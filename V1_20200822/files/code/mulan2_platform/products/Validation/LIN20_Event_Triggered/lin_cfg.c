/*
 * LIN Configuration API
 *
 * This file is application specific and depends on LDF/NCF files
 * Generated by configuration tool C:\EVWS\_LIBRARY_PLATFORMS\library_platform_mulan2\bin\ldf_nodegen.exe (version 1.4.0)
 *
 * Copyright (C) 2007-2015 Melexis N.V.
 */

#include "lin_api.h"

/* 
 * ----------------------------------------------------------------------------
 *              LIN configuration
 * ----------------------------------------------------------------------------
 */
/* Baudrate, see lin_cfg.h */
/* Node Address for/by Diagnostics */
const ml_uint8 ml_InitialNAD	= 0x31U; /* Node Address for Diagnostics	 */
ml_uint8 ml_ConfiguredNAD	= 0x31U;

/*--- LIN Product Identification --------------------------------------*/
const ml_uint8 ml_ProductID[5] __attribute__((aligned(2)))	= {
  0xfeU,	 /* SupplierID LSB */
  0x5aU,	 /* SupplierID MSB */
  0x00U,	 /* FunctionID LSB */
  0x10U,	 /* FunctionID MSB */
  0x01U	 /* VariantID */
};


#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
/*-----node configuration, stores PIDs corresponding to indices ----*/
l_u8 node_configuration[ML_NUMBER_OF_DYNAMIC_MESSAGES]; 

/*
 ********************************************************************************
 * ld_read_configuration_i1, ld_set_configuration_i1
 *
 * "data" will store node configuration
 *
 * "length" should be ML_NUMBER_OF_DYNAMIC_MESSAGES+1
 ********************************************************************************
 */

l_u8 ld_read_configuration_i1 (l_u8 data[], l_u8* const length)
{
    uint_fast8_t i; /* iterator */

    if (*length < (ML_NUMBER_OF_DYNAMIC_MESSAGES + 1U))
    {
        /* returns proper length to the application */
        *length = ML_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
        return (l_u8)LD_LENGTH_TOO_SHORT;
    }
    data[0] = ml_ConfiguredNAD;

    /* other data filled in by assignFrameIdRange */

    for (i = 0U; i < ML_NUMBER_OF_DYNAMIC_MESSAGES; i++)
    {
        data[i+1U] = node_configuration[i];
    }

    /* returns actual length to the application */
    *length = ML_NUMBER_OF_DYNAMIC_MESSAGES + 1U;
    return (l_u8)LD_READ_OK;
}


l_u8 ld_set_configuration_i1 (const l_u8 data[], l_u16 length)
{
    uint_fast8_t i; /* iterator */

    if ((ML_NUMBER_OF_DYNAMIC_MESSAGES + 1U) != length)
    {
        return (l_u8)LD_LENGTH_NOT_CORRECT;
    }
    /* else: length is Ok, continue processing .. */


    for (i = 0U; i < ML_NUMBER_OF_DYNAMIC_MESSAGES; i++)
    {
        if (data[i+1U] == 0U)   /* unassign this message index */
        {
            (void)ml_Disconnect();
            if (ml_DisableMessage((ml_MessageID)i) != 0U)
            {
                (void)ml_Connect();
                return (l_u8)LD_DATA_ERROR;
            }
            (void)ml_Connect();
        }
        else if (data[i+1U] != 0xFFU)    /* 0xFF is "don't care" value */
        {
            (void)ml_Disconnect();
            if (ml_AssignFrameToMessageID((ml_MessageID)i, data[i+1U]) != 0U)
            {
                (void)ml_Connect();
                return (l_u8)LD_DATA_ERROR; /* configuration could not be set */
            }
            (void)ml_Connect();
        }
        else {
            /* no other special id, continue processing .. */
        }
    }

    /* if no return occurred, new configuration can be stored, otherwise the previous one remains */
    for (i = 0U; i < ML_NUMBER_OF_DYNAMIC_MESSAGES; i++)
    {
        node_configuration[i] = data[i+1U];

#if defined (HAS_EVENT_TRIGGERED_FRAMES)
         /*
          * For Associated Unconditional Frames put PID as a first
          * data in the data buffer
          */ 
          if (ML_UNCOND_ASSOCIATED == frame_list[i].frame_type) {
              l_u8 volatile *frame_buffer = frame_list[i].dataBuffer;
              *frame_buffer = data[i+1U]; /* pid */
          }
          /* else: it is not unconditional frame */
#endif /* HAS_EVENT_TRIGGERED_FRAMES */        
    }
    
    ml_ConfiguredNAD = data[0];
#if defined(HAS_SET_LOADER_NAD)
    (void)ml_SetLoaderNAD(ml_ConfiguredNAD);   /* notify the loader about application's NAD */
#endif /* HAS_SET_LOADER_NAD */

    return (l_u8)LD_SET_OK;
}

#endif /* HAS_SAVE_CONFIGURATION_SERVICE */

/* EOF */
