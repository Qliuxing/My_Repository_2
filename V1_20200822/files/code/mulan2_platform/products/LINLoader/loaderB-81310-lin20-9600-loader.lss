mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


loaderB-81310-lin20-9600-loader.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00008000  00008000  000001f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00009540  00009540  000016e4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000016  0000bf68  0000bf68  00002d16  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00002c86  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  00002d14  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  00002d0e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .app_version  00000004  0000bf58  0000bf58  00002d06  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .pltf_version 00000004  0000bf5c  0000bf5c  00002d0a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .ramfunc      0000001e  00000740  000095c8  0000176c  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text         000014f6  000095e8  000095e8  0000178c  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 10 .shared_ram   00000010  00000000  00000000  00002d2c  2**0
                  CONTENTS, READONLY
 11 .ram_lin_fixed 00000006  00000010  00000010  000001f4  2**1
                  ALLOC
 12 .dp           00000020  00000018  0000aade  00002c82  2**1
                  ALLOC
 13 .data         00000004  00000038  0000aade  00002c82  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 14 .bss          00000006  0000003c  0000aae2  00002c86  2**1
                  ALLOC
 15 .bist_stat    00000008  00000042  0000aae2  00002c86  2**1
                  ALLOC
 16 .debug_abbrev 000012bb  00000000  00000000  00002d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_info   00002f2b  00000000  00000000  00003ff7  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_line   0000302f  00000000  00000000  00006f22  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_frame  0000072c  00000000  00000000  00009f52  2**1
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_pubnames 000005de  00000000  00000000  0000a67e  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_aranges 00000234  00000000  00000000  0000ac5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_str    0000119c  00000000  00000000  0000ae90  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .comment      00000011  00000000  00000000  0000c02c  2**0
                  CONTENTS, READONLY

Disassembly of section .mlx4_flash:

00008000 <__mlx4_flash_start>:
    8000:	a55a      	or	A, dp:0x5a <__bist_stat_end+0x10>
    8002:	5aa5      	mov	io:0x25 <_ml_driver_mode+0x1>, Y
    8004:	0000      	nop
    8006:	0000      	nop
    8008:	2442      	or	X, #66
    800a:	2442      	or	X, #66
    800c:	243f      	or	X, #63
    800e:	243f      	or	X, #63
    8010:	0000      	nop
    8012:	0000      	nop
    8014:	0000      	nop
    8016:	0000      	nop
    8018:	4100      	mov	dp:0x0 <__data_dp_size>, AL
    801a:	2000      	add	X, #0
    801c:	0000      	nop
    801e:	0000      	nop
    8020:	01e0      	jmp	0x83e2 <__mlx4_flash_start+0x3e2>
    8022:	0003      	jmp	0x802a <__mlx4_flash_start+0x2a>
    8024:	0005      	jmp	0x8030 <__mlx4_flash_start+0x30>
    8026:	0000      	nop
    8028:	4233      	mov	[S-52], AL
    802a:	5f50      	mov	ep:0x50 <__bist_stat_end+0x6>, X
    802c:	7c6d      	lod	X, #109
    802e:	998a      	subc	AL, dp:0x8a <__bist_stat_end+0x40>
    8030:	140e      	call	0x784e <__io__+0x504e>
    8032:	201a      	add	X, #26
    8034:	2c26      	cmp	X, #38
    8036:	3832      	subc	X, #50
    8038:	0208      	jmp	0x844a <__mlx4_flash_start+0x44a>
    803a:	af52      	cmp	A, ep:0x52 <__bist_stat_end+0x8>
    803c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    803e:	ff35      	xor	Y, ep:0x35 <_ml_driver_mode+0x11>
    8040:	e0e0      	add	Y, #-32
    8042:	dba6      	subc	AH, ep:0xa6 <__bist_stat_end+0x5c>
    8044:	0000      	nop
    8046:	0200      	jmp	0x8448 <__mlx4_flash_start+0x448>
    8048:	7da0      	lod	X, dp:0xa0 <__bist_stat_end+0x56>
    804a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    804c:	39e4      	subc	X, dp:0xe4 <__bist_stat_end+0x9a>
    804e:	934e      	adc	AL, ep:0x4e <__bist_stat_end+0x4>
    8050:	d3e0      	adc	AH, ep:0xe0 <__bist_stat_end+0x96>
    8052:	a497      	or	A, #-105
    8054:	2c1f      	cmp	X, #31
    8056:	5b68      	mov	ep:0x68 <__bist_stat_end+0x1e>, Y
    8058:	a81f      	sub	A, #31
    805a:	b47f      	and	A, #127
    805c:	00b2      	jmp	0x81c2 <__mlx4_flash_start+0x1c2>
    805e:	7c50      	lod	X, #80
    8060:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    8062:	773a      	lod	PC, ep:0x3a <_LINBaud>
    8064:	b78e      	and	A, ep:0x8e <__bist_stat_end+0x44>
    8066:	773b      	lod	PC, ep:0x3b <_LINBaud+0x1>
    8068:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    806a:	34e9      	and	X, #-23
    806c:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    806e:	b76f      	and	A, ep:0x6f <__bist_stat_end+0x25>
    8070:	773f      	lod	PC, ep:0x3f <_page_buffer+0x1>
    8072:	4c02 b203 	add	D, #-1291603453
    8076:	b303 
    8078:	8684      	or	AL, io:0x4 <__data_size>
    807a:	7203      	lod	A, [S-4]
    807c:	4c03      	add	D, ??
    807e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    8080:	380e      	subc	X, #14
    8082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    8084:	320a      	adc	X, [S-11]
    8086:	340a      	and	X, #10
    8088:	3eac      	xor	X, io:0x2c <_ml_driver_mode+0x8>
    808a:	3b16      	subc	X, ep:0x16 <_stFixedRamNAD+0x6>
    808c:	3730      	and	X, ep:0x30 <_ml_driver_mode+0xc>
    808e:	6193      	lod	AL, dp:0x93 <__bist_stat_end+0x49>
    8090:	b680      	and	A, io:0x0 <__data_dp_size>
    8092:	7273      	lod	A, [S-116]
    8094:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    8098:	7239      	lod	A, [S-58]
    809a:	726f      	lod	A, [S-112]
    809c:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    809e:	714c      	lod	A, dp:0x4c <__bist_stat_end+0x2>
    80a0:	b588      	and	A, dp:0x88 <__bist_stat_end+0x3e>
    80a2:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    80a4:	0000      	nop
    80a6:	0000      	nop
    80a8:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    80aa:	320a      	adc	X, [S-11]
    80ac:	580a      	inc	S, #11
    80ae:	0901      	clrb	io:0x00.1
    80b0:	2080      	add	X, #-128
    80b2:	623a      	lod	AL, [S-59]
    80b4:	7270      	lod	A, [S-113]
    80b6:	b637      	and	A, [S-56]
    80b8:	b373      	adc	A, ep:0x73 <__bist_stat_end+0x29>
    80ba:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    80bc:	e783      	or	Y, ep:0x83 <__bist_stat_end+0x39>
    80be:	1101      	call	0x82c2 <__mlx4_flash_start+0x2c2>
    80c0:	20b7      	add	X, #-73
    80c2:	6c03      	lod	YH, #3
    80c4:	206e      	add	X, #110
    80c6:	2066      	add	X, #102
    80c8:	2073      	add	X, #115
    80ca:	2050      	add	X, #80
    80cc:	e680      	or	Y, io:0x0 <__data_dp_size>
    80ce:	1102      	call	0x82d4 <__mlx4_flash_start+0x2d4>
    80d0:	b782      	and	A, ep:0x82 <__bist_stat_end+0x38>
    80d2:	207a      	add	X, #122
    80d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    80d6:	110b      	call	0x82ee <__mlx4_flash_start+0x2ee>
    80d8:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    80da:	207a      	add	X, #122
    80dc:	b270      	adc	A, [S-113]
    80de:	a688      	or	A, io:0x8 <__bist_stat_size>
    80e0:	1106      	call	0x82ee <__mlx4_flash_start+0x2ee>
    80e2:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    80e4:	207a      	add	X, #122
    80e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    80e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    80ea:	1101      	call	0x82ee <__mlx4_flash_start+0x2ee>
    80ec:	207c      	add	X, #124
    80ee:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    80f0:	7373      	lod	A, ep:0x73 <__bist_stat_end+0x29>
    80f2:	2050      	add	X, #80
    80f4:	7373      	lod	A, ep:0x73 <__bist_stat_end+0x29>
    80f6:	2056      	add	X, #86
    80f8:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    80fa:	7373      	lod	A, ep:0x73 <__bist_stat_end+0x29>
    80fc:	3cc3      	xor	X, #-61
    80fe:	2050      	add	X, #80
    8100:	b384      	adc	A, ep:0x84 <__bist_stat_end+0x3a>
    8102:	b285      	adc	A, io:0x5 <__data_size+0x1>
    8104:	7380      	lod	A, ep:0x80 <__bist_stat_end+0x36>
    8106:	7334      	lod	A, ep:0x34 <_ml_driver_mode+0x10>
    8108:	7235      	lod	A, [S-54]
    810a:	7ca7      	lod	X, #-89
    810c:	7d34      	lod	X, dp:0x34 <_ml_driver_mode+0x10>
    810e:	6c03      	lod	YH, #3
    8110:	20b1      	add	X, #-79
    8112:	20ad      	add	X, #-83
    8114:	20b3      	add	X, #-77
    8116:	20b3      	add	X, #-77
    8118:	20b3      	add	X, #-77
    811a:	20a1      	add	X, #-95
    811c:	20b3      	add	X, #-77
    811e:	20b3      	add	X, #-77
    8120:	20b3      	add	X, #-77
    8122:	20b3      	add	X, #-77
    8124:	20b3      	add	X, #-77
    8126:	20b3      	add	X, #-77
    8128:	20b3      	add	X, #-77
    812a:	20b3      	add	X, #-77
    812c:	20b3      	add	X, #-77
    812e:	2098      	add	X, #-104
    8130:	a682      	or	A, io:0x2 <_LinCmnd>
    8132:	1106      	call	0x8340 <__mlx4_flash_start+0x340>
    8134:	b35f      	adc	A, ep:0x5f <__bist_stat_end+0x15>
    8136:	bf8e      	xor	A, ep:0x8e <__bist_stat_end+0x44>
    8138:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    813a:	0101      	jmp	0x833e <__mlx4_flash_start+0x33e>
    813c:	f781      	and	Y, ep:0x81 <__bist_stat_end+0x37>
    813e:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    8140:	20b1      	add	X, #-79
    8142:	e682      	or	Y, io:0x2 <_LinCmnd>
    8144:	110d      	call	0x8360 <__mlx4_flash_start+0x360>
    8146:	b286      	adc	A, io:0x6 <__bss_size>
    8148:	b35f      	adc	A, ep:0x5f <__bist_stat_end+0x15>
    814a:	f782      	and	Y, ep:0x82 <__bist_stat_end+0x38>
    814c:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    814e:	0103      	jmp	0x8356 <__mlx4_flash_start+0x356>
    8150:	bf8d      	xor	A, ep:0x8d <__bist_stat_end+0x43>
    8152:	b680      	and	A, io:0x0 <__data_dp_size>
    8154:	7273      	lod	A, [S-116]
    8156:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    8158:	20b1      	add	X, #-79
    815a:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    815c:	1101      	call	0x8360 <__mlx4_flash_start+0x360>
    815e:	245d      	or	X, #93
    8160:	20b3      	add	X, #-77
    8162:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8164:	20b4      	add	X, #-76
    8166:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8168:	7381      	lod	A, ep:0x81 <__bist_stat_end+0x37>
    816a:	5404      	ret	#5
    816c:	2056      	add	X, #86
    816e:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    8170:	1104      	call	0x837a <__mlx4_flash_start+0x37a>
    8172:	b270      	adc	A, [S-113]
    8174:	a688      	or	A, io:0x8 <__bist_stat_size>
    8176:	1105      	call	0x8382 <__mlx4_flash_start+0x382>
    8178:	2048      	add	X, #72
    817a:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    817c:	622e      	lod	AL, [S-47]
    817e:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8180:	0101      	jmp	0x8384 <__mlx4_flash_start+0x384>
    8182:	2056      	add	X, #86
    8184:	b139      	adc	A, dp:0x39 <__bss_dp_end+0x1>
    8186:	e14c      	add	Y, dp:0x4c <__bist_stat_end+0x2>
    8188:	1101      	call	0x838c <__mlx4_flash_start+0x38c>
    818a:	20e4      	add	X, #-28
    818c:	4592      	mov	dp:0x92 <__bist_stat_end+0x48>, YL
    818e:	76e5      	jmp	MH
    8190:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8192:	77e5      	lod	PC, ep:0xe5 <__bist_stat_end+0x9b>
    8194:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8196:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8198:	7139      	lod	A, dp:0x39 <__bss_dp_end+0x1>
    819a:	6198      	lod	AL, dp:0x98 <__bist_stat_end+0x4e>
    819c:	e581      	or	Y, dp:0x81 <__bist_stat_end+0x37>
    819e:	110b      	call	0x83b6 <__mlx4_flash_start+0x3b6>
    81a0:	7cd5      	lod	X, #-43
    81a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    81a4:	b208      	adc	A, [S-9]
    81a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    81a8:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    81aa:	a783      	or	A, ep:0x83 <__bist_stat_end+0x39>
    81ac:	1105      	call	0x83b8 <__mlx4_flash_start+0x3b8>
    81ae:	bf8c      	xor	A, ep:0x8c <__bist_stat_end+0x42>
    81b0:	f373      	adc	Y, ep:0x73 <__bist_stat_end+0x29>
    81b2:	7373      	lod	A, ep:0x73 <__bist_stat_end+0x29>
    81b4:	724c      	lod	A, [S-77]
    81b6:	2050      	add	X, #80
    81b8:	7271      	lod	A, [S-114]
    81ba:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    81bc:	e781      	or	Y, ep:0x81 <__bist_stat_end+0x37>
    81be:	0102      	jmp	0x83c4 <__mlx4_flash_start+0x3c4>
    81c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    81c2:	20da      	add	X, #-38
    81c4:	b686      	and	A, io:0x6 <__bss_size>
    81c6:	20da      	add	X, #-38
    81c8:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    81ca:	300a      	adc	X, #10
    81cc:	6198      	lod	AL, dp:0x98 <__bist_stat_end+0x4e>
    81ce:	ef80      	cmp	Y, ep:0x80 <__bist_stat_end+0x36>
    81d0:	0103      	jmp	0x83d8 <__mlx4_flash_start+0x3d8>
    81d2:	b684      	and	A, io:0x4 <__data_size>
    81d4:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    81d6:	2030      	add	X, #48
    81d8:	b24e      	adc	A, [S-79]
    81da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    81dc:	724e      	lod	A, [S-79]
    81de:	6c02      	lod	YH, #2
    81e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    81e2:	20f4      	add	X, #-12
    81e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    81e6:	2100      	add	X, dp:0x0 <__data_dp_size>
    81e8:	b78b      	and	A, ep:0x8b <__bist_stat_end+0x41>
    81ea:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    81ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    81ee:	61ae      	lod	AL, dp:0xae <__bist_stat_end+0x64>
    81f0:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    81f2:	61b7      	lod	AL, dp:0xb7 <__bist_stat_end+0x6d>
    81f4:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    81f6:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    81f8:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    81fa:	61ae      	lod	AL, dp:0xae <__bist_stat_end+0x64>
    81fc:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    81fe:	2110      	add	X, dp:0x10 <_stFixedRamNAD>
    8200:	b682      	and	A, io:0x2 <_LinCmnd>
    8202:	724e      	lod	A, [S-79]
    8204:	b78d      	and	A, ep:0x8d <__bist_stat_end+0x43>
    8206:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8208:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    820a:	61ae      	lod	AL, dp:0xae <__bist_stat_end+0x64>
    820c:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    820e:	2110      	add	X, dp:0x10 <_stFixedRamNAD>
    8210:	b24c      	adc	A, [S-77]
    8212:	7271      	lod	A, [S-114]
    8214:	b78b      	and	A, ep:0x8b <__bist_stat_end+0x41>
    8216:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    8218:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    821a:	61ae      	lod	AL, dp:0xae <__bist_stat_end+0x64>
    821c:	b785      	and	A, ep:0x85 <__bist_stat_end+0x3b>
    821e:	61b7      	lod	AL, dp:0xb7 <__bist_stat_end+0x6d>
    8220:	b24e      	adc	A, [S-79]
    8222:	b171      	adc	A, dp:0x71 <__bist_stat_end+0x27>
    8224:	61bb      	lod	AL, dp:0xbb <__bist_stat_end+0x71>
    8226:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    8228:	b56d      	and	A, dp:0x6d <__bist_stat_end+0x23>
    822a:	b685      	and	A, io:0x5 <__data_size+0x1>
    822c:	b66e      	and	A, [S-111]
    822e:	61bb      	lod	AL, dp:0xbb <__bist_stat_end+0x71>
    8230:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8232:	b680      	and	A, io:0x0 <__data_dp_size>
    8234:	738b      	lod	A, ep:0x8b <__bist_stat_end+0x41>
    8236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    8238:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    823a:	7388      	lod	A, ep:0x88 <__bist_stat_end+0x3e>
    823c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    823e:	5408      	ret	#9
    8240:	b273      	adc	A, [S-116]
    8242:	a688      	or	A, io:0x8 <__bist_stat_size>
    8244:	1109      	call	0x8458 <__mlx4_flash_start+0x458>
    8246:	b24e      	adc	A, [S-79]
    8248:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    824a:	0103      	jmp	0x8452 <__mlx4_flash_start+0x452>
    824c:	b15f      	adc	A, dp:0x5f <__bist_stat_end+0x15>
    824e:	a582      	or	A, dp:0x82 <__bist_stat_end+0x38>
    8250:	0102      	jmp	0x8456 <__mlx4_flash_start+0x456>
    8252:	b680      	and	A, io:0x0 <__data_dp_size>
    8254:	204a      	add	X, #74
    8256:	2048      	add	X, #72
    8258:	3806      	subc	X, #6
    825a:	380e      	subc	X, #14
    825c:	580c      	inc	S, #13
    825e:	0807      	clrb	dp:0x00.7
    8260:	62e6      	lod	AL, Y
    8262:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8264:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8266:	1108      	call	0x8478 <__mlx4_flash_start+0x478>
    8268:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    826a:	1105      	call	0x8476 <__mlx4_flash_start+0x476>
    826c:	212e      	add	X, dp:0x2e <_ml_driver_mode+0xa>
    826e:	623a      	lod	AL, [S-59]
    8270:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    8272:	1101      	call	0x8476 <__mlx4_flash_start+0x476>
    8274:	212e      	add	X, dp:0x2e <_ml_driver_mode+0xa>
    8276:	2030      	add	X, #48
    8278:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    827a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    827c:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    827e:	6223      	lod	AL, [S-36]
    8280:	6198      	lod	AL, dp:0x98 <__bist_stat_end+0x4e>
    8282:	b208      	adc	A, [S-9]
    8284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    8286:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    8288:	6c03      	lod	YH, #3
    828a:	2155      	add	X, dp:0x55 <__bist_stat_end+0xb>
    828c:	214a      	add	X, dp:0x4a <__bist_stat_end>
    828e:	b688      	and	A, io:0x8 <__bist_stat_size>
    8290:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8292:	215a      	add	X, dp:0x5a <__bist_stat_end+0x10>
    8294:	b586      	and	A, dp:0x86 <__bist_stat_end+0x3c>
    8296:	61a8      	lod	AL, dp:0xa8 <__bist_stat_end+0x5e>
    8298:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    829a:	b6e5      	and	A, MH
    829c:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    829e:	b7e5      	and	A, ep:0xe5 <__bist_stat_end+0x9b>
    82a0:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    82a2:	76e5      	jmp	MH
    82a4:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    82a6:	77e5      	lod	PC, ep:0xe5 <__bist_stat_end+0x9b>
    82a8:	b686      	and	A, io:0x6 <__bss_size>
    82aa:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    82ac:	61a8      	lod	AL, dp:0xa8 <__bist_stat_end+0x5e>
    82ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    82b0:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    82b2:	3e10      	xor	X, [S-17]
    82b4:	724c      	lod	A, [S-77]
    82b6:	7139      	lod	A, dp:0x39 <__bss_dp_end+0x1>
    82b8:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    82ba:	34c0      	and	X, #-64
    82bc:	623a      	lod	AL, [S-59]
    82be:	38b7      	subc	X, #-73
    82c0:	357b      	and	X, dp:0x7b <__bist_stat_end+0x31>
    82c2:	3663      	and	X, [S-100]
    82c4:	7cd3      	lod	X, #-45
    82c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    82c8:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    82ca:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    82cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    82ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    82d0:	b208      	adc	A, [S-9]
    82d2:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    82d4:	4616      	mov	[S-23], YL
    82d6:	3561      	and	X, dp:0x61 <__bist_stat_end+0x17>
    82d8:	7208      	lod	A, [S-9]
    82da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    82dc:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    82de:	0103      	jmp	0x84e6 <__mlx4_flash_start+0x4e6>
    82e0:	b272      	adc	A, [S-115]
    82e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    82e4:	010a      	jmp	0x84fa <__mlx4_flash_start+0x4fa>
    82e6:	4500      	mov	dp:0x0 <__data_dp_size>, YL
    82e8:	4584      	mov	dp:0x84 <__bist_stat_end+0x3a>, YL
    82ea:	8582      	or	AL, dp:0x82 <__bist_stat_end+0x38>
    82ec:	5802      	inc	S, #3
    82ee:	b739      	and	A, ep:0x39 <__bss_dp_end+0x1>
    82f0:	b638      	and	A, [S-57]
    82f2:	7272      	lod	A, [S-115]
    82f4:	b737      	and	A, ep:0x37 <_ml_driver_mode+0x13>
    82f6:	0004      	jmp	0x8300 <__mlx4_flash_start+0x300>
    82f8:	2167      	add	X, dp:0x67 <__bist_stat_end+0x1d>
    82fa:	b685      	and	A, io:0x5 <__data_size+0x1>
    82fc:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    82fe:	2047      	add	X, #71
    8300:	6217      	lod	AL, [S-24]
    8302:	0007      	jmp	0x8312 <__mlx4_flash_start+0x312>
    8304:	1102      	call	0x850a <__mlx4_flash_start+0x50a>
    8306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    8308:	7209      	lod	A, [S-10]
    830a:	b208      	adc	A, [S-9]
    830c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    830e:	6198      	lod	AL, dp:0x98 <__bist_stat_end+0x4e>
    8310:	2165      	add	X, dp:0x65 <__bist_stat_end+0x1b>
    8312:	b16f      	adc	A, dp:0x6f <__bist_stat_end+0x25>
    8314:	bd83      	xor	A, dp:0x83 <__bist_stat_end+0x39>
    8316:	716f      	lod	A, dp:0x6f <__bist_stat_end+0x25>
    8318:	b15f      	adc	A, dp:0x5f <__bist_stat_end+0x15>
    831a:	a582      	or	A, dp:0x82 <__bist_stat_end+0x38>
    831c:	1101      	call	0x8520 <__mlx4_flash_start+0x520>
    831e:	2030      	add	X, #48
    8320:	b785      	and	A, ep:0x85 <__bist_stat_end+0x3b>
    8322:	62d2      	lod	AL, [A++]
    8324:	212e      	add	X, dp:0x2e <_ml_driver_mode+0xa>
    8326:	38b7      	subc	X, #-73
    8328:	3e18      	xor	X, [S-25]
    832a:	357b      	and	X, dp:0x7b <__bist_stat_end+0x31>
    832c:	367b      	and	X, [S-124]
    832e:	6800      	lod	AH, #0
    8330:	7370      	lod	A, ep:0x70 <__bist_stat_end+0x26>
    8332:	b792      	and	A, ep:0x92 <__bist_stat_end+0x48>
    8334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    8336:	b20a      	adc	A, [S-11]
    8338:	d667      	and	AH, [S-104]
    833a:	720b      	lod	A, [S-12]
    833c:	b76b      	and	A, ep:0x6b <__bist_stat_end+0x21>
    833e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    8340:	b370      	adc	A, ep:0x70 <__bist_stat_end+0x26>
    8342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    8344:	b20a      	adc	A, [S-11]
    8346:	d667      	and	AH, [S-104]
    8348:	720b      	lod	A, [S-12]
    834a:	b76b      	and	A, ep:0x6b <__bist_stat_end+0x21>
    834c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    834e:	6800      	lod	AH, #0
    8350:	b7e5      	and	A, ep:0xe5 <__bist_stat_end+0x9b>
    8352:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8354:	e78f      	or	Y, ep:0x8f <__bist_stat_end+0x45>
    8356:	b7e5      	and	A, ep:0xe5 <__bist_stat_end+0x9b>
    8358:	ef87      	cmp	Y, ep:0x87 <__bist_stat_end+0x3d>
    835a:	6800      	lod	AH, #0
    835c:	7270      	lod	A, [S-113]
    835e:	b6e7      	and	A, R
    8360:	8791      	or	AL, ep:0x91 <__bist_stat_end+0x47>
    8362:	76e7      	jmp	R
    8364:	c791      	or	AH, ep:0x91 <__bist_stat_end+0x47>
    8366:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    8368:	e370      	add	Y, ep:0x70 <__bist_stat_end+0x26>
    836a:	0109      	jmp	0x857e <__mlx4_flash_start+0x57e>
    836c:	21af      	add	X, dp:0xaf <__bist_stat_end+0x65>
    836e:	b587      	and	A, dp:0x87 <__bist_stat_end+0x3d>
    8370:	b66d      	and	A, [S-110]
    8372:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8374:	b56d      	and	A, dp:0x6d <__bist_stat_end+0x23>
    8376:	76e7      	jmp	R
    8378:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    837a:	75e7      	lod	PC, dp:0xe7 <__bist_stat_end+0x9d>
    837c:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    837e:	6800      	lod	AH, #0
    8380:	b140      	adc	A, dp:0x40 <_page_buffer+0x2>
    8382:	814e      	add	AL, dp:0x4e <__bist_stat_end+0x4>
    8384:	7140      	lod	A, dp:0x40 <_page_buffer+0x2>
    8386:	b141      	adc	A, dp:0x41 <_page_buffer+0x3>
    8388:	894f      	sub	AL, dp:0x4f <__bist_stat_end+0x5>
    838a:	7141      	lod	A, dp:0x41 <_page_buffer+0x3>
    838c:	b142      	adc	A, dp:0x42 <__bss_end>
    838e:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    8390:	7142      	lod	A, dp:0x42 <__bss_end>
    8392:	b143      	adc	A, dp:0x43 <__bss_end+0x1>
    8394:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    8396:	7143      	lod	A, dp:0x43 <__bss_end+0x1>
    8398:	b144      	adc	A, dp:0x44 <_bistResetInfo>
    839a:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    839c:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    839e:	6800      	lod	AH, #0
    83a0:	b154      	adc	A, dp:0x54 <__bist_stat_end+0xa>
    83a2:	814e      	add	AL, dp:0x4e <__bist_stat_end+0x4>
    83a4:	7154      	lod	A, dp:0x54 <__bist_stat_end+0xa>
    83a6:	b155      	adc	A, dp:0x55 <__bist_stat_end+0xb>
    83a8:	894f      	sub	AL, dp:0x4f <__bist_stat_end+0x5>
    83aa:	7155      	lod	A, dp:0x55 <__bist_stat_end+0xb>
    83ac:	b156      	adc	A, dp:0x56 <__bist_stat_end+0xc>
    83ae:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    83b0:	7156      	lod	A, dp:0x56 <__bist_stat_end+0xc>
    83b2:	b157      	adc	A, dp:0x57 <__bist_stat_end+0xd>
    83b4:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    83b6:	7157      	lod	A, dp:0x57 <__bist_stat_end+0xd>
    83b8:	6800      	lod	AH, #0
    83ba:	b34e      	adc	A, ep:0x4e <__bist_stat_end+0x4>
    83bc:	b24f      	adc	A, [S-80]
    83be:	b15a      	adc	A, dp:0x5a <__bist_stat_end+0x10>
    83c0:	e349      	add	Y, ep:0x49 <_bistErrorInfo+0x1>
    83c2:	ea4a      	sub	Y, [S-75]
    83c4:	e94b      	sub	Y, dp:0x4b <__bist_stat_end+0x1>
    83c6:	1003      	call	0x83ce <__mlx4_flash_start+0x3ce>
    83c8:	7349      	lod	A, ep:0x49 <_bistErrorInfo+0x1>
    83ca:	724a      	lod	A, [S-75]
    83cc:	714b      	lod	A, dp:0x4b <__bist_stat_end+0x1>
    83ce:	e346      	add	Y, ep:0x46 <_bistError>
    83d0:	ea47      	sub	Y, [S-72]
    83d2:	e948      	sub	Y, dp:0x48 <_bistErrorInfo>
    83d4:	0003      	jmp	0x83dc <__mlx4_flash_start+0x3dc>
    83d6:	7346      	lod	A, ep:0x46 <_bistError>
    83d8:	7247      	lod	A, [S-72]
    83da:	7148      	lod	A, dp:0x48 <_bistErrorInfo>
    83dc:	e684      	or	Y, io:0x4 <__data_size>
    83de:	ed80      	cmp	Y, dp:0x80 <__bist_stat_end+0x36>
    83e0:	0009      	jmp	0x83f4 <__mlx4_flash_start+0x3f4>
    83e2:	8350      	add	AL, ep:0x50 <__bist_stat_end+0x6>
    83e4:	8a51      	sub	AL, [S-82]
    83e6:	8952      	sub	AL, dp:0x52 <__bist_stat_end+0x8>
    83e8:	7350      	lod	A, ep:0x50 <__bist_stat_end+0x6>
    83ea:	7251      	lod	A, [S-82]
    83ec:	7152      	lod	A, dp:0x52 <__bist_stat_end+0x8>
    83ee:	b353      	adc	A, ep:0x53 <__bist_stat_end+0x9>
    83f0:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    83f2:	7353      	lod	A, ep:0x53 <__bist_stat_end+0x9>
    83f4:	6800      	lod	AH, #0
    83f6:	b157      	adc	A, dp:0x57 <__bist_stat_end+0xd>
    83f8:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    83fa:	7157      	lod	A, dp:0x57 <__bist_stat_end+0xd>
    83fc:	b156      	adc	A, dp:0x56 <__bist_stat_end+0xc>
    83fe:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8400:	7156      	lod	A, dp:0x56 <__bist_stat_end+0xc>
    8402:	b155      	adc	A, dp:0x55 <__bist_stat_end+0xb>
    8404:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8406:	7155      	lod	A, dp:0x55 <__bist_stat_end+0xb>
    8408:	b154      	adc	A, dp:0x54 <__bist_stat_end+0xa>
    840a:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    840c:	7154      	lod	A, dp:0x54 <__bist_stat_end+0xa>
    840e:	b144      	adc	A, dp:0x44 <_bistResetInfo>
    8410:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8412:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    8414:	b143      	adc	A, dp:0x43 <__bss_end+0x1>
    8416:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8418:	7143      	lod	A, dp:0x43 <__bss_end+0x1>
    841a:	b142      	adc	A, dp:0x42 <__bss_end>
    841c:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    841e:	7142      	lod	A, dp:0x42 <__bss_end>
    8420:	b141      	adc	A, dp:0x41 <_page_buffer+0x3>
    8422:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8424:	7141      	lod	A, dp:0x41 <_page_buffer+0x3>
    8426:	b140      	adc	A, dp:0x40 <_page_buffer+0x2>
    8428:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    842a:	7140      	lod	A, dp:0x40 <_page_buffer+0x2>
    842c:	6800      	lod	AH, #0
    842e:	b139      	adc	A, dp:0x39 <__bss_dp_end+0x1>
    8430:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8432:	7139      	lod	A, dp:0x39 <__bss_dp_end+0x1>
    8434:	e14c      	add	Y, dp:0x4c <__bist_stat_end+0x2>
    8436:	0006      	jmp	0x8444 <__mlx4_flash_start+0x444>
    8438:	0102      	jmp	0x863e <__mlx4_flash_start+0x63e>
    843a:	4050      	jmp	fp2:0x80
    843c:	222a      	add	X, [S-43]
    843e:	b20a      	adc	A, [S-11]
    8440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    8442:	2226      	add	X, [S-39]
    8444:	4592      	mov	dp:0x92 <__bist_stat_end+0x48>, YL
    8446:	b6e5      	and	A, MH
    8448:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    844a:	b7e5      	and	A, ep:0xe5 <__bist_stat_end+0x9b>
    844c:	7234      	lod	A, [S-53]
    844e:	7335      	lod	A, ep:0x35 <_ml_driver_mode+0x11>
    8450:	7208      	lod	A, [S-9]
    8452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    8454:	6800      	lod	AH, #0
    8456:	3e60      	xor	X, [S-97]
    8458:	3e90      	xor	X, io:0x10 <_stFixedRamNAD>
    845a:	6800      	lod	AH, #0
    845c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    845e:	b208      	adc	A, [S-9]
    8460:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8462:	4616      	mov	[S-23], YL
    8464:	2228      	add	X, [S-41]
    8466:	820a      	add	AL, [S-11]
    8468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    846a:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    846c:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    846e:	720a      	lod	A, [S-11]
    8470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    8472:	6800      	lod	AH, #0
    8474:	b739      	and	A, ep:0x39 <__bss_dp_end+0x1>
    8476:	b638      	and	A, [S-57]
    8478:	6800      	lod	AH, #0
    847a:	b53e      	and	A, dp:0x3e <_page_buffer>
    847c:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    847e:	753e      	lod	PC, dp:0x3e <_page_buffer>
    8480:	6800      	lod	AH, #0
    8482:	b330      	adc	A, ep:0x30 <_ml_driver_mode+0xc>
    8484:	b231      	adc	A, [S-50]
    8486:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8488:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    848a:	7330      	lod	A, ep:0x30 <_ml_driver_mode+0xc>
    848c:	7231      	lod	A, [S-50]
    848e:	e336      	add	Y, ep:0x36 <_ml_driver_mode+0x12>
    8490:	ea37      	sub	Y, [S-56]
    8492:	6800      	lod	AH, #0
    8494:	0009      	jmp	0x84a8 <__mlx4_flash_start+0x4a8>
    8496:	b340      	adc	A, ep:0x40 <_page_buffer+0x2>
    8498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    849a:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    849c:	b341      	adc	A, ep:0x41 <_page_buffer+0x3>
    849e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    84a0:	7341      	lod	A, ep:0x41 <_page_buffer+0x3>
    84a2:	b342      	adc	A, ep:0x42 <__bss_end>
    84a4:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    84a6:	2257      	add	X, [S-88]
    84a8:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    84aa:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    84ac:	7341      	lod	A, ep:0x41 <_page_buffer+0x3>
    84ae:	7342      	lod	A, ep:0x42 <__bss_end>
    84b0:	6800      	lod	AH, #0
    84b2:	b354      	adc	A, ep:0x54 <__bist_stat_end+0xa>
    84b4:	b255      	adc	A, [S-86]
    84b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    84b8:	8a03      	sub	AL, [S-4]
    84ba:	7354      	lod	A, ep:0x54 <__bist_stat_end+0xa>
    84bc:	7255      	lod	A, [S-86]
    84be:	b356      	adc	A, ep:0x56 <__bist_stat_end+0xc>
    84c0:	b257      	adc	A, [S-88]
    84c2:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    84c4:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    84c6:	7356      	lod	A, ep:0x56 <__bist_stat_end+0xc>
    84c8:	7257      	lod	A, [S-88]
    84ca:	6800      	lod	AH, #0
    84cc:	b354      	adc	A, ep:0x54 <__bist_stat_end+0xa>
    84ce:	b255      	adc	A, [S-86]
    84d0:	e330      	add	Y, ep:0x30 <_ml_driver_mode+0xc>
    84d2:	ea31      	sub	Y, [S-50]
    84d4:	b356      	adc	A, ep:0x56 <__bist_stat_end+0xc>
    84d6:	b257      	adc	A, [S-88]
    84d8:	eb32      	sub	Y, ep:0x32 <_ml_driver_mode+0xe>
    84da:	ea33      	sub	Y, [S-52]
    84dc:	6800      	lod	AH, #0
    84de:	b726      	and	A, ep:0x26 <_ml_driver_mode+0x2>
    84e0:	bf8f      	xor	A, ep:0x8f <__bist_stat_end+0x45>
    84e2:	4040      	jmp	fp2:0x00
    84e4:	0108      	jmp	0x86f6 <__mlx4_flash_start+0x6f6>
    84e6:	3cc3      	xor	X, #-61
    84e8:	b782      	and	A, ep:0x82 <__bist_stat_end+0x38>
    84ea:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    84ec:	833c      	add	AL, ep:0x3c <__data_end>
    84ee:	733c      	lod	A, ep:0x3c <__data_end>
    84f0:	b33d      	adc	A, ep:0x3d <__data_end+0x1>
    84f2:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    84f4:	733d      	lod	A, ep:0x3d <__data_end+0x1>
    84f6:	6800      	lod	AH, #0
    84f8:	b726      	and	A, ep:0x26 <_ml_driver_mode+0x2>
    84fa:	a78f      	or	A, ep:0x8f <__bist_stat_end+0x45>
    84fc:	0101      	jmp	0x8700 <__mlx4_flash_start+0x700>
    84fe:	3cc3      	xor	X, #-61
    8500:	6800      	lod	AH, #0
    8502:	2939      	sub	X, dp:0x39 <__bss_dp_end+0x1>
    8504:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8506:	493c      	mov	dp:0x3c <__data_end>, AH
    8508:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    850a:	b75e      	and	A, ep:0x5e <__bist_stat_end+0x14>
    850c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    850e:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    8510:	b680      	and	A, io:0x0 <__data_dp_size>
    8512:	b75e      	and	A, ep:0x5e <__bist_stat_end+0x14>
    8514:	b682      	and	A, io:0x2 <_LinCmnd>
    8516:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    8518:	3b33      	subc	X, ep:0x33 <_ml_driver_mode+0xf>
    851a:	6800      	lod	AH, #0
    851c:	3b12      	subc	X, ep:0x12 <_stFixedRamNAD+0x2>
    851e:	b726      	and	A, ep:0x26 <_ml_driver_mode+0x2>
    8520:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    8522:	b682      	and	A, io:0x2 <_LinCmnd>
    8524:	bfbc      	xor	A, ep:0xbc <__bist_stat_end+0x72>
    8526:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    8528:	6800      	lod	AH, #0
    852a:	b301      	adc	A, ep:0x1 <__data_dp_size+0x1>
    852c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    852e:	1106      	call	0x873c <__mlx4_flash_start+0x73c>
    8530:	e781      	or	Y, ep:0x81 <__bist_stat_end+0x37>
    8532:	1108      	call	0x8744 <__mlx4_flash_start+0x744>
    8534:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8536:	7381      	lod	A, ep:0x81 <__bist_stat_end+0x37>
    8538:	5404      	ret	#5
    853a:	202f      	add	X, #47
    853c:	e78e      	or	Y, ep:0x8e <__bist_stat_end+0x44>
    853e:	0102      	jmp	0x8744 <__mlx4_flash_start+0x744>
    8540:	a752      	or	A, ep:0x52 <__bist_stat_end+0x8>
    8542:	1104      	call	0x874c <__mlx4_flash_start+0x74c>
    8544:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8546:	7381      	lod	A, ep:0x81 <__bist_stat_end+0x37>
    8548:	5404      	ret	#5
    854a:	6800      	lod	AH, #0
    854c:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    854e:	7381      	lod	A, ep:0x81 <__bist_stat_end+0x37>
    8550:	5404      	ret	#5
    8552:	e684      	or	Y, io:0x4 <__data_size>
    8554:	1102      	call	0x875a <__mlx4_flash_start+0x75a>
    8556:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8558:	29d4      	sub	X, dp:0xd4 <__bist_stat_end+0x8a>
    855a:	7201      	lod	A, [S-2]
    855c:	e682      	or	Y, io:0x2 <_LinCmnd>
    855e:	1101      	call	0x8762 <__mlx4_flash_start+0x762>
    8560:	248f      	or	X, #-113
    8562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    8564:	1101      	call	0x8768 <__mlx4_flash_start+0x768>
    8566:	2967      	sub	X, dp:0x67 <__bist_stat_end+0x1d>
    8568:	2487      	or	X, #-121
    856a:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    856c:	bf8d      	xor	A, ep:0x8d <__bist_stat_end+0x43>
    856e:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    8570:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8572:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    8574:	b782      	and	A, ep:0x82 <__bist_stat_end+0x38>
    8576:	22d2      	add	X, [A++]
    8578:	0b04      	setb	io:0x00.4
    857a:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    857c:	f788      	and	Y, ep:0x88 <__bist_stat_end+0x3e>
    857e:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    8580:	22e5      	add	X, MH
    8582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    8584:	b20d      	adc	A, [S-14]
    8586:	7238      	lod	A, [S-57]
    8588:	b202      	adc	A, [S-3]
    858a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    858c:	b203      	adc	A, [S-4]
    858e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    8590:	b63e      	and	A, [S-63]
    8592:	22d7      	.word	0x22d7
    8594:	b101      	adc	A, dp:0x1 <__data_dp_size+0x1>
    8596:	7201      	lod	A, [S-2]
    8598:	7338      	lod	A, ep:0x38 <__bss_dp_end>
    859a:	b365      	adc	A, ep:0x65 <__bist_stat_end+0x1b>
    859c:	bf81      	xor	A, ep:0x81 <__bist_stat_end+0x37>
    859e:	0101      	jmp	0x87a2 <__mlx4_flash_start+0x7a2>
    85a0:	6800      	lod	AH, #0
    85a2:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    85a4:	0b04      	setb	io:0x00.4
    85a6:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    85a8:	f788      	and	Y, ep:0x88 <__bist_stat_end+0x3e>
    85aa:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    85ac:	22e5      	add	X, MH
    85ae:	7334      	lod	A, ep:0x34 <_ml_driver_mode+0x10>
    85b0:	7235      	lod	A, [S-54]
    85b2:	7388      	lod	A, ep:0x88 <__bist_stat_end+0x3e>
    85b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    85b6:	718a      	lod	A, dp:0x8a <__bist_stat_end+0x40>
    85b8:	b338      	adc	A, ep:0x38 <__bss_dp_end>
    85ba:	738b      	lod	A, ep:0x8b <__bist_stat_end+0x41>
    85bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    85be:	b20f      	adc	A, [S-16]
    85c0:	738e      	lod	A, ep:0x8e <__bist_stat_end+0x44>
    85c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    85c4:	5408      	ret	#9
    85c6:	7ca6      	lod	X, #-90
    85c8:	7d34      	lod	X, dp:0x34 <_ml_driver_mode+0x10>
    85ca:	6800      	lod	AH, #0
    85cc:	b384      	adc	A, ep:0x84 <__bist_stat_end+0x3a>
    85ce:	b285      	adc	A, io:0x5 <__data_size+0x1>
    85d0:	7380      	lod	A, ep:0x80 <__bist_stat_end+0x36>
    85d2:	7334      	lod	A, ep:0x34 <_ml_driver_mode+0x10>
    85d4:	7235      	lod	A, [S-54]
    85d6:	7ca7      	lod	X, #-89
    85d8:	7d34      	lod	X, dp:0x34 <_ml_driver_mode+0x10>
    85da:	6c03      	lod	YH, #3
    85dc:	2300      	add	X, ep:0x0 <__data_dp_size>
    85de:	2295      	add	X, io:0x15 <_stFixedRamNAD+0x5>
    85e0:	23ee      	add	X, ep:0xee <__bist_stat_end+0xa4>
    85e2:	2300      	add	X, ep:0x0 <__data_dp_size>
    85e4:	2300      	add	X, ep:0x0 <__data_dp_size>
    85e6:	23a1      	add	X, ep:0xa1 <__bist_stat_end+0x57>
    85e8:	240b      	or	X, #11
    85ea:	23cb      	add	X, ep:0xcb <__bist_stat_end+0x81>
    85ec:	2300      	add	X, ep:0x0 <__data_dp_size>
    85ee:	2300      	add	X, ep:0x0 <__data_dp_size>
    85f0:	2304      	add	X, ep:0x4 <__data_size>
    85f2:	23c3      	add	X, ep:0xc3 <__bist_stat_end+0x79>
    85f4:	23e6      	add	X, ep:0xe6 <__bist_stat_end+0x9c>
    85f6:	23da      	add	X, ep:0xda <__bist_stat_end+0x90>
    85f8:	2300      	add	X, ep:0x0 <__data_dp_size>
    85fa:	23b7      	add	X, ep:0xb7 <__bist_stat_end+0x6d>
    85fc:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    85fe:	2301      	add	X, ep:0x1 <__data_dp_size+0x1>
    8600:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8602:	7381      	lod	A, ep:0x81 <__bist_stat_end+0x37>
    8604:	5404      	ret	#5
    8606:	6800      	lod	AH, #0
    8608:	e682      	or	Y, io:0x2 <_LinCmnd>
    860a:	0104      	jmp	0x8814 <__mlx4_flash_start+0x814>
    860c:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    860e:	7282      	lod	A, io:0x2 <_LinCmnd>
    8610:	b684      	and	A, io:0x4 <__data_size>
    8612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    8614:	b680      	and	A, io:0x0 <__data_dp_size>
    8616:	7282      	lod	A, io:0x2 <_LinCmnd>
    8618:	b680      	and	A, io:0x0 <__data_dp_size>
    861a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    861c:	22fe      	add	X, [X+6]
    861e:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8620:	a688      	or	A, io:0x8 <__bist_stat_size>
    8622:	0102      	jmp	0x8828 <__mlx4_flash_start+0x828>
    8624:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8626:	2315      	add	X, ep:0x15 <_stFixedRamNAD+0x5>
    8628:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    862a:	7170      	lod	A, dp:0x70 <__bist_stat_end+0x26>
    862c:	a684      	or	A, io:0x4 <__data_size>
    862e:	0101      	jmp	0x8832 <__mlx4_flash_start+0x832>
    8630:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    8634:	4692      	mov	io:0x12 <_stFixedRamNAD+0x2>, YL
    8636:	7271      	lod	A, [S-114]
    8638:	b286      	adc	A, io:0x6 <__bss_size>
    863a:	4616      	mov	[S-23], YL
    863c:	7286      	lod	A, io:0x6 <__bss_size>
    863e:	b271      	adc	A, [S-114]
    8640:	b5a3      	and	A, dp:0xa3 <__bist_stat_end+0x59>
    8642:	0009      	jmp	0x8656 <__mlx4_flash_start+0x656>
    8644:	6c02      	lod	YH, #2
    8646:	bd8e      	xor	A, dp:0x8e <__bist_stat_end+0x44>
    8648:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    864a:	bd8d      	xor	A, dp:0x8d <__bist_stat_end+0x43>
    864c:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    864e:	bd8b      	xor	A, dp:0x8b <__bist_stat_end+0x41>
    8650:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    8652:	bd87      	xor	A, dp:0x87 <__bist_stat_end+0x3d>
    8654:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    8656:	6c02      	lod	YH, #2
    8658:	f581      	and	Y, dp:0x81 <__bist_stat_end+0x37>
    865a:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    865c:	f582      	and	Y, dp:0x82 <__bist_stat_end+0x38>
    865e:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    8660:	f584      	and	Y, dp:0x84 <__bist_stat_end+0x3a>
    8662:	2333      	add	X, ep:0x33 <_ml_driver_mode+0xf>
    8664:	f588      	and	Y, dp:0x88 <__bist_stat_end+0x3e>
    8666:	b691      	and	A, io:0x11 <_stFixedRamNAD+0x1>
    8668:	b170      	adc	A, dp:0x70 <__bist_stat_end+0x26>
    866a:	76a3      	jmp	io:0x23 <_LinMessage+0x1>
    866c:	e78a      	or	Y, ep:0x8a <__bist_stat_end+0x40>
    866e:	1008      	call	0x8680 <__mlx4_flash_start+0x680>
    8670:	8782      	or	AL, ep:0x82 <__bist_stat_end+0x38>
    8672:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8674:	a783      	or	A, ep:0x83 <__bist_stat_end+0x39>
    8676:	4794      	mov	ep:0x94 <__bist_stat_end+0x4a>, YL
    8678:	0101      	jmp	0x887c <__mlx4_flash_start+0x87c>
    867a:	231c      	add	X, ep:0x1c <_LinFrameDataBuffer+0x4>
    867c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    867e:	231d      	add	X, ep:0x1d <_LinFrameDataBuffer+0x5>
    8680:	e78c      	or	Y, ep:0x8c <__bist_stat_end+0x42>
    8682:	1003      	call	0x868a <__mlx4_flash_start+0x68a>
    8684:	8782      	or	AL, ep:0x82 <__bist_stat_end+0x38>
    8686:	4050      	jmp	fp2:0x80
    8688:	231f      	add	X, ep:0x1f <__ramfunc_size+0x1>
    868a:	22fe      	add	X, [X+6]
    868c:	b202      	adc	A, [S-3]
    868e:	b36b      	adc	A, ep:0x6b <__bist_stat_end+0x21>
    8690:	836a      	add	AL, ep:0x6a <__bist_stat_end+0x20>
    8692:	736b      	lod	A, ep:0x6b <__bist_stat_end+0x21>
    8694:	bf81      	xor	A, ep:0x81 <__bist_stat_end+0x37>
    8696:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8698:	6c03      	lod	YH, #3
    869a:	2375      	add	X, ep:0x75 <__bist_stat_end+0x2b>
    869c:	2351      	add	X, ep:0x51 <__bist_stat_end+0x7>
    869e:	236c      	add	X, ep:0x6c <__bist_stat_end+0x22>
    86a0:	2375      	add	X, ep:0x75 <__bist_stat_end+0x2b>
    86a2:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    86a4:	7202      	lod	A, [S-3]
    86a6:	b203      	adc	A, [S-4]
    86a8:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    86aa:	f36b      	adc	Y, ep:0x6b <__bist_stat_end+0x21>
    86ac:	736b      	lod	A, ep:0x6b <__bist_stat_end+0x21>
    86ae:	b786      	and	A, ep:0x86 <__bist_stat_end+0x3c>
    86b0:	e73e      	or	Y, ep:0x3e <_page_buffer>
    86b2:	0002      	jmp	0x86b8 <__mlx4_flash_start+0x6b8>
    86b4:	0106      	jmp	0x88c2 <__mlx4_flash_start+0x8c2>
    86b6:	2373      	add	X, ep:0x73 <__bist_stat_end+0x29>
    86b8:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    86ba:	e73e      	or	Y, ep:0x3e <_page_buffer>
    86bc:	1003      	call	0x86c4 <__mlx4_flash_start+0x6c4>
    86be:	b78f      	and	A, ep:0x8f <__bist_stat_end+0x45>
    86c0:	2362      	add	X, ep:0x62 <__bist_stat_end+0x18>
    86c2:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    86c4:	0000      	nop
    86c6:	0000      	nop
    86c8:	0000      	nop
    86ca:	0000      	nop
    86cc:	0000      	nop
    86ce:	0000      	nop
    86d0:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    86d2:	e780      	or	Y, ep:0x80 <__bist_stat_end+0x36>
    86d4:	0108      	jmp	0x88e6 <__mlx4_flash_start+0x8e6>
    86d6:	2362      	add	X, ep:0x62 <__bist_stat_end+0x18>
    86d8:	c681      	or	AH, io:0x1 <__data_dp_size+0x1>
    86da:	7202      	lod	A, [S-3]
    86dc:	b203      	adc	A, [S-4]
    86de:	ce80      	cmp	AH, io:0x0 <__data_dp_size>
    86e0:	b78e      	and	A, ep:0x8e <__bist_stat_end+0x44>
    86e2:	bb6b      	subc	A, ep:0x6b <__bist_stat_end+0x21>
    86e4:	736b      	lod	A, ep:0x6b <__bist_stat_end+0x21>
    86e6:	7203      	lod	A, [S-4]
    86e8:	4c02 6800 	add	D, #1920034816
    86ec:	7271 
    86ee:	b16d      	adc	A, dp:0x6d <__bist_stat_end+0x23>
    86f0:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    86f2:	716d      	lod	A, dp:0x6d <__bist_stat_end+0x23>
    86f4:	0b04      	setb	io:0x00.4
    86f6:	b25e      	adc	A, [S-95]
    86f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    86fa:	725e      	lod	A, [S-95]
    86fc:	2388      	add	X, ep:0x88 <__bist_stat_end+0x3e>
    86fe:	7189      	lod	A, dp:0x89 <__bist_stat_end+0x3f>
    8700:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    8702:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8704:	7335      	lod	A, ep:0x35 <_ml_driver_mode+0x11>
    8706:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    8708:	7388      	lod	A, ep:0x88 <__bist_stat_end+0x3e>
    870a:	5408      	ret	#9
    870c:	7c55      	lod	X, #85
    870e:	7d34      	lod	X, dp:0x34 <_ml_driver_mode+0x10>
    8710:	b691      	and	A, io:0x11 <_stFixedRamNAD+0x1>
    8712:	b588      	and	A, dp:0x88 <__bist_stat_end+0x3e>
    8714:	3beb      	subc	X, ep:0xeb <__bist_stat_end+0xa1>
    8716:	b5a6      	and	A, dp:0xa6 <__bist_stat_end+0x5c>
    8718:	716e      	lod	A, dp:0x6e <__bist_stat_end+0x24>
    871a:	a58f      	or	A, dp:0x8f <__bist_stat_end+0x45>
    871c:	1103      	call	0x8924 <__mlx4_flash_start+0x924>
    871e:	b16c      	adc	A, dp:0x6c <__bist_stat_end+0x22>
    8720:	bd84      	xor	A, dp:0x84 <__bist_stat_end+0x3a>
    8722:	716c      	lod	A, dp:0x6c <__bist_stat_end+0x22>
    8724:	b271      	adc	A, [S-114]
    8726:	6800      	lod	AH, #0
    8728:	a688      	or	A, io:0x8 <__bist_stat_size>
    872a:	110a      	call	0x8940 <__mlx4_flash_start+0x940>
    872c:	b23b      	adc	A, [S-60]
    872e:	f684      	and	Y, io:0x4 <__data_size>
    8730:	723b      	lod	A, [S-60]
    8732:	b35a      	adc	A, ep:0x5a <__bist_stat_end+0x10>
    8734:	7342      	lod	A, ep:0x42 <__bss_end>
    8736:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8738:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    873a:	7341      	lod	A, ep:0x41 <_page_buffer+0x3>
    873c:	7343      	lod	A, ep:0x43 <__bss_end+0x1>
    873e:	7344      	lod	A, ep:0x44 <_bistResetInfo>
    8740:	6800      	lod	AH, #0
    8742:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    8744:	b286      	adc	A, io:0x6 <__bss_size>
    8746:	010a      	jmp	0x895c <__mlx4_flash_start+0x95c>
    8748:	000e      	jmp	0x8766 <__mlx4_flash_start+0x766>
    874a:	e680      	or	Y, io:0x0 <__data_dp_size>
    874c:	b35f      	adc	A, ep:0x5f <__bist_stat_end+0x15>
    874e:	0103      	jmp	0x8956 <__mlx4_flash_start+0x956>
    8750:	f782      	and	Y, ep:0x82 <__bist_stat_end+0x38>
    8752:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    8754:	22fe      	add	X, [X+6]
    8756:	bf8d      	xor	A, ep:0x8d <__bist_stat_end+0x43>
    8758:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    875a:	22fe      	add	X, [X+6]
    875c:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    875e:	f788      	and	Y, ep:0x88 <__bist_stat_end+0x3e>
    8760:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    8762:	7200      	lod	A, [S-1]
    8764:	22fe      	add	X, [X+6]
    8766:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8768:	f784      	and	Y, ep:0x84 <__bist_stat_end+0x3a>
    876a:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    876c:	22fe      	add	X, [X+6]
    876e:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    8770:	bf8d      	xor	A, ep:0x8d <__bist_stat_end+0x43>
    8772:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    8774:	a682      	or	A, io:0x2 <_LinCmnd>
    8776:	1106      	call	0x8984 <__mlx4_flash_start+0x984>
    8778:	b35f      	adc	A, ep:0x5f <__bist_stat_end+0x15>
    877a:	bf8e      	xor	A, ep:0x8e <__bist_stat_end+0x44>
    877c:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    877e:	0101      	jmp	0x8982 <__mlx4_flash_start+0x982>
    8780:	f781      	and	Y, ep:0x81 <__bist_stat_end+0x37>
    8782:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    8784:	22fe      	add	X, [X+6]
    8786:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8788:	e301      	add	Y, ep:0x1 <__data_dp_size+0x1>
    878a:	0101      	jmp	0x898e <__mlx4_flash_start+0x98e>
    878c:	2300      	add	X, ep:0x0 <__data_dp_size>
    878e:	7264      	lod	A, [S-101]
    8790:	b286      	adc	A, io:0x6 <__bss_size>
    8792:	7265      	lod	A, [S-102]
    8794:	22fe      	add	X, [X+6]
    8796:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8798:	e301      	add	Y, ep:0x1 <__data_dp_size+0x1>
    879a:	0101      	jmp	0x899e <__mlx4_flash_start+0x99e>
    879c:	2300      	add	X, ep:0x0 <__data_dp_size>
    879e:	4692      	mov	io:0x12 <_stFixedRamNAD+0x2>, YL
    87a0:	be86      	xor	A, io:0x6 <__bss_size>
    87a2:	6c02      	lod	YH, #2
    87a4:	3e04      	xor	X, [S-5]
    87a6:	23d9      	add	X, ep:0xd9 <__bist_stat_end+0x8f>
    87a8:	3e05      	xor	X, [S-6]
    87aa:	23d9      	add	X, ep:0xd9 <__bist_stat_end+0x8f>
    87ac:	3e06      	xor	X, [S-7]
    87ae:	23d9      	add	X, ep:0xd9 <__bist_stat_end+0x8f>
    87b0:	3e07      	xor	X, [S-8]
    87b2:	22fe      	add	X, [X+6]
    87b4:	b285      	adc	A, io:0x5 <__data_size+0x1>
    87b6:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    87b8:	0106      	jmp	0x89c6 <__mlx4_flash_start+0x9c6>
    87ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    87bc:	0102      	jmp	0x89c2 <__mlx4_flash_start+0x9c2>
    87be:	b680      	and	A, io:0x0 <__data_dp_size>
    87c0:	23e4      	add	X, ep:0xe4 <__bist_stat_end+0x9a>
    87c2:	b682      	and	A, io:0x2 <_LinCmnd>
    87c4:	23e4      	add	X, ep:0xe4 <__bist_stat_end+0x9a>
    87c6:	b684      	and	A, io:0x4 <__data_size>
    87c8:	726c      	lod	A, [S-109]
    87ca:	22fe      	add	X, [X+6]
    87cc:	b301      	adc	A, ep:0x1 <__data_dp_size+0x1>
    87ce:	7382      	lod	A, ep:0x82 <__bist_stat_end+0x38>
    87d0:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    87d2:	7383      	lod	A, ep:0x83 <__bist_stat_end+0x39>
    87d4:	f686      	and	Y, io:0x6 <__bss_size>
    87d6:	bf92      	xor	A, ep:0x92 <__bist_stat_end+0x48>
    87d8:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    87da:	22fe      	add	X, [X+6]
    87dc:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    87de:	e301      	add	Y, ep:0x1 <__data_dp_size+0x1>
    87e0:	0101      	jmp	0x89e4 <__mlx4_flash_start+0x9e4>
    87e2:	2300      	add	X, ep:0x0 <__data_dp_size>
    87e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    87e6:	010e      	jmp	0x8a04 <__mlx4_flash_start+0xa04>
    87e8:	763e      	jmp	[S-63]
    87ea:	7207      	lod	A, [S-8]
    87ec:	7206      	lod	A, [S-7]
    87ee:	b286      	adc	A, io:0x6 <__bss_size>
    87f0:	7202      	lod	A, [S-3]
    87f2:	7204      	lod	A, [S-5]
    87f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    87f6:	7203      	lod	A, [S-4]
    87f8:	7205      	lod	A, [S-6]
    87fa:	b25c      	adc	A, [S-93]
    87fc:	f684      	and	Y, io:0x4 <__data_size>
    87fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    8800:	725c      	lod	A, [S-93]
    8802:	22fe      	add	X, [X+6]
    8804:	b25c      	adc	A, [S-93]
    8806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    8808:	b386      	adc	A, ep:0x86 <__bist_stat_end+0x3c>
    880a:	e780      	or	Y, ep:0x80 <__bist_stat_end+0x36>
    880c:	0101      	jmp	0x8a10 <__mlx4_flash_start+0xa10>
    880e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    8810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    8812:	725c      	lod	A, [S-93]
    8814:	22fe      	add	X, [X+6]
    8816:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8818:	e301      	add	Y, ep:0x1 <__data_dp_size+0x1>
    881a:	0101      	jmp	0x8a1e <__mlx4_flash_start+0xa1e>
    881c:	2300      	add	X, ep:0x0 <__data_dp_size>
    881e:	b387      	adc	A, ep:0x87 <__bist_stat_end+0x3d>
    8820:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8822:	0001      	jmp	0x8826 <__mlx4_flash_start+0x826>
    8824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    8826:	7271      	lod	A, [S-114]
    8828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    882a:	4608      	mov	[S-9], YL
    882c:	6c02      	lod	YH, #2
    882e:	b11c      	adc	A, dp:0x1c <_LinFrameDataBuffer+0x4>
    8830:	241e      	or	X, #30
    8832:	b11d      	adc	A, dp:0x1d <_LinFrameDataBuffer+0x5>
    8834:	241e      	or	X, #30
    8836:	b12c      	adc	A, dp:0x2c <_ml_driver_mode+0x8>
    8838:	241e      	or	X, #30
    883a:	b12d      	adc	A, dp:0x2d <_ml_driver_mode+0x9>
    883c:	b387      	adc	A, ep:0x87 <__bist_stat_end+0x3d>
    883e:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8840:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8842:	b371      	adc	A, ep:0x71 <__bist_stat_end+0x27>
    8844:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    8846:	4788      	mov	ep:0x88 <__bist_stat_end+0x3e>, YL
    8848:	0009      	jmp	0x885c <__mlx4_flash_start+0x85c>
    884a:	6c03      	lod	YH, #3
    884c:	bd8e      	xor	A, dp:0x8e <__bist_stat_end+0x44>
    884e:	2436      	or	X, #54
    8850:	bd8d      	xor	A, dp:0x8d <__bist_stat_end+0x43>
    8852:	2436      	or	X, #54
    8854:	bd8b      	xor	A, dp:0x8b <__bist_stat_end+0x41>
    8856:	2436      	or	X, #54
    8858:	bd87      	xor	A, dp:0x87 <__bist_stat_end+0x3d>
    885a:	2436      	or	X, #54
    885c:	6c03      	lod	YH, #3
    885e:	f581      	and	Y, dp:0x81 <__bist_stat_end+0x37>
    8860:	2436      	or	X, #54
    8862:	f582      	and	Y, dp:0x82 <__bist_stat_end+0x38>
    8864:	2436      	or	X, #54
    8866:	f584      	and	Y, dp:0x84 <__bist_stat_end+0x3a>
    8868:	2436      	or	X, #54
    886a:	f588      	and	Y, dp:0x88 <__bist_stat_end+0x3e>
    886c:	6c02      	lod	YH, #2
    886e:	711c      	lod	A, dp:0x1c <_LinFrameDataBuffer+0x4>
    8870:	243e      	or	X, #62
    8872:	711d      	lod	A, dp:0x1d <_LinFrameDataBuffer+0x5>
    8874:	243e      	or	X, #62
    8876:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    8878:	243e      	or	X, #62
    887a:	712d      	lod	A, dp:0x2d <_ml_driver_mode+0x9>
    887c:	22fe      	add	X, [X+6]
    887e:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8880:	b682      	and	A, io:0x2 <_LinCmnd>
    8882:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8884:	7c01      	lod	X, #1
    8886:	5018      	call	fp0:0xC0
    8888:	54c0      	.word	0x54c0
    888a:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    888c:	733e      	lod	A, ep:0x3e <_page_buffer>
    888e:	733f      	lod	A, ep:0x3f <_page_buffer+0x1>
    8890:	5401      	ret
    8892:	3e60      	xor	X, [S-97]
    8894:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8896:	773a      	lod	PC, ep:0x3a <_LINBaud>
    8898:	773b      	lod	PC, ep:0x3b <_LINBaud+0x1>
    889a:	773f      	lod	PC, ep:0x3f <_page_buffer+0x1>
    889c:	355b      	and	X, dp:0x5b <__bist_stat_end+0x11>
    889e:	365b      	and	X, [S-92]
    88a0:	3730      	and	X, ep:0x30 <_ml_driver_mode+0xc>
    88a2:	7736      	lod	PC, ep:0x36 <_ml_driver_mode+0x12>
    88a4:	3ba0      	subc	X, ep:0xa0 <__bist_stat_end+0x56>
    88a6:	b78f      	and	A, ep:0x8f <__bist_stat_end+0x45>
    88a8:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    88aa:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    88ac:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    88ae:	b78e      	and	A, ep:0x8e <__bist_stat_end+0x44>
    88b0:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    88b2:	b680      	and	A, io:0x0 <__data_dp_size>
    88b4:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    88b6:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    88b8:	7301      	lod	A, ep:0x1 <__data_dp_size+0x1>
    88ba:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    88bc:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    88be:	494e      	mov	dp:0x4e <__bist_stat_end+0x4>, AH
    88c0:	4930      	mov	dp:0x30 <_ml_driver_mode+0xc>, AH
    88c2:	493a      	mov	dp:0x3a <_LINBaud>, AH
    88c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    88c6:	4964      	mov	dp:0x64 <__bist_stat_end+0x1a>, AH
    88c8:	735f      	lod	A, ep:0x5f <__bist_stat_end+0x15>
    88ca:	736c      	lod	A, ep:0x6c <__bist_stat_end+0x22>
    88cc:	735c      	lod	A, ep:0x5c <__bist_stat_end+0x12>
    88ce:	7338      	lod	A, ep:0x38 <__bss_dp_end>
    88d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    88d2:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    88d4:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    88d6:	b58b      	and	A, dp:0x8b <__bist_stat_end+0x41>
    88d8:	7105      	lod	A, dp:0x5 <__data_size+0x1>
    88da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    88dc:	b58c      	and	A, dp:0x8c <__bist_stat_end+0x42>
    88de:	7104      	lod	A, dp:0x4 <__data_size>
    88e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    88e2:	b583      	and	A, dp:0x83 <__bist_stat_end+0x39>
    88e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    88e6:	7106      	lod	A, dp:0x6 <__bss_size>
    88e8:	b680      	and	A, io:0x0 <__data_dp_size>
    88ea:	77c6      	lod	PC, ep:0xc6 <__bist_stat_end+0x7c>
    88ec:	77ca      	lod	PC, ep:0xca <__bist_stat_end+0x80>
    88ee:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    88f0:	0101      	jmp	0x8af4 <__mlx4_flash_start+0xaf4>
    88f2:	2475      	or	X, #117
    88f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    88f6:	7336      	lod	A, ep:0x36 <_ml_driver_mode+0x12>
    88f8:	7237      	lod	A, [S-56]
    88fa:	b788      	and	A, ep:0x88 <__bist_stat_end+0x3e>
    88fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    88fe:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8900:	738c      	lod	A, ep:0x8c <__bist_stat_end+0x42>
    8902:	b784      	and	A, ep:0x84 <__bist_stat_end+0x3a>
    8904:	738d      	lod	A, ep:0x8d <__bist_stat_end+0x43>
    8906:	7c02      	lod	X, #2
    8908:	5820      	inc	S, #33
    890a:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    890c:	62ca      	lod	AL, [--PC]
    890e:	622b      	lod	AL, [S-44]
    8910:	3448      	and	X, #72
    8912:	5809      	inc	S, #10
    8914:	62e6      	lod	AL, Y
    8916:	2489      	or	X, #-119
    8918:	b78a      	and	A, ep:0x8a <__bist_stat_end+0x40>
    891a:	b682      	and	A, io:0x2 <_LinCmnd>
    891c:	62ca      	lod	AL, [--PC]
    891e:	5018      	call	fp0:0xC0
    8920:	54c0      	.word	0x54c0
    8922:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8924:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    8926:	24a3      	or	X, #-93
    8928:	b680      	and	A, io:0x0 <__data_dp_size>
    892a:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    892c:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    892e:	0106      	jmp	0x8b3c <__mlx4_flash_start+0xb3c>
    8930:	bf8e      	xor	A, ep:0x8e <__bist_stat_end+0x44>
    8932:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    8934:	b239      	adc	A, [S-58]
    8936:	7238      	lod	A, [S-57]
    8938:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    893a:	b686      	and	A, io:0x6 <__bss_size>
    893c:	e680      	or	Y, io:0x0 <__data_dp_size>
    893e:	0101      	jmp	0x8b42 <__mlx4_flash_start+0xb42>
    8940:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8942:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8944:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    8946:	b16f      	adc	A, dp:0x6f <__bist_stat_end+0x25>
    8948:	bd88      	xor	A, dp:0x88 <__bist_stat_end+0x3e>
    894a:	716f      	lod	A, dp:0x6f <__bist_stat_end+0x25>
    894c:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    894e:	a78d      	or	A, ep:0x8d <__bist_stat_end+0x43>
    8950:	1101      	call	0x8b54 <__mlx4_flash_start+0xb54>
    8952:	24c2      	or	X, #-62
    8954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    8956:	494e      	mov	dp:0x4e <__bist_stat_end+0x4>, AH
    8958:	b58e      	and	A, dp:0x8e <__bist_stat_end+0x44>
    895a:	b561      	and	A, dp:0x61 <__bist_stat_end+0x17>
    895c:	e53e      	or	Y, dp:0x3e <_page_buffer>
    895e:	1101      	call	0x8b62 <__mlx4_flash_start+0xb62>
    8960:	24c2      	or	X, #-62
    8962:	b340      	adc	A, ep:0x40 <_page_buffer+0x2>
    8964:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    8966:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    8968:	b341      	adc	A, ep:0x41 <_page_buffer+0x3>
    896a:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    896c:	7341      	lod	A, ep:0x41 <_page_buffer+0x3>
    896e:	b342      	adc	A, ep:0x42 <__bss_end>
    8970:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8972:	7342      	lod	A, ep:0x42 <__bss_end>
    8974:	b343      	adc	A, ep:0x43 <__bss_end+0x1>
    8976:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8978:	7343      	lod	A, ep:0x43 <__bss_end+0x1>
    897a:	b344      	adc	A, ep:0x44 <_bistResetInfo>
    897c:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    897e:	7344      	lod	A, ep:0x44 <_bistResetInfo>
    8980:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8982:	24ae      	or	X, #-82
    8984:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8986:	7166      	lod	A, dp:0x66 <__bist_stat_end+0x1c>
    8988:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    898a:	7167      	lod	A, dp:0x67 <__bist_stat_end+0x1d>
    898c:	b58e      	and	A, dp:0x8e <__bist_stat_end+0x44>
    898e:	b561      	and	A, dp:0x61 <__bist_stat_end+0x17>
    8990:	e106      	add	Y, dp:0x6 <__bss_size>
    8992:	0108      	jmp	0x8ba4 <__mlx4_flash_start+0xba4>
    8994:	b266      	adc	A, [S-103]
    8996:	4692      	mov	io:0x12 <_stFixedRamNAD+0x2>, YL
    8998:	7266      	lod	A, [S-103]
    899a:	b267      	adc	A, [S-104]
    899c:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    899e:	7267      	lod	A, [S-104]
    89a0:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    89a2:	24c8      	or	X, #-56
    89a4:	4d66      	mov	dp:0x66 <__bist_stat_end+0x1c>, YH
    89a6:	4968      	mov	dp:0x68 <__bist_stat_end+0x1e>, AH
    89a8:	6281      	lod	AL, io:0x1 <__data_dp_size+0x1>
    89aa:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    89ac:	733a      	lod	A, ep:0x3a <_LINBaud>
    89ae:	623a      	lod	AL, [S-59]
    89b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    89b2:	1104      	call	0x8bbc <__mlx4_flash_start+0xbbc>
    89b4:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    89b6:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    89b8:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    89ba:	24f2      	or	X, #-14
    89bc:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    89be:	a78d      	or	A, ep:0x8d <__bist_stat_end+0x43>
    89c0:	0103      	jmp	0x8bc8 <__mlx4_flash_start+0xbc8>
    89c2:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    89c4:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    89c6:	2494      	or	X, #-108
    89c8:	580e      	inc	S, #15
    89ca:	0803      	clrb	dp:0x00.3
    89cc:	0906      	clrb	io:0x00.6
    89ce:	62e6      	lod	AL, Y
    89d0:	24e4      	or	X, #-28
    89d2:	623a      	lod	AL, [S-59]
    89d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    89d6:	0106      	jmp	0x8be4 <__mlx4_flash_start+0xbe4>
    89d8:	24e4      	or	X, #-28
    89da:	626f      	lod	AL, [S-112]
    89dc:	0001      	jmp	0x89e0 <__mlx4_flash_start+0x9e0>
    89de:	24e9      	or	X, #-23
    89e0:	b586      	and	A, dp:0x86 <__bist_stat_end+0x3c>
    89e2:	29d4      	sub	X, dp:0xd4 <__bist_stat_end+0x8a>
    89e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    89e6:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    89e8:	380d      	subc	X, #13
    89ea:	3805      	subc	X, #5
    89ec:	3479      	and	X, #121
    89ee:	303a      	adc	X, #58
    89f0:	39f6      	subc	X, dp:0xf6 <__bist_stat_end+0xac>
    89f2:	b26c      	adc	A, [S-109]
    89f4:	a686      	or	A, io:0x6 <__bss_size>
    89f6:	0106      	jmp	0x8c04 <__mlx4_flash_start+0xc04>
    89f8:	f681      	and	Y, io:0x1 <__data_dp_size+0x1>
    89fa:	726c      	lod	A, [S-109]
    89fc:	b26e      	adc	A, [S-111]
    89fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    8a00:	1101      	call	0x8c04 <__mlx4_flash_start+0xc04>
    8a02:	6376      	lod	AL, ep:0x76 <__bist_stat_end+0x2c>
    8a04:	3cc3      	xor	X, #-61
    8a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    8a08:	be38      	xor	A, [S-57]
    8a0a:	0101      	jmp	0x8c0e <__mlx4_flash_start+0xc0e>
    8a0c:	2494      	or	X, #-108
    8a0e:	580e      	inc	S, #15
    8a10:	0905      	clrb	io:0x00.5
    8a12:	0802      	clrb	dp:0x00.2
    8a14:	62e6      	lod	AL, Y
    8a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8a18:	623a      	lod	AL, [S-59]
    8a1a:	2522      	or	X, dp:0x22 <_LinMessage>
    8a1c:	623a      	lod	AL, [S-59]
    8a1e:	b15c      	adc	A, dp:0x5c <__bist_stat_end+0x12>
    8a20:	bd8e      	xor	A, dp:0x8e <__bist_stat_end+0x44>
    8a22:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    8a24:	1102      	call	0x8c2a <__mlx4_flash_start+0xc2a>
    8a26:	a78c      	or	A, ep:0x8c <__bist_stat_end+0x42>
    8a28:	0101      	jmp	0x8c2c <__mlx4_flash_start+0xc2c>
    8a2a:	f581      	and	Y, dp:0x81 <__bist_stat_end+0x37>
    8a2c:	715c      	lod	A, dp:0x5c <__bist_stat_end+0x12>
    8a2e:	4050      	jmp	fp2:0x80
    8a30:	6c04      	lod	YH, #4
    8a32:	2528      	or	X, dp:0x28 <_ml_driver_mode+0x4>
    8a34:	2542      	or	X, dp:0x42 <__bss_end>
    8a36:	254f      	or	X, dp:0x4f <__bist_stat_end+0x5>
    8a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8a3a:	b15c      	adc	A, dp:0x5c <__bist_stat_end+0x12>
    8a3c:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    8a3e:	0107      	jmp	0x8c4e <__mlx4_flash_start+0xc4e>
    8a40:	bd8e      	xor	A, dp:0x8e <__bist_stat_end+0x44>
    8a42:	715c      	lod	A, dp:0x5c <__bist_stat_end+0x12>
    8a44:	484f      	macu	D, AL, [X]
    8a46:	6c04      	lod	YH, #4
    8a48:	2557      	or	X, dp:0x57 <__bist_stat_end+0xd>
    8a4a:	2584      	or	X, dp:0x84 <__bist_stat_end+0x3a>
    8a4c:	25c6      	or	X, dp:0xc6 <__bist_stat_end+0x7c>
    8a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8a50:	484e      	macu	D, AL, [X++]
    8a52:	61c0      	lod	AL, dp:0xc0 <__bist_stat_end+0x76>
    8a54:	e583      	or	Y, dp:0x83 <__bist_stat_end+0x39>
    8a56:	1104      	call	0x8c60 <__mlx4_flash_start+0xc60>
    8a58:	b143      	adc	A, dp:0x43 <__bss_end+0x1>
    8a5a:	e585      	or	Y, dp:0x85 <__bist_stat_end+0x3b>
    8a5c:	1101      	call	0x8c60 <__mlx4_flash_start+0xc60>
    8a5e:	2918      	sub	X, dp:0x18 <_LinFrameDataBuffer>
    8a60:	b16c      	adc	A, dp:0x6c <__bist_stat_end+0x22>
    8a62:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    8a64:	010e      	jmp	0x8c82 <__mlx4_flash_start+0xc82>
    8a66:	b168      	adc	A, dp:0x68 <__bist_stat_end+0x1e>
    8a68:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8a6a:	7168      	lod	A, dp:0x68 <__bist_stat_end+0x1e>
    8a6c:	b169      	adc	A, dp:0x69 <__bist_stat_end+0x1f>
    8a6e:	cd80      	cmp	AH, dp:0x80 <__bist_stat_end+0x36>
    8a70:	7169      	lod	A, dp:0x69 <__bist_stat_end+0x1f>
    8a72:	1107      	call	0x8c82 <__mlx4_flash_start+0xc82>
    8a74:	4d66      	mov	dp:0x66 <__bist_stat_end+0x1c>, YH
    8a76:	4968      	mov	dp:0x68 <__bist_stat_end+0x1e>, AH
    8a78:	b16e      	adc	A, dp:0x6e <__bist_stat_end+0x24>
    8a7a:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8a7c:	716e      	lod	A, dp:0x6e <__bist_stat_end+0x24>
    8a7e:	1101      	call	0x8c82 <__mlx4_flash_start+0xc82>
    8a80:	6376      	lod	AL, ep:0x76 <__bist_stat_end+0x2c>
    8a82:	251d      	or	X, dp:0x1d <_LinFrameDataBuffer+0x5>
    8a84:	61d6      	lod	AL, dp:0xd6 <__bist_stat_end+0x8c>
    8a86:	7271      	lod	A, [S-114]
    8a88:	b256      	adc	A, [S-87]
    8a8a:	c242      	add	AH, [S-67]
    8a8c:	c943      	sub	AH, dp:0x43 <__bss_end+0x1>
    8a8e:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8a90:	4616      	mov	[S-23], YL
    8a92:	e242      	add	Y, [S-67]
    8a94:	e943      	sub	Y, dp:0x43 <__bss_end+0x1>
    8a96:	1002      	call	0x8a9c <__mlx4_flash_start+0xa9c>
    8a98:	b271      	adc	A, [S-114]
    8a9a:	251d      	or	X, dp:0x1d <_LinFrameDataBuffer+0x5>
    8a9c:	2494      	or	X, #-108
    8a9e:	b15a      	adc	A, dp:0x5a <__bist_stat_end+0x10>
    8aa0:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8aa2:	715a      	lod	A, dp:0x5a <__bist_stat_end+0x10>
    8aa4:	e583      	or	Y, dp:0x83 <__bist_stat_end+0x39>
    8aa6:	1001      	call	0x8aaa <__mlx4_flash_start+0xaaa>
    8aa8:	251d      	or	X, dp:0x1d <_LinFrameDataBuffer+0x5>
    8aaa:	6394      	lod	AL, ep:0x94 <__bist_stat_end+0x4a>
    8aac:	25ee      	or	X, dp:0xee <__bist_stat_end+0xa4>
    8aae:	61c0      	lod	AL, dp:0xc0 <__bist_stat_end+0x76>
    8ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    8ab2:	1102      	call	0x8cb8 <__mlx4_flash_start+0xcb8>
    8ab4:	7c06      	lod	X, #6
    8ab6:	2494      	or	X, #-108
    8ab8:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8aba:	e144      	add	Y, dp:0x44 <_bistResetInfo>
    8abc:	0005      	jmp	0x8ac8 <__mlx4_flash_start+0xac8>
    8abe:	b142      	adc	A, dp:0x42 <__bss_end>
    8ac0:	e589      	or	Y, dp:0x89 <__bist_stat_end+0x3f>
    8ac2:	b143      	adc	A, dp:0x43 <__bss_end+0x1>
    8ac4:	ed81      	cmp	Y, dp:0x81 <__bist_stat_end+0x37>
    8ac6:	0003      	jmp	0x8ace <__mlx4_flash_start+0xace>
    8ac8:	623d      	lod	AL, [S-62]
    8aca:	6207      	lod	AL, [S-8]
    8acc:	255c      	or	X, dp:0x5c <__bist_stat_end+0x12>
    8ace:	b35c      	adc	A, ep:0x5c <__bist_stat_end+0x12>
    8ad0:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8ad2:	1107      	call	0x8ce2 <__mlx4_flash_start+0xce2>
    8ad4:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    8ad6:	0105      	jmp	0x8ce2 <__mlx4_flash_start+0xce2>
    8ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    8ada:	e73e      	or	Y, ep:0x3e <_page_buffer>
    8adc:	1002      	call	0x8ae2 <__mlx4_flash_start+0xae2>
    8ade:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    8ae0:	2495      	or	X, #-107
    8ae2:	b36c      	adc	A, ep:0x6c <__bist_stat_end+0x22>
    8ae4:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    8ae6:	0105      	jmp	0x8cf2 <__mlx4_flash_start+0xcf2>
    8ae8:	bf8e      	xor	A, ep:0x8e <__bist_stat_end+0x44>
    8aea:	736c      	lod	A, ep:0x6c <__bist_stat_end+0x22>
    8aec:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    8aee:	b680      	and	A, io:0x0 <__data_dp_size>
    8af0:	62d2      	lod	AL, [A++]
    8af2:	4d40      	mov	dp:0x40 <_page_buffer+0x2>, YH
    8af4:	4954      	mov	dp:0x54 <__bist_stat_end+0xa>, AH
    8af6:	4d42      	mov	dp:0x42 <__bss_end>, YH
    8af8:	4956      	mov	dp:0x56 <__bist_stat_end+0xc>, AH
    8afa:	7c4a      	lod	X, #74
    8afc:	380e      	subc	X, #14
    8afe:	3806      	subc	X, #6
    8b00:	344c      	and	X, #76
    8b02:	484f      	macu	D, AL, [X]
    8b04:	5c01      	dec	S, #2
    8b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8b08:	61d0      	lod	AL, dp:0xd0 <__bist_stat_end+0x86>
    8b0a:	380f      	subc	X, #15
    8b0c:	3806      	subc	X, #6
    8b0e:	300a      	adc	X, #10
    8b10:	39f0      	subc	X, dp:0xf0 <__bist_stat_end+0xa6>
    8b12:	348f      	and	X, #-113
    8b14:	5c02      	dec	S, #3
    8b16:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8b18:	7172      	lod	A, dp:0x72 <__bist_stat_end+0x28>
    8b1a:	715a      	lod	A, dp:0x5a <__bist_stat_end+0x10>
    8b1c:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8b1e:	4946      	mov	dp:0x46 <_bistError>, AH
    8b20:	4948      	mov	dp:0x48 <_bistErrorInfo>, AH
    8b22:	b58f      	and	A, dp:0x8f <__bist_stat_end+0x45>
    8b24:	714b      	lod	A, dp:0x4b <__bist_stat_end+0x1>
    8b26:	714a      	lod	A, dp:0x4a <__bist_stat_end>
    8b28:	b343      	adc	A, ep:0x43 <__bss_end+0x1>
    8b2a:	b242      	adc	A, [S-67]
    8b2c:	b141      	adc	A, dp:0x41 <_page_buffer+0x3>
    8b2e:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8b30:	4942      	mov	dp:0x42 <__bss_end>, AH
    8b32:	7342      	lod	A, ep:0x42 <__bss_end>
    8b34:	7241      	lod	A, [S-66]
    8b36:	7140      	lod	A, dp:0x40 <_page_buffer+0x2>
    8b38:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    8b3a:	4616      	mov	[S-23], YL
    8b3c:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8b3e:	8140      	add	AL, dp:0x40 <_page_buffer+0x2>
    8b40:	8a41      	sub	AL, [S-66]
    8b42:	8b42      	sub	AL, ep:0x42 <__bss_end>
    8b44:	7140      	lod	A, dp:0x40 <_page_buffer+0x2>
    8b46:	7241      	lod	A, [S-66]
    8b48:	7342      	lod	A, ep:0x42 <__bss_end>
    8b4a:	7150      	lod	A, dp:0x50 <__bist_stat_end+0x6>
    8b4c:	7251      	lod	A, [S-82]
    8b4e:	7352      	lod	A, ep:0x52 <__bist_stat_end+0x8>
    8b50:	b35c      	adc	A, ep:0x5c <__bist_stat_end+0x12>
    8b52:	bf8c      	xor	A, ep:0x8c <__bist_stat_end+0x42>
    8b54:	e784      	or	Y, ep:0x84 <__bist_stat_end+0x3a>
    8b56:	0101      	jmp	0x8d5a <__mlx4_flash_start+0xd5a>
    8b58:	25c3      	or	X, dp:0xc3 <__bist_stat_end+0x79>
    8b5a:	b73e      	and	A, ep:0x3e <_page_buffer>
    8b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    8b5e:	100b      	call	0x8b76 <__mlx4_flash_start+0xb76>
    8b60:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8b62:	b152      	adc	A, dp:0x52 <__bist_stat_end+0x8>
    8b64:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8b66:	7152      	lod	A, dp:0x52 <__bist_stat_end+0x8>
    8b68:	b151      	adc	A, dp:0x51 <__bist_stat_end+0x7>
    8b6a:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8b6c:	7151      	lod	A, dp:0x51 <__bist_stat_end+0x7>
    8b6e:	b150      	adc	A, dp:0x50 <__bist_stat_end+0x6>
    8b70:	4516      	mov	dp:0x16 <_stFixedRamNAD+0x6>, YL
    8b72:	7150      	lod	A, dp:0x50 <__bist_stat_end+0x6>
    8b74:	25ae      	or	X, dp:0xae <__bist_stat_end+0x64>
    8b76:	b150      	adc	A, dp:0x50 <__bist_stat_end+0x6>
    8b78:	e104      	add	Y, dp:0x4 <__data_size>
    8b7a:	b151      	adc	A, dp:0x51 <__bist_stat_end+0x7>
    8b7c:	e905      	sub	Y, dp:0x5 <__data_size+0x1>
    8b7e:	b152      	adc	A, dp:0x52 <__bist_stat_end+0x8>
    8b80:	ed80      	cmp	Y, dp:0x80 <__bist_stat_end+0x36>
    8b82:	1001      	call	0x8b86 <__mlx4_flash_start+0xb86>
    8b84:	2494      	or	X, #-108
    8b86:	4950      	mov	dp:0x50 <__bist_stat_end+0x6>, AH
    8b88:	4952      	mov	dp:0x52 <__bist_stat_end+0x8>, AH
    8b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8b8c:	61dd      	lod	AL, dp:0xdd <__bist_stat_end+0x93>
    8b8e:	1001      	call	0x8b92 <__mlx4_flash_start+0xb92>
    8b90:	25ee      	or	X, dp:0xee <__bist_stat_end+0xa4>
    8b92:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8b94:	715a      	lod	A, dp:0x5a <__bist_stat_end+0x10>
    8b96:	b172      	adc	A, dp:0x72 <__bist_stat_end+0x28>
    8b98:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8b9a:	7172      	lod	A, dp:0x72 <__bist_stat_end+0x28>
    8b9c:	e588      	or	Y, dp:0x88 <__bist_stat_end+0x3e>
    8b9e:	0101      	jmp	0x8da2 <__mlx4_flash_start+0xda2>
    8ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    8ba2:	b150      	adc	A, dp:0x50 <__bist_stat_end+0x6>
    8ba4:	4592      	mov	dp:0x92 <__bist_stat_end+0x48>, YL
    8ba6:	716a      	lod	A, dp:0x6a <__bist_stat_end+0x20>
    8ba8:	b153      	adc	A, dp:0x53 <__bist_stat_end+0x9>
    8baa:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8bac:	7353      	lod	A, ep:0x53 <__bist_stat_end+0x9>
    8bae:	b351      	adc	A, ep:0x51 <__bist_stat_end+0x7>
    8bb0:	b252      	adc	A, [S-83]
    8bb2:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8bb4:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8bb6:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    8bb8:	7350      	lod	A, ep:0x50 <__bist_stat_end+0x6>
    8bba:	7251      	lod	A, [S-82]
    8bbc:	7152      	lod	A, dp:0x52 <__bist_stat_end+0x8>
    8bbe:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8bc0:	4616      	mov	[S-23], YL
    8bc2:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8bc4:	e349      	add	Y, ep:0x49 <_bistErrorInfo+0x1>
    8bc6:	ea4a      	sub	Y, [S-75]
    8bc8:	e94b      	sub	Y, dp:0x4b <__bist_stat_end+0x1>
    8bca:	1008      	call	0x8bdc <__mlx4_flash_start+0xbdc>
    8bcc:	8350      	add	AL, ep:0x50 <__bist_stat_end+0x6>
    8bce:	8a51      	sub	AL, [S-82]
    8bd0:	8952      	sub	AL, dp:0x52 <__bist_stat_end+0x8>
    8bd2:	e346      	add	Y, ep:0x46 <_bistError>
    8bd4:	ea47      	sub	Y, [S-72]
    8bd6:	e948      	sub	Y, dp:0x48 <_bistErrorInfo>
    8bd8:	0001      	jmp	0x8bdc <__mlx4_flash_start+0xbdc>
    8bda:	25f6      	or	X, dp:0xf6 <__bist_stat_end+0xac>
    8bdc:	b35c      	adc	A, ep:0x5c <__bist_stat_end+0x12>
    8bde:	bf8c      	xor	A, ep:0x8c <__bist_stat_end+0x42>
    8be0:	e784      	or	Y, ep:0x84 <__bist_stat_end+0x3a>
    8be2:	1103      	call	0x8dea <__mlx4_flash_start+0xdea>
    8be4:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    8be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    8be8:	2495      	or	X, #-107
    8bea:	2494      	or	X, #-108
    8bec:	b73e      	and	A, ep:0x3e <_page_buffer>
    8bee:	b252      	adc	A, [S-83]
    8bf0:	e680      	or	Y, io:0x0 <__data_dp_size>
    8bf2:	b153      	adc	A, dp:0x53 <__bist_stat_end+0x9>
    8bf4:	ed80      	cmp	Y, dp:0x80 <__bist_stat_end+0x36>
    8bf6:	1101      	call	0x8dfa <__mlx4_flash_start+0xdfa>
    8bf8:	260e      	or	X, [S-15]
    8bfa:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8bfc:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8bfe:	7153      	lod	A, dp:0x53 <__bist_stat_end+0x9>
    8c00:	4616      	mov	[S-23], YL
    8c02:	7252      	lod	A, [S-83]
    8c04:	b251      	adc	A, [S-82]
    8c06:	4616      	mov	[S-23], YL
    8c08:	7251      	lod	A, [S-82]
    8c0a:	b250      	adc	A, [S-81]
    8c0c:	4616      	mov	[S-23], YL
    8c0e:	7250      	lod	A, [S-81]
    8c10:	b26a      	adc	A, [S-107]
    8c12:	4616      	mov	[S-23], YL
    8c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    8c16:	726a      	lod	A, [S-107]
    8c18:	61fb      	lod	AL, dp:0xfb <__bist_stat_end+0xb1>
    8c1a:	25f7      	or	X, dp:0xf7 <__bist_stat_end+0xad>
    8c1c:	b250      	adc	A, [S-81]
    8c1e:	b151      	adc	A, dp:0x51 <__bist_stat_end+0x7>
    8c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    8c22:	ed8c      	cmp	Y, dp:0x8c <__bist_stat_end+0x42>
    8c24:	1001      	call	0x8c28 <__mlx4_flash_start+0xc28>
    8c26:	261a      	or	X, [S-27]
    8c28:	4510      	mov	dp:0x10 <_stFixedRamNAD>, YL
    8c2a:	4616      	mov	[S-23], YL
    8c2c:	7172      	lod	A, dp:0x72 <__bist_stat_end+0x28>
    8c2e:	61fb      	lod	AL, dp:0xfb <__bist_stat_end+0xb1>
    8c30:	b172      	adc	A, dp:0x72 <__bist_stat_end+0x28>
    8c32:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8c34:	7258      	lod	A, [S-89]
    8c36:	7159      	lod	A, dp:0x59 <__bist_stat_end+0xf>
    8c38:	b53e      	and	A, dp:0x3e <_page_buffer>
    8c3a:	773e      	lod	PC, ep:0x3e <_page_buffer>
    8c3c:	623a      	lod	AL, [S-59]
    8c3e:	484f      	macu	D, AL, [X]
    8c40:	380d      	subc	X, #13
    8c42:	3806      	subc	X, #6
    8c44:	e53e      	or	Y, dp:0x3e <_page_buffer>
    8c46:	0108      	jmp	0x8e58 <__mlx4_flash_start+0xe58>
    8c48:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8c4a:	b34f      	adc	A, ep:0x4f <__bist_stat_end+0x5>
    8c4c:	b24e      	adc	A, [S-79]
    8c4e:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    8c50:	4616      	mov	[S-23], YL
    8c52:	734f      	lod	A, ep:0x4f <__bist_stat_end+0x5>
    8c54:	724e      	lod	A, [S-79]
    8c56:	2622      	or	X, [S-35]
    8c58:	580e      	inc	S, #15
    8c5a:	0903      	clrb	io:0x00.3
    8c5c:	0809      	clrb	dp:0x01.1
    8c5e:	62e6      	lod	AL, Y
    8c60:	262c      	or	X, [S-45]
    8c62:	623a      	lod	AL, [S-59]
    8c64:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8c66:	715a      	lod	A, dp:0x5a <__bist_stat_end+0x10>
    8c68:	6394      	lod	AL, ep:0x94 <__bist_stat_end+0x4a>
    8c6a:	b583      	and	A, dp:0x83 <__bist_stat_end+0x39>
    8c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    8c6e:	2495      	or	X, #-107
    8c70:	b739      	and	A, ep:0x39 <__bss_dp_end+0x1>
    8c72:	b638      	and	A, [S-57]
    8c74:	348a      	and	X, #-118
    8c76:	4c58      	dadjs	D, A
    8c78:	b342      	adc	A, ep:0x42 <__bss_end>
    8c7a:	e780      	or	Y, ep:0x80 <__bist_stat_end+0x36>
    8c7c:	0101      	jmp	0x8e80 <__mlx4_flash_start+0xe80>
    8c7e:	2647      	or	X, [S-72]
    8c80:	b340      	adc	A, ep:0x40 <_page_buffer+0x2>
    8c82:	b241      	adc	A, [S-66]
    8c84:	e358      	add	Y, ep:0x58 <__bist_stat_end+0xe>
    8c86:	ea59      	sub	Y, [S-90]
    8c88:	1002      	call	0x8c8e <__mlx4_flash_start+0xc8e>
    8c8a:	7c04      	lod	X, #4
    8c8c:	2494      	or	X, #-108
    8c8e:	b34e      	adc	A, ep:0x4e <__bist_stat_end+0x4>
    8c90:	b24f      	adc	A, [S-80]
    8c92:	484f      	macu	D, AL, [X]
    8c94:	834e      	add	AL, ep:0x4e <__bist_stat_end+0x4>
    8c96:	8a4f      	sub	AL, [S-80]
    8c98:	1001      	call	0x8c9c <__mlx4_flash_start+0xc9c>
    8c9a:	2635      	or	X, [S-54]
    8c9c:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    8c9e:	724f      	lod	A, [S-80]
    8ca0:	b358      	adc	A, ep:0x58 <__bist_stat_end+0xe>
    8ca2:	b259      	adc	A, [S-90]
    8ca4:	4610      	mov	[S-17], YL
    8ca6:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8ca8:	8358      	add	AL, ep:0x58 <__bist_stat_end+0xe>
    8caa:	8a59      	sub	AL, [S-90]
    8cac:	0004      	jmp	0x8cb6 <__mlx4_flash_start+0xcb6>
    8cae:	e34e      	add	Y, ep:0x4e <__bist_stat_end+0x4>
    8cb0:	ea4f      	sub	Y, [S-80]
    8cb2:	1001      	call	0x8cb6 <__mlx4_flash_start+0xcb6>
    8cb4:	2635      	or	X, [S-54]
    8cb6:	b358      	adc	A, ep:0x58 <__bist_stat_end+0xe>
    8cb8:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    8cba:	b259      	adc	A, [S-90]
    8cbc:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8cbe:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8cc0:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    8cc2:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    8cc4:	7331      	lod	A, ep:0x31 <_ml_driver_mode+0xd>
    8cc6:	7232      	lod	A, [S-51]
    8cc8:	7133      	lod	A, dp:0x33 <_ml_driver_mode+0xf>
    8cca:	e355      	add	Y, ep:0x55 <__bist_stat_end+0xb>
    8ccc:	ea56      	sub	Y, [S-87]
    8cce:	e957      	sub	Y, dp:0x57 <__bist_stat_end+0xd>
    8cd0:	1002      	call	0x8cd6 <__mlx4_flash_start+0xcd6>
    8cd2:	b585      	and	A, dp:0x85 <__bist_stat_end+0x3b>
    8cd4:	2636      	or	X, [S-55]
    8cd6:	b15c      	adc	A, dp:0x5c <__bist_stat_end+0x12>
    8cd8:	a588      	or	A, dp:0x88 <__bist_stat_end+0x3e>
    8cda:	1102      	call	0x8ee0 <__mlx4_flash_start+0xee0>
    8cdc:	a584      	or	A, dp:0x84 <__bist_stat_end+0x3a>
    8cde:	1101      	call	0x8ee2 <__mlx4_flash_start+0xee2>
    8ce0:	26ad      	or	X, io:0x2d <_ml_driver_mode+0x9>
    8ce2:	b359      	adc	A, ep:0x59 <__bist_stat_end+0xf>
    8ce4:	b158      	adc	A, dp:0x58 <__bist_stat_end+0xe>
    8ce6:	4592      	mov	dp:0x92 <__bist_stat_end+0x48>, YL
    8ce8:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8cea:	b680      	and	A, io:0x0 <__data_dp_size>
    8cec:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    8cee:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8cf0:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    8cf2:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    8cf4:	b359      	adc	A, ep:0x59 <__bist_stat_end+0xf>
    8cf6:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    8cf8:	834e      	add	AL, ep:0x4e <__bist_stat_end+0x4>
    8cfa:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    8cfc:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    8cfe:	724f      	lod	A, [S-80]
    8d00:	b358      	adc	A, ep:0x58 <__bist_stat_end+0xe>
    8d02:	b259      	adc	A, [S-90]
    8d04:	b53e      	and	A, dp:0x3e <_page_buffer>
    8d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    8d08:	0102      	jmp	0x8f0e <__mlx4_flash_start+0xf0e>
    8d0a:	0005      	jmp	0x8d16 <__mlx4_flash_start+0xd16>
    8d0c:	269c      	or	X, io:0x1c <_LinFrameDataBuffer+0x4>
    8d0e:	e304      	add	Y, ep:0x4 <__data_size>
    8d10:	ea05      	sub	Y, [S-6]
    8d12:	0001      	jmp	0x8d16 <__mlx4_flash_start+0xd16>
    8d14:	269c      	or	X, io:0x1c <_LinFrameDataBuffer+0x4>
    8d16:	834e      	add	AL, ep:0x4e <__bist_stat_end+0x4>
    8d18:	8a4f      	sub	AL, [S-80]
    8d1a:	e788      	or	Y, ep:0x88 <__bist_stat_end+0x3e>
    8d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    8d1e:	0003      	jmp	0x8d26 <__mlx4_flash_start+0xd26>
    8d20:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    8d22:	4610      	mov	[S-17], YL
    8d24:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    8d28:	0102      	jmp	0x8f2e <__mlx4_flash_start+0xf2e>
    8d2a:	0004      	jmp	0x8d34 <__mlx4_flash_start+0xd34>
    8d2c:	26ad      	or	X, io:0x2d <_ml_driver_mode+0x9>
    8d2e:	e304      	add	Y, ep:0x4 <__data_size>
    8d30:	ea05      	sub	Y, [S-6]
    8d32:	100d      	call	0x8d4e <__mlx4_flash_start+0xd4e>
    8d34:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8d36:	2636      	or	X, [S-55]
    8d38:	c34e      	add	AH, ep:0x4e <__bist_stat_end+0x4>
    8d3a:	ca4f      	sub	AH, [S-80]
    8d3c:	e783      	or	Y, ep:0x83 <__bist_stat_end+0x39>
    8d3e:	ee86      	cmp	Y, io:0x6 <__bss_size>
    8d40:	1003      	call	0x8d48 <__mlx4_flash_start+0xd48>
    8d42:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8d44:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    8d46:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    8d4a:	0102      	jmp	0x8f50 <__mlx4_flash_start+0xf50>
    8d4c:	1004      	call	0x8d56 <__mlx4_flash_start+0xd56>
    8d4e:	26ad      	or	X, io:0x2d <_ml_driver_mode+0x9>
    8d50:	e304      	add	Y, ep:0x4 <__data_size>
    8d52:	ea05      	sub	Y, [S-6]
    8d54:	0002      	jmp	0x8d5a <__mlx4_flash_start+0xd5a>
    8d56:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8d58:	2636      	or	X, [S-55]
    8d5a:	4d58      	mov	dp:0x58 <__bist_stat_end+0xe>, YH
    8d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    8d5e:	b73e      	and	A, ep:0x3e <_page_buffer>
    8d60:	7306      	lod	A, ep:0x6 <__bss_size>
    8d62:	4c02 7ccb 	add	D, #2097315019
    8d66:	7d02 
    8d68:	b25e      	adc	A, [S-95]
    8d6a:	f681      	and	Y, io:0x1 <__data_dp_size+0x1>
    8d6c:	725e      	lod	A, [S-95]
    8d6e:	344a      	and	X, #74
    8d70:	3906      	subc	X, dp:0x6 <__bss_size>
    8d72:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    8d74:	724e      	lod	A, [S-79]
    8d76:	7245      	lod	A, [S-70]
    8d78:	b239      	adc	A, [S-58]
    8d7a:	7271      	lod	A, [S-114]
    8d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    8d7e:	7239      	lod	A, [S-58]
    8d80:	5c00      	dec	S
    8d82:	4d1c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, YH
    8d84:	4962      	mov	dp:0x62 <__bist_stat_end+0x18>, AH
    8d86:	4d2c      	mov	dp:0x2c <_ml_driver_mode+0x8>, YH
    8d88:	492e      	mov	dp:0x2e <_ml_driver_mode+0xa>, AH
    8d8a:	b680      	and	A, io:0x0 <__data_dp_size>
    8d8c:	720d      	lod	A, [S-14]
    8d8e:	3807      	subc	X, #7
    8d90:	380e      	subc	X, #14
    8d92:	3430      	and	X, #48
    8d94:	580e      	inc	S, #15
    8d96:	0803      	clrb	dp:0x00.3
    8d98:	0907      	clrb	io:0x00.7
    8d9a:	62e6      	lod	AL, Y
    8d9c:	26ca      	or	X, [--PC]
    8d9e:	623a      	lod	AL, [S-59]
    8da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    8da2:	0101      	jmp	0x8fa6 <__mlx4_flash_start+0xfa6>
    8da4:	26ca      	or	X, [--PC]
    8da6:	26f1      	or	X, [Y+1]
    8da8:	623a      	lod	AL, [S-59]
    8daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    8dac:	1101      	call	0x8fb0 <__mlx4_flash_start+0xfb0>
    8dae:	26f1      	or	X, [Y+1]
    8db0:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    8db2:	1105      	call	0x8fbe <__mlx4_flash_start+0xfbe>
    8db4:	626f      	lod	AL, [S-112]
    8db6:	0001      	jmp	0x8dba <__mlx4_flash_start+0xdba>
    8db8:	26ca      	or	X, [--PC]
    8dba:	b586      	and	A, dp:0x86 <__bist_stat_end+0x3c>
    8dbc:	29d4      	sub	X, dp:0xd4 <__bist_stat_end+0x8a>
    8dbe:	b239      	adc	A, [S-58]
    8dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    8dc2:	110e      	call	0x8fe0 <__mlx4_flash_start+0xfe0>
    8dc4:	b680      	and	A, io:0x0 <__data_dp_size>
    8dc6:	e24e      	add	Y, [S-79]
    8dc8:	1108      	call	0x8fda <__mlx4_flash_start+0xfda>
    8dca:	6259      	lod	AL, [S-90]
    8dcc:	6266      	lod	AL, [S-103]
    8dce:	0007      	jmp	0x8dde <__mlx4_flash_start+0xdde>
    8dd0:	b585      	and	A, dp:0x85 <__bist_stat_end+0x3b>
    8dd2:	b271      	adc	A, [S-114]
    8dd4:	7239      	lod	A, [S-58]
    8dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    8dd8:	2495      	or	X, #-107
    8dda:	724e      	lod	A, [S-79]
    8ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    8dde:	26ca      	or	X, [--PC]
    8de0:	26ca      	or	X, [--PC]
    8de2:	b33a      	adc	A, ep:0x3a <_LINBaud>
    8de4:	f782      	and	Y, ep:0x82 <__bist_stat_end+0x38>
    8de6:	733a      	lod	A, ep:0x3a <_LINBaud>
    8de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    8dea:	7c4c      	lod	X, #76
    8dec:	3805      	subc	X, #5
    8dee:	3808      	subc	X, #8
    8df0:	3906      	subc	X, dp:0x6 <__bss_size>
    8df2:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8df4:	4940      	mov	dp:0x40 <_page_buffer+0x2>, AH
    8df6:	4942      	mov	dp:0x42 <__bss_end>, AH
    8df8:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    8dfa:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    8dfc:	b589      	and	A, dp:0x89 <__bist_stat_end+0x3f>
    8dfe:	580a      	inc	S, #11
    8e00:	0904      	clrb	io:0x00.4
    8e02:	7172      	lod	A, dp:0x72 <__bist_stat_end+0x28>
    8e04:	62e6      	lod	AL, Y
    8e06:	b172      	adc	A, dp:0x72 <__bist_stat_end+0x28>
    8e08:	26ff      	or	X, [X+7]
    8e0a:	623a      	lod	AL, [S-59]
    8e0c:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8e0e:	4008      	jmp	fp0:0x40
    8e10:	6346      	lod	AL, ep:0x46 <_bistError>
    8e12:	a58f      	or	A, dp:0x8f <__bist_stat_end+0x45>
    8e14:	0101      	jmp	0x9018 <__mlx4_flash_start+0x1018>
    8e16:	2726      	or	X, ep:0x26 <_ml_driver_mode+0x2>
    8e18:	1409      	call	0x862c <__mlx4_flash_start+0x62c>
    8e1a:	3807      	subc	X, #7
    8e1c:	380e      	subc	X, #14
    8e1e:	3430      	and	X, #48
    8e20:	27bd      	or	X, ep:0xbd <__bist_stat_end+0x73>
    8e22:	b239      	adc	A, [S-58]
    8e24:	7238      	lod	A, [S-57]
    8e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    8e28:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8e2a:	24a3      	or	X, #-93
    8e2c:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    8e2e:	b239      	adc	A, [S-58]
    8e30:	7238      	lod	A, [S-57]
    8e32:	4040      	jmp	fp2:0x00
    8e34:	624a      	lod	AL, [S-75]
    8e36:	1504      	call	0x8840 <__mlx4_flash_start+0x840>
    8e38:	b23b      	adc	A, [S-60]
    8e3a:	f681      	and	Y, io:0x1 <__data_dp_size+0x1>
    8e3c:	723b      	lod	A, [S-60]
    8e3e:	24a3      	or	X, #-93
    8e40:	b23b      	adc	A, [S-60]
    8e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    8e44:	723b      	lod	A, [S-60]
    8e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    8e48:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8e4a:	24a3      	or	X, #-93
    8e4c:	4060      	jmp	fp3:0x00
    8e4e:	624a      	lod	AL, [S-75]
    8e50:	e589      	or	Y, dp:0x89 <__bist_stat_end+0x3f>
    8e52:	1109      	call	0x9066 <__mlx4_flash_start+0x1066>
    8e54:	b339      	adc	A, ep:0x39 <__bss_dp_end+0x1>
    8e56:	e78f      	or	Y, ep:0x8f <__bist_stat_end+0x45>
    8e58:	010a      	jmp	0x906e <__mlx4_flash_start+0x106e>
    8e5a:	1409      	call	0x866e <__mlx4_flash_start+0x66e>
    8e5c:	b686      	and	A, io:0x6 <__bss_size>
    8e5e:	7338      	lod	A, ep:0x38 <__bss_dp_end>
    8e60:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8e62:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8e64:	24a3      	or	X, #-93
    8e66:	4060      	jmp	fp3:0x00
    8e68:	622e      	lod	AL, [S-47]
    8e6a:	0501      	jmp	0x886e <__mlx4_flash_start+0x86e>
    8e6c:	2739      	or	X, ep:0x39 <__bss_dp_end+0x1>
    8e6e:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8e70:	26ff      	or	X, [X+7]
    8e72:	e583      	or	Y, dp:0x83 <__bist_stat_end+0x39>
    8e74:	1001      	call	0x8e78 <__mlx4_flash_start+0xe78>
    8e76:	274c      	or	X, ep:0x4c <__bist_stat_end+0x2>
    8e78:	b791      	and	A, ep:0x91 <__bist_stat_end+0x47>
    8e7a:	d78f      	and	AH, ep:0x8f <__bist_stat_end+0x45>
    8e7c:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8e7e:	bf87      	xor	A, ep:0x87 <__bist_stat_end+0x3d>
    8e80:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    8e82:	4060      	jmp	fp3:0x00
    8e84:	4d62      	mov	dp:0x62 <__bist_stat_end+0x18>, YH
    8e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    8e88:	b63d      	and	A, [S-62]
    8e8a:	721e      	lod	A, [S-31]
    8e8c:	4962      	mov	dp:0x62 <__bist_stat_end+0x18>, AH
    8e8e:	4d2e      	mov	dp:0x2e <_ml_driver_mode+0xa>, YH
    8e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    8e92:	b63d      	and	A, [S-62]
    8e94:	721f      	lod	A, [S-32]
    8e96:	492e      	mov	dp:0x2e <_ml_driver_mode+0xa>, AH
    8e98:	7492      	lod	PC, #-110
    8e9a:	be81      	xor	A, io:0x1 <__data_dp_size+0x1>
    8e9c:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    8e9e:	1101      	call	0x90a2 <__mlx4_flash_start+0x10a2>
    8ea0:	4692      	mov	io:0x12 <_stFixedRamNAD+0x2>, YL
    8ea2:	d245      	adc	AH, [S-70]
    8ea4:	7245      	lod	A, [S-70]
    8ea6:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    8ea8:	6c01      	lod	YH, #1
    8eaa:	2768      	or	X, ep:0x68 <__bist_stat_end+0x1e>
    8eac:	277b      	or	X, ep:0x7b <__bist_stat_end+0x31>
    8eae:	278a      	or	X, ep:0x8a <__bist_stat_end+0x40>
    8eb0:	26ff      	or	X, [X+7]
    8eb2:	26ff      	or	X, [X+7]
    8eb4:	26ff      	or	X, [X+7]
    8eb6:	26ff      	or	X, [X+7]
    8eb8:	275e      	or	X, ep:0x5e <__bist_stat_end+0x14>
    8eba:	26ff      	or	X, [X+7]
    8ebc:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    8ebe:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    8ec0:	0106      	jmp	0x90ce <__mlx4_flash_start+0x10ce>
    8ec2:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    8ec4:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    8ec6:	b271      	adc	A, [S-114]
    8ec8:	7238      	lod	A, [S-57]
    8eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    8ecc:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8ece:	26ff      	or	X, [X+7]
    8ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    8ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    8ed4:	bf82      	xor	A, ep:0x82 <__bist_stat_end+0x38>
    8ed6:	d345      	adc	AH, ep:0x45 <_bistResetInfo+0x1>
    8ed8:	b209      	adc	A, [S-10]
    8eda:	720f      	lod	A, [S-16]
    8edc:	be81      	xor	A, io:0x1 <__data_dp_size+0x1>
    8ede:	d792      	and	AH, ep:0x92 <__bist_stat_end+0x48>
    8ee0:	1101      	call	0x90e4 <__mlx4_flash_start+0x10e4>
    8ee2:	26ff      	or	X, [X+7]
    8ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    8ee6:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    8ee8:	b638      	and	A, [S-57]
    8eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    8eec:	1103      	call	0x90f4 <__mlx4_flash_start+0x10f4>
    8eee:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    8ef0:	f784      	and	Y, ep:0x84 <__bist_stat_end+0x3a>
    8ef2:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    8ef4:	24a3      	or	X, #-93
    8ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    8ef8:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8efa:	0102      	jmp	0x9100 <__mlx4_flash_start+0x1100>
    8efc:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8efe:	26ff      	or	X, [X+7]
    8f00:	b360      	adc	A, ep:0x60 <__bist_stat_end+0x16>
    8f02:	b161      	adc	A, dp:0x61 <__bist_stat_end+0x17>
    8f04:	f580      	and	Y, dp:0x80 <__bist_stat_end+0x36>
    8f06:	b6a7      	and	A, io:0x27 <_ml_driver_mode+0x3>
    8f08:	7260      	lod	A, [S-97]
    8f0a:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    8f0c:	b6a7      	and	A, io:0x27 <_ml_driver_mode+0x3>
    8f0e:	7261      	lod	A, [S-98]
    8f10:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    8f12:	26ff      	or	X, [X+7]
    8f14:	b209      	adc	A, [S-10]
    8f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    8f18:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8f1a:	1102      	call	0x9120 <__mlx4_flash_start+0x1120>
    8f1c:	f781      	and	Y, ep:0x81 <__bist_stat_end+0x37>
    8f1e:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    8f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    8f22:	4610      	mov	[S-17], YL
    8f24:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8f26:	4610      	mov	[S-17], YL
    8f28:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    8f2a:	720d      	lod	A, [S-14]
    8f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    8f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    8f30:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8f32:	0104      	jmp	0x913c <__mlx4_flash_start+0x113c>
    8f34:	b31f      	adc	A, ep:0x1f <__ramfunc_size+0x1>
    8f36:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8f38:	1105      	call	0x9144 <__mlx4_flash_start+0x1144>
    8f3a:	8788      	or	AL, ep:0x88 <__bist_stat_end+0x3e>
    8f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    8f3e:	b680      	and	A, io:0x0 <__data_dp_size>
    8f40:	720d      	lod	A, [S-14]
    8f42:	27b5      	or	X, ep:0xb5 <__bist_stat_end+0x6b>
    8f44:	3bea      	subc	X, ep:0xea <__bist_stat_end+0xa0>
    8f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    8f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    8f4a:	4050      	jmp	fp2:0x80
    8f4c:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    8f4e:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    8f50:	f588      	and	Y, dp:0x88 <__bist_stat_end+0x3e>
    8f52:	b6a7      	and	A, io:0x27 <_ml_driver_mode+0x3>
    8f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    8f56:	0105      	jmp	0x9162 <__mlx4_flash_start+0x1162>
    8f58:	b20d      	adc	A, [S-14]
    8f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    8f5c:	720d      	lod	A, [S-14]
    8f5e:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8f60:	26ff      	or	X, [X+7]
    8f62:	720d      	lod	A, [S-14]
    8f64:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    8f66:	b7a7      	and	A, ep:0xa7 <__bist_stat_end+0x5d>
    8f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    8f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    8f6c:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    8f6e:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    8f70:	3beb      	subc	X, ep:0xeb <__bist_stat_end+0xa1>
    8f72:	7360      	lod	A, ep:0x60 <__bist_stat_end+0x16>
    8f74:	7161      	lod	A, dp:0x61 <__bist_stat_end+0x17>
    8f76:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    8f78:	26ff      	or	X, [X+7]
    8f7a:	1501      	call	0x897e <__mlx4_flash_start+0x97e>
    8f7c:	2800      	sub	X, #0
    8f7e:	b35c      	adc	A, ep:0x5c <__bist_stat_end+0x12>
    8f80:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    8f82:	1109      	call	0x9196 <__mlx4_flash_start+0x1196>
    8f84:	f784      	and	Y, ep:0x84 <__bist_stat_end+0x3a>
    8f86:	735c      	lod	A, ep:0x5c <__bist_stat_end+0x12>
    8f88:	4804      	mulu	D, A, [Y++]
    8f8a:	b73e      	and	A, ep:0x3e <_page_buffer>
    8f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    8f8e:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8f90:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    8f92:	0101      	jmp	0x9196 <__mlx4_flash_start+0x1196>
    8f94:	24a3      	or	X, #-93
    8f96:	5cc2      	neg	A
    8f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    8f9a:	a588      	or	A, dp:0x88 <__bist_stat_end+0x3e>
    8f9c:	0103      	jmp	0x91a4 <__mlx4_flash_start+0x11a4>
    8f9e:	7ca8      	lod	X, #-88
    8fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    8fa2:	24a3      	or	X, #-93
    8fa4:	b261      	adc	A, [S-98]
    8fa6:	4600      	mov	[S-1], YL
    8fa8:	e681      	or	Y, io:0x1 <__data_dp_size+0x1>
    8faa:	0104      	jmp	0x91b4 <__mlx4_flash_start+0x11b4>
    8fac:	0001      	jmp	0x8fb0 <__mlx4_flash_start+0xfb0>
    8fae:	24a3      	or	X, #-93
    8fb0:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    8fb2:	27e7      	or	X, ep:0xe7 <__bist_stat_end+0x9d>
    8fb4:	5c00      	dec	S
    8fb6:	b35f      	adc	A, ep:0x5f <__bist_stat_end+0x15>
    8fb8:	a783      	or	A, ep:0x83 <__bist_stat_end+0x39>
    8fba:	1103      	call	0x91c2 <__mlx4_flash_start+0x11c2>
    8fbc:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8fbe:	bf83      	xor	A, ep:0x83 <__bist_stat_end+0x39>
    8fc0:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    8fc2:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    8fc4:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    8fc6:	1102      	call	0x91cc <__mlx4_flash_start+0x11cc>
    8fc8:	b784      	and	A, ep:0x84 <__bist_stat_end+0x3a>
    8fca:	62bc      	lod	AL, io:0x3c <__data_end>
    8fcc:	b781      	and	A, ep:0x81 <__bist_stat_end+0x37>
    8fce:	b260      	adc	A, [S-97]
    8fd0:	725b      	lod	A, [S-92]
    8fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    8fd4:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    8fd6:	724c      	lod	A, [S-77]
    8fd8:	c681      	or	AH, io:0x1 <__data_dp_size+0x1>
    8fda:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8fdc:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    8fde:	b556      	and	A, dp:0x56 <__bist_stat_end+0xc>
    8fe0:	7137      	lod	A, dp:0x37 <_ml_driver_mode+0x13>
    8fe2:	c681      	or	AH, io:0x1 <__data_dp_size+0x1>
    8fe4:	b556      	and	A, dp:0x56 <__bist_stat_end+0xc>
    8fe6:	7136      	lod	A, dp:0x36 <_ml_driver_mode+0x12>
    8fe8:	b25b      	adc	A, [S-92]
    8fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    8fec:	4788      	mov	ep:0x88 <__bist_stat_end+0x3e>, YL
    8fee:	f693      	and	Y, io:0x13 <_stFixedRamNAD+0x3>
    8ff0:	725b      	lod	A, [S-92]
    8ff2:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    8ff4:	0002      	jmp	0x8ffa <__mlx4_flash_start+0xffa>
    8ff6:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    8ff8:	27fe      	or	X, ep:0xfe <__bist_stat_end+0xb4>
    8ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    8ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    8ffe:	281f      	sub	X, #31
    9000:	b239      	adc	A, [S-58]
    9002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    9004:	0101      	jmp	0x9208 <__mlx4_flash_start+0x1208>
    9006:	2814      	sub	X, #20
    9008:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    900a:	a782      	or	A, ep:0x82 <__bist_stat_end+0x38>
    900c:	0103      	jmp	0x9214 <__mlx4_flash_start+0x1214>
    900e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    9010:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    9012:	24a3      	or	X, #-93
    9014:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    9016:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    9018:	0107      	jmp	0x9228 <__mlx4_flash_start+0x1228>
    901a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    901c:	e580      	or	Y, dp:0x80 <__bist_stat_end+0x36>
    901e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    9020:	ed80      	cmp	Y, dp:0x80 <__bist_stat_end+0x36>
    9022:	1102      	call	0x9228 <__mlx4_flash_start+0x1228>
    9024:	f782      	and	Y, ep:0x82 <__bist_stat_end+0x38>
    9026:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    9028:	e24c      	add	Y, [S-77]
    902a:	0109      	jmp	0x923e <__mlx4_flash_start+0x123e>
    902c:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    902e:	bf87      	xor	A, ep:0x87 <__bist_stat_end+0x3d>
    9030:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    9032:	4692      	mov	io:0x12 <_stFixedRamNAD+0x2>, YL
    9034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    9036:	77e6      	lod	PC, ep:0xe6 <__bist_stat_end+0x9c>
    9038:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    903a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    903c:	77e6      	lod	PC, ep:0xe6 <__bist_stat_end+0x9c>
    903e:	b139      	adc	A, dp:0x39 <__bss_dp_end+0x1>
    9040:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    9042:	7139      	lod	A, dp:0x39 <__bss_dp_end+0x1>
    9044:	1106      	call	0x9252 <__mlx4_flash_start+0x1252>
    9046:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    9048:	4930      	mov	dp:0x30 <_ml_driver_mode+0xc>, AH
    904a:	b35b      	adc	A, ep:0x5b <__bist_stat_end+0x11>
    904c:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    904e:	1107      	call	0x925e <__mlx4_flash_start+0x125e>
    9050:	2849      	sub	X, #73
    9052:	b208      	adc	A, [S-9]
    9054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    9056:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    9058:	e14c      	add	Y, dp:0x4c <__bist_stat_end+0x2>
    905a:	0105      	jmp	0x9266 <__mlx4_flash_start+0x1266>
    905c:	6233      	lod	AL, [S-52]
    905e:	7cce      	lod	X, #-50
    9060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    9062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    9064:	26ca      	or	X, [--PC]
    9066:	820a      	add	AL, [S-11]
    9068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    906a:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    906c:	8f80      	cmp	AL, ep:0x80 <__bist_stat_end+0x36>
    906e:	0103      	jmp	0x9276 <__mlx4_flash_start+0x1276>
    9070:	b684      	and	A, io:0x4 <__data_size>
    9072:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    9074:	24a3      	or	X, #-93
    9076:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    9078:	a782      	or	A, ep:0x82 <__bist_stat_end+0x38>
    907a:	0105      	jmp	0x9286 <__mlx4_flash_start+0x1286>
    907c:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    907e:	bf8d      	xor	A, ep:0x8d <__bist_stat_end+0x43>
    9080:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    9082:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    9084:	29d4      	sub	X, dp:0xd4 <__bist_stat_end+0x8a>
    9086:	b35e      	adc	A, ep:0x5e <__bist_stat_end+0x14>
    9088:	f782      	and	Y, ep:0x82 <__bist_stat_end+0x38>
    908a:	735e      	lod	A, ep:0x5e <__bist_stat_end+0x14>
    908c:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    908e:	62bc      	lod	AL, io:0x3c <__data_end>
    9090:	24a3      	or	X, #-93
    9092:	b58f      	and	A, dp:0x8f <__bist_stat_end+0x45>
    9094:	7139      	lod	A, dp:0x39 <__bss_dp_end+0x1>
    9096:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    9098:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    909a:	4940      	mov	dp:0x40 <_page_buffer+0x2>, AH
    909c:	4942      	mov	dp:0x42 <__bss_end>, AH
    909e:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    90a0:	b738      	and	A, ep:0x38 <__bss_dp_end>
    90a2:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    90a4:	110b      	call	0x92bc <__mlx4_flash_start+0x12bc>
    90a6:	b239      	adc	A, [S-58]
    90a8:	7238      	lod	A, [S-57]
    90aa:	b685      	and	A, io:0x5 <__data_size+0x1>
    90ac:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    90ae:	b23b      	adc	A, [S-60]
    90b0:	f684      	and	Y, io:0x4 <__data_size>
    90b2:	723b      	lod	A, [S-60]
    90b4:	b25e      	adc	A, [S-95]
    90b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    90b8:	725e      	lod	A, [S-95]
    90ba:	24a1      	or	X, #-95
    90bc:	3805      	subc	X, #5
    90be:	3808      	subc	X, #8
    90c0:	346b      	and	X, #107
    90c2:	34b0      	and	X, #-80
    90c4:	4930      	mov	dp:0x30 <_ml_driver_mode+0xc>, AH
    90c6:	b34c      	adc	A, ep:0x4c <__bist_stat_end+0x2>
    90c8:	c781      	or	AH, ep:0x81 <__bist_stat_end+0x37>
    90ca:	4796      	mov	ep:0x96 <__bist_stat_end+0x4c>, YL
    90cc:	b65b      	and	A, [S-92]
    90ce:	7236      	lod	A, [S-55]
    90d0:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    90d2:	b65b      	and	A, [S-92]
    90d4:	7237      	lod	A, [S-56]
    90d6:	b364      	adc	A, ep:0x64 <__bist_stat_end+0x1a>
    90d8:	bf84      	xor	A, ep:0x84 <__bist_stat_end+0x3a>
    90da:	0101      	jmp	0x92de <__mlx4_flash_start+0x12de>
    90dc:	b581      	and	A, dp:0x81 <__bist_stat_end+0x37>
    90de:	858a      	or	AL, dp:0x8a <__bist_stat_end+0x40>
    90e0:	715d      	lod	A, dp:0x5d <__bist_stat_end+0x13>
    90e2:	b164      	adc	A, dp:0x64 <__bist_stat_end+0x1a>
    90e4:	bd83      	xor	A, dp:0x83 <__bist_stat_end+0x39>
    90e6:	8582      	or	AL, dp:0x82 <__bist_stat_end+0x38>
    90e8:	714d      	lod	A, dp:0x4d <__bist_stat_end+0x3>
    90ea:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    90ec:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    90ee:	5c00      	dec	S
    90f0:	0101      	jmp	0x92f4 <__mlx4_flash_start+0x12f4>
    90f2:	5c02      	dec	S, #3
    90f4:	580e      	inc	S, #15
    90f6:	0809      	clrb	dp:0x01.1
    90f8:	090c      	clrb	io:0x01.4
    90fa:	62e6      	lod	AL, Y
    90fc:	b16f      	adc	A, dp:0x6f <__bist_stat_end+0x25>
    90fe:	a588      	or	A, dp:0x88 <__bist_stat_end+0x3e>
    9100:	1103      	call	0x9308 <__mlx4_flash_start+0x1308>
    9102:	a584      	or	A, dp:0x84 <__bist_stat_end+0x3a>
    9104:	0105      	jmp	0x9310 <__mlx4_flash_start+0x1310>
    9106:	24a3      	or	X, #-93
    9108:	2892      	sub	X, #-110
    910a:	623a      	lod	AL, [S-59]
    910c:	a688      	or	A, io:0x8 <__bist_stat_size>
    910e:	0106      	jmp	0x931c <__mlx4_flash_start+0x131c>
    9110:	287a      	sub	X, #122
    9112:	623a      	lod	AL, [S-59]
    9114:	a788      	or	A, ep:0x88 <__bist_stat_end+0x3e>
    9116:	1102      	call	0x931c <__mlx4_flash_start+0x131c>
    9118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    911a:	1101      	call	0x931e <__mlx4_flash_start+0x131e>
    911c:	2853      	sub	X, #83
    911e:	a781      	or	A, ep:0x81 <__bist_stat_end+0x37>
    9120:	1107      	call	0x9330 <__mlx4_flash_start+0x1330>
    9122:	287a      	sub	X, #122
    9124:	b14d      	adc	A, dp:0x4d <__bist_stat_end+0x3>
    9126:	e580      	or	Y, dp:0x80 <__bist_stat_end+0x36>
    9128:	1101      	call	0x932c <__mlx4_flash_start+0x132c>
    912a:	28a6      	sub	X, #-90
    912c:	5cc2      	neg	A
    912e:	287a      	sub	X, #122
    9130:	6241      	lod	AL, [S-66]
    9132:	0001      	jmp	0x9136 <__mlx4_flash_start+0x1136>
    9134:	2711      	or	X, ep:0x11 <_stFixedRamNAD+0x1>
    9136:	b14d      	adc	A, dp:0x4d <__bist_stat_end+0x3>
    9138:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    913a:	1101      	call	0x933e <__mlx4_flash_start+0x133e>
    913c:	6346      	lod	AL, ep:0x46 <_bistError>
    913e:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    9140:	8d80      	cmp	AL, dp:0x80 <__bist_stat_end+0x36>
    9142:	714d      	lod	A, dp:0x4d <__bist_stat_end+0x3>
    9144:	e580      	or	Y, dp:0x80 <__bist_stat_end+0x36>
    9146:	1101      	call	0x934a <__mlx4_flash_start+0x134a>
    9148:	0501      	jmp	0x8b4c <__mlx4_flash_start+0xb4c>
    914a:	287a      	sub	X, #122
    914c:	b36f      	adc	A, ep:0x6f <__bist_stat_end+0x25>
    914e:	bf87      	xor	A, ep:0x87 <__bist_stat_end+0x3d>
    9150:	736f      	lod	A, ep:0x6f <__bist_stat_end+0x25>
    9152:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    9154:	3468      	and	X, #104
    9156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    9158:	b203      	adc	A, [S-4]
    915a:	4610      	mov	[S-17], YL
    915c:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    915e:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    9160:	724f      	lod	A, [S-80]
    9162:	4c4f      	dadju	D, [X]
    9164:	6217      	lod	AL, [S-24]
    9166:	6233      	lod	AL, [S-52]
    9168:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    916a:	7170      	lod	A, dp:0x70 <__bist_stat_end+0x26>
    916c:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    916e:	484f      	macu	D, AL, [X]
    9170:	380a      	subc	X, #10
    9172:	3420      	and	X, #32
    9174:	3965      	subc	X, dp:0x65 <__bist_stat_end+0x1b>
    9176:	3501      	and	X, dp:0x1 <__data_dp_size+0x1>
    9178:	37a4      	and	X, ep:0xa4 <__bist_stat_end+0x5a>
    917a:	346b      	and	X, #107
    917c:	5806      	inc	S, #7
    917e:	090e      	clrb	io:0x01.6
    9180:	623a      	lod	AL, [S-59]
    9182:	484f      	macu	D, AL, [X]
    9184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    9186:	b203      	adc	A, [S-4]
    9188:	4610      	mov	[S-17], YL
    918a:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    918c:	834e      	add	AL, ep:0x4e <__bist_stat_end+0x4>
    918e:	8a4f      	sub	AL, [S-80]
    9190:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    9192:	724f      	lod	A, [S-80]
    9194:	4c4f      	dadju	D, [X]
    9196:	3409      	and	X, #9
    9198:	3808      	subc	X, #8
    919a:	28eb      	sub	X, #-21
    919c:	623a      	lod	AL, [S-59]
    919e:	a688      	or	A, io:0x8 <__bist_stat_size>
    91a0:	1101      	call	0x93a4 <__mlx4_flash_start+0x13a4>
    91a2:	28fb      	sub	X, #-5
    91a4:	351b      	and	X, dp:0x1b <_LinFrameDataBuffer+0x3>
    91a6:	b582      	and	A, dp:0x82 <__bist_stat_end+0x38>
    91a8:	b682      	and	A, io:0x2 <_LinCmnd>
    91aa:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    91ac:	b681      	and	A, io:0x1 <__data_dp_size+0x1>
    91ae:	7201      	lod	A, [S-2]
    91b0:	2487      	or	X, #-121
    91b2:	6217      	lod	AL, [S-24]
    91b4:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    91b6:	0007      	jmp	0x91c6 <__mlx4_flash_start+0x11c6>
    91b8:	1107      	call	0x93c8 <__mlx4_flash_start+0x13c8>
    91ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    91bc:	d78f      	and	AH, ep:0x8f <__bist_stat_end+0x45>
    91be:	7234      	lod	A, [S-53]
    91c0:	7335      	lod	A, ep:0x35 <_ml_driver_mode+0x11>
    91c2:	6228      	lod	AL, [S-41]
    91c4:	28e5      	sub	X, #-27
    91c6:	2906      	sub	X, dp:0x6 <__bss_size>
    91c8:	6233      	lod	AL, [S-52]
    91ca:	4040      	jmp	fp2:0x00
    91cc:	3501      	and	X, dp:0x1 <__data_dp_size+0x1>
    91ce:	580a      	inc	S, #11
    91d0:	0902      	clrb	io:0x00.2
    91d2:	62e6      	lod	AL, Y
    91d4:	28e7      	sub	X, #-25
    91d6:	623a      	lod	AL, [S-59]
    91d8:	a684      	or	A, io:0x4 <__data_size>
    91da:	110d      	call	0x93f6 <__mlx4_flash_start+0x13f6>
    91dc:	b370      	adc	A, ep:0x70 <__bist_stat_end+0x26>
    91de:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    91e0:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    91e2:	624a      	lod	AL, [S-75]
    91e4:	6346      	lod	AL, ep:0x46 <_bistError>
    91e6:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    91e8:	e15d      	add	Y, dp:0x5d <__bist_stat_end+0x13>
    91ea:	0109      	jmp	0x93fe <__mlx4_flash_start+0x13fe>
    91ec:	622e      	lod	AL, [S-47]
    91ee:	b370      	adc	A, ep:0x70 <__bist_stat_end+0x26>
    91f0:	4784      	mov	ep:0x84 <__bist_stat_end+0x3a>, YL
    91f2:	7370      	lod	A, ep:0x70 <__bist_stat_end+0x26>
    91f4:	28e6      	sub	X, #-26
    91f6:	4040      	jmp	fp2:0x00
    91f8:	624a      	lod	AL, [S-75]
    91fa:	351b      	and	X, dp:0x1b <_LinFrameDataBuffer+0x3>
    91fc:	2853      	sub	X, #83
    91fe:	b370      	adc	A, ep:0x70 <__bist_stat_end+0x26>
    9200:	4040      	jmp	fp2:0x00
    9202:	4784      	mov	ep:0x84 <__bist_stat_end+0x3a>, YL
    9204:	7370      	lod	A, ep:0x70 <__bist_stat_end+0x26>
    9206:	7ccf      	lod	X, #-49
    9208:	7d34      	lod	X, dp:0x34 <_ml_driver_mode+0x10>
    920a:	28d9      	sub	X, #-39
    920c:	351b      	and	X, dp:0x1b <_LinFrameDataBuffer+0x3>
    920e:	580a      	inc	S, #11
    9210:	0902      	clrb	io:0x00.2
    9212:	62e6      	lod	AL, Y
    9214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    9216:	623a      	lod	AL, [S-59]
    9218:	a684      	or	A, io:0x4 <__data_size>
    921a:	0101      	jmp	0x941e <__mlx4_flash_start+0x141e>
    921c:	28fb      	sub	X, #-5
    921e:	b15f      	adc	A, dp:0x5f <__bist_stat_end+0x15>
    9220:	a583      	or	A, dp:0x83 <__bist_stat_end+0x39>
    9222:	1103      	call	0x942a <__mlx4_flash_start+0x142a>
    9224:	b100      	adc	A, dp:0x0 <__data_dp_size>
    9226:	a581      	or	A, dp:0x81 <__bist_stat_end+0x37>
    9228:	0102      	jmp	0x942e <__mlx4_flash_start+0x142e>
    922a:	b785      	and	A, ep:0x85 <__bist_stat_end+0x3b>
    922c:	62bc      	lod	AL, io:0x3c <__data_end>
    922e:	24a3      	or	X, #-93
    9230:	3807      	subc	X, #7
    9232:	3809      	subc	X, #9
    9234:	3468      	and	X, #104
    9236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    9238:	b638      	and	A, [S-57]
    923a:	a688      	or	A, io:0x8 <__bist_stat_size>
    923c:	0101      	jmp	0x9440 <__mlx4_flash_start+0x1440>
    923e:	2494      	or	X, #-108
    9240:	b101      	adc	A, dp:0x1 <__data_dp_size+0x1>
    9242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    9244:	7201      	lod	A, [S-2]
    9246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    9248:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    924a:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    924c:	580e      	inc	S, #15
    924e:	0803      	clrb	dp:0x00.3
    9250:	0906      	clrb	io:0x00.6
    9252:	62e6      	lod	AL, Y
    9254:	2926      	sub	X, dp:0x26 <_ml_driver_mode+0x2>
    9256:	623a      	lod	AL, [S-59]
    9258:	a688      	or	A, io:0x8 <__bist_stat_size>
    925a:	010a      	jmp	0x9470 <__mlx4_flash_start+0x1470>
    925c:	248c      	or	X, #-116
    925e:	626f      	lod	AL, [S-112]
    9260:	1007      	call	0x9270 <__mlx4_flash_start+0x1270>
    9262:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    9264:	b684      	and	A, io:0x4 <__data_size>
    9266:	62ca      	lod	AL, [--PC]
    9268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    926a:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    926c:	7370      	lod	A, ep:0x70 <__bist_stat_end+0x26>
    926e:	2a05      	sub	X, [S-6]
    9270:	2926      	sub	X, dp:0x26 <_ml_driver_mode+0x2>
    9272:	5c00      	dec	S
    9274:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    9276:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    9278:	4954      	mov	dp:0x54 <__bist_stat_end+0xa>, AH
    927a:	4956      	mov	dp:0x56 <__bist_stat_end+0xc>, AH
    927c:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    927e:	a78d      	or	A, ep:0x8d <__bist_stat_end+0x43>
    9280:	1103      	call	0x9488 <__mlx4_flash_start+0x1488>
    9282:	4940      	mov	dp:0x40 <_page_buffer+0x2>, AH
    9284:	4942      	mov	dp:0x42 <__bss_end>, AH
    9286:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    9288:	b78e      	and	A, ep:0x8e <__bist_stat_end+0x44>
    928a:	b763      	and	A, ep:0x63 <__bist_stat_end+0x19>
    928c:	773e      	lod	PC, ep:0x3e <_page_buffer>
    928e:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    9290:	735a      	lod	A, ep:0x5a <__bist_stat_end+0x10>
    9292:	736a      	lod	A, ep:0x6a <__bist_stat_end+0x20>
    9294:	736b      	lod	A, ep:0x6b <__bist_stat_end+0x21>
    9296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    9298:	4710      	mov	ep:0x10 <_stFixedRamNAD>, YL
    929a:	734f      	lod	A, ep:0x4f <__bist_stat_end+0x5>
    929c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    929e:	4716      	mov	ep:0x16 <_stFixedRamNAD+0x6>, YL
    92a0:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    92a2:	4c4e      	dadju	D, [X++]
    92a4:	34ef      	and	X, #-17
    92a6:	3985      	subc	X, dp:0x85 <__bist_stat_end+0x3b>
    92a8:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    92aa:	4c4f      	dadju	D, [X]
    92ac:	484f      	macu	D, AL, [X]
    92ae:	3806      	subc	X, #6
    92b0:	380a      	subc	X, #10
    92b2:	3428      	and	X, #40
    92b4:	3beb      	subc	X, ep:0xeb <__bist_stat_end+0xa1>
    92b6:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    92b8:	736d      	lod	A, ep:0x6d <__bist_stat_end+0x23>
    92ba:	b588      	and	A, dp:0x88 <__bist_stat_end+0x3e>
    92bc:	b6a7      	and	A, io:0x27 <_ml_driver_mode+0x3>
    92be:	726e      	lod	A, [S-111]
    92c0:	b23b      	adc	A, [S-60]
    92c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    92c4:	1103      	call	0x94cc <__mlx4_flash_start+0x14cc>
    92c6:	4930      	mov	dp:0x30 <_ml_driver_mode+0xc>, AH
    92c8:	b78c      	and	A, ep:0x8c <__bist_stat_end+0x42>
    92ca:	735b      	lod	A, ep:0x5b <__bist_stat_end+0x11>
    92cc:	2282      	add	X, io:0x2 <_LinCmnd>
    92ce:	622b      	lod	AL, [S-44]
    92d0:	6281      	lod	AL, io:0x1 <__data_dp_size+0x1>
    92d2:	3f88      	xor	X, ep:0x88 <__bist_stat_end+0x3e>
    92d4:	b680      	and	A, io:0x0 <__data_dp_size>
    92d6:	7271      	lod	A, [S-114]
    92d8:	7c54      	lod	X, #84
    92da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    92dc:	773e      	lod	PC, ep:0x3e <_page_buffer>
    92de:	4c04      	add	D, [Y++]
    92e0:	3805      	subc	X, #5
    92e2:	3808      	subc	X, #8
    92e4:	3449      	and	X, #73
    92e6:	3906      	subc	X, dp:0x6 <__bss_size>
    92e8:	3512      	and	X, dp:0x12 <_stFixedRamNAD+0x2>
    92ea:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    92ec:	623a      	lod	AL, [S-59]
    92ee:	b58c      	and	A, dp:0x8c <__bist_stat_end+0x42>
    92f0:	b55d      	and	A, dp:0x5d <__bist_stat_end+0x13>
    92f2:	580a      	inc	S, #11
    92f4:	0902      	clrb	io:0x00.2
    92f6:	62e6      	lod	AL, Y
    92f8:	2979      	sub	X, dp:0x79 <__bist_stat_end+0x2f>
    92fa:	623a      	lod	AL, [S-59]
    92fc:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    92fe:	0102      	jmp	0x9504 <__mlx4_flash_end+0x14>
    9300:	3502      	and	X, dp:0x2 <_LinCmnd>
    9302:	2979      	sub	X, dp:0x79 <__bist_stat_end+0x2f>
    9304:	351b      	and	X, dp:0x1b <_LinFrameDataBuffer+0x3>
    9306:	b271      	adc	A, [S-114]
    9308:	8681      	or	AL, io:0x1 <__data_dp_size+0x1>
    930a:	7271      	lod	A, [S-114]
    930c:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    930e:	1105      	call	0x951a <__mlx4_flash_end+0x2a>
    9310:	e686      	or	Y, io:0x6 <__bss_size>
    9312:	0101      	jmp	0x9516 <__mlx4_flash_end+0x26>
    9314:	296c      	sub	X, dp:0x6c <__bist_stat_end+0x22>
    9316:	b584      	and	A, dp:0x84 <__bist_stat_end+0x3a>
    9318:	29d4      	sub	X, dp:0xd4 <__bist_stat_end+0x8a>
    931a:	3809      	subc	X, #9
    931c:	5806      	inc	S, #7
    931e:	0902      	clrb	io:0x00.2
    9320:	623a      	lod	AL, [S-59]
    9322:	29b2      	sub	X, dp:0xb2 <__bist_stat_end+0x68>
    9324:	623a      	lod	AL, [S-59]
    9326:	a688      	or	A, io:0x8 <__bist_stat_size>
    9328:	0101      	jmp	0x952c <__mlx4_flash_end+0x3c>
    932a:	29b2      	sub	X, dp:0xb2 <__bist_stat_end+0x68>
    932c:	b580      	and	A, dp:0x80 <__bist_stat_end+0x36>
    932e:	7143      	lod	A, dp:0x43 <__bss_end+0x1>
    9330:	7144      	lod	A, dp:0x44 <_bistResetInfo>
    9332:	b304      	adc	A, ep:0x4 <__data_size>
    9334:	b205      	adc	A, [S-6]
    9336:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    9338:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    933a:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    933c:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    933e:	7241      	lod	A, [S-66]
    9340:	7142      	lod	A, dp:0x42 <__bss_end>
    9342:	4792      	mov	ep:0x92 <__bist_stat_end+0x48>, YL
    9344:	4696      	mov	io:0x16 <_stFixedRamNAD+0x6>, YL
    9346:	4596      	mov	dp:0x96 <__bist_stat_end+0x4c>, YL
    9348:	8340      	add	AL, ep:0x40 <_page_buffer+0x2>
    934a:	8a41      	sub	AL, [S-66]
    934c:	8942      	sub	AL, dp:0x42 <__bss_end>
    934e:	7340      	lod	A, ep:0x40 <_page_buffer+0x2>
    9350:	7241      	lod	A, [S-66]
    9352:	7142      	lod	A, dp:0x42 <__bss_end>
    9354:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    9356:	b788      	and	A, ep:0x88 <__bist_stat_end+0x3e>
    9358:	b682      	and	A, io:0x2 <_LinCmnd>
    935a:	62ca      	lod	AL, [--PC]
    935c:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    935e:	f784      	and	Y, ep:0x84 <__bist_stat_end+0x3a>
    9360:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    9362:	24a3      	or	X, #-93
    9364:	6281      	lod	AL, io:0x1 <__data_dp_size+0x1>
    9366:	b271      	adc	A, [S-114]
    9368:	e685      	or	Y, io:0x5 <__data_size+0x1>
    936a:	0103      	jmp	0x9572 <_INDXtbl+0x32>
    936c:	b784      	and	A, ep:0x84 <__bist_stat_end+0x3a>
    936e:	b585      	and	A, dp:0x85 <__bist_stat_end+0x3b>
    9370:	29bb      	sub	X, dp:0xbb <__bist_stat_end+0x71>
    9372:	b786      	and	A, ep:0x86 <__bist_stat_end+0x3c>
    9374:	b587      	and	A, dp:0x87 <__bist_stat_end+0x3d>
    9376:	b763      	and	A, ep:0x63 <__bist_stat_end+0x19>
    9378:	b561      	and	A, dp:0x61 <__bist_stat_end+0x17>
    937a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    937c:	77bc      	lod	PC, ep:0xbc <__bist_stat_end+0x72>
    937e:	b682      	and	A, io:0x2 <_LinCmnd>
    9380:	75bc      	lod	PC, dp:0xbc <__bist_stat_end+0x72>
    9382:	3b33      	subc	X, ep:0x33 <_ml_driver_mode+0xf>
    9384:	580f      	inc	S, #16
    9386:	080b      	clrb	dp:0x01.3
    9388:	0902      	clrb	io:0x00.2
    938a:	62e6      	lod	AL, Y
    938c:	29c2      	sub	X, dp:0xc2 <__bist_stat_end+0x78>
    938e:	623a      	lod	AL, [S-59]
    9390:	a688      	or	A, io:0x8 <__bist_stat_size>
    9392:	0105      	jmp	0x959e <_PARAMtbl+0x1e>
    9394:	b726      	and	A, ep:0x26 <_ml_driver_mode+0x2>
    9396:	bf8f      	xor	A, ep:0x8f <__bist_stat_end+0x45>
    9398:	0101      	jmp	0x959c <_PARAMtbl+0x1c>
    939a:	2982      	sub	X, dp:0x82 <__bist_stat_end+0x38>
    939c:	29c2      	sub	X, dp:0xc2 <__bist_stat_end+0x78>
    939e:	623a      	lod	AL, [S-59]
    93a0:	b785      	and	A, ep:0x85 <__bist_stat_end+0x3b>
    93a2:	b682      	and	A, io:0x2 <_LinCmnd>
    93a4:	62ca      	lod	AL, [--PC]
    93a6:	24a3      	or	X, #-93
    93a8:	7172      	lod	A, dp:0x72 <__bist_stat_end+0x28>
    93aa:	b738      	and	A, ep:0x38 <__bss_dp_end>
    93ac:	7370      	lod	A, ep:0x70 <__bist_stat_end+0x26>
    93ae:	b787      	and	A, ep:0x87 <__bist_stat_end+0x3d>
    93b0:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    93b2:	734f      	lod	A, ep:0x4f <__bist_stat_end+0x5>
    93b4:	b786      	and	A, ep:0x86 <__bist_stat_end+0x3c>
    93b6:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    93b8:	734e      	lod	A, ep:0x4e <__bist_stat_end+0x4>
    93ba:	4c4e      	dadju	D, [X++]
    93bc:	4c4f      	dadju	D, [X]
    93be:	b784      	and	A, ep:0x84 <__bist_stat_end+0x3a>
    93c0:	b75f      	and	A, ep:0x5f <__bist_stat_end+0x15>
    93c2:	773e      	lod	PC, ep:0x3e <_page_buffer>
    93c4:	3469      	and	X, #105
    93c6:	3807      	subc	X, #7
    93c8:	380a      	subc	X, #10
    93ca:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    93cc:	b585      	and	A, dp:0x85 <__bist_stat_end+0x3b>
    93ce:	b55d      	and	A, dp:0x5d <__bist_stat_end+0x13>
    93d0:	8581      	or	AL, dp:0x81 <__bist_stat_end+0x37>
    93d2:	580e      	inc	S, #15
    93d4:	0803      	clrb	dp:0x00.3
    93d6:	0906      	clrb	io:0x00.6
    93d8:	62e6      	lod	AL, Y
    93da:	29e9      	sub	X, dp:0xe9 <__bist_stat_end+0x9f>
    93dc:	623a      	lod	AL, [S-59]
    93de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    93e0:	110c      	call	0x95fa <_main+0x2>
    93e2:	2a3c      	sub	X, [S-61]
    93e4:	627c      	lod	AL, [S-125]
    93e6:	0101      	jmp	0x95ea <_stext+0x2>
    93e8:	29e9      	sub	X, dp:0xe9 <__bist_stat_end+0x9f>
    93ea:	623a      	lod	AL, [S-59]
    93ec:	c581      	or	AH, dp:0x81 <__bist_stat_end+0x37>
    93ee:	0107      	jmp	0x95fe <_mlu_ApplicationStop+0x2>
    93f0:	bf84      	xor	A, ep:0x84 <__bist_stat_end+0x3a>
    93f2:	1104      	call	0x95fc <_mlu_ApplicationStop>
    93f4:	a681      	or	A, io:0x1 <__data_dp_size+0x1>
    93f6:	1102      	call	0x95fc <_mlu_ApplicationStop>
    93f8:	29ef      	sub	X, dp:0xef <__bist_stat_end+0xa5>
    93fa:	29e9      	sub	X, dp:0xe9 <__bist_stat_end+0x9f>
    93fc:	29ef      	sub	X, dp:0xef <__bist_stat_end+0xa5>
    93fe:	b101      	adc	A, dp:0x1 <__data_dp_size+0x1>
    9400:	e584      	or	Y, dp:0x84 <__bist_stat_end+0x3a>
    9402:	0103      	jmp	0x960a <_mlu_LinSleepMode>
    9404:	b372      	adc	A, ep:0x72 <__bist_stat_end+0x28>
    9406:	b684      	and	A, io:0x4 <__data_size>
    9408:	62ca      	lod	AL, [--PC]
    940a:	b365      	adc	A, ep:0x65 <__bist_stat_end+0x1b>
    940c:	a784      	or	A, ep:0x84 <__bist_stat_end+0x3a>
    940e:	1101      	call	0x9612 <_start+0x4>
    9410:	2a1b      	sub	X, [S-28]
    9412:	3448      	and	X, #72
    9414:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    9416:	3804      	subc	X, #4
    9418:	3e40      	xor	X, [S-65]
    941a:	3f8c      	xor	X, ep:0x8c <__bist_stat_end+0x42>
    941c:	b723      	and	A, ep:0x23 <_LinMessage+0x1>
    941e:	bf84      	xor	A, ep:0x84 <__bist_stat_end+0x3a>
    9420:	0105      	jmp	0x962c <_start+0x1e>
    9422:	623a      	lod	AL, [S-59]
    9424:	bf88      	xor	A, ep:0x88 <__bist_stat_end+0x3e>
    9426:	1101      	call	0x962a <_start+0x1c>
    9428:	2a0e      	sub	X, [S-15]
    942a:	2a3a      	sub	X, [S-59]
    942c:	3e98      	xor	X, io:0x18 <_LinFrameDataBuffer>
    942e:	580b      	inc	S, #12
    9430:	090d      	clrb	io:0x01.5
    9432:	62e6      	lod	AL, Y
    9434:	2a17      	sub	X, [S-24]
    9436:	3468      	and	X, #104
    9438:	3790      	and	X, ep:0x90 <__bist_stat_end+0x46>
    943a:	3806      	subc	X, #6
    943c:	380a      	subc	X, #10
    943e:	b370      	adc	A, ep:0x70 <__bist_stat_end+0x26>
    9440:	bf88      	xor	A, ep:0x88 <__bist_stat_end+0x3e>
    9442:	010d      	jmp	0x965e <__ram_section_init+0x2e>
    9444:	b638      	and	A, [S-57]
    9446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    9448:	110a      	call	0x965e <__ram_section_init+0x2e>
    944a:	2a3c      	sub	X, [S-61]
    944c:	627c      	lod	AL, [S-125]
    944e:	0101      	jmp	0x9652 <__ram_section_init+0x22>
    9450:	2a17      	sub	X, [S-24]
    9452:	b723      	and	A, ep:0x23 <_LinMessage+0x1>
    9454:	bf84      	xor	A, ep:0x84 <__bist_stat_end+0x3a>
    9456:	110e      	call	0x9674 <__prestart+0x2>
    9458:	623a      	lod	AL, [S-59]
    945a:	7c05      	lod	X, #5
    945c:	2a17      	sub	X, [S-24]
    945e:	580e      	inc	S, #15
    9460:	0805      	clrb	dp:0x00.5
    9462:	0902      	clrb	io:0x00.2
    9464:	62e6      	lod	AL, Y
    9466:	2a2f      	sub	X, [S-48]
    9468:	627c      	lod	AL, [S-125]
    946a:	2a2f      	sub	X, [S-48]
    946c:	623a      	lod	AL, [S-59]
    946e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    9470:	0103      	jmp	0x9678 <__prestart+0x6>
    9472:	2a2f      	sub	X, [S-48]
    9474:	622b      	lod	AL, [S-44]
    9476:	2a72      	sub	X, [S-115]
    9478:	4d3e      	mov	dp:0x3e <_page_buffer>, YH
    947a:	4930      	mov	dp:0x30 <_ml_driver_mode+0xc>, AH
    947c:	3449      	and	X, #73
    947e:	3809      	subc	X, #9
    9480:	3805      	subc	X, #5
    9482:	37a0      	and	X, ep:0xa0 <__bist_stat_end+0x56>
    9484:	3986      	subc	X, dp:0x86 <__bist_stat_end+0x3c>
    9486:	580e      	inc	S, #15
    9488:	0803      	clrb	dp:0x00.3
    948a:	0903      	clrb	io:0x00.3
    948c:	62e6      	lod	AL, Y
    948e:	2a43      	sub	X, [S-68]
    9490:	2a60      	sub	X, [S-97]
    9492:	627c      	lod	AL, [S-125]
    9494:	0101      	jmp	0x9698 <__prestart+0x26>
    9496:	2a43      	sub	X, [S-68]
    9498:	623a      	lod	AL, [S-59]
    949a:	b330      	adc	A, ep:0x30 <_ml_driver_mode+0xc>
    949c:	b231      	adc	A, [S-50]
    949e:	8781      	or	AL, ep:0x81 <__bist_stat_end+0x37>
    94a0:	8e80      	cmp	AL, io:0x0 <__data_dp_size>
    94a2:	7330      	lod	A, ep:0x30 <_ml_driver_mode+0xc>
    94a4:	7231      	lod	A, [S-50]
    94a6:	b588      	and	A, dp:0x88 <__bist_stat_end+0x3e>
    94a8:	e75d      	or	Y, ep:0x5d <__bist_stat_end+0x13>
    94aa:	b589      	and	A, dp:0x89 <__bist_stat_end+0x3f>
    94ac:	ee5d      	cmp	Y, [S-94]
    94ae:	1102      	call	0x96b4 <__prestart+0x42>
    94b0:	b782      	and	A, ep:0x82 <__bist_stat_end+0x38>
    94b2:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    94b4:	b58a      	and	A, dp:0x8a <__bist_stat_end+0x40>
    94b6:	e75d      	or	Y, ep:0x5d <__bist_stat_end+0x13>
    94b8:	b58b      	and	A, dp:0x8b <__bist_stat_end+0x41>
    94ba:	ee5d      	cmp	Y, [S-94]
    94bc:	0001      	jmp	0x94c0 <__mlx4_flash_start+0x14c0>
    94be:	2918      	sub	X, dp:0x18 <_LinFrameDataBuffer>
    94c0:	623a      	lod	AL, [S-59]
    94c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    94c4:	1101      	call	0x96c8 <__prestart+0x56>
    94c6:	2a43      	sub	X, [S-68]
    94c8:	b201      	adc	A, [S-2]
    94ca:	b33b      	adc	A, ep:0x3b <_LINBaud+0x1>
    94cc:	a782      	or	A, ep:0x82 <__bist_stat_end+0x38>
    94ce:	1105      	call	0x96da <__prestart+0x68>
    94d0:	7c05      	lod	X, #5
    94d2:	e684      	or	Y, io:0x4 <__data_size>
    94d4:	0101      	jmp	0x96d8 <__prestart+0x66>
    94d6:	29e2      	sub	X, dp:0xe2 <__bist_stat_end+0x98>
    94d8:	2a1b      	sub	X, [S-28]
    94da:	e684      	or	Y, io:0x4 <__data_size>
    94dc:	0103      	jmp	0x96e4 <__prestart+0x72>
    94de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    94e0:	62b5      	lod	AL, io:0x35 <_ml_driver_mode+0x11>
    94e2:	24a3      	or	X, #-93
    94e4:	b783      	and	A, ep:0x83 <__bist_stat_end+0x39>
    94e6:	b682      	and	A, io:0x2 <_LinCmnd>
    94e8:	62ca      	lod	AL, [--PC]
    94ea:	b780      	and	A, ep:0x80 <__bist_stat_end+0x36>
    94ec:	733b      	lod	A, ep:0x3b <_LINBaud+0x1>
    94ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00009540 <_INDXtbl>:
    9540:	c0c0      	add	AH, #-64
    9542:	c0c0      	add	AH, #-64
    9544:	c0c0      	add	AH, #-64
    9546:	c0c0      	add	AH, #-64
    9548:	c0c0      	add	AH, #-64
    954a:	c0c0      	add	AH, #-64
    954c:	c0c0      	add	AH, #-64
    954e:	c0c0      	add	AH, #-64
    9550:	c0c0      	add	AH, #-64
    9552:	c0c0      	add	AH, #-64
    9554:	c0c0      	add	AH, #-64
    9556:	c0c0      	add	AH, #-64
    9558:	c0c0      	add	AH, #-64
    955a:	c0c0      	add	AH, #-64
    955c:	c0c0      	add	AH, #-64
    955e:	c0c0      	add	AH, #-64
    9560:	c0c0      	add	AH, #-64
    9562:	c0c0      	add	AH, #-64
    9564:	c0c0      	add	AH, #-64
    9566:	c0c0      	add	AH, #-64
    9568:	c0c0      	add	AH, #-64
    956a:	c0c0      	add	AH, #-64
    956c:	c0c0      	add	AH, #-64
    956e:	c0c0      	add	AH, #-64
    9570:	c0c0      	add	AH, #-64
    9572:	c0c0      	add	AH, #-64
    9574:	c0c0      	add	AH, #-64
    9576:	c0c0      	add	AH, #-64
    9578:	c0c0      	add	AH, #-64
    957a:	c0c0      	add	AH, #-64
    957c:	1110      	call	0x979e <__prestart+0x12c>
    957e:	c0c0      	add	AH, #-64

00009580 <_PARAMtbl>:
    9580:	a0a0      	add	A, #-96
    9582:	a0a0      	add	A, #-96
    9584:	a0a0      	add	A, #-96
    9586:	a0a0      	add	A, #-96
    9588:	a0a0      	add	A, #-96
    958a:	a0a0      	add	A, #-96
    958c:	a0a0      	add	A, #-96
    958e:	a0a0      	add	A, #-96
    9590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    9592:	a0a0      	add	A, #-96
    9594:	a0a0      	add	A, #-96
    9596:	a0a0      	add	A, #-96
    9598:	a0a0      	add	A, #-96
    959a:	a0a0      	add	A, #-96
    959c:	a0a0      	add	A, #-96
    959e:	a0a0      	add	A, #-96
    95a0:	a0a0      	add	A, #-96
    95a2:	a0a0      	add	A, #-96
    95a4:	a0a0      	add	A, #-96
    95a6:	a0a0      	add	A, #-96
    95a8:	a0a0      	add	A, #-96
    95aa:	a0a0      	add	A, #-96
    95ac:	a0a0      	add	A, #-96
    95ae:	a0a0      	add	A, #-96
    95b0:	a0a0      	add	A, #-96
    95b2:	a0a0      	add	A, #-96
    95b4:	a0a0      	add	A, #-96
    95b6:	a0a0      	add	A, #-96
    95b8:	a0a0      	add	A, #-96
    95ba:	a0a0      	add	A, #-96
    95bc:	a0a0      	add	A, #-96
    95be:	a0a0      	add	A, #-96

000095c0 <_AUTOADDtbl>:
    95c0:	0000      	nop
    95c2:	0000      	nop
    95c4:	0000      	nop
    95c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 95e8 	jmpf	0x95e8 <_stext>
    bf6e:	0000      	nop
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da bf72 	jmpf	0xbf72 <__vectors+0xa>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	76da bf7a 	jmpf	0xbf7a <__vectors+0x12>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000095e8 <_stext>:
    95e8:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    95ec:	a6da 0200 	or	A, #512
    95f0:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    95f4:	76da 9672 	jmpf	0x9672 <__prestart>

000095f8 <_main>:
    /*
    * The main is never called from crt0 in the loader
    */

	return 0;
}
    95f8:	7000      	lod	A, #0
    95fa:	5401      	ret

000095fc <_mlu_ApplicationStop>:
#include "lin.h"

ml_Status mlu_ApplicationStop(void)
{
    return ML_SUCCESS;      /* by default, return that the application has stopped */
}
    95fc:	7000      	lod	A, #0
    95fe:	5401      	ret

00009600 <_mlu_AutoAddressingStep>:

#if STANDALONE_LOADER == 0
void mlu_AutoAddressingStep(ml_uint8 StepNumber)
{
    (void)StepNumber;       /* not used */
    9600:	5401      	ret

00009602 <_mlu_DataRequest>:
}

void mlu_DataRequest(ml_MessageID MessageIndex)
{
    (void)MessageIndex;     /* unused parameter */
    ml_DiscardFrame();
    9602:	11e3      	call	0x99ca <_ml_DiscardFrame>
    9604:	5401      	ret

00009606 <_mlu_DataTransmitted>:
}

void mlu_DataTransmitted(void)
{
    9606:	5401      	ret

00009608 <_mlu_ErrorDetected>:
    /* empty */
}

void mlu_ErrorDetected(ml_LinError Error)
{
    (void)Error; /* not used */
    9608:	5401      	ret

0000960a <_mlu_LinSleepMode>:
}

void mlu_LinSleepMode(ml_StateReason Reason)
{
    (void)Reason;   /* not used */
    960a:	5401      	ret

0000960c <_mlu_MessageReceived>:
    /* some action during entering sleep state */
}

void mlu_MessageReceived (ml_MessageID Index)
{
    (void)Index; /* not used */
    960c:	5401      	ret

0000960e <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    960e:	7000      	lod	A, #0
    9610:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    9612:	70ff      	lod	A, #-1
    9614:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    9618:	72da 004a 	lod	A, #74
    961c:	52ef      	mov	S, A

    _low_level_init();
    961e:	82db a754 	callf	0xa754 <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    9622:	1006      	call	0x9630 <__ram_section_init>
    _premain();
    9624:	82db a89e 	callf	0xa89e <__premain>
    (void)main();
    9628:	17e7      	call	0x95f8 <_main>
    _fatal();
    962a:	82db a748 	callf	0xa748 <__fatal>
    962e:	5401      	ret

00009630 <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    9630:	7ada 0018 	lod	Y, #24
    9634:	eeda 0038 	cmp	Y, #56
    9638:	1c03      	jnc	0x9640 <__ram_section_init+0x10>
        *w++ = 0;
    963a:	7000      	lod	A, #0
    963c:	52d6      	mov	[Y++], A
    963e:	07fa      	jmp	0x9634 <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    9640:	7ada 003c 	lod	Y, #60
    9644:	eeda 0042 	cmp	Y, #66
    9648:	1c03      	jnc	0x9650 <__ram_section_init+0x20>
        *w++ = 0;
    964a:	7000      	lod	A, #0
    964c:	52d6      	mov	[Y++], A
    964e:	07fa      	jmp	0x9644 <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    9650:	7eda aade 	lod	X, #43742

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    9654:	7ada 0018 	lod	Y, #24
    9658:	eeda 0018 	cmp	Y, #24
    965c:	1c02      	jnc	0x9662 <__ram_section_init+0x32>
        *w++ = *r++;
    965e:	54ce      	movsw	[Y++], [X++]
    9660:	07fb      	jmp	0x9658 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    9662:	7ada 0038 	lod	Y, #56
    9666:	eeda 003c 	cmp	Y, #60
    966a:	1c02      	jnc	0x9670 <__ram_section_init+0x40>
        *w++ = *r++;
    966c:	54ce      	movsw	[Y++], [X++]
    966e:	07fb      	jmp	0x9666 <__ram_section_init+0x36>
    9670:	5401      	ret

00009672 <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    9672:	5801      	inc	S, #2
    9674:	7000      	lod	A, #0
    9676:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    9678:	70ff      	lod	A, #-1
    967a:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    967e:	72da 004a 	lod	A, #74
    9682:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    9684:	10f4      	call	0x986e <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    9686:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    968a:	b401      	and	A, #1
    968c:	1d27      	jne	0x96dc <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    968e:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    9692:	5cf2      	usex	A
    9694:	4422      	asl	A
    9696:	7ada 10e8 	lod	Y, #4328
    969a:	eae2      	sub	Y, A
    969c:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    96a0:	5cf2      	usex	A
    96a2:	7ee2      	lod	X, A
    96a4:	7014      	lod	A, #20
    96a6:	aaee      	sub	A, X
    96a8:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    96aa:	7ee2      	lod	X, A
    96ac:	7000      	lod	A, #0
    96ae:	08a7      	clrb	ML.7
    96b0:	b2d6      	adc	A, [Y++]
    96b2:	1bfe      	djnz	X, 0x96b0 <__prestart+0x3e>
    96b4:	92e4      	adc	AL, AH
    96b6:	9000      	adc	AL, #0
    96b8:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    96ba:	aeda 00ff 	cmp	A, #255
    96be:	1d0e      	jne	0x96dc <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    96c0:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    96c4:	b4f8      	and	A, #-8
    96c6:	aeda 04b8 	cmp	A, #1208
    96ca:	1d08      	jne	0x96dc <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    96cc:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    96d0:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    96d4:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    96d6:	eeda 201a 	cmp	Y, #8218
    96da:	1a7c      	jule	0x96d4 <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    96dc:	72d8 0042 	lod	A, 0x42 <__bss_end>
    96e0:	aeda b598 	cmp	A, #46488
    96e4:	1901      	je	0x96e8 <__prestart+0x76>
    96e6:	0037      	jmp	0x9756 <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    96e8:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    96ea:	ac00      	cmp	A, #0
    96ec:	1a84      	jsl	0x96f6 <__prestart+0x84>
    96ee:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    96f2:	8c00      	cmp	AL, #0
    96f4:	1e98      	jsge	0x9726 <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    96f6:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    96fa:	aeda 3072 	cmp	A, #12402
    96fe:	1d01      	jne	0x9702 <__prestart+0x90>
    9700:	0031      	jmp	0x9764 <__prestart+0xf2>
    9702:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9706:	aeda 3212 	cmp	A, #12818
    970a:	192c      	je	0x9764 <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    970c:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9710:	1905      	je	0x971c <__prestart+0xaa>
    9712:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9716:	aeda 1a45 	cmp	A, #6725
    971a:	1d03      	jne	0x9722 <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    971c:	72da 5c92 	lod	A, #23698
    9720:	000d      	jmp	0x973c <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    9722:	7c00      	lod	X, #0
    9724:	0015      	jmp	0x9750 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    9726:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    972a:	aeda 3072 	cmp	A, #12402
    972e:	1909      	je	0x9742 <__prestart+0xd0>
    9730:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9734:	aeda 3212 	cmp	A, #12818
    9738:	1904      	je	0x9742 <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    973a:	7000      	lod	A, #0
    973c:	52d8 0044 	mov	0x44 <_bistResetInfo>, A
    9740:	0011      	jmp	0x9764 <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    9742:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9746:	aeda 1a45 	cmp	A, #6725
    974a:	1d0c      	jne	0x9764 <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    974c:	7eda 56d2 	lod	X, #22226
    9750:	5ed8 0044 	mov	0x44 <_bistResetInfo>, X
    9754:	0007      	jmp	0x9764 <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    9756:	7000      	lod	A, #0
    9758:	52d8 0044 	mov	0x44 <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    975c:	7eda b598 	lod	X, #46488
    9760:	5ed8 0042 	mov	0x42 <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    9764:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9768:	aeda 3072 	cmp	A, #12402
    976c:	191a      	je	0x97a2 <__prestart+0x130>
    976e:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9772:	aeda 3212 	cmp	A, #12818
    9776:	1915      	je	0x97a2 <__prestart+0x130>
    9778:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    977c:	aeda 5c92 	cmp	A, #23698
    9780:	1910      	je	0x97a2 <__prestart+0x130>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    9782:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    9786:	7c20      	lod	X, #32
    9788:	7000      	lod	A, #0
    978a:	08a7      	clrb	ML.7
    978c:	b2d6      	adc	A, [Y++]
    978e:	1bfe      	djnz	X, 0x978c <__prestart+0x11a>
    9790:	92e4      	adc	AL, AH
    9792:	9000      	adc	AL, #0
    9794:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    9796:	aeda 00ff 	cmp	A, #255
    979a:	1903      	je	0x97a2 <__prestart+0x130>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    979c:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    979e:	76da a748 	jmpf	0xa748 <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    97a2:	6030      	lod	AL, #48
    97a4:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    97a8:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    97ac:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    97b0:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    97b4:	a6da 8000 	or	A, #32768
    97b8:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    97bc:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    97c0:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    97c4:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    97c8:	b6da 00ff 	and	A, #255
    97cc:	a6da c000 	or	A, #49152
    97d0:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    97d4:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    97d8:	94cf      	and	AL, #-49
    97da:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    97de:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    97e2:	b4f9      	and	A, #-7
    97e4:	a402      	or	A, #2
    97e6:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    97ea:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    97ee:	b401      	and	A, #1
    97f0:	1914      	je	0x981a <__prestart+0x1a8>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    97f2:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    97f6:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    97fa:	a6e6      	or	A, Y
    97fc:	190e      	je	0x981a <__prestart+0x1a8>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    97fe:	7eda 95c8 	lod	X, #38344

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    9802:	7ada 0740 	lod	Y, #1856
    9806:	eeda 075e 	cmp	Y, #1886
    980a:	1c05      	jnc	0x9816 <__prestart+0x1a4>
        *w++ = *r++;
    980c:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    980e:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    9810:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    9812:	54ce      	movsw	[Y++], [X++]
    9814:	07f8      	jmp	0x9806 <__prestart+0x194>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    9816:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    981a:	72da 6fd1 	lod	A, #28625
    981e:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    9822:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    9824:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    9828:	b401      	and	A, #1
    982a:	1d03      	jne	0x9832 <__prestart+0x1c0>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    982c:	e001      	add	Y, #1
    982e:	ec63      	cmp	Y, #99
    9830:	1a79      	jule	0x9824 <__prestart+0x1b2>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    9832:	ec64      	cmp	Y, #100
    9834:	1d01      	jne	0x9838 <__prestart+0x1c6>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    9836:	07ff      	jmp	0x9836 <__prestart+0x1c4>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    9838:	6024      	lod	AL, #36
    983a:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    983e:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9842:	aeda 3072 	cmp	A, #12402
    9846:	190e      	je	0x9864 <__prestart+0x1f2>
    9848:	82db a456 	callf	0xa456 <_LDR_GetState>
    984c:	8c00      	cmp	AL, #0
    984e:	1d0a      	jne	0x9864 <__prestart+0x1f2>
    9850:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9854:	aeda 3212 	cmp	A, #12818
    9858:	1905      	je	0x9864 <__prestart+0x1f2>
    985a:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    985e:	aeda 5c92 	cmp	A, #23698
    9862:	1d02      	jne	0x9868 <__prestart+0x1f6>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    9864:	06d4      	jmp	0x960e <_start>
    9866:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    9868:	76da a6fa 	jmpf	0xa6fa <_RAM_Test>
    986c:	5403      	ret	#4

0000986e <_NVRAM_LoadAll>:
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
        WD_T = 0;                       /* .. acknowledge the watchdog */
    986e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    9872:	b401      	and	A, #1
    9874:	1908      	je	0x9886 <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    9876:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    9878:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    987a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    987c:	b430      	and	A, #48
    987e:	1977      	je	0x986e <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    9880:	6000      	lod	AL, #0
    9882:	4282      	mov	io:0x2 <_LinCmnd>, AL
    9884:	07f4      	jmp	0x986e <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    9886:	72da 8000 	lod	A, #32768
    988a:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    988e:	72da 8001 	lod	A, #32769
    9892:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    9896:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    989a:	b401      	and	A, #1
    989c:	1908      	je	0x98ae <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    989e:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    98a0:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    98a2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    98a4:	b430      	and	A, #48
    98a6:	1977      	je	0x9896 <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    98a8:	6000      	lod	AL, #0
    98aa:	4282      	mov	io:0x2 <_LinCmnd>, AL
    98ac:	07f4      	jmp	0x9896 <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    98ae:	7000      	lod	A, #0
    98b0:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    98b4:	7001      	lod	A, #1
    98b6:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    98ba:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    98be:	b401      	and	A, #1
    98c0:	1908      	je	0x98d2 <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    98c2:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    98c4:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    98c6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    98c8:	b430      	and	A, #48
    98ca:	1977      	je	0x98ba <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    98cc:	6000      	lod	AL, #0
    98ce:	4282      	mov	io:0x2 <_LinCmnd>, AL
    98d0:	07f4      	jmp	0x98ba <_NVRAM_LoadAll+0x4c>
    98d2:	5401      	ret

000098d4 <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    98d4:	7ee2      	lod	X, A
    98d6:	b6da 7fff 	and	A, #32767
    98da:	ac01      	cmp	A, #1
    98dc:	1906      	je	0x98ea <_NVRAM_SavePage+0x16>
    98de:	1803      	jc	0x98e6 <_NVRAM_SavePage+0x12>
    98e0:	ac02      	cmp	A, #2
    98e2:	1905      	je	0x98ee <_NVRAM_SavePage+0x1a>
    98e4:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    98e6:	7810      	lod	Y, #16
            break;
    98e8:	0004      	jmp	0x98f2 <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    98ea:	7818      	lod	Y, #24
            break;
    98ec:	0002      	jmp	0x98f2 <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    98ee:	7ada 8400 	lod	Y, #33792
    98f2:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    98f6:	b401      	and	A, #1
    98f8:	1908      	je	0x990a <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    98fa:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    98fc:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    98fe:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    9900:	b430      	and	A, #48
    9902:	1977      	je	0x98f2 <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    9904:	6000      	lod	AL, #0
    9906:	4282      	mov	io:0x2 <_LinCmnd>, AL
    9908:	07f4      	jmp	0x98f2 <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    990a:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    990e:	e403      	or	Y, #3
    9910:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    9914:	2c00      	cmp	X, #0
    9916:	1a8c      	jsl	0x9930 <_NVRAM_SavePage+0x5c>
    9918:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    991c:	b401      	and	A, #1
    991e:	1908      	je	0x9930 <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    9920:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    9922:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    9924:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    9926:	b430      	and	A, #48
    9928:	1977      	je	0x9918 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    992a:	6000      	lod	AL, #0
    992c:	4282      	mov	io:0x2 <_LinCmnd>, AL
    992e:	07f4      	jmp	0x9918 <_NVRAM_SavePage+0x44>
    9930:	5401      	ret

00009932 <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    9932:	7ae2      	lod	Y, A
    9934:	6203      	lod	AL, [S-4]
    9936:	5cf2      	usex	A
    9938:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    993a:	72e6      	lod	A, Y
    993c:	b401      	and	A, #1
    993e:	1908      	je	0x9950 <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    9940:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    9942:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    9944:	b6da 00ff 	and	A, #255
    9948:	36da 00ff 	and	X, #255
    994c:	7eec      	swap	X
    994e:	0003      	jmp	0x9956 <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    9950:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    9952:	b6da ff00 	and	A, #65280
    9956:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    9958:	52f0      	mov	[Y], A
    995a:	5401      	ret

0000995c <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    995c:	7000      	lod	A, #0
    995e:	17ba      	call	0x98d4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    9960:	7001      	lod	A, #1
    9962:	17b8      	call	0x98d4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    9964:	7002      	lod	A, #2
    9966:	17b6      	call	0x98d4 <_NVRAM_SavePage>
    9968:	5401      	ret

0000996a <_ml_ReleaseBuffer>:
    996a:	602f      	lod	AL, #47
    996c:	0033      	jmp	0x99d4 <_ml_ContFrame+0x6>

0000996e <_ml_ReleaseBufferProg>:
    996e:	9401      	and	AL, #1
    9970:	44a0      	asl	AL, #2
    9972:	44a0      	asl	AL, #2
    9974:	840f      	or	AL, #15
    9976:	002e      	jmp	0x99d4 <_ml_ContFrame+0x6>

00009978 <_ml_DataReady>:
    9978:	6ae0      	lod	AH, AL
    997a:	6015      	lod	AL, #21
    997c:	7eda 0008 	lod	X, #8
    9980:	7ada 0018 	lod	Y, #24
    9984:	54c6      	movsw	[X++], [Y++]
    9986:	54c6      	movsw	[X++], [Y++]
    9988:	54c6      	movsw	[X++], [Y++]
    998a:	54c6      	movsw	[X++], [Y++]
    998c:	0023      	jmp	0x99d4 <_ml_ContFrame+0x6>

0000998e <_ml_AssignFrameToMessageID>:
    998e:	6a03      	lod	AH, [S-4]
    9990:	d43f      	and	AH, #63
    9992:	0004      	jmp	0x999c <_ml_EnableMessage+0x4>

00009994 <_ml_DisableMessage>:
    9994:	6802      	lod	AH, #2
    9996:	0001      	jmp	0x999a <_ml_EnableMessage+0x2>

00009998 <_ml_EnableMessage>:
    9998:	6803      	lod	AH, #3
    999a:	44d4      	rr	AH, #2
    999c:	44a0      	asl	AL, #2
    999e:	44a0      	asl	AL, #2
    99a0:	8406      	or	AL, #6
    99a2:	0018      	jmp	0x99d4 <_ml_ContFrame+0x6>

000099a4 <_ml_AutoAddressingConfig>:
    99a4:	44a0      	asl	AL, #2
    99a6:	44a0      	asl	AL, #2
    99a8:	840d      	or	AL, #13
    99aa:	0014      	jmp	0x99d4 <_ml_ContFrame+0x6>

000099ac <_ml_SetSlewRate>:
    99ac:	44a2      	asl	A, #2
    99ae:	44a2      	asl	A, #2
    99b0:	a407      	or	A, #7
    99b2:	0010      	jmp	0x99d4 <_ml_ContFrame+0x6>

000099b4 <_ml_SetOptions>:
    99b4:	6a03      	lod	AH, [S-4]
    99b6:	44a4      	asl	AH, #2
    99b8:	86e4      	or	AL, AH
    99ba:	44a0      	asl	AL, #2
    99bc:	44a0      	asl	AL, #2
    99be:	840b      	or	AL, #11
    99c0:	c607      	or	AH, [S-8]
    99c2:	44a4      	asl	AH, #2
    99c4:	c605      	or	AH, [S-6]
    99c6:	dc01      	xor	AH, #1
    99c8:	0005      	jmp	0x99d4 <_ml_ContFrame+0x6>

000099ca <_ml_DiscardFrame>:
    99ca:	6005      	lod	AL, #5
    99cc:	0003      	jmp	0x99d4 <_ml_ContFrame+0x6>

000099ce <_ml_ContFrame>:
    99ce:	6ae0      	lod	AH, AL
    99d0:	6025      	lod	AL, #37
    99d2:	0000      	nop
    99d4:	54e2      	mov	Cx, #2
    99d6:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    99da:	7ae2      	lod	Y, A
    99dc:	6041      	lod	AL, #65
    99de:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    99e2:	7eda 03e8 	lod	X, #1000
    99e6:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    99ea:	9402      	and	AL, #2
    99ec:	1d03      	jne	0x99f4 <_ml_ContFrame+0x26>
    99ee:	1bfb      	djnz	X, 0x99e6 <_ml_ContFrame+0x18>
    99f0:	7002      	lod	A, #2
    99f2:	5401      	ret
    99f4:	7ee6      	lod	X, Y
    99f6:	340f      	and	X, #15
    99f8:	72d8 0000 	lod	A, 0x0 <__data_dp_size>
    99fc:	6800      	lod	AH, #0
    99fe:	aeee      	cmp	A, X
    9a00:	1d02      	jne	0x9a06 <_ml_ContFrame+0x38>
    9a02:	7000      	lod	A, #0
    9a04:	5401      	ret
    9a06:	72e6      	lod	A, Y
    9a08:	1fe6      	djnz	Cx, 0x99d6 <_ml_ContFrame+0x8>
    9a0a:	7001      	lod	A, #1
    9a0c:	5401      	ret

00009a0e <_ml_LinModuleVersion>:
    9a0e:	602a      	lod	AL, #42
    9a10:	17e1      	call	0x99d4 <_ml_ContFrame+0x6>
    9a12:	ac00      	cmp	A, #0
    9a14:	1d11      	jne	0x9a38 <_ml_LinModuleVersion+0x2a>
    9a16:	72d8 0000 	lod	A, 0x0 <__data_dp_size>
    9a1a:	940f      	and	AL, #15
    9a1c:	8c0a      	cmp	AL, #10
    9a1e:	1d0c      	jne	0x9a38 <_ml_LinModuleVersion+0x2a>
    9a20:	66e4      	lod	YL, AH
    9a22:	601a      	lod	AL, #26
    9a24:	17d7      	call	0x99d4 <_ml_ContFrame+0x6>
    9a26:	ac00      	cmp	A, #0
    9a28:	1d07      	jne	0x9a38 <_ml_LinModuleVersion+0x2a>
    9a2a:	72d8 0000 	lod	A, 0x0 <__data_dp_size>
    9a2e:	940f      	and	AL, #15
    9a30:	8c0a      	cmp	AL, #10
    9a32:	1d02      	jne	0x9a38 <_ml_LinModuleVersion+0x2a>
    9a34:	62e8      	lod	AL, YL
    9a36:	5401      	ret
    9a38:	7000      	lod	A, #0
    9a3a:	5401      	ret

00009a3c <_ml_GetState>:
    9a3c:	44a2      	asl	A, #2
    9a3e:	44a2      	asl	A, #2
    9a40:	a40c      	or	A, #12
    9a42:	17c8      	call	0x99d4 <_ml_ContFrame+0x6>
    9a44:	ac00      	cmp	A, #0
    9a46:	1d0b      	jne	0x9a5e <_ml_GetState+0x22>
    9a48:	72d8 0000 	lod	A, 0x0 <__data_dp_size>
    9a4c:	8c0c      	cmp	AL, #12
    9a4e:	1d07      	jne	0x9a5e <_ml_GetState+0x22>
    9a50:	62e4      	lod	AL, AH
    9a52:	44f4      	asr	AH, #2
    9a54:	44f4      	asr	AH, #2
    9a56:	4ad8 3c00 	mov	0x3c <__data_end>, AH
    9a5a:	b40f      	and	A, #15
    9a5c:	5401      	ret
    9a5e:	70ff      	lod	A, #-1
    9a60:	5401      	ret

00009a62 <_ml_SetBaudRate>:
    9a62:	44a0      	asl	AL, #2
    9a64:	44a0      	asl	AL, #2
    9a66:	8402      	or	AL, #2
    9a68:	7a03      	lod	Y, [S-4]
    9a6a:	6ae8      	lod	AH, YL
    9a6c:	07b3      	jmp	0x99d4 <_ml_ContFrame+0x6>

00009a6e <_ml_SetAutoBaudRateMode>:
    9a6e:	6ae0      	lod	AH, AL
    9a70:	6002      	lod	AL, #2
    9a72:	84e0      	or	AL, #-32
    9a74:	07af      	jmp	0x99d4 <_ml_ContFrame+0x6>

00009a76 <_ml_Connect>:
    9a76:	6002      	lod	AL, #2
    9a78:	0008      	jmp	0x9a8a <_ml_GotoSleep+0x4>

00009a7a <_ml_Disconnect>:
    9a7a:	6001      	lod	AL, #1
    9a7c:	0006      	jmp	0x9a8a <_ml_GotoSleep+0x4>

00009a7e <_ml_SwitchToFast>:
    9a7e:	600f      	lod	AL, #15
    9a80:	0004      	jmp	0x9a8a <_ml_GotoSleep+0x4>

00009a82 <_ml_WakeUp>:
    9a82:	6008      	lod	AL, #8
    9a84:	0002      	jmp	0x9a8a <_ml_GotoSleep+0x4>

00009a86 <_ml_GotoSleep>:
    9a86:	6004      	lod	AL, #4
    9a88:	0000      	nop
    9a8a:	44a0      	asl	AL, #2
    9a8c:	44a0      	asl	AL, #2
    9a8e:	8401      	or	AL, #1
    9a90:	07a1      	jmp	0x99d4 <_ml_ContFrame+0x6>

00009a92 <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    9a92:	60aa      	lod	AL, #-86
    9a94:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    9a98:	7104      	lod	A, dp:0x4 <__data_size>
    9a9a:	5122      	mov	dp:0x22 <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    9a9c:	7810      	lod	Y, #16
    9a9e:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    9aa2:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    9aa4:	ac03      	cmp	A, #3
    9aa6:	1d09      	jne	0x9aba <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    9aa8:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    9aaa:	5118      	mov	dp:0x18 <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    9aac:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    9aae:	591a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    9ab0:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    9ab2:	511c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    9ab4:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    9ab6:	591e      	mov	dp:0x1e <__ramfunc_size>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    9ab8:	1758      	call	0x996a <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    9aba:	6042      	lod	AL, #66
    9abc:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    9ac0:	5401      	ret

00009ac2 <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    9ac2:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    9ac4:	7922      	lod	Y, dp:0x22 <_LinMessage>
    9ac6:	72e6      	lod	A, Y
    9ac8:	b40f      	and	A, #15
    9aca:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    9acc:	ac07      	cmp	A, #7
    9ace:	1d06      	jne	0x9adc <_ml_ProccessLinEvent+0x1a>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    9ad0:	44b6      	lsr	Y, #2
    9ad2:	44b6      	lsr	Y, #2
    9ad4:	72e6      	lod	A, Y
    9ad6:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    9ad8:	1593      	call	0x9600 <_mlu_AutoAddressingStep>
    9ada:	00c2      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    9adc:	72e6      	lod	A, Y
    9ade:	6000      	lod	AL, #0
    9ae0:	72e4      	swap	A
    9ae2:	b43f      	and	A, #63
    9ae4:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    9ae6:	62d8 0024 	lod	AL, 0x24 <_ml_driver_mode>
    9aea:	8c55      	cmp	AL, #85
    9aec:	1d01      	jne	0x9af0 <_ml_ProccessLinEvent+0x2e>
    9aee:	0098      	jmp	0x9c20 <_ml_ProccessLinEvent+0x15e>
        if (LDR_GetState() == 0) {
    9af0:	82db a456 	callf	0xa456 <_LDR_GetState>
    9af4:	8c00      	cmp	AL, #0
    9af6:	1901      	je	0x9afa <_ml_ProccessLinEvent+0x38>
    9af8:	0065      	jmp	0x9bc4 <_ml_ProccessLinEvent+0x102>
#endif
            switch(LinCommand) {
    9afa:	7203      	lod	A, [S-4]
    9afc:	a0ff      	add	A, #-1
    9afe:	ac04      	cmp	A, #4
    9b00:	1a01      	jule	0x9b04 <_ml_ProccessLinEvent+0x42>
    9b02:	00ae      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
    9b04:	4422      	asl	A
    9b06:	7ae2      	lod	Y, A
    9b08:	e2da aac8 	add	Y, #43720
    9b0c:	72f0      	lod	A, [Y]
    9b0e:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    9b10:	7922      	lod	Y, dp:0x22 <_LinMessage>
    9b12:	72e6      	lod	A, Y
    9b14:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    9b18:	ac40      	cmp	A, #64
    9b1a:	1901      	je	0x9b1e <_ml_ProccessLinEvent+0x5c>
    9b1c:	00a1      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    9b1e:	44c6      	rl	Y, #2
    9b20:	44c6      	rl	Y, #2
    9b22:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    9b24:	72e6      	lod	A, Y
    9b26:	1571      	call	0x960a <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    9b28:	009b      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    9b2a:	7922      	lod	Y, dp:0x22 <_LinMessage>
    9b2c:	72e6      	lod	A, Y
    9b2e:	44b2      	lsr	A, #2
    9b30:	44b2      	lsr	A, #2
    9b32:	b40f      	and	A, #15
    9b34:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    9b36:	ac05      	cmp	A, #5
    9b38:	1d0e      	jne	0x9b56 <_ml_ProccessLinEvent+0x94>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    9b3a:	6400      	lod	YL, #0
    9b3c:	7ae8      	swap	Y
    9b3e:	72e6      	lod	A, Y
    9b40:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    9b42:	44b6      	lsr	Y, #2
    9b44:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    9b46:	80ff      	add	AL, #-1
    9b48:	8c08      	cmp	AL, #8
    9b4a:	1a17      	jule	0x9b7a <_ml_ProccessLinEvent+0xb8>
    9b4c:	62e8      	lod	AL, YL
    9b4e:	8c0f      	cmp	AL, #15
    9b50:	1914      	je	0x9b7a <_ml_ProccessLinEvent+0xb8>
                            Error = ml_erStopBitTX;
    9b52:	7c10      	lod	X, #16
    9b54:	0012      	jmp	0x9b7a <_ml_ProccessLinEvent+0xb8>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    9b56:	ac0c      	cmp	A, #12
    9b58:	1d05      	jne	0x9b64 <_ml_ProccessLinEvent+0xa2>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    9b5a:	44c6      	rl	Y, #2
    9b5c:	44c6      	rl	Y, #2
    9b5e:	f40f      	and	Y, #15
                        if(nbytes == 0)
    9b60:	1d0c      	jne	0x9b7a <_ml_ProccessLinEvent+0xb8>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    9b62:	007e      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    9b64:	ac02      	cmp	A, #2
    9b66:	1d09      	jne	0x9b7a <_ml_ProccessLinEvent+0xb8>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    9b68:	6400      	lod	YL, #0
    9b6a:	7ae8      	swap	Y
    9b6c:	72e6      	lod	A, Y
    9b6e:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    9b70:	8c02      	cmp	AL, #2
    9b72:	1d03      	jne	0x9b7a <_ml_ProccessLinEvent+0xb8>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    9b74:	1782      	call	0x9a7a <_ml_Disconnect>
                            (void)ml_Connect();
    9b76:	177f      	call	0x9a76 <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    9b78:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    9b7a:	72ee      	lod	A, X
    9b7c:	1545      	call	0x9608 <_mlu_ErrorDetected>
                    break;
    9b7e:	0070      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    9b80:	7104      	lod	A, dp:0x4 <__data_size>
    9b82:	52d8 0038 	mov	0x38 <__bss_dp_end>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    9b86:	6106      	lod	AL, dp:0x6 <__bss_size>
    9b88:	42d8 003a 	mov	0x3a <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    9b8c:	6201      	lod	AL, [S-2]
    9b8e:	8c10      	cmp	AL, #16
    9b90:	1902      	je	0x9b96 <_ml_ProccessLinEvent+0xd4>
                        mlu_MessageReceived(LinID); /* notify application */
    9b92:	7201      	lod	A, [S-2]
    9b94:	000a      	jmp	0x9baa <_ml_ProccessLinEvent+0xe8>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    9b96:	54ca 0000 	pushw	#0
    9b9a:	72da 0018 	lod	A, #24
    9b9e:	1074      	call	0x9c88 <_ldr_isReadByIdMessage>
    9ba0:	5c01      	dec	S, #2
    9ba2:	8c00      	cmp	AL, #0
    9ba4:	1901      	je	0x9ba8 <_ml_ProccessLinEvent+0xe6>
    9ba6:	0031      	jmp	0x9c0a <_ml_ProccessLinEvent+0x148>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    9ba8:	7010      	lod	A, #16
    9baa:	1530      	call	0x960c <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    9bac:	0059      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    9bae:	7104      	lod	A, dp:0x4 <__data_size>
    9bb0:	52d8 0038 	mov	0x38 <__bss_dp_end>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    9bb4:	6106      	lod	AL, dp:0x6 <__bss_size>
    9bb6:	42d8 003a 	mov	0x3a <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    9bba:	7201      	lod	A, [S-2]
    9bbc:	1522      	call	0x9602 <_mlu_DataRequest>
                    break;
    9bbe:	0050      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    9bc0:	1522      	call	0x9606 <_mlu_DataTransmitted>
                    break;
    9bc2:	004e      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    9bc4:	7203      	lod	A, [S-4]
    9bc6:	ac03      	cmp	A, #3
    9bc8:	190d      	je	0x9be4 <_ml_ProccessLinEvent+0x122>
    9bca:	1e03      	jug	0x9bd2 <_ml_ProccessLinEvent+0x110>
    9bcc:	ac02      	cmp	A, #2
    9bce:	1905      	je	0x9bda <_ml_ProccessLinEvent+0x118>
    9bd0:	0047      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
    9bd2:	7203      	lod	A, [S-4]
    9bd4:	ac04      	cmp	A, #4
    9bd6:	191d      	je	0x9c12 <_ml_ProccessLinEvent+0x150>
    9bd8:	0043      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    9bda:	6122      	lod	AL, dp:0x22 <_LinMessage>
    9bdc:	44b2      	lsr	A, #2
    9bde:	44b2      	lsr	A, #2
    9be0:	b40f      	and	A, #15
    9be2:	002f      	jmp	0x9c42 <_ml_ProccessLinEvent+0x180>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    9be4:	7104      	lod	A, dp:0x4 <__data_size>
    9be6:	52d8 0038 	mov	0x38 <__bss_dp_end>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    9bea:	6106      	lod	AL, dp:0x6 <__bss_size>
    9bec:	42d8 003a 	mov	0x3a <_LINBaud>, AL

                    if (LinID == D_DIA) {
    9bf0:	6201      	lod	AL, [S-2]
    9bf2:	8c10      	cmp	AL, #16
    9bf4:	1901      	je	0x9bf8 <_ml_ProccessLinEvent+0x136>
    9bf6:	0034      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    9bf8:	54ca 0001 	pushw	#1
    9bfc:	72da 0018 	lod	A, #24
    9c00:	1043      	call	0x9c88 <_ldr_isReadByIdMessage>
    9c02:	5c01      	dec	S, #2
    9c04:	8c00      	cmp	AL, #0
    9c06:	1d01      	jne	0x9c0a <_ml_ProccessLinEvent+0x148>
    9c08:	002b      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    9c0a:	611b      	lod	AL, dp:0x1b <_LinFrameDataBuffer+0x3>
    9c0c:	5cf2      	usex	A
    9c0e:	11b0      	call	0x9f70 <_ml_ldr_ReadByIdMessage>
    9c10:	0027      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    9c12:	7104      	lod	A, dp:0x4 <__data_size>
    9c14:	52d8 0038 	mov	0x38 <__bss_dp_end>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    9c18:	6106      	lod	AL, dp:0x6 <__bss_size>
    9c1a:	42d8 003a 	mov	0x3a <_LINBaud>, AL
    9c1e:	001d      	jmp	0x9c5a <_ml_ProccessLinEvent+0x198>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    9c20:	7203      	lod	A, [S-4]
    9c22:	ac03      	cmp	A, #3
    9c24:	1910      	je	0x9c46 <_ml_ProccessLinEvent+0x184>
    9c26:	1e03      	jug	0x9c2e <_ml_ProccessLinEvent+0x16c>
    9c28:	ac02      	cmp	A, #2
    9c2a:	1907      	je	0x9c3a <_ml_ProccessLinEvent+0x178>
    9c2c:	0019      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
    9c2e:	7203      	lod	A, [S-4]
    9c30:	ac04      	cmp	A, #4
    9c32:	1913      	je	0x9c5a <_ml_ProccessLinEvent+0x198>
    9c34:	ac05      	cmp	A, #5
    9c36:	1913      	je	0x9c5e <_ml_ProccessLinEvent+0x19c>
    9c38:	0013      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    9c3a:	44b6      	lsr	Y, #2
    9c3c:	44b6      	lsr	Y, #2
    9c3e:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    9c40:	72e6      	lod	A, Y
    9c42:	10fe      	call	0x9e40 <_ml_ldr_ErrorDetected>
                 break;
    9c44:	000d      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    9c46:	6201      	lod	AL, [S-2]
    9c48:	8c10      	cmp	AL, #16
    9c4a:	1d0a      	jne	0x9c60 <_ml_ProccessLinEvent+0x19e>
    9c4c:	6118      	lod	AL, dp:0x18 <_LinFrameDataBuffer>
    9c4e:	8d20      	cmp	AL, dp:0x20 <__bss_dp_size>
    9c50:	1902      	je	0x9c56 <_ml_ProccessLinEvent+0x194>
    9c52:	8c7f      	cmp	AL, #127
    9c54:	1d05      	jne	0x9c60 <_ml_ProccessLinEvent+0x19e>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    9c56:	11da      	call	0xa00c <_ml_DiagReceived>
    9c58:	0003      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    9c5a:	16b7      	call	0x99ca <_ml_DiscardFrame>
                 break;
    9c5c:	0001      	jmp	0x9c60 <_ml_ProccessLinEvent+0x19e>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    9c5e:	11a4      	call	0x9fa8 <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    9c60:	60ab      	lod	AL, #-85
    9c62:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    9c66:	5405      	ret	#6

00009c68 <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    9c68:	42d8 0014 	mov	0x14 <_stFixedRamNAD+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    9c6c:	7ada 0010 	lod	Y, #16
    9c70:	7eda 72ef 	lod	X, #29423
    9c74:	5ef0      	mov	[Y], X
    9c76:	7eda e861 	lod	X, #59489
    9c7a:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    9c7c:	4120      	mov	dp:0x20 <__bss_dp_size>, AL
    return ML_SUCCESS;
}
    9c7e:	7000      	lod	A, #0
    9c80:	5401      	ret

00009c82 <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    9c82:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9c84:	5cf2      	usex	A
}
    9c86:	5401      	ret

00009c88 <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    9c88:	5801      	inc	S, #2
    9c8a:	7ae2      	lod	Y, A
    9c8c:	6205      	lod	AL, [S-6]
    9c8e:	5cf2      	usex	A
    9c90:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    9c92:	7ef0      	lod	X, [Y]
    9c94:	2eda 067f 	cmp	X, #1663
    9c98:	1907      	je	0x9ca8 <_ldr_isReadByIdMessage+0x20>
    9c9a:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9c9c:	b6da 06ff 	and	A, #1791
    9ca0:	a6da 0600 	or	A, #1536
    9ca4:	2ee2      	cmp	X, A
    9ca6:	1d15      	jne	0x9cd2 <_ldr_isReadByIdMessage+0x4a>
    9ca8:	72f2      	lod	A, [Y+2]
    9caa:	8cb2      	cmp	AL, #-78
    9cac:	1d12      	jne	0x9cd2 <_ldr_isReadByIdMessage+0x4a>
    9cae:	7ef4      	lod	X, [Y+4]
    9cb0:	2c13      	cmp	X, #19
    9cb2:	1d04      	jne	0x9cbc <_ldr_isReadByIdMessage+0x34>
    9cb4:	72f6      	lod	A, [Y+6]
    9cb6:	aeda cafe 	cmp	A, #51966
    9cba:	1909      	je	0x9cce <_ldr_isReadByIdMessage+0x46>
    9cbc:	6201      	lod	AL, [S-2]
    9cbe:	8c01      	cmp	AL, #1
    9cc0:	1d08      	jne	0x9cd2 <_ldr_isReadByIdMessage+0x4a>
    9cc2:	2eda 7fff 	cmp	X, #32767
    9cc6:	1d05      	jne	0x9cd2 <_ldr_isReadByIdMessage+0x4a>
    9cc8:	72f6      	lod	A, [Y+6]
    9cca:	acff      	cmp	A, #-1
    9ccc:	1d02      	jne	0x9cd2 <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    9cce:	7001      	lod	A, #1
    9cd0:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    9cd2:	7000      	lod	A, #0
    }
}
    9cd4:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    9cd6:	5801      	inc	S, #2
    9cd8:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    9cda:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9cdc:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    9cde:	6003      	lod	AL, #3
    9ce0:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    9ce2:	607f      	lod	AL, #127
    9ce4:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    9ce6:	13b7      	call	0xa456 <_LDR_GetState>
    9ce8:	8480      	or	AL, #-128
    9cea:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    9cec:	6125      	lod	AL, dp:0x25 <_ml_driver_mode+0x1>
    9cee:	8601      	or	AL, [S-2]
    9cf0:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    9cf2:	60ff      	lod	AL, #-1
    9cf4:	411d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    9cf6:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
    LinFrameDataBuffer[7] = 0xFF;
    9cf8:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    9cfa:	6000      	lod	AL, #0
    9cfc:	4125      	mov	dp:0x25 <_ml_driver_mode+0x1>, AL
    9cfe:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    9d00:	5801      	inc	S, #2
    9d02:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    9d04:	aeda 00f0 	cmp	A, #240
    9d08:	1d02      	jne	0x9d0e <_ldr_isReadByIdMessage+0x86>
    9d0a:	6125      	lod	AL, dp:0x25 <_ml_driver_mode+0x1>
    9d0c:	1904      	je	0x9d16 <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    9d0e:	72e6      	lod	A, Y
    9d10:	17e2      	call	0x9cd6 <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    9d12:	7000      	lod	A, #0
    9d14:	000e      	jmp	0x9d32 <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    9d16:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9d18:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    9d1a:	6002      	lod	AL, #2
    9d1c:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    9d1e:	60f4      	lod	AL, #-12
    9d20:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    9d22:	1399      	call	0xa456 <_LDR_GetState>
    9d24:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    9d26:	60ff      	lod	AL, #-1
    9d28:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    9d2a:	411d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    9d2c:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
        LinFrameDataBuffer[7] = 0xFF;
    9d2e:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL
        blReturn = ML_TRUE;
    9d30:	7001      	lod	A, #1
    9d32:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    9d34:	7000      	lod	A, #0
    9d36:	1620      	call	0x9978 <_ml_DataReady>

    return ( blReturn );
}
    9d38:	7201      	lod	A, [S-2]
    9d3a:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    9d3c:	5807      	inc	S, #8
    9d3e:	660b      	lod	YL, [S-12]
    9d40:	5cf6      	usex	Y
    9d42:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    9d44:	792c      	lod	Y, dp:0x2c <_ml_driver_mode+0x8>
    9d46:	e134      	add	Y, dp:0x34 <_ml_driver_mode+0x10>
    9d48:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    9d4a:	7ae2      	lod	Y, A
    9d4c:	e2da 0018 	add	Y, #24


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    9d50:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    9d52:	5205      	mov	[S-6], A
    9d54:	72e6      	lod	A, Y
    9d56:	a001      	add	A, #1
    9d58:	5203      	mov	[S-4], A
    9d5a:	20ff      	add	X, #-1
    9d5c:	5e01      	mov	[S-2], X
    9d5e:	7e05      	lod	X, [S-6]
    9d60:	2d30      	cmp	X, dp:0x30 <_ml_driver_mode+0xc>
    9d62:	1c04      	jnc	0x9d6c <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    9d64:	7e07      	lod	X, [S-8]
    9d66:	62de      	lod	AL, [X++]
    9d68:	5e07      	mov	[S-8], X
    9d6a:	0001      	jmp	0x9d6e <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    9d6c:	60ff      	lod	AL, #-1
    9d6e:	42f0      	mov	[Y], AL
    9d70:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    9d72:	7205      	lod	A, [S-6]
    9d74:	a001      	add	A, #1
    9d76:	5134      	mov	dp:0x34 <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    9d78:	7e01      	lod	X, [S-2]
    9d7a:	1d6a      	jne	0x9d50 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    9d7c:	ad30      	cmp	A, dp:0x30 <_ml_driver_mode+0xc>
    9d7e:	1802      	jc	0x9d84 <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    9d80:	7000      	lod	A, #0
    9d82:	1625      	call	0x99ce <_ml_ContFrame>
    9d84:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    9d86:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    9d88:	6125      	lod	AL, dp:0x25 <_ml_driver_mode+0x1>
    9d8a:	1904      	je	0x9d94 <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    9d8c:	72da 00f0 	lod	A, #240
    9d90:	17a2      	call	0x9cd6 <_ldr_isReadByIdMessage+0x4e>
    9d92:	0039      	jmp	0x9e06 <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    9d94:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    9d96:	7ae2      	lod	Y, A
    9d98:	e002      	add	Y, #2
    9d9a:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    9d9c:	ac04      	cmp	A, #4
    9d9e:	1a17      	jule	0x9dce <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    9da0:	7001      	lod	A, #1
    9da2:	1615      	call	0x99ce <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    9da4:	6000      	lod	AL, #0
    9da6:	4136      	mov	dp:0x36 <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    9da8:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9daa:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    9dac:	7201      	lod	A, [S-2]
    9dae:	b6da 0f00 	and	A, #3840
    9db2:	6000      	lod	AL, #0
    9db4:	72e4      	swap	A
    9db6:	8410      	or	AL, #16
    9db8:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    9dba:	6601      	lod	YL, [S-2]
    9dbc:	451a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    9dbe:	60f4      	lod	AL, #-12
    9dc0:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    9dc2:	1349      	call	0xa456 <_LDR_GetState>
    9dc4:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    9dc6:	54ca 0003 	pushw	#3
    9dca:	7005      	lod	A, #5
    9dcc:	001a      	jmp	0x9e02 <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    9dce:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9dd0:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    9dd2:	6201      	lod	AL, [S-2]
    9dd4:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    9dd6:	60f4      	lod	AL, #-12
    9dd8:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    9dda:	133d      	call	0xa456 <_LDR_GetState>
    9ddc:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    9dde:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    9de0:	aeda bf66 	cmp	A, #48998
    9de4:	1d0b      	jne	0x9dfc <_ldr_isReadByIdMessage+0x174>
    9de6:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    9de8:	ac02      	cmp	A, #2
    9dea:	1d08      	jne	0x9dfc <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    9dec:	1334      	call	0xa456 <_LDR_GetState>
    9dee:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    9df0:	6400      	lod	YL, #0
    9df2:	451d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    9df4:	60ff      	lod	AL, #-1
    9df6:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    9df8:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL
    9dfa:	0005      	jmp	0x9e06 <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    9dfc:	54ca 0004 	pushw	#4
    9e00:	7004      	lod	A, #4
    9e02:	179c      	call	0x9d3c <_ldr_isReadByIdMessage+0xb4>
    9e04:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    9e06:	7000      	lod	A, #0
    9e08:	15b7      	call	0x9978 <_ml_DataReady>
    9e0a:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    9e0c:	5801      	inc	S, #2
    9e0e:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    9e10:	6125      	lod	AL, dp:0x25 <_ml_driver_mode+0x1>
    9e12:	1904      	je	0x9e1c <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    9e14:	72da 00f0 	lod	A, #240
    9e18:	175e      	call	0x9cd6 <_ldr_isReadByIdMessage+0x4e>
    9e1a:	000f      	jmp	0x9e3a <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    9e1c:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9e1e:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    9e20:	6006      	lod	AL, #6
    9e22:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    9e24:	60f4      	lod	AL, #-12
    9e26:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    9e28:	1316      	call	0xa456 <_LDR_GetState>
    9e2a:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    9e2c:	7930      	lod	Y, dp:0x30 <_ml_driver_mode+0xc>
    9e2e:	4d1c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    9e30:	451d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    9e32:	7201      	lod	A, [S-2]
    9e34:	491e      	mov	dp:0x1e <__ramfunc_size>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    9e36:	6201      	lod	AL, [S-2]
    9e38:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    9e3a:	7000      	lod	A, #0
    9e3c:	159d      	call	0x9978 <_ml_DataReady>
    9e3e:	5403      	ret	#4

00009e40 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    9e40:	ac0a      	cmp	A, #10
    9e42:	1901      	je	0x9e46 <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    9e44:	4125      	mov	dp:0x25 <_ml_driver_mode+0x1>, AL
    9e46:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    9e48:	5807      	inc	S, #8
    9e4a:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    9e4c:	6125      	lod	AL, dp:0x25 <_ml_driver_mode+0x1>
    9e4e:	1904      	je	0x9e58 <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    9e50:	72da 00f0 	lod	A, #240
    9e54:	1740      	call	0x9cd6 <_ldr_isReadByIdMessage+0x4e>
    9e56:	0040      	jmp	0x9ed8 <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    9e58:	1610      	call	0x9a7a <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    9e5a:	792c      	lod	Y, dp:0x2c <_ml_driver_mode+0x8>
    9e5c:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    9e5e:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    9e60:	7000      	lod	A, #0
    9e62:	5201      	mov	[S-2], A
    9e64:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    9e66:	5203      	mov	[S-4], A
    9e68:	7000      	lod	A, #0
    9e6a:	ae03      	cmp	A, [S-4]
    9e6c:	1c26      	jnc	0x9eba <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    9e6e:	7ae8      	swap	Y
        crc ^= *data;
    9e70:	7e05      	lod	X, [S-6]
    9e72:	62de      	lod	AL, [X++]
    9e74:	5e05      	mov	[S-6], X
    9e76:	5cf2      	usex	A
    9e78:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    9e7a:	62e8      	lod	AL, YL
    9e7c:	44b0      	lsr	AL, #2
    9e7e:	44b0      	lsr	AL, #2
    9e80:	5cf2      	usex	A
    9e82:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    9e84:	72e6      	lod	A, Y
    9e86:	b40f      	and	A, #15
    9e88:	44d2      	rr	A, #2
    9e8a:	44d2      	rr	A, #2
    9e8c:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    9e8e:	72e6      	lod	A, Y
    9e90:	b6da 00ff 	and	A, #255
    9e94:	44a2      	asl	A, #2
    9e96:	44a2      	asl	A, #2
    9e98:	4422      	asl	A
    9e9a:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    9e9c:	7201      	lod	A, [S-2]
    9e9e:	b6da 0fff 	and	A, #4095
    9ea2:	1d07      	jne	0x9eb2 <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    9ea4:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    9ea6:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    9ea8:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    9eaa:	b430      	and	A, #48
    9eac:	1902      	je	0x9eb2 <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    9eae:	6000      	lod	AL, #0
    9eb0:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    9eb2:	7201      	lod	A, [S-2]
    9eb4:	a001      	add	A, #1
    9eb6:	5201      	mov	[S-2], A
    9eb8:	07d8      	jmp	0x9e6a <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    9eba:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9ebc:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    9ebe:	6006      	lod	AL, #6
    9ec0:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    9ec2:	60f4      	lod	AL, #-12
    9ec4:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    9ec6:	60ff      	lod	AL, #-1
    9ec8:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    9eca:	4d1c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    9ecc:	451d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    9ece:	7207      	lod	A, [S-8]
    9ed0:	491e      	mov	dp:0x1e <__ramfunc_size>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    9ed2:	6607      	lod	YL, [S-8]
    9ed4:	451f      	mov	dp:0x1f <__ramfunc_size+0x1>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    9ed6:	15cf      	call	0x9a76 <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    9ed8:	7000      	lod	A, #0
    9eda:	154e      	call	0x9978 <_ml_DataReady>
    9edc:	5409      	ret	#10

00009ede <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    9ede:	5801      	inc	S, #2
    9ee0:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    9ee2:	12b9      	call	0xa456 <_LDR_GetState>
    9ee4:	8c00      	cmp	AL, #0
    9ee6:	1d09      	jne	0x9efa <_ml_ldr_SwitchToProgMode+0x1c>
    9ee8:	82db 95fc 	callf	0x95fc <_mlu_ApplicationStop>
    9eec:	8c00      	cmp	AL, #0
    9eee:	1905      	je	0x9efa <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    9ef0:	6000      	lod	AL, #0
    9ef2:	4124      	mov	dp:0x24 <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    9ef4:	7000      	lod	A, #0
    9ef6:	153b      	call	0x996e <_ml_ReleaseBufferProg>
    9ef8:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    9efa:	7000      	lod	A, #0
    9efc:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    9f00:	12aa      	call	0xa456 <_LDR_GetState>
    9f02:	8c00      	cmp	AL, #0
    9f04:	1d0b      	jne	0x9f1c <_ml_ldr_SwitchToProgMode+0x3e>
    9f06:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    9f0a:	aeda 3212 	cmp	A, #12818
    9f0e:	1906      	je	0x9f1c <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    9f10:	1525      	call	0x995c <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    9f12:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    9f16:	a410      	or	A, #16
    9f18:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    9f1c:	6055      	lod	AL, #85
    9f1e:	4124      	mov	dp:0x24 <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    9f20:	6000      	lod	AL, #0
    9f22:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    9f24:	12a3      	call	0xa46c <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    9f26:	7001      	lod	A, #1
    9f28:	1522      	call	0x996e <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    9f2a:	6201      	lod	AL, [S-2]
    9f2c:	8c01      	cmp	AL, #1
    9f2e:	1d0c      	jne	0x9f48 <_ml_ldr_SwitchToProgMode+0x6a>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    9f30:	72da 3212 	lod	A, #12818
    9f34:	52d8 0044 	mov	0x44 <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    9f38:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    9f3c:	94fe      	and	AL, #-2
    9f3e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    9f42:	82db a936 	callf	0xa936 <_MLX16_RESET>
            for (;;) {
    9f46:	07ff      	jmp	0x9f46 <_ml_ldr_SwitchToProgMode+0x68>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    9f48:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9f4a:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    9f4c:	6006      	lod	AL, #6
    9f4e:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    9f50:	60f2      	lod	AL, #-14
    9f52:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    9f54:	4cea 0004 	movu	YA, #4
    9f58:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    9f5a:	4cea 0401 	movu	YA, #1025
    9f5e:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    9f60:	6000      	lod	AL, #0
    9f62:	411d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    9f64:	411e      	mov	dp:0x1e <__ramfunc_size>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    9f66:	1277      	call	0xa456 <_LDR_GetState>
    9f68:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    9f6a:	7000      	lod	A, #0
    9f6c:	1505      	call	0x9978 <_ml_DataReady>
    9f6e:	5403      	ret	#4

00009f70 <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    9f70:	8c33      	cmp	AL, #51
    9f72:	1d03      	jne	0x9f7a <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    9f74:	7001      	lod	A, #1
    9f76:	17b3      	call	0x9ede <_ml_ldr_SwitchToProgMode>
    9f78:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    9f7a:	ac00      	cmp	A, #0
    9f7c:	1d14      	jne	0x9fa6 <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    9f7e:	7001      	lod	A, #1
    9f80:	14f6      	call	0x996e <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    9f82:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9f84:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    9f86:	6006      	lod	AL, #6
    9f88:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    9f8a:	60f2      	lod	AL, #-14
    9f8c:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    9f8e:	6013      	lod	AL, #19
    9f90:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    9f92:	6000      	lod	AL, #0
    9f94:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    9f96:	60fe      	lod	AL, #-2
    9f98:	411d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    9f9a:	60ca      	lod	AL, #-54
    9f9c:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    9f9e:	6001      	lod	AL, #1
    9fa0:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    9fa2:	7000      	lod	A, #0
    9fa4:	14e9      	call	0x9978 <_ml_DataReady>
    9fa6:	5401      	ret

00009fa8 <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    9fa8:	6137      	lod	AL, dp:0x37 <_ml_driver_mode+0x13>
    9faa:	8c03      	cmp	AL, #3
    9fac:	1d15      	jne	0x9fd8 <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    9fae:	7000      	lod	A, #0
    9fb0:	150e      	call	0x99ce <_ml_ContFrame>
            (void)ml_Disconnect();
    9fb2:	1563      	call	0x9a7a <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    9fb4:	6128      	lod	AL, dp:0x28 <_ml_driver_mode+0x4>
    9fb6:	5cf2      	usex	A
    9fb8:	1372      	call	0xa69e <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    9fba:	54ca 0000 	pushw	#0
    9fbe:	54ca 0001 	pushw	#1
    9fc2:	54ca 0000 	pushw	#0
    9fc6:	7001      	lod	A, #1
    9fc8:	14f5      	call	0x99b4 <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    9fca:	7001      	lod	A, #1
    9fcc:	14ef      	call	0x99ac <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    9fce:	1557      	call	0x9a7e <_ml_SwitchToFast>
            pendingAction = 0;
    9fd0:	6000      	lod	AL, #0
    9fd2:	4137      	mov	dp:0x37 <_ml_driver_mode+0x13>, AL
            break;
    9fd4:	5c05      	dec	S, #6
    9fd6:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    9fd8:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    9fda:	8c06      	cmp	AL, #6
    9fdc:	1902      	je	0x9fe2 <_ml_DiagRequest+0x3a>
    9fde:	8c08      	cmp	AL, #8
    9fe0:	1d14      	jne	0xa00a <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    9fe2:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    9fe4:	ad30      	cmp	A, dp:0x30 <_ml_driver_mode+0xc>
    9fe6:	1c11      	jnc	0xa00a <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    9fe8:	6136      	lod	AL, dp:0x36 <_ml_driver_mode+0x12>
    9fea:	8001      	add	AL, #1
    9fec:	66e0      	lod	YL, AL
    9fee:	4136      	mov	dp:0x36 <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    9ff0:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    9ff2:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    9ff4:	62e8      	lod	AL, YL
    9ff6:	940f      	and	AL, #15
    9ff8:	8420      	or	AL, #32
    9ffa:	4119      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    9ffc:	54ca 0006 	pushw	#6
    a000:	7002      	lod	A, #2
    a002:	169c      	call	0x9d3c <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    a004:	7000      	lod	A, #0
    a006:	14b8      	call	0x9978 <_ml_DataReady>
    a008:	5c01      	dec	S, #2
    a00a:	5401      	ret

0000a00c <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    a00c:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    a00e:	6119      	lod	AL, dp:0x19 <_LinFrameDataBuffer+0x1>
    a010:	5cf2      	usex	A
    a012:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    a014:	b6da 00f0 	and	A, #240
    a018:	ac20      	cmp	A, #32
    a01a:	1901      	je	0xa01e <_ml_DiagReceived+0x12>
    a01c:	0071      	jmp	0xa100 <_ml_DiagReceived+0xf4>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    a01e:	7a0b      	lod	Y, [S-12]
    a020:	f40f      	and	Y, #15
    a022:	6136      	lod	AL, dp:0x36 <_ml_driver_mode+0x12>
    a024:	4209      	mov	[S-10], AL
    a026:	b40f      	and	A, #15
    a028:	eee2      	cmp	Y, A
    a02a:	1901      	je	0xa02e <_ml_DiagReceived+0x22>
    a02c:	0065      	jmp	0xa0f8 <_ml_DiagReceived+0xec>
                ddFrameCounter += 1;
    a02e:	6209      	lod	AL, [S-10]
    a030:	8001      	add	AL, #1
    a032:	4136      	mov	dp:0x36 <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    a034:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    a036:	8c85      	cmp	AL, #-123
    a038:	1901      	je	0xa03c <_ml_DiagReceived+0x30>
    a03a:	003d      	jmp	0xa0b6 <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    a03c:	7800      	lod	Y, #0
    a03e:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    a040:	7934      	lod	Y, dp:0x34 <_ml_driver_mode+0x10>
    a042:	ed30      	cmp	Y, dp:0x30 <_ml_driver_mode+0xc>
    a044:	1c0a      	jnc	0xa05a <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    a046:	712e      	lod	A, dp:0x2e <_ml_driver_mode+0xa>
    a048:	a2e6      	add	A, Y
    a04a:	7a0d      	lod	Y, [S-14]
    a04c:	e2da 001a 	add	Y, #26
    a050:	66f0      	lod	YL, [Y]
    a052:	5cf6      	usex	Y
    a054:	5adf      	push	Y
    a056:	1241      	call	0xa4da <_Flash_PageBufferFill>
    a058:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    a05a:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    a05c:	a001      	add	A, #1
    a05e:	5134      	mov	dp:0x34 <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    a060:	7a0d      	lod	Y, [S-14]
    a062:	e001      	add	Y, #1
    a064:	5a0d      	mov	[S-14], Y
    a066:	ec05      	cmp	Y, #5
    a068:	1a6b      	jule	0xa040 <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    a06a:	ad30      	cmp	A, dp:0x30 <_ml_driver_mode+0xc>
    a06c:	1c01      	jnc	0xa070 <_ml_DiagReceived+0x64>
    a06e:	01f2      	jmp	0xa454 <_ml_DiagReceived+0x448>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    a070:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a072:	1303      	call	0xa67a <_Flash_PageWriteFiltered>
    a074:	512a      	mov	dp:0x2a <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    a076:	ac00      	cmp	A, #0
    a078:	1901      	je	0xa07c <_ml_DiagReceived+0x70>
    a07a:	0040      	jmp	0xa0fc <_ml_DiagReceived+0xf0>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    a07c:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    a07e:	7932      	lod	Y, dp:0x32 <_ml_driver_mode+0xe>
    a080:	aee6      	cmp	A, Y
    a082:	1c15      	jnc	0xa0ae <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    a084:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a086:	7ee2      	lod	X, A
    a088:	22da 0080 	add	X, #128
    a08c:	5d2c      	mov	dp:0x2c <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    a08e:	7000      	lod	A, #0
    a090:	512e      	mov	dp:0x2e <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    a092:	5134      	mov	dp:0x34 <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    a094:	5930      	mov	dp:0x30 <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    a096:	eeda 0080 	cmp	Y, #128
    a09a:	1a03      	jule	0xa0a2 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    a09c:	72da 0080 	lod	A, #128
    a0a0:	5130      	mov	dp:0x30 <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    a0a2:	72e6      	lod	A, Y
    a0a4:	a930      	sub	A, dp:0x30 <_ml_driver_mode+0xc>
    a0a6:	5132      	mov	dp:0x32 <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    a0a8:	72ee      	lod	A, X
    a0aa:	1208      	call	0xa4bc <_Flash_PageRead>
    a0ac:	0027      	jmp	0xa0fc <_ml_DiagReceived+0xf0>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    a0ae:	7800      	lod	Y, #0
    a0b0:	5930      	mov	dp:0x30 <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    a0b2:	5932      	mov	dp:0x32 <_ml_driver_mode+0xe>, Y
    a0b4:	0023      	jmp	0xa0fc <_ml_DiagReceived+0xf0>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    a0b6:	8c47      	cmp	AL, #71
    a0b8:	1d21      	jne	0xa0fc <_ml_DiagReceived+0xf0>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    a0ba:	7000      	lod	A, #0
    a0bc:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    a0be:	7934      	lod	Y, dp:0x34 <_ml_driver_mode+0x10>
    a0c0:	ed30      	cmp	Y, dp:0x30 <_ml_driver_mode+0xc>
    a0c2:	1c0a      	jnc	0xa0d8 <_ml_DiagReceived+0xcc>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    a0c4:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a0c6:	a2e6      	add	A, Y
    a0c8:	7a0d      	lod	Y, [S-14]
    a0ca:	e2da 001a 	add	Y, #26
    a0ce:	66f0      	lod	YL, [Y]
    a0d0:	5cf6      	usex	Y
    a0d2:	5adf      	push	Y
    a0d4:	142e      	call	0x9932 <_NVRAM_BufferFill>
    a0d6:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    a0d8:	7134      	lod	A, dp:0x34 <_ml_driver_mode+0x10>
    a0da:	a001      	add	A, #1
    a0dc:	5134      	mov	dp:0x34 <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    a0de:	7a0d      	lod	Y, [S-14]
    a0e0:	e001      	add	Y, #1
    a0e2:	5a0d      	mov	[S-14], Y
    a0e4:	ec05      	cmp	Y, #5
    a0e6:	1a6b      	jule	0xa0be <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    a0e8:	ad30      	cmp	A, dp:0x30 <_ml_driver_mode+0xc>
    a0ea:	1c01      	jnc	0xa0ee <_ml_DiagReceived+0xe2>
    a0ec:	01b3      	jmp	0xa454 <_ml_DiagReceived+0x448>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    a0ee:	1436      	call	0x995c <_NVRAM_SaveAll>
                        ddDataSize = 0;
    a0f0:	7000      	lod	A, #0
    a0f2:	5130      	mov	dp:0x30 <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    a0f4:	146c      	call	0x99ce <_ml_ContFrame>
    a0f6:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    a0f8:	6400      	lod	YL, #0
    a0fa:	4526      	mov	dp:0x26 <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    a0fc:	7000      	lod	A, #0
    a0fe:	07fa      	jmp	0xa0f4 <_ml_DiagReceived+0xe8>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    a100:	ac10      	cmp	A, #16
    a102:	1901      	je	0xa106 <_ml_DiagReceived+0xfa>
    a104:	0040      	jmp	0xa186 <_ml_DiagReceived+0x17a>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    a106:	611b      	lod	AL, dp:0x1b <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    a108:	8cb4      	cmp	AL, #-76
    a10a:	1901      	je	0xa10e <_ml_DiagReceived+0x102>
    a10c:	019d      	jmp	0xa448 <_ml_DiagReceived+0x43c>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    a10e:	611c      	lod	AL, dp:0x1c <_LinFrameDataBuffer+0x4>
    a110:	8cd3      	cmp	AL, #-45
    a112:	1901      	je	0xa116 <_ml_DiagReceived+0x10a>
    a114:	0199      	jmp	0xa448 <_ml_DiagReceived+0x43c>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    a116:	6001      	lod	AL, #1
    a118:	4136      	mov	dp:0x36 <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    a11a:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    a11c:	8c85      	cmp	AL, #-123
    a11e:	1d14      	jne	0xa148 <_ml_DiagReceived+0x13c>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    a120:	611d      	lod	AL, dp:0x1d <_LinFrameDataBuffer+0x5>
    a122:	5cf2      	usex	A
    a124:	52df      	push	A
    a126:	712e      	lod	A, dp:0x2e <_ml_driver_mode+0xa>
    a128:	11d8      	call	0xa4da <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    a12a:	712e      	lod	A, dp:0x2e <_ml_driver_mode+0xa>
    a12c:	a001      	add	A, #1
    a12e:	651e      	lod	YL, dp:0x1e <__ramfunc_size>
    a130:	5cf6      	usex	Y
    a132:	5adf      	push	Y
    a134:	11d2      	call	0xa4da <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    a136:	712e      	lod	A, dp:0x2e <_ml_driver_mode+0xa>
    a138:	a002      	add	A, #2
    a13a:	651f      	lod	YL, dp:0x1f <__ramfunc_size+0x1>
    a13c:	5cf6      	usex	Y
    a13e:	5adf      	push	Y
    a140:	11cc      	call	0xa4da <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    a142:	7003      	lod	A, #3
    a144:	5134      	mov	dp:0x34 <_ml_driver_mode+0x10>, A
    a146:	0018      	jmp	0xa178 <_ml_DiagReceived+0x16c>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    a148:	8c47      	cmp	AL, #71
    a14a:	1d1a      	jne	0xa180 <_ml_DiagReceived+0x174>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    a14c:	611d      	lod	AL, dp:0x1d <_LinFrameDataBuffer+0x5>
    a14e:	5cf2      	usex	A
    a150:	52df      	push	A
    a152:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a154:	82db 9932 	callf	0x9932 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    a158:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a15a:	a001      	add	A, #1
    a15c:	651e      	lod	YL, dp:0x1e <__ramfunc_size>
    a15e:	5cf6      	usex	Y
    a160:	5adf      	push	Y
    a162:	82db 9932 	callf	0x9932 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    a166:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a168:	a002      	add	A, #2
    a16a:	651f      	lod	YL, dp:0x1f <__ramfunc_size+0x1>
    a16c:	5cf6      	usex	Y
    a16e:	5adf      	push	Y
    a170:	82db 9932 	callf	0x9932 <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    a174:	7803      	lod	Y, #3
    a176:	5934      	mov	dp:0x34 <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    a178:	7001      	lod	A, #1
    a17a:	1429      	call	0x99ce <_ml_ContFrame>
    a17c:	5c05      	dec	S, #6
    a17e:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    a180:	7020      	lod	A, #32
    a182:	15be      	call	0x9d00 <_ldr_isReadByIdMessage+0x78>
    a184:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    a186:	620b      	lod	AL, [S-12]
    a188:	94f0      	and	AL, #-16
    a18a:	1901      	je	0xa18e <_ml_DiagReceived+0x182>
    a18c:	0160      	jmp	0xa44e <_ml_DiagReceived+0x442>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    a18e:	7000      	lod	A, #0
    a190:	141e      	call	0x99ce <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    a192:	720b      	lod	A, [S-12]
    a194:	b40f      	and	A, #15
    a196:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    a198:	611a      	lod	AL, dp:0x1a <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    a19a:	8cb4      	cmp	AL, #-76
    a19c:	190d      	je	0xa1b8 <_ml_DiagReceived+0x1ac>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    a19e:	54ca 0001 	pushw	#1
    a1a2:	72da 0018 	lod	A, #24
    a1a6:	1570      	call	0x9c88 <_ldr_isReadByIdMessage>
    a1a8:	5c01      	dec	S, #2
    a1aa:	8c00      	cmp	AL, #0
    a1ac:	1d01      	jne	0xa1b0 <_ml_DiagReceived+0x1a4>
    a1ae:	014c      	jmp	0xa448 <_ml_DiagReceived+0x43c>
                ml_ldr_ReadByIdMessage(Data[0]);
    a1b0:	611b      	lod	AL, dp:0x1b <_LinFrameDataBuffer+0x3>
    a1b2:	5cf2      	usex	A
    a1b4:	16dd      	call	0x9f70 <_ml_ldr_ReadByIdMessage>
    a1b6:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    a1b8:	611b      	lod	AL, dp:0x1b <_LinFrameDataBuffer+0x3>
    a1ba:	4207      	mov	[S-8], AL
    a1bc:	8cd3      	cmp	AL, #-45
    a1be:	190a      	je	0xa1d4 <_ml_DiagReceived+0x1c8>
    a1c0:	8c80      	cmp	AL, #-128
    a1c2:	1908      	je	0xa1d4 <_ml_DiagReceived+0x1c8>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    a1c4:	691c      	lod	AH, dp:0x1c <_LinFrameDataBuffer+0x4>
    a1c6:	611d      	lod	AL, dp:0x1d <_LinFrameDataBuffer+0x5>
    a1c8:	512c      	mov	dp:0x2c <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    a1ca:	691e      	lod	AH, dp:0x1e <__ramfunc_size>
    a1cc:	611f      	lod	AL, dp:0x1f <__ramfunc_size+0x1>
    a1ce:	5130      	mov	dp:0x30 <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    a1d0:	7800      	lod	Y, #0
    a1d2:	5934      	mov	dp:0x34 <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    a1d4:	6607      	lod	YL, [S-8]
    a1d6:	5cf6      	usex	Y
    a1d8:	72e6      	lod	A, Y
    a1da:	b420      	and	A, #32
    a1dc:	1929      	je	0xa230 <_ml_DiagReceived+0x224>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    a1de:	72e6      	lod	A, Y
    a1e0:	b430      	and	A, #48
    a1e2:	ac20      	cmp	A, #32
    a1e4:	1d18      	jne	0xa216 <_ml_DiagReceived+0x20a>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    a1e6:	6085      	lod	AL, #-123
    a1e8:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    a1ea:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a1ec:	7ae2      	lod	Y, A
    a1ee:	f47f      	and	Y, #127
    a1f0:	592e      	mov	dp:0x2e <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    a1f2:	b480      	and	A, #-128
    a1f4:	5205      	mov	[S-6], A
    a1f6:	512c      	mov	dp:0x2c <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    a1f8:	7d30      	lod	X, dp:0x30 <_ml_driver_mode+0xc>
    a1fa:	5d32      	mov	dp:0x32 <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    a1fc:	72da 0080 	lod	A, #128
    a200:	aae6      	sub	A, Y
    a202:	5130      	mov	dp:0x30 <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    a204:	aeee      	cmp	A, X
    a206:	1a01      	jule	0xa20a <_ml_DiagReceived+0x1fe>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    a208:	5d30      	mov	dp:0x30 <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    a20a:	7205      	lod	A, [S-6]
    a20c:	1147      	call	0xa49c <_Flash_GetWriteTime>
    a20e:	15fe      	call	0x9e0c <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    a210:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a212:	1154      	call	0xa4bc <_Flash_PageRead>
    a214:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    a216:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    a218:	8cd6      	cmp	AL, #-42
    a21a:	1901      	je	0xa21e <_ml_DiagReceived+0x212>
    a21c:	0086      	jmp	0xa32a <_ml_DiagReceived+0x31e>
    a21e:	6127      	lod	AL, dp:0x27 <_ml_driver_mode+0x3>
    a220:	1901      	je	0xa224 <_ml_DiagReceived+0x218>
    a222:	0083      	jmp	0xa32a <_ml_DiagReceived+0x31e>
    a224:	6128      	lod	AL, dp:0x28 <_ml_driver_mode+0x4>
    a226:	8c01      	cmp	AL, #1
    a228:	1901      	je	0xa22c <_ml_DiagReceived+0x220>
    a22a:	007f      	jmp	0xa32a <_ml_DiagReceived+0x31e>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    a22c:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    a22e:	0105      	jmp	0xa43a <_ml_DiagReceived+0x42e>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    a230:	eeda 0080 	cmp	Y, #128
    a234:	1d01      	jne	0xa238 <_ml_DiagReceived+0x22c>
    a236:	002c      	jmp	0xa290 <_ml_DiagReceived+0x284>
    a238:	1f0c      	jsg	0xa252 <_ml_DiagReceived+0x246>
    a23a:	ec08      	cmp	Y, #8
    a23c:	1d01      	jne	0xa240 <_ml_DiagReceived+0x234>
    a23e:	0064      	jmp	0xa308 <_ml_DiagReceived+0x2fc>
    a240:	1f04      	jsg	0xa24a <_ml_DiagReceived+0x23e>
    a242:	ec03      	cmp	Y, #3
    a244:	1d01      	jne	0xa248 <_ml_DiagReceived+0x23c>
    a246:	0038      	jmp	0xa2b8 <_ml_DiagReceived+0x2ac>
    a248:	00ff      	jmp	0xa448 <_ml_DiagReceived+0x43c>
    a24a:	ec47      	cmp	Y, #71
    a24c:	1d01      	jne	0xa250 <_ml_DiagReceived+0x244>
    a24e:	0058      	jmp	0xa300 <_ml_DiagReceived+0x2f4>
    a250:	00fb      	jmp	0xa448 <_ml_DiagReceived+0x43c>
    a252:	eeda 00c1 	cmp	Y, #193
    a256:	190f      	je	0xa276 <_ml_DiagReceived+0x26a>
    a258:	1f05      	jsg	0xa264 <_ml_DiagReceived+0x258>
    a25a:	eeda 0092 	cmp	Y, #146
    a25e:	1d01      	jne	0xa262 <_ml_DiagReceived+0x256>
    a260:	0058      	jmp	0xa312 <_ml_DiagReceived+0x306>
    a262:	00f2      	jmp	0xa448 <_ml_DiagReceived+0x43c>
    a264:	eeda 00d3 	cmp	Y, #211
    a268:	1d01      	jne	0xa26c <_ml_DiagReceived+0x260>
    a26a:	0062      	jmp	0xa330 <_ml_DiagReceived+0x324>
    a26c:	eeda 00d6 	cmp	Y, #214
    a270:	1d01      	jne	0xa274 <_ml_DiagReceived+0x268>
    a272:	00c5      	jmp	0xa3fe <_ml_DiagReceived+0x3f2>
    a274:	00e9      	jmp	0xa448 <_ml_DiagReceived+0x43c>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    a276:	10ef      	call	0xa456 <_LDR_GetState>
    a278:	66e0      	lod	YL, AL
    a27a:	611c      	lod	AL, dp:0x1c <_LinFrameDataBuffer+0x4>
    a27c:	8ee8      	cmp	AL, YL
    a27e:	1d01      	jne	0xa282 <_ml_DiagReceived+0x276>
    a280:	00e9      	jmp	0xa454 <_ml_DiagReceived+0x448>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    a282:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    a286:	94fe      	and	AL, #-2
    a288:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    a28c:	1354      	call	0xa936 <_MLX16_RESET>
                            }
                            break;
    a28e:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    a290:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    a292:	8c85      	cmp	AL, #-123
    a294:	1d09      	jne	0xa2a8 <_ml_DiagReceived+0x29c>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    a296:	712a      	lod	A, dp:0x2a <_ml_driver_mode+0x6>
    a298:	1d05      	jne	0xa2a4 <_ml_DiagReceived+0x298>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    a29a:	7130      	lod	A, dp:0x30 <_ml_driver_mode+0xc>
    a29c:	1901      	je	0xa2a0 <_ml_DiagReceived+0x294>
    a29e:	0770      	jmp	0xa180 <_ml_DiagReceived+0x174>
                                        ddCurrentOp = 0;            /* operation done */
    a2a0:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
    a2a2:	0007      	jmp	0xa2b2 <_ml_DiagReceived+0x2a6>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    a2a4:	7050      	lod	A, #80
    a2a6:	076d      	jmp	0xa182 <_ml_DiagReceived+0x176>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    a2a8:	8c47      	cmp	AL, #71
    a2aa:	1901      	je	0xa2ae <_ml_DiagReceived+0x2a2>
    a2ac:	00b6      	jmp	0xa41a <_ml_DiagReceived+0x40e>
                                ddCurrentOp = 0;                /* operation done */
    a2ae:	6400      	lod	YL, #0
    a2b0:	4526      	mov	dp:0x26 <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    a2b2:	7000      	lod	A, #0
    a2b4:	15ab      	call	0x9e0c <_ldr_isReadByIdMessage+0x184>
    a2b6:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    a2b8:	620b      	lod	AL, [S-12]
    a2ba:	8c03      	cmp	AL, #3
    a2bc:	1d08      	jne	0xa2ce <_ml_DiagReceived+0x2c2>
                                peCurrentValue = Data[1];
    a2be:	611c      	lod	AL, dp:0x1c <_LinFrameDataBuffer+0x4>
    a2c0:	4128      	mov	dp:0x28 <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    a2c2:	8c64      	cmp	AL, #100
    a2c4:	1e04      	jug	0xa2ce <_ml_DiagReceived+0x2c2>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    a2c6:	8c12      	cmp	AL, #18
    a2c8:	1e04      	jug	0xa2d2 <_ml_DiagReceived+0x2c6>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    a2ca:	6013      	lod	AL, #19
    a2cc:	0001      	jmp	0xa2d0 <_ml_DiagReceived+0x2c4>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    a2ce:	6064      	lod	AL, #100
    a2d0:	4128      	mov	dp:0x28 <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    a2d2:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    a2d4:	4118      	mov	dp:0x18 <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    a2d6:	6403      	lod	YL, #3
    a2d8:	4519      	mov	dp:0x19 <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    a2da:	60f4      	lod	AL, #-12
    a2dc:	411a      	mov	dp:0x1a <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    a2de:	10bb      	call	0xa456 <_LDR_GetState>
    a2e0:	411b      	mov	dp:0x1b <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    a2e2:	6128      	lod	AL, dp:0x28 <_ml_driver_mode+0x4>
    a2e4:	411c      	mov	dp:0x1c <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    a2e6:	60ff      	lod	AL, #-1
    a2e8:	411d      	mov	dp:0x1d <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    a2ea:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    a2ec:	411f      	mov	dp:0x1f <__ramfunc_size+0x1>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    a2ee:	7000      	lod	A, #0
    a2f0:	82db 9978 	callf	0x9978 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    a2f4:	7001      	lod	A, #1
    a2f6:	82db 99ce 	callf	0x99ce <_ml_ContFrame>
                            pendingAction = ddFastProt;
    a2fa:	6003      	lod	AL, #3
    a2fc:	4137      	mov	dp:0x37 <_ml_driver_mode+0x13>, AL
                            break;
    a2fe:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    a300:	4526      	mov	dp:0x26 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    a302:	82db 986e 	callf	0x986e <_NVRAM_LoadAll>
    a306:	07d5      	jmp	0xa2b2 <_ml_DiagReceived+0x2a6>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    a308:	4526      	mov	dp:0x26 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    a30a:	82db 986e 	callf	0x986e <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    a30e:	153b      	call	0x9d86 <_ldr_isReadByIdMessage+0xfe>
                            break;
    a310:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    a312:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a314:	6000      	lod	AL, #0
    a316:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    a318:	ac08      	cmp	A, #8
    a31a:	1902      	je	0xa320 <_ml_DiagReceived+0x314>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    a31c:	7010      	lod	A, #16
    a31e:	0731      	jmp	0xa182 <_ml_DiagReceived+0x176>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    a320:	7801      	lod	Y, #1
    a322:	5930      	mov	dp:0x30 <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    a324:	72da aad4 	lod	A, #43732
    a328:	512c      	mov	dp:0x2c <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    a32a:	6006      	lod	AL, #6
    a32c:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
    a32e:	07ef      	jmp	0xa30e <_ml_DiagReceived+0x302>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    a330:	6126      	lod	AL, dp:0x26 <_ml_driver_mode+0x2>
    a332:	8c85      	cmp	AL, #-123
    a334:	1901      	je	0xa338 <_ml_DiagReceived+0x32c>
    a336:	0042      	jmp	0xa3bc <_ml_DiagReceived+0x3b0>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    a338:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a33a:	a12e      	add	A, dp:0x2e <_ml_driver_mode+0xa>
    a33c:	aeda bf66 	cmp	A, #48998
    a340:	1d24      	jne	0xa38a <_ml_DiagReceived+0x37e>
    a342:	7132      	lod	A, dp:0x32 <_ml_driver_mode+0xe>
    a344:	ac02      	cmp	A, #2
    a346:	1d21      	jne	0xa38a <_ml_DiagReceived+0x37e>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    a348:	611c      	lod	AL, dp:0x1c <_LinFrameDataBuffer+0x4>
    a34a:	5cf2      	usex	A

                                    switch (new_state) {
    a34c:	1903      	je	0xa354 <_ml_DiagReceived+0x348>
    a34e:	ac01      	cmp	A, #1
    a350:	190d      	je	0xa36c <_ml_DiagReceived+0x360>
    a352:	0051      	jmp	0xa3f6 <_ml_DiagReceived+0x3ea>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    a354:	72da be84 	lod	A, #48772
    a358:	10b1      	call	0xa4bc <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    a35a:	72da be84 	lod	A, #48772
    a35e:	b47f      	and	A, #127
    a360:	54ca 0001 	pushw	#1
    a364:	10ba      	call	0xa4da <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    a366:	72da be84 	lod	A, #48772
    a36a:	000b      	jmp	0xa382 <_ml_DiagReceived+0x376>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    a36c:	72da be80 	lod	A, #48768
    a370:	10a5      	call	0xa4bc <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    a372:	72da be80 	lod	A, #48768
    a376:	b47f      	and	A, #127
    a378:	54ca 0001 	pushw	#1
    a37c:	10ae      	call	0xa4da <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    a37e:	72da be80 	lod	A, #48768
    a382:	10c3      	call	0xa50a <_Flash_PageWrite>
    a384:	512a      	mov	dp:0x2a <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    a386:	5c01      	dec	S, #2
    a388:	0036      	jmp	0xa3f6 <_ml_DiagReceived+0x3ea>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    a38a:	7800      	lod	Y, #0
    a38c:	5a0d      	mov	[S-14], Y
    a38e:	20fe      	add	X, #-2
    a390:	5e03      	mov	[S-4], X
    a392:	eeee      	cmp	Y, X
    a394:	1c0f      	jnc	0xa3b4 <_ml_DiagReceived+0x3a8>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    a396:	712e      	lod	A, dp:0x2e <_ml_driver_mode+0xa>
    a398:	a20d      	add	A, [S-14]
    a39a:	7a0d      	lod	Y, [S-14]
    a39c:	e2da 001c 	add	Y, #28
    a3a0:	66f0      	lod	YL, [Y]
    a3a2:	5cf6      	usex	Y
    a3a4:	5adf      	push	Y
    a3a6:	1099      	call	0xa4da <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    a3a8:	5c01      	dec	S, #2
    a3aa:	720d      	lod	A, [S-14]
    a3ac:	a001      	add	A, #1
    a3ae:	520d      	mov	[S-14], A
    a3b0:	ae03      	cmp	A, [S-4]
    a3b2:	1871      	jc	0xa396 <_ml_DiagReceived+0x38a>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    a3b4:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a3b6:	1161      	call	0xa67a <_Flash_PageWriteFiltered>
    a3b8:	512a      	mov	dp:0x2a <_ml_driver_mode+0x6>, A
    a3ba:	001d      	jmp	0xa3f6 <_ml_DiagReceived+0x3ea>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    a3bc:	8c47      	cmp	AL, #71
    a3be:	1d19      	jne	0xa3f2 <_ml_DiagReceived+0x3e6>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    a3c0:	7800      	lod	Y, #0
    a3c2:	5a0d      	mov	[S-14], Y
    a3c4:	20fe      	add	X, #-2
    a3c6:	5e01      	mov	[S-2], X
    a3c8:	eeee      	cmp	Y, X
    a3ca:	1c10      	jnc	0xa3ec <_ml_DiagReceived+0x3e0>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    a3cc:	712c      	lod	A, dp:0x2c <_ml_driver_mode+0x8>
    a3ce:	a20d      	add	A, [S-14]
    a3d0:	7a0d      	lod	Y, [S-14]
    a3d2:	e2da 001c 	add	Y, #28
    a3d6:	66f0      	lod	YL, [Y]
    a3d8:	5cf6      	usex	Y
    a3da:	5adf      	push	Y
    a3dc:	82db 9932 	callf	0x9932 <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    a3e0:	5c01      	dec	S, #2
    a3e2:	720d      	lod	A, [S-14]
    a3e4:	a001      	add	A, #1
    a3e6:	520d      	mov	[S-14], A
    a3e8:	ae01      	cmp	A, [S-2]
    a3ea:	1870      	jc	0xa3cc <_ml_DiagReceived+0x3c0>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    a3ec:	82db 995c 	callf	0x995c <_NVRAM_SaveAll>
    a3f0:	0002      	jmp	0xa3f6 <_ml_DiagReceived+0x3ea>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    a3f2:	7020      	lod	A, #32
    a3f4:	1485      	call	0x9d00 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    a3f6:	7800      	lod	Y, #0
    a3f8:	5932      	mov	dp:0x32 <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    a3fa:	5930      	mov	dp:0x30 <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    a3fc:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    a3fe:	60d6      	lod	AL, #-42
    a400:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    a402:	611c      	lod	AL, dp:0x1c <_LinFrameDataBuffer+0x4>
    a404:	4127      	mov	dp:0x27 <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    a406:	1d0c      	jne	0xa420 <_ml_DiagReceived+0x414>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    a408:	611d      	lod	AL, dp:0x1d <_LinFrameDataBuffer+0x5>
    a40a:	4128      	mov	dp:0x28 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    a40c:	5cf2      	usex	A
    a40e:	1903      	je	0xa416 <_ml_DiagReceived+0x40a>
    a410:	ac01      	cmp	A, #1
    a412:	1903      	je	0xa41a <_ml_DiagReceived+0x40e>
    a414:	0017      	jmp	0xa444 <_ml_DiagReceived+0x438>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    a416:	6000      	lod	AL, #0
    a418:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    a41a:	72da 00f0 	lod	A, #240
    a41e:	06b1      	jmp	0xa182 <_ml_DiagReceived+0x176>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    a420:	8c01      	cmp	AL, #1
    a422:	1d10      	jne	0xa444 <_ml_DiagReceived+0x438>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    a424:	611d      	lod	AL, dp:0x1d <_LinFrameDataBuffer+0x5>
    a426:	4128      	mov	dp:0x28 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    a428:	1d0a      	jne	0xa43e <_ml_DiagReceived+0x432>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    a42a:	611e      	lod	AL, dp:0x1e <__ramfunc_size>
    a42c:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    a42e:	1101      	call	0xa632 <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    a430:	7ada 4000 	lod	Y, #16384
    a434:	592c      	mov	dp:0x2c <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    a436:	7800      	lod	Y, #0
    a438:	5930      	mov	dp:0x30 <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    a43a:	1506      	call	0x9e48 <_ml_ldr_ErrorDetected+0x8>
                                    break;
    a43c:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    a43e:	6000      	lod	AL, #0
    a440:	4126      	mov	dp:0x26 <_ml_driver_mode+0x2>, AL
    a442:	0002      	jmp	0xa448 <_ml_DiagReceived+0x43c>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    a444:	6400      	lod	YL, #0
    a446:	4526      	mov	dp:0x26 <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    a448:	72da 00d0 	lod	A, #208
    a44c:	069a      	jmp	0xa182 <_ml_DiagReceived+0x176>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    a44e:	72da 00b0 	lod	A, #176
    a452:	1456      	call	0x9d00 <_ldr_isReadByIdMessage+0x78>
    a454:	540f      	ret	#16

0000a456 <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    a456:	7ada be80 	lod	Y, #48768
    a45a:	62f0      	lod	AL, [Y]
    a45c:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    a460:	66e0      	lod	YL, AL
    a462:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    a466:	a2e6      	add	A, Y
    a468:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    a46a:	5401      	ret

0000a46c <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    a46c:	17f4      	call	0xa456 <_LDR_GetState>
    a46e:	8c03      	cmp	AL, #3
    a470:	1d03      	jne	0xa478 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    a472:	72da 8000 	lod	A, #32768
    a476:	0001      	jmp	0xa47a <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    a478:	7000      	lod	A, #0
    a47a:	52d8 0040 	mov	0x40 <_page_buffer+0x2>, A
    a47e:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    a480:	a2da c000 	add	A, #49152
    a484:	72e4      	swap	A
    a486:	b6da 00ff 	and	A, #255
    a48a:	44b2      	lsr	A, #2
    a48c:	4432      	lsr	A
}
    a48e:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    a490:	44e2      	sfb	A
    a492:	b6d8 0040 	and	A, 0x40 <_page_buffer+0x2>
    a496:	1901      	je	0xa49a <_Flash_InitDriver+0x2e>
    a498:	7001      	lod	A, #1
}
    a49a:	5401      	ret

0000a49c <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    a49c:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    a49e:	17f0      	call	0xa480 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    a4a0:	17f7      	call	0xa490 <_Flash_InitDriver+0x24>
    a4a2:	8c00      	cmp	AL, #0
    a4a4:	1d09      	jne	0xa4b8 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    a4a6:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    a4aa:	8c01      	cmp	AL, #1
    a4ac:	1a02      	jule	0xa4b2 <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    a4ae:	7030      	lod	A, #48
    a4b0:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    a4b2:	72da 02a6 	lod	A, #678
    a4b6:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    a4b8:	7006      	lod	A, #6
    }

    return wr_time;
}
    a4ba:	5401      	ret

0000a4bc <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    a4bc:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    a4be:	b480      	and	A, #-128
    a4c0:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    a4c2:	7ed8 003e 	lod	X, 0x3e <_page_buffer>
    a4c6:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    a4c8:	7a03      	lod	Y, [S-4]
    a4ca:	54c6      	movsw	[X++], [Y++]
    a4cc:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    a4ce:	7201      	lod	A, [S-2]
    a4d0:	a2da 0080 	add	A, #128
    a4d4:	2ee2      	cmp	X, A
    a4d6:	1878      	jc	0xa4c8 <_Flash_PageRead+0xc>
    a4d8:	5405      	ret	#6

0000a4da <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    a4da:	b47f      	and	A, #127
    a4dc:	7ae2      	lod	Y, A
    a4de:	e2d8 003e 	add	Y, 0x3e <_page_buffer>
    a4e2:	6203      	lod	AL, [S-4]
    a4e4:	42f0      	mov	[Y], AL
    a4e6:	5401      	ret

0000a4e8 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    a4e8:	b480      	and	A, #-128
    a4ea:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    a4ec:	7ad8 003e 	lod	Y, 0x3e <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    a4f0:	72d6      	lod	A, [Y++]
    a4f2:	aede      	cmp	A, [X++]
    a4f4:	1902      	je	0xa4fa <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    a4f6:	7001      	lod	A, #1
    a4f8:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    a4fa:	72d8 003e 	lod	A, 0x3e <_page_buffer>
    a4fe:	a2da 0080 	add	A, #128
    a502:	eee2      	cmp	Y, A
    a504:	1875      	jc	0xa4f0 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    a506:	7000      	lod	A, #0
}
    a508:	5401      	ret

0000a50a <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    a50a:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    a50c:	b480      	and	A, #-128
    a50e:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    a510:	17a2      	call	0xa456 <_LDR_GetState>
    a512:	8c01      	cmp	AL, #1
    a514:	1d0b      	jne	0xa52c <_Flash_PageWrite+0x22>
    a516:	72da bf66 	lod	A, #48998
    a51a:	b480      	and	A, #-128
    a51c:	7a09      	lod	Y, [S-10]
    a51e:	eee2      	cmp	Y, A
    a520:	1d05      	jne	0xa52c <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    a522:	7ad8 003e 	lod	Y, 0x3e <_page_buffer>
    a526:	e076      	add	Y, #118
    a528:	6120      	lod	AL, dp:0x20 <__bss_dp_size>
    a52a:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a52c:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a52e:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a530:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a532:	b430      	and	A, #48
    a534:	1902      	je	0xa53a <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a536:	6000      	lod	AL, #0
    a538:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    a53a:	123a      	call	0xa9b0 <_mlx_isPowerOk>
    a53c:	8c00      	cmp	AL, #0
    a53e:	1d02      	jne	0xa544 <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    a540:	7001      	lod	A, #1
    a542:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    a544:	7a09      	lod	Y, [S-10]
    a546:	eeda be80 	cmp	Y, #48768
    a54a:	1d01      	jne	0xa54e <_Flash_PageWrite+0x44>
    a54c:	0045      	jmp	0xa5d8 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    a54e:	72e6      	lod	A, Y
    a550:	1797      	call	0xa480 <_Flash_InitDriver+0x14>
    a552:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    a554:	179d      	call	0xa490 <_Flash_InitDriver+0x24>
    a556:	8c00      	cmp	AL, #0
    a558:	1901      	je	0xa55c <_Flash_PageWrite+0x52>
    a55a:	003e      	jmp	0xa5d8 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a55c:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a55e:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a560:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a562:	b430      	and	A, #48
    a564:	1902      	je	0xa56a <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a566:	6000      	lod	AL, #0
    a568:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    a56a:	7207      	lod	A, [S-8]
    a56c:	487a 0800 	muls	Y, A, #2048
    a570:	e2da 4000 	add	Y, #16384
    a574:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    a576:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    a57a:	8c01      	cmp	AL, #1
    a57c:	1a03      	jule	0xa584 <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    a57e:	7801      	lod	Y, #1
    a580:	5a03      	mov	[S-4], Y
    a582:	0002      	jmp	0xa588 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    a584:	7010      	lod	A, #16
    a586:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    a588:	7800      	lod	Y, #0
    a58a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    a58e:	7a05      	lod	Y, [S-6]
    a590:	7000      	lod	A, #0
    a592:	52d6      	mov	[Y++], A
        *dst++ = 0;
    a594:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    a596:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    a598:	72da 00c8 	lod	A, #200
    a59c:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    a5a0:	62d8 0024 	lod	AL, 0x24 <_ml_driver_mode>
    a5a4:	8c55      	cmp	AL, #85
    a5a6:	1903      	je	0xa5ae <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    a5a8:	7000      	lod	A, #0
    a5aa:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    a5ae:	7000      	lod	A, #0
    a5b0:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    a5b2:	72ee      	lod	A, X
    a5b4:	80ff      	add	AL, #-1
    a5b6:	5cf2      	usex	A
    a5b8:	7ee2      	lod	X, A
    a5ba:	1d6e      	jne	0xa598 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    a5bc:	7a05      	lod	Y, [S-6]
    a5be:	e2da 0080 	add	Y, #128
    a5c2:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    a5c4:	7203      	lod	A, [S-4]
    a5c6:	a0ff      	add	A, #-1
    a5c8:	5203      	mov	[S-4], A
    a5ca:	1d5e      	jne	0xa588 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    a5cc:	7207      	lod	A, [S-8]
    a5ce:	44e2      	sfb	A
    a5d0:	a6d8 0040 	or	A, 0x40 <_page_buffer+0x2>
    a5d4:	52d8 0040 	mov	0x40 <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a5d8:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a5da:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a5dc:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a5de:	b430      	and	A, #48
    a5e0:	1902      	je	0xa5e6 <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a5e2:	6400      	lod	YL, #0
    a5e4:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    a5e6:	7000      	lod	A, #0
    a5e8:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    a5ec:	7ad8 003e 	lod	Y, 0x3e <_page_buffer>
    dst = (uint16_t *)addr;
    a5f0:	7e09      	lod	X, [S-10]
    a5f2:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    a5f4:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    a5f6:	7201      	lod	A, [S-2]
    a5f8:	a2da 0080 	add	A, #128
    a5fc:	eee2      	cmp	Y, A
    a5fe:	187a      	jc	0xa5f4 <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    a600:	7818      	lod	Y, #24
    a602:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    a606:	62d8 0024 	lod	AL, 0x24 <_ml_driver_mode>
    a60a:	8c55      	cmp	AL, #85
    a60c:	1903      	je	0xa614 <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    a60e:	7000      	lod	A, #0
    a610:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    a614:	7a09      	lod	Y, [S-10]
    a616:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    a618:	7000      	lod	A, #0
    a61a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a61e:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a620:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a622:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a624:	b430      	and	A, #48
    a626:	1902      	je	0xa62c <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a628:	6400      	lod	YL, #0
    a62a:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    a62c:	7209      	lod	A, [S-10]
    a62e:	175c      	call	0xa4e8 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    a630:	540b      	ret	#12

0000a632 <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    a632:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    a634:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    a638:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    a63a:	7ae8      	swap	Y
    a63c:	f6da 00ff 	and	Y, #255
    a640:	4436      	lsr	Y
    a642:	7ee6      	lod	X, Y
    a644:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    a646:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    a648:	ac3f      	cmp	A, #63
    a64a:	1b02      	jsle	0xa650 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    a64c:	703f      	lod	A, #63
    a64e:	0003      	jmp	0xa656 <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    a650:	ac00      	cmp	A, #0
    a652:	1e81      	jsge	0xa656 <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    a654:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    a656:	7ae2      	lod	Y, A
    a658:	f43f      	and	Y, #63
    a65a:	f6da 00ff 	and	Y, #255
    a65e:	7ae8      	swap	Y
    a660:	4426      	asl	Y
    a662:	7201      	lod	A, [S-2]
    a664:	b6da 81ff 	and	A, #33279
    a668:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    a66a:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    a66e:	4432      	lsr	A
    a670:	b6da 3f00 	and	A, #16128
    a674:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    a676:	72ee      	lod	A, X
    a678:	5403      	ret	#4

0000a67a <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    a67a:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    a67c:	b480      	and	A, #-128
    a67e:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    a680:	aeda be80 	cmp	A, #48768
    a684:	1907      	je	0xa694 <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    a686:	7201      	lod	A, [S-2]
    a688:	aeda bf00 	cmp	A, #48896
    a68c:	1d05      	jne	0xa698 <_Flash_PageWriteFiltered+0x1e>
    a68e:	16e3      	call	0xa456 <_LDR_GetState>
    a690:	8c03      	cmp	AL, #3
    a692:	1d02      	jne	0xa698 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    a694:	7000      	lod	A, #0
    a696:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    a698:	7201      	lod	A, [S-2]
    a69a:	1737      	call	0xa50a <_Flash_PageWrite>
}
    a69c:	5403      	ret	#4

0000a69e <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    a69e:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    a6a0:	4cc2 45c0 	mov	D, #280000
    a6a4:	0004 
    a6a6:	4872 0006 	muls	A, A, #6
    a6aa:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a6ac:	4c80      	mov	YA, D
    a6ae:	7e03      	lod	X, [S-4]
    a6b0:	4c63      	divu	YA, X
    a6b2:	4c63      	divu	YA, X
    a6b4:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    a6b6:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    a6b8:	7000      	lod	A, #0
    a6ba:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    a6bc:	eeda 027a 	cmp	Y, #634
    a6c0:	1e04      	jug	0xa6ca <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    a6c2:	80ff      	add	AL, #-1
    a6c4:	b40f      	and	A, #15
    a6c6:	5205      	mov	[S-6], A
            break;
    a6c8:	0005      	jmp	0xa6d4 <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    a6ca:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    a6cc:	8001      	add	AL, #1
    a6ce:	5cf2      	usex	A
    a6d0:	8c02      	cmp	AL, #2
    a6d2:	1a74      	jule	0xa6bc <_ml_SetFastBaudRate+0x1e>
    a6d4:	72e6      	lod	A, Y
    a6d6:	a005      	add	A, #5
    a6d8:	4cf2      	usex	YA
    a6da:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a6dc:	4c63      	divu	YA, X
    a6de:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    a6e0:	8080      	add	AL, #-128
    a6e2:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    a6e4:	52df      	push	A
    a6e6:	7207      	lod	A, [S-8]
    a6e8:	82db 9a62 	callf	0x9a62 <_ml_SetBaudRate>
    a6ec:	5c01      	dec	S, #2
    a6ee:	5407      	ret	#8
    a6f0:	b66d      	and	A, [S-110]
    a6f2:	6ddb      	lod	YH, dp:0xdb <__bist_stat_end+0x91>
    a6f4:	dbb6      	subc	AH, ep:0xb6 <__bist_stat_end+0x6c>
    a6f6:	b66d      	and	A, [S-110]
    a6f8:	6ddb      	lod	YH, dp:0xdb <__bist_stat_end+0x91>

0000a6fa <_RAM_Test>:
    a6fa:	7ada a6f0 	lod	Y, #42736
    a6fe:	4cc0      	mov	D, YA
    a700:	7c00      	lod	X, #0
    a702:	54c6      	movsw	[X++], [Y++]
    a704:	54c6      	movsw	[X++], [Y++]
    a706:	54c6      	movsw	[X++], [Y++]
    a708:	7800      	lod	Y, #0
    a70a:	54c6      	movsw	[X++], [Y++]
    a70c:	2eda 07fe 	cmp	X, #2046
    a710:	1a7c      	jule	0xa70a <_RAM_Test+0x10>
    a712:	4c80      	mov	YA, D
    a714:	7c00      	lod	X, #0
    a716:	72de      	lod	A, [X++]
    a718:	aed6      	cmp	A, [Y++]
    a71a:	1d0a      	jne	0xa730 <_RAM_Test+0x36>
    a71c:	72de      	lod	A, [X++]
    a71e:	aed6      	cmp	A, [Y++]
    a720:	1d07      	jne	0xa730 <_RAM_Test+0x36>
    a722:	72de      	lod	A, [X++]
    a724:	aed6      	cmp	A, [Y++]
    a726:	1d04      	jne	0xa730 <_RAM_Test+0x36>
    a728:	7800      	lod	Y, #0
    a72a:	72de      	lod	A, [X++]
    a72c:	aed6      	cmp	A, [Y++]
    a72e:	1902      	je	0xa734 <_RAM_Test+0x3a>
    a730:	64f3      	lod	YL, #-13
    a732:	000a      	jmp	0xa748 <__fatal>
    a734:	2eda 07fe 	cmp	X, #2046
    a738:	1a78      	jule	0xa72a <_RAM_Test+0x30>
    a73a:	4c80      	mov	YA, D
    a73c:	e002      	add	Y, #2
    a73e:	eeda a6f6 	cmp	Y, #42742
    a742:	1d5d      	jne	0xa6fe <_RAM_Test+0x4>
    a744:	76da 960e 	jmpf	0x960e <_start>

0000a748 <__fatal>:
 *     (no need to save registers)
 *  2. Program counter was saved to Y register by JMPUSERVECTOR before jump to Fatal Handler
 */
__MLX_TEXT__ void _fatal (void)
{
    __asm__ __volatile__ ( "mov %0,Y \n\t" : "=m" (bistError) );
    a748:	5ad8 0046 	mov	0x46 <_bistError>, Y
    bistErrorInfo = (uint16)__builtin_return_address(0);
    a74c:	7201      	lod	A, [S-2]
    a74e:	52d8 0048 	mov	0x48 <_bistErrorInfo>, A

    for (;;) {
    a752:	07ff      	jmp	0xa752 <__fatal+0xa>

0000a754 <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    a754:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    a756:	72d8 0042 	lod	A, 0x42 <__bss_end>
    a75a:	aeda b598 	cmp	A, #46488
    a75e:	1907      	je	0xa76e <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    a760:	72da b598 	lod	A, #46488
    a764:	52d8 0042 	mov	0x42 <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    a768:	7800      	lod	Y, #0
    a76a:	5ad8 0044 	mov	0x44 <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    a76e:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    a772:	aeda 3072 	cmp	A, #12402
    a776:	1d01      	jne	0xa77a <__low_level_init+0x26>
    a778:	006d      	jmp	0xa854 <__low_level_init+0x100>
    a77a:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    a77e:	aeda 3212 	cmp	A, #12818
    a782:	1d01      	jne	0xa786 <__low_level_init+0x32>
    a784:	0067      	jmp	0xa854 <__low_level_init+0x100>
    a786:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    a78a:	aeda 5c92 	cmp	A, #23698
    a78e:	1d01      	jne	0xa792 <__low_level_init+0x3e>
    a790:	0061      	jmp	0xa854 <__low_level_init+0x100>
    a792:	7c0f      	lod	X, #15
    a794:	7ada 11c0 	lod	Y, #4544
    a798:	7000      	lod	A, #0
    a79a:	08a7      	clrb	ML.7
    a79c:	b2d6      	adc	A, [Y++]
    a79e:	1bfe      	djnz	X, 0xa79c <__low_level_init+0x48>
    a7a0:	92e4      	adc	AL, AH
    a7a2:	9000      	adc	AL, #0
    a7a4:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    a7a6:	aeda 00ff 	cmp	A, #255
    a7aa:	1902      	je	0xa7b0 <__low_level_init+0x5c>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    a7ac:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    a7ae:	07cc      	jmp	0xa748 <__fatal>
    a7b0:	7c0c      	lod	X, #12
    a7b2:	7ada 11de 	lod	Y, #4574
    a7b6:	7000      	lod	A, #0
    a7b8:	08a7      	clrb	ML.7
    a7ba:	b2d6      	adc	A, [Y++]
    a7bc:	1bfe      	djnz	X, 0xa7ba <__low_level_init+0x66>
    a7be:	92e4      	adc	AL, AH
    a7c0:	9000      	adc	AL, #0
    a7c2:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    a7c4:	aeda 00ff 	cmp	A, #255
    a7c8:	1902      	je	0xa7ce <__low_level_init+0x7a>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    a7ca:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    a7cc:	07bd      	jmp	0xa748 <__fatal>
    a7ce:	7c05      	lod	X, #5
    a7d0:	7ada 11f6 	lod	Y, #4598
    a7d4:	7000      	lod	A, #0
    a7d6:	08a7      	clrb	ML.7
    a7d8:	b2d6      	adc	A, [Y++]
    a7da:	1bfe      	djnz	X, 0xa7d8 <__low_level_init+0x84>
    a7dc:	92e4      	adc	AL, AH
    a7de:	9000      	adc	AL, #0
    a7e0:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    a7e2:	aeda 00ff 	cmp	A, #255
    a7e6:	1902      	je	0xa7ec <__low_level_init+0x98>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    a7e8:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    a7ea:	07ae      	jmp	0xa748 <__fatal>
    a7ec:	7ada 10fc 	lod	Y, #4348
    a7f0:	7c02      	lod	X, #2
    a7f2:	7000      	lod	A, #0
    a7f4:	08a7      	clrb	ML.7
    a7f6:	b2d6      	adc	A, [Y++]
    a7f8:	1bfe      	djnz	X, 0xa7f6 <__low_level_init+0xa2>
    a7fa:	92e4      	adc	AL, AH
    a7fc:	9000      	adc	AL, #0
    a7fe:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    a800:	aeda 00ff 	cmp	A, #255
    a804:	1d07      	jne	0xa814 <__low_level_init+0xc0>
    a806:	7eda 11f8 	lod	X, #4600
    a80a:	7ada 10fe 	lod	Y, #4350
    a80e:	72f0      	lod	A, [Y]
    a810:	aef8      	cmp	A, [X]
    a812:	1920      	je	0xa854 <__low_level_init+0x100>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    a814:	7000      	lod	A, #0
    a816:	7eda 10fc 	lod	X, #4348
    a81a:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    a81c:	7eda 10fe 	lod	X, #4350
    a820:	7ada 11f8 	lod	Y, #4600
    a824:	7af0      	lod	Y, [Y]
    a826:	5af8      	mov	[X], Y
    a828:	7ada 10fc 	lod	Y, #4348
    a82c:	7c02      	lod	X, #2
    a82e:	7000      	lod	A, #0
    a830:	08a7      	clrb	ML.7
    a832:	b2d6      	adc	A, [Y++]
    a834:	1bfe      	djnz	X, 0xa832 <__low_level_init+0xde>
    a836:	92e4      	adc	AL, AH
    a838:	9000      	adc	AL, #0
    a83a:	5cf2      	usex	A
    a83c:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    a83e:	72da 00ff 	lod	A, #255
    a842:	aa05      	sub	A, [S-6]
    a844:	7ada 10fc 	lod	Y, #4348
    a848:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    a84a:	7001      	lod	A, #1
    a84c:	82db 98d4 	callf	0x98d4 <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    a850:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    a852:	077a      	jmp	0xa748 <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    a854:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    a858:	8408      	or	AL, #8
    a85a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    a85e:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    a862:	b6da ff7f 	and	A, #65407
    a866:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    a86a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    a86e:	94f7      	and	AL, #-9
    a870:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    a874:	7c04      	lod	X, #4
    a876:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    a87a:	72da 7c50 	lod	A, #31824
    a87e:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    a882:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    a886:	94fe      	and	AL, #-2
    a888:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    a88c:	0000      	nop
    NOP();
    a88e:	0000      	nop
    NOP();
    a890:	0000      	nop
    MLX4_START();
    a892:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    a896:	8401      	or	AL, #1
    a898:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    a89c:	540f      	ret	#16

0000a89e <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    a89e:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    a8a0:	72ef      	lod	A, S
    a8a2:	a080      	add	A, #-128
    a8a4:	52d8 003e 	mov	0x3e <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    a8a8:	15d6      	call	0xa456 <_LDR_GetState>
    a8aa:	8c00      	cmp	AL, #0
    a8ac:	1d06      	jne	0xa8ba <__premain+0x1c>
    a8ae:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    a8b2:	aeda 3212 	cmp	A, #12818
    a8b6:	1901      	je	0xa8ba <__premain+0x1c>
    a8b8:	003b      	jmp	0xa930 <__premain+0x92>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
	    if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    a8ba:	72d8 0010 	lod	A, 0x10 <_stFixedRamNAD>
    a8be:	7ad8 0012 	lod	Y, 0x12 <_stFixedRamNAD+0x2>
    a8c2:	4cb2 72ef 	cmp	YA, #-396266769
    a8c6:	e861 
    a8c8:	1913      	je	0xa8f0 <__premain+0x52>
		{
			uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76);					/* Get NAD from Flash at STACK_IT Segment */
    a8ca:	7ada bf76 	lod	Y, #49014
    a8ce:	72f0      	lod	A, [Y]
    a8d0:	5cf2      	usex	A
			if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    a8d2:	8c00      	cmp	AL, #0
    a8d4:	1a82      	jsl	0xa8da <__premain+0x3c>
    a8d6:	ac00      	cmp	A, #0
    a8d8:	1d01      	jne	0xa8dc <__premain+0x3e>
			{
				u8NAD = 0x7F;													/* Invalid NAD; Use default NAD */
    a8da:	707f      	lod	A, #127
			}
			stFixedRamNAD.nad = u8NAD;
    a8dc:	42d8 0014 	mov	0x14 <_stFixedRamNAD+0x4>, AL
			stFixedRamNAD.key = _mlx_NAD_Security_Key;
    a8e0:	72da 72ef 	lod	A, #29423
    a8e4:	52d8 0010 	mov	0x10 <_stFixedRamNAD>, A
    a8e8:	72da e861 	lod	A, #59489
    a8ec:	52d8 0012 	mov	0x12 <_stFixedRamNAD+0x2>, A
		}
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    a8f0:	54f7      	mov	UPr, #7

        ml_LinInit();
    a8f2:	10ab      	call	0xaa4a <_ml_LinInit>
        (void)ml_Connect();
    a8f4:	82db 9a76 	callf	0x9a76 <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    a8f8:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    a8fc:	aeda 3212 	cmp	A, #12818
    a900:	1d07      	jne	0xa910 <__premain+0x72>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    a902:	7000      	lod	A, #0
    a904:	82db 9ede 	callf	0x9ede <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    a908:	72da 5c92 	lod	A, #23698
    a90c:	52d8 0044 	mov	0x44 <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a910:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a912:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a914:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a916:	b430      	and	A, #48
    a918:	1902      	je	0xa91e <__premain+0x80>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a91a:	6000      	lod	AL, #0
    a91c:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    a91e:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    a922:	b410      	and	A, #16
    a924:	1975      	je	0xa910 <__premain+0x72>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    a926:	82db 9a92 	callf	0x9a92 <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    a92a:	82db 9ac2 	callf	0x9ac2 <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    a92e:	07f0      	jmp	0xa910 <__premain+0x72>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    a930:	54f7      	mov	UPr, #7
    a932:	5c7f      	dec	S, #128
    a934:	5401      	ret

0000a936 <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    a936:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    a938:	4407      	mov	R, #0
    a93a:	500c      	call	fp0:0x60
    a93c:	54f0      	mov	UPr, #0
    a93e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a940:	b430      	and	A, #48
    a942:	ac10      	cmp	A, #16
    a944:	1914      	je	0xa96e <_MLX16_RESET+0x38>
    a946:	1e03      	jug	0xa94e <_MLX16_RESET+0x18>
    a948:	ac00      	cmp	A, #0
    a94a:	190c      	je	0xa964 <_MLX16_RESET+0x2e>
    a94c:	002f      	jmp	0xa9ac <_MLX16_RESET+0x76>
    a94e:	ac20      	cmp	A, #32
    a950:	1903      	je	0xa958 <_MLX16_RESET+0x22>
    a952:	ac30      	cmp	A, #48
    a954:	1904      	je	0xa95e <_MLX16_RESET+0x28>
    a956:	002a      	jmp	0xa9ac <_MLX16_RESET+0x76>
    a958:	6000      	lod	AL, #0
    a95a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    a95c:	07fd      	jmp	0xa958 <_MLX16_RESET+0x22>
    a95e:	6000      	lod	AL, #0
    a960:	4282      	mov	io:0x2 <_LinCmnd>, AL
    a962:	07ff      	jmp	0xa962 <_MLX16_RESET+0x2c>
    a964:	6001      	lod	AL, #1
    a966:	4282      	mov	io:0x2 <_LinCmnd>, AL
    a968:	6010      	lod	AL, #16
    a96a:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    a96c:	07ff      	jmp	0xa96c <_MLX16_RESET+0x36>
    a96e:	6282      	lod	AL, io:0x2 <_LinCmnd>
    a970:	66e0      	lod	YL, AL
    a972:	5cf6      	usex	Y
    a974:	44a6      	asl	Y, #2
    a976:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a978:	b403      	and	A, #3
    a97a:	4422      	asl	A
    a97c:	ac00      	cmp	A, #0
    a97e:	1b03      	jsle	0xa986 <_MLX16_RESET+0x50>
    a980:	42e9      	mov	Cx, AL
    a982:	4426      	asl	Y
    a984:	1ffe      	djnz	Cx, 0xa982 <_MLX16_RESET+0x4c>
    a986:	ec7d      	cmp	Y, #125
    a988:	1c01      	jnc	0xa98c <_MLX16_RESET+0x56>
    a98a:	07ff      	jmp	0xa98a <_MLX16_RESET+0x54>
    a98c:	7eda 06d6 	lod	X, #1750
    a990:	1bff      	djnz	X, 0xa990 <_MLX16_RESET+0x5a>
    a992:	72da 6301 	lod	A, #25345
    a996:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
    a998:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    a99a:	b6da 6000 	and	A, #24576
    a99e:	1d76      	jne	0xa98c <_MLX16_RESET+0x56>
    a9a0:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    a9a4:	b4fe      	and	A, #-2
    a9a6:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    a9aa:	07ff      	jmp	0xa9aa <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    a9ac:	5ae3      	mov	M, Y
    a9ae:	5401      	ret

0000a9b0 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    a9b0:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    a9b2:	7003      	lod	A, #3
    a9b4:	5205      	mov	[S-6], A
    a9b6:	70ff      	lod	A, #-1
    a9b8:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    a9ba:	7000      	lod	A, #0
    a9bc:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    a9be:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    a9c0:	b401      	and	A, #1
    a9c2:	1917      	je	0xa9f2 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    a9c4:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    a9c6:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    a9c8:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    a9ca:	b430      	and	A, #48
    a9cc:	1902      	je	0xa9d2 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    a9ce:	6000      	lod	AL, #0
    a9d0:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    a9d2:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    a9d4:	b4fb      	and	A, #-5
    a9d6:	5290      	mov	io:0x10 <_stFixedRamNAD>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    a9d8:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    a9da:	b401      	and	A, #1
    a9dc:	190a      	je	0xa9f2 <_mlx_isPowerOk+0x42>
    a9de:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    a9e0:	7eda 15e0 	lod	X, #5600
    a9e4:	1bff      	djnz	X, 0xa9e4 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    a9e6:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    a9e8:	b401      	and	A, #1
    a9ea:	1903      	je	0xa9f2 <_mlx_isPowerOk+0x42>
    a9ec:	e0ff      	add	Y, #-1
    a9ee:	ecff      	cmp	Y, #-1
    a9f0:	1d77      	jne	0xa9e0 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    a9f2:	7000      	lod	A, #0
    a9f4:	5290      	mov	io:0x10 <_stFixedRamNAD>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    a9f6:	72ef      	lod	A, S
    a9f8:	a0fe      	add	A, #-2
    a9fa:	5294      	mov	io:0x14 <_stFixedRamNAD+0x4>, A
    a9fc:	72ef      	lod	A, S
    a9fe:	a0fa      	add	A, #-6
    aa00:	5292      	mov	io:0x12 <_stFixedRamNAD+0x2>, A
    aa02:	72da 0080 	lod	A, #128
    aa06:	5290      	mov	io:0x10 <_stFixedRamNAD>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    aa08:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    aa0a:	a401      	or	A, #1
    aa0c:	5290      	mov	io:0x10 <_stFixedRamNAD>, A
    DELAY(500);                     /* some delay for sample and hold */
    aa0e:	7eda 01f4 	lod	X, #500
    aa12:	1bff      	djnz	X, 0xaa12 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    aa14:	7040      	lod	A, #64
    aa16:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    aa1a:	7290      	lod	A, io:0x10 <_stFixedRamNAD>
    aa1c:	a6da 0100 	or	A, #256
    aa20:	5290      	mov	io:0x10 <_stFixedRamNAD>, A
    aa22:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    aa26:	b440      	and	A, #64
    aa28:	1d08      	jne	0xaa3a <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    aa2a:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    aa2c:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    aa2e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    aa30:	b430      	and	A, #48
    aa32:	1977      	je	0xaa22 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    aa34:	6000      	lod	AL, #0
    aa36:	4282      	mov	io:0x2 <_LinCmnd>, AL
    aa38:	07f4      	jmp	0xaa22 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    aa3a:	7201      	lod	A, [S-2]
    aa3c:	aeda 0158 	cmp	A, #344
    aa40:	1e02      	jug	0xaa46 <_mlx_isPowerOk+0x96>
        return false;
    aa42:	7000      	lod	A, #0
    aa44:	5407      	ret	#8
    }
    else {
        return true;
    aa46:	7001      	lod	A, #1
    }
}
    aa48:	5407      	ret	#8

0000aa4a <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    aa4a:	100e      	call	0xaa68 <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    aa4c:	54ca 0000 	pushw	#0
    aa50:	54ca 0001 	pushw	#1
    aa54:	54ca 0000 	pushw	#0
    aa58:	7001      	lod	A, #1
    aa5a:	82db 99b4 	callf	0x99b4 <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    aa5e:	7000      	lod	A, #0
    aa60:	82db 99ac 	callf	0x99ac <_ml_SetSlewRate>
    aa64:	5c05      	dec	S, #6
    aa66:	5401      	ret

0000aa68 <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    aa68:	14f6      	call	0xa456 <_LDR_GetState>
    aa6a:	8c00      	cmp	AL, #0
    aa6c:	1d0a      	jne	0xaa82 <_ml_InitLinModule+0x1a>
    aa6e:	72d8 0044 	lod	A, 0x44 <_bistResetInfo>
    aa72:	aeda 3212 	cmp	A, #12818
    aa76:	1905      	je	0xaa82 <_ml_InitLinModule+0x1a>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    aa78:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    aa7c:	a410      	or	A, #16
    aa7e:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    aa82:	729a      	lod	A, io:0x1a <_LinFrameDataBuffer+0x2>
    AWD_CTRL = temp;
    aa84:	529a      	mov	io:0x1a <_LinFrameDataBuffer+0x2>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    aa86:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    aa88:	b430      	and	A, #48
    aa8a:	1902      	je	0xaa90 <_ml_InitLinModule+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    aa8c:	6000      	lod	AL, #0
    aa8e:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    aa90:	6084      	lod	AL, #-124
    aa92:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    aa96:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    aa9a:	b404      	and	A, #4
    aa9c:	197c      	je	0xaa96 <_ml_InitLinModule+0x2e>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    aa9e:	60ab      	lod	AL, #-85
    aaa0:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    aaa4:	6000      	lod	AL, #0
    aaa6:	42d8 0024 	mov	0x24 <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    aaaa:	72d8 0010 	lod	A, 0x10 <_stFixedRamNAD>
    aaae:	7ad8 0012 	lod	Y, 0x12 <_stFixedRamNAD+0x2>
    aab2:	4cb2 72ef 	cmp	YA, #-396266769
    aab6:	e861 
    aab8:	1d03      	jne	0xaac0 <_ml_InitLinModule+0x58>
    {
        LIN_nad = stFixedRamNAD.nad;
    aaba:	62d8 0014 	lod	AL, 0x14 <_stFixedRamNAD+0x4>
    aabe:	0001      	jmp	0xaac2 <_ml_InitLinModule+0x5a>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    aac0:	6001      	lod	AL, #1
    aac2:	4120      	mov	dp:0x20 <__bss_dp_size>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    aac4:	7000      	lod	A, #0
    aac6:	5401      	ret
    aac8:	9b10      	subc	AL, ep:0x10 <_stFixedRamNAD>
    aaca:	9b2a      	subc	AL, ep:0x2a <_ml_driver_mode+0x6>
    aacc:	9b80      	subc	AL, ep:0x80 <__bist_stat_end+0x36>
    aace:	9bae      	subc	AL, ep:0xae <__bist_stat_end+0x64>
    aad0:	9bc0      	subc	AL, ep:0xc0 <__bist_stat_end+0x76>
    aad2:	0000      	nop
    aad4:	0001      	jmp	0xaad8 <_ml_InitLinModule+0x70>
    aad6:	0600      	jmp	0xa6d8 <_ml_SetFastBaudRate+0x3a>
    aad8:	00b2      	jmp	0xac3e <_etext+0x160>
    aada:	7fff      	lod	X, ep:0xff <__bist_stat_end+0xb5>
    aadc:	ffff      	xor	Y, ep:0xff <__bist_stat_end+0xb5>
