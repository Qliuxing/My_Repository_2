mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


MLX81315A_S03_VALVE.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00004000  00004000  00000274  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00005540  00005540  00001764  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000098  0000bf68  0000bf68  000065d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00006532  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  000065d2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  000065cc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .protection_key 00000008  0000bf46  0000bf46  000065b2  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .flash_crc    00000002  0000bf4e  0000bf4e  000065ba  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .product_no   00000008  0000bf50  0000bf50  000065bc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .app_version  00000004  0000bf58  0000bf58  000065c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .pltf_version 00000004  0000bf5c  0000bf5c  000065c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .ramfunc      0000001e  00000740  000055c8  000017ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         00004cb6  000055e8  000055e8  0000180c  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 13 .shared_ram   00000010  00000000  00000000  0000666c  2**0
                  CONTENTS, READONLY
 14 .ram_lin_fixed 00000006  00000010  00000010  00000274  2**1
                  ALLOC
 15 .dp.data      00000020  00000018  0000a29e  000064c2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 16 .dp           000000b0  00000038  0000a2be  000064e2  2**1
                  ALLOC
 17 .dp.noinit    00000010  000000e8  0000a2be  000064e2  2**1
                  ALLOC
 18 .data         00000050  000000f8  0000a2be  000064e2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 19 .bss          00000162  00000148  0000a30e  00006532  2**1
                  ALLOC
 20 .bist_stat    00000008  000002aa  0000a30e  00006532  2**1
                  ALLOC
 21 .debug_abbrev 0000277e  00000000  00000000  0000667c  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_info   0000d461  00000000  00000000  00008dfa  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   00007c36  00000000  00000000  0001625b  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  0000106c  00000000  00000000  0001de92  2**1
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_pubnames 0000196a  00000000  00000000  0001eefe  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_aranges 00000444  00000000  00000000  00020868  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_str    0000356c  00000000  00000000  00020cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .comment      00000011  00000000  00000000  00024218  2**0
                  CONTENTS, READONLY
 29 .debug_ranges 0000000c  00000000  00000000  00024229  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .mlx4_flash:

00004000 <__mlx4_flash_start>:
    4000:	a55a      	or	A, dp:0x5a <_g_NvramUser+0x4>
    4002:	5aa5      	mov	io:0x25 <_g_u8EmergencyRunOcc>, Y
    4004:	0000      	nop
    4006:	0000      	nop
    4008:	2442      	or	X, #66
    400a:	2442      	or	X, #66
    400c:	243f      	or	X, #63
    400e:	243f      	or	X, #63
    4010:	0000      	nop
    4012:	0000      	nop
    4014:	0000      	nop
    4016:	0000      	nop
    4018:	4100      	mov	dp:0x0 <__dp__>, AL
    401a:	2000      	add	X, #0
    401c:	0000      	nop
    401e:	0000      	nop
    4020:	01e0      	jmp	0x43e2 <__mlx4_flash_start+0x3e2>
    4022:	0003      	jmp	0x402a <__mlx4_flash_start+0x2a>
    4024:	0005      	jmp	0x4030 <__mlx4_flash_start+0x30>
    4026:	0000      	nop
    4028:	4233      	mov	[S-52], AL
    402a:	5f50      	mov	ep:0x50 <__data_size>, X
    402c:	7c6d      	lod	X, #109
    402e:	998a      	subc	AL, dp:0x8a <_g_NvramUser+0x34>
    4030:	140e      	call	0x384e <__io__+0x104e>
    4032:	201a      	add	X, #26
    4034:	2c26      	cmp	X, #38
    4036:	3832      	subc	X, #50
    4038:	0208      	jmp	0x444a <__mlx4_flash_start+0x44a>
    403a:	af52      	cmp	A, ep:0x52 <_g_u16MotorCurrentMovAvgxN>
    403c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    403e:	ff35      	xor	Y, ep:0x35 <_g_u16StartupDelay+0x1>
    4040:	e0e0      	add	Y, #-32
    4042:	dba6      	subc	AH, ep:0xa6 <_g_NvramUser+0x50>
    4044:	0000      	nop
    4046:	0200      	jmp	0x4448 <__mlx4_flash_start+0x448>
    4048:	7da0      	lod	X, dp:0xa0 <_g_NvramUser+0x4a>
    404a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    404c:	39e4      	subc	X, dp:0xe4 <_ml_driver_mode+0x10>
    404e:	934e      	adc	AL, ep:0x4e <_g_u16CommutTimerPeriod>
    4050:	d3e0      	adc	AH, ep:0xe0 <_ml_driver_mode+0xc>
    4052:	a497      	or	A, #-105
    4054:	2c1f      	cmp	X, #31
    4056:	5b68      	mov	ep:0x68 <_g_NvramUser+0x12>, Y
    4058:	a81f      	sub	A, #31
    405a:	b47f      	and	A, #127
    405c:	00b2      	jmp	0x41c2 <__mlx4_flash_start+0x1c2>
    405e:	7c50      	lod	X, #80
    4060:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    4062:	773a      	lod	PC, ep:0x3a <__data_dp_end+0x2>
    4064:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x38>
    4066:	773b      	lod	PC, ep:0x3b <__data_dp_end+0x3>
    4068:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    406a:	34e9      	and	X, #-23
    406c:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    406e:	b76f      	and	A, ep:0x6f <_g_NvramUser+0x19>
    4070:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x7>
    4072:	4c02 b203 	add	D, #-1291603453
    4076:	b303 
    4078:	8684      	or	AL, io:0x4 <_LinMess>
    407a:	7203      	lod	A, [S-4]
    407c:	4c03      	add	D, ??
    407e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    4080:	380e      	subc	X, #14
    4082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    4084:	320a      	adc	X, [S-11]
    4086:	340a      	and	X, #10
    4088:	3eac      	xor	X, io:0x2c <_g_u8BufferOutID>
    408a:	3b16      	subc	X, ep:0x16 <__dp_noinit_size+0x6>
    408c:	3730      	and	X, ep:0x30 <_l_u16VTIdx>
    408e:	6193      	lod	AL, dp:0x93 <_g_NvramUser+0x3d>
    4090:	b680      	and	A, io:0x0 <__dp__>
    4092:	7273      	lod	A, [S-116]
    4094:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4098:	7239      	lod	A, [S-58]
    409a:	726f      	lod	A, [S-112]
    409c:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    409e:	714c      	lod	A, dp:0x4c <_g_u16MicroStepIdx>
    40a0:	b588      	and	A, dp:0x88 <_g_NvramUser+0x32>
    40a2:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    40a4:	0000      	nop
    40a6:	0000      	nop
    40a8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    40aa:	320a      	adc	X, [S-11]
    40ac:	580a      	inc	S, #11
    40ae:	0901      	clrb	io:0x00.1
    40b0:	2080      	add	X, #-128
    40b2:	623a      	lod	AL, [S-59]
    40b4:	7270      	lod	A, [S-113]
    40b6:	b637      	and	A, [S-56]
    40b8:	b373      	adc	A, ep:0x73 <_g_NvramUser+0x1d>
    40ba:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    40bc:	e783      	or	Y, ep:0x83 <_g_NvramUser+0x2d>
    40be:	1101      	call	0x42c2 <__mlx4_flash_start+0x2c2>
    40c0:	20b7      	add	X, #-73
    40c2:	6c03      	lod	YH, #3
    40c4:	206e      	add	X, #110
    40c6:	2066      	add	X, #102
    40c8:	2073      	add	X, #115
    40ca:	2050      	add	X, #80
    40cc:	e680      	or	Y, io:0x0 <__dp__>
    40ce:	1102      	call	0x42d4 <__mlx4_flash_start+0x2d4>
    40d0:	b782      	and	A, ep:0x82 <_g_NvramUser+0x2c>
    40d2:	207a      	add	X, #122
    40d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    40d6:	110b      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40d8:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    40da:	207a      	add	X, #122
    40dc:	b270      	adc	A, [S-113]
    40de:	a688      	or	A, io:0x8 <__bist_stat_size>
    40e0:	1106      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40e2:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    40e4:	207a      	add	X, #122
    40e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    40e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    40ea:	1101      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40ec:	207c      	add	X, #124
    40ee:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    40f0:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x1d>
    40f2:	2050      	add	X, #80
    40f4:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x1d>
    40f6:	2056      	add	X, #86
    40f8:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    40fa:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x1d>
    40fc:	3cc3      	xor	X, #-61
    40fe:	2050      	add	X, #80
    4100:	b384      	adc	A, ep:0x84 <_g_NvramUser+0x2e>
    4102:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    4104:	7380      	lod	A, ep:0x80 <_g_NvramUser+0x2a>
    4106:	7334      	lod	A, ep:0x34 <_g_u16StartupDelay>
    4108:	7235      	lod	A, [S-54]
    410a:	7ca7      	lod	X, #-89
    410c:	7d34      	lod	X, dp:0x34 <_g_u16StartupDelay>
    410e:	6c03      	lod	YH, #3
    4110:	20b1      	add	X, #-79
    4112:	20ad      	add	X, #-83
    4114:	20b3      	add	X, #-77
    4116:	20b3      	add	X, #-77
    4118:	20b3      	add	X, #-77
    411a:	20a1      	add	X, #-95
    411c:	20b3      	add	X, #-77
    411e:	20b3      	add	X, #-77
    4120:	20b3      	add	X, #-77
    4122:	20b3      	add	X, #-77
    4124:	20b3      	add	X, #-77
    4126:	20b3      	add	X, #-77
    4128:	20b3      	add	X, #-77
    412a:	20b3      	add	X, #-77
    412c:	20b3      	add	X, #-77
    412e:	2098      	add	X, #-104
    4130:	a682      	or	A, io:0x2 <_LinCmnd>
    4132:	1106      	call	0x4340 <__mlx4_flash_start+0x340>
    4134:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x9>
    4136:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x38>
    4138:	a681      	or	A, io:0x1 <__dp__+0x1>
    413a:	0101      	jmp	0x433e <__mlx4_flash_start+0x33e>
    413c:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x2b>
    413e:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    4140:	20b1      	add	X, #-79
    4142:	e682      	or	Y, io:0x2 <_LinCmnd>
    4144:	110d      	call	0x4360 <__mlx4_flash_start+0x360>
    4146:	b286      	adc	A, io:0x6 <_LinMess2>
    4148:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x9>
    414a:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x2c>
    414c:	e681      	or	Y, io:0x1 <__dp__+0x1>
    414e:	0103      	jmp	0x4356 <__mlx4_flash_start+0x356>
    4150:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x37>
    4152:	b680      	and	A, io:0x0 <__dp__>
    4154:	7273      	lod	A, [S-116]
    4156:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    4158:	20b1      	add	X, #-79
    415a:	e681      	or	Y, io:0x1 <__dp__+0x1>
    415c:	1101      	call	0x4360 <__mlx4_flash_start+0x360>
    415e:	245d      	or	X, #93
    4160:	20b3      	add	X, #-77
    4162:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4164:	20b4      	add	X, #-76
    4166:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4168:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x2b>
    416a:	5404      	ret	#5
    416c:	2056      	add	X, #86
    416e:	a681      	or	A, io:0x1 <__dp__+0x1>
    4170:	1104      	call	0x437a <__mlx4_flash_start+0x37a>
    4172:	b270      	adc	A, [S-113]
    4174:	a688      	or	A, io:0x8 <__bist_stat_size>
    4176:	1105      	call	0x4382 <__mlx4_flash_start+0x382>
    4178:	2048      	add	X, #72
    417a:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    417c:	622e      	lod	AL, [S-47]
    417e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4180:	0101      	jmp	0x4384 <__mlx4_flash_start+0x384>
    4182:	2056      	add	X, #86
    4184:	b139      	adc	A, dp:0x39 <__data_dp_end+0x1>
    4186:	e14c      	add	Y, dp:0x4c <_g_u16MicroStepIdx>
    4188:	1101      	call	0x438c <__mlx4_flash_start+0x38c>
    418a:	20e4      	add	X, #-28
    418c:	4592      	mov	dp:0x92 <_g_NvramUser+0x3c>, YL
    418e:	76e5      	jmp	MH
    4190:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4192:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0x11>
    4194:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4196:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4198:	7139      	lod	A, dp:0x39 <__data_dp_end+0x1>
    419a:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x42>
    419c:	e581      	or	Y, dp:0x81 <_g_NvramUser+0x2b>
    419e:	110b      	call	0x43b6 <__mlx4_flash_start+0x3b6>
    41a0:	7cd5      	lod	X, #-43
    41a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    41a4:	b208      	adc	A, [S-9]
    41a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    41a8:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    41aa:	a783      	or	A, ep:0x83 <_g_NvramUser+0x2d>
    41ac:	1105      	call	0x43b8 <__mlx4_flash_start+0x3b8>
    41ae:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x36>
    41b0:	f373      	adc	Y, ep:0x73 <_g_NvramUser+0x1d>
    41b2:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x1d>
    41b4:	724c      	lod	A, [S-77]
    41b6:	2050      	add	X, #80
    41b8:	7271      	lod	A, [S-114]
    41ba:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    41bc:	e781      	or	Y, ep:0x81 <_g_NvramUser+0x2b>
    41be:	0102      	jmp	0x43c4 <__mlx4_flash_start+0x3c4>
    41c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    41c2:	20da      	add	X, #-38
    41c4:	b686      	and	A, io:0x6 <_LinMess2>
    41c6:	20da      	add	X, #-38
    41c8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    41ca:	300a      	adc	X, #10
    41cc:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x42>
    41ce:	ef80      	cmp	Y, ep:0x80 <_g_NvramUser+0x2a>
    41d0:	0103      	jmp	0x43d8 <__mlx4_flash_start+0x3d8>
    41d2:	b684      	and	A, io:0x4 <_LinMess>
    41d4:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    41d6:	2030      	add	X, #48
    41d8:	b24e      	adc	A, [S-79]
    41da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    41dc:	724e      	lod	A, [S-79]
    41de:	6c02      	lod	YH, #2
    41e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    41e2:	20f4      	add	X, #-12
    41e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    41e6:	2100      	add	X, dp:0x0 <__dp__>
    41e8:	b78b      	and	A, ep:0x8b <_g_NvramUser+0x35>
    41ea:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    41ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    41ee:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x58>
    41f0:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    41f2:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    41f4:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    41f6:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    41f8:	b681      	and	A, io:0x1 <__dp__+0x1>
    41fa:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x58>
    41fc:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    41fe:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4200:	b682      	and	A, io:0x2 <_LinCmnd>
    4202:	724e      	lod	A, [S-79]
    4204:	b78d      	and	A, ep:0x8d <_g_NvramUser+0x37>
    4206:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4208:	b681      	and	A, io:0x1 <__dp__+0x1>
    420a:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x58>
    420c:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    420e:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4210:	b24c      	adc	A, [S-77]
    4212:	7271      	lod	A, [S-114]
    4214:	b78b      	and	A, ep:0x8b <_g_NvramUser+0x35>
    4216:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    4218:	b681      	and	A, io:0x1 <__dp__+0x1>
    421a:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x58>
    421c:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2f>
    421e:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    4220:	b24e      	adc	A, [S-79]
    4222:	b171      	adc	A, dp:0x71 <_g_NvramUser+0x1b>
    4224:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4226:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    4228:	b56d      	and	A, dp:0x6d <_g_NvramUser+0x17>
    422a:	b685      	and	A, io:0x5 <_LinMess+0x1>
    422c:	b66e      	and	A, [S-111]
    422e:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4230:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4232:	b680      	and	A, io:0x0 <__dp__>
    4234:	738b      	lod	A, ep:0x8b <_g_NvramUser+0x35>
    4236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    4238:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    423a:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x32>
    423c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    423e:	5408      	ret	#9
    4240:	b273      	adc	A, [S-116]
    4242:	a688      	or	A, io:0x8 <__bist_stat_size>
    4244:	1109      	call	0x4458 <__mlx4_flash_start+0x458>
    4246:	b24e      	adc	A, [S-79]
    4248:	e681      	or	Y, io:0x1 <__dp__+0x1>
    424a:	0103      	jmp	0x4452 <__mlx4_flash_start+0x452>
    424c:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x9>
    424e:	a582      	or	A, dp:0x82 <_g_NvramUser+0x2c>
    4250:	0102      	jmp	0x4456 <__mlx4_flash_start+0x456>
    4252:	b680      	and	A, io:0x0 <__dp__>
    4254:	204a      	add	X, #74
    4256:	2048      	add	X, #72
    4258:	3806      	subc	X, #6
    425a:	380e      	subc	X, #14
    425c:	580c      	inc	S, #13
    425e:	0807      	clrb	dp:0x00.7
    4260:	62e6      	lod	AL, Y
    4262:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4264:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4266:	1108      	call	0x4478 <__mlx4_flash_start+0x478>
    4268:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    426a:	1105      	call	0x4476 <__mlx4_flash_start+0x476>
    426c:	212e      	add	X, dp:0x2e <_g_u8SAE_SendErrorState>
    426e:	623a      	lod	AL, [S-59]
    4270:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    4272:	1101      	call	0x4476 <__mlx4_flash_start+0x476>
    4274:	212e      	add	X, dp:0x2e <_g_u8SAE_SendErrorState>
    4276:	2030      	add	X, #48
    4278:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    427a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    427c:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    427e:	6223      	lod	AL, [S-36]
    4280:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x42>
    4282:	b208      	adc	A, [S-9]
    4284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    4286:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    4288:	6c03      	lod	YH, #3
    428a:	2155      	add	X, dp:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    428c:	214a      	add	X, dp:0x4a <_g_u16CorrectionRatio>
    428e:	b688      	and	A, io:0x8 <__bist_stat_size>
    4290:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4292:	215a      	add	X, dp:0x5a <_g_NvramUser+0x4>
    4294:	b586      	and	A, dp:0x86 <_g_NvramUser+0x30>
    4296:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x52>
    4298:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    429a:	b6e5      	and	A, MH
    429c:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    429e:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0x11>
    42a0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    42a2:	76e5      	jmp	MH
    42a4:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    42a6:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0x11>
    42a8:	b686      	and	A, io:0x6 <_LinMess2>
    42aa:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    42ac:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x52>
    42ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    42b0:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    42b2:	3e10      	xor	X, [S-17]
    42b4:	724c      	lod	A, [S-77]
    42b6:	7139      	lod	A, dp:0x39 <__data_dp_end+0x1>
    42b8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    42ba:	34c0      	and	X, #-64
    42bc:	623a      	lod	AL, [S-59]
    42be:	38b7      	subc	X, #-73
    42c0:	357b      	and	X, dp:0x7b <_g_NvramUser+0x25>
    42c2:	3663      	and	X, [S-100]
    42c4:	7cd3      	lod	X, #-45
    42c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    42c8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    42ca:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    42cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    42ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    42d0:	b208      	adc	A, [S-9]
    42d2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    42d4:	4616      	mov	[S-23], YL
    42d6:	3561      	and	X, dp:0x61 <_g_NvramUser+0xb>
    42d8:	7208      	lod	A, [S-9]
    42da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    42dc:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    42de:	0103      	jmp	0x44e6 <__mlx4_flash_start+0x4e6>
    42e0:	b272      	adc	A, [S-115]
    42e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    42e4:	010a      	jmp	0x44fa <__mlx4_flash_start+0x4fa>
    42e6:	4500      	mov	dp:0x0 <__dp__>, YL
    42e8:	4584      	mov	dp:0x84 <_g_NvramUser+0x2e>, YL
    42ea:	8582      	or	AL, dp:0x82 <_g_NvramUser+0x2c>
    42ec:	5802      	inc	S, #3
    42ee:	b739      	and	A, ep:0x39 <__data_dp_end+0x1>
    42f0:	b638      	and	A, [S-57]
    42f2:	7272      	lod	A, [S-115]
    42f4:	b737      	and	A, ep:0x37 <_l_u8StallCountA>
    42f6:	0004      	jmp	0x4300 <__mlx4_flash_start+0x300>
    42f8:	2167      	add	X, dp:0x67 <_g_NvramUser+0x11>
    42fa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    42fc:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    42fe:	2047      	add	X, #71
    4300:	6217      	lod	AL, [S-24]
    4302:	0007      	jmp	0x4312 <__mlx4_flash_start+0x312>
    4304:	1102      	call	0x450a <__mlx4_flash_start+0x50a>
    4306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    4308:	7209      	lod	A, [S-10]
    430a:	b208      	adc	A, [S-9]
    430c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    430e:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x42>
    4310:	2165      	add	X, dp:0x65 <_g_NvramUser+0xf>
    4312:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x19>
    4314:	bd83      	xor	A, dp:0x83 <_g_NvramUser+0x2d>
    4316:	716f      	lod	A, dp:0x6f <_g_NvramUser+0x19>
    4318:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x9>
    431a:	a582      	or	A, dp:0x82 <_g_NvramUser+0x2c>
    431c:	1101      	call	0x4520 <__mlx4_flash_start+0x520>
    431e:	2030      	add	X, #48
    4320:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2f>
    4322:	62d2      	lod	AL, [A++]
    4324:	212e      	add	X, dp:0x2e <_g_u8SAE_SendErrorState>
    4326:	38b7      	subc	X, #-73
    4328:	3e18      	xor	X, [S-25]
    432a:	357b      	and	X, dp:0x7b <_g_NvramUser+0x25>
    432c:	367b      	and	X, [S-124]
    432e:	6800      	lod	AH, #0
    4330:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x1a>
    4332:	b792      	and	A, ep:0x92 <_g_NvramUser+0x3c>
    4334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4336:	b20a      	adc	A, [S-11]
    4338:	d667      	and	AH, [S-104]
    433a:	720b      	lod	A, [S-12]
    433c:	b76b      	and	A, ep:0x6b <_g_NvramUser+0x15>
    433e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    4340:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x1a>
    4342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4344:	b20a      	adc	A, [S-11]
    4346:	d667      	and	AH, [S-104]
    4348:	720b      	lod	A, [S-12]
    434a:	b76b      	and	A, ep:0x6b <_g_NvramUser+0x15>
    434c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    434e:	6800      	lod	AH, #0
    4350:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0x11>
    4352:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4354:	e78f      	or	Y, ep:0x8f <_g_NvramUser+0x39>
    4356:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0x11>
    4358:	ef87      	cmp	Y, ep:0x87 <_g_NvramUser+0x31>
    435a:	6800      	lod	AH, #0
    435c:	7270      	lod	A, [S-113]
    435e:	b6e7      	and	A, R
    4360:	8791      	or	AL, ep:0x91 <_g_NvramUser+0x3b>
    4362:	76e7      	jmp	R
    4364:	c791      	or	AH, ep:0x91 <_g_NvramUser+0x3b>
    4366:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    4368:	e370      	add	Y, ep:0x70 <_g_NvramUser+0x1a>
    436a:	0109      	jmp	0x457e <__mlx4_flash_start+0x57e>
    436c:	21af      	add	X, dp:0xaf <_g_NvramUser+0x59>
    436e:	b587      	and	A, dp:0x87 <_g_NvramUser+0x31>
    4370:	b66d      	and	A, [S-110]
    4372:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4374:	b56d      	and	A, dp:0x6d <_g_NvramUser+0x17>
    4376:	76e7      	jmp	R
    4378:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    437a:	75e7      	lod	PC, dp:0xe7 <_ml_driver_mode+0x13>
    437c:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    437e:	6800      	lod	AH, #0
    4380:	b140      	adc	A, dp:0x40 <_g_DiagResponse>
    4382:	814e      	add	AL, dp:0x4e <_g_u16CommutTimerPeriod>
    4384:	7140      	lod	A, dp:0x40 <_g_DiagResponse>
    4386:	b141      	adc	A, dp:0x41 <_g_DiagResponse+0x1>
    4388:	894f      	sub	AL, dp:0x4f <_g_u16CommutTimerPeriod+0x1>
    438a:	7141      	lod	A, dp:0x41 <_g_DiagResponse+0x1>
    438c:	b142      	adc	A, dp:0x42 <_g_DiagResponse+0x2>
    438e:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    4390:	7142      	lod	A, dp:0x42 <_g_DiagResponse+0x2>
    4392:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x3>
    4394:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    4396:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x3>
    4398:	b144      	adc	A, dp:0x44 <_g_DiagResponse+0x4>
    439a:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    439c:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    439e:	6800      	lod	AH, #0
    43a0:	b154      	adc	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    43a2:	814e      	add	AL, dp:0x4e <_g_u16CommutTimerPeriod>
    43a4:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    43a6:	b155      	adc	A, dp:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    43a8:	894f      	sub	AL, dp:0x4f <_g_u16CommutTimerPeriod+0x1>
    43aa:	7155      	lod	A, dp:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    43ac:	b156      	adc	A, dp:0x56 <_g_NvramUser>
    43ae:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    43b0:	7156      	lod	A, dp:0x56 <_g_NvramUser>
    43b2:	b157      	adc	A, dp:0x57 <_g_NvramUser+0x1>
    43b4:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    43b6:	7157      	lod	A, dp:0x57 <_g_NvramUser+0x1>
    43b8:	6800      	lod	AH, #0
    43ba:	b34e      	adc	A, ep:0x4e <_g_u16CommutTimerPeriod>
    43bc:	b24f      	adc	A, [S-80]
    43be:	b15a      	adc	A, dp:0x5a <_g_NvramUser+0x4>
    43c0:	e349      	add	Y, ep:0x49 <_l_u8LinInFrameMsgID+0x1>
    43c2:	ea4a      	sub	Y, [S-75]
    43c4:	e94b      	sub	Y, dp:0x4b <_g_u16CorrectionRatio+0x1>
    43c6:	1003      	call	0x43ce <__mlx4_flash_start+0x3ce>
    43c8:	7349      	lod	A, ep:0x49 <_l_u8LinInFrameMsgID+0x1>
    43ca:	724a      	lod	A, [S-75]
    43cc:	714b      	lod	A, dp:0x4b <_g_u16CorrectionRatio+0x1>
    43ce:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x6>
    43d0:	ea47      	sub	Y, [S-72]
    43d2:	e948      	sub	Y, dp:0x48 <_l_u8LinInFrameMsgID>
    43d4:	0003      	jmp	0x43dc <__mlx4_flash_start+0x3dc>
    43d6:	7346      	lod	A, ep:0x46 <_g_DiagResponse+0x6>
    43d8:	7247      	lod	A, [S-72]
    43da:	7148      	lod	A, dp:0x48 <_l_u8LinInFrameMsgID>
    43dc:	e684      	or	Y, io:0x4 <_LinMess>
    43de:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x2a>
    43e0:	0009      	jmp	0x43f4 <__mlx4_flash_start+0x3f4>
    43e2:	8350      	add	AL, ep:0x50 <__data_size>
    43e4:	8a51      	sub	AL, [S-82]
    43e6:	8952      	sub	AL, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    43e8:	7350      	lod	A, ep:0x50 <__data_size>
    43ea:	7251      	lod	A, [S-82]
    43ec:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    43ee:	b353      	adc	A, ep:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    43f0:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    43f2:	7353      	lod	A, ep:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    43f4:	6800      	lod	AH, #0
    43f6:	b157      	adc	A, dp:0x57 <_g_NvramUser+0x1>
    43f8:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    43fa:	7157      	lod	A, dp:0x57 <_g_NvramUser+0x1>
    43fc:	b156      	adc	A, dp:0x56 <_g_NvramUser>
    43fe:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4400:	7156      	lod	A, dp:0x56 <_g_NvramUser>
    4402:	b155      	adc	A, dp:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    4404:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4406:	7155      	lod	A, dp:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    4408:	b154      	adc	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    440a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    440c:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    440e:	b144      	adc	A, dp:0x44 <_g_DiagResponse+0x4>
    4410:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4412:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    4414:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x3>
    4416:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4418:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x3>
    441a:	b142      	adc	A, dp:0x42 <_g_DiagResponse+0x2>
    441c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    441e:	7142      	lod	A, dp:0x42 <_g_DiagResponse+0x2>
    4420:	b141      	adc	A, dp:0x41 <_g_DiagResponse+0x1>
    4422:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4424:	7141      	lod	A, dp:0x41 <_g_DiagResponse+0x1>
    4426:	b140      	adc	A, dp:0x40 <_g_DiagResponse>
    4428:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    442a:	7140      	lod	A, dp:0x40 <_g_DiagResponse>
    442c:	6800      	lod	AH, #0
    442e:	b139      	adc	A, dp:0x39 <__data_dp_end+0x1>
    4430:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4432:	7139      	lod	A, dp:0x39 <__data_dp_end+0x1>
    4434:	e14c      	add	Y, dp:0x4c <_g_u16MicroStepIdx>
    4436:	0006      	jmp	0x4444 <__mlx4_flash_start+0x444>
    4438:	0102      	jmp	0x463e <__mlx4_flash_start+0x63e>
    443a:	4050      	jmp	fp2:0x80
    443c:	222a      	add	X, [S-43]
    443e:	b20a      	adc	A, [S-11]
    4440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    4442:	2226      	add	X, [S-39]
    4444:	4592      	mov	dp:0x92 <_g_NvramUser+0x3c>, YL
    4446:	b6e5      	and	A, MH
    4448:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    444a:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0x11>
    444c:	7234      	lod	A, [S-53]
    444e:	7335      	lod	A, ep:0x35 <_g_u16StartupDelay+0x1>
    4450:	7208      	lod	A, [S-9]
    4452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    4454:	6800      	lod	AH, #0
    4456:	3e60      	xor	X, [S-97]
    4458:	3e90      	xor	X, io:0x10 <__dp_noinit_size>
    445a:	6800      	lod	AH, #0
    445c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    445e:	b208      	adc	A, [S-9]
    4460:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4462:	4616      	mov	[S-23], YL
    4464:	2228      	add	X, [S-41]
    4466:	820a      	add	AL, [S-11]
    4468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    446a:	8e80      	cmp	AL, io:0x0 <__dp__>
    446c:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    446e:	720a      	lod	A, [S-11]
    4470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    4472:	6800      	lod	AH, #0
    4474:	b739      	and	A, ep:0x39 <__data_dp_end+0x1>
    4476:	b638      	and	A, [S-57]
    4478:	6800      	lod	AH, #0
    447a:	b53e      	and	A, dp:0x3e <__data_dp_end+0x6>
    447c:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    447e:	753e      	lod	PC, dp:0x3e <__data_dp_end+0x6>
    4480:	6800      	lod	AH, #0
    4482:	b330      	adc	A, ep:0x30 <_l_u16VTIdx>
    4484:	b231      	adc	A, [S-50]
    4486:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4488:	8e80      	cmp	AL, io:0x0 <__dp__>
    448a:	7330      	lod	A, ep:0x30 <_l_u16VTIdx>
    448c:	7231      	lod	A, [S-50]
    448e:	e336      	add	Y, ep:0x36 <_l_u8StallCountO>
    4490:	ea37      	sub	Y, [S-56]
    4492:	6800      	lod	AH, #0
    4494:	0009      	jmp	0x44a8 <__mlx4_flash_start+0x4a8>
    4496:	b340      	adc	A, ep:0x40 <_g_DiagResponse>
    4498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    449a:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    449c:	b341      	adc	A, ep:0x41 <_g_DiagResponse+0x1>
    449e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    44a0:	7341      	lod	A, ep:0x41 <_g_DiagResponse+0x1>
    44a2:	b342      	adc	A, ep:0x42 <_g_DiagResponse+0x2>
    44a4:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    44a6:	2257      	add	X, [S-88]
    44a8:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    44aa:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    44ac:	7341      	lod	A, ep:0x41 <_g_DiagResponse+0x1>
    44ae:	7342      	lod	A, ep:0x42 <_g_DiagResponse+0x2>
    44b0:	6800      	lod	AH, #0
    44b2:	b354      	adc	A, ep:0x54 <_g_u16MotorCurrentLPFx64>
    44b4:	b255      	adc	A, [S-86]
    44b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    44b8:	8a03      	sub	AL, [S-4]
    44ba:	7354      	lod	A, ep:0x54 <_g_u16MotorCurrentLPFx64>
    44bc:	7255      	lod	A, [S-86]
    44be:	b356      	adc	A, ep:0x56 <_g_NvramUser>
    44c0:	b257      	adc	A, [S-88]
    44c2:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    44c4:	8e80      	cmp	AL, io:0x0 <__dp__>
    44c6:	7356      	lod	A, ep:0x56 <_g_NvramUser>
    44c8:	7257      	lod	A, [S-88]
    44ca:	6800      	lod	AH, #0
    44cc:	b354      	adc	A, ep:0x54 <_g_u16MotorCurrentLPFx64>
    44ce:	b255      	adc	A, [S-86]
    44d0:	e330      	add	Y, ep:0x30 <_l_u16VTIdx>
    44d2:	ea31      	sub	Y, [S-50]
    44d4:	b356      	adc	A, ep:0x56 <_g_NvramUser>
    44d6:	b257      	adc	A, [S-88]
    44d8:	eb32      	sub	Y, ep:0x32 <_g_u8MotorStopDelay>
    44da:	ea33      	sub	Y, [S-52]
    44dc:	6800      	lod	AH, #0
    44de:	b726      	and	A, ep:0x26 <_g_u8StallOcc>
    44e0:	bf8f      	xor	A, ep:0x8f <_g_NvramUser+0x39>
    44e2:	4040      	jmp	fp2:0x00
    44e4:	0108      	jmp	0x46f6 <__mlx4_flash_start+0x6f6>
    44e6:	3cc3      	xor	X, #-61
    44e8:	b782      	and	A, ep:0x82 <_g_NvramUser+0x2c>
    44ea:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    44ec:	833c      	add	AL, ep:0x3c <__data_dp_end+0x4>
    44ee:	733c      	lod	A, ep:0x3c <__data_dp_end+0x4>
    44f0:	b33d      	adc	A, ep:0x3d <__data_dp_end+0x5>
    44f2:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    44f4:	733d      	lod	A, ep:0x3d <__data_dp_end+0x5>
    44f6:	6800      	lod	AH, #0
    44f8:	b726      	and	A, ep:0x26 <_g_u8StallOcc>
    44fa:	a78f      	or	A, ep:0x8f <_g_NvramUser+0x39>
    44fc:	0101      	jmp	0x4700 <__mlx4_flash_start+0x700>
    44fe:	3cc3      	xor	X, #-61
    4500:	6800      	lod	AH, #0
    4502:	2939      	sub	X, dp:0x39 <__data_dp_end+0x1>
    4504:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4506:	493c      	mov	dp:0x3c <__data_dp_end+0x4>, AH
    4508:	b681      	and	A, io:0x1 <__dp__+0x1>
    450a:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x8>
    450c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    450e:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4510:	b680      	and	A, io:0x0 <__dp__>
    4512:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x8>
    4514:	b682      	and	A, io:0x2 <_LinCmnd>
    4516:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4518:	3b33      	subc	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    451a:	6800      	lod	AH, #0
    451c:	3b12      	subc	X, ep:0x12 <__dp_noinit_size+0x2>
    451e:	b726      	and	A, ep:0x26 <_g_u8StallOcc>
    4520:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    4522:	b682      	and	A, io:0x2 <_LinCmnd>
    4524:	bfbc      	xor	A, ep:0xbc <__bss_dp_size+0xc>
    4526:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4528:	6800      	lod	AH, #0
    452a:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    452c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    452e:	1106      	call	0x473c <__mlx4_flash_start+0x73c>
    4530:	e781      	or	Y, ep:0x81 <_g_NvramUser+0x2b>
    4532:	1108      	call	0x4744 <__mlx4_flash_start+0x744>
    4534:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4536:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x2b>
    4538:	5404      	ret	#5
    453a:	202f      	add	X, #47
    453c:	e78e      	or	Y, ep:0x8e <_g_NvramUser+0x38>
    453e:	0102      	jmp	0x4744 <__mlx4_flash_start+0x744>
    4540:	a752      	or	A, ep:0x52 <_g_u16MotorCurrentMovAvgxN>
    4542:	1104      	call	0x474c <__mlx4_flash_start+0x74c>
    4544:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4546:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x2b>
    4548:	5404      	ret	#5
    454a:	6800      	lod	AH, #0
    454c:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    454e:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x2b>
    4550:	5404      	ret	#5
    4552:	e684      	or	Y, io:0x4 <_LinMess>
    4554:	1102      	call	0x475a <__mlx4_flash_start+0x75a>
    4556:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4558:	29d4      	sub	X, dp:0xd4 <_ml_driver_mode>
    455a:	7201      	lod	A, [S-2]
    455c:	e682      	or	Y, io:0x2 <_LinCmnd>
    455e:	1101      	call	0x4762 <__mlx4_flash_start+0x762>
    4560:	248f      	or	X, #-113
    4562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    4564:	1101      	call	0x4768 <__mlx4_flash_start+0x768>
    4566:	2967      	sub	X, dp:0x67 <_g_NvramUser+0x11>
    4568:	2487      	or	X, #-121
    456a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    456c:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x37>
    456e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    4570:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4572:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    4574:	b782      	and	A, ep:0x82 <_g_NvramUser+0x2c>
    4576:	22d2      	add	X, [A++]
    4578:	0b04      	setb	io:0x00.4
    457a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    457c:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x32>
    457e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    4580:	22e5      	add	X, MH
    4582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    4584:	b20d      	adc	A, [S-14]
    4586:	7238      	lod	A, [S-57]
    4588:	b202      	adc	A, [S-3]
    458a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    458c:	b203      	adc	A, [S-4]
    458e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    4590:	b63e      	and	A, [S-63]
    4592:	22d7      	.word	0x22d7
    4594:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    4596:	7201      	lod	A, [S-2]
    4598:	7338      	lod	A, ep:0x38 <__data_dp_end>
    459a:	b365      	adc	A, ep:0x65 <_g_NvramUser+0xf>
    459c:	bf81      	xor	A, ep:0x81 <_g_NvramUser+0x2b>
    459e:	0101      	jmp	0x47a2 <__mlx4_flash_start+0x7a2>
    45a0:	6800      	lod	AH, #0
    45a2:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    45a4:	0b04      	setb	io:0x00.4
    45a6:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    45a8:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x32>
    45aa:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    45ac:	22e5      	add	X, MH
    45ae:	7334      	lod	A, ep:0x34 <_g_u16StartupDelay>
    45b0:	7235      	lod	A, [S-54]
    45b2:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x32>
    45b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    45b6:	718a      	lod	A, dp:0x8a <_g_NvramUser+0x34>
    45b8:	b338      	adc	A, ep:0x38 <__data_dp_end>
    45ba:	738b      	lod	A, ep:0x8b <_g_NvramUser+0x35>
    45bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    45be:	b20f      	adc	A, [S-16]
    45c0:	738e      	lod	A, ep:0x8e <_g_NvramUser+0x38>
    45c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    45c4:	5408      	ret	#9
    45c6:	7ca6      	lod	X, #-90
    45c8:	7d34      	lod	X, dp:0x34 <_g_u16StartupDelay>
    45ca:	6800      	lod	AH, #0
    45cc:	b384      	adc	A, ep:0x84 <_g_NvramUser+0x2e>
    45ce:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    45d0:	7380      	lod	A, ep:0x80 <_g_NvramUser+0x2a>
    45d2:	7334      	lod	A, ep:0x34 <_g_u16StartupDelay>
    45d4:	7235      	lod	A, [S-54]
    45d6:	7ca7      	lod	X, #-89
    45d8:	7d34      	lod	X, dp:0x34 <_g_u16StartupDelay>
    45da:	6c03      	lod	YH, #3
    45dc:	2300      	add	X, ep:0x0 <__dp__>
    45de:	2295      	add	X, io:0x15 <__dp_noinit_size+0x5>
    45e0:	23ee      	add	X, ep:0xee <_g_u16TargetPosition>
    45e2:	2300      	add	X, ep:0x0 <__dp__>
    45e4:	2300      	add	X, ep:0x0 <__dp__>
    45e6:	23a1      	add	X, ep:0xa1 <_g_NvramUser+0x4b>
    45e8:	240b      	or	X, #11
    45ea:	23cb      	add	X, ep:0xcb <_LinFrameDataBuffer+0x3>
    45ec:	2300      	add	X, ep:0x0 <__dp__>
    45ee:	2300      	add	X, ep:0x0 <__dp__>
    45f0:	2304      	add	X, ep:0x4 <_LinMess>
    45f2:	23c3      	add	X, ep:0xc3 <__bss_dp_size+0x13>
    45f4:	23e6      	add	X, ep:0xe6 <_ml_driver_mode+0x12>
    45f6:	23da      	add	X, ep:0xda <_ml_driver_mode+0x6>
    45f8:	2300      	add	X, ep:0x0 <__dp__>
    45fa:	23b7      	add	X, ep:0xb7 <__bss_dp_size+0x7>
    45fc:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    45fe:	2301      	add	X, ep:0x1 <__dp__+0x1>
    4600:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4602:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x2b>
    4604:	5404      	ret	#5
    4606:	6800      	lod	AH, #0
    4608:	e682      	or	Y, io:0x2 <_LinCmnd>
    460a:	0104      	jmp	0x4814 <__mlx4_flash_start+0x814>
    460c:	b681      	and	A, io:0x1 <__dp__+0x1>
    460e:	7282      	lod	A, io:0x2 <_LinCmnd>
    4610:	b684      	and	A, io:0x4 <_LinMess>
    4612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    4614:	b680      	and	A, io:0x0 <__dp__>
    4616:	7282      	lod	A, io:0x2 <_LinCmnd>
    4618:	b680      	and	A, io:0x0 <__dp__>
    461a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    461c:	22fe      	add	X, [X+6]
    461e:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4620:	a688      	or	A, io:0x8 <__bist_stat_size>
    4622:	0102      	jmp	0x4828 <__mlx4_flash_start+0x828>
    4624:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4626:	2315      	add	X, ep:0x15 <__dp_noinit_size+0x5>
    4628:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    462a:	7170      	lod	A, dp:0x70 <_g_NvramUser+0x1a>
    462c:	a684      	or	A, io:0x4 <_LinMess>
    462e:	0101      	jmp	0x4832 <__mlx4_flash_start+0x832>
    4630:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    4634:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4636:	7271      	lod	A, [S-114]
    4638:	b286      	adc	A, io:0x6 <_LinMess2>
    463a:	4616      	mov	[S-23], YL
    463c:	7286      	lod	A, io:0x6 <_LinMess2>
    463e:	b271      	adc	A, [S-114]
    4640:	b5a3      	and	A, dp:0xa3 <_g_NvramUser+0x4d>
    4642:	0009      	jmp	0x4656 <__mlx4_flash_start+0x656>
    4644:	6c02      	lod	YH, #2
    4646:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x38>
    4648:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    464a:	bd8d      	xor	A, dp:0x8d <_g_NvramUser+0x37>
    464c:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    464e:	bd8b      	xor	A, dp:0x8b <_g_NvramUser+0x35>
    4650:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    4652:	bd87      	xor	A, dp:0x87 <_g_NvramUser+0x31>
    4654:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    4656:	6c02      	lod	YH, #2
    4658:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x2b>
    465a:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    465c:	f582      	and	Y, dp:0x82 <_g_NvramUser+0x2c>
    465e:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    4660:	f584      	and	Y, dp:0x84 <_g_NvramUser+0x2e>
    4662:	2333      	add	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    4664:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x32>
    4666:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4668:	b170      	adc	A, dp:0x70 <_g_NvramUser+0x1a>
    466a:	76a3      	jmp	io:0x23 <_g_e8DegradedMotorRequest>
    466c:	e78a      	or	Y, ep:0x8a <_g_NvramUser+0x34>
    466e:	1008      	call	0x4680 <__mlx4_flash_start+0x680>
    4670:	8782      	or	AL, ep:0x82 <_g_NvramUser+0x2c>
    4672:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4674:	a783      	or	A, ep:0x83 <_g_NvramUser+0x2d>
    4676:	4794      	mov	ep:0x94 <_g_NvramUser+0x3e>, YL
    4678:	0101      	jmp	0x487c <__mlx4_flash_start+0x87c>
    467a:	231c      	add	X, ep:0x1c <_g_i16MotorVoltage>
    467c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    467e:	231d      	add	X, ep:0x1d <_g_i16MotorVoltage+0x1>
    4680:	e78c      	or	Y, ep:0x8c <_g_NvramUser+0x36>
    4682:	1003      	call	0x468a <__mlx4_flash_start+0x68a>
    4684:	8782      	or	AL, ep:0x82 <_g_NvramUser+0x2c>
    4686:	4050      	jmp	fp2:0x80
    4688:	231f      	add	X, ep:0x1f <__ramfunc_size+0x1>
    468a:	22fe      	add	X, [X+6]
    468c:	b202      	adc	A, [S-3]
    468e:	b36b      	adc	A, ep:0x6b <_g_NvramUser+0x15>
    4690:	836a      	add	AL, ep:0x6a <_g_NvramUser+0x14>
    4692:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x15>
    4694:	bf81      	xor	A, ep:0x81 <_g_NvramUser+0x2b>
    4696:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4698:	6c03      	lod	YH, #3
    469a:	2375      	add	X, ep:0x75 <_g_NvramUser+0x1f>
    469c:	2351      	add	X, ep:0x51 <__data_size+0x1>
    469e:	236c      	add	X, ep:0x6c <_g_NvramUser+0x16>
    46a0:	2375      	add	X, ep:0x75 <_g_NvramUser+0x1f>
    46a2:	8681      	or	AL, io:0x1 <__dp__+0x1>
    46a4:	7202      	lod	A, [S-3]
    46a6:	b203      	adc	A, [S-4]
    46a8:	8e80      	cmp	AL, io:0x0 <__dp__>
    46aa:	f36b      	adc	Y, ep:0x6b <_g_NvramUser+0x15>
    46ac:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x15>
    46ae:	b786      	and	A, ep:0x86 <_g_NvramUser+0x30>
    46b0:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x6>
    46b2:	0002      	jmp	0x46b8 <__mlx4_flash_start+0x6b8>
    46b4:	0106      	jmp	0x48c2 <__mlx4_flash_start+0x8c2>
    46b6:	2373      	add	X, ep:0x73 <_g_NvramUser+0x1d>
    46b8:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    46ba:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x6>
    46bc:	1003      	call	0x46c4 <__mlx4_flash_start+0x6c4>
    46be:	b78f      	and	A, ep:0x8f <_g_NvramUser+0x39>
    46c0:	2362      	add	X, ep:0x62 <_g_NvramUser+0xc>
    46c2:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    46c4:	0000      	nop
    46c6:	0000      	nop
    46c8:	0000      	nop
    46ca:	0000      	nop
    46cc:	0000      	nop
    46ce:	0000      	nop
    46d0:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    46d2:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x2a>
    46d4:	0108      	jmp	0x48e6 <__mlx4_flash_start+0x8e6>
    46d6:	2362      	add	X, ep:0x62 <_g_NvramUser+0xc>
    46d8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    46da:	7202      	lod	A, [S-3]
    46dc:	b203      	adc	A, [S-4]
    46de:	ce80      	cmp	AH, io:0x0 <__dp__>
    46e0:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x38>
    46e2:	bb6b      	subc	A, ep:0x6b <_g_NvramUser+0x15>
    46e4:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x15>
    46e6:	7203      	lod	A, [S-4]
    46e8:	4c02 6800 	add	D, #1920034816
    46ec:	7271 
    46ee:	b16d      	adc	A, dp:0x6d <_g_NvramUser+0x17>
    46f0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    46f2:	716d      	lod	A, dp:0x6d <_g_NvramUser+0x17>
    46f4:	0b04      	setb	io:0x00.4
    46f6:	b25e      	adc	A, [S-95]
    46f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    46fa:	725e      	lod	A, [S-95]
    46fc:	2388      	add	X, ep:0x88 <_g_NvramUser+0x32>
    46fe:	7189      	lod	A, dp:0x89 <_g_NvramUser+0x33>
    4700:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    4702:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4704:	7335      	lod	A, ep:0x35 <_g_u16StartupDelay+0x1>
    4706:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    4708:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x32>
    470a:	5408      	ret	#9
    470c:	7c55      	lod	X, #85
    470e:	7d34      	lod	X, dp:0x34 <_g_u16StartupDelay>
    4710:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4712:	b588      	and	A, dp:0x88 <_g_NvramUser+0x32>
    4714:	3beb      	subc	X, ep:0xeb <_g_u8MotorHoldingCurrEna+0x1>
    4716:	b5a6      	and	A, dp:0xa6 <_g_NvramUser+0x50>
    4718:	716e      	lod	A, dp:0x6e <_g_NvramUser+0x18>
    471a:	a58f      	or	A, dp:0x8f <_g_NvramUser+0x39>
    471c:	1103      	call	0x4924 <__mlx4_flash_start+0x924>
    471e:	b16c      	adc	A, dp:0x6c <_g_NvramUser+0x16>
    4720:	bd84      	xor	A, dp:0x84 <_g_NvramUser+0x2e>
    4722:	716c      	lod	A, dp:0x6c <_g_NvramUser+0x16>
    4724:	b271      	adc	A, [S-114]
    4726:	6800      	lod	AH, #0
    4728:	a688      	or	A, io:0x8 <__bist_stat_size>
    472a:	110a      	call	0x4940 <__mlx4_flash_start+0x940>
    472c:	b23b      	adc	A, [S-60]
    472e:	f684      	and	Y, io:0x4 <_LinMess>
    4730:	723b      	lod	A, [S-60]
    4732:	b35a      	adc	A, ep:0x5a <_g_NvramUser+0x4>
    4734:	7342      	lod	A, ep:0x42 <_g_DiagResponse+0x2>
    4736:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4738:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    473a:	7341      	lod	A, ep:0x41 <_g_DiagResponse+0x1>
    473c:	7343      	lod	A, ep:0x43 <_g_DiagResponse+0x3>
    473e:	7344      	lod	A, ep:0x44 <_g_DiagResponse+0x4>
    4740:	6800      	lod	AH, #0
    4742:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4744:	b286      	adc	A, io:0x6 <_LinMess2>
    4746:	010a      	jmp	0x495c <__mlx4_flash_start+0x95c>
    4748:	000e      	jmp	0x4766 <__mlx4_flash_start+0x766>
    474a:	e680      	or	Y, io:0x0 <__dp__>
    474c:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x9>
    474e:	0103      	jmp	0x4956 <__mlx4_flash_start+0x956>
    4750:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x2c>
    4752:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    4754:	22fe      	add	X, [X+6]
    4756:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x37>
    4758:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    475a:	22fe      	add	X, [X+6]
    475c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    475e:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x32>
    4760:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    4762:	7200      	lod	A, [S-1]
    4764:	22fe      	add	X, [X+6]
    4766:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4768:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2e>
    476a:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    476c:	22fe      	add	X, [X+6]
    476e:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    4770:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x37>
    4772:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    4774:	a682      	or	A, io:0x2 <_LinCmnd>
    4776:	1106      	call	0x4984 <__mlx4_flash_start+0x984>
    4778:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x9>
    477a:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x38>
    477c:	a681      	or	A, io:0x1 <__dp__+0x1>
    477e:	0101      	jmp	0x4982 <__mlx4_flash_start+0x982>
    4780:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x2b>
    4782:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    4784:	22fe      	add	X, [X+6]
    4786:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4788:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    478a:	0101      	jmp	0x498e <__mlx4_flash_start+0x98e>
    478c:	2300      	add	X, ep:0x0 <__dp__>
    478e:	7264      	lod	A, [S-101]
    4790:	b286      	adc	A, io:0x6 <_LinMess2>
    4792:	7265      	lod	A, [S-102]
    4794:	22fe      	add	X, [X+6]
    4796:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4798:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    479a:	0101      	jmp	0x499e <__mlx4_flash_start+0x99e>
    479c:	2300      	add	X, ep:0x0 <__dp__>
    479e:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    47a0:	be86      	xor	A, io:0x6 <_LinMess2>
    47a2:	6c02      	lod	YH, #2
    47a4:	3e04      	xor	X, [S-5]
    47a6:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x5>
    47a8:	3e05      	xor	X, [S-6]
    47aa:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x5>
    47ac:	3e06      	xor	X, [S-7]
    47ae:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x5>
    47b0:	3e07      	xor	X, [S-8]
    47b2:	22fe      	add	X, [X+6]
    47b4:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    47b6:	e681      	or	Y, io:0x1 <__dp__+0x1>
    47b8:	0106      	jmp	0x49c6 <__mlx4_flash_start+0x9c6>
    47ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    47bc:	0102      	jmp	0x49c2 <__mlx4_flash_start+0x9c2>
    47be:	b680      	and	A, io:0x0 <__dp__>
    47c0:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0x10>
    47c2:	b682      	and	A, io:0x2 <_LinCmnd>
    47c4:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0x10>
    47c6:	b684      	and	A, io:0x4 <_LinMess>
    47c8:	726c      	lod	A, [S-109]
    47ca:	22fe      	add	X, [X+6]
    47cc:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    47ce:	7382      	lod	A, ep:0x82 <_g_NvramUser+0x2c>
    47d0:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    47d2:	7383      	lod	A, ep:0x83 <_g_NvramUser+0x2d>
    47d4:	f686      	and	Y, io:0x6 <_LinMess2>
    47d6:	bf92      	xor	A, ep:0x92 <_g_NvramUser+0x3c>
    47d8:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    47da:	22fe      	add	X, [X+6]
    47dc:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    47de:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    47e0:	0101      	jmp	0x49e4 <__mlx4_flash_start+0x9e4>
    47e2:	2300      	add	X, ep:0x0 <__dp__>
    47e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    47e6:	010e      	jmp	0x4a04 <__mlx4_flash_start+0xa04>
    47e8:	763e      	jmp	[S-63]
    47ea:	7207      	lod	A, [S-8]
    47ec:	7206      	lod	A, [S-7]
    47ee:	b286      	adc	A, io:0x6 <_LinMess2>
    47f0:	7202      	lod	A, [S-3]
    47f2:	7204      	lod	A, [S-5]
    47f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    47f6:	7203      	lod	A, [S-4]
    47f8:	7205      	lod	A, [S-6]
    47fa:	b25c      	adc	A, [S-93]
    47fc:	f684      	and	Y, io:0x4 <_LinMess>
    47fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4800:	725c      	lod	A, [S-93]
    4802:	22fe      	add	X, [X+6]
    4804:	b25c      	adc	A, [S-93]
    4806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4808:	b386      	adc	A, ep:0x86 <_g_NvramUser+0x30>
    480a:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x2a>
    480c:	0101      	jmp	0x4a10 <__mlx4_flash_start+0xa10>
    480e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    4812:	725c      	lod	A, [S-93]
    4814:	22fe      	add	X, [X+6]
    4816:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4818:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    481a:	0101      	jmp	0x4a1e <__mlx4_flash_start+0xa1e>
    481c:	2300      	add	X, ep:0x0 <__dp__>
    481e:	b387      	adc	A, ep:0x87 <_g_NvramUser+0x31>
    4820:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4822:	0001      	jmp	0x4826 <__mlx4_flash_start+0x826>
    4824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    4826:	7271      	lod	A, [S-114]
    4828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    482a:	4608      	mov	[S-9], YL
    482c:	6c02      	lod	YH, #2
    482e:	b11c      	adc	A, dp:0x1c <_g_i16MotorVoltage>
    4830:	241e      	or	X, #30
    4832:	b11d      	adc	A, dp:0x1d <_g_i16MotorVoltage+0x1>
    4834:	241e      	or	X, #30
    4836:	b12c      	adc	A, dp:0x2c <_g_u8BufferOutID>
    4838:	241e      	or	X, #30
    483a:	b12d      	adc	A, dp:0x2d <_l_u8ActDirection>
    483c:	b387      	adc	A, ep:0x87 <_g_NvramUser+0x31>
    483e:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4840:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4842:	b371      	adc	A, ep:0x71 <_g_NvramUser+0x1b>
    4844:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    4846:	4788      	mov	ep:0x88 <_g_NvramUser+0x32>, YL
    4848:	0009      	jmp	0x485c <__mlx4_flash_start+0x85c>
    484a:	6c03      	lod	YH, #3
    484c:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x38>
    484e:	2436      	or	X, #54
    4850:	bd8d      	xor	A, dp:0x8d <_g_NvramUser+0x37>
    4852:	2436      	or	X, #54
    4854:	bd8b      	xor	A, dp:0x8b <_g_NvramUser+0x35>
    4856:	2436      	or	X, #54
    4858:	bd87      	xor	A, dp:0x87 <_g_NvramUser+0x31>
    485a:	2436      	or	X, #54
    485c:	6c03      	lod	YH, #3
    485e:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x2b>
    4860:	2436      	or	X, #54
    4862:	f582      	and	Y, dp:0x82 <_g_NvramUser+0x2c>
    4864:	2436      	or	X, #54
    4866:	f584      	and	Y, dp:0x84 <_g_NvramUser+0x2e>
    4868:	2436      	or	X, #54
    486a:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x32>
    486c:	6c02      	lod	YH, #2
    486e:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    4870:	243e      	or	X, #62
    4872:	711d      	lod	A, dp:0x1d <_g_i16MotorVoltage+0x1>
    4874:	243e      	or	X, #62
    4876:	712c      	lod	A, dp:0x2c <_g_u8BufferOutID>
    4878:	243e      	or	X, #62
    487a:	712d      	lod	A, dp:0x2d <_l_u8ActDirection>
    487c:	22fe      	add	X, [X+6]
    487e:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4880:	b682      	and	A, io:0x2 <_LinCmnd>
    4882:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4884:	7c01      	lod	X, #1
    4886:	5018      	call	fp0:0xC0
    4888:	54c0      	.word	0x54c0
    488a:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    488c:	733e      	lod	A, ep:0x3e <__data_dp_end+0x6>
    488e:	733f      	lod	A, ep:0x3f <__data_dp_end+0x7>
    4890:	5401      	ret
    4892:	3e60      	xor	X, [S-97]
    4894:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4896:	773a      	lod	PC, ep:0x3a <__data_dp_end+0x2>
    4898:	773b      	lod	PC, ep:0x3b <__data_dp_end+0x3>
    489a:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x7>
    489c:	355b      	and	X, dp:0x5b <_g_NvramUser+0x5>
    489e:	365b      	and	X, [S-92]
    48a0:	3730      	and	X, ep:0x30 <_l_u16VTIdx>
    48a2:	7736      	lod	PC, ep:0x36 <_l_u8StallCountO>
    48a4:	3ba0      	subc	X, ep:0xa0 <_g_NvramUser+0x4a>
    48a6:	b78f      	and	A, ep:0x8f <_g_NvramUser+0x39>
    48a8:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    48aa:	b681      	and	A, io:0x1 <__dp__+0x1>
    48ac:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48ae:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x38>
    48b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    48b2:	b680      	and	A, io:0x0 <__dp__>
    48b4:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48b6:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    48b8:	7301      	lod	A, ep:0x1 <__dp__+0x1>
    48ba:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    48bc:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    48be:	494e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, AH
    48c0:	4930      	mov	dp:0x30 <_l_u16VTIdx>, AH
    48c2:	493a      	mov	dp:0x3a <__data_dp_end+0x2>, AH
    48c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    48c6:	4964      	mov	dp:0x64 <_g_NvramUser+0xe>, AH
    48c8:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x9>
    48ca:	736c      	lod	A, ep:0x6c <_g_NvramUser+0x16>
    48cc:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x6>
    48ce:	7338      	lod	A, ep:0x38 <__data_dp_end>
    48d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    48d2:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    48d4:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    48d6:	b58b      	and	A, dp:0x8b <_g_NvramUser+0x35>
    48d8:	7105      	lod	A, dp:0x5 <_LinMess+0x1>
    48da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    48dc:	b58c      	and	A, dp:0x8c <_g_NvramUser+0x36>
    48de:	7104      	lod	A, dp:0x4 <_LinMess>
    48e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    48e2:	b583      	and	A, dp:0x83 <_g_NvramUser+0x2d>
    48e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    48e6:	7106      	lod	A, dp:0x6 <_LinMess2>
    48e8:	b680      	and	A, io:0x0 <__dp__>
    48ea:	77c6      	lod	PC, ep:0xc6 <_g_u16PID_I>
    48ec:	77ca      	lod	PC, ep:0xca <_LinFrameDataBuffer+0x2>
    48ee:	8681      	or	AL, io:0x1 <__dp__+0x1>
    48f0:	0101      	jmp	0x4af4 <__mlx4_flash_start+0xaf4>
    48f2:	2475      	or	X, #117
    48f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    48f6:	7336      	lod	A, ep:0x36 <_l_u8StallCountO>
    48f8:	7237      	lod	A, [S-56]
    48fa:	b788      	and	A, ep:0x88 <_g_NvramUser+0x32>
    48fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    48fe:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4900:	738c      	lod	A, ep:0x8c <_g_NvramUser+0x36>
    4902:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2e>
    4904:	738d      	lod	A, ep:0x8d <_g_NvramUser+0x37>
    4906:	7c02      	lod	X, #2
    4908:	5820      	inc	S, #33
    490a:	b681      	and	A, io:0x1 <__dp__+0x1>
    490c:	62ca      	lod	AL, [--PC]
    490e:	622b      	lod	AL, [S-44]
    4910:	3448      	and	X, #72
    4912:	5809      	inc	S, #10
    4914:	62e6      	lod	AL, Y
    4916:	2489      	or	X, #-119
    4918:	b78a      	and	A, ep:0x8a <_g_NvramUser+0x34>
    491a:	b682      	and	A, io:0x2 <_LinCmnd>
    491c:	62ca      	lod	AL, [--PC]
    491e:	5018      	call	fp0:0xC0
    4920:	54c0      	.word	0x54c0
    4922:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4924:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    4926:	24a3      	or	X, #-93
    4928:	b680      	and	A, io:0x0 <__dp__>
    492a:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    492c:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    492e:	0106      	jmp	0x4b3c <__mlx4_flash_start+0xb3c>
    4930:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x38>
    4932:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    4934:	b239      	adc	A, [S-58]
    4936:	7238      	lod	A, [S-57]
    4938:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    493a:	b686      	and	A, io:0x6 <_LinMess2>
    493c:	e680      	or	Y, io:0x0 <__dp__>
    493e:	0101      	jmp	0x4b42 <__mlx4_flash_start+0xb42>
    4940:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4942:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4944:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    4946:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x19>
    4948:	bd88      	xor	A, dp:0x88 <_g_NvramUser+0x32>
    494a:	716f      	lod	A, dp:0x6f <_g_NvramUser+0x19>
    494c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    494e:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x37>
    4950:	1101      	call	0x4b54 <__mlx4_flash_start+0xb54>
    4952:	24c2      	or	X, #-62
    4954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    4956:	494e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, AH
    4958:	b58e      	and	A, dp:0x8e <_g_NvramUser+0x38>
    495a:	b561      	and	A, dp:0x61 <_g_NvramUser+0xb>
    495c:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x6>
    495e:	1101      	call	0x4b62 <__mlx4_flash_start+0xb62>
    4960:	24c2      	or	X, #-62
    4962:	b340      	adc	A, ep:0x40 <_g_DiagResponse>
    4964:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    4966:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    4968:	b341      	adc	A, ep:0x41 <_g_DiagResponse+0x1>
    496a:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    496c:	7341      	lod	A, ep:0x41 <_g_DiagResponse+0x1>
    496e:	b342      	adc	A, ep:0x42 <_g_DiagResponse+0x2>
    4970:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4972:	7342      	lod	A, ep:0x42 <_g_DiagResponse+0x2>
    4974:	b343      	adc	A, ep:0x43 <_g_DiagResponse+0x3>
    4976:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4978:	7343      	lod	A, ep:0x43 <_g_DiagResponse+0x3>
    497a:	b344      	adc	A, ep:0x44 <_g_DiagResponse+0x4>
    497c:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    497e:	7344      	lod	A, ep:0x44 <_g_DiagResponse+0x4>
    4980:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4982:	24ae      	or	X, #-82
    4984:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4986:	7166      	lod	A, dp:0x66 <_g_NvramUser+0x10>
    4988:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    498a:	7167      	lod	A, dp:0x67 <_g_NvramUser+0x11>
    498c:	b58e      	and	A, dp:0x8e <_g_NvramUser+0x38>
    498e:	b561      	and	A, dp:0x61 <_g_NvramUser+0xb>
    4990:	e106      	add	Y, dp:0x6 <_LinMess2>
    4992:	0108      	jmp	0x4ba4 <__mlx4_flash_start+0xba4>
    4994:	b266      	adc	A, [S-103]
    4996:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4998:	7266      	lod	A, [S-103]
    499a:	b267      	adc	A, [S-104]
    499c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    499e:	7267      	lod	A, [S-104]
    49a0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    49a2:	24c8      	or	X, #-56
    49a4:	4d66      	mov	dp:0x66 <_g_NvramUser+0x10>, YH
    49a6:	4968      	mov	dp:0x68 <_g_NvramUser+0x12>, AH
    49a8:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    49aa:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    49ac:	733a      	lod	A, ep:0x3a <__data_dp_end+0x2>
    49ae:	623a      	lod	AL, [S-59]
    49b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    49b2:	1104      	call	0x4bbc <__mlx4_flash_start+0xbbc>
    49b4:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    49b6:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    49b8:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    49ba:	24f2      	or	X, #-14
    49bc:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    49be:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x37>
    49c0:	0103      	jmp	0x4bc8 <__mlx4_flash_start+0xbc8>
    49c2:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    49c4:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    49c6:	2494      	or	X, #-108
    49c8:	580e      	inc	S, #15
    49ca:	0803      	clrb	dp:0x00.3
    49cc:	0906      	clrb	io:0x00.6
    49ce:	62e6      	lod	AL, Y
    49d0:	24e4      	or	X, #-28
    49d2:	623a      	lod	AL, [S-59]
    49d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    49d6:	0106      	jmp	0x4be4 <__mlx4_flash_start+0xbe4>
    49d8:	24e4      	or	X, #-28
    49da:	626f      	lod	AL, [S-112]
    49dc:	0001      	jmp	0x49e0 <__mlx4_flash_start+0x9e0>
    49de:	24e9      	or	X, #-23
    49e0:	b586      	and	A, dp:0x86 <_g_NvramUser+0x30>
    49e2:	29d4      	sub	X, dp:0xd4 <_ml_driver_mode>
    49e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    49e6:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    49e8:	380d      	subc	X, #13
    49ea:	3805      	subc	X, #5
    49ec:	3479      	and	X, #121
    49ee:	303a      	adc	X, #58
    49f0:	39f6      	subc	X, dp:0xf6 <_g_u16ActuatorTgtPos>
    49f2:	b26c      	adc	A, [S-109]
    49f4:	a686      	or	A, io:0x6 <_LinMess2>
    49f6:	0106      	jmp	0x4c04 <__mlx4_flash_start+0xc04>
    49f8:	f681      	and	Y, io:0x1 <__dp__+0x1>
    49fa:	726c      	lod	A, [S-109]
    49fc:	b26e      	adc	A, [S-111]
    49fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    4a00:	1101      	call	0x4c04 <__mlx4_flash_start+0xc04>
    4a02:	6376      	lod	AL, ep:0x76 <_g_NvramUser+0x20>
    4a04:	3cc3      	xor	X, #-61
    4a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    4a08:	be38      	xor	A, [S-57]
    4a0a:	0101      	jmp	0x4c0e <__mlx4_flash_start+0xc0e>
    4a0c:	2494      	or	X, #-108
    4a0e:	580e      	inc	S, #15
    4a10:	0905      	clrb	io:0x00.5
    4a12:	0802      	clrb	dp:0x00.2
    4a14:	62e6      	lod	AL, Y
    4a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a18:	623a      	lod	AL, [S-59]
    4a1a:	2522      	or	X, dp:0x22 <_g_u8RewindFlags>
    4a1c:	623a      	lod	AL, [S-59]
    4a1e:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x6>
    4a20:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x38>
    4a22:	a681      	or	A, io:0x1 <__dp__+0x1>
    4a24:	1102      	call	0x4c2a <__mlx4_flash_start+0xc2a>
    4a26:	a78c      	or	A, ep:0x8c <_g_NvramUser+0x36>
    4a28:	0101      	jmp	0x4c2c <__mlx4_flash_start+0xc2c>
    4a2a:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x2b>
    4a2c:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x6>
    4a2e:	4050      	jmp	fp2:0x80
    4a30:	6c04      	lod	YH, #4
    4a32:	2528      	or	X, dp:0x28 <_g_e8MotorDirectionCCW>
    4a34:	2542      	or	X, dp:0x42 <_g_DiagResponse+0x2>
    4a36:	254f      	or	X, dp:0x4f <_g_u16CommutTimerPeriod+0x1>
    4a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a3a:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x6>
    4a3c:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    4a3e:	0107      	jmp	0x4c4e <__mlx4_flash_start+0xc4e>
    4a40:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x38>
    4a42:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x6>
    4a44:	484f      	macu	D, AL, [X]
    4a46:	6c04      	lod	YH, #4
    4a48:	2557      	or	X, dp:0x57 <_g_NvramUser+0x1>
    4a4a:	2584      	or	X, dp:0x84 <_g_NvramUser+0x2e>
    4a4c:	25c6      	or	X, dp:0xc6 <_g_u16PID_I>
    4a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a50:	484e      	macu	D, AL, [X++]
    4a52:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4a54:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x2d>
    4a56:	1104      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a58:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x3>
    4a5a:	e585      	or	Y, dp:0x85 <_g_NvramUser+0x2f>
    4a5c:	1101      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a5e:	2918      	sub	X, dp:0x18 <__data_dp_start>
    4a60:	b16c      	adc	A, dp:0x6c <_g_NvramUser+0x16>
    4a62:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    4a64:	010e      	jmp	0x4c82 <__mlx4_flash_start+0xc82>
    4a66:	b168      	adc	A, dp:0x68 <_g_NvramUser+0x12>
    4a68:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4a6a:	7168      	lod	A, dp:0x68 <_g_NvramUser+0x12>
    4a6c:	b169      	adc	A, dp:0x69 <_g_NvramUser+0x13>
    4a6e:	cd80      	cmp	AH, dp:0x80 <_g_NvramUser+0x2a>
    4a70:	7169      	lod	A, dp:0x69 <_g_NvramUser+0x13>
    4a72:	1107      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a74:	4d66      	mov	dp:0x66 <_g_NvramUser+0x10>, YH
    4a76:	4968      	mov	dp:0x68 <_g_NvramUser+0x12>, AH
    4a78:	b16e      	adc	A, dp:0x6e <_g_NvramUser+0x18>
    4a7a:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4a7c:	716e      	lod	A, dp:0x6e <_g_NvramUser+0x18>
    4a7e:	1101      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a80:	6376      	lod	AL, ep:0x76 <_g_NvramUser+0x20>
    4a82:	251d      	or	X, dp:0x1d <_g_i16MotorVoltage+0x1>
    4a84:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    4a86:	7271      	lod	A, [S-114]
    4a88:	b256      	adc	A, [S-87]
    4a8a:	c242      	add	AH, [S-67]
    4a8c:	c943      	sub	AH, dp:0x43 <_g_DiagResponse+0x3>
    4a8e:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4a90:	4616      	mov	[S-23], YL
    4a92:	e242      	add	Y, [S-67]
    4a94:	e943      	sub	Y, dp:0x43 <_g_DiagResponse+0x3>
    4a96:	1002      	call	0x4a9c <__mlx4_flash_start+0xa9c>
    4a98:	b271      	adc	A, [S-114]
    4a9a:	251d      	or	X, dp:0x1d <_g_i16MotorVoltage+0x1>
    4a9c:	2494      	or	X, #-108
    4a9e:	b15a      	adc	A, dp:0x5a <_g_NvramUser+0x4>
    4aa0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4aa2:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x4>
    4aa4:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x2d>
    4aa6:	1001      	call	0x4aaa <__mlx4_flash_start+0xaaa>
    4aa8:	251d      	or	X, dp:0x1d <_g_i16MotorVoltage+0x1>
    4aaa:	6394      	lod	AL, ep:0x94 <_g_NvramUser+0x3e>
    4aac:	25ee      	or	X, dp:0xee <_g_u16TargetPosition>
    4aae:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4ab2:	1102      	call	0x4cb8 <__mlx4_flash_start+0xcb8>
    4ab4:	7c06      	lod	X, #6
    4ab6:	2494      	or	X, #-108
    4ab8:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4aba:	e144      	add	Y, dp:0x44 <_g_DiagResponse+0x4>
    4abc:	0005      	jmp	0x4ac8 <__mlx4_flash_start+0xac8>
    4abe:	b142      	adc	A, dp:0x42 <_g_DiagResponse+0x2>
    4ac0:	e589      	or	Y, dp:0x89 <_g_NvramUser+0x33>
    4ac2:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x3>
    4ac4:	ed81      	cmp	Y, dp:0x81 <_g_NvramUser+0x2b>
    4ac6:	0003      	jmp	0x4ace <__mlx4_flash_start+0xace>
    4ac8:	623d      	lod	AL, [S-62]
    4aca:	6207      	lod	AL, [S-8]
    4acc:	255c      	or	X, dp:0x5c <_g_NvramUser+0x6>
    4ace:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x6>
    4ad0:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4ad2:	1107      	call	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad4:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    4ad6:	0105      	jmp	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    4ada:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x6>
    4adc:	1002      	call	0x4ae2 <__mlx4_flash_start+0xae2>
    4ade:	b681      	and	A, io:0x1 <__dp__+0x1>
    4ae0:	2495      	or	X, #-107
    4ae2:	b36c      	adc	A, ep:0x6c <_g_NvramUser+0x16>
    4ae4:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    4ae6:	0105      	jmp	0x4cf2 <__mlx4_flash_start+0xcf2>
    4ae8:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x38>
    4aea:	736c      	lod	A, ep:0x6c <_g_NvramUser+0x16>
    4aec:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    4aee:	b680      	and	A, io:0x0 <__dp__>
    4af0:	62d2      	lod	AL, [A++]
    4af2:	4d40      	mov	dp:0x40 <_g_DiagResponse>, YH
    4af4:	4954      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, AH
    4af6:	4d42      	mov	dp:0x42 <_g_DiagResponse+0x2>, YH
    4af8:	4956      	mov	dp:0x56 <_g_NvramUser>, AH
    4afa:	7c4a      	lod	X, #74
    4afc:	380e      	subc	X, #14
    4afe:	3806      	subc	X, #6
    4b00:	344c      	and	X, #76
    4b02:	484f      	macu	D, AL, [X]
    4b04:	5c01      	dec	S, #2
    4b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b08:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    4b0a:	380f      	subc	X, #15
    4b0c:	3806      	subc	X, #6
    4b0e:	300a      	adc	X, #10
    4b10:	39f0      	subc	X, dp:0xf0 <_g_u8MotorCtrlSpeed>
    4b12:	348f      	and	X, #-113
    4b14:	5c02      	dec	S, #3
    4b16:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4b18:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x1c>
    4b1a:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x4>
    4b1c:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4b1e:	4946      	mov	dp:0x46 <_g_DiagResponse+0x6>, AH
    4b20:	4948      	mov	dp:0x48 <_l_u8LinInFrameMsgID>, AH
    4b22:	b58f      	and	A, dp:0x8f <_g_NvramUser+0x39>
    4b24:	714b      	lod	A, dp:0x4b <_g_u16CorrectionRatio+0x1>
    4b26:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    4b28:	b343      	adc	A, ep:0x43 <_g_DiagResponse+0x3>
    4b2a:	b242      	adc	A, [S-67]
    4b2c:	b141      	adc	A, dp:0x41 <_g_DiagResponse+0x1>
    4b2e:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4b30:	4942      	mov	dp:0x42 <_g_DiagResponse+0x2>, AH
    4b32:	7342      	lod	A, ep:0x42 <_g_DiagResponse+0x2>
    4b34:	7241      	lod	A, [S-66]
    4b36:	7140      	lod	A, dp:0x40 <_g_DiagResponse>
    4b38:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4b3a:	4616      	mov	[S-23], YL
    4b3c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b3e:	8140      	add	AL, dp:0x40 <_g_DiagResponse>
    4b40:	8a41      	sub	AL, [S-66]
    4b42:	8b42      	sub	AL, ep:0x42 <_g_DiagResponse+0x2>
    4b44:	7140      	lod	A, dp:0x40 <_g_DiagResponse>
    4b46:	7241      	lod	A, [S-66]
    4b48:	7342      	lod	A, ep:0x42 <_g_DiagResponse+0x2>
    4b4a:	7150      	lod	A, dp:0x50 <__data_size>
    4b4c:	7251      	lod	A, [S-82]
    4b4e:	7352      	lod	A, ep:0x52 <_g_u16MotorCurrentMovAvgxN>
    4b50:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x6>
    4b52:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x36>
    4b54:	e784      	or	Y, ep:0x84 <_g_NvramUser+0x2e>
    4b56:	0101      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4b58:	25c3      	or	X, dp:0xc3 <__bss_dp_size+0x13>
    4b5a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x6>
    4b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    4b5e:	100b      	call	0x4b76 <__mlx4_flash_start+0xb76>
    4b60:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4b62:	b152      	adc	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    4b64:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4b66:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    4b68:	b151      	adc	A, dp:0x51 <__data_size+0x1>
    4b6a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b6c:	7151      	lod	A, dp:0x51 <__data_size+0x1>
    4b6e:	b150      	adc	A, dp:0x50 <__data_size>
    4b70:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b72:	7150      	lod	A, dp:0x50 <__data_size>
    4b74:	25ae      	or	X, dp:0xae <_g_NvramUser+0x58>
    4b76:	b150      	adc	A, dp:0x50 <__data_size>
    4b78:	e104      	add	Y, dp:0x4 <_LinMess>
    4b7a:	b151      	adc	A, dp:0x51 <__data_size+0x1>
    4b7c:	e905      	sub	Y, dp:0x5 <_LinMess+0x1>
    4b7e:	b152      	adc	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    4b80:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x2a>
    4b82:	1001      	call	0x4b86 <__mlx4_flash_start+0xb86>
    4b84:	2494      	or	X, #-108
    4b86:	4950      	mov	dp:0x50 <__data_size>, AH
    4b88:	4952      	mov	dp:0x52 <_g_u16MotorCurrentMovAvgxN>, AH
    4b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b8c:	61dd      	lod	AL, dp:0xdd <_ml_driver_mode+0x9>
    4b8e:	1001      	call	0x4b92 <__mlx4_flash_start+0xb92>
    4b90:	25ee      	or	X, dp:0xee <_g_u16TargetPosition>
    4b92:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4b94:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x4>
    4b96:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x1c>
    4b98:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4b9a:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x1c>
    4b9c:	e588      	or	Y, dp:0x88 <_g_NvramUser+0x32>
    4b9e:	0101      	jmp	0x4da2 <__mlx4_flash_start+0xda2>
    4ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4ba2:	b150      	adc	A, dp:0x50 <__data_size>
    4ba4:	4592      	mov	dp:0x92 <_g_NvramUser+0x3c>, YL
    4ba6:	716a      	lod	A, dp:0x6a <_g_NvramUser+0x14>
    4ba8:	b153      	adc	A, dp:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    4baa:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4bac:	7353      	lod	A, ep:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    4bae:	b351      	adc	A, ep:0x51 <__data_size+0x1>
    4bb0:	b252      	adc	A, [S-83]
    4bb2:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4bb4:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4bb6:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    4bb8:	7350      	lod	A, ep:0x50 <__data_size>
    4bba:	7251      	lod	A, [S-82]
    4bbc:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    4bbe:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bc0:	4616      	mov	[S-23], YL
    4bc2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4bc4:	e349      	add	Y, ep:0x49 <_l_u8LinInFrameMsgID+0x1>
    4bc6:	ea4a      	sub	Y, [S-75]
    4bc8:	e94b      	sub	Y, dp:0x4b <_g_u16CorrectionRatio+0x1>
    4bca:	1008      	call	0x4bdc <__mlx4_flash_start+0xbdc>
    4bcc:	8350      	add	AL, ep:0x50 <__data_size>
    4bce:	8a51      	sub	AL, [S-82]
    4bd0:	8952      	sub	AL, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    4bd2:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x6>
    4bd4:	ea47      	sub	Y, [S-72]
    4bd6:	e948      	sub	Y, dp:0x48 <_l_u8LinInFrameMsgID>
    4bd8:	0001      	jmp	0x4bdc <__mlx4_flash_start+0xbdc>
    4bda:	25f6      	or	X, dp:0xf6 <_g_u16ActuatorTgtPos>
    4bdc:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x6>
    4bde:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x36>
    4be0:	e784      	or	Y, ep:0x84 <_g_NvramUser+0x2e>
    4be2:	1103      	call	0x4dea <__mlx4_flash_start+0xdea>
    4be4:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    4be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4be8:	2495      	or	X, #-107
    4bea:	2494      	or	X, #-108
    4bec:	b73e      	and	A, ep:0x3e <__data_dp_end+0x6>
    4bee:	b252      	adc	A, [S-83]
    4bf0:	e680      	or	Y, io:0x0 <__dp__>
    4bf2:	b153      	adc	A, dp:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    4bf4:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x2a>
    4bf6:	1101      	call	0x4dfa <__mlx4_flash_start+0xdfa>
    4bf8:	260e      	or	X, [S-15]
    4bfa:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4bfc:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bfe:	7153      	lod	A, dp:0x53 <_g_u16MotorCurrentMovAvgxN+0x1>
    4c00:	4616      	mov	[S-23], YL
    4c02:	7252      	lod	A, [S-83]
    4c04:	b251      	adc	A, [S-82]
    4c06:	4616      	mov	[S-23], YL
    4c08:	7251      	lod	A, [S-82]
    4c0a:	b250      	adc	A, [S-81]
    4c0c:	4616      	mov	[S-23], YL
    4c0e:	7250      	lod	A, [S-81]
    4c10:	b26a      	adc	A, [S-107]
    4c12:	4616      	mov	[S-23], YL
    4c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    4c16:	726a      	lod	A, [S-107]
    4c18:	61fb      	lod	AL, dp:0xfb <_g_u8TorqueBoostRequest>
    4c1a:	25f7      	or	X, dp:0xf7 <_g_u16ActuatorTgtPos+0x1>
    4c1c:	b250      	adc	A, [S-81]
    4c1e:	b151      	adc	A, dp:0x51 <__data_size+0x1>
    4c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    4c22:	ed8c      	cmp	Y, dp:0x8c <_g_NvramUser+0x36>
    4c24:	1001      	call	0x4c28 <__mlx4_flash_start+0xc28>
    4c26:	261a      	or	X, [S-27]
    4c28:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4c2a:	4616      	mov	[S-23], YL
    4c2c:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x1c>
    4c2e:	61fb      	lod	AL, dp:0xfb <_g_u8TorqueBoostRequest>
    4c30:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x1c>
    4c32:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4c34:	7258      	lod	A, [S-89]
    4c36:	7159      	lod	A, dp:0x59 <_g_NvramUser+0x3>
    4c38:	b53e      	and	A, dp:0x3e <__data_dp_end+0x6>
    4c3a:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x6>
    4c3c:	623a      	lod	AL, [S-59]
    4c3e:	484f      	macu	D, AL, [X]
    4c40:	380d      	subc	X, #13
    4c42:	3806      	subc	X, #6
    4c44:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x6>
    4c46:	0108      	jmp	0x4e58 <__mlx4_flash_start+0xe58>
    4c48:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4c4a:	b34f      	adc	A, ep:0x4f <_g_u16CommutTimerPeriod+0x1>
    4c4c:	b24e      	adc	A, [S-79]
    4c4e:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4c50:	4616      	mov	[S-23], YL
    4c52:	734f      	lod	A, ep:0x4f <_g_u16CommutTimerPeriod+0x1>
    4c54:	724e      	lod	A, [S-79]
    4c56:	2622      	or	X, [S-35]
    4c58:	580e      	inc	S, #15
    4c5a:	0903      	clrb	io:0x00.3
    4c5c:	0809      	clrb	dp:0x01.1
    4c5e:	62e6      	lod	AL, Y
    4c60:	262c      	or	X, [S-45]
    4c62:	623a      	lod	AL, [S-59]
    4c64:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4c66:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x4>
    4c68:	6394      	lod	AL, ep:0x94 <_g_NvramUser+0x3e>
    4c6a:	b583      	and	A, dp:0x83 <_g_NvramUser+0x2d>
    4c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    4c6e:	2495      	or	X, #-107
    4c70:	b739      	and	A, ep:0x39 <__data_dp_end+0x1>
    4c72:	b638      	and	A, [S-57]
    4c74:	348a      	and	X, #-118
    4c76:	4c58      	dadjs	D, A
    4c78:	b342      	adc	A, ep:0x42 <_g_DiagResponse+0x2>
    4c7a:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x2a>
    4c7c:	0101      	jmp	0x4e80 <__mlx4_flash_start+0xe80>
    4c7e:	2647      	or	X, [S-72]
    4c80:	b340      	adc	A, ep:0x40 <_g_DiagResponse>
    4c82:	b241      	adc	A, [S-66]
    4c84:	e358      	add	Y, ep:0x58 <_g_NvramUser+0x2>
    4c86:	ea59      	sub	Y, [S-90]
    4c88:	1002      	call	0x4c8e <__mlx4_flash_start+0xc8e>
    4c8a:	7c04      	lod	X, #4
    4c8c:	2494      	or	X, #-108
    4c8e:	b34e      	adc	A, ep:0x4e <_g_u16CommutTimerPeriod>
    4c90:	b24f      	adc	A, [S-80]
    4c92:	484f      	macu	D, AL, [X]
    4c94:	834e      	add	AL, ep:0x4e <_g_u16CommutTimerPeriod>
    4c96:	8a4f      	sub	AL, [S-80]
    4c98:	1001      	call	0x4c9c <__mlx4_flash_start+0xc9c>
    4c9a:	2635      	or	X, [S-54]
    4c9c:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    4c9e:	724f      	lod	A, [S-80]
    4ca0:	b358      	adc	A, ep:0x58 <_g_NvramUser+0x2>
    4ca2:	b259      	adc	A, [S-90]
    4ca4:	4610      	mov	[S-17], YL
    4ca6:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4ca8:	8358      	add	AL, ep:0x58 <_g_NvramUser+0x2>
    4caa:	8a59      	sub	AL, [S-90]
    4cac:	0004      	jmp	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cae:	e34e      	add	Y, ep:0x4e <_g_u16CommutTimerPeriod>
    4cb0:	ea4f      	sub	Y, [S-80]
    4cb2:	1001      	call	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cb4:	2635      	or	X, [S-54]
    4cb6:	b358      	adc	A, ep:0x58 <_g_NvramUser+0x2>
    4cb8:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    4cba:	b259      	adc	A, [S-90]
    4cbc:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4cbe:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4cc0:	7130      	lod	A, dp:0x30 <_l_u16VTIdx>
    4cc2:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    4cc4:	7331      	lod	A, ep:0x31 <_l_u16VTIdx+0x1>
    4cc6:	7232      	lod	A, [S-51]
    4cc8:	7133      	lod	A, dp:0x33 <_g_u8MotorStopDelay+0x1>
    4cca:	e355      	add	Y, ep:0x55 <_g_u16MotorCurrentLPFx64+0x1>
    4ccc:	ea56      	sub	Y, [S-87]
    4cce:	e957      	sub	Y, dp:0x57 <_g_NvramUser+0x1>
    4cd0:	1002      	call	0x4cd6 <__mlx4_flash_start+0xcd6>
    4cd2:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2f>
    4cd4:	2636      	or	X, [S-55]
    4cd6:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x6>
    4cd8:	a588      	or	A, dp:0x88 <_g_NvramUser+0x32>
    4cda:	1102      	call	0x4ee0 <__mlx4_flash_start+0xee0>
    4cdc:	a584      	or	A, dp:0x84 <_g_NvramUser+0x2e>
    4cde:	1101      	call	0x4ee2 <__mlx4_flash_start+0xee2>
    4ce0:	26ad      	or	X, io:0x2d <_l_u8ActDirection>
    4ce2:	b359      	adc	A, ep:0x59 <_g_NvramUser+0x3>
    4ce4:	b158      	adc	A, dp:0x58 <_g_NvramUser+0x2>
    4ce6:	4592      	mov	dp:0x92 <_g_NvramUser+0x3c>, YL
    4ce8:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4cea:	b680      	and	A, io:0x0 <__dp__>
    4cec:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cee:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4cf0:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cf2:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    4cf4:	b359      	adc	A, ep:0x59 <_g_NvramUser+0x3>
    4cf6:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4cf8:	834e      	add	AL, ep:0x4e <_g_u16CommutTimerPeriod>
    4cfa:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cfc:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    4cfe:	724f      	lod	A, [S-80]
    4d00:	b358      	adc	A, ep:0x58 <_g_NvramUser+0x2>
    4d02:	b259      	adc	A, [S-90]
    4d04:	b53e      	and	A, dp:0x3e <__data_dp_end+0x6>
    4d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d08:	0102      	jmp	0x4f0e <__mlx4_flash_start+0xf0e>
    4d0a:	0005      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d0c:	269c      	or	X, io:0x1c <_g_i16MotorVoltage>
    4d0e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d10:	ea05      	sub	Y, [S-6]
    4d12:	0001      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d14:	269c      	or	X, io:0x1c <_g_i16MotorVoltage>
    4d16:	834e      	add	AL, ep:0x4e <_g_u16CommutTimerPeriod>
    4d18:	8a4f      	sub	AL, [S-80]
    4d1a:	e788      	or	Y, ep:0x88 <_g_NvramUser+0x32>
    4d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    4d1e:	0003      	jmp	0x4d26 <__mlx4_flash_start+0xd26>
    4d20:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    4d22:	4610      	mov	[S-17], YL
    4d24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d28:	0102      	jmp	0x4f2e <__mlx4_flash_start+0xf2e>
    4d2a:	0004      	jmp	0x4d34 <__mlx4_flash_start+0xd34>
    4d2c:	26ad      	or	X, io:0x2d <_l_u8ActDirection>
    4d2e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d30:	ea05      	sub	Y, [S-6]
    4d32:	100d      	call	0x4d4e <__mlx4_flash_start+0xd4e>
    4d34:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4d36:	2636      	or	X, [S-55]
    4d38:	c34e      	add	AH, ep:0x4e <_g_u16CommutTimerPeriod>
    4d3a:	ca4f      	sub	AH, [S-80]
    4d3c:	e783      	or	Y, ep:0x83 <_g_NvramUser+0x2d>
    4d3e:	ee86      	cmp	Y, io:0x6 <_LinMess2>
    4d40:	1003      	call	0x4d48 <__mlx4_flash_start+0xd48>
    4d42:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4d44:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    4d46:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d4a:	0102      	jmp	0x4f50 <__mlx4_flash_start+0xf50>
    4d4c:	1004      	call	0x4d56 <__mlx4_flash_start+0xd56>
    4d4e:	26ad      	or	X, io:0x2d <_l_u8ActDirection>
    4d50:	e304      	add	Y, ep:0x4 <_LinMess>
    4d52:	ea05      	sub	Y, [S-6]
    4d54:	0002      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4d56:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4d58:	2636      	or	X, [S-55]
    4d5a:	4d58      	mov	dp:0x58 <_g_NvramUser+0x2>, YH
    4d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    4d5e:	b73e      	and	A, ep:0x3e <__data_dp_end+0x6>
    4d60:	7306      	lod	A, ep:0x6 <_LinMess2>
    4d62:	4c02 7ccb 	add	D, #2097315019
    4d66:	7d02 
    4d68:	b25e      	adc	A, [S-95]
    4d6a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4d6c:	725e      	lod	A, [S-95]
    4d6e:	344a      	and	X, #74
    4d70:	3906      	subc	X, dp:0x6 <_LinMess2>
    4d72:	b681      	and	A, io:0x1 <__dp__+0x1>
    4d74:	724e      	lod	A, [S-79]
    4d76:	7245      	lod	A, [S-70]
    4d78:	b239      	adc	A, [S-58]
    4d7a:	7271      	lod	A, [S-114]
    4d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    4d7e:	7239      	lod	A, [S-58]
    4d80:	5c00      	dec	S
    4d82:	4d1c      	mov	dp:0x1c <_g_i16MotorVoltage>, YH
    4d84:	4962      	mov	dp:0x62 <_g_NvramUser+0xc>, AH
    4d86:	4d2c      	mov	dp:0x2c <_g_u8BufferOutID>, YH
    4d88:	492e      	mov	dp:0x2e <_g_u8SAE_SendErrorState>, AH
    4d8a:	b680      	and	A, io:0x0 <__dp__>
    4d8c:	720d      	lod	A, [S-14]
    4d8e:	3807      	subc	X, #7
    4d90:	380e      	subc	X, #14
    4d92:	3430      	and	X, #48
    4d94:	580e      	inc	S, #15
    4d96:	0803      	clrb	dp:0x00.3
    4d98:	0907      	clrb	io:0x00.7
    4d9a:	62e6      	lod	AL, Y
    4d9c:	26ca      	or	X, [--PC]
    4d9e:	623a      	lod	AL, [S-59]
    4da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4da2:	0101      	jmp	0x4fa6 <__mlx4_flash_start+0xfa6>
    4da4:	26ca      	or	X, [--PC]
    4da6:	26f1      	or	X, [Y+1]
    4da8:	623a      	lod	AL, [S-59]
    4daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    4dac:	1101      	call	0x4fb0 <__mlx4_flash_start+0xfb0>
    4dae:	26f1      	or	X, [Y+1]
    4db0:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    4db2:	1105      	call	0x4fbe <__mlx4_flash_start+0xfbe>
    4db4:	626f      	lod	AL, [S-112]
    4db6:	0001      	jmp	0x4dba <__mlx4_flash_start+0xdba>
    4db8:	26ca      	or	X, [--PC]
    4dba:	b586      	and	A, dp:0x86 <_g_NvramUser+0x30>
    4dbc:	29d4      	sub	X, dp:0xd4 <_ml_driver_mode>
    4dbe:	b239      	adc	A, [S-58]
    4dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4dc2:	110e      	call	0x4fe0 <__mlx4_flash_start+0xfe0>
    4dc4:	b680      	and	A, io:0x0 <__dp__>
    4dc6:	e24e      	add	Y, [S-79]
    4dc8:	1108      	call	0x4fda <__mlx4_flash_start+0xfda>
    4dca:	6259      	lod	AL, [S-90]
    4dcc:	6266      	lod	AL, [S-103]
    4dce:	0007      	jmp	0x4dde <__mlx4_flash_start+0xdde>
    4dd0:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2f>
    4dd2:	b271      	adc	A, [S-114]
    4dd4:	7239      	lod	A, [S-58]
    4dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4dd8:	2495      	or	X, #-107
    4dda:	724e      	lod	A, [S-79]
    4ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    4dde:	26ca      	or	X, [--PC]
    4de0:	26ca      	or	X, [--PC]
    4de2:	b33a      	adc	A, ep:0x3a <__data_dp_end+0x2>
    4de4:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x2c>
    4de6:	733a      	lod	A, ep:0x3a <__data_dp_end+0x2>
    4de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    4dea:	7c4c      	lod	X, #76
    4dec:	3805      	subc	X, #5
    4dee:	3808      	subc	X, #8
    4df0:	3906      	subc	X, dp:0x6 <_LinMess2>
    4df2:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4df4:	4940      	mov	dp:0x40 <_g_DiagResponse>, AH
    4df6:	4942      	mov	dp:0x42 <_g_DiagResponse+0x2>, AH
    4df8:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    4dfa:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    4dfc:	b589      	and	A, dp:0x89 <_g_NvramUser+0x33>
    4dfe:	580a      	inc	S, #11
    4e00:	0904      	clrb	io:0x00.4
    4e02:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x1c>
    4e04:	62e6      	lod	AL, Y
    4e06:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x1c>
    4e08:	26ff      	or	X, [X+7]
    4e0a:	623a      	lod	AL, [S-59]
    4e0c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4e0e:	4008      	jmp	fp0:0x40
    4e10:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x6>
    4e12:	a58f      	or	A, dp:0x8f <_g_NvramUser+0x39>
    4e14:	0101      	jmp	0x5018 <__mlx4_flash_start+0x1018>
    4e16:	2726      	or	X, ep:0x26 <_g_u8StallOcc>
    4e18:	1409      	call	0x462c <__mlx4_flash_start+0x62c>
    4e1a:	3807      	subc	X, #7
    4e1c:	380e      	subc	X, #14
    4e1e:	3430      	and	X, #48
    4e20:	27bd      	or	X, ep:0xbd <__bss_dp_size+0xd>
    4e22:	b239      	adc	A, [S-58]
    4e24:	7238      	lod	A, [S-57]
    4e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    4e28:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4e2a:	24a3      	or	X, #-93
    4e2c:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    4e2e:	b239      	adc	A, [S-58]
    4e30:	7238      	lod	A, [S-57]
    4e32:	4040      	jmp	fp2:0x00
    4e34:	624a      	lod	AL, [S-75]
    4e36:	1504      	call	0x4840 <__mlx4_flash_start+0x840>
    4e38:	b23b      	adc	A, [S-60]
    4e3a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4e3c:	723b      	lod	A, [S-60]
    4e3e:	24a3      	or	X, #-93
    4e40:	b23b      	adc	A, [S-60]
    4e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4e44:	723b      	lod	A, [S-60]
    4e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    4e48:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4e4a:	24a3      	or	X, #-93
    4e4c:	4060      	jmp	fp3:0x00
    4e4e:	624a      	lod	AL, [S-75]
    4e50:	e589      	or	Y, dp:0x89 <_g_NvramUser+0x33>
    4e52:	1109      	call	0x5066 <__mlx4_flash_start+0x1066>
    4e54:	b339      	adc	A, ep:0x39 <__data_dp_end+0x1>
    4e56:	e78f      	or	Y, ep:0x8f <_g_NvramUser+0x39>
    4e58:	010a      	jmp	0x506e <__mlx4_flash_start+0x106e>
    4e5a:	1409      	call	0x466e <__mlx4_flash_start+0x66e>
    4e5c:	b686      	and	A, io:0x6 <_LinMess2>
    4e5e:	7338      	lod	A, ep:0x38 <__data_dp_end>
    4e60:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4e62:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4e64:	24a3      	or	X, #-93
    4e66:	4060      	jmp	fp3:0x00
    4e68:	622e      	lod	AL, [S-47]
    4e6a:	0501      	jmp	0x486e <__mlx4_flash_start+0x86e>
    4e6c:	2739      	or	X, ep:0x39 <__data_dp_end+0x1>
    4e6e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4e70:	26ff      	or	X, [X+7]
    4e72:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x2d>
    4e74:	1001      	call	0x4e78 <__mlx4_flash_start+0xe78>
    4e76:	274c      	or	X, ep:0x4c <_g_u16MicroStepIdx>
    4e78:	b791      	and	A, ep:0x91 <_g_NvramUser+0x3b>
    4e7a:	d78f      	and	AH, ep:0x8f <_g_NvramUser+0x39>
    4e7c:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4e7e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x31>
    4e80:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    4e82:	4060      	jmp	fp3:0x00
    4e84:	4d62      	mov	dp:0x62 <_g_NvramUser+0xc>, YH
    4e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    4e88:	b63d      	and	A, [S-62]
    4e8a:	721e      	lod	A, [S-31]
    4e8c:	4962      	mov	dp:0x62 <_g_NvramUser+0xc>, AH
    4e8e:	4d2e      	mov	dp:0x2e <_g_u8SAE_SendErrorState>, YH
    4e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    4e92:	b63d      	and	A, [S-62]
    4e94:	721f      	lod	A, [S-32]
    4e96:	492e      	mov	dp:0x2e <_g_u8SAE_SendErrorState>, AH
    4e98:	7492      	lod	PC, #-110
    4e9a:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4e9c:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    4e9e:	1101      	call	0x50a2 <__mlx4_flash_start+0x10a2>
    4ea0:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4ea2:	d245      	adc	AH, [S-70]
    4ea4:	7245      	lod	A, [S-70]
    4ea6:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    4ea8:	6c01      	lod	YH, #1
    4eaa:	2768      	or	X, ep:0x68 <_g_NvramUser+0x12>
    4eac:	277b      	or	X, ep:0x7b <_g_NvramUser+0x25>
    4eae:	278a      	or	X, ep:0x8a <_g_NvramUser+0x34>
    4eb0:	26ff      	or	X, [X+7]
    4eb2:	26ff      	or	X, [X+7]
    4eb4:	26ff      	or	X, [X+7]
    4eb6:	26ff      	or	X, [X+7]
    4eb8:	275e      	or	X, ep:0x5e <_g_NvramUser+0x8>
    4eba:	26ff      	or	X, [X+7]
    4ebc:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    4ebe:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    4ec0:	0106      	jmp	0x50ce <__mlx4_flash_start+0x10ce>
    4ec2:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    4ec4:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    4ec6:	b271      	adc	A, [S-114]
    4ec8:	7238      	lod	A, [S-57]
    4eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    4ecc:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4ece:	26ff      	or	X, [X+7]
    4ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    4ed4:	bf82      	xor	A, ep:0x82 <_g_NvramUser+0x2c>
    4ed6:	d345      	adc	AH, ep:0x45 <_g_DiagResponse+0x5>
    4ed8:	b209      	adc	A, [S-10]
    4eda:	720f      	lod	A, [S-16]
    4edc:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4ede:	d792      	and	AH, ep:0x92 <_g_NvramUser+0x3c>
    4ee0:	1101      	call	0x50e4 <__mlx4_flash_start+0x10e4>
    4ee2:	26ff      	or	X, [X+7]
    4ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    4ee6:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    4ee8:	b638      	and	A, [S-57]
    4eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    4eec:	1103      	call	0x50f4 <__mlx4_flash_start+0x10f4>
    4eee:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    4ef0:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2e>
    4ef2:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    4ef4:	24a3      	or	X, #-93
    4ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    4ef8:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4efa:	0102      	jmp	0x5100 <__mlx4_flash_start+0x1100>
    4efc:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4efe:	26ff      	or	X, [X+7]
    4f00:	b360      	adc	A, ep:0x60 <_g_NvramUser+0xa>
    4f02:	b161      	adc	A, dp:0x61 <_g_NvramUser+0xb>
    4f04:	f580      	and	Y, dp:0x80 <_g_NvramUser+0x2a>
    4f06:	b6a7      	and	A, io:0x27 <_g_u8ChipResetOcc>
    4f08:	7260      	lod	A, [S-97]
    4f0a:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    4f0c:	b6a7      	and	A, io:0x27 <_g_u8ChipResetOcc>
    4f0e:	7261      	lod	A, [S-98]
    4f10:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    4f12:	26ff      	or	X, [X+7]
    4f14:	b209      	adc	A, [S-10]
    4f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4f18:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4f1a:	1102      	call	0x5120 <__mlx4_flash_start+0x1120>
    4f1c:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x2b>
    4f1e:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    4f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4f22:	4610      	mov	[S-17], YL
    4f24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f26:	4610      	mov	[S-17], YL
    4f28:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f2a:	720d      	lod	A, [S-14]
    4f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    4f30:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4f32:	0104      	jmp	0x513c <__mlx4_flash_start+0x113c>
    4f34:	b31f      	adc	A, ep:0x1f <__ramfunc_size+0x1>
    4f36:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4f38:	1105      	call	0x5144 <__mlx4_flash_start+0x1144>
    4f3a:	8788      	or	AL, ep:0x88 <_g_NvramUser+0x32>
    4f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f3e:	b680      	and	A, io:0x0 <__dp__>
    4f40:	720d      	lod	A, [S-14]
    4f42:	27b5      	or	X, ep:0xb5 <__bss_dp_size+0x5>
    4f44:	3bea      	subc	X, ep:0xea <_g_u8MotorHoldingCurrEna>
    4f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    4f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f4a:	4050      	jmp	fp2:0x80
    4f4c:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    4f4e:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    4f50:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x32>
    4f52:	b6a7      	and	A, io:0x27 <_g_u8ChipResetOcc>
    4f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    4f56:	0105      	jmp	0x5162 <__mlx4_flash_start+0x1162>
    4f58:	b20d      	adc	A, [S-14]
    4f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4f5c:	720d      	lod	A, [S-14]
    4f5e:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4f60:	26ff      	or	X, [X+7]
    4f62:	720d      	lod	A, [S-14]
    4f64:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    4f66:	b7a7      	and	A, ep:0xa7 <_g_NvramUser+0x51>
    4f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f6c:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    4f6e:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    4f70:	3beb      	subc	X, ep:0xeb <_g_u8MotorHoldingCurrEna+0x1>
    4f72:	7360      	lod	A, ep:0x60 <_g_NvramUser+0xa>
    4f74:	7161      	lod	A, dp:0x61 <_g_NvramUser+0xb>
    4f76:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    4f78:	26ff      	or	X, [X+7]
    4f7a:	1501      	call	0x497e <__mlx4_flash_start+0x97e>
    4f7c:	2800      	sub	X, #0
    4f7e:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x6>
    4f80:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    4f82:	1109      	call	0x5196 <__mlx4_flash_start+0x1196>
    4f84:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2e>
    4f86:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x6>
    4f88:	4804      	mulu	D, A, [Y++]
    4f8a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x6>
    4f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    4f8e:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4f90:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    4f92:	0101      	jmp	0x5196 <__mlx4_flash_start+0x1196>
    4f94:	24a3      	or	X, #-93
    4f96:	5cc2      	neg	A
    4f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f9a:	a588      	or	A, dp:0x88 <_g_NvramUser+0x32>
    4f9c:	0103      	jmp	0x51a4 <__mlx4_flash_start+0x11a4>
    4f9e:	7ca8      	lod	X, #-88
    4fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    4fa2:	24a3      	or	X, #-93
    4fa4:	b261      	adc	A, [S-98]
    4fa6:	4600      	mov	[S-1], YL
    4fa8:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4faa:	0104      	jmp	0x51b4 <__mlx4_flash_start+0x11b4>
    4fac:	0001      	jmp	0x4fb0 <__mlx4_flash_start+0xfb0>
    4fae:	24a3      	or	X, #-93
    4fb0:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    4fb2:	27e7      	or	X, ep:0xe7 <_ml_driver_mode+0x13>
    4fb4:	5c00      	dec	S
    4fb6:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x9>
    4fb8:	a783      	or	A, ep:0x83 <_g_NvramUser+0x2d>
    4fba:	1103      	call	0x51c2 <__mlx4_flash_start+0x11c2>
    4fbc:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4fbe:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x2d>
    4fc0:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    4fc2:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    4fc4:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    4fc6:	1102      	call	0x51cc <__mlx4_flash_start+0x11cc>
    4fc8:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2e>
    4fca:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x4>
    4fcc:	b781      	and	A, ep:0x81 <_g_NvramUser+0x2b>
    4fce:	b260      	adc	A, [S-97]
    4fd0:	725b      	lod	A, [S-92]
    4fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4fd4:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fd6:	724c      	lod	A, [S-77]
    4fd8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fda:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4fdc:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fde:	b556      	and	A, dp:0x56 <_g_NvramUser>
    4fe0:	7137      	lod	A, dp:0x37 <_l_u8StallCountA>
    4fe2:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fe4:	b556      	and	A, dp:0x56 <_g_NvramUser>
    4fe6:	7136      	lod	A, dp:0x36 <_l_u8StallCountO>
    4fe8:	b25b      	adc	A, [S-92]
    4fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    4fec:	4788      	mov	ep:0x88 <_g_NvramUser+0x32>, YL
    4fee:	f693      	and	Y, io:0x13 <__dp_noinit_size+0x3>
    4ff0:	725b      	lod	A, [S-92]
    4ff2:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4ff4:	0002      	jmp	0x4ffa <__mlx4_flash_start+0xffa>
    4ff6:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    4ff8:	27fe      	or	X, ep:0xfe <_g_u16Mlx4StateCheckCounter>
    4ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    4ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4ffe:	281f      	sub	X, #31
    5000:	b239      	adc	A, [S-58]
    5002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    5004:	0101      	jmp	0x5208 <__mlx4_flash_start+0x1208>
    5006:	2814      	sub	X, #20
    5008:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    500a:	a782      	or	A, ep:0x82 <_g_NvramUser+0x2c>
    500c:	0103      	jmp	0x5214 <__mlx4_flash_start+0x1214>
    500e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    5010:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    5012:	24a3      	or	X, #-93
    5014:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    5016:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    5018:	0107      	jmp	0x5228 <__mlx4_flash_start+0x1228>
    501a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    501c:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x2a>
    501e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    5020:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x2a>
    5022:	1102      	call	0x5228 <__mlx4_flash_start+0x1228>
    5024:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x2c>
    5026:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    5028:	e24c      	add	Y, [S-77]
    502a:	0109      	jmp	0x523e <__mlx4_flash_start+0x123e>
    502c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    502e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x31>
    5030:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    5032:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    5034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    5036:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0x12>
    5038:	8681      	or	AL, io:0x1 <__dp__+0x1>
    503a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    503c:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0x12>
    503e:	b139      	adc	A, dp:0x39 <__data_dp_end+0x1>
    5040:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    5042:	7139      	lod	A, dp:0x39 <__data_dp_end+0x1>
    5044:	1106      	call	0x5252 <__mlx4_flash_start+0x1252>
    5046:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    5048:	4930      	mov	dp:0x30 <_l_u16VTIdx>, AH
    504a:	b35b      	adc	A, ep:0x5b <_g_NvramUser+0x5>
    504c:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    504e:	1107      	call	0x525e <__mlx4_flash_start+0x125e>
    5050:	2849      	sub	X, #73
    5052:	b208      	adc	A, [S-9]
    5054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    5056:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    5058:	e14c      	add	Y, dp:0x4c <_g_u16MicroStepIdx>
    505a:	0105      	jmp	0x5266 <__mlx4_flash_start+0x1266>
    505c:	6233      	lod	AL, [S-52]
    505e:	7cce      	lod	X, #-50
    5060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    5062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5064:	26ca      	or	X, [--PC]
    5066:	820a      	add	AL, [S-11]
    5068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    506a:	8681      	or	AL, io:0x1 <__dp__+0x1>
    506c:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x2a>
    506e:	0103      	jmp	0x5276 <__mlx4_flash_start+0x1276>
    5070:	b684      	and	A, io:0x4 <_LinMess>
    5072:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    5074:	24a3      	or	X, #-93
    5076:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    5078:	a782      	or	A, ep:0x82 <_g_NvramUser+0x2c>
    507a:	0105      	jmp	0x5286 <__mlx4_flash_start+0x1286>
    507c:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    507e:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x37>
    5080:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    5082:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    5084:	29d4      	sub	X, dp:0xd4 <_ml_driver_mode>
    5086:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x8>
    5088:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x2c>
    508a:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x8>
    508c:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    508e:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x4>
    5090:	24a3      	or	X, #-93
    5092:	b58f      	and	A, dp:0x8f <_g_NvramUser+0x39>
    5094:	7139      	lod	A, dp:0x39 <__data_dp_end+0x1>
    5096:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    5098:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    509a:	4940      	mov	dp:0x40 <_g_DiagResponse>, AH
    509c:	4942      	mov	dp:0x42 <_g_DiagResponse+0x2>, AH
    509e:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    50a0:	b738      	and	A, ep:0x38 <__data_dp_end>
    50a2:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    50a4:	110b      	call	0x52bc <__mlx4_flash_start+0x12bc>
    50a6:	b239      	adc	A, [S-58]
    50a8:	7238      	lod	A, [S-57]
    50aa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    50ac:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    50ae:	b23b      	adc	A, [S-60]
    50b0:	f684      	and	Y, io:0x4 <_LinMess>
    50b2:	723b      	lod	A, [S-60]
    50b4:	b25e      	adc	A, [S-95]
    50b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    50b8:	725e      	lod	A, [S-95]
    50ba:	24a1      	or	X, #-95
    50bc:	3805      	subc	X, #5
    50be:	3808      	subc	X, #8
    50c0:	346b      	and	X, #107
    50c2:	34b0      	and	X, #-80
    50c4:	4930      	mov	dp:0x30 <_l_u16VTIdx>, AH
    50c6:	b34c      	adc	A, ep:0x4c <_g_u16MicroStepIdx>
    50c8:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x2b>
    50ca:	4796      	mov	ep:0x96 <_g_NvramUser+0x40>, YL
    50cc:	b65b      	and	A, [S-92]
    50ce:	7236      	lod	A, [S-55]
    50d0:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    50d2:	b65b      	and	A, [S-92]
    50d4:	7237      	lod	A, [S-56]
    50d6:	b364      	adc	A, ep:0x64 <_g_NvramUser+0xe>
    50d8:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2e>
    50da:	0101      	jmp	0x52de <__mlx4_flash_start+0x12de>
    50dc:	b581      	and	A, dp:0x81 <_g_NvramUser+0x2b>
    50de:	858a      	or	AL, dp:0x8a <_g_NvramUser+0x34>
    50e0:	715d      	lod	A, dp:0x5d <_g_NvramUser+0x7>
    50e2:	b164      	adc	A, dp:0x64 <_g_NvramUser+0xe>
    50e4:	bd83      	xor	A, dp:0x83 <_g_NvramUser+0x2d>
    50e6:	8582      	or	AL, dp:0x82 <_g_NvramUser+0x2c>
    50e8:	714d      	lod	A, dp:0x4d <_g_u16MicroStepIdx+0x1>
    50ea:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    50ec:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    50ee:	5c00      	dec	S
    50f0:	0101      	jmp	0x52f4 <__mlx4_flash_start+0x12f4>
    50f2:	5c02      	dec	S, #3
    50f4:	580e      	inc	S, #15
    50f6:	0809      	clrb	dp:0x01.1
    50f8:	090c      	clrb	io:0x01.4
    50fa:	62e6      	lod	AL, Y
    50fc:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x19>
    50fe:	a588      	or	A, dp:0x88 <_g_NvramUser+0x32>
    5100:	1103      	call	0x5308 <__mlx4_flash_start+0x1308>
    5102:	a584      	or	A, dp:0x84 <_g_NvramUser+0x2e>
    5104:	0105      	jmp	0x5310 <__mlx4_flash_start+0x1310>
    5106:	24a3      	or	X, #-93
    5108:	2892      	sub	X, #-110
    510a:	623a      	lod	AL, [S-59]
    510c:	a688      	or	A, io:0x8 <__bist_stat_size>
    510e:	0106      	jmp	0x531c <__mlx4_flash_start+0x131c>
    5110:	287a      	sub	X, #122
    5112:	623a      	lod	AL, [S-59]
    5114:	a788      	or	A, ep:0x88 <_g_NvramUser+0x32>
    5116:	1102      	call	0x531c <__mlx4_flash_start+0x131c>
    5118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    511a:	1101      	call	0x531e <__mlx4_flash_start+0x131e>
    511c:	2853      	sub	X, #83
    511e:	a781      	or	A, ep:0x81 <_g_NvramUser+0x2b>
    5120:	1107      	call	0x5330 <__mlx4_flash_start+0x1330>
    5122:	287a      	sub	X, #122
    5124:	b14d      	adc	A, dp:0x4d <_g_u16MicroStepIdx+0x1>
    5126:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x2a>
    5128:	1101      	call	0x532c <__mlx4_flash_start+0x132c>
    512a:	28a6      	sub	X, #-90
    512c:	5cc2      	neg	A
    512e:	287a      	sub	X, #122
    5130:	6241      	lod	AL, [S-66]
    5132:	0001      	jmp	0x5136 <__mlx4_flash_start+0x1136>
    5134:	2711      	or	X, ep:0x11 <__dp_noinit_size+0x1>
    5136:	b14d      	adc	A, dp:0x4d <_g_u16MicroStepIdx+0x1>
    5138:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    513a:	1101      	call	0x533e <__mlx4_flash_start+0x133e>
    513c:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x6>
    513e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    5140:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x2a>
    5142:	714d      	lod	A, dp:0x4d <_g_u16MicroStepIdx+0x1>
    5144:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x2a>
    5146:	1101      	call	0x534a <__mlx4_flash_start+0x134a>
    5148:	0501      	jmp	0x4b4c <__mlx4_flash_start+0xb4c>
    514a:	287a      	sub	X, #122
    514c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x19>
    514e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x31>
    5150:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x19>
    5152:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    5154:	3468      	and	X, #104
    5156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5158:	b203      	adc	A, [S-4]
    515a:	4610      	mov	[S-17], YL
    515c:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    515e:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    5160:	724f      	lod	A, [S-80]
    5162:	4c4f      	dadju	D, [X]
    5164:	6217      	lod	AL, [S-24]
    5166:	6233      	lod	AL, [S-52]
    5168:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    516a:	7170      	lod	A, dp:0x70 <_g_NvramUser+0x1a>
    516c:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    516e:	484f      	macu	D, AL, [X]
    5170:	380a      	subc	X, #10
    5172:	3420      	and	X, #32
    5174:	3965      	subc	X, dp:0x65 <_g_NvramUser+0xf>
    5176:	3501      	and	X, dp:0x1 <__dp__+0x1>
    5178:	37a4      	and	X, ep:0xa4 <_g_NvramUser+0x4e>
    517a:	346b      	and	X, #107
    517c:	5806      	inc	S, #7
    517e:	090e      	clrb	io:0x01.6
    5180:	623a      	lod	AL, [S-59]
    5182:	484f      	macu	D, AL, [X]
    5184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5186:	b203      	adc	A, [S-4]
    5188:	4610      	mov	[S-17], YL
    518a:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    518c:	834e      	add	AL, ep:0x4e <_g_u16CommutTimerPeriod>
    518e:	8a4f      	sub	AL, [S-80]
    5190:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    5192:	724f      	lod	A, [S-80]
    5194:	4c4f      	dadju	D, [X]
    5196:	3409      	and	X, #9
    5198:	3808      	subc	X, #8
    519a:	28eb      	sub	X, #-21
    519c:	623a      	lod	AL, [S-59]
    519e:	a688      	or	A, io:0x8 <__bist_stat_size>
    51a0:	1101      	call	0x53a4 <__mlx4_flash_start+0x13a4>
    51a2:	28fb      	sub	X, #-5
    51a4:	351b      	and	X, dp:0x1b <_g_u8StallTypeComm+0x1>
    51a6:	b582      	and	A, dp:0x82 <_g_NvramUser+0x2c>
    51a8:	b682      	and	A, io:0x2 <_LinCmnd>
    51aa:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    51ac:	b681      	and	A, io:0x1 <__dp__+0x1>
    51ae:	7201      	lod	A, [S-2]
    51b0:	2487      	or	X, #-121
    51b2:	6217      	lod	AL, [S-24]
    51b4:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    51b6:	0007      	jmp	0x51c6 <__mlx4_flash_start+0x11c6>
    51b8:	1107      	call	0x53c8 <__mlx4_flash_start+0x13c8>
    51ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    51bc:	d78f      	and	AH, ep:0x8f <_g_NvramUser+0x39>
    51be:	7234      	lod	A, [S-53]
    51c0:	7335      	lod	A, ep:0x35 <_g_u16StartupDelay+0x1>
    51c2:	6228      	lod	AL, [S-41]
    51c4:	28e5      	sub	X, #-27
    51c6:	2906      	sub	X, dp:0x6 <_LinMess2>
    51c8:	6233      	lod	AL, [S-52]
    51ca:	4040      	jmp	fp2:0x00
    51cc:	3501      	and	X, dp:0x1 <__dp__+0x1>
    51ce:	580a      	inc	S, #11
    51d0:	0902      	clrb	io:0x00.2
    51d2:	62e6      	lod	AL, Y
    51d4:	28e7      	sub	X, #-25
    51d6:	623a      	lod	AL, [S-59]
    51d8:	a684      	or	A, io:0x4 <_LinMess>
    51da:	110d      	call	0x53f6 <__mlx4_flash_start+0x13f6>
    51dc:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x1a>
    51de:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e0:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e2:	624a      	lod	AL, [S-75]
    51e4:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x6>
    51e6:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    51e8:	e15d      	add	Y, dp:0x5d <_g_NvramUser+0x7>
    51ea:	0109      	jmp	0x53fe <__mlx4_flash_start+0x13fe>
    51ec:	622e      	lod	AL, [S-47]
    51ee:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x1a>
    51f0:	4784      	mov	ep:0x84 <_g_NvramUser+0x2e>, YL
    51f2:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x1a>
    51f4:	28e6      	sub	X, #-26
    51f6:	4040      	jmp	fp2:0x00
    51f8:	624a      	lod	AL, [S-75]
    51fa:	351b      	and	X, dp:0x1b <_g_u8StallTypeComm+0x1>
    51fc:	2853      	sub	X, #83
    51fe:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x1a>
    5200:	4040      	jmp	fp2:0x00
    5202:	4784      	mov	ep:0x84 <_g_NvramUser+0x2e>, YL
    5204:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x1a>
    5206:	7ccf      	lod	X, #-49
    5208:	7d34      	lod	X, dp:0x34 <_g_u16StartupDelay>
    520a:	28d9      	sub	X, #-39
    520c:	351b      	and	X, dp:0x1b <_g_u8StallTypeComm+0x1>
    520e:	580a      	inc	S, #11
    5210:	0902      	clrb	io:0x00.2
    5212:	62e6      	lod	AL, Y
    5214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    5216:	623a      	lod	AL, [S-59]
    5218:	a684      	or	A, io:0x4 <_LinMess>
    521a:	0101      	jmp	0x541e <__mlx4_flash_start+0x141e>
    521c:	28fb      	sub	X, #-5
    521e:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x9>
    5220:	a583      	or	A, dp:0x83 <_g_NvramUser+0x2d>
    5222:	1103      	call	0x542a <__mlx4_flash_start+0x142a>
    5224:	b100      	adc	A, dp:0x0 <__dp__>
    5226:	a581      	or	A, dp:0x81 <_g_NvramUser+0x2b>
    5228:	0102      	jmp	0x542e <__mlx4_flash_start+0x142e>
    522a:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2f>
    522c:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x4>
    522e:	24a3      	or	X, #-93
    5230:	3807      	subc	X, #7
    5232:	3809      	subc	X, #9
    5234:	3468      	and	X, #104
    5236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5238:	b638      	and	A, [S-57]
    523a:	a688      	or	A, io:0x8 <__bist_stat_size>
    523c:	0101      	jmp	0x5440 <__mlx4_flash_start+0x1440>
    523e:	2494      	or	X, #-108
    5240:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    5244:	7201      	lod	A, [S-2]
    5246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    5248:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    524a:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    524c:	580e      	inc	S, #15
    524e:	0803      	clrb	dp:0x00.3
    5250:	0906      	clrb	io:0x00.6
    5252:	62e6      	lod	AL, Y
    5254:	2926      	sub	X, dp:0x26 <_g_u8StallOcc>
    5256:	623a      	lod	AL, [S-59]
    5258:	a688      	or	A, io:0x8 <__bist_stat_size>
    525a:	010a      	jmp	0x5470 <__mlx4_flash_start+0x1470>
    525c:	248c      	or	X, #-116
    525e:	626f      	lod	AL, [S-112]
    5260:	1007      	call	0x5270 <__mlx4_flash_start+0x1270>
    5262:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    5264:	b684      	and	A, io:0x4 <_LinMess>
    5266:	62ca      	lod	AL, [--PC]
    5268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    526a:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    526c:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x1a>
    526e:	2a05      	sub	X, [S-6]
    5270:	2926      	sub	X, dp:0x26 <_g_u8StallOcc>
    5272:	5c00      	dec	S
    5274:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    5276:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    5278:	4954      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, AH
    527a:	4956      	mov	dp:0x56 <_g_NvramUser>, AH
    527c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    527e:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x37>
    5280:	1103      	call	0x5488 <__mlx4_flash_start+0x1488>
    5282:	4940      	mov	dp:0x40 <_g_DiagResponse>, AH
    5284:	4942      	mov	dp:0x42 <_g_DiagResponse+0x2>, AH
    5286:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    5288:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x38>
    528a:	b763      	and	A, ep:0x63 <_g_NvramUser+0xd>
    528c:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x6>
    528e:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    5290:	735a      	lod	A, ep:0x5a <_g_NvramUser+0x4>
    5292:	736a      	lod	A, ep:0x6a <_g_NvramUser+0x14>
    5294:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x15>
    5296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    5298:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    529a:	734f      	lod	A, ep:0x4f <_g_u16CommutTimerPeriod+0x1>
    529c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    529e:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    52a0:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    52a2:	4c4e      	dadju	D, [X++]
    52a4:	34ef      	and	X, #-17
    52a6:	3985      	subc	X, dp:0x85 <_g_NvramUser+0x2f>
    52a8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    52aa:	4c4f      	dadju	D, [X]
    52ac:	484f      	macu	D, AL, [X]
    52ae:	3806      	subc	X, #6
    52b0:	380a      	subc	X, #10
    52b2:	3428      	and	X, #40
    52b4:	3beb      	subc	X, ep:0xeb <_g_u8MotorHoldingCurrEna+0x1>
    52b6:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    52b8:	736d      	lod	A, ep:0x6d <_g_NvramUser+0x17>
    52ba:	b588      	and	A, dp:0x88 <_g_NvramUser+0x32>
    52bc:	b6a7      	and	A, io:0x27 <_g_u8ChipResetOcc>
    52be:	726e      	lod	A, [S-111]
    52c0:	b23b      	adc	A, [S-60]
    52c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    52c4:	1103      	call	0x54cc <__mlx4_flash_start+0x14cc>
    52c6:	4930      	mov	dp:0x30 <_l_u16VTIdx>, AH
    52c8:	b78c      	and	A, ep:0x8c <_g_NvramUser+0x36>
    52ca:	735b      	lod	A, ep:0x5b <_g_NvramUser+0x5>
    52cc:	2282      	add	X, io:0x2 <_LinCmnd>
    52ce:	622b      	lod	AL, [S-44]
    52d0:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    52d2:	3f88      	xor	X, ep:0x88 <_g_NvramUser+0x32>
    52d4:	b680      	and	A, io:0x0 <__dp__>
    52d6:	7271      	lod	A, [S-114]
    52d8:	7c54      	lod	X, #84
    52da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    52dc:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x6>
    52de:	4c04      	add	D, [Y++]
    52e0:	3805      	subc	X, #5
    52e2:	3808      	subc	X, #8
    52e4:	3449      	and	X, #73
    52e6:	3906      	subc	X, dp:0x6 <_LinMess2>
    52e8:	3512      	and	X, dp:0x12 <__dp_noinit_size+0x2>
    52ea:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    52ec:	623a      	lod	AL, [S-59]
    52ee:	b58c      	and	A, dp:0x8c <_g_NvramUser+0x36>
    52f0:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x7>
    52f2:	580a      	inc	S, #11
    52f4:	0902      	clrb	io:0x00.2
    52f6:	62e6      	lod	AL, Y
    52f8:	2979      	sub	X, dp:0x79 <_g_NvramUser+0x23>
    52fa:	623a      	lod	AL, [S-59]
    52fc:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    52fe:	0102      	jmp	0x5504 <__mlx4_flash_end+0x14>
    5300:	3502      	and	X, dp:0x2 <_LinCmnd>
    5302:	2979      	sub	X, dp:0x79 <_g_NvramUser+0x23>
    5304:	351b      	and	X, dp:0x1b <_g_u8StallTypeComm+0x1>
    5306:	b271      	adc	A, [S-114]
    5308:	8681      	or	AL, io:0x1 <__dp__+0x1>
    530a:	7271      	lod	A, [S-114]
    530c:	a681      	or	A, io:0x1 <__dp__+0x1>
    530e:	1105      	call	0x551a <__mlx4_flash_end+0x2a>
    5310:	e686      	or	Y, io:0x6 <_LinMess2>
    5312:	0101      	jmp	0x5516 <__mlx4_flash_end+0x26>
    5314:	296c      	sub	X, dp:0x6c <_g_NvramUser+0x16>
    5316:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2e>
    5318:	29d4      	sub	X, dp:0xd4 <_ml_driver_mode>
    531a:	3809      	subc	X, #9
    531c:	5806      	inc	S, #7
    531e:	0902      	clrb	io:0x00.2
    5320:	623a      	lod	AL, [S-59]
    5322:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    5324:	623a      	lod	AL, [S-59]
    5326:	a688      	or	A, io:0x8 <__bist_stat_size>
    5328:	0101      	jmp	0x552c <__mlx4_flash_end+0x3c>
    532a:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    532c:	b580      	and	A, dp:0x80 <_g_NvramUser+0x2a>
    532e:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x3>
    5330:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    5332:	b304      	adc	A, ep:0x4 <_LinMess>
    5334:	b205      	adc	A, [S-6]
    5336:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    5338:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    533a:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    533c:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    533e:	7241      	lod	A, [S-66]
    5340:	7142      	lod	A, dp:0x42 <_g_DiagResponse+0x2>
    5342:	4792      	mov	ep:0x92 <_g_NvramUser+0x3c>, YL
    5344:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    5346:	4596      	mov	dp:0x96 <_g_NvramUser+0x40>, YL
    5348:	8340      	add	AL, ep:0x40 <_g_DiagResponse>
    534a:	8a41      	sub	AL, [S-66]
    534c:	8942      	sub	AL, dp:0x42 <_g_DiagResponse+0x2>
    534e:	7340      	lod	A, ep:0x40 <_g_DiagResponse>
    5350:	7241      	lod	A, [S-66]
    5352:	7142      	lod	A, dp:0x42 <_g_DiagResponse+0x2>
    5354:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    5356:	b788      	and	A, ep:0x88 <_g_NvramUser+0x32>
    5358:	b682      	and	A, io:0x2 <_LinCmnd>
    535a:	62ca      	lod	AL, [--PC]
    535c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    535e:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2e>
    5360:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    5362:	24a3      	or	X, #-93
    5364:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    5366:	b271      	adc	A, [S-114]
    5368:	e685      	or	Y, io:0x5 <_LinMess+0x1>
    536a:	0103      	jmp	0x5572 <_INDXtbl+0x32>
    536c:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2e>
    536e:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2f>
    5370:	29bb      	sub	X, dp:0xbb <__bss_dp_size+0xb>
    5372:	b786      	and	A, ep:0x86 <_g_NvramUser+0x30>
    5374:	b587      	and	A, dp:0x87 <_g_NvramUser+0x31>
    5376:	b763      	and	A, ep:0x63 <_g_NvramUser+0xd>
    5378:	b561      	and	A, dp:0x61 <_g_NvramUser+0xb>
    537a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    537c:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    537e:	b682      	and	A, io:0x2 <_LinCmnd>
    5380:	75bc      	lod	PC, dp:0xbc <__bss_dp_size+0xc>
    5382:	3b33      	subc	X, ep:0x33 <_g_u8MotorStopDelay+0x1>
    5384:	580f      	inc	S, #16
    5386:	080b      	clrb	dp:0x01.3
    5388:	0902      	clrb	io:0x00.2
    538a:	62e6      	lod	AL, Y
    538c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    538e:	623a      	lod	AL, [S-59]
    5390:	a688      	or	A, io:0x8 <__bist_stat_size>
    5392:	0105      	jmp	0x559e <_INDXtbl+0x5e>
    5394:	b726      	and	A, ep:0x26 <_g_u8StallOcc>
    5396:	bf8f      	xor	A, ep:0x8f <_g_NvramUser+0x39>
    5398:	0101      	jmp	0x559c <_INDXtbl+0x5c>
    539a:	2982      	sub	X, dp:0x82 <_g_NvramUser+0x2c>
    539c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    539e:	623a      	lod	AL, [S-59]
    53a0:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2f>
    53a2:	b682      	and	A, io:0x2 <_LinCmnd>
    53a4:	62ca      	lod	AL, [--PC]
    53a6:	24a3      	or	X, #-93
    53a8:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x1c>
    53aa:	b738      	and	A, ep:0x38 <__data_dp_end>
    53ac:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x1a>
    53ae:	b787      	and	A, ep:0x87 <_g_NvramUser+0x31>
    53b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    53b2:	734f      	lod	A, ep:0x4f <_g_u16CommutTimerPeriod+0x1>
    53b4:	b786      	and	A, ep:0x86 <_g_NvramUser+0x30>
    53b6:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    53b8:	734e      	lod	A, ep:0x4e <_g_u16CommutTimerPeriod>
    53ba:	4c4e      	dadju	D, [X++]
    53bc:	4c4f      	dadju	D, [X]
    53be:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2e>
    53c0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x9>
    53c2:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x6>
    53c4:	3469      	and	X, #105
    53c6:	3807      	subc	X, #7
    53c8:	380a      	subc	X, #10
    53ca:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    53cc:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2f>
    53ce:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x7>
    53d0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x2b>
    53d2:	580e      	inc	S, #15
    53d4:	0803      	clrb	dp:0x00.3
    53d6:	0906      	clrb	io:0x00.6
    53d8:	62e6      	lod	AL, Y
    53da:	29e9      	sub	X, dp:0xe9 <_g_e8StallDetectorEna>
    53dc:	623a      	lod	AL, [S-59]
    53de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    53e0:	110c      	call	0x55fa <_start+0x12>
    53e2:	2a3c      	sub	X, [S-61]
    53e4:	627c      	lod	AL, [S-125]
    53e6:	0101      	jmp	0x55ea <_start+0x2>
    53e8:	29e9      	sub	X, dp:0xe9 <_g_e8StallDetectorEna>
    53ea:	623a      	lod	AL, [S-59]
    53ec:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x2b>
    53ee:	0107      	jmp	0x55fe <_start+0x16>
    53f0:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2e>
    53f2:	1104      	call	0x55fc <_start+0x14>
    53f4:	a681      	or	A, io:0x1 <__dp__+0x1>
    53f6:	1102      	call	0x55fc <_start+0x14>
    53f8:	29ef      	sub	X, dp:0xef <_g_u16TargetPosition+0x1>
    53fa:	29e9      	sub	X, dp:0xe9 <_g_e8StallDetectorEna>
    53fc:	29ef      	sub	X, dp:0xef <_g_u16TargetPosition+0x1>
    53fe:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5400:	e584      	or	Y, dp:0x84 <_g_NvramUser+0x2e>
    5402:	0103      	jmp	0x560a <__ram_section_init+0x2>
    5404:	b372      	adc	A, ep:0x72 <_g_NvramUser+0x1c>
    5406:	b684      	and	A, io:0x4 <_LinMess>
    5408:	62ca      	lod	AL, [--PC]
    540a:	b365      	adc	A, ep:0x65 <_g_NvramUser+0xf>
    540c:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2e>
    540e:	1101      	call	0x5612 <__ram_section_init+0xa>
    5410:	2a1b      	sub	X, [S-28]
    5412:	3448      	and	X, #72
    5414:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    5416:	3804      	subc	X, #4
    5418:	3e40      	xor	X, [S-65]
    541a:	3f8c      	xor	X, ep:0x8c <_g_NvramUser+0x36>
    541c:	b723      	and	A, ep:0x23 <_g_e8DegradedMotorRequest>
    541e:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2e>
    5420:	0105      	jmp	0x562c <__ram_section_init+0x24>
    5422:	623a      	lod	AL, [S-59]
    5424:	bf88      	xor	A, ep:0x88 <_g_NvramUser+0x32>
    5426:	1101      	call	0x562a <__ram_section_init+0x22>
    5428:	2a0e      	sub	X, [S-15]
    542a:	2a3a      	sub	X, [S-59]
    542c:	3e98      	xor	X, io:0x18 <__data_dp_start>
    542e:	580b      	inc	S, #12
    5430:	090d      	clrb	io:0x01.5
    5432:	62e6      	lod	AL, Y
    5434:	2a17      	sub	X, [S-24]
    5436:	3468      	and	X, #104
    5438:	3790      	and	X, ep:0x90 <_g_NvramUser+0x3a>
    543a:	3806      	subc	X, #6
    543c:	380a      	subc	X, #10
    543e:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x1a>
    5440:	bf88      	xor	A, ep:0x88 <_g_NvramUser+0x32>
    5442:	010d      	jmp	0x565e <_STACK_IT+0x14>
    5444:	b638      	and	A, [S-57]
    5446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5448:	110a      	call	0x565e <_STACK_IT+0x14>
    544a:	2a3c      	sub	X, [S-61]
    544c:	627c      	lod	AL, [S-125]
    544e:	0101      	jmp	0x5652 <_STACK_IT+0x8>
    5450:	2a17      	sub	X, [S-24]
    5452:	b723      	and	A, ep:0x23 <_g_e8DegradedMotorRequest>
    5454:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2e>
    5456:	110e      	call	0x5674 <_STACK_IT+0x2a>
    5458:	623a      	lod	AL, [S-59]
    545a:	7c05      	lod	X, #5
    545c:	2a17      	sub	X, [S-24]
    545e:	580e      	inc	S, #15
    5460:	0805      	clrb	dp:0x00.5
    5462:	0902      	clrb	io:0x00.2
    5464:	62e6      	lod	AL, Y
    5466:	2a2f      	sub	X, [S-48]
    5468:	627c      	lod	AL, [S-125]
    546a:	2a2f      	sub	X, [S-48]
    546c:	623a      	lod	AL, [S-59]
    546e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5470:	0103      	jmp	0x5678 <_STACK_IT+0x2e>
    5472:	2a2f      	sub	X, [S-48]
    5474:	622b      	lod	AL, [S-44]
    5476:	2a72      	sub	X, [S-115]
    5478:	4d3e      	mov	dp:0x3e <__data_dp_end+0x6>, YH
    547a:	4930      	mov	dp:0x30 <_l_u16VTIdx>, AH
    547c:	3449      	and	X, #73
    547e:	3809      	subc	X, #9
    5480:	3805      	subc	X, #5
    5482:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x4a>
    5484:	3986      	subc	X, dp:0x86 <_g_NvramUser+0x30>
    5486:	580e      	inc	S, #15
    5488:	0803      	clrb	dp:0x00.3
    548a:	0903      	clrb	io:0x00.3
    548c:	62e6      	lod	AL, Y
    548e:	2a43      	sub	X, [S-68]
    5490:	2a60      	sub	X, [S-97]
    5492:	627c      	lod	AL, [S-125]
    5494:	0101      	jmp	0x5698 <__fatal+0xc>
    5496:	2a43      	sub	X, [S-68]
    5498:	623a      	lod	AL, [S-59]
    549a:	b330      	adc	A, ep:0x30 <_l_u16VTIdx>
    549c:	b231      	adc	A, [S-50]
    549e:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x2b>
    54a0:	8e80      	cmp	AL, io:0x0 <__dp__>
    54a2:	7330      	lod	A, ep:0x30 <_l_u16VTIdx>
    54a4:	7231      	lod	A, [S-50]
    54a6:	b588      	and	A, dp:0x88 <_g_NvramUser+0x32>
    54a8:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x7>
    54aa:	b589      	and	A, dp:0x89 <_g_NvramUser+0x33>
    54ac:	ee5d      	cmp	Y, [S-94]
    54ae:	1102      	call	0x56b4 <__fatal+0x28>
    54b0:	b782      	and	A, ep:0x82 <_g_NvramUser+0x2c>
    54b2:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    54b4:	b58a      	and	A, dp:0x8a <_g_NvramUser+0x34>
    54b6:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x7>
    54b8:	b58b      	and	A, dp:0x8b <_g_NvramUser+0x35>
    54ba:	ee5d      	cmp	Y, [S-94]
    54bc:	0001      	jmp	0x54c0 <__mlx4_flash_start+0x14c0>
    54be:	2918      	sub	X, dp:0x18 <__data_dp_start>
    54c0:	623a      	lod	AL, [S-59]
    54c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    54c4:	1101      	call	0x56c8 <__fatal+0x3c>
    54c6:	2a43      	sub	X, [S-68]
    54c8:	b201      	adc	A, [S-2]
    54ca:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x3>
    54cc:	a782      	or	A, ep:0x82 <_g_NvramUser+0x2c>
    54ce:	1105      	call	0x56da <__fatal+0x4e>
    54d0:	7c05      	lod	X, #5
    54d2:	e684      	or	Y, io:0x4 <_LinMess>
    54d4:	0101      	jmp	0x56d8 <__fatal+0x4c>
    54d6:	29e2      	sub	X, dp:0xe2 <_ml_driver_mode+0xe>
    54d8:	2a1b      	sub	X, [S-28]
    54da:	e684      	or	Y, io:0x4 <_LinMess>
    54dc:	0103      	jmp	0x56e4 <__fatal+0x58>
    54de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    54e0:	62b5      	lod	AL, io:0x35 <_g_u16StartupDelay+0x1>
    54e2:	24a3      	or	X, #-93
    54e4:	b783      	and	A, ep:0x83 <_g_NvramUser+0x2d>
    54e6:	b682      	and	A, io:0x2 <_LinCmnd>
    54e8:	62ca      	lod	AL, [--PC]
    54ea:	b780      	and	A, ep:0x80 <_g_NvramUser+0x2a>
    54ec:	733b      	lod	A, ep:0x3b <__data_dp_end+0x3>
    54ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00005540 <_INDXtbl>:
    5540:	c0c0      	add	AH, #-64
    5542:	c0c0      	add	AH, #-64
    5544:	c0c0      	add	AH, #-64
    5546:	c0c0      	add	AH, #-64
    5548:	c0c0      	add	AH, #-64
    554a:	c0c0      	add	AH, #-64
    554c:	c0c0      	add	AH, #-64
    554e:	c0c0      	add	AH, #-64
    5550:	c0c0      	add	AH, #-64
    5552:	c0c0      	add	AH, #-64
    5554:	c0c0      	add	AH, #-64
    5556:	c0c0      	add	AH, #-64
    5558:	c0c0      	add	AH, #-64
    555a:	c0c0      	add	AH, #-64
    555c:	c0c0      	add	AH, #-64
    555e:	c0c0      	add	AH, #-64
    5560:	c0c0      	add	AH, #-64
    5562:	c0c0      	add	AH, #-64
    5564:	c0c0      	add	AH, #-64
    5566:	c0c0      	add	AH, #-64
    5568:	c0c0      	add	AH, #-64
    556a:	c0c0      	add	AH, #-64
    556c:	c0c0      	add	AH, #-64
    556e:	c0c0      	add	AH, #-64
    5570:	c0c0      	add	AH, #-64
    5572:	c0c0      	add	AH, #-64
    5574:	c0c0      	add	AH, #-64
    5576:	c0c0      	add	AH, #-64
    5578:	c0c0      	add	AH, #-64
    557a:	c0c0      	add	AH, #-64
    557c:	1110      	call	0x579e <__premain+0x52>
    557e:	c0c0      	add	AH, #-64
    5580:	09a0      	clrb	io:0x14.0
    5582:	a02a      	add	A, #42
    5584:	a0a0      	add	A, #-96
    5586:	a0a0      	add	A, #-96
    5588:	a0a0      	add	A, #-96
    558a:	a0a0      	add	A, #-96
    558c:	a0a0      	add	A, #-96
    558e:	a0a0      	add	A, #-96
    5590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    5592:	a0a0      	add	A, #-96
    5594:	a0a0      	add	A, #-96
    5596:	a0a0      	add	A, #-96
    5598:	a0a0      	add	A, #-96
    559a:	a0a0      	add	A, #-96
    559c:	a0a0      	add	A, #-96
    559e:	a0a0      	add	A, #-96
    55a0:	a0a0      	add	A, #-96
    55a2:	a0a0      	add	A, #-96
    55a4:	a0a0      	add	A, #-96
    55a6:	a0a0      	add	A, #-96
    55a8:	a0a0      	add	A, #-96
    55aa:	a0a0      	add	A, #-96
    55ac:	a0a0      	add	A, #-96
    55ae:	a0a0      	add	A, #-96
    55b0:	a0a0      	add	A, #-96
    55b2:	a0a0      	add	A, #-96
    55b4:	a0a0      	add	A, #-96
    55b6:	a0a0      	add	A, #-96
    55b8:	a0a0      	add	A, #-96
    55ba:	a0a0      	add	A, #-96
    55bc:	a0a0      	add	A, #-96
    55be:	a0a0      	add	A, #-96

000055c0 <_AUTOADDtbl>:
    55c0:	2610      	or	X, [S-17]
    55c2:	1626      	call	0x5210 <__mlx4_flash_start+0x1210>
    55c4:	0000      	nop
    55c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 57e2 	jmpf	0x57e2 <__prestart>
    bf6e:	a55a      	or	A, dp:0x5a <_g_NvramUser+0x4>
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da 564a 	jmpf	0x564a <_STACK_IT>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	6402      	lod	YL, #2
    bf7c:	76da 568c 	jmpf	0x568c <__fatal>
    bf80:	54f8      	mov	UPr, #8
    bf82:	6403      	lod	YL, #3
    bf84:	76da 568c 	jmpf	0x568c <__fatal>
    bf88:	54f8      	mov	UPr, #8
    bf8a:	6404      	lod	YL, #4
    bf8c:	76da 568c 	jmpf	0x568c <__fatal>
    bf90:	54f0      	mov	UPr, #0
    bf92:	6405      	lod	YL, #5
    bf94:	76da 568c 	jmpf	0x568c <__fatal>
    bf98:	54f0      	mov	UPr, #0
    bf9a:	6406      	lod	YL, #6
    bf9c:	76da 568c 	jmpf	0x568c <__fatal>
    bfa0:	54f0      	mov	UPr, #0
    bfa2:	6407      	lod	YL, #7
    bfa4:	76da 568c 	jmpf	0x568c <__fatal>
    bfa8:	54f0      	mov	UPr, #0
    bfaa:	6408      	lod	YL, #8
    bfac:	76da 568c 	jmpf	0x568c <__fatal>
    bfb0:	54d4      	psup	#4
    bfb2:	76da 5e7c 	jmpf	0x5e7c <_linit>
    bfb6:	0000      	nop
    bfb8:	54d5      	psup	#5
    bfba:	76da a016 	jmpf	0xa016 <_TIMER_IT>
    bfbe:	0000      	nop
    bfc0:	54d4      	psup	#4
    bfc2:	76da 860c 	jmpf	0x860c <_ADC_IT>
    bfc6:	0000      	nop
    bfc8:	54f0      	mov	UPr, #0
    bfca:	640c      	lod	YL, #12
    bfcc:	76da 568c 	jmpf	0x568c <__fatal>
    bfd0:	54d3      	psup	#3
    bfd2:	76da 94b8 	jmpf	0x94b8 <_EXT0_IT>
    bfd6:	0000      	nop
    bfd8:	54f0      	mov	UPr, #0
    bfda:	640e      	lod	YL, #14
    bfdc:	76da 568c 	jmpf	0x568c <__fatal>
    bfe0:	54f0      	mov	UPr, #0
    bfe2:	640f      	lod	YL, #15
    bfe4:	76da 568c 	jmpf	0x568c <__fatal>
    bfe8:	54f0      	mov	UPr, #0
    bfea:	6410      	lod	YL, #16
    bfec:	76da 568c 	jmpf	0x568c <__fatal>
    bff0:	54d2      	psup	#2
    bff2:	76da 897e 	jmpf	0x897e <_EXT4_IT>
    bff6:	0000      	nop
    bff8:	54f0      	mov	UPr, #0
    bffa:	6412      	lod	YL, #18
    bffc:	76da 568c 	jmpf	0x568c <__fatal>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000055e8 <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    55e8:	7000      	lod	A, #0
    55ea:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    55ec:	70ff      	lod	A, #-1
    55ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    55f2:	72da 02b2 	lod	A, #690
    55f6:	52ef      	mov	S, A

    _low_level_init();
    55f8:	82db 69e2 	callf	0x69e2 <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    55fc:	1005      	call	0x5608 <__ram_section_init>
    _premain();
    55fe:	10a6      	call	0x574c <__premain>
    (void)main();
    5600:	82db 6dcc 	callf	0x6dcc <_main>
    _fatal();
    5604:	1043      	call	0x568c <__fatal>
    5606:	5401      	ret

00005608 <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    5608:	7ada 0038 	lod	Y, #56
    560c:	eeda 00e8 	cmp	Y, #232
    5610:	1c03      	jnc	0x5618 <__ram_section_init+0x10>
        *w++ = 0;
    5612:	7000      	lod	A, #0
    5614:	52d6      	mov	[Y++], A
    5616:	07fa      	jmp	0x560c <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    5618:	7ada 0148 	lod	Y, #328
    561c:	eeda 02aa 	cmp	Y, #682
    5620:	1c03      	jnc	0x5628 <__ram_section_init+0x20>
        *w++ = 0;
    5622:	7000      	lod	A, #0
    5624:	52d6      	mov	[Y++], A
    5626:	07fa      	jmp	0x561c <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    5628:	7eda a29e 	lod	X, #41630

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    562c:	7ada 0018 	lod	Y, #24
    5630:	eeda 0038 	cmp	Y, #56
    5634:	1c02      	jnc	0x563a <__ram_section_init+0x32>
        *w++ = *r++;
    5636:	54ce      	movsw	[Y++], [X++]
    5638:	07fb      	jmp	0x5630 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    563a:	7ada 00f8 	lod	Y, #248
    563e:	eeda 0148 	cmp	Y, #328
    5642:	1c02      	jnc	0x5648 <__ram_section_init+0x40>
        *w++ = *r++;
    5644:	54ce      	movsw	[Y++], [X++]
    5646:	07fb      	jmp	0x563e <__ram_section_init+0x36>
    5648:	5401      	ret

0000564a <_STACK_IT>:
 * Fatal program termination (Stack IRQ)
 */
__MLX_TEXT__ void STACK_IT(void)
{
	/* Chip header is valid and chip successfully initialised; LIN Command Reset use AWD to reset chip */
	if ( (bistHeader == C_CHIP_HEADER) && ((bistResetInfo == (uint16) C_CHIP_STATE_LIN_CMD_RESET) || (bistResetInfo == (uint16) C_CHIP_STATE_LOADER_PROG_RESET)) )
    564a:	72d8 02aa 	lod	A, 0x2aa <__bss_end>
    564e:	aeda b598 	cmp	A, #46488
    5652:	1d19      	jne	0x5686 <_STACK_IT+0x3c>
    5654:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5658:	aeda 3072 	cmp	A, #12402
    565c:	1905      	je	0x5668 <_STACK_IT+0x1e>
    565e:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5662:	aeda 3212 	cmp	A, #12818
    5666:	1d0f      	jne	0x5686 <_STACK_IT+0x3c>
	{
		/* INLINE MLX16_RESET (Don't use stack) */
		do
		{
			if ( (PLL_CTRL & PLL_EN) != 0U )									/* Only delay in case of PLL is active */
    5668:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    566c:	b401      	and	A, #1
    566e:	1903      	je	0x5676 <_STACK_IT+0x2c>
			{
				DELAY_US( 250U);												/* Should be called with period > 200us, otherwise bit AWD_WRITE_FAIL will be set and further acknowledgment will fail during next 200 us */
    5670:	7eda 06d6 	lod	X, #1750
    5674:	1bff      	djnz	X, 0x5674 <_STACK_IT+0x2a>
			}
			AWD_CTRL = (AWD_ATT | AWD_WRITE_FAIL | (3U << 8) | 1U);				/* Set 1:1 pre-scaler and minimal period; AWD timeout will be 100 us */
    5676:	72da 6301 	lod	A, #25345
    567a:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
		} while ( (AWD_CTRL & (AWD_ATT | AWD_WRITE_FAIL)) != 0U );
    567c:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    567e:	b6da 6000 	and	A, #24576
    5682:	1d72      	jne	0x5668 <_STACK_IT+0x1e>
		for ( ; ; ) {
    5684:	07ff      	jmp	0x5684 <_STACK_IT+0x3a>
			/* wait for reset */
		}
	}
	__asm__( "mov yl, #01");
    5686:	6401      	lod	YL, #1
	__asm__( "jmp __fatal");
    5688:	0001      	jmp	0x568c <__fatal>
    568a:	5401      	ret

0000568c <__fatal>:
 * 0x079C: Address of failure (from stack)
 */
__MLX_TEXT__ void _fatal (void)
{
	/* YL = Error-reason; Don't use stack */
	__asm__("lod X, 0x2026");													/* X = [FL_CTRL0] */
    568c:	7ed8 2026 	lod	X, 0x2026 <__ep__+0x1026>
	__asm__("and X, #0x07");													/* X[2:0] = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) */
    5690:	3407      	and	X, #7
	__asm__("lod A, 0x2040");													/* A = [PLL_STAT] */
    5692:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
	__asm__("and A, #0x03");													/* A[1:0] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) */
    5696:	b403      	and	A, #3
	__asm__("asl A, #2");
    5698:	44a2      	asl	A, #2
	__asm__("asl A, #2");														/* A[5:4] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569a:	44a2      	asl	A, #2
	__asm__("or  A, X");														/* A(L) = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569c:	a6ee      	or	A, X
	__asm__("lod YH, AL");														/* YH = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569e:	6ee0      	lod	YH, AL
	__asm__("mov _bistError, Y");
    56a0:	5ad8 02ae 	mov	0x2ae <_bistError>, Y
	__asm__("lod A, [S-2]");													/* Save address of failed instruction */
    56a4:	7201      	lod	A, [S-2]
	__asm__("mov _bistErrorInfo, A");											/* Failure address */
    56a6:	52d8 02b0 	mov	0x2b0 <_bistErrorInfo>, A

#if _SUPPORT_CRASH_RECOVERY
	/* Crash recovery */
	if ( (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) && ((uint8)(bistError & 0xFFU) < 0x05U) )
    56aa:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    56ae:	aeda 1a45 	cmp	A, #6725
    56b2:	1901      	je	0x56b6 <__fatal+0x2a>
    56b4:	0039      	jmp	0x5728 <__fatal+0x9c>
    56b6:	72d8 02ae 	lod	A, 0x2ae <_bistError>
    56ba:	8c04      	cmp	AL, #4
    56bc:	1e35      	jug	0x5728 <__fatal+0x9c>
	{
		/* Crash recovery is enabled, and type of IRQ is between 0x01 and 0x04 */
		bistResetInfo = C_CHIP_STATE_FATAL_CRASH_RECOVERY;						/* Start recovery (on-going) */
    56be:	72da 1872 	lod	A, #6258
    56c2:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
		SET_STACK( &stack);														/* Re-initialise stack */
    56c6:	72da 02b2 	lod	A, #690
    56ca:	52ef      	mov	S, A
		ENTER_SYSTEM_MODE();													/* Protected mode, highest priority (0) */
    56cc:	4407      	mov	R, #0
    56ce:	500c      	call	fp0:0x60
    56d0:	54f0      	mov	UPr, #0
		if ( (ANA_INA & XI4_OC_DRV) != 0U )										/* MMP170405-3 - Begin */
    56d2:	729c      	lod	A, io:0x1c <_g_i16MotorVoltage>
    56d4:	b6da 0100 	and	A, #256
    56d8:	190b      	je	0x56f0 <__fatal+0x64>
		{
			/* Over-current! */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_YES;
    56da:	6001      	lod	AL, #1
    56dc:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			MotorDriverStop( (uint16) C_STOP_EMERGENCY);						/* Over-current */
    56de:	7002      	lod	A, #2
    56e0:	82db 9296 	callf	0x9296 <_MotorDriverStop>
			g_u16TargetPosition = g_u16ActualPosition;
    56e4:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    56e6:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
			SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    56e8:	72da 00d0 	lod	A, #208
    56ec:	82db 89e6 	callf	0x89e6 <_SetLastError>
		}																		/* MMP170405-3 - End */
		XI0_PEND = CLR_T1_INT4;
    56f0:	7040      	lod	A, #64
    56f2:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI2_PEND = 0xFFFFU;														/* Clear all XI2_PEND flags */
    56f6:	70ff      	lod	A, #-1
    56f8:	52d8 2038 	mov	0x2038 <__ep__+0x1038>, A
		XI4_PEND = (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV);
    56fc:	72da e100 	lod	A, #57600
    5700:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		g_u8Mlx4ErrorState = (uint8) C_MLX4_STATE_IMMEDIATE_RST;				/* Reset MLX4 always */
    5704:	6080      	lod	AL, #-128
    5706:	42d8 00fd 	mov	0xfd <_g_u8Mlx4ErrorState>, AL
		PEND = CLR_TIMER_IT;													/* Core-Timer */
    570a:	7020      	lod	A, #32
    570c:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		SET_PRIORITY( 7);														/* Protected mode, low priority (7) */
    5710:	54f7      	mov	UPr, #7
		if ( (FL_CTRL0 & FL_DETECT) != 0U )
    5712:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5716:	b401      	and	A, #1
    5718:	1903      	je	0x5720 <__fatal+0x94>
		{
			(void) FlashBackgroundTest( 0U);
    571a:	7000      	lod	A, #0
    571c:	82db 6cd8 	callf	0x6cd8 <_FlashBackgroundTest>
		}
		(void) main();
    5720:	82db 6dcc 	callf	0x6dcc <_main>

		/* Should never come here, as main should not be left */
		__asm__( "mov YL, #0x19");												/* C_MLX16_MAIN_FATAL */
    5724:	6419      	lod	YL, #25
		/* lint -e{974} */ _fatal();
    5726:	17b2      	call	0x568c <__fatal>
	}
#endif /* _SUPPORT_CRASH_RECOVERY */

	SET_STACK( &stack);															/* Re-initialise stack */
    5728:	72da 02b2 	lod	A, #690
    572c:	52ef      	mov	S, A
	ENTER_SYSTEM_MODE();														/* Protected mode, highest priority (0) */
    572e:	4407      	mov	R, #0
    5730:	500c      	call	fp0:0x60
    5732:	54f0      	mov	UPr, #0
	FL_CTRL0 &= ~(FL_DBE | FL_SBE);												/* Clear DBE and SBE errors */
    5734:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5738:	b4f9      	and	A, #-7
    573a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

	/* Disable motor driver first, before waiting for watchdog */
	DRVCFG_DIS_UVWT();															/* Tri-state (disconnect) the phase U, V, W and T */
    573e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    5742:	b6da fe00 	and	A, #65024
    5746:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	for (;;) {
    574a:	07ff      	jmp	0x574a <__fatal+0xbe>

0000574c <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    574c:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    574e:	72ef      	lod	A, S
    5750:	a080      	add	A, #-128
    5752:	52d8 02a6 	mov	0x2a6 <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    5756:	82db 66ee 	callf	0x66ee <_LDR_GetState>
    575a:	8c00      	cmp	AL, #0
    575c:	1d06      	jne	0x576a <__premain+0x1e>
    575e:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5762:	aeda 3212 	cmp	A, #12818
    5766:	1901      	je	0x576a <__premain+0x1e>
    5768:	0039      	jmp	0x57dc <__premain+0x90>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
        if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    576a:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    576e:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    5772:	4cb2 72ef 	cmp	YA, #-396266769
    5776:	e861 
    5778:	1913      	je	0x57a0 <__premain+0x54>
            /* RAM contents lost; Load User-page of NVRAM and get NAD.
             * NVRAM is only 16-bit accessible; Copy it first to System RAM variable.
             * NOTE: Don't use NVRAM_LoadUserPage() as this function and others are not located in __MLX_TEXT__ segment.
             */
/* Loader-version: uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76); */          /* Get NAD from Flash at STACK_IT Segment */
            uint8_t u8NAD = (uint8) ((uint16 *) C_ADDR_USERPAGE1)[1];           /* NAD is LSB of 2nd 16-bit Word of NVRAM-user structure (MMP161208-1) */
    577a:	7ada 1002 	lod	Y, #4098
    577e:	72f0      	lod	A, [Y]
    5780:	5cf2      	usex	A
            if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    5782:	8c00      	cmp	AL, #0
    5784:	1a82      	jsl	0x578a <__premain+0x3e>
    5786:	ac00      	cmp	A, #0
    5788:	1d01      	jne	0x578c <__premain+0x40>
            {
                u8NAD = 0x7F;                                                   /* Invalid NAD; Use default NAD */
    578a:	707f      	lod	A, #127
            }
            stFixedRamNAD.nad = u8NAD;
    578c:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
            stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5790:	72da 72ef 	lod	A, #29423
    5794:	52d8 0010 	mov	0x10 <__dp_noinit_size>, A
    5798:	72da e861 	lod	A, #59489
    579c:	52d8 0012 	mov	0x12 <__dp_noinit_size+0x2>, A
        }
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    57a0:	54f7      	mov	UPr, #7

        ml_LinInit();
    57a2:	82db 66ce 	callf	0x66ce <_ml_LinInit>
        (void)ml_Connect();
    57a6:	125b      	call	0x5c5e <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    57a8:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    57ac:	aeda 3212 	cmp	A, #12818
    57b0:	1d07      	jne	0x57c0 <__premain+0x74>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    57b2:	7000      	lod	A, #0
    57b4:	82db 614e 	callf	0x614e <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    57b8:	72da 5c92 	lod	A, #23698
    57bc:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    57c0:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    57c2:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    57c4:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    57c6:	b430      	and	A, #48
    57c8:	1902      	je	0x57ce <__premain+0x82>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    57ca:	6000      	lod	AL, #0
    57cc:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    57ce:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    57d2:	b410      	and	A, #16
    57d4:	1975      	je	0x57c0 <__premain+0x74>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    57d6:	1251      	call	0x5c7a <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    57d8:	1268      	call	0x5caa <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    57da:	07f2      	jmp	0x57c0 <__premain+0x74>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    57dc:	54f7      	mov	UPr, #7
    57de:	5c7f      	dec	S, #128
    57e0:	5401      	ret

000057e2 <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    57e2:	5801      	inc	S, #2
    57e4:	7000      	lod	A, #0
    57e6:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    57e8:	70ff      	lod	A, #-1
    57ea:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    57ee:	72da 02b2 	lod	A, #690
    57f2:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    57f4:	1130      	call	0x5a56 <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    57f6:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    57fa:	b401      	and	A, #1
    57fc:	1d27      	jne	0x584c <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    57fe:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5802:	5cf2      	usex	A
    5804:	4422      	asl	A
    5806:	7ada 10e8 	lod	Y, #4328
    580a:	eae2      	sub	Y, A
    580c:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5810:	5cf2      	usex	A
    5812:	7ee2      	lod	X, A
    5814:	7014      	lod	A, #20
    5816:	aaee      	sub	A, X
    5818:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    581a:	7ee2      	lod	X, A
    581c:	7000      	lod	A, #0
    581e:	08a7      	clrb	ML.7
    5820:	b2d6      	adc	A, [Y++]
    5822:	1bfe      	djnz	X, 0x5820 <__prestart+0x3e>
    5824:	92e4      	adc	AL, AH
    5826:	9000      	adc	AL, #0
    5828:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    582a:	aeda 00ff 	cmp	A, #255
    582e:	1d0e      	jne	0x584c <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    5830:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    5834:	b4f8      	and	A, #-8
    5836:	aeda 04b8 	cmp	A, #1208
    583a:	1d08      	jne	0x584c <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    583c:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    5840:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    5844:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    5846:	eeda 201a 	cmp	Y, #8218
    584a:	1a7c      	jule	0x5844 <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    584c:	72d8 02aa 	lod	A, 0x2aa <__bss_end>
    5850:	aeda b598 	cmp	A, #46488
    5854:	1901      	je	0x5858 <__prestart+0x76>
    5856:	0037      	jmp	0x58c6 <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    5858:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    585a:	ac00      	cmp	A, #0
    585c:	1a84      	jsl	0x5866 <__prestart+0x84>
    585e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    5862:	8c00      	cmp	AL, #0
    5864:	1e98      	jsge	0x5896 <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    5866:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    586a:	aeda 3072 	cmp	A, #12402
    586e:	1d01      	jne	0x5872 <__prestart+0x90>
    5870:	0031      	jmp	0x58d4 <__prestart+0xf2>
    5872:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5876:	aeda 3212 	cmp	A, #12818
    587a:	192c      	je	0x58d4 <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    587c:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5880:	1905      	je	0x588c <__prestart+0xaa>
    5882:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5886:	aeda 1a45 	cmp	A, #6725
    588a:	1d03      	jne	0x5892 <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    588c:	72da 5c92 	lod	A, #23698
    5890:	000d      	jmp	0x58ac <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    5892:	7c00      	lod	X, #0
    5894:	0015      	jmp	0x58c0 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    5896:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    589a:	aeda 3072 	cmp	A, #12402
    589e:	1909      	je	0x58b2 <__prestart+0xd0>
    58a0:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    58a4:	aeda 3212 	cmp	A, #12818
    58a8:	1904      	je	0x58b2 <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    58aa:	7000      	lod	A, #0
    58ac:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
    58b0:	0011      	jmp	0x58d4 <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    58b2:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    58b6:	aeda 1a45 	cmp	A, #6725
    58ba:	1d0c      	jne	0x58d4 <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    58bc:	7eda 56d2 	lod	X, #22226
    58c0:	5ed8 02ac 	mov	0x2ac <_bistResetInfo>, X
    58c4:	0007      	jmp	0x58d4 <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    58c6:	7000      	lod	A, #0
    58c8:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    58cc:	7eda b598 	lod	X, #46488
    58d0:	5ed8 02aa 	mov	0x2aa <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    58d4:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    58d8:	aeda 3072 	cmp	A, #12402
    58dc:	1919      	je	0x5910 <__prestart+0x12e>
    58de:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    58e2:	aeda 3212 	cmp	A, #12818
    58e6:	1914      	je	0x5910 <__prestart+0x12e>
    58e8:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    58ec:	aeda 5c92 	cmp	A, #23698
    58f0:	190f      	je	0x5910 <__prestart+0x12e>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    58f2:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    58f6:	7c20      	lod	X, #32
    58f8:	7000      	lod	A, #0
    58fa:	08a7      	clrb	ML.7
    58fc:	b2d6      	adc	A, [Y++]
    58fe:	1bfe      	djnz	X, 0x58fc <__prestart+0x11a>
    5900:	92e4      	adc	AL, AH
    5902:	9000      	adc	AL, #0
    5904:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    5906:	aeda 00ff 	cmp	A, #255
    590a:	1902      	je	0x5910 <__prestart+0x12e>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    590c:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    590e:	06be      	jmp	0x568c <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    5910:	6030      	lod	AL, #48
    5912:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    5916:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    591a:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    591e:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    5922:	a6da 8000 	or	A, #32768
    5926:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    592a:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    592e:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    5932:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    5936:	b6da 00ff 	and	A, #255
    593a:	a6da c000 	or	A, #49152
    593e:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    5942:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    5946:	94cf      	and	AL, #-49
    5948:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    594c:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    5950:	b4f9      	and	A, #-7
    5952:	a402      	or	A, #2
    5954:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    5958:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    595c:	b401      	and	A, #1
    595e:	1914      	je	0x5988 <__prestart+0x1a6>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    5960:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    5964:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    5968:	a6e6      	or	A, Y
    596a:	190e      	je	0x5988 <__prestart+0x1a6>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    596c:	7eda 55c8 	lod	X, #21960

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    5970:	7ada 0740 	lod	Y, #1856
    5974:	eeda 075e 	cmp	Y, #1886
    5978:	1c05      	jnc	0x5984 <__prestart+0x1a2>
        *w++ = *r++;
    597a:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    597c:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    597e:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    5980:	54ce      	movsw	[Y++], [X++]
    5982:	07f8      	jmp	0x5974 <__prestart+0x192>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    5984:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    5988:	72da 6fd1 	lod	A, #28625
    598c:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    5990:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    5992:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    5996:	b401      	and	A, #1
    5998:	1d03      	jne	0x59a0 <__prestart+0x1be>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    599a:	e001      	add	Y, #1
    599c:	ec63      	cmp	Y, #99
    599e:	1a79      	jule	0x5992 <__prestart+0x1b0>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    59a0:	ec64      	cmp	Y, #100
    59a2:	1d01      	jne	0x59a6 <__prestart+0x1c4>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    59a4:	07ff      	jmp	0x59a4 <__prestart+0x1c2>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    59a6:	6024      	lod	AL, #36
    59a8:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    59ac:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    59b0:	aeda 3072 	cmp	A, #12402
    59b4:	190e      	je	0x59d2 <__prestart+0x1f0>
    59b6:	82db 66ee 	callf	0x66ee <_LDR_GetState>
    59ba:	8c00      	cmp	AL, #0
    59bc:	1d0a      	jne	0x59d2 <__prestart+0x1f0>
    59be:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    59c2:	aeda 3212 	cmp	A, #12818
    59c6:	1905      	je	0x59d2 <__prestart+0x1f0>
    59c8:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    59cc:	aeda 5c92 	cmp	A, #23698
    59d0:	1d02      	jne	0x59d6 <__prestart+0x1f4>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    59d2:	060a      	jmp	0x55e8 <_start>
    59d4:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    59d6:	76da 6992 	jmpf	0x6992 <_RAM_Test>
    59da:	5403      	ret	#4

000059dc <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    59dc:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    59de:	4407      	mov	R, #0
    59e0:	500c      	call	fp0:0x60
    59e2:	54f0      	mov	UPr, #0
    59e4:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59e6:	b430      	and	A, #48
    59e8:	ac10      	cmp	A, #16
    59ea:	1914      	je	0x5a14 <_MLX16_RESET+0x38>
    59ec:	1e03      	jug	0x59f4 <_MLX16_RESET+0x18>
    59ee:	ac00      	cmp	A, #0
    59f0:	190c      	je	0x5a0a <_MLX16_RESET+0x2e>
    59f2:	002f      	jmp	0x5a52 <_MLX16_RESET+0x76>
    59f4:	ac20      	cmp	A, #32
    59f6:	1903      	je	0x59fe <_MLX16_RESET+0x22>
    59f8:	ac30      	cmp	A, #48
    59fa:	1904      	je	0x5a04 <_MLX16_RESET+0x28>
    59fc:	002a      	jmp	0x5a52 <_MLX16_RESET+0x76>
    59fe:	6000      	lod	AL, #0
    5a00:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a02:	07fd      	jmp	0x59fe <_MLX16_RESET+0x22>
    5a04:	6000      	lod	AL, #0
    5a06:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a08:	07ff      	jmp	0x5a08 <_MLX16_RESET+0x2c>
    5a0a:	6001      	lod	AL, #1
    5a0c:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a0e:	6010      	lod	AL, #16
    5a10:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    5a12:	07ff      	jmp	0x5a12 <_MLX16_RESET+0x36>
    5a14:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5a16:	66e0      	lod	YL, AL
    5a18:	5cf6      	usex	Y
    5a1a:	44a6      	asl	Y, #2
    5a1c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a1e:	b403      	and	A, #3
    5a20:	4422      	asl	A
    5a22:	ac00      	cmp	A, #0
    5a24:	1b03      	jsle	0x5a2c <_MLX16_RESET+0x50>
    5a26:	42e9      	mov	Cx, AL
    5a28:	4426      	asl	Y
    5a2a:	1ffe      	djnz	Cx, 0x5a28 <_MLX16_RESET+0x4c>
    5a2c:	ec7d      	cmp	Y, #125
    5a2e:	1c01      	jnc	0x5a32 <_MLX16_RESET+0x56>
    5a30:	07ff      	jmp	0x5a30 <_MLX16_RESET+0x54>
    5a32:	7eda 06d6 	lod	X, #1750
    5a36:	1bff      	djnz	X, 0x5a36 <_MLX16_RESET+0x5a>
    5a38:	72da 6301 	lod	A, #25345
    5a3c:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
    5a3e:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    5a40:	b6da 6000 	and	A, #24576
    5a44:	1d76      	jne	0x5a32 <_MLX16_RESET+0x56>
    5a46:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    5a4a:	b4fe      	and	A, #-2
    5a4c:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    5a50:	07ff      	jmp	0x5a50 <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    5a52:	5ae3      	mov	M, Y
    5a54:	5401      	ret

00005a56 <_NVRAM_LoadAll>:
    5a56:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a5a:	b401      	and	A, #1
    5a5c:	1908      	je	0x5a6e <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a5e:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5a60:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a62:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a64:	b430      	and	A, #48
    5a66:	1977      	je	0x5a56 <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a68:	6000      	lod	AL, #0
    5a6a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a6c:	07f4      	jmp	0x5a56 <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    5a6e:	72da 8000 	lod	A, #32768
    5a72:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    5a76:	72da 8001 	lod	A, #32769
    5a7a:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    5a7e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a82:	b401      	and	A, #1
    5a84:	1908      	je	0x5a96 <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a86:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5a88:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a8a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a8c:	b430      	and	A, #48
    5a8e:	1977      	je	0x5a7e <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a90:	6000      	lod	AL, #0
    5a92:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a94:	07f4      	jmp	0x5a7e <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    5a96:	7000      	lod	A, #0
    5a98:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    5a9c:	7001      	lod	A, #1
    5a9e:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    5aa2:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5aa6:	b401      	and	A, #1
    5aa8:	1908      	je	0x5aba <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5aaa:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5aac:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5aae:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5ab0:	b430      	and	A, #48
    5ab2:	1977      	je	0x5aa2 <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5ab4:	6000      	lod	AL, #0
    5ab6:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5ab8:	07f4      	jmp	0x5aa2 <_NVRAM_LoadAll+0x4c>
    5aba:	5401      	ret

00005abc <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    5abc:	7ee2      	lod	X, A
    5abe:	b6da 7fff 	and	A, #32767
    5ac2:	ac01      	cmp	A, #1
    5ac4:	1906      	je	0x5ad2 <_NVRAM_SavePage+0x16>
    5ac6:	1803      	jc	0x5ace <_NVRAM_SavePage+0x12>
    5ac8:	ac02      	cmp	A, #2
    5aca:	1905      	je	0x5ad6 <_NVRAM_SavePage+0x1a>
    5acc:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    5ace:	7810      	lod	Y, #16
            break;
    5ad0:	0004      	jmp	0x5ada <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    5ad2:	7818      	lod	Y, #24
            break;
    5ad4:	0002      	jmp	0x5ada <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    5ad6:	7ada 8400 	lod	Y, #33792
    5ada:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5ade:	b401      	and	A, #1
    5ae0:	1908      	je	0x5af2 <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5ae2:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5ae4:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5ae6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5ae8:	b430      	and	A, #48
    5aea:	1977      	je	0x5ada <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5aec:	6000      	lod	AL, #0
    5aee:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5af0:	07f4      	jmp	0x5ada <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    5af2:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    5af6:	e403      	or	Y, #3
    5af8:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    5afc:	2c00      	cmp	X, #0
    5afe:	1a8c      	jsl	0x5b18 <_NVRAM_SavePage+0x5c>
    5b00:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5b04:	b401      	and	A, #1
    5b06:	1908      	je	0x5b18 <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5b08:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5b0a:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5b0c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5b0e:	b430      	and	A, #48
    5b10:	1977      	je	0x5b00 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5b12:	6000      	lod	AL, #0
    5b14:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5b16:	07f4      	jmp	0x5b00 <_NVRAM_SavePage+0x44>
    5b18:	5401      	ret

00005b1a <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    5b1a:	7ae2      	lod	Y, A
    5b1c:	6203      	lod	AL, [S-4]
    5b1e:	5cf2      	usex	A
    5b20:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    5b22:	72e6      	lod	A, Y
    5b24:	b401      	and	A, #1
    5b26:	1908      	je	0x5b38 <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    5b28:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5b2a:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    5b2c:	b6da 00ff 	and	A, #255
    5b30:	36da 00ff 	and	X, #255
    5b34:	7eec      	swap	X
    5b36:	0003      	jmp	0x5b3e <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5b38:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    5b3a:	b6da ff00 	and	A, #65280
    5b3e:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    5b40:	52f0      	mov	[Y], A
    5b42:	5401      	ret

00005b44 <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    5b44:	7000      	lod	A, #0
    5b46:	17ba      	call	0x5abc <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    5b48:	7001      	lod	A, #1
    5b4a:	17b8      	call	0x5abc <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    5b4c:	7002      	lod	A, #2
    5b4e:	17b6      	call	0x5abc <_NVRAM_SavePage>
    5b50:	5401      	ret

00005b52 <_ml_ReleaseBuffer>:
    5b52:	602f      	lod	AL, #47
    5b54:	0033      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b56 <_ml_ReleaseBufferProg>:
    5b56:	9401      	and	AL, #1
    5b58:	44a0      	asl	AL, #2
    5b5a:	44a0      	asl	AL, #2
    5b5c:	840f      	or	AL, #15
    5b5e:	002e      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b60 <_ml_DataReady>:
    5b60:	6ae0      	lod	AH, AL
    5b62:	6015      	lod	AL, #21
    5b64:	7eda 0008 	lod	X, #8
    5b68:	7ada 00c8 	lod	Y, #200
    5b6c:	54c6      	movsw	[X++], [Y++]
    5b6e:	54c6      	movsw	[X++], [Y++]
    5b70:	54c6      	movsw	[X++], [Y++]
    5b72:	54c6      	movsw	[X++], [Y++]
    5b74:	0023      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b76 <_ml_AssignFrameToMessageID>:
    5b76:	6a03      	lod	AH, [S-4]
    5b78:	d43f      	and	AH, #63
    5b7a:	0004      	jmp	0x5b84 <_ml_EnableMessage+0x4>

00005b7c <_ml_DisableMessage>:
    5b7c:	6802      	lod	AH, #2
    5b7e:	0001      	jmp	0x5b82 <_ml_EnableMessage+0x2>

00005b80 <_ml_EnableMessage>:
    5b80:	6803      	lod	AH, #3
    5b82:	44d4      	rr	AH, #2
    5b84:	44a0      	asl	AL, #2
    5b86:	44a0      	asl	AL, #2
    5b88:	8406      	or	AL, #6
    5b8a:	0018      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b8c <_ml_AutoAddressingConfig>:
    5b8c:	44a0      	asl	AL, #2
    5b8e:	44a0      	asl	AL, #2
    5b90:	840d      	or	AL, #13
    5b92:	0014      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b94 <_ml_SetSlewRate>:
    5b94:	44a2      	asl	A, #2
    5b96:	44a2      	asl	A, #2
    5b98:	a407      	or	A, #7
    5b9a:	0010      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005b9c <_ml_SetOptions>:
    5b9c:	6a03      	lod	AH, [S-4]
    5b9e:	44a4      	asl	AH, #2
    5ba0:	86e4      	or	AL, AH
    5ba2:	44a0      	asl	AL, #2
    5ba4:	44a0      	asl	AL, #2
    5ba6:	840b      	or	AL, #11
    5ba8:	c607      	or	AH, [S-8]
    5baa:	44a4      	asl	AH, #2
    5bac:	c605      	or	AH, [S-6]
    5bae:	dc01      	xor	AH, #1
    5bb0:	0005      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005bb2 <_ml_DiscardFrame>:
    5bb2:	6005      	lod	AL, #5
    5bb4:	0003      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005bb6 <_ml_ContFrame>:
    5bb6:	6ae0      	lod	AH, AL
    5bb8:	6025      	lod	AL, #37
    5bba:	0000      	nop
    5bbc:	54e2      	mov	Cx, #2
    5bbe:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    5bc2:	7ae2      	lod	Y, A
    5bc4:	6041      	lod	AL, #65
    5bc6:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5bca:	7eda 03e8 	lod	X, #1000
    5bce:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5bd2:	9402      	and	AL, #2
    5bd4:	1d03      	jne	0x5bdc <_ml_ContFrame+0x26>
    5bd6:	1bfb      	djnz	X, 0x5bce <_ml_ContFrame+0x18>
    5bd8:	7002      	lod	A, #2
    5bda:	5401      	ret
    5bdc:	7ee6      	lod	X, Y
    5bde:	340f      	and	X, #15
    5be0:	72d8 0000 	lod	A, 0x0 <__dp__>
    5be4:	6800      	lod	AH, #0
    5be6:	aeee      	cmp	A, X
    5be8:	1d02      	jne	0x5bee <_ml_ContFrame+0x38>
    5bea:	7000      	lod	A, #0
    5bec:	5401      	ret
    5bee:	72e6      	lod	A, Y
    5bf0:	1fe6      	djnz	Cx, 0x5bbe <_ml_ContFrame+0x8>
    5bf2:	7001      	lod	A, #1
    5bf4:	5401      	ret

00005bf6 <_ml_LinModuleVersion>:
    5bf6:	602a      	lod	AL, #42
    5bf8:	17e1      	call	0x5bbc <_ml_ContFrame+0x6>
    5bfa:	ac00      	cmp	A, #0
    5bfc:	1d11      	jne	0x5c20 <_ml_LinModuleVersion+0x2a>
    5bfe:	72d8 0000 	lod	A, 0x0 <__dp__>
    5c02:	940f      	and	AL, #15
    5c04:	8c0a      	cmp	AL, #10
    5c06:	1d0c      	jne	0x5c20 <_ml_LinModuleVersion+0x2a>
    5c08:	66e4      	lod	YL, AH
    5c0a:	601a      	lod	AL, #26
    5c0c:	17d7      	call	0x5bbc <_ml_ContFrame+0x6>
    5c0e:	ac00      	cmp	A, #0
    5c10:	1d07      	jne	0x5c20 <_ml_LinModuleVersion+0x2a>
    5c12:	72d8 0000 	lod	A, 0x0 <__dp__>
    5c16:	940f      	and	AL, #15
    5c18:	8c0a      	cmp	AL, #10
    5c1a:	1d02      	jne	0x5c20 <_ml_LinModuleVersion+0x2a>
    5c1c:	62e8      	lod	AL, YL
    5c1e:	5401      	ret
    5c20:	7000      	lod	A, #0
    5c22:	5401      	ret

00005c24 <_ml_GetState>:
    5c24:	44a2      	asl	A, #2
    5c26:	44a2      	asl	A, #2
    5c28:	a40c      	or	A, #12
    5c2a:	17c8      	call	0x5bbc <_ml_ContFrame+0x6>
    5c2c:	ac00      	cmp	A, #0
    5c2e:	1d0b      	jne	0x5c46 <_ml_GetState+0x22>
    5c30:	72d8 0000 	lod	A, 0x0 <__dp__>
    5c34:	8c0c      	cmp	AL, #12
    5c36:	1d07      	jne	0x5c46 <_ml_GetState+0x22>
    5c38:	62e4      	lod	AL, AH
    5c3a:	44f4      	asr	AH, #2
    5c3c:	44f4      	asr	AH, #2
    5c3e:	4ad8 a402 	mov	0x2a4 <_LinStatus>, AH
    5c42:	b40f      	and	A, #15
    5c44:	5401      	ret
    5c46:	70ff      	lod	A, #-1
    5c48:	5401      	ret

00005c4a <_ml_SetBaudRate>:
    5c4a:	44a0      	asl	AL, #2
    5c4c:	44a0      	asl	AL, #2
    5c4e:	8402      	or	AL, #2
    5c50:	7a03      	lod	Y, [S-4]
    5c52:	6ae8      	lod	AH, YL
    5c54:	07b3      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005c56 <_ml_SetAutoBaudRateMode>:
    5c56:	6ae0      	lod	AH, AL
    5c58:	6002      	lod	AL, #2
    5c5a:	84e0      	or	AL, #-32
    5c5c:	07af      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005c5e <_ml_Connect>:
    5c5e:	6002      	lod	AL, #2
    5c60:	0008      	jmp	0x5c72 <_ml_GotoSleep+0x4>

00005c62 <_ml_Disconnect>:
    5c62:	6001      	lod	AL, #1
    5c64:	0006      	jmp	0x5c72 <_ml_GotoSleep+0x4>

00005c66 <_ml_SwitchToFast>:
    5c66:	600f      	lod	AL, #15
    5c68:	0004      	jmp	0x5c72 <_ml_GotoSleep+0x4>

00005c6a <_ml_WakeUp>:
    5c6a:	6008      	lod	AL, #8
    5c6c:	0002      	jmp	0x5c72 <_ml_GotoSleep+0x4>

00005c6e <_ml_GotoSleep>:
    5c6e:	6004      	lod	AL, #4
    5c70:	0000      	nop
    5c72:	44a0      	asl	AL, #2
    5c74:	44a0      	asl	AL, #2
    5c76:	8401      	or	AL, #1
    5c78:	07a1      	jmp	0x5bbc <_ml_ContFrame+0x6>

00005c7a <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    5c7a:	60aa      	lod	AL, #-86
    5c7c:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    5c80:	7104      	lod	A, dp:0x4 <_LinMess>
    5c82:	51d2      	mov	dp:0xd2 <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    5c84:	7810      	lod	Y, #16
    5c86:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5c8a:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    5c8c:	ac03      	cmp	A, #3
    5c8e:	1d09      	jne	0x5ca2 <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    5c90:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    5c92:	51c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    5c94:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    5c96:	59ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    5c98:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    5c9a:	51cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    5c9c:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    5c9e:	59ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    5ca0:	1758      	call	0x5b52 <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    5ca2:	6042      	lod	AL, #66
    5ca4:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5ca8:	5401      	ret

00005caa <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    5caa:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5cac:	79d2      	lod	Y, dp:0xd2 <_LinMessage>
    5cae:	72e6      	lod	A, Y
    5cb0:	b40f      	and	A, #15
    5cb2:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    5cb4:	ac07      	cmp	A, #7
    5cb6:	1d07      	jne	0x5cc6 <_ml_ProccessLinEvent+0x1c>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    5cb8:	44b6      	lsr	Y, #2
    5cba:	44b6      	lsr	Y, #2
    5cbc:	72e6      	lod	A, Y
    5cbe:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    5cc0:	82db 78b8 	callf	0x78b8 <_mlu_AutoAddressingStep>
    5cc4:	00c7      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    5cc6:	72e6      	lod	A, Y
    5cc8:	6000      	lod	AL, #0
    5cca:	72e4      	swap	A
    5ccc:	b43f      	and	A, #63
    5cce:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    5cd0:	62d8 00d4 	lod	AL, 0xd4 <_ml_driver_mode>
    5cd4:	8c55      	cmp	AL, #85
    5cd6:	1d01      	jne	0x5cda <_ml_ProccessLinEvent+0x30>
    5cd8:	009d      	jmp	0x5e14 <_ml_ProccessLinEvent+0x16a>
        if (LDR_GetState() == 0) {
    5cda:	82db 66ee 	callf	0x66ee <_LDR_GetState>
    5cde:	8c00      	cmp	AL, #0
    5ce0:	1901      	je	0x5ce4 <_ml_ProccessLinEvent+0x3a>
    5ce2:	006a      	jmp	0x5db8 <_ml_ProccessLinEvent+0x10e>
#endif
            switch(LinCommand) {
    5ce4:	7203      	lod	A, [S-4]
    5ce6:	a0ff      	add	A, #-1
    5ce8:	ac04      	cmp	A, #4
    5cea:	1a01      	jule	0x5cee <_ml_ProccessLinEvent+0x44>
    5cec:	00b3      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
    5cee:	4422      	asl	A
    5cf0:	7ae2      	lod	Y, A
    5cf2:	e2da 6bd0 	add	Y, #27600
    5cf6:	72f0      	lod	A, [Y]
    5cf8:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    5cfa:	79d2      	lod	Y, dp:0xd2 <_LinMessage>
    5cfc:	72e6      	lod	A, Y
    5cfe:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    5d02:	ac40      	cmp	A, #64
    5d04:	1901      	je	0x5d08 <_ml_ProccessLinEvent+0x5e>
    5d06:	00a6      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    5d08:	44c6      	rl	Y, #2
    5d0a:	44c6      	rl	Y, #2
    5d0c:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    5d0e:	72e6      	lod	A, Y
    5d10:	82db 7836 	callf	0x7836 <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    5d14:	009f      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    5d16:	79d2      	lod	Y, dp:0xd2 <_LinMessage>
    5d18:	72e6      	lod	A, Y
    5d1a:	44b2      	lsr	A, #2
    5d1c:	44b2      	lsr	A, #2
    5d1e:	b40f      	and	A, #15
    5d20:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    5d22:	ac05      	cmp	A, #5
    5d24:	1d0e      	jne	0x5d42 <_ml_ProccessLinEvent+0x98>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    5d26:	6400      	lod	YL, #0
    5d28:	7ae8      	swap	Y
    5d2a:	72e6      	lod	A, Y
    5d2c:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    5d2e:	44b6      	lsr	Y, #2
    5d30:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    5d32:	80ff      	add	AL, #-1
    5d34:	8c08      	cmp	AL, #8
    5d36:	1a17      	jule	0x5d66 <_ml_ProccessLinEvent+0xbc>
    5d38:	62e8      	lod	AL, YL
    5d3a:	8c0f      	cmp	AL, #15
    5d3c:	1914      	je	0x5d66 <_ml_ProccessLinEvent+0xbc>
                            Error = ml_erStopBitTX;
    5d3e:	7c10      	lod	X, #16
    5d40:	0012      	jmp	0x5d66 <_ml_ProccessLinEvent+0xbc>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    5d42:	ac0c      	cmp	A, #12
    5d44:	1d05      	jne	0x5d50 <_ml_ProccessLinEvent+0xa6>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    5d46:	44c6      	rl	Y, #2
    5d48:	44c6      	rl	Y, #2
    5d4a:	f40f      	and	Y, #15
                        if(nbytes == 0)
    5d4c:	1d0c      	jne	0x5d66 <_ml_ProccessLinEvent+0xbc>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    5d4e:	0082      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    5d50:	ac02      	cmp	A, #2
    5d52:	1d09      	jne	0x5d66 <_ml_ProccessLinEvent+0xbc>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    5d54:	6400      	lod	YL, #0
    5d56:	7ae8      	swap	Y
    5d58:	72e6      	lod	A, Y
    5d5a:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    5d5c:	8c02      	cmp	AL, #2
    5d5e:	1d03      	jne	0x5d66 <_ml_ProccessLinEvent+0xbc>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    5d60:	1780      	call	0x5c62 <_ml_Disconnect>
                            (void)ml_Connect();
    5d62:	177d      	call	0x5c5e <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    5d64:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    5d66:	72ee      	lod	A, X
    5d68:	82db 7820 	callf	0x7820 <_mlu_ErrorDetected>
                    break;
    5d6c:	0073      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d6e:	7104      	lod	A, dp:0x4 <_LinMess>
    5d70:	52d8 0144 	mov	0x144 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d74:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d76:	42d8 0146 	mov	0x146 <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    5d7a:	6201      	lod	AL, [S-2]
    5d7c:	8c10      	cmp	AL, #16
    5d7e:	1902      	je	0x5d84 <_ml_ProccessLinEvent+0xda>
                        mlu_MessageReceived(LinID); /* notify application */
    5d80:	7201      	lod	A, [S-2]
    5d82:	000a      	jmp	0x5d98 <_ml_ProccessLinEvent+0xee>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    5d84:	54ca 0000 	pushw	#0
    5d88:	72da 00c8 	lod	A, #200
    5d8c:	10b5      	call	0x5ef8 <_ldr_isReadByIdMessage>
    5d8e:	5c01      	dec	S, #2
    5d90:	8c00      	cmp	AL, #0
    5d92:	1901      	je	0x5d96 <_ml_ProccessLinEvent+0xec>
    5d94:	0034      	jmp	0x5dfe <_ml_ProccessLinEvent+0x154>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    5d96:	7010      	lod	A, #16
    5d98:	82db 784e 	callf	0x784e <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    5d9c:	005b      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d9e:	7104      	lod	A, dp:0x4 <_LinMess>
    5da0:	52d8 0144 	mov	0x144 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5da4:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5da6:	42d8 0146 	mov	0x146 <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    5daa:	7201      	lod	A, [S-2]
    5dac:	82db 77c2 	callf	0x77c2 <_mlu_DataRequest>
                    break;
    5db0:	0051      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    5db2:	82db 7812 	callf	0x7812 <_mlu_DataTransmitted>
                    break;
    5db6:	004e      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    5db8:	7203      	lod	A, [S-4]
    5dba:	ac03      	cmp	A, #3
    5dbc:	190d      	je	0x5dd8 <_ml_ProccessLinEvent+0x12e>
    5dbe:	1e03      	jug	0x5dc6 <_ml_ProccessLinEvent+0x11c>
    5dc0:	ac02      	cmp	A, #2
    5dc2:	1905      	je	0x5dce <_ml_ProccessLinEvent+0x124>
    5dc4:	0047      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
    5dc6:	7203      	lod	A, [S-4]
    5dc8:	ac04      	cmp	A, #4
    5dca:	191d      	je	0x5e06 <_ml_ProccessLinEvent+0x15c>
    5dcc:	0043      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5dce:	61d2      	lod	AL, dp:0xd2 <_LinMessage>
    5dd0:	44b2      	lsr	A, #2
    5dd2:	44b2      	lsr	A, #2
    5dd4:	b40f      	and	A, #15
    5dd6:	002f      	jmp	0x5e36 <_ml_ProccessLinEvent+0x18c>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5dd8:	7104      	lod	A, dp:0x4 <_LinMess>
    5dda:	52d8 0144 	mov	0x144 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5dde:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5de0:	42d8 0146 	mov	0x146 <_LINBaud>, AL

                    if (LinID == D_DIA) {
    5de4:	6201      	lod	AL, [S-2]
    5de6:	8c10      	cmp	AL, #16
    5de8:	1901      	je	0x5dec <_ml_ProccessLinEvent+0x142>
    5dea:	0034      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    5dec:	54ca 0001 	pushw	#1
    5df0:	72da 00c8 	lod	A, #200
    5df4:	1081      	call	0x5ef8 <_ldr_isReadByIdMessage>
    5df6:	5c01      	dec	S, #2
    5df8:	8c00      	cmp	AL, #0
    5dfa:	1d01      	jne	0x5dfe <_ml_ProccessLinEvent+0x154>
    5dfc:	002b      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    5dfe:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x3>
    5e00:	5cf2      	usex	A
    5e02:	11ed      	call	0x61de <_ml_ldr_ReadByIdMessage>
    5e04:	0027      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5e06:	7104      	lod	A, dp:0x4 <_LinMess>
    5e08:	52d8 0144 	mov	0x144 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5e0c:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5e0e:	42d8 0146 	mov	0x146 <_LINBaud>, AL
    5e12:	001d      	jmp	0x5e4e <_ml_ProccessLinEvent+0x1a4>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    5e14:	7203      	lod	A, [S-4]
    5e16:	ac03      	cmp	A, #3
    5e18:	1910      	je	0x5e3a <_ml_ProccessLinEvent+0x190>
    5e1a:	1e03      	jug	0x5e22 <_ml_ProccessLinEvent+0x178>
    5e1c:	ac02      	cmp	A, #2
    5e1e:	1907      	je	0x5e2e <_ml_ProccessLinEvent+0x184>
    5e20:	0019      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
    5e22:	7203      	lod	A, [S-4]
    5e24:	ac04      	cmp	A, #4
    5e26:	1913      	je	0x5e4e <_ml_ProccessLinEvent+0x1a4>
    5e28:	ac05      	cmp	A, #5
    5e2a:	1913      	je	0x5e52 <_ml_ProccessLinEvent+0x1a8>
    5e2c:	0013      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5e2e:	44b6      	lsr	Y, #2
    5e30:	44b6      	lsr	Y, #2
    5e32:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    5e34:	72e6      	lod	A, Y
    5e36:	113c      	call	0x60b0 <_ml_ldr_ErrorDetected>
                 break;
    5e38:	000d      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    5e3a:	6201      	lod	AL, [S-2]
    5e3c:	8c10      	cmp	AL, #16
    5e3e:	1d0a      	jne	0x5e54 <_ml_ProccessLinEvent+0x1aa>
    5e40:	61c8      	lod	AL, dp:0xc8 <_LinFrameDataBuffer>
    5e42:	8dd0      	cmp	AL, dp:0xd0 <_LIN_nad>
    5e44:	1902      	je	0x5e4a <_ml_ProccessLinEvent+0x1a0>
    5e46:	8c7f      	cmp	AL, #127
    5e48:	1d05      	jne	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    5e4a:	1217      	call	0x627a <_ml_DiagReceived>
    5e4c:	0003      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    5e4e:	16b1      	call	0x5bb2 <_ml_DiscardFrame>
                 break;
    5e50:	0001      	jmp	0x5e54 <_ml_ProccessLinEvent+0x1aa>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    5e52:	11e1      	call	0x6216 <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    5e54:	60ab      	lod	AL, #-85
    5e56:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    5e5a:	5405      	ret	#6

00005e5c <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    5e5c:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5e60:	7ada 0010 	lod	Y, #16
    5e64:	7eda 72ef 	lod	X, #29423
    5e68:	5ef0      	mov	[Y], X
    5e6a:	7eda e861 	lod	X, #59489
    5e6e:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    5e70:	41d0      	mov	dp:0xd0 <_LIN_nad>, AL
    return ML_SUCCESS;
}
    5e72:	7000      	lod	A, #0
    5e74:	5401      	ret

00005e76 <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    5e76:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    5e78:	5cf2      	usex	A
}
    5e7a:	5401      	ret

00005e7c <_linit>:
 * This function is called whenever an EVENT interrupt from the LIN task (Mlx4)
 * occurs
 */
void __interrupt__ ml_LinInterruptHandler(void);
__MLX_TEXT__  void ml_LinInterruptHandler(void)
{
    5e7c:	52df      	push	A
    5e7e:	5edf      	push	X
    5e80:	5adf      	push	Y
    5e82:	4c83      	push	D
    ml_GetLinEventData();
    5e84:	16fa      	call	0x5c7a <_ml_GetLinEventData>
    ml_ProccessLinEvent();
    5e86:	1711      	call	0x5caa <_ml_ProccessLinEvent>
    5e88:	4cc3      	pop	D
    5e8a:	7acf      	pop	Y
    5e8c:	7ecf      	pop	X
    5e8e:	72cf      	pop	A
    5e90:	4407      	mov	R, #0
    5e92:	72cb      	pop	M
    5e94:	5401      	ret

00005e96 <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    5e96:	82db 66ee 	callf	0x66ee <_LDR_GetState>
    5e9a:	8c00      	cmp	AL, #0
    5e9c:	1d0a      	jne	0x5eb2 <_ml_InitLinModule+0x1c>
    5e9e:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    5ea2:	aeda 3212 	cmp	A, #12818
    5ea6:	1905      	je	0x5eb2 <_ml_InitLinModule+0x1c>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    5ea8:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    5eac:	a410      	or	A, #16
    5eae:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5eb2:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    5eb4:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5eb6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5eb8:	b430      	and	A, #48
    5eba:	1902      	je	0x5ec0 <_ml_InitLinModule+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5ebc:	6000      	lod	AL, #0
    5ebe:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    5ec0:	6084      	lod	AL, #-124
    5ec2:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    5ec6:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5eca:	b404      	and	A, #4
    5ecc:	197c      	je	0x5ec6 <_ml_InitLinModule+0x30>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    5ece:	60ab      	lod	AL, #-85
    5ed0:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    5ed4:	6000      	lod	AL, #0
    5ed6:	42d8 00d4 	mov	0xd4 <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    5eda:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    5ede:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    5ee2:	4cb2 72ef 	cmp	YA, #-396266769
    5ee6:	e861 
    5ee8:	1d03      	jne	0x5ef0 <_ml_InitLinModule+0x5a>
    {
        LIN_nad = stFixedRamNAD.nad;
    5eea:	62d8 0014 	lod	AL, 0x14 <__dp_noinit_size+0x4>
    5eee:	0001      	jmp	0x5ef2 <_ml_InitLinModule+0x5c>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    5ef0:	6001      	lod	AL, #1
    5ef2:	41d0      	mov	dp:0xd0 <_LIN_nad>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    5ef4:	7000      	lod	A, #0
    5ef6:	5401      	ret

00005ef8 <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    5ef8:	5801      	inc	S, #2
    5efa:	7ae2      	lod	Y, A
    5efc:	6205      	lod	AL, [S-6]
    5efe:	5cf2      	usex	A
    5f00:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    5f02:	7ef0      	lod	X, [Y]
    5f04:	2eda 067f 	cmp	X, #1663
    5f08:	1907      	je	0x5f18 <_ldr_isReadByIdMessage+0x20>
    5f0a:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    5f0c:	b6da 06ff 	and	A, #1791
    5f10:	a6da 0600 	or	A, #1536
    5f14:	2ee2      	cmp	X, A
    5f16:	1d15      	jne	0x5f42 <_ldr_isReadByIdMessage+0x4a>
    5f18:	72f2      	lod	A, [Y+2]
    5f1a:	8cb2      	cmp	AL, #-78
    5f1c:	1d12      	jne	0x5f42 <_ldr_isReadByIdMessage+0x4a>
    5f1e:	7ef4      	lod	X, [Y+4]
    5f20:	2c13      	cmp	X, #19
    5f22:	1d04      	jne	0x5f2c <_ldr_isReadByIdMessage+0x34>
    5f24:	72f6      	lod	A, [Y+6]
    5f26:	aeda cafe 	cmp	A, #51966
    5f2a:	1909      	je	0x5f3e <_ldr_isReadByIdMessage+0x46>
    5f2c:	6201      	lod	AL, [S-2]
    5f2e:	8c01      	cmp	AL, #1
    5f30:	1d08      	jne	0x5f42 <_ldr_isReadByIdMessage+0x4a>
    5f32:	2eda 7fff 	cmp	X, #32767
    5f36:	1d05      	jne	0x5f42 <_ldr_isReadByIdMessage+0x4a>
    5f38:	72f6      	lod	A, [Y+6]
    5f3a:	acff      	cmp	A, #-1
    5f3c:	1d02      	jne	0x5f42 <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    5f3e:	7001      	lod	A, #1
    5f40:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    5f42:	7000      	lod	A, #0
    }
}
    5f44:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    5f46:	5801      	inc	S, #2
    5f48:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    5f4a:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    5f4c:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    5f4e:	6003      	lod	AL, #3
    5f50:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    5f52:	607f      	lod	AL, #127
    5f54:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    5f56:	13cb      	call	0x66ee <_LDR_GetState>
    5f58:	8480      	or	AL, #-128
    5f5a:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    5f5c:	61d5      	lod	AL, dp:0xd5 <_ml_driver_mode+0x1>
    5f5e:	8601      	or	AL, [S-2]
    5f60:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    5f62:	60ff      	lod	AL, #-1
    5f64:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    5f66:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL
    LinFrameDataBuffer[7] = 0xFF;
    5f68:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    5f6a:	6000      	lod	AL, #0
    5f6c:	41d5      	mov	dp:0xd5 <_ml_driver_mode+0x1>, AL
    5f6e:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    5f70:	5801      	inc	S, #2
    5f72:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    5f74:	aeda 00f0 	cmp	A, #240
    5f78:	1d02      	jne	0x5f7e <_ldr_isReadByIdMessage+0x86>
    5f7a:	61d5      	lod	AL, dp:0xd5 <_ml_driver_mode+0x1>
    5f7c:	1904      	je	0x5f86 <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    5f7e:	72e6      	lod	A, Y
    5f80:	17e2      	call	0x5f46 <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    5f82:	7000      	lod	A, #0
    5f84:	000e      	jmp	0x5fa2 <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    5f86:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    5f88:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    5f8a:	6002      	lod	AL, #2
    5f8c:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    5f8e:	60f4      	lod	AL, #-12
    5f90:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    5f92:	13ad      	call	0x66ee <_LDR_GetState>
    5f94:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    5f96:	60ff      	lod	AL, #-1
    5f98:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    5f9a:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    5f9c:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL
        LinFrameDataBuffer[7] = 0xFF;
    5f9e:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL
        blReturn = ML_TRUE;
    5fa0:	7001      	lod	A, #1
    5fa2:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    5fa4:	7000      	lod	A, #0
    5fa6:	15dc      	call	0x5b60 <_ml_DataReady>

    return ( blReturn );
}
    5fa8:	7201      	lod	A, [S-2]
    5faa:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    5fac:	5807      	inc	S, #8
    5fae:	660b      	lod	YL, [S-12]
    5fb0:	5cf6      	usex	Y
    5fb2:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    5fb4:	79dc      	lod	Y, dp:0xdc <_ml_driver_mode+0x8>
    5fb6:	e1e4      	add	Y, dp:0xe4 <_ml_driver_mode+0x10>
    5fb8:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    5fba:	7ae2      	lod	Y, A
    5fbc:	e2da 00c8 	add	Y, #200


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    5fc0:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0x10>
    5fc2:	5205      	mov	[S-6], A
    5fc4:	72e6      	lod	A, Y
    5fc6:	a001      	add	A, #1
    5fc8:	5203      	mov	[S-4], A
    5fca:	20ff      	add	X, #-1
    5fcc:	5e01      	mov	[S-2], X
    5fce:	7e05      	lod	X, [S-6]
    5fd0:	2de0      	cmp	X, dp:0xe0 <_ml_driver_mode+0xc>
    5fd2:	1c04      	jnc	0x5fdc <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    5fd4:	7e07      	lod	X, [S-8]
    5fd6:	62de      	lod	AL, [X++]
    5fd8:	5e07      	mov	[S-8], X
    5fda:	0001      	jmp	0x5fde <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    5fdc:	60ff      	lod	AL, #-1
    5fde:	42f0      	mov	[Y], AL
    5fe0:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    5fe2:	7205      	lod	A, [S-6]
    5fe4:	a001      	add	A, #1
    5fe6:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    5fe8:	7e01      	lod	X, [S-2]
    5fea:	1d6a      	jne	0x5fc0 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    5fec:	ade0      	cmp	A, dp:0xe0 <_ml_driver_mode+0xc>
    5fee:	1802      	jc	0x5ff4 <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    5ff0:	7000      	lod	A, #0
    5ff2:	15e1      	call	0x5bb6 <_ml_ContFrame>
    5ff4:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    5ff6:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    5ff8:	61d5      	lod	AL, dp:0xd5 <_ml_driver_mode+0x1>
    5ffa:	1904      	je	0x6004 <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5ffc:	72da 00f0 	lod	A, #240
    6000:	17a2      	call	0x5f46 <_ldr_isReadByIdMessage+0x4e>
    6002:	0039      	jmp	0x6076 <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    6004:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xc>
    6006:	7ae2      	lod	Y, A
    6008:	e002      	add	Y, #2
    600a:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    600c:	ac04      	cmp	A, #4
    600e:	1a17      	jule	0x603e <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    6010:	7001      	lod	A, #1
    6012:	15d1      	call	0x5bb6 <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    6014:	6000      	lod	AL, #0
    6016:	41e6      	mov	dp:0xe6 <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    6018:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    601a:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    601c:	7201      	lod	A, [S-2]
    601e:	b6da 0f00 	and	A, #3840
    6022:	6000      	lod	AL, #0
    6024:	72e4      	swap	A
    6026:	8410      	or	AL, #16
    6028:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    602a:	6601      	lod	YL, [S-2]
    602c:	45ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    602e:	60f4      	lod	AL, #-12
    6030:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    6032:	135d      	call	0x66ee <_LDR_GetState>
    6034:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    6036:	54ca 0003 	pushw	#3
    603a:	7005      	lod	A, #5
    603c:	001a      	jmp	0x6072 <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    603e:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    6040:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    6042:	6201      	lod	AL, [S-2]
    6044:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    6046:	60f4      	lod	AL, #-12
    6048:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    604a:	1351      	call	0x66ee <_LDR_GetState>
    604c:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    604e:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    6050:	aeda bf66 	cmp	A, #48998
    6054:	1d0b      	jne	0x606c <_ldr_isReadByIdMessage+0x174>
    6056:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xc>
    6058:	ac02      	cmp	A, #2
    605a:	1d08      	jne	0x606c <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    605c:	1348      	call	0x66ee <_LDR_GetState>
    605e:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    6060:	6400      	lod	YL, #0
    6062:	45cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    6064:	60ff      	lod	AL, #-1
    6066:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    6068:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL
    606a:	0005      	jmp	0x6076 <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    606c:	54ca 0004 	pushw	#4
    6070:	7004      	lod	A, #4
    6072:	179c      	call	0x5fac <_ldr_isReadByIdMessage+0xb4>
    6074:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    6076:	7000      	lod	A, #0
    6078:	1573      	call	0x5b60 <_ml_DataReady>
    607a:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    607c:	5801      	inc	S, #2
    607e:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    6080:	61d5      	lod	AL, dp:0xd5 <_ml_driver_mode+0x1>
    6082:	1904      	je	0x608c <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    6084:	72da 00f0 	lod	A, #240
    6088:	175e      	call	0x5f46 <_ldr_isReadByIdMessage+0x4e>
    608a:	000f      	jmp	0x60aa <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    608c:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    608e:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    6090:	6006      	lod	AL, #6
    6092:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    6094:	60f4      	lod	AL, #-12
    6096:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    6098:	132a      	call	0x66ee <_LDR_GetState>
    609a:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    609c:	79e0      	lod	Y, dp:0xe0 <_ml_driver_mode+0xc>
    609e:	4dcc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    60a0:	45cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    60a2:	7201      	lod	A, [S-2]
    60a4:	49ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    60a6:	6201      	lod	AL, [S-2]
    60a8:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    60aa:	7000      	lod	A, #0
    60ac:	1559      	call	0x5b60 <_ml_DataReady>
    60ae:	5403      	ret	#4

000060b0 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    60b0:	ac0a      	cmp	A, #10
    60b2:	1901      	je	0x60b6 <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    60b4:	41d5      	mov	dp:0xd5 <_ml_driver_mode+0x1>, AL
    60b6:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    60b8:	5807      	inc	S, #8
    60ba:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    60bc:	61d5      	lod	AL, dp:0xd5 <_ml_driver_mode+0x1>
    60be:	1904      	je	0x60c8 <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    60c0:	72da 00f0 	lod	A, #240
    60c4:	1740      	call	0x5f46 <_ldr_isReadByIdMessage+0x4e>
    60c6:	0040      	jmp	0x6148 <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    60c8:	15cc      	call	0x5c62 <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    60ca:	79dc      	lod	Y, dp:0xdc <_ml_driver_mode+0x8>
    60cc:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    60ce:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    60d0:	7000      	lod	A, #0
    60d2:	5201      	mov	[S-2], A
    60d4:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xc>
    60d6:	5203      	mov	[S-4], A
    60d8:	7000      	lod	A, #0
    60da:	ae03      	cmp	A, [S-4]
    60dc:	1c26      	jnc	0x612a <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    60de:	7ae8      	swap	Y
        crc ^= *data;
    60e0:	7e05      	lod	X, [S-6]
    60e2:	62de      	lod	AL, [X++]
    60e4:	5e05      	mov	[S-6], X
    60e6:	5cf2      	usex	A
    60e8:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    60ea:	62e8      	lod	AL, YL
    60ec:	44b0      	lsr	AL, #2
    60ee:	44b0      	lsr	AL, #2
    60f0:	5cf2      	usex	A
    60f2:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    60f4:	72e6      	lod	A, Y
    60f6:	b40f      	and	A, #15
    60f8:	44d2      	rr	A, #2
    60fa:	44d2      	rr	A, #2
    60fc:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    60fe:	72e6      	lod	A, Y
    6100:	b6da 00ff 	and	A, #255
    6104:	44a2      	asl	A, #2
    6106:	44a2      	asl	A, #2
    6108:	4422      	asl	A
    610a:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    610c:	7201      	lod	A, [S-2]
    610e:	b6da 0fff 	and	A, #4095
    6112:	1d07      	jne	0x6122 <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6114:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    6116:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6118:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    611a:	b430      	and	A, #48
    611c:	1902      	je	0x6122 <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    611e:	6000      	lod	AL, #0
    6120:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    6122:	7201      	lod	A, [S-2]
    6124:	a001      	add	A, #1
    6126:	5201      	mov	[S-2], A
    6128:	07d8      	jmp	0x60da <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    612a:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    612c:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    612e:	6006      	lod	AL, #6
    6130:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    6132:	60f4      	lod	AL, #-12
    6134:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    6136:	60ff      	lod	AL, #-1
    6138:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    613a:	4dcc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    613c:	45cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    613e:	7207      	lod	A, [S-8]
    6140:	49ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    6142:	6607      	lod	YL, [S-8]
    6144:	45cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    6146:	158b      	call	0x5c5e <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    6148:	7000      	lod	A, #0
    614a:	150a      	call	0x5b60 <_ml_DataReady>
    614c:	5409      	ret	#10

0000614e <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    614e:	5801      	inc	S, #2
    6150:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    6152:	12cd      	call	0x66ee <_LDR_GetState>
    6154:	8c00      	cmp	AL, #0
    6156:	1d09      	jne	0x616a <_ml_ldr_SwitchToProgMode+0x1c>
    6158:	82db 778e 	callf	0x778e <_mlu_ApplicationStop>
    615c:	8c00      	cmp	AL, #0
    615e:	1905      	je	0x616a <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    6160:	6000      	lod	AL, #0
    6162:	41d4      	mov	dp:0xd4 <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    6164:	7000      	lod	A, #0
    6166:	14f7      	call	0x5b56 <_ml_ReleaseBufferProg>
    6168:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    616a:	7000      	lod	A, #0
    616c:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    6170:	12be      	call	0x66ee <_LDR_GetState>
    6172:	8c00      	cmp	AL, #0
    6174:	1d0b      	jne	0x618c <_ml_ldr_SwitchToProgMode+0x3e>
    6176:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    617a:	aeda 3212 	cmp	A, #12818
    617e:	1906      	je	0x618c <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    6180:	14e1      	call	0x5b44 <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    6182:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    6186:	a410      	or	A, #16
    6188:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    618c:	6055      	lod	AL, #85
    618e:	41d4      	mov	dp:0xd4 <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    6190:	6000      	lod	AL, #0
    6192:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    6194:	12b7      	call	0x6704 <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    6196:	7001      	lod	A, #1
    6198:	14de      	call	0x5b56 <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    619a:	6201      	lod	AL, [S-2]
    619c:	8c01      	cmp	AL, #1
    619e:	1d0b      	jne	0x61b6 <_ml_ldr_SwitchToProgMode+0x68>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    61a0:	72da 3212 	lod	A, #12818
    61a4:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    61a8:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    61ac:	94fe      	and	AL, #-2
    61ae:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    61b2:	1414      	call	0x59dc <_MLX16_RESET>
            for (;;) {
    61b4:	07ff      	jmp	0x61b4 <_ml_ldr_SwitchToProgMode+0x66>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    61b6:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    61b8:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    61ba:	6006      	lod	AL, #6
    61bc:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    61be:	60f2      	lod	AL, #-14
    61c0:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    61c2:	4cea 0004 	movu	YA, #4
    61c6:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    61c8:	4cea 0401 	movu	YA, #1025
    61cc:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    61ce:	6000      	lod	AL, #0
    61d0:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    61d2:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    61d4:	128c      	call	0x66ee <_LDR_GetState>
    61d6:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    61d8:	7000      	lod	A, #0
    61da:	14c2      	call	0x5b60 <_ml_DataReady>
    61dc:	5403      	ret	#4

000061de <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    61de:	8c33      	cmp	AL, #51
    61e0:	1d03      	jne	0x61e8 <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    61e2:	7001      	lod	A, #1
    61e4:	17b4      	call	0x614e <_ml_ldr_SwitchToProgMode>
    61e6:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    61e8:	ac00      	cmp	A, #0
    61ea:	1d14      	jne	0x6214 <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    61ec:	7001      	lod	A, #1
    61ee:	14b3      	call	0x5b56 <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    61f0:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    61f2:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    61f4:	6006      	lod	AL, #6
    61f6:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    61f8:	60f2      	lod	AL, #-14
    61fa:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    61fc:	6013      	lod	AL, #19
    61fe:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    6200:	6000      	lod	AL, #0
    6202:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    6204:	60fe      	lod	AL, #-2
    6206:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    6208:	60ca      	lod	AL, #-54
    620a:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    620c:	6001      	lod	AL, #1
    620e:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6210:	7000      	lod	A, #0
    6212:	14a6      	call	0x5b60 <_ml_DataReady>
    6214:	5401      	ret

00006216 <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    6216:	61e7      	lod	AL, dp:0xe7 <_ml_driver_mode+0x13>
    6218:	8c03      	cmp	AL, #3
    621a:	1d15      	jne	0x6246 <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    621c:	7000      	lod	A, #0
    621e:	14cb      	call	0x5bb6 <_ml_ContFrame>
            (void)ml_Disconnect();
    6220:	1520      	call	0x5c62 <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    6222:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x4>
    6224:	5cf2      	usex	A
    6226:	1387      	call	0x6936 <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6228:	54ca 0000 	pushw	#0
    622c:	54ca 0001 	pushw	#1
    6230:	54ca 0000 	pushw	#0
    6234:	7001      	lod	A, #1
    6236:	14b2      	call	0x5b9c <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    6238:	7001      	lod	A, #1
    623a:	14ac      	call	0x5b94 <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    623c:	1514      	call	0x5c66 <_ml_SwitchToFast>
            pendingAction = 0;
    623e:	6000      	lod	AL, #0
    6240:	41e7      	mov	dp:0xe7 <_ml_driver_mode+0x13>, AL
            break;
    6242:	5c05      	dec	S, #6
    6244:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    6246:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    6248:	8c06      	cmp	AL, #6
    624a:	1902      	je	0x6250 <_ml_DiagRequest+0x3a>
    624c:	8c08      	cmp	AL, #8
    624e:	1d14      	jne	0x6278 <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    6250:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0x10>
    6252:	ade0      	cmp	A, dp:0xe0 <_ml_driver_mode+0xc>
    6254:	1c11      	jnc	0x6278 <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    6256:	61e6      	lod	AL, dp:0xe6 <_ml_driver_mode+0x12>
    6258:	8001      	add	AL, #1
    625a:	66e0      	lod	YL, AL
    625c:	41e6      	mov	dp:0xe6 <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    625e:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    6260:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    6262:	62e8      	lod	AL, YL
    6264:	940f      	and	AL, #15
    6266:	8420      	or	AL, #32
    6268:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    626a:	54ca 0006 	pushw	#6
    626e:	7002      	lod	A, #2
    6270:	169d      	call	0x5fac <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6272:	7000      	lod	A, #0
    6274:	1475      	call	0x5b60 <_ml_DataReady>
    6276:	5c01      	dec	S, #2
    6278:	5401      	ret

0000627a <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    627a:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    627c:	61c9      	lod	AL, dp:0xc9 <_LinFrameDataBuffer+0x1>
    627e:	5cf2      	usex	A
    6280:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    6282:	b6da 00f0 	and	A, #240
    6286:	ac20      	cmp	A, #32
    6288:	1901      	je	0x628c <_ml_DiagReceived+0x12>
    628a:	0073      	jmp	0x6372 <_ml_DiagReceived+0xf8>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    628c:	7a0b      	lod	Y, [S-12]
    628e:	f40f      	and	Y, #15
    6290:	61e6      	lod	AL, dp:0xe6 <_ml_driver_mode+0x12>
    6292:	4209      	mov	[S-10], AL
    6294:	b40f      	and	A, #15
    6296:	eee2      	cmp	Y, A
    6298:	1901      	je	0x629c <_ml_DiagReceived+0x22>
    629a:	0067      	jmp	0x636a <_ml_DiagReceived+0xf0>
                ddFrameCounter += 1;
    629c:	6209      	lod	AL, [S-10]
    629e:	8001      	add	AL, #1
    62a0:	41e6      	mov	dp:0xe6 <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    62a2:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    62a4:	8c85      	cmp	AL, #-123
    62a6:	1901      	je	0x62aa <_ml_DiagReceived+0x30>
    62a8:	003d      	jmp	0x6324 <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62aa:	7800      	lod	Y, #0
    62ac:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    62ae:	79e4      	lod	Y, dp:0xe4 <_ml_driver_mode+0x10>
    62b0:	ede0      	cmp	Y, dp:0xe0 <_ml_driver_mode+0xc>
    62b2:	1c0a      	jnc	0x62c8 <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    62b4:	71de      	lod	A, dp:0xde <_ml_driver_mode+0xa>
    62b6:	a2e6      	add	A, Y
    62b8:	7a0d      	lod	Y, [S-14]
    62ba:	e2da 00ca 	add	Y, #202
    62be:	66f0      	lod	YL, [Y]
    62c0:	5cf6      	usex	Y
    62c2:	5adf      	push	Y
    62c4:	1256      	call	0x6772 <_Flash_PageBufferFill>
    62c6:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    62c8:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0x10>
    62ca:	a001      	add	A, #1
    62cc:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62ce:	7a0d      	lod	Y, [S-14]
    62d0:	e001      	add	Y, #1
    62d2:	5a0d      	mov	[S-14], Y
    62d4:	ec05      	cmp	Y, #5
    62d6:	1a6b      	jule	0x62ae <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    62d8:	ade0      	cmp	A, dp:0xe0 <_ml_driver_mode+0xc>
    62da:	1c01      	jnc	0x62de <_ml_DiagReceived+0x64>
    62dc:	01f7      	jmp	0x66cc <_ml_DiagReceived+0x452>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    62de:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    62e0:	1318      	call	0x6912 <_Flash_PageWriteFiltered>
    62e2:	51da      	mov	dp:0xda <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    62e4:	ac00      	cmp	A, #0
    62e6:	1901      	je	0x62ea <_ml_DiagReceived+0x70>
    62e8:	0042      	jmp	0x636e <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    62ea:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0x10>
    62ec:	79e2      	lod	Y, dp:0xe2 <_ml_driver_mode+0xe>
    62ee:	aee6      	cmp	A, Y
    62f0:	1c15      	jnc	0x631c <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    62f2:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    62f4:	7ee2      	lod	X, A
    62f6:	22da 0080 	add	X, #128
    62fa:	5ddc      	mov	dp:0xdc <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    62fc:	7000      	lod	A, #0
    62fe:	51de      	mov	dp:0xde <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    6300:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    6302:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    6304:	eeda 0080 	cmp	Y, #128
    6308:	1a03      	jule	0x6310 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    630a:	72da 0080 	lod	A, #128
    630e:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    6310:	72e6      	lod	A, Y
    6312:	a9e0      	sub	A, dp:0xe0 <_ml_driver_mode+0xc>
    6314:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    6316:	72ee      	lod	A, X
    6318:	121d      	call	0x6754 <_Flash_PageRead>
    631a:	0029      	jmp	0x636e <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    631c:	7800      	lod	Y, #0
    631e:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    6320:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xe>, Y
    6322:	0025      	jmp	0x636e <_ml_DiagReceived+0xf4>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    6324:	8c47      	cmp	AL, #71
    6326:	1d23      	jne	0x636e <_ml_DiagReceived+0xf4>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6328:	7000      	lod	A, #0
    632a:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    632c:	79e4      	lod	Y, dp:0xe4 <_ml_driver_mode+0x10>
    632e:	ede0      	cmp	Y, dp:0xe0 <_ml_driver_mode+0xc>
    6330:	1c0b      	jnc	0x6348 <_ml_DiagReceived+0xce>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    6332:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    6334:	a2e6      	add	A, Y
    6336:	7a0d      	lod	Y, [S-14]
    6338:	e2da 00ca 	add	Y, #202
    633c:	66f0      	lod	YL, [Y]
    633e:	5cf6      	usex	Y
    6340:	5adf      	push	Y
    6342:	82db 5b1a 	callf	0x5b1a <_NVRAM_BufferFill>
    6346:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6348:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0x10>
    634a:	a001      	add	A, #1
    634c:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    634e:	7a0d      	lod	Y, [S-14]
    6350:	e001      	add	Y, #1
    6352:	5a0d      	mov	[S-14], Y
    6354:	ec05      	cmp	Y, #5
    6356:	1a6a      	jule	0x632c <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6358:	ade0      	cmp	A, dp:0xe0 <_ml_driver_mode+0xc>
    635a:	1c01      	jnc	0x635e <_ml_DiagReceived+0xe4>
    635c:	01b7      	jmp	0x66cc <_ml_DiagReceived+0x452>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    635e:	82db 5b44 	callf	0x5b44 <_NVRAM_SaveAll>
                        ddDataSize = 0;
    6362:	7000      	lod	A, #0
    6364:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    6366:	1427      	call	0x5bb6 <_ml_ContFrame>
    6368:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    636a:	6400      	lod	YL, #0
    636c:	45d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    636e:	7000      	lod	A, #0
    6370:	07fa      	jmp	0x6366 <_ml_DiagReceived+0xec>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    6372:	ac10      	cmp	A, #16
    6374:	1901      	je	0x6378 <_ml_DiagReceived+0xfe>
    6376:	0041      	jmp	0x63fa <_ml_DiagReceived+0x180>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    6378:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    637a:	8cb4      	cmp	AL, #-76
    637c:	1901      	je	0x6380 <_ml_DiagReceived+0x106>
    637e:	01a0      	jmp	0x66c0 <_ml_DiagReceived+0x446>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    6380:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x4>
    6382:	8cd3      	cmp	AL, #-45
    6384:	1901      	je	0x6388 <_ml_DiagReceived+0x10e>
    6386:	019c      	jmp	0x66c0 <_ml_DiagReceived+0x446>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    6388:	6001      	lod	AL, #1
    638a:	41e6      	mov	dp:0xe6 <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    638c:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    638e:	8c85      	cmp	AL, #-123
    6390:	1d14      	jne	0x63ba <_ml_DiagReceived+0x140>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    6392:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x5>
    6394:	5cf2      	usex	A
    6396:	52df      	push	A
    6398:	71de      	lod	A, dp:0xde <_ml_driver_mode+0xa>
    639a:	11eb      	call	0x6772 <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    639c:	71de      	lod	A, dp:0xde <_ml_driver_mode+0xa>
    639e:	a001      	add	A, #1
    63a0:	65ce      	lod	YL, dp:0xce <_LinFrameDataBuffer+0x6>
    63a2:	5cf6      	usex	Y
    63a4:	5adf      	push	Y
    63a6:	11e5      	call	0x6772 <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    63a8:	71de      	lod	A, dp:0xde <_ml_driver_mode+0xa>
    63aa:	a002      	add	A, #2
    63ac:	65cf      	lod	YL, dp:0xcf <_LinFrameDataBuffer+0x7>
    63ae:	5cf6      	usex	Y
    63b0:	5adf      	push	Y
    63b2:	11df      	call	0x6772 <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    63b4:	7003      	lod	A, #3
    63b6:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, A
    63b8:	0018      	jmp	0x63ea <_ml_DiagReceived+0x170>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    63ba:	8c47      	cmp	AL, #71
    63bc:	1d1b      	jne	0x63f4 <_ml_DiagReceived+0x17a>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    63be:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x5>
    63c0:	5cf2      	usex	A
    63c2:	52df      	push	A
    63c4:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    63c6:	82db 5b1a 	callf	0x5b1a <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    63ca:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    63cc:	a001      	add	A, #1
    63ce:	65ce      	lod	YL, dp:0xce <_LinFrameDataBuffer+0x6>
    63d0:	5cf6      	usex	Y
    63d2:	5adf      	push	Y
    63d4:	82db 5b1a 	callf	0x5b1a <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    63d8:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    63da:	a002      	add	A, #2
    63dc:	65cf      	lod	YL, dp:0xcf <_LinFrameDataBuffer+0x7>
    63de:	5cf6      	usex	Y
    63e0:	5adf      	push	Y
    63e2:	82db 5b1a 	callf	0x5b1a <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    63e6:	7803      	lod	Y, #3
    63e8:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    63ea:	7001      	lod	A, #1
    63ec:	82db 5bb6 	callf	0x5bb6 <_ml_ContFrame>
    63f0:	5c05      	dec	S, #6
    63f2:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    63f4:	7020      	lod	A, #32
    63f6:	15bc      	call	0x5f70 <_ldr_isReadByIdMessage+0x78>
    63f8:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    63fa:	620b      	lod	AL, [S-12]
    63fc:	94f0      	and	AL, #-16
    63fe:	1901      	je	0x6402 <_ml_DiagReceived+0x188>
    6400:	0162      	jmp	0x66c6 <_ml_DiagReceived+0x44c>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    6402:	7000      	lod	A, #0
    6404:	82db 5bb6 	callf	0x5bb6 <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    6408:	720b      	lod	A, [S-12]
    640a:	b40f      	and	A, #15
    640c:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    640e:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    6410:	8cb4      	cmp	AL, #-76
    6412:	190d      	je	0x642e <_ml_DiagReceived+0x1b4>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    6414:	54ca 0001 	pushw	#1
    6418:	72da 00c8 	lod	A, #200
    641c:	156d      	call	0x5ef8 <_ldr_isReadByIdMessage>
    641e:	5c01      	dec	S, #2
    6420:	8c00      	cmp	AL, #0
    6422:	1d01      	jne	0x6426 <_ml_DiagReceived+0x1ac>
    6424:	014d      	jmp	0x66c0 <_ml_DiagReceived+0x446>
                ml_ldr_ReadByIdMessage(Data[0]);
    6426:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x3>
    6428:	5cf2      	usex	A
    642a:	16d9      	call	0x61de <_ml_ldr_ReadByIdMessage>
    642c:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    642e:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x3>
    6430:	4207      	mov	[S-8], AL
    6432:	8cd3      	cmp	AL, #-45
    6434:	190a      	je	0x644a <_ml_DiagReceived+0x1d0>
    6436:	8c80      	cmp	AL, #-128
    6438:	1908      	je	0x644a <_ml_DiagReceived+0x1d0>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    643a:	69cc      	lod	AH, dp:0xcc <_LinFrameDataBuffer+0x4>
    643c:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x5>
    643e:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    6440:	69ce      	lod	AH, dp:0xce <_LinFrameDataBuffer+0x6>
    6442:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x7>
    6444:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    6446:	7800      	lod	Y, #0
    6448:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    644a:	6607      	lod	YL, [S-8]
    644c:	5cf6      	usex	Y
    644e:	72e6      	lod	A, Y
    6450:	b420      	and	A, #32
    6452:	1929      	je	0x64a6 <_ml_DiagReceived+0x22c>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    6454:	72e6      	lod	A, Y
    6456:	b430      	and	A, #48
    6458:	ac20      	cmp	A, #32
    645a:	1d18      	jne	0x648c <_ml_DiagReceived+0x212>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    645c:	6085      	lod	AL, #-123
    645e:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    6460:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    6462:	7ae2      	lod	Y, A
    6464:	f47f      	and	Y, #127
    6466:	59de      	mov	dp:0xde <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    6468:	b480      	and	A, #-128
    646a:	5205      	mov	[S-6], A
    646c:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    646e:	7de0      	lod	X, dp:0xe0 <_ml_driver_mode+0xc>
    6470:	5de2      	mov	dp:0xe2 <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    6472:	72da 0080 	lod	A, #128
    6476:	aae6      	sub	A, Y
    6478:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    647a:	aeee      	cmp	A, X
    647c:	1a01      	jule	0x6480 <_ml_DiagReceived+0x206>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    647e:	5de0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    6480:	7205      	lod	A, [S-6]
    6482:	1158      	call	0x6734 <_Flash_GetWriteTime>
    6484:	15fb      	call	0x607c <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    6486:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    6488:	1165      	call	0x6754 <_Flash_PageRead>
    648a:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    648c:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    648e:	8cd6      	cmp	AL, #-42
    6490:	1901      	je	0x6494 <_ml_DiagReceived+0x21a>
    6492:	0087      	jmp	0x65a2 <_ml_DiagReceived+0x328>
    6494:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x3>
    6496:	1901      	je	0x649a <_ml_DiagReceived+0x220>
    6498:	0084      	jmp	0x65a2 <_ml_DiagReceived+0x328>
    649a:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x4>
    649c:	8c01      	cmp	AL, #1
    649e:	1901      	je	0x64a2 <_ml_DiagReceived+0x228>
    64a0:	0080      	jmp	0x65a2 <_ml_DiagReceived+0x328>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    64a2:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xc>
    64a4:	0106      	jmp	0x66b2 <_ml_DiagReceived+0x438>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    64a6:	eeda 0080 	cmp	Y, #128
    64aa:	1d01      	jne	0x64ae <_ml_DiagReceived+0x234>
    64ac:	002d      	jmp	0x6508 <_ml_DiagReceived+0x28e>
    64ae:	1f0c      	jsg	0x64c8 <_ml_DiagReceived+0x24e>
    64b0:	ec08      	cmp	Y, #8
    64b2:	1d01      	jne	0x64b6 <_ml_DiagReceived+0x23c>
    64b4:	0065      	jmp	0x6580 <_ml_DiagReceived+0x306>
    64b6:	1f04      	jsg	0x64c0 <_ml_DiagReceived+0x246>
    64b8:	ec03      	cmp	Y, #3
    64ba:	1d01      	jne	0x64be <_ml_DiagReceived+0x244>
    64bc:	0039      	jmp	0x6530 <_ml_DiagReceived+0x2b6>
    64be:	0100      	jmp	0x66c0 <_ml_DiagReceived+0x446>
    64c0:	ec47      	cmp	Y, #71
    64c2:	1d01      	jne	0x64c6 <_ml_DiagReceived+0x24c>
    64c4:	0059      	jmp	0x6578 <_ml_DiagReceived+0x2fe>
    64c6:	00fc      	jmp	0x66c0 <_ml_DiagReceived+0x446>
    64c8:	eeda 00c1 	cmp	Y, #193
    64cc:	190f      	je	0x64ec <_ml_DiagReceived+0x272>
    64ce:	1f05      	jsg	0x64da <_ml_DiagReceived+0x260>
    64d0:	eeda 0092 	cmp	Y, #146
    64d4:	1d01      	jne	0x64d8 <_ml_DiagReceived+0x25e>
    64d6:	0059      	jmp	0x658a <_ml_DiagReceived+0x310>
    64d8:	00f3      	jmp	0x66c0 <_ml_DiagReceived+0x446>
    64da:	eeda 00d3 	cmp	Y, #211
    64de:	1d01      	jne	0x64e2 <_ml_DiagReceived+0x268>
    64e0:	0063      	jmp	0x65a8 <_ml_DiagReceived+0x32e>
    64e2:	eeda 00d6 	cmp	Y, #214
    64e6:	1d01      	jne	0x64ea <_ml_DiagReceived+0x270>
    64e8:	00c6      	jmp	0x6676 <_ml_DiagReceived+0x3fc>
    64ea:	00ea      	jmp	0x66c0 <_ml_DiagReceived+0x446>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    64ec:	1100      	call	0x66ee <_LDR_GetState>
    64ee:	66e0      	lod	YL, AL
    64f0:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x4>
    64f2:	8ee8      	cmp	AL, YL
    64f4:	1d01      	jne	0x64f8 <_ml_DiagReceived+0x27e>
    64f6:	00ea      	jmp	0x66cc <_ml_DiagReceived+0x452>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    64f8:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    64fc:	94fe      	and	AL, #-2
    64fe:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    6502:	82db 59dc 	callf	0x59dc <_MLX16_RESET>
                            }
                            break;
    6506:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    6508:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    650a:	8c85      	cmp	AL, #-123
    650c:	1d09      	jne	0x6520 <_ml_DiagReceived+0x2a6>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    650e:	71da      	lod	A, dp:0xda <_ml_driver_mode+0x6>
    6510:	1d05      	jne	0x651c <_ml_DiagReceived+0x2a2>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    6512:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xc>
    6514:	1901      	je	0x6518 <_ml_DiagReceived+0x29e>
    6516:	076e      	jmp	0x63f4 <_ml_DiagReceived+0x17a>
                                        ddCurrentOp = 0;            /* operation done */
    6518:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
    651a:	0007      	jmp	0x652a <_ml_DiagReceived+0x2b0>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    651c:	7050      	lod	A, #80
    651e:	076b      	jmp	0x63f6 <_ml_DiagReceived+0x17c>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6520:	8c47      	cmp	AL, #71
    6522:	1901      	je	0x6526 <_ml_DiagReceived+0x2ac>
    6524:	00b6      	jmp	0x6692 <_ml_DiagReceived+0x418>
                                ddCurrentOp = 0;                /* operation done */
    6526:	6400      	lod	YL, #0
    6528:	45d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    652a:	7000      	lod	A, #0
    652c:	15a7      	call	0x607c <_ldr_isReadByIdMessage+0x184>
    652e:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    6530:	620b      	lod	AL, [S-12]
    6532:	8c03      	cmp	AL, #3
    6534:	1d08      	jne	0x6546 <_ml_DiagReceived+0x2cc>
                                peCurrentValue = Data[1];
    6536:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x4>
    6538:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    653a:	8c64      	cmp	AL, #100
    653c:	1e04      	jug	0x6546 <_ml_DiagReceived+0x2cc>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    653e:	8c12      	cmp	AL, #18
    6540:	1e04      	jug	0x654a <_ml_DiagReceived+0x2d0>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    6542:	6013      	lod	AL, #19
    6544:	0001      	jmp	0x6548 <_ml_DiagReceived+0x2ce>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    6546:	6064      	lod	AL, #100
    6548:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    654a:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    654c:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    654e:	6403      	lod	YL, #3
    6550:	45c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    6552:	60f4      	lod	AL, #-12
    6554:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    6556:	10cb      	call	0x66ee <_LDR_GetState>
    6558:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    655a:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x4>
    655c:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    655e:	60ff      	lod	AL, #-1
    6560:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    6562:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    6564:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x7>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    6566:	7000      	lod	A, #0
    6568:	82db 5b60 	callf	0x5b60 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    656c:	7001      	lod	A, #1
    656e:	82db 5bb6 	callf	0x5bb6 <_ml_ContFrame>
                            pendingAction = ddFastProt;
    6572:	6003      	lod	AL, #3
    6574:	41e7      	mov	dp:0xe7 <_ml_driver_mode+0x13>, AL
                            break;
    6576:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    6578:	45d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    657a:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
    657e:	07d5      	jmp	0x652a <_ml_DiagReceived+0x2b0>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    6580:	45d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    6582:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    6586:	1537      	call	0x5ff6 <_ldr_isReadByIdMessage+0xfe>
                            break;
    6588:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    658a:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    658c:	6000      	lod	AL, #0
    658e:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    6590:	ac08      	cmp	A, #8
    6592:	1902      	je	0x6598 <_ml_DiagReceived+0x31e>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    6594:	7010      	lod	A, #16
    6596:	072f      	jmp	0x63f6 <_ml_DiagReceived+0x17c>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    6598:	7801      	lod	Y, #1
    659a:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    659c:	72da 6bdc 	lod	A, #27612
    65a0:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    65a2:	6006      	lod	AL, #6
    65a4:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
    65a6:	07ef      	jmp	0x6586 <_ml_DiagReceived+0x30c>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    65a8:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode+0x2>
    65aa:	8c85      	cmp	AL, #-123
    65ac:	1901      	je	0x65b0 <_ml_DiagReceived+0x336>
    65ae:	0042      	jmp	0x6634 <_ml_DiagReceived+0x3ba>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    65b0:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    65b2:	a1de      	add	A, dp:0xde <_ml_driver_mode+0xa>
    65b4:	aeda bf66 	cmp	A, #48998
    65b8:	1d24      	jne	0x6602 <_ml_DiagReceived+0x388>
    65ba:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xe>
    65bc:	ac02      	cmp	A, #2
    65be:	1d21      	jne	0x6602 <_ml_DiagReceived+0x388>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    65c0:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x4>
    65c2:	5cf2      	usex	A

                                    switch (new_state) {
    65c4:	1903      	je	0x65cc <_ml_DiagReceived+0x352>
    65c6:	ac01      	cmp	A, #1
    65c8:	190d      	je	0x65e4 <_ml_DiagReceived+0x36a>
    65ca:	0051      	jmp	0x666e <_ml_DiagReceived+0x3f4>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    65cc:	72da be84 	lod	A, #48772
    65d0:	10c1      	call	0x6754 <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    65d2:	72da be84 	lod	A, #48772
    65d6:	b47f      	and	A, #127
    65d8:	54ca 0001 	pushw	#1
    65dc:	10ca      	call	0x6772 <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    65de:	72da be84 	lod	A, #48772
    65e2:	000b      	jmp	0x65fa <_ml_DiagReceived+0x380>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    65e4:	72da be80 	lod	A, #48768
    65e8:	10b5      	call	0x6754 <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    65ea:	72da be80 	lod	A, #48768
    65ee:	b47f      	and	A, #127
    65f0:	54ca 0001 	pushw	#1
    65f4:	10be      	call	0x6772 <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    65f6:	72da be80 	lod	A, #48768
    65fa:	10d3      	call	0x67a2 <_Flash_PageWrite>
    65fc:	51da      	mov	dp:0xda <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    65fe:	5c01      	dec	S, #2
    6600:	0036      	jmp	0x666e <_ml_DiagReceived+0x3f4>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6602:	7800      	lod	Y, #0
    6604:	5a0d      	mov	[S-14], Y
    6606:	20fe      	add	X, #-2
    6608:	5e03      	mov	[S-4], X
    660a:	eeee      	cmp	Y, X
    660c:	1c0f      	jnc	0x662c <_ml_DiagReceived+0x3b2>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    660e:	71de      	lod	A, dp:0xde <_ml_driver_mode+0xa>
    6610:	a20d      	add	A, [S-14]
    6612:	7a0d      	lod	Y, [S-14]
    6614:	e2da 00cc 	add	Y, #204
    6618:	66f0      	lod	YL, [Y]
    661a:	5cf6      	usex	Y
    661c:	5adf      	push	Y
    661e:	10a9      	call	0x6772 <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6620:	5c01      	dec	S, #2
    6622:	720d      	lod	A, [S-14]
    6624:	a001      	add	A, #1
    6626:	520d      	mov	[S-14], A
    6628:	ae03      	cmp	A, [S-4]
    662a:	1871      	jc	0x660e <_ml_DiagReceived+0x394>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    662c:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    662e:	1171      	call	0x6912 <_Flash_PageWriteFiltered>
    6630:	51da      	mov	dp:0xda <_ml_driver_mode+0x6>, A
    6632:	001d      	jmp	0x666e <_ml_DiagReceived+0x3f4>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6634:	8c47      	cmp	AL, #71
    6636:	1d19      	jne	0x666a <_ml_DiagReceived+0x3f0>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6638:	7800      	lod	Y, #0
    663a:	5a0d      	mov	[S-14], Y
    663c:	20fe      	add	X, #-2
    663e:	5e01      	mov	[S-2], X
    6640:	eeee      	cmp	Y, X
    6642:	1c10      	jnc	0x6664 <_ml_DiagReceived+0x3ea>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    6644:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x8>
    6646:	a20d      	add	A, [S-14]
    6648:	7a0d      	lod	Y, [S-14]
    664a:	e2da 00cc 	add	Y, #204
    664e:	66f0      	lod	YL, [Y]
    6650:	5cf6      	usex	Y
    6652:	5adf      	push	Y
    6654:	82db 5b1a 	callf	0x5b1a <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6658:	5c01      	dec	S, #2
    665a:	720d      	lod	A, [S-14]
    665c:	a001      	add	A, #1
    665e:	520d      	mov	[S-14], A
    6660:	ae01      	cmp	A, [S-2]
    6662:	1870      	jc	0x6644 <_ml_DiagReceived+0x3ca>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    6664:	82db 5b44 	callf	0x5b44 <_NVRAM_SaveAll>
    6668:	0002      	jmp	0x666e <_ml_DiagReceived+0x3f4>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    666a:	7020      	lod	A, #32
    666c:	1481      	call	0x5f70 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    666e:	7800      	lod	Y, #0
    6670:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    6672:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    6674:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    6676:	60d6      	lod	AL, #-42
    6678:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    667a:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x4>
    667c:	41d7      	mov	dp:0xd7 <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    667e:	1d0c      	jne	0x6698 <_ml_DiagReceived+0x41e>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    6680:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x5>
    6682:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    6684:	5cf2      	usex	A
    6686:	1903      	je	0x668e <_ml_DiagReceived+0x414>
    6688:	ac01      	cmp	A, #1
    668a:	1903      	je	0x6692 <_ml_DiagReceived+0x418>
    668c:	0017      	jmp	0x66bc <_ml_DiagReceived+0x442>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    668e:	6000      	lod	AL, #0
    6690:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    6692:	72da 00f0 	lod	A, #240
    6696:	06af      	jmp	0x63f6 <_ml_DiagReceived+0x17c>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    6698:	8c01      	cmp	AL, #1
    669a:	1d10      	jne	0x66bc <_ml_DiagReceived+0x442>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    669c:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x5>
    669e:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    66a0:	1d0a      	jne	0x66b6 <_ml_DiagReceived+0x43c>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    66a2:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x6>
    66a4:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    66a6:	1111      	call	0x68ca <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    66a8:	7ada 4000 	lod	Y, #16384
    66ac:	59dc      	mov	dp:0xdc <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    66ae:	7800      	lod	Y, #0
    66b0:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    66b2:	1502      	call	0x60b8 <_ml_ldr_ErrorDetected+0x8>
                                    break;
    66b4:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    66b6:	6000      	lod	AL, #0
    66b8:	41d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, AL
    66ba:	0002      	jmp	0x66c0 <_ml_DiagReceived+0x446>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    66bc:	6400      	lod	YL, #0
    66be:	45d6      	mov	dp:0xd6 <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    66c0:	72da 00d0 	lod	A, #208
    66c4:	0698      	jmp	0x63f6 <_ml_DiagReceived+0x17c>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    66c6:	72da 00b0 	lod	A, #176
    66ca:	1452      	call	0x5f70 <_ldr_isReadByIdMessage+0x78>
    66cc:	540f      	ret	#16

000066ce <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    66ce:	82db 5e96 	callf	0x5e96 <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    66d2:	54ca 0000 	pushw	#0
    66d6:	54ca 0001 	pushw	#1
    66da:	54ca 0000 	pushw	#0
    66de:	7001      	lod	A, #1
    66e0:	82db 5b9c 	callf	0x5b9c <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    66e4:	7000      	lod	A, #0
    66e6:	82db 5b94 	callf	0x5b94 <_ml_SetSlewRate>
    66ea:	5c05      	dec	S, #6
    66ec:	5401      	ret

000066ee <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    66ee:	7ada be80 	lod	Y, #48768
    66f2:	62f0      	lod	AL, [Y]
    66f4:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    66f8:	66e0      	lod	YL, AL
    66fa:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    66fe:	a2e6      	add	A, Y
    6700:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    6702:	5401      	ret

00006704 <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    6704:	17f4      	call	0x66ee <_LDR_GetState>
    6706:	8c03      	cmp	AL, #3
    6708:	1d03      	jne	0x6710 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    670a:	72da 8000 	lod	A, #32768
    670e:	0001      	jmp	0x6712 <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    6710:	7000      	lod	A, #0
    6712:	52d8 02a8 	mov	0x2a8 <_page_buffer+0x2>, A
    6716:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    6718:	a2da c000 	add	A, #49152
    671c:	72e4      	swap	A
    671e:	b6da 00ff 	and	A, #255
    6722:	44b2      	lsr	A, #2
    6724:	4432      	lsr	A
}
    6726:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    6728:	44e2      	sfb	A
    672a:	b6d8 02a8 	and	A, 0x2a8 <_page_buffer+0x2>
    672e:	1901      	je	0x6732 <_Flash_InitDriver+0x2e>
    6730:	7001      	lod	A, #1
}
    6732:	5401      	ret

00006734 <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    6734:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    6736:	17f0      	call	0x6718 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    6738:	17f7      	call	0x6728 <_Flash_InitDriver+0x24>
    673a:	8c00      	cmp	AL, #0
    673c:	1d09      	jne	0x6750 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    673e:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    6742:	8c01      	cmp	AL, #1
    6744:	1a02      	jule	0x674a <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    6746:	7030      	lod	A, #48
    6748:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    674a:	72da 02a6 	lod	A, #678
    674e:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    6750:	7006      	lod	A, #6
    }

    return wr_time;
}
    6752:	5401      	ret

00006754 <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    6754:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    6756:	b480      	and	A, #-128
    6758:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    675a:	7ed8 02a6 	lod	X, 0x2a6 <_page_buffer>
    675e:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    6760:	7a03      	lod	Y, [S-4]
    6762:	54c6      	movsw	[X++], [Y++]
    6764:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    6766:	7201      	lod	A, [S-2]
    6768:	a2da 0080 	add	A, #128
    676c:	2ee2      	cmp	X, A
    676e:	1878      	jc	0x6760 <_Flash_PageRead+0xc>
    6770:	5405      	ret	#6

00006772 <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    6772:	b47f      	and	A, #127
    6774:	7ae2      	lod	Y, A
    6776:	e2d8 02a6 	add	Y, 0x2a6 <_page_buffer>
    677a:	6203      	lod	AL, [S-4]
    677c:	42f0      	mov	[Y], AL
    677e:	5401      	ret

00006780 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    6780:	b480      	and	A, #-128
    6782:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    6784:	7ad8 02a6 	lod	Y, 0x2a6 <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    6788:	72d6      	lod	A, [Y++]
    678a:	aede      	cmp	A, [X++]
    678c:	1902      	je	0x6792 <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    678e:	7001      	lod	A, #1
    6790:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    6792:	72d8 02a6 	lod	A, 0x2a6 <_page_buffer>
    6796:	a2da 0080 	add	A, #128
    679a:	eee2      	cmp	Y, A
    679c:	1875      	jc	0x6788 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    679e:	7000      	lod	A, #0
}
    67a0:	5401      	ret

000067a2 <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    67a2:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    67a4:	b480      	and	A, #-128
    67a6:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    67a8:	17a2      	call	0x66ee <_LDR_GetState>
    67aa:	8c01      	cmp	AL, #1
    67ac:	1d0b      	jne	0x67c4 <_Flash_PageWrite+0x22>
    67ae:	72da bf66 	lod	A, #48998
    67b2:	b480      	and	A, #-128
    67b4:	7a09      	lod	Y, [S-10]
    67b6:	eee2      	cmp	Y, A
    67b8:	1d05      	jne	0x67c4 <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    67ba:	7ad8 02a6 	lod	Y, 0x2a6 <_page_buffer>
    67be:	e076      	add	Y, #118
    67c0:	61d0      	lod	AL, dp:0xd0 <_LIN_nad>
    67c2:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67c4:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    67c6:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67c8:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67ca:	b430      	and	A, #48
    67cc:	1902      	je	0x67d2 <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67ce:	6000      	lod	AL, #0
    67d0:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    67d2:	11b0      	call	0x6b34 <_mlx_isPowerOk>
    67d4:	8c00      	cmp	AL, #0
    67d6:	1d02      	jne	0x67dc <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    67d8:	7001      	lod	A, #1
    67da:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    67dc:	7a09      	lod	Y, [S-10]
    67de:	eeda be80 	cmp	Y, #48768
    67e2:	1d01      	jne	0x67e6 <_Flash_PageWrite+0x44>
    67e4:	0045      	jmp	0x6870 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    67e6:	72e6      	lod	A, Y
    67e8:	1797      	call	0x6718 <_Flash_InitDriver+0x14>
    67ea:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    67ec:	179d      	call	0x6728 <_Flash_InitDriver+0x24>
    67ee:	8c00      	cmp	AL, #0
    67f0:	1901      	je	0x67f4 <_Flash_PageWrite+0x52>
    67f2:	003e      	jmp	0x6870 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67f4:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    67f6:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67f8:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67fa:	b430      	and	A, #48
    67fc:	1902      	je	0x6802 <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67fe:	6000      	lod	AL, #0
    6800:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    6802:	7207      	lod	A, [S-8]
    6804:	487a 0800 	muls	Y, A, #2048
    6808:	e2da 4000 	add	Y, #16384
    680c:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    680e:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    6812:	8c01      	cmp	AL, #1
    6814:	1a03      	jule	0x681c <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    6816:	7801      	lod	Y, #1
    6818:	5a03      	mov	[S-4], Y
    681a:	0002      	jmp	0x6820 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    681c:	7010      	lod	A, #16
    681e:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    6820:	7800      	lod	Y, #0
    6822:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    6826:	7a05      	lod	Y, [S-6]
    6828:	7000      	lod	A, #0
    682a:	52d6      	mov	[Y++], A
        *dst++ = 0;
    682c:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    682e:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    6830:	72da 00c8 	lod	A, #200
    6834:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    6838:	62d8 00d4 	lod	AL, 0xd4 <_ml_driver_mode>
    683c:	8c55      	cmp	AL, #85
    683e:	1903      	je	0x6846 <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    6840:	7000      	lod	A, #0
    6842:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    6846:	7000      	lod	A, #0
    6848:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    684a:	72ee      	lod	A, X
    684c:	80ff      	add	AL, #-1
    684e:	5cf2      	usex	A
    6850:	7ee2      	lod	X, A
    6852:	1d6e      	jne	0x6830 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    6854:	7a05      	lod	Y, [S-6]
    6856:	e2da 0080 	add	Y, #128
    685a:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    685c:	7203      	lod	A, [S-4]
    685e:	a0ff      	add	A, #-1
    6860:	5203      	mov	[S-4], A
    6862:	1d5e      	jne	0x6820 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    6864:	7207      	lod	A, [S-8]
    6866:	44e2      	sfb	A
    6868:	a6d8 02a8 	or	A, 0x2a8 <_page_buffer+0x2>
    686c:	52d8 02a8 	mov	0x2a8 <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6870:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    6872:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6874:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6876:	b430      	and	A, #48
    6878:	1902      	je	0x687e <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    687a:	6400      	lod	YL, #0
    687c:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    687e:	7000      	lod	A, #0
    6880:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    6884:	7ad8 02a6 	lod	Y, 0x2a6 <_page_buffer>
    dst = (uint16_t *)addr;
    6888:	7e09      	lod	X, [S-10]
    688a:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    688c:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    688e:	7201      	lod	A, [S-2]
    6890:	a2da 0080 	add	A, #128
    6894:	eee2      	cmp	Y, A
    6896:	187a      	jc	0x688c <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    6898:	7818      	lod	Y, #24
    689a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    689e:	62d8 00d4 	lod	AL, 0xd4 <_ml_driver_mode>
    68a2:	8c55      	cmp	AL, #85
    68a4:	1903      	je	0x68ac <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    68a6:	7000      	lod	A, #0
    68a8:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    68ac:	7a09      	lod	Y, [S-10]
    68ae:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    68b0:	7000      	lod	A, #0
    68b2:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    68b6:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    68b8:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    68ba:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    68bc:	b430      	and	A, #48
    68be:	1902      	je	0x68c4 <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    68c0:	6400      	lod	YL, #0
    68c2:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    68c4:	7209      	lod	A, [S-10]
    68c6:	175c      	call	0x6780 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    68c8:	540b      	ret	#12

000068ca <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    68ca:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    68cc:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    68d0:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    68d2:	7ae8      	swap	Y
    68d4:	f6da 00ff 	and	Y, #255
    68d8:	4436      	lsr	Y
    68da:	7ee6      	lod	X, Y
    68dc:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    68de:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    68e0:	ac3f      	cmp	A, #63
    68e2:	1b02      	jsle	0x68e8 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    68e4:	703f      	lod	A, #63
    68e6:	0003      	jmp	0x68ee <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    68e8:	ac00      	cmp	A, #0
    68ea:	1e81      	jsge	0x68ee <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    68ec:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    68ee:	7ae2      	lod	Y, A
    68f0:	f43f      	and	Y, #63
    68f2:	f6da 00ff 	and	Y, #255
    68f6:	7ae8      	swap	Y
    68f8:	4426      	asl	Y
    68fa:	7201      	lod	A, [S-2]
    68fc:	b6da 81ff 	and	A, #33279
    6900:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    6902:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    6906:	4432      	lsr	A
    6908:	b6da 3f00 	and	A, #16128
    690c:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    690e:	72ee      	lod	A, X
    6910:	5403      	ret	#4

00006912 <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    6912:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    6914:	b480      	and	A, #-128
    6916:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    6918:	aeda be80 	cmp	A, #48768
    691c:	1907      	je	0x692c <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    691e:	7201      	lod	A, [S-2]
    6920:	aeda bf00 	cmp	A, #48896
    6924:	1d05      	jne	0x6930 <_Flash_PageWriteFiltered+0x1e>
    6926:	16e3      	call	0x66ee <_LDR_GetState>
    6928:	8c03      	cmp	AL, #3
    692a:	1d02      	jne	0x6930 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    692c:	7000      	lod	A, #0
    692e:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    6930:	7201      	lod	A, [S-2]
    6932:	1737      	call	0x67a2 <_Flash_PageWrite>
}
    6934:	5403      	ret	#4

00006936 <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    6936:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6938:	4cc2 45c0 	mov	D, #280000
    693c:	0004 
    693e:	4872 0006 	muls	A, A, #6
    6942:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6944:	4c80      	mov	YA, D
    6946:	7e03      	lod	X, [S-4]
    6948:	4c63      	divu	YA, X
    694a:	4c63      	divu	YA, X
    694c:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    694e:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    6950:	7000      	lod	A, #0
    6952:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    6954:	eeda 027a 	cmp	Y, #634
    6958:	1e04      	jug	0x6962 <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    695a:	80ff      	add	AL, #-1
    695c:	b40f      	and	A, #15
    695e:	5205      	mov	[S-6], A
            break;
    6960:	0005      	jmp	0x696c <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    6962:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    6964:	8001      	add	AL, #1
    6966:	5cf2      	usex	A
    6968:	8c02      	cmp	AL, #2
    696a:	1a74      	jule	0x6954 <_ml_SetFastBaudRate+0x1e>
    696c:	72e6      	lod	A, Y
    696e:	a005      	add	A, #5
    6970:	4cf2      	usex	YA
    6972:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6974:	4c63      	divu	YA, X
    6976:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6978:	8080      	add	AL, #-128
    697a:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    697c:	52df      	push	A
    697e:	7207      	lod	A, [S-8]
    6980:	82db 5c4a 	callf	0x5c4a <_ml_SetBaudRate>
    6984:	5c01      	dec	S, #2
    6986:	5407      	ret	#8
    6988:	b66d      	and	A, [S-110]
    698a:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x7>
    698c:	dbb6      	subc	AH, ep:0xb6 <__bss_dp_size+0x6>
    698e:	b66d      	and	A, [S-110]
    6990:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x7>

00006992 <_RAM_Test>:
    6992:	7ada 6988 	lod	Y, #27016
    6996:	4cc0      	mov	D, YA
    6998:	7c00      	lod	X, #0
    699a:	54c6      	movsw	[X++], [Y++]
    699c:	54c6      	movsw	[X++], [Y++]
    699e:	54c6      	movsw	[X++], [Y++]
    69a0:	7800      	lod	Y, #0
    69a2:	54c6      	movsw	[X++], [Y++]
    69a4:	2eda 07fe 	cmp	X, #2046
    69a8:	1a7c      	jule	0x69a2 <_RAM_Test+0x10>
    69aa:	4c80      	mov	YA, D
    69ac:	7c00      	lod	X, #0
    69ae:	72de      	lod	A, [X++]
    69b0:	aed6      	cmp	A, [Y++]
    69b2:	1d0a      	jne	0x69c8 <_RAM_Test+0x36>
    69b4:	72de      	lod	A, [X++]
    69b6:	aed6      	cmp	A, [Y++]
    69b8:	1d07      	jne	0x69c8 <_RAM_Test+0x36>
    69ba:	72de      	lod	A, [X++]
    69bc:	aed6      	cmp	A, [Y++]
    69be:	1d04      	jne	0x69c8 <_RAM_Test+0x36>
    69c0:	7800      	lod	Y, #0
    69c2:	72de      	lod	A, [X++]
    69c4:	aed6      	cmp	A, [Y++]
    69c6:	1903      	je	0x69ce <_RAM_Test+0x3c>
    69c8:	64f3      	lod	YL, #-13
    69ca:	76da 568c 	jmpf	0x568c <__fatal>
    69ce:	2eda 07fe 	cmp	X, #2046
    69d2:	1a77      	jule	0x69c2 <_RAM_Test+0x30>
    69d4:	4c80      	mov	YA, D
    69d6:	e002      	add	Y, #2
    69d8:	eeda 698e 	cmp	Y, #27022
    69dc:	1d5c      	jne	0x6996 <_RAM_Test+0x4>
    69de:	76da 55e8 	jmpf	0x55e8 <_start>

000069e2 <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    69e2:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    69e4:	72d8 02aa 	lod	A, 0x2aa <__bss_end>
    69e8:	aeda b598 	cmp	A, #46488
    69ec:	1907      	je	0x69fc <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    69ee:	72da b598 	lod	A, #46488
    69f2:	52d8 02aa 	mov	0x2aa <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    69f6:	7800      	lod	Y, #0
    69f8:	5ad8 02ac 	mov	0x2ac <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if (   (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    69fc:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6a00:	aeda 3072 	cmp	A, #12402
    6a04:	1d01      	jne	0x6a08 <__low_level_init+0x26>
    6a06:	0071      	jmp	0x6aea <__low_level_init+0x108>
    6a08:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6a0c:	aeda 3212 	cmp	A, #12818
    6a10:	1d01      	jne	0x6a14 <__low_level_init+0x32>
    6a12:	006b      	jmp	0x6aea <__low_level_init+0x108>
    6a14:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6a18:	aeda 5c92 	cmp	A, #23698
    6a1c:	1d01      	jne	0x6a20 <__low_level_init+0x3e>
    6a1e:	0065      	jmp	0x6aea <__low_level_init+0x108>
    6a20:	7c0f      	lod	X, #15
    6a22:	7ada 11c0 	lod	Y, #4544
    6a26:	7000      	lod	A, #0
    6a28:	08a7      	clrb	ML.7
    6a2a:	b2d6      	adc	A, [Y++]
    6a2c:	1bfe      	djnz	X, 0x6a2a <__low_level_init+0x48>
    6a2e:	92e4      	adc	AL, AH
    6a30:	9000      	adc	AL, #0
    6a32:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    6a34:	aeda 00ff 	cmp	A, #255
    6a38:	1903      	je	0x6a40 <__low_level_init+0x5e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    6a3a:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    6a3c:	76da 568c 	jmpf	0x568c <__fatal>
    6a40:	7c0c      	lod	X, #12
    6a42:	7ada 11de 	lod	Y, #4574
    6a46:	7000      	lod	A, #0
    6a48:	08a7      	clrb	ML.7
    6a4a:	b2d6      	adc	A, [Y++]
    6a4c:	1bfe      	djnz	X, 0x6a4a <__low_level_init+0x68>
    6a4e:	92e4      	adc	AL, AH
    6a50:	9000      	adc	AL, #0
    6a52:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    6a54:	aeda 00ff 	cmp	A, #255
    6a58:	1903      	je	0x6a60 <__low_level_init+0x7e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    6a5a:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    6a5c:	76da 568c 	jmpf	0x568c <__fatal>
    6a60:	7c05      	lod	X, #5
    6a62:	7ada 11f6 	lod	Y, #4598
    6a66:	7000      	lod	A, #0
    6a68:	08a7      	clrb	ML.7
    6a6a:	b2d6      	adc	A, [Y++]
    6a6c:	1bfe      	djnz	X, 0x6a6a <__low_level_init+0x88>
    6a6e:	92e4      	adc	AL, AH
    6a70:	9000      	adc	AL, #0
    6a72:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    6a74:	aeda 00ff 	cmp	A, #255
    6a78:	1903      	je	0x6a80 <__low_level_init+0x9e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    6a7a:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    6a7c:	76da 568c 	jmpf	0x568c <__fatal>
    6a80:	7ada 10fc 	lod	Y, #4348
    6a84:	7c02      	lod	X, #2
    6a86:	7000      	lod	A, #0
    6a88:	08a7      	clrb	ML.7
    6a8a:	b2d6      	adc	A, [Y++]
    6a8c:	1bfe      	djnz	X, 0x6a8a <__low_level_init+0xa8>
    6a8e:	92e4      	adc	AL, AH
    6a90:	9000      	adc	AL, #0
    6a92:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    6a94:	aeda 00ff 	cmp	A, #255
    6a98:	1d07      	jne	0x6aa8 <__low_level_init+0xc6>
    6a9a:	7eda 11f8 	lod	X, #4600
    6a9e:	7ada 10fe 	lod	Y, #4350
    6aa2:	72f0      	lod	A, [Y]
    6aa4:	aef8      	cmp	A, [X]
    6aa6:	1921      	je	0x6aea <__low_level_init+0x108>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    6aa8:	7000      	lod	A, #0
    6aaa:	7eda 10fc 	lod	X, #4348
    6aae:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    6ab0:	7eda 10fe 	lod	X, #4350
    6ab4:	7ada 11f8 	lod	Y, #4600
    6ab8:	7af0      	lod	Y, [Y]
    6aba:	5af8      	mov	[X], Y
    6abc:	7ada 10fc 	lod	Y, #4348
    6ac0:	7c02      	lod	X, #2
    6ac2:	7000      	lod	A, #0
    6ac4:	08a7      	clrb	ML.7
    6ac6:	b2d6      	adc	A, [Y++]
    6ac8:	1bfe      	djnz	X, 0x6ac6 <__low_level_init+0xe4>
    6aca:	92e4      	adc	AL, AH
    6acc:	9000      	adc	AL, #0
    6ace:	5cf2      	usex	A
    6ad0:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    6ad2:	72da 00ff 	lod	A, #255
    6ad6:	aa05      	sub	A, [S-6]
    6ad8:	7ada 10fc 	lod	Y, #4348
    6adc:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    6ade:	7001      	lod	A, #1
    6ae0:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    6ae4:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    6ae6:	76da 568c 	jmpf	0x568c <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    6aea:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6aee:	8408      	or	AL, #8
    6af0:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    6af4:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    6af8:	b6da ff7f 	and	A, #65407
    6afc:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    6b00:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6b04:	94f7      	and	AL, #-9
    6b06:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    6b0a:	7c04      	lod	X, #4
    6b0c:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    6b10:	72da 7c50 	lod	A, #31824
    6b14:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    6b18:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6b1c:	94fe      	and	AL, #-2
    6b1e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    6b22:	0000      	nop
    NOP();
    6b24:	0000      	nop
    NOP();
    6b26:	0000      	nop
    MLX4_START();
    6b28:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6b2c:	8401      	or	AL, #1
    6b2e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    6b32:	540f      	ret	#16

00006b34 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    6b34:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    6b36:	7003      	lod	A, #3
    6b38:	5205      	mov	[S-6], A
    6b3a:	70ff      	lod	A, #-1
    6b3c:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    6b3e:	7000      	lod	A, #0
    6b40:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    6b42:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b44:	b401      	and	A, #1
    6b46:	1917      	je	0x6b76 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b48:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    6b4a:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b4c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b4e:	b430      	and	A, #48
    6b50:	1902      	je	0x6b56 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b52:	6000      	lod	AL, #0
    6b54:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    6b56:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b58:	b4fb      	and	A, #-5
    6b5a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b5c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b5e:	b401      	and	A, #1
    6b60:	190a      	je	0x6b76 <_mlx_isPowerOk+0x42>
    6b62:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    6b64:	7eda 15e0 	lod	X, #5600
    6b68:	1bff      	djnz	X, 0x6b68 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b6a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b6c:	b401      	and	A, #1
    6b6e:	1903      	je	0x6b76 <_mlx_isPowerOk+0x42>
    6b70:	e0ff      	add	Y, #-1
    6b72:	ecff      	cmp	Y, #-1
    6b74:	1d77      	jne	0x6b64 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    6b76:	7000      	lod	A, #0
    6b78:	5290      	mov	io:0x10 <__dp_noinit_size>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    6b7a:	72ef      	lod	A, S
    6b7c:	a0fe      	add	A, #-2
    6b7e:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
    6b80:	72ef      	lod	A, S
    6b82:	a0fa      	add	A, #-6
    6b84:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
    6b86:	72da 0080 	lod	A, #128
    6b8a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    6b8c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b8e:	a401      	or	A, #1
    6b90:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    DELAY(500);                     /* some delay for sample and hold */
    6b92:	7eda 01f4 	lod	X, #500
    6b96:	1bff      	djnz	X, 0x6b96 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    6b98:	7040      	lod	A, #64
    6b9a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    6b9e:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6ba0:	a6da 0100 	or	A, #256
    6ba4:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    6ba6:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6baa:	b440      	and	A, #64
    6bac:	1d08      	jne	0x6bbe <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6bae:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    6bb0:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6bb2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6bb4:	b430      	and	A, #48
    6bb6:	1977      	je	0x6ba6 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6bb8:	6000      	lod	AL, #0
    6bba:	4282      	mov	io:0x2 <_LinCmnd>, AL
    6bbc:	07f4      	jmp	0x6ba6 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    6bbe:	7201      	lod	A, [S-2]
    6bc0:	aeda 0158 	cmp	A, #344
    6bc4:	1e02      	jug	0x6bca <_mlx_isPowerOk+0x96>
        return false;
    6bc6:	7000      	lod	A, #0
    6bc8:	5407      	ret	#8
    }
    else {
        return true;
    6bca:	7001      	lod	A, #1
    }
}
    6bcc:	5407      	ret	#8
    6bce:	0000      	nop
    6bd0:	5cfa      	usex	
    6bd2:	5d16      	mov	dp:0x16 <__dp_noinit_size+0x6>, X
    6bd4:	5d6e      	mov	dp:0x6e <_g_NvramUser+0x18>, X
    6bd6:	5d9e      	mov	dp:0x9e <_g_NvramUser+0x48>, X
    6bd8:	5db2      	mov	dp:0xb2 <__bss_dp_size+0x2>, X
    6bda:	0000      	nop
    6bdc:	0001      	jmp	0x6be0 <_muldivI16_I16byI16byI16+0x2>

00006bde <_muldivI16_I16byI16byI16>:
    6bde:	7a03      	lod	Y, [S-4]
    6be0:	4831      	muls	YA, A, Y
    6be2:	7e05      	lod	X, [S-6]
    6be4:	4c73      	divs	YA, X
    6be6:	4c73      	divs	YA, X
    6be8:	4c7b      	dadjs	YA, X
    6bea:	5401      	ret

00006bec <_muldivU16_U16byU16byU16>:
    6bec:	7a03      	lod	Y, [S-4]
    6bee:	4821      	mulu	YA, A, Y
    6bf0:	7e05      	lod	X, [S-6]
    6bf2:	4c63      	divu	YA, X
    6bf4:	4c63      	divu	YA, X
    6bf6:	5401      	ret

00006bf8 <_divI32_I32byI16>:
    6bf8:	7e03      	lod	X, [S-4]
    6bfa:	1d87      	jnn	0x6c0a <_divI32_I32byU16+0x2>
    6bfc:	5cce      	neg	X
    6bfe:	5e03      	mov	[S-4], X
    6c00:	e000      	add	Y, #0
    6c02:	1d86      	jnn	0x6c10 <_divI32_I32byU16+0x8>
    6c04:	4cf0      	neg	YA
    6c06:	0011      	jmp	0x6c2a <_divU32_U32byU16>

00006c08 <_divI32_I32byU16>:
    6c08:	7e03      	lod	X, [S-4]
    6c0a:	e000      	add	Y, #0
    6c0c:	1d8e      	jnn	0x6c2a <_divU32_U32byU16>
    6c0e:	4cf0      	neg	YA
    6c10:	4ca3      	push	YA
    6c12:	72e6      	lod	A, Y
    6c14:	7800      	lod	Y, #0
    6c16:	7e07      	lod	X, [S-8]
    6c18:	4c63      	divu	YA, X
    6c1a:	4c63      	divu	YA, X
    6c1c:	5201      	mov	[S-2], A
    6c1e:	7203      	lod	A, [S-4]
    6c20:	4c63      	divu	YA, X
    6c22:	4c63      	divu	YA, X
    6c24:	7a01      	lod	Y, [S-2]
    6c26:	4cf0      	neg	YA
    6c28:	5405      	ret	#6

00006c2a <_divU32_U32byU16>:
    6c2a:	4ca3      	push	YA
    6c2c:	72e6      	lod	A, Y
    6c2e:	7800      	lod	Y, #0
    6c30:	7e07      	lod	X, [S-8]
    6c32:	4c63      	divu	YA, X
    6c34:	4c63      	divu	YA, X
    6c36:	5201      	mov	[S-2], A
    6c38:	7203      	lod	A, [S-4]
    6c3a:	4c63      	divu	YA, X
    6c3c:	4c63      	divu	YA, X
    6c3e:	7a01      	lod	Y, [S-2]
    6c40:	5405      	ret	#6

00006c42 <_mulI32_I16byU16>:
    6c42:	a000      	add	A, #0
    6c44:	1d85      	jnn	0x6c50 <_mulU32_U16byU16>
    6c46:	5cc2      	neg	A
    6c48:	7a03      	lod	Y, [S-4]
    6c4a:	4821      	mulu	YA, A, Y
    6c4c:	4cf0      	neg	YA
    6c4e:	5401      	ret

00006c50 <_mulU32_U16byU16>:
    6c50:	7a03      	lod	Y, [S-4]
    6c52:	4821      	mulu	YA, A, Y
    6c54:	5401      	ret

00006c56 <_mulI32hi_I32byI16>:
    6c56:	7e03      	lod	X, [S-4]
    6c58:	1d94      	jnn	0x6c82 <_mulI32hi_I32byU16+0x2>
    6c5a:	5cce      	neg	X
    6c5c:	4803      	mulu	D, A, X
    6c5e:	4c88      	mov	A, DL
    6c60:	488f      	lsr	D, #16
    6c62:	4cf3      	swap	YA
    6c64:	2000      	add	X, #0
    6c66:	1982      	jn	0x6c6c <_mulI32hi_I32byI16+0x16>
    6c68:	4853      	macs	D, A, X
    6c6a:	0003      	jmp	0x6c72 <_mulI32hi_I32byI16+0x1c>
    6c6c:	4cd0      	neg	D
    6c6e:	4853      	macs	D, A, X
    6c70:	4cd0      	neg	D
    6c72:	e000      	add	Y, #0
    6c74:	1902      	je	0x6c7a <_mulI32hi_I32byI16+0x24>
    6c76:	4c0a 0001 	addu	D, #1
    6c7a:	4c80      	mov	YA, D
    6c7c:	4cf0      	neg	YA
    6c7e:	5401      	ret

00006c80 <_mulI32hi_I32byU16>:
    6c80:	7e03      	lod	X, [S-4]
    6c82:	e000      	add	Y, #0
    6c84:	1d8e      	jnn	0x6ca2 <_mulU32hi_U32byU16+0x2>
    6c86:	4cf0      	neg	YA
    6c88:	4803      	mulu	D, A, X
    6c8a:	4c88      	mov	A, DL
    6c8c:	488f      	lsr	D, #16
    6c8e:	4cf3      	swap	YA
    6c90:	4843      	macu	D, A, X
    6c92:	e000      	add	Y, #0
    6c94:	1902      	je	0x6c9a <_mulI32hi_I32byU16+0x1a>
    6c96:	4c0a 0001 	addu	D, #1
    6c9a:	4c80      	mov	YA, D
    6c9c:	4cf0      	neg	YA
    6c9e:	5401      	ret

00006ca0 <_mulU32hi_U32byU16>:
    6ca0:	7e03      	lod	X, [S-4]
    6ca2:	4803      	mulu	D, A, X
    6ca4:	488f      	lsr	D, #16
    6ca6:	4cf3      	swap	YA
    6ca8:	4843      	macu	D, A, X
    6caa:	4c80      	mov	YA, D
    6cac:	5401      	ret

00006cae <_RamBackgroundTest>:
{
	/* Use compare instead of CRC-check !! */
	uint16 *pu16Page;
#if (LINPROT == LIN2J_VALVE_VW)
	(void) u16Page;
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80U) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80U) )
    6cae:	7ada 101d 	lod	Y, #4125
    6cb2:	66f0      	lod	YL, [Y]
    6cb4:	f6da 0080 	and	Y, #128
    6cb8:	7ee6      	lod	X, Y
    6cba:	7ada 111d 	lod	Y, #4381
    6cbe:	62f0      	lod	AL, [Y]
    6cc0:	b6da 0080 	and	A, #128
    6cc4:	2ee2      	cmp	X, A
    6cc6:	1903      	je	0x6cce <_RamBackgroundTest+0x20>
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;
    6cc8:	72da 1100 	lod	A, #4352
    6ccc:	0002      	jmp	0x6cd2 <_RamBackgroundTest+0x24>
	}
	else
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE1;
    6cce:	72da 1000 	lod	A, #4096
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;									/* Compare NVRAM User-page #2 against RAM */
	}
#endif /* (LINPROT == LIN2J_VALVE_VW) */

	return ( NVRAM_PageVerify( pu16Page) );
    6cd2:	82db 98de 	callf	0x98de <_NVRAM_PageVerify>

} /* End of RamBackgroundTest() */
    6cd6:	5401      	ret

00006cd8 <_FlashBackgroundTest>:
#define C_FLASH_CRC_FAILED			0U
#define C_FLASH_CRC_OK				1U
#define C_FLASH_CRC_CALCULATING		2U

uint16 FlashBackgroundTest( uint16 u16Size)
{
    6cd8:	5807      	inc	S, #8
    6cda:	7ee2      	lod	X, A
	uint16 u16Result = C_FLASH_CRC_CALCULATING;
    6cdc:	4cd3      	swap	D
    6cde:	48cf      	asl	D, #16
    6ce0:	4c0a 0002 	addu	D, #2
	static uint16 *pu16Segment = (uint16 *) FLASH_START_ADDR;
	static uint16 u16FlashCRC = 0;

	if ( u16Size == 0U )
    6ce4:	ac00      	cmp	A, #0
    6ce6:	1d06      	jne	0x6cf4 <_FlashBackgroundTest+0x1c>
	{
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6ce8:	72da 4000 	lod	A, #16384
    6cec:	52d8 010c 	mov	0x10c <_g_i16SupplyVoltage+0x2>, A
		return ( u16Result );
    6cf0:	7002      	lod	A, #2
    6cf2:	5409      	ret	#10
	}
	if ( pu16Segment == (uint16 *) FLASH_START_ADDR )
    6cf4:	7ad8 010c 	lod	Y, 0x10c <_g_i16SupplyVoltage+0x2>
    6cf8:	eeda 4000 	cmp	Y, #16384
    6cfc:	1d03      	jne	0x6d04 <_FlashBackgroundTest+0x2c>
	{
		u16FlashCRC = 0xFFFFU;													/* Initialise the CRC preset with 0xFFFF */
    6cfe:	70ff      	lod	A, #-1
    6d00:	52d8 010e 	mov	0x10e <_g_i16SupplyVoltage+0x4>, A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
    6d04:	72e6      	lod	A, Y
    6d06:	a2ee      	add	A, X
    6d08:	aeda c000 	cmp	A, #49152
    6d0c:	1a04      	jule	0x6d16 <_FlashBackgroundTest+0x3e>
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
    6d0e:	72da c000 	lod	A, #49152
    6d12:	7ee2      	lod	X, A
    6d14:	2ae6      	sub	X, Y
	}
	for ( ; u16Size > 0U; u16Size-- )
    6d16:	2c00      	cmp	X, #0
    6d18:	192b      	je	0x6d70 <_FlashBackgroundTest+0x98>
    6d1a:	5a03      	mov	[S-4], Y
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
    6d1c:	7a03      	lod	Y, [S-4]
    6d1e:	eeda bf4e 	cmp	Y, #48974
    6d22:	1920      	je	0x6d64 <_FlashBackgroundTest+0x8c>
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
    6d24:	72f0      	lod	A, [Y]
    6d26:	5205      	mov	[S-6], A
			for ( u8Count = 16U; u8Count > 0U; u8Count-- )
    6d28:	7810      	lod	Y, #16
    6d2a:	5a07      	mov	[S-8], Y
    6d2c:	7ad8 010e 	lod	Y, 0x10e <_g_i16SupplyVoltage+0x4>
			{
				uint16 u16XorFlag = !!(u16FlashCRC & 0x8000);
    6d30:	72e6      	lod	A, Y
    6d32:	b6da 8000 	and	A, #32768
    6d36:	5201      	mov	[S-2], A
    6d38:	1902      	je	0x6d3e <_FlashBackgroundTest+0x66>
    6d3a:	7001      	lod	A, #1
    6d3c:	5201      	mov	[S-2], A
				u16FlashCRC = (u16FlashCRC << 1);
    6d3e:	4426      	asl	Y
				if ( (u16Data & 0x8000U) != 0U )
    6d40:	7205      	lod	A, [S-6]
    6d42:	ac00      	cmp	A, #0
    6d44:	1e81      	jsge	0x6d48 <_FlashBackgroundTest+0x70>
				{
					u16FlashCRC++;
    6d46:	e001      	add	Y, #1
				}
				if ( u16XorFlag != 0U )
    6d48:	7201      	lod	A, [S-2]
    6d4a:	1902      	je	0x6d50 <_FlashBackgroundTest+0x78>
				{
					u16FlashCRC ^= POLY;
    6d4c:	feda 1021 	xor	Y, #4129
				}
				u16Data <<= 1;
    6d50:	7205      	lod	A, [S-6]
    6d52:	4422      	asl	A
    6d54:	5205      	mov	[S-6], A
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
			for ( u8Count = 16U; u8Count > 0U; u8Count-- )
    6d56:	6207      	lod	AL, [S-8]
    6d58:	80ff      	add	AL, #-1
    6d5a:	5cf2      	usex	A
    6d5c:	5207      	mov	[S-8], A
    6d5e:	1d68      	jne	0x6d30 <_FlashBackgroundTest+0x58>
    6d60:	5ad8 010e 	mov	0x10e <_g_i16SupplyVoltage+0x4>, Y
					u16FlashCRC ^= POLY;
				}
				u16Data <<= 1;
			}
		}
		pu16Segment++;
    6d64:	7203      	lod	A, [S-4]
    6d66:	a002      	add	A, #2
    6d68:	5203      	mov	[S-4], A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
	}
	for ( ; u16Size > 0U; u16Size-- )
    6d6a:	1bd8      	djnz	X, 0x6d1c <_FlashBackgroundTest+0x44>
    6d6c:	52d8 010c 	mov	0x10c <_g_i16SupplyVoltage+0x2>, A
			}
		}
		pu16Segment++;
	}

	if ( (uint16) pu16Segment >= FLASH_END_ADDR )
    6d70:	72d8 010c 	lod	A, 0x10c <_g_i16SupplyVoltage+0x2>
    6d74:	aeda bfff 	cmp	A, #49151
    6d78:	1a14      	jule	0x6da2 <_FlashBackgroundTest+0xca>
	{
		/* CRC fully calculated, check values */
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6d7a:	7ada 4000 	lod	Y, #16384
    6d7e:	5ad8 010c 	mov	0x10c <_g_i16SupplyVoltage+0x2>, Y
		if ( *(uint16 *) FLASH_CRC_ADDR != 0U )									/* Flash/ROM Checksum programmed? */
    6d82:	7ada bf4e 	lod	Y, #48974
    6d86:	72f0      	lod	A, [Y]
    6d88:	190c      	je	0x6da2 <_FlashBackgroundTest+0xca>
		{
			if ( *(uint16 *) FLASH_CRC_ADDR != u16FlashCRC )
    6d8a:	aed8 010e 	cmp	A, 0x10e <_g_i16SupplyVoltage+0x4>
    6d8e:	1905      	je	0x6d9a <_FlashBackgroundTest+0xc2>
			{
				u16Result = C_FLASH_CRC_FAILED;
    6d90:	4cd3      	swap	D
    6d92:	48cf      	asl	D, #16
    6d94:	4c0a 0000 	addu	D, #0
    6d98:	0004      	jmp	0x6da2 <_FlashBackgroundTest+0xca>
			}
			else
			{
				u16Result = C_FLASH_CRC_OK;
    6d9a:	4cd3      	swap	D
    6d9c:	48cf      	asl	D, #16
    6d9e:	4c0a 0001 	addu	D, #1
			}
		}
	}

	return ( u16Result );
    6da2:	4c88      	mov	A, DL

} /* End of FlashBackgroundTest() */
    6da4:	5409      	ret	#10

00006da6 <_noinit_section_init>:
void noinit_section_init(void)
{
#if (LINPROT == LIN2X_ACT44)
	g_e8MotorCtrlMode = (uint8) C_MOTOR_CTRL_STOP;
#endif /* (LINPROT == LIN2X_ACT44) */
	g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;								/* Control-flag Stall-detector enabled [WD] */;
    6da6:	6007      	lod	AL, #7
    6da8:	41e9      	mov	dp:0xe9 <_g_e8StallDetectorEna>, AL
	g_u8MotorHoldingCurrEna = FALSE;
    6daa:	6000      	lod	AL, #0
    6dac:	41ea      	mov	dp:0xea <_g_u8MotorHoldingCurrEna>, AL
#if (LINPROT == LIN2J_VALVE_VW)
	g_u16ActualPosition = (0U + C_PERC_OFFSET);
    6dae:	72da 0900 	lod	A, #2304
    6db2:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
	g_u16TargetPosition = (0U + C_PERC_OFFSET);
    6db4:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
#else  /* (LINPROT == LIN2J_VALVE_VW) */
	g_u16ActualPosition = 32767U;
	g_u16TargetPosition = 65535U;
#endif /* (LINPROT == LIN2J_VALVE_VW) */
	g_u8MotorCtrlSpeed = (uint8) C_DEFAULT_MOTOR_SPEED;
    6db6:	6003      	lod	AL, #3
    6db8:	41f0      	mov	dp:0xf0 <_g_u8MotorCtrlSpeed>, AL
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    6dba:	6000      	lod	AL, #0
    6dbc:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
	g_u16CalibTravel = g_NvramUser.DefTravel;									/* Number of steps between two end-stops */
    6dbe:	7168      	lod	A, dp:0x68 <_g_NvramUser+0x12>
    6dc0:	51f2      	mov	dp:0xf2 <_g_u16CalibTravel>, A

	/* MotorDriver.c variables */
	g_u16ActuatorActPos = g_u16ActualPosition;
    6dc2:	72da 0900 	lod	A, #2304
    6dc6:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = g_u16TargetPosition;
    6dc8:	51f6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, A
    6dca:	5401      	ret

00006dcc <_main>:
 *	S. (Optional) Determine actuator position
 *	T. (Watch-dog Reset) Start actuator (if needed)
 *	U. Main application loop
 * ****************************************************************************	*/
int16 main( void)
{
    6dcc:	5817      	inc	S, #24
	/* *************************************************** */
	/* *** A. Initialise background schedule (Task-ID) *** */
	/* *************************************************** */
	uint8 u8BackgroundSchedulerTaskID = 0U;
    6dce:	7000      	lod	A, #0
    6dd0:	5217      	mov	[S-24], A

#if _SUPPORT_CRASH_RECOVERY
	/* **************************************************************** */
	/* *** B. (Optional) Check crash-recovery (fatal-error handler) *** */
	/* **************************************************************** */
	if ( bistResetInfo == C_CHIP_STATE_FATAL_CRASH_RECOVERY )
    6dd2:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6dd6:	aeda 1872 	cmp	A, #6258
    6dda:	1d0d      	jne	0x6df6 <_main+0x2a>
	{
#if LIN_COMM
		g_u8LinInFrameBufState = C_LIN_IN_FREE;
    6ddc:	6400      	lod	YL, #0
    6dde:	46d8 0112 	mov	0x112 <_g_u8LinInFrameBufState>, YL
#endif /* LIN_COMM */
		if ( (g_e8StallDetectorEna != (uint8) C_STALLDET_NONE) && ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0)) /*lint !e845 */
    6de2:	61e9      	lod	AL, dp:0xe9 <_g_e8StallDetectorEna>
    6de4:	1d01      	jne	0x6de8 <_main+0x1c>
    6de6:	00c5      	jmp	0x6f72 <_main+0x1a6>
    6de8:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    6dea:	b401      	and	A, #1
    6dec:	1d01      	jne	0x6df0 <_main+0x24>
    6dee:	00c1      	jmp	0x6f72 <_main+0x1a6>
		{
			/* Actuator is active; clear motor-raw-current moving-average buffer */
			MotorDriverCurrentMeasureInit();
    6df0:	82db 8eee 	callf	0x8eee <_MotorDriverCurrentMeasureInit>
    6df4:	00be      	jmp	0x6f72 <_main+0x1a6>
#if WATCHDOG == DISABLED
		WD_CTRL = 0U;															/* Disable digital Watch-dog */
		AWD_CTRL = 0x8000U;														/* Disable analogue Watch-dog */
#endif /* WATCHDOG == DISABLED */
#if WATCHDOG == ENABLED
		WD_T = WatchDog_PeriodOf100ms;											/* Initialise the (Digital) watch-dog comparator to 100ms */
    6df6:	60c3      	lod	AL, #-61
    6df8:	4282      	mov	io:0x2 <_LinCmnd>, AL
		WD_CTRL = WatchDog_ModeTimer;											/* Define the mode and start the watchdog */
    6dfa:	6012      	lod	AL, #18
    6dfc:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
 *
 *****************************************************************************
 */
__MLX_TEXT__  static INLINE void awdg_init (uint8 prescaler, uint8 timer)
{
    AWD_CTRL = ((uint16)(prescaler & 3) << 8) | timer;
    6dfe:	7eda 019c 	lod	X, #412
    6e02:	5e9a      	mov	io:0x1a <_g_u8StallTypeComm>, X
		awdg_init( AWDG_DIV_16, C_AWD_PERIOD_250MS);
		/* Maximum Watch-dog period */
#endif /* WATCHDOG == ENABLED */
#if MCU_ASSP_MODE
		ANA_OUTL |= ASSP;														/* ASSP-mode */
    6e04:	72d8 28d4 	lod	A, 0x28d4 <__io__+0xd4>
    6e08:	a401      	or	A, #1
    6e0a:	52d8 28d4 	mov	0x28d4 <__io__+0xd4>, A

#if _SUPPORT_TESTMODE_OFF
		/* ******************************************** */
		/* *** D. (Optional) Chip test-mode disable *** */
		/* ******************************************** */
		CONTROL |= OUTA_WE;														/* Grant access to ANA_OUTx registers */
    6e0e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6e12:	8408      	or	AL, #8
    6e14:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
		ANA_OUTA |= TEST_MODE_DIS;												/* Disable test-mode */
    6e18:	72d8 201c 	lod	A, 0x201c <__ep__+0x101c>
    6e1c:	a6da 0080 	or	A, #128
    6e20:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
		CONTROL &= ~OUTA_WE;
    6e24:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6e28:	94f7      	and	AL, #-9
    6e2a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
#endif /* MCU_ASSP_MODE */
#endif /* _DEBUG_SPI */
#endif /* _DEBUG */

		/* Application mode */
		SET_PRIORITY(0);
    6e2e:	54f0      	mov	UPr, #0
		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    6e30:	6002      	lod	AL, #2
    6e32:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
		/* ******************************* */
		/* *** E. Load user NVRAM page *** */
		/* ******************************* */
		NVRAM_LoadUserPage();													/* Load User NVRAM storage parameters */
    6e34:	82db 9a02 	callf	0x9a02 <_NVRAM_LoadUserPage>
#if USE_MULTI_PURPOSE_BUFFER
		g_MPBuf.u8Type = (uint8) C_MP_BUF_NONE;
		g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;
#endif /* USE_MULTI_PURPOSE_BUFFER */

		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    6e38:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6e3c:	aeda 5c92 	cmp	A, #23698
    6e40:	1901      	je	0x6e44 <_main+0x78>
		{
			noinit_section_init();
    6e42:	17b1      	call	0x6da6 <_noinit_section_init>
		}
		g_e8StallDetectorEna = C_STALLDET_NONE;
    6e44:	6000      	lod	AL, #0
    6e46:	41e9      	mov	dp:0xe9 <_g_e8StallDetectorEna>, AL
		if ( g_NvramUser.StallDetectorEna )
    6e48:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    6e4a:	4215      	mov	[S-22], AL
    6e4c:	44b0      	lsr	AL, #2
    6e4e:	4430      	lsr	AL
    6e50:	b401      	and	A, #1
    6e52:	1902      	je	0x6e58 <_main+0x8c>
		{
#if _SUPPORT_STALLDET_H
			g_e8StallDetectorEna |= C_STALLDET_HnA;								/* Control-flag Stall-detector "H" and "A" enabled */
#else  /* _SUPPORT_STALLDET_H */
			g_e8StallDetectorEna |= C_STALLDET_A;								/* Control-flag Stall-detector "A" enabled */
    6e54:	6001      	lod	AL, #1
    6e56:	41e9      	mov	dp:0xe9 <_g_e8StallDetectorEna>, AL
#endif /* _SUPPORT_STALLDET_H */
		}
		if ( NVRAM_STALL_O )
    6e58:	61c5      	lod	AL, dp:0xc5 <__bss_dp_size+0x15>
    6e5a:	44b2      	lsr	A, #2
    6e5c:	44b2      	lsr	A, #2
    6e5e:	44b2      	lsr	A, #2
    6e60:	b401      	and	A, #1
    6e62:	1903      	je	0x6e6a <_main+0x9e>
		{
			g_e8StallDetectorEna |= C_STALLDET_O;								/* Control-flag Stall-detector "O" enabled */
    6e64:	61e9      	lod	AL, dp:0xe9 <_g_e8StallDetectorEna>
    6e66:	8402      	or	AL, #2
    6e68:	41e9      	mov	dp:0xe9 <_g_e8StallDetectorEna>, AL
		}
		g_u8MotorHoldingCurrEna = g_NvramUser.MotorHoldingCurrentEna;			/* Control-flag motor Holding-current enabled */
    6e6a:	6215      	lod	AL, [S-22]
    6e6c:	44b0      	lsr	AL, #2
    6e6e:	44b0      	lsr	AL, #2
    6e70:	b401      	and	A, #1
    6e72:	41ea      	mov	dp:0xea <_g_u8MotorHoldingCurrEna>, AL

		/* ********************************************** */
		/* *** F. Initialise Error-logging management *** */
		/* ********************************************** */
		ErrorLogInit();
    6e74:	82db 89be 	callf	0x89be <_ErrorLogInit>

		/* Log Watch-dog reset */
		if ( bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET )						/* LIN-command chip reset use WD; No need to log */
    6e78:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6e7c:	aeda 3072 	cmp	A, #12402
    6e80:	1918      	je	0x6eb2 <_main+0xe6>
		{
			if ( (CONTROL & WD_BOOT) || (AWD_CTRL & AWD_RST) )
    6e82:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6e86:	8c00      	cmp	AL, #0
    6e88:	1a83      	jsl	0x6e90 <_main+0xc4>
    6e8a:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    6e8c:	ac00      	cmp	A, #0
    6e8e:	1e91      	jsge	0x6eb2 <_main+0xe6>
			{
				if ( CONTROL & WD_BOOT )
    6e90:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6e94:	8c00      	cmp	AL, #0
    6e96:	1e89      	jsge	0x6eaa <_main+0xde>
				{
					if ( AWD_CTRL & AWD_RST )
    6e98:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    6e9a:	ac00      	cmp	A, #0
    6e9c:	1e83      	jsge	0x6ea4 <_main+0xd8>
					{
						SetLastError( (uint8) C_ERR_WD_AWD_RST);				/* Both Analogue & Digital Watch-dog reset */
    6e9e:	72da 00f3 	lod	A, #243
    6ea2:	0005      	jmp	0x6eae <_main+0xe2>
					}
					else
					{
						SetLastError( (uint8) C_ERR_WD_RST);					/* Digital Watch-dog reset */
    6ea4:	72da 00f1 	lod	A, #241
    6ea8:	0002      	jmp	0x6eae <_main+0xe2>
					}
				}
				else
				{
					SetLastError( (uint8) C_ERR_AWD_RST);						/* Analogue Watch-dog reset */
    6eaa:	72da 00f2 	lod	A, #242
    6eae:	82db 89e6 	callf	0x89e6 <_SetLastError>
		}

		/* ******************************************* */
		/* *** G. Initialise chip (H/W) Diagnostic *** */
		/* ******************************************* */
		DiagnosticsInit();														/* Initialise Diagnostic */
    6eb2:	82db 8910 	callf	0x8910 <_DiagnosticsInit>

		/* ************************* */
		/* *** H. Initialise ADC *** */
		/* ************************* */
		ADC_Init();																/* Initialise ADC */
    6eb6:	82db 8444 	callf	0x8444 <_ADC_Init>

		/* ********************************** */
		/* *** I. Initialise Motor-driver *** */
		/* ********************************** */
		MotorDriverInit();														/* Initialise Motor-Driver */
    6eba:	82db 8a7a 	callf	0x8a7a <_MotorDriverInit>

		/* *************************************** */
		/* *** J. Initialise rewind management *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0) )
    6ebe:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6ec2:	aeda 5c92 	cmp	A, #23698
    6ec6:	1907      	je	0x6ed6 <_main+0x10a>
    6ec8:	61a1      	lod	AL, dp:0xa1 <_g_NvramUser+0x4b>
    6eca:	8c00      	cmp	AL, #0
    6ecc:	1e84      	jsge	0x6ed6 <_main+0x10a>
    6ece:	61be      	lod	AL, dp:0xbe <__bss_dp_size+0xe>
    6ed0:	1902      	je	0x6ed6 <_main+0x10a>
#else  /* _SUPPORT_WD_RST_RECOVERY */
		if ( (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0U) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			g_u8RewindFlags = (uint8) (C_REWIND_STALL_DETECT | C_REWIND_DIRECTION_AUTO);/* After POR: Enable Rewind and set auto-direction */
    6ed2:	6006      	lod	AL, #6
    6ed4:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
		}

		SET_PRIORITY(7);
    6ed6:	54f7      	mov	UPr, #7

		/* ********************************* */
		/* *** K. Motor-driver self-test *** */
		/* ********************************* */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
    6ed8:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6edc:	aeda 5c92 	cmp	A, #23698
    6ee0:	190a      	je	0x6ef6 <_main+0x12a>
    6ee2:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6ee6:	aeda 3072 	cmp	A, #12402
    6eea:	1905      	je	0x6ef6 <_main+0x12a>
#else  /* _SUPPORT_WD_RST_RECOVERY */
		if ( ((CONTROL & WD_BOOT) == 0U) && ((AWD_CTRL & AWD_RST) == 0U) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
#if (_SUPPORT_MOTOR_SELFTEST != FALSE)
			g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_SELFTEST;
    6eec:	6004      	lod	AL, #4
    6eee:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
			MotorDriverSelfTest();												/* Self-test Motor-Driver */
    6ef0:	82db 8cac 	callf	0x8cac <_MotorDriverSelfTest>
    6ef4:	0007      	jmp	0x6f04 <_main+0x138>
#endif /* (_SUPPORT_MOTOR_SELFTEST != FALSE) */
		}
#if _SUPPORT_WD_RST_RECOVERY
		else if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    6ef6:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6efa:	aeda 5c92 	cmp	A, #23698
    6efe:	1d02      	jne	0x6f04 <_main+0x138>
		{
			g_u8ChipResetOcc = FALSE;											/* Clear chip-reset flag before LIN initialisation */
    6f00:	6400      	lod	YL, #0
    6f02:	4527      	mov	dp:0x27 <_g_u8ChipResetOcc>, YL
		}
#endif /* _SUPPORT_WD_RST_RECOVERY */

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    6f04:	6002      	lod	AL, #2
    6f06:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
		
		/* ********************************* */
		/* *** L. Initialise PID-Control *** */
		/* ********************************* */
		PID_Init();																/* PID Control initialisation */
    6f08:	82db 9b8e 	callf	0x9b8e <_PID_Init>

		/* *************************************** */
		/* *** M. Initialise (Task) Core Timer *** */
		/* *************************************** */
		Timer_Init();															/* Initialise (Core) Timer */
    6f0c:	82db 9f54 	callf	0x9f54 <_Timer_Init>

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    6f10:	6000      	lod	AL, #0
    6f12:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL

		/* **************************************************************** */
		/* *** N. Perform an initial supply and temperature measurement *** */
		/* ***    and energies motor coils (MotorDriverStop()).			*** */
		/* **************************************************************** */
		MeasureVsupplyAndTemperature();
    6f14:	82db 8762 	callf	0x8762 <_MeasureVsupplyAndTemperature>
		GetChipTemperature( TRUE);
    6f18:	7001      	lod	A, #1
    6f1a:	82db 8692 	callf	0x8692 <_GetChipTemperature>
		MotorDriverStop( (uint16) C_STOP_IMMEDIATE);							/* Energies coils if needed */
    6f1e:	7001      	lod	A, #1
    6f20:	82db 9296 	callf	0x9296 <_MotorDriverStop>
#if LIN_COMM
		/* *************************************** */
		/* *** O. Initialise LIN-communication *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    6f24:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6f28:	aeda 5c92 	cmp	A, #23698
    6f2c:	1d02      	jne	0x6f32 <_main+0x166>
		{
			/* Do not change actual and target position */
			LIN_Init( TRUE);													/* Initialise LIN communication interface */
    6f2e:	7001      	lod	A, #1
    6f30:	0001      	jmp	0x6f34 <_main+0x168>
		}
		else
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			LIN_Init( FALSE);													/* Initialise LIN communication interface */
    6f32:	7000      	lod	A, #0
    6f34:	82db 774c 	callf	0x774c <_LIN_Init>
		}

		/* Check chip-state for LIN-command RESET, to setup diagnostic-response */
		if ( bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET )
    6f38:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6f3c:	aeda 3072 	cmp	A, #12402
    6f40:	1d05      	jne	0x6f4c <_main+0x180>
		{
#if (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
#endif /* (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE) */
#if ((LINPROT & LINXX) == LIN2J)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
    6f42:	82db 83ac 	callf	0x83ac <_RfrDiagReset>
#endif /* ((LINPROT & LINXX) == LIN2J) */
			bistResetInfo = C_CHIP_STATE_COLD_START;
    6f46:	7800      	lod	Y, #0
    6f48:	5ad8 02ac 	mov	0x2ac <_bistResetInfo>, Y
		}
#endif /* LIN_COMM */

#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    6f4c:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6f50:	aeda 5c92 	cmp	A, #23698
    6f54:	1904      	je	0x6f5e <_main+0x192>
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			g_u16ActuatorActPos = g_u16ActualPosition;							/* Initialise the Actuator positions too */
    6f56:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    6f58:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
			g_u16ActuatorTgtPos = g_u16TargetPosition;
    6f5a:	7dee      	lod	X, dp:0xee <_g_u16TargetPosition>
    6f5c:	5df6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, X

#if _SUPPORT_WD_RST_RECOVERY
		/* ****************************************************** */
		/* *** T. (Watch-dog Reset) Start actuator (if needed) *** */
		/* ****************************************************** */
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    6f5e:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    6f62:	aeda 5c92 	cmp	A, #23698
    6f66:	1d05      	jne	0x6f72 <_main+0x1a6>
		{
			if ( g_u16ActuatorActPos != g_u16ActuatorTgtPos )
    6f68:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    6f6a:	adf6      	cmp	A, dp:0xf6 <_g_u16ActuatorTgtPos>
    6f6c:	1902      	je	0x6f72 <_main+0x1a6>
			{
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    6f6e:	6003      	lod	AL, #3
    6f70:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
		}
#endif /* _SUPPORT_WD_RST_RECOVERY */
	}

#if _SUPPORT_CRASH_RECOVERY
	bistResetInfo = C_CHIP_STATE_FATAL_RECOVER_ENA;							/* Enable Fatal crash recovery */
    6f72:	72da 1a45 	lod	A, #6725
    6f76:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6f7a:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    AWD_CTRL = temp;
    6f7c:	529a      	mov	io:0x1a <_g_u8StallTypeComm>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6f7e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6f80:	b430      	and	A, #48
    6f82:	1902      	je	0x6f88 <_main+0x1bc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6f84:	6400      	lod	YL, #0
    6f86:	4682      	mov	io:0x2 <_LinCmnd>, YL

		/* ********************************* */
		/* *** c. LIN(-IN) communication *** */
		/* ********************************* */
#if LIN_COMM
		if ( g_u8LinInFrameBufState != C_LIN_IN_FREE )
    6f88:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
    6f8c:	1902      	je	0x6f92 <_main+0x1c6>
		{
			/* LIN message buffer filled */
			HandleLinInMsg();
    6f8e:	82db 787a 	callf	0x787a <_HandleLinInMsg>

		/* ******************************* */
		/* *** d. Motor Driver current *** */
		/* ******************************* */
		/* Calculate Current (1000LSB/A) [mA] */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0U) || (g_u8MotorHoldingCurrState != FALSE) )
    6f92:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    6f94:	b401      	and	A, #1
    6f96:	1d03      	jne	0x6f9e <_main+0x1d2>
    6f98:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    6f9c:	1911      	je	0x6fc0 <_main+0x1f4>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6f9e:	82db 874e 	callf	0x874e <_GetMotorDriverCurrent>
    6fa2:	794a      	lod	Y, dp:0x4a <_g_u16CorrectionRatio>
    6fa4:	7eda 6180 	lod	X, #24960
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    6fa8:	4821      	mulu	YA, A, Y
    6faa:	4c63      	divu	YA, X
    6fac:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6fae:	52d8 0106 	mov	0x106 <_g_i16Current>, A
		{
			/* Average current = unfiltered_current * Motor_PWM_DutyCycle */
			g_i16Current = (int16) muldivU16_U16byU16byU16( (uint16) GetMotorDriverCurrent(), g_u16CorrectionRatio, (PWM_REG_PERIOD << (4 + PWM_PRESCALER_N)));

			if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0U )
    6fb2:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    6fb4:	b401      	and	A, #1
    6fb6:	1d0e      	jne	0x6fd4 <_main+0x208>
			{
				/* Motor holding mode: Update motor-current LPF for PID-control */
				MotorDriverCurrentMeasure( FALSE);
    6fb8:	7000      	lod	A, #0
    6fba:	82db 8f42 	callf	0x8f42 <_MotorDriverCurrentMeasure>
    6fbe:	000a      	jmp	0x6fd4 <_main+0x208>
			}
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0U )
    6fc0:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    6fc2:	b401      	and	A, #1
    6fc4:	1d07      	jne	0x6fd4 <_main+0x208>
#else  /* LIN_COMM */
		if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0U )
#endif /* LIN_COMM */
		{
			g_i16Current = 0;
    6fc6:	7c00      	lod	X, #0
    6fc8:	5ed8 0106 	mov	0x106 <_g_i16Current>, X
			g_u16MotorCurrentLPFx64 = 0U;
    6fcc:	5d54      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, X
			g_u16MotorCurrentMovAvgxN = 0U;
    6fce:	5d52      	mov	dp:0x52 <_g_u16MotorCurrentMovAvgxN>, X
			MeasureVsupplyAndTemperature();										/* Perform Vbat/Temperature measurement incase motor is stopped */
    6fd0:	82db 8762 	callf	0x8762 <_MeasureVsupplyAndTemperature>

		/* ************************************************************** */
		/* *** e. Chip and Motor Driver voltage (degraded-mode check) *** */
		/* ************************************************************** */
		/* Calculate Voltage (100LSB/V) [10mV] */
		GetVsupply();
    6fd4:	82db 8612 	callf	0x8612 <_GetVsupply>
		GetVsupplyMotor();
    6fd8:	82db 864e 	callf	0x864e <_GetVsupplyMotor>
		if ( g_i16MotorVoltage < (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS) )
    6fdc:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x52>
    6fde:	5cf2      	usex	A
    6fe0:	4872 0019 	muls	A, A, #25
    6fe4:	4472      	asr	A
    6fe6:	5213      	mov	[S-20], A
    6fe8:	7ae2      	lod	Y, A
    6fea:	e0ce      	add	Y, #-50
    6fec:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    6fee:	aee6      	cmp	A, Y
    6ff0:	1e91      	jsge	0x7014 <_main+0x248>
		{
			/* First time application under-voltage error */
			if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_UV) == 0x00U )
    6ff2:	66d8 00fa 	lod	YL, 0xfa <_l_e8ErrorDebounceFilter>
    6ff6:	72e6      	lod	A, Y
    6ff8:	b404      	and	A, #4
    6ffa:	1d03      	jne	0x7002 <_main+0x236>
			{
				/* Need twice a under-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_UV;
    6ffc:	62e8      	lod	AL, YL
    6ffe:	8404      	or	AL, #4
    7000:	0036      	jmp	0x706e <_main+0x2a2>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_UNDER )
    7002:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    7004:	8c01      	cmp	AL, #1
    7006:	1d01      	jne	0x700a <_main+0x23e>
    7008:	0034      	jmp	0x7072 <_main+0x2a6>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_UNDER;
    700a:	6001      	lod	AL, #1
    700c:	4129      	mov	dp:0x29 <_g_e8ErrorVoltage>, AL
#if (LINPROT == LIN2X_ACT44)
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
#endif /* (LINPROT == LIN2X_ACT44) */
					SetLastError( (uint8) C_ERR_APPL_UNDER_VOLT);
    700e:	72da 00a2 	lod	A, #162
    7012:	001a      	jmp	0x7048 <_main+0x27c>
#if (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44)
				u16DegradeDelay = 0xFFFF;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		else if ( g_i16MotorVoltage > (NVRAM_APPL_OVOLT + C_VOLTAGE_HYS) )
    7014:	61a9      	lod	AL, dp:0xa9 <_g_NvramUser+0x53>
    7016:	5cf2      	usex	A
    7018:	4872 0019 	muls	A, A, #25
    701c:	7ee2      	lod	X, A
    701e:	447e      	asr	X
    7020:	7aee      	lod	Y, X
    7022:	e032      	add	Y, #50
    7024:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    7026:	aee6      	cmp	A, Y
    7028:	1b12      	jsle	0x704e <_main+0x282>
		{
			/* First time application over-voltage error */
			if ( (l_e8ErrorDebounceFilter & C_DEBFLT_ERR_OV) == 0x00U )
    702a:	66d8 00fa 	lod	YL, 0xfa <_l_e8ErrorDebounceFilter>
    702e:	72e6      	lod	A, Y
    7030:	b408      	and	A, #8
    7032:	1d03      	jne	0x703a <_main+0x26e>
			{
				/* Need twice a over-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OV;
    7034:	62e8      	lod	AL, YL
    7036:	8408      	or	AL, #8
    7038:	001a      	jmp	0x706e <_main+0x2a2>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_OVER )
    703a:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    703c:	8c02      	cmp	AL, #2
    703e:	1919      	je	0x7072 <_main+0x2a6>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_OVER;
    7040:	6002      	lod	AL, #2
    7042:	4129      	mov	dp:0x29 <_g_e8ErrorVoltage>, AL
#if (LINPROT == LIN2X_ACT44)
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
#endif /* (LINPROT == LIN2X_ACT44) */
					SetLastError( (uint8) C_ERR_APPL_OVER_VOLT);
    7044:	72da 00a3 	lod	A, #163
    7048:	82db 89e6 	callf	0x89e6 <_SetLastError>
    704c:	0012      	jmp	0x7072 <_main+0x2a6>
#if (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44)
				u16DegradeDelay = 0xFFFFU;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		else if ( (g_i16MotorVoltage >= (NVRAM_APPL_UVOLT + C_VOLTAGE_HYS)) && (g_i16SupplyVoltage <= (NVRAM_APPL_OVOLT - C_VOLTAGE_HYS)) )
    704e:	7a13      	lod	Y, [S-20]
    7050:	e032      	add	Y, #50
    7052:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    7054:	aee6      	cmp	A, Y
    7056:	1a8d      	jsl	0x7072 <_main+0x2a6>
    7058:	7aee      	lod	Y, X
    705a:	e0ce      	add	Y, #-50
    705c:	72d8 010a 	lod	A, 0x10a <_g_i16SupplyVoltage>
    7060:	aee6      	cmp	A, Y
    7062:	1f07      	jsg	0x7072 <_main+0x2a6>
					/* Nothing */
				}
			}
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
#else  /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
    7064:	6000      	lod	AL, #0
    7066:	4129      	mov	dp:0x29 <_g_e8ErrorVoltage>, AL
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
    7068:	62d8 00fa 	lod	AL, 0xfa <_l_e8ErrorDebounceFilter>
    706c:	94f3      	and	AL, #-13
    706e:	42d8 00fa 	mov	0xfa <_l_e8ErrorDebounceFilter>, AL
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
		}

#if _SUPPORT_LIN_UV
		if ( NVRAM_LIN_UV != 0 )
    7072:	61c3      	lod	AL, dp:0xc3 <__bss_dp_size+0x13>
    7074:	b407      	and	A, #7
    7076:	191d      	je	0x70b2 <_main+0x2e6>
		{
			if ( g_i16MotorVoltage >= (int16) (600 + (NVRAM_LIN_UV * 50)) )
    7078:	4872 0032 	muls	A, A, #50
    707c:	a2da 0258 	add	A, #600
    7080:	791c      	lod	Y, dp:0x1c <_g_i16MotorVoltage>
    7082:	eee2      	cmp	Y, A
    7084:	1a84      	jsl	0x708e <_main+0x2c2>
			{
				g_u16LinUVTimeCounter = 0U;										/* Stop LIN UV time-counter */
    7086:	7800      	lod	Y, #0
    7088:	5ad8 0142 	mov	0x142 <_g_u16LinUVTimeCounter>, Y
    708c:	0012      	jmp	0x70b2 <_main+0x2e6>
			}
			else if ( g_u16LinUVTimeCounter > PI_TICKS_PER_SECOND )
    708e:	72d8 0142 	lod	A, 0x142 <_g_u16LinUVTimeCounter>
    7092:	aeda 07d0 	cmp	A, #2000
    7096:	1a08      	jule	0x70a8 <_main+0x2dc>
			{
				/* Restart MLX4 Bus-timeout */
				(void) ml_Disconnect();
    7098:	82db 5c62 	callf	0x5c62 <_ml_Disconnect>
				(void) ml_Connect();
    709c:	82db 5c5e 	callf	0x5c5e <_ml_Connect>
				g_u16LinUVTimeCounter = 1;										/* Re-start LIN UV time-counter */
    70a0:	7c01      	lod	X, #1
    70a2:	5ed8 0142 	mov	0x142 <_g_u16LinUVTimeCounter>, X
    70a6:	0005      	jmp	0x70b2 <_main+0x2e6>
			}
			else if ( g_u16LinUVTimeCounter == 0U )
    70a8:	ac00      	cmp	A, #0
    70aa:	1d03      	jne	0x70b2 <_main+0x2e6>
			{
				g_u16LinUVTimeCounter = 1U;										/* Start LIN UV time-counter */
    70ac:	7001      	lod	A, #1
    70ae:	52d8 0142 	mov	0x142 <_g_u16LinUVTimeCounter>, A

		/* ************************************************************* */
		/* *** f. Chip and ambient temperature (degraded-mode check) *** */
		/* ************************************************************* */
		/* Calculate Chip internal temperature (1LSB/C) [C] */
		GetChipTemperature( FALSE);
    70b2:	7000      	lod	A, #0
    70b4:	82db 8692 	callf	0x8692 <_GetChipTemperature>
#if _SUPPORT_AMBIENT_TEMP
		SelfHeatCompensation();
    70b8:	82db 9ef0 	callf	0x9ef0 <_SelfHeatCompensation>
		if ( ((g_i16AmbjTemperature > (int16) (NVRAM_APPL_OTEMP + C_TEMPERATURE_HYS)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) ||
    70bc:	61a7      	lod	AL, dp:0xa7 <_g_NvramUser+0x51>
    70be:	5cf2      	usex	A
    70c0:	7ee2      	lod	X, A
    70c2:	7ae2      	lod	Y, A
    70c4:	e0c7      	add	Y, #-57
    70c6:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    70c8:	aee6      	cmp	A, Y
    70ca:	1b03      	jsle	0x70d2 <_main+0x306>
    70cc:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    70ce:	b401      	and	A, #1
    70d0:	1904      	je	0x70da <_main+0x30e>
    70d2:	7120      	lod	A, dp:0x20 <__data_dp_size>
    70d4:	aeda 0099 	cmp	A, #153
    70d8:	1b14      	jsle	0x7102 <_main+0x336>
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( ((g_i16ChipTemperature > (int16) (NVRAM_APPL_OTEMP + C_TEMPERATURE_HYS)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) ||
			 (g_i16ChipTemperature > C_CHIP_OVERTEMP_LEVEL) )
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_YES )
    70da:	6124      	lod	AL, dp:0x24 <_g_e8ErrorOverTemperature>
    70dc:	8c01      	cmp	AL, #1
    70de:	191d      	je	0x711a <_main+0x34e>
			{
				if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT) == 0x00U )
    70e0:	66d8 00fa 	lod	YL, 0xfa <_l_e8ErrorDebounceFilter>
    70e4:	72e6      	lod	A, Y
    70e6:	b402      	and	A, #2
    70e8:	1d03      	jne	0x70f0 <_main+0x324>
				{
					/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
					l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVT;
    70ea:	62e8      	lod	AL, YL
    70ec:	8402      	or	AL, #2
    70ee:	0013      	jmp	0x7116 <_main+0x34a>
				}
				else
				{
					g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    70f0:	6001      	lod	AL, #1
    70f2:	4124      	mov	dp:0x24 <_g_e8ErrorOverTemperature>, AL
					g_u16TargetPosition = g_u16ActualPosition;				/* If over-temperature, then FPOS = CPOS (9.5.3.2) */
    70f4:	79ec      	lod	Y, dp:0xec <_g_u16ActualPosition>
    70f6:	59ee      	mov	dp:0xee <_g_u16TargetPosition>, Y
						{
							g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
						}
					}
#endif /* _SUPPORT_OVT_PED */
					SetLastError( (uint8) C_ERR_APPL_OVER_TEMP);
    70f8:	72da 00a1 	lod	A, #161
    70fc:	82db 89e6 	callf	0x89e6 <_SetLastError>
    7100:	000c      	jmp	0x711a <_main+0x34e>
				}
			}
		}
#if _SUPPORT_AMBIENT_TEMP
		else if ( g_i16AmbjTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
    7102:	7aee      	lod	Y, X
    7104:	e0c1      	add	Y, #-63
    7106:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    7108:	aee6      	cmp	A, Y
    710a:	1e87      	jsge	0x711a <_main+0x34e>
#else  /* _SUPPORT_AMBIENT_TEMP */
		else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_NO;
    710c:	6000      	lod	AL, #0
    710e:	4124      	mov	dp:0x24 <_g_e8ErrorOverTemperature>, AL
			l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVT;
    7110:	62d8 00fa 	lod	AL, 0xfa <_l_e8ErrorDebounceFilter>
    7114:	94fd      	and	AL, #-3
    7116:	42d8 00fa 	mov	0xfa <_l_e8ErrorDebounceFilter>, AL

		/* ****************************** */
		/* *** g. Degraded-mode check *** */
		/* ****************************** */
		/* Degraded check */
		if ( ((g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE) ||
    711a:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    711c:	1d03      	jne	0x7124 <_main+0x358>
    711e:	6124      	lod	AL, dp:0x24 <_g_e8ErrorOverTemperature>
    7120:	8c01      	cmp	AL, #1
    7122:	1d1d      	jne	0x715e <_main+0x392>
    7124:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7126:	8c00      	cmp	AL, #0
    7128:	1a9a      	jsl	0x715e <_main+0x392>
			  (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_YES)) &&
			 ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) == 0U) )
		{
			/* Not in degradation state; Stop motor, remember last "request" and enter degradation state */
			if ( g_e8MotorRequest != (uint8) C_MOTOR_REQUEST_NONE )
    712a:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    712c:	1904      	je	0x7136 <_main+0x36a>
			{
				g_e8DegradedMotorRequest = g_e8MotorRequest;
    712e:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7130:	6400      	lod	YL, #0
    7132:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
    7134:	0008      	jmp	0x7146 <_main+0x37a>
				MotorDriverStop( (uint16) C_STOP_RAMPDOWN);						/* Degraded-mode (Running) */
			}
			else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0U )
    7136:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7138:	b401      	and	A, #1
    713a:	1907      	je	0x714a <_main+0x37e>
			{
				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )
    713c:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    713e:	8c01      	cmp	AL, #1
    7140:	1d0b      	jne	0x7158 <_main+0x38c>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;	/* Set before Diagnostics UV/OV kicks-in */
    7142:	6003      	lod	AL, #3
    7144:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Degraded-mode (Running) */
    7146:	7000      	lod	A, #0
    7148:	0005      	jmp	0x7154 <_main+0x388>
				else
				{
					/* "Stopping" */
				}
			}
			else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    714a:	6123      	lod	AL, dp:0x23 <_g_e8DegradedMotorRequest>
    714c:	1d05      	jne	0x7158 <_main+0x38c>
			{
				/* Actuator is stopped, but maybe still powered (holding-mode);
				 * Request to stop without ramp-down */
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;		/* In case non-degraded mode, (optionally) turn on holding-mode */
    714e:	6001      	lod	AL, #1
    7150:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Degraded-mode */
    7152:	7002      	lod	A, #2
    7154:	82db 9296 	callf	0x9296 <_MotorDriverStop>
			}
			else
			{
				/* Nothing */
			}
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    7158:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    715a:	8480      	or	AL, #-128
    715c:	000e      	jmp	0x717a <_main+0x3ae>
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) && 
    715e:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7160:	8c00      	cmp	AL, #0
    7162:	1e8c      	jsge	0x717c <_main+0x3b0>
    7164:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    7166:	1d0a      	jne	0x717c <_main+0x3b0>
    7168:	6124      	lod	AL, dp:0x24 <_g_e8ErrorOverTemperature>
    716a:	1d08      	jne	0x717c <_main+0x3b0>
			 (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && 
			 (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_NO) )
		{
			/* No longer degraded mode */
			if ( g_e8DegradedMotorRequest != (uint8) C_MOTOR_REQUEST_NONE ) 
    716c:	6123      	lod	AL, dp:0x23 <_g_e8DegradedMotorRequest>
    716e:	1903      	je	0x7176 <_main+0x3aa>
			{
				g_e8MotorRequest = (uint8) g_e8DegradedMotorRequest;
    7170:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7172:	6000      	lod	AL, #0
    7174:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
			}
			g_e8MotorStatusMode &= (uint8) ~C_MOTOR_STATUS_DEGRADED;
    7176:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7178:	947f      	and	AL, #127
    717a:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
		/* ************************************************* */
		/* *** i. Handling Motor Request (Emergency Run) *** */
		/* ************************************************* */
#if (_SUPPORT_BUSTIMEOUT)
		/* Bus-timeout occurred */
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_EMRUN )
    717c:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    717e:	8c07      	cmp	AL, #7
    7180:	1901      	je	0x7184 <_main+0x3b8>
    7182:	0031      	jmp	0x71e6 <_main+0x41a>
		{
			/* Actuator move's towards Emergency Run position */
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7184:	6400      	lod	YL, #0
    7186:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL

#if (((LINPROT & LINXX) == LIN2X) || ((LINPROT & LINXX) == LIN2J))
			if ( g_NvramUser.EmergencyRunEndStopHi == 0U )
    7188:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    718a:	9404      	and	AL, #4
    718c:	1d03      	jne	0x7194 <_main+0x3c8>
			{
				/* Move to Low EndStop */
				g_u16TargetPosition = C_MIN_POS;
    718e:	7c00      	lod	X, #0
    7190:	5dee      	mov	dp:0xee <_g_u16TargetPosition>, X
    7192:	0003      	jmp	0x719a <_main+0x3ce>
			}
			else
			{
				/* Move to High EndStop */
				g_u16TargetPosition = C_MAX_POS;
    7194:	72da 00ff 	lod	A, #255
    7198:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
			}
			if ( g_NvramUser.MotorDirectionCCW )
    719a:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    719c:	b401      	and	A, #1
    719e:	1904      	je	0x71a8 <_main+0x3dc>
			{
				g_u16TargetPosition = C_MAX_POS - g_u16TargetPosition;
    71a0:	72da 00ff 	lod	A, #255
    71a4:	a9ee      	sub	A, dp:0xee <_g_u16TargetPosition>
    71a6:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
			}
#if (LINPROT == LIN2J_VALVE_VW)
			/* Convert GM percentage position to micro-step position */
			if ( g_u16TargetPosition == C_MIN_POS )
    71a8:	71ee      	lod	A, dp:0xee <_g_u16TargetPosition>
    71aa:	1904      	je	0x71b4 <_main+0x3e8>
			{
				g_u16TargetPosition = 0U;
			}
			else
			{
				g_u16TargetPosition = g_u16CalibTravel + (2U * C_PERC_OFFSET);
    71ac:	71f2      	lod	A, dp:0xf2 <_g_u16CalibTravel>
    71ae:	a2da 1200 	add	A, #4608
    71b2:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
			}
#endif /* (LINPROT == LIN2J_VALVE_VW)*/

			if ( g_u16TargetPosition != g_u16ActualPosition )
    71b4:	71ee      	lod	A, dp:0xee <_g_u16TargetPosition>
    71b6:	adec      	cmp	A, dp:0xec <_g_u16ActualPosition>
    71b8:	1916      	je	0x71e6 <_main+0x41a>
			{
				/* Only move actuator when not already at position */
				g_u8EmergencyRunOcc = TRUE;
    71ba:	6001      	lod	AL, #1
    71bc:	4125      	mov	dp:0x25 <_g_u8EmergencyRunOcc>, AL
				g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;
    71be:	6007      	lod	AL, #7
    71c0:	41e9      	mov	dp:0xe9 <_g_e8StallDetectorEna>, AL
				g_u8StallOcc = FALSE;
    71c2:	6400      	lod	YL, #0
    71c4:	4526      	mov	dp:0x26 <_g_u8StallOcc>, YL
				g_u8StallTypeComm &= ~M_STALL_MODE;
    71c6:	611a      	lod	AL, dp:0x1a <_g_u8StallTypeComm>
    71c8:	9487      	and	AL, #-121
    71ca:	411a      	mov	dp:0x1a <_g_u8StallTypeComm>, AL
				if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_RUNNING )
    71cc:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    71ce:	8c01      	cmp	AL, #1
    71d0:	1902      	je	0x71d6 <_main+0x40a>
				{
					/* If motor not running, set speed; Otherwise leave speed as is */
					g_u8MotorCtrlSpeed = (uint8) C_MOTOR_SPEED_MID;
    71d2:	6003      	lod	AL, #3
    71d4:	41f0      	mov	dp:0xf0 <_g_u8MotorCtrlSpeed>, AL
				}
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    71d6:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    71d8:	8c00      	cmp	AL, #0
    71da:	1e83      	jsge	0x71e2 <_main+0x416>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    71dc:	6003      	lod	AL, #3
    71de:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
    71e0:	0002      	jmp	0x71e6 <_main+0x41a>
				}
				else
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    71e2:	6003      	lod	AL, #3
    71e4:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
#endif /* (_SUPPORT_BUSTIMEOUT) */

		/* ********************************************************************************************* */
		/* *** j. Handling Motor Request (resp. STOP, INIT, START, CALIBRATION, SLEEP, SPEED-CHANGE) *** */
		/* ********************************************************************************************* */
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_STOP )
    71e6:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    71e8:	4211      	mov	[S-18], AL
    71ea:	8c01      	cmp	AL, #1
    71ec:	1d0a      	jne	0x7202 <_main+0x436>
		{
			/* Stop Actuator */
			g_u8RewindFlags &= (uint8) ~(C_REWIND_ACTIVE | C_REWIND_REWIND);
    71ee:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    71f0:	94d7      	and	AL, #-41
    71f2:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
			MotorDriverStop( (uint16) C_STOP_RAMPDOWN);							/* LIN-command request */
    71f4:	7000      	lod	A, #0
    71f6:	82db 9296 	callf	0x9296 <_MotorDriverStop>
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    71fa:	6400      	lod	YL, #0
    71fc:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    71fe:	4523      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, YL
    7200:	00f6      	jmp	0x73ee <_main+0x622>
#if _SUPPORT_AUTO_CALIBRATION
			g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
#endif /* _SUPPORT_AUTO_CALIBRATION */
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_INIT) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_INIT) )
    7202:	6211      	lod	AL, [S-18]
    7204:	8c02      	cmp	AL, #2
    7206:	1904      	je	0x7210 <_main+0x444>
    7208:	6123      	lod	AL, dp:0x23 <_g_e8DegradedMotorRequest>
    720a:	4210      	mov	[S-17], AL
    720c:	8c02      	cmp	AL, #2
    720e:	1d08      	jne	0x7220 <_main+0x454>
		{
			/* Actuator initialisation: Set new actual position */
			g_u16ActuatorActPos = g_u16ActualPosition;
    7210:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    7212:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7214:	6400      	lod	YL, #0
    7216:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7218:	4523      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, YL
			g_e8CalibrationStep = (uint8) C_CALIB_DONE;
    721a:	6007      	lod	AL, #7
    721c:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    721e:	00e7      	jmp	0x73ee <_main+0x622>
		}
#endif /* LIN_COMM */
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_START) && (g_u8MotorStartDelay == 0) )
    7220:	6211      	lod	AL, [S-18]
    7222:	8c03      	cmp	AL, #3
    7224:	1901      	je	0x7228 <_main+0x45c>
    7226:	008e      	jmp	0x7344 <_main+0x578>
    7228:	62d8 00fc 	lod	AL, 0xfc <_g_u8MotorStartDelay>
    722c:	1901      	je	0x7230 <_main+0x464>
    722e:	008d      	jmp	0x734a <_main+0x57e>
		{	
			/* Start Actuator */
#define C_MAX_VALID_MOTOR_CURR	600U		/* 600mA */
			uint16 u16MotorCurrent;												/* MMP170405-2 - Begin */
			if ( g_u16MotorCurrentMovAvgxN == 0U )
    7230:	7952      	lod	Y, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    7232:	1d05      	jne	0x723e <_main+0x472>
			{
				/* Sample once the motor current */
				MeasureMotorCurrent();
    7234:	82db 8790 	callf	0x8790 <_MeasureMotorCurrent>
				u16MotorCurrent = (uint16) GetMotorDriverCurrent();
    7238:	82db 874e 	callf	0x874e <_GetMotorDriverCurrent>
    723c:	0008      	jmp	0x724e <_main+0x482>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    723e:	72d8 011e 	lod	A, 0x11e <_g_u16MCurrgain>
    uint32 result;

    __asm__ __volatile__ (
    7242:	4801      	mulu	D, A, Y
    7244:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    7246:	4c22 1000 	add	YA, #4096
    724a:	0000 
    724c:	48ac      	lsr	YA, #13
    724e:	7ee2      	lod	X, A
			else
			{
				/* Use sampled (running or holding) motor current */
				u16MotorCurrent = (uint16) ((mulU32_U16byU16( g_u16MotorCurrentMovAvgxN, g_u16MCurrgain) + (C_GMCURR_DIV << (C_MOVAVG_SSZ - 1U))) / (C_GMCURR_DIV << C_MOVAVG_SSZ)); /* Moving average-motor current [mA] */
			}
			if ( (g_u16ActualPosition != g_u16TargetPosition) &&
    7250:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    7252:	520f      	mov	[S-16], A
    7254:	79ee      	lod	Y, dp:0xee <_g_u16TargetPosition>
    7256:	5a0d      	mov	[S-14], Y
    7258:	aee6      	cmp	A, Y
    725a:	1d01      	jne	0x725e <_main+0x492>
    725c:	0070      	jmp	0x733e <_main+0x572>
    725e:	ec00      	cmp	Y, #0
    7260:	1d05      	jne	0x726c <_main+0x4a0>
    7262:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    7264:	aeda 0900 	cmp	A, #2304
    7268:	1d01      	jne	0x726c <_main+0x4a0>
    726a:	0069      	jmp	0x733e <_main+0x572>
    726c:	71f2      	lod	A, dp:0xf2 <_g_u16CalibTravel>
    726e:	520b      	mov	[S-12], A
    7270:	a2da 1200 	add	A, #4608
    7274:	7a0d      	lod	Y, [S-14]
    7276:	eee2      	cmp	Y, A
    7278:	1d07      	jne	0x7288 <_main+0x4bc>
    727a:	7a0b      	lod	Y, [S-12]
    727c:	e2da 0900 	add	Y, #2304
    7280:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    7282:	aee6      	cmp	A, Y
    7284:	1d01      	jne	0x7288 <_main+0x4bc>
    7286:	005b      	jmp	0x733e <_main+0x572>
    7288:	2eda 0257 	cmp	X, #599
    728c:	1a01      	jule	0x7290 <_main+0x4c4>
    728e:	0057      	jmp	0x733e <_main+0x572>
				!((g_u16TargetPosition == (g_u16CalibTravel + (2*C_PERC_OFFSET))) && (g_u16ActuatorActPos == (g_u16CalibTravel + C_PERC_OFFSET))) && /* Not position '255' */
				(u16MotorCurrent < C_MAX_VALID_MOTOR_CURR) )					/* MMP170405-2 - End */
			{
				uint8 u8NewMotorDirectionCCW;
#if LIN_COMM
				uint8 u8MotorSpeedIdx = (uint8) (g_u8MotorCtrlSpeed & 0x07U);
    7290:	61f0      	lod	AL, dp:0xf0 <_g_u8MotorCtrlSpeed>
    7292:	b407      	and	A, #7
				g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    7294:	4119      	mov	dp:0x19 <_g_u8MotorStatusSpeed>, AL
				g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[u8MotorSpeedIdx];
    7296:	4422      	asl	A
    7298:	7ae2      	lod	Y, A
    729a:	e2da 0178 	add	Y, #376
    729e:	7ef0      	lod	X, [Y]
    72a0:	5ed8 0160 	mov	0x160 <_g_u16MotorSpeedRPS>, X
				g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[u8MotorSpeedIdx];
    72a4:	7ae2      	lod	Y, A
    72a6:	e2da 0168 	add	Y, #360
    72aa:	72f0      	lod	A, [Y]
    72ac:	5150      	mov	dp:0x50 <__data_size>, A
				g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_2;
				g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[C_MOTOR_SPEED_2];		/* Use Speed #2 as default */
				g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[C_MOTOR_SPEED_2];
#endif /* LIN_COMM */

				u8NewMotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? TRUE : FALSE;
    72ae:	7c00      	lod	X, #0
    72b0:	7a0d      	lod	Y, [S-14]
    72b2:	ee0f      	cmp	Y, [S-16]
    72b4:	1c01      	jnc	0x72b8 <_main+0x4ec>
    72b6:	7c01      	lod	X, #1

				if ( g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT )
    72b8:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    72ba:	b402      	and	A, #2
    72bc:	1d01      	jne	0x72c0 <_main+0x4f4>
    72be:	002e      	jmp	0x731c <_main+0x550>
				{
					if ( (NVRAM_REWIND_STEPS != 0U) &&
    72c0:	61be      	lod	AL, dp:0xbe <__bss_dp_size+0xe>
    72c2:	66e0      	lod	YL, AL
    72c4:	5cf6      	usex	Y
    72c6:	1924      	je	0x7310 <_main+0x544>
    72c8:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    72ca:	b401      	and	A, #1
    72cc:	aeee      	cmp	A, X
    72ce:	1903      	je	0x72d6 <_main+0x50a>
    72d0:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    72d2:	b404      	and	A, #4
    72d4:	191d      	je	0x7310 <_main+0x544>
						(((g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == u8NewMotorDirectionCCW) || (g_u8RewindFlags & C_REWIND_DIRECTION_AUTO)) )
					{
						/* Start rewind-function, with "rewinding" */
						g_u8RewindFlags = (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND);	/* Start rewind-process */
    72d6:	6028      	lod	AL, #40
    72d8:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
						g_u16TargetPositionRewind = g_u16TargetPosition;
    72da:	720d      	lod	A, [S-14]
    72dc:	52d8 0148 	mov	0x148 <__data_end>, A
						if ( u8NewMotorDirectionCCW )
    72e0:	2c00      	cmp	X, #0
    72e2:	190c      	je	0x72fc <_main+0x530>
						{
#if (LINPROT == LIN2J_VALVE_VW)
							if ( g_u16ActualPosition < (uint16) ((g_u16CalibTravel + C_PERC_OFFSET) - NVRAM_REWIND_STEPS) )
    72e4:	720b      	lod	A, [S-12]
    72e6:	aae6      	sub	A, Y
    72e8:	a2da 0900 	add	A, #2304
    72ec:	5201      	mov	[S-2], A
    72ee:	720f      	lod	A, [S-16]
    72f0:	ae01      	cmp	A, [S-2]
    72f2:	1c0b      	jnc	0x730a <_main+0x53e>
#else  /* (LINPROT == LIN2J_VALVE_VW) */
							if ( g_u16ActualPosition < (uint16) (C_MAX_POS - NVRAM_REWIND_STEPS) )
#endif /* (LINPROT == LIN2J_VALVE_VW) */
							{
								g_u16TargetPosition = g_u16ActualPosition + NVRAM_REWIND_STEPS;
    72f4:	a2e6      	add	A, Y
    72f6:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
								u8NewMotorDirectionCCW = FALSE;
    72f8:	7c00      	lod	X, #0
    72fa:	0010      	jmp	0x731c <_main+0x550>
								g_u8RewindFlags = 0U;							/* No rewind possible */
							}
						}
						else
						{
							if ( g_u16ActualPosition > NVRAM_REWIND_STEPS )
    72fc:	720f      	lod	A, [S-16]
    72fe:	aee6      	cmp	A, Y
    7300:	1a04      	jule	0x730a <_main+0x53e>
							{
								g_u16TargetPosition = g_u16ActualPosition - NVRAM_REWIND_STEPS;
    7302:	aae6      	sub	A, Y
    7304:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
								u8NewMotorDirectionCCW = TRUE;
    7306:	7c01      	lod	X, #1
    7308:	0009      	jmp	0x731c <_main+0x550>
							}
							else
							{
								g_u8RewindFlags = 0U;							/* No rewind possible */
    730a:	6400      	lod	YL, #0
    730c:	4522      	mov	dp:0x22 <_g_u8RewindFlags>, YL
    730e:	0006      	jmp	0x731c <_main+0x550>
							}
						}
					}
					else if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != u8NewMotorDirectionCCW )
    7310:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    7312:	b401      	and	A, #1
    7314:	aeee      	cmp	A, X
    7316:	1902      	je	0x731c <_main+0x550>
					{
						g_u8RewindFlags = 0U;									/* Clear previous detected stall flags */
    7318:	6000      	lod	AL, #0
    731a:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
					}
				}

				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP )
    731c:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    731e:	1d05      	jne	0x732a <_main+0x55e>
				{
					g_e8MotorDirectionCCW = u8NewMotorDirectionCCW;
    7320:	7aee      	lod	Y, X
    7322:	4528      	mov	dp:0x28 <_g_e8MotorDirectionCCW>, YL
					MotorDriverStart();
    7324:	82db 9140 	callf	0x9140 <_MotorDriverStart>
    7328:	000a      	jmp	0x733e <_main+0x572>
				}
				else if ( u8NewMotorDirectionCCW != g_e8MotorDirectionCCW )
    732a:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    732c:	7aee      	lod	Y, X
    732e:	8ee8      	cmp	AL, YL
    7330:	1904      	je	0x733a <_main+0x56e>
				{
					/* Changing direction; Stop motor first before starting in opposite direction */
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Change of direction */
    7332:	7000      	lod	A, #0
    7334:	82db 9296 	callf	0x9296 <_MotorDriverStop>
					continue;
    7338:	0620      	jmp	0x6f7a <_main+0x1ae>
				}
				else
				{
					g_u16ActuatorTgtPos = g_u16TargetPosition;					/* Motor already started; Update target-position only */
    733a:	7dee      	lod	X, dp:0xee <_g_u16TargetPosition>
    733c:	5df6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, X
				}
			}
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    733e:	6000      	lod	AL, #0
    7340:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
    7342:	0055      	jmp	0x73ee <_main+0x622>
					g_e8StallDetectorEna &= (uint8) ~C_STALLDET_CALIB;
				}
			}
		}
#endif /* _SUPPORT_AUTO_CALIBRATION */
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) )
    7344:	6211      	lod	AL, [S-18]
    7346:	8c06      	cmp	AL, #6
    7348:	1904      	je	0x7352 <_main+0x586>
    734a:	6210      	lod	AL, [S-17]
    734c:	8c06      	cmp	AL, #6
    734e:	1901      	je	0x7352 <_main+0x586>
    7350:	0037      	jmp	0x73c0 <_main+0x5f4>
		{
			/* Actuator enters (Deep-)SLEEP mode (lowest power mode; Only LIN/PWM message can wake-up) */
			if ( ((g_e8MotorStatusMode & ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) &&
    7352:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7354:	b47f      	and	A, #127
    7356:	1d2e      	jne	0x73b4 <_main+0x5e8>
    7358:	6132      	lod	AL, dp:0x32 <_g_u8MotorStopDelay>
    735a:	1d2c      	jne	0x73b4 <_main+0x5e8>
    735c:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    7360:	b401      	and	A, #1
    7362:	1d28      	jne	0x73b4 <_main+0x5e8>
					(g_u8MotorStopDelay == 0U) &&
					((NV_CTRL & NV_BUSY) == 0U) )
			{
				if ( g_u8MotorHoldingCurrEna &&									/* Holding mode enabled */
    7364:	61ea      	lod	AL, dp:0xea <_g_u8MotorHoldingCurrEna>
    7366:	1908      	je	0x7378 <_main+0x5ac>
    7368:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    736a:	8c02      	cmp	AL, #2
    736c:	1905      	je	0x7378 <_main+0x5ac>
    736e:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    7370:	1d03      	jne	0x7378 <_main+0x5ac>
					(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) )
				{
					MotorDriverStop( (uint16) C_STOP_SLEEP);					/* Disable holding current */
    7372:	7003      	lod	A, #3
    7374:	82db 9296 	callf	0x9296 <_MotorDriverStop>

#if (LINPROT == LIN2J_VALVE_VW)
				/* Before the actuator enters in Sleep, it saves in EEPROM the CPOS,
				 * the Status and the NAD only if the value of cells is different as the RAM value.
				 */
				LIN_SAE_J2602_Store();											/* MMP160613-2 */
    7378:	136d      	call	0x7a54 <_LIN_SAE_J2602_Store>
				 * Wake up is done by resetting the chip. The source of the wake up can be found in ANA_INB.
				 * Note: In case between MLX4_HALT and MLX16_HALT a LIN-bus event happens, the chip will not
				 * enter SLEEP but HALT-mode. To allow a LIN wake-up, the Analogue Watchdog is set to minimum
				 * period of 100us to allow a chip reset.
				 */
				IO_WU = 0U;														/* Disable IO3 wake up */
    737a:	7800      	lod	Y, #0
    737c:	5ad8 28c8 	mov	0x28c8 <__io__+0xc8>, Y
				ANA_OUTG = ANA_OUTG & 0xFF9EU;									/* Clear Internal WU delay and DIS_GTSM */
    7380:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    7384:	b49e      	and	A, #-98
    7386:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
				MASK = 0U;
    738a:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y
				ADC_Stop();
    738e:	82db 840c 	callf	0x840c <_ADC_Stop>
				/* Go into sleep/halt */
				AWD_CTRL = (3U << 8) | 1U;										/* Set 1:1 prescaler and minimal period; AWD timeout will be 100 us */
    7392:	7eda 0301 	lod	X, #769
    7396:	5e9a      	mov	io:0x1a <_g_u8StallTypeComm>, X
				MLX4_RESET();
    7398:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    739c:	94fe      	and	AL, #-2
    739e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				MLX16_HALT();													/* See MELEXIS doc */
    73a2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    73a6:	8402      	or	AL, #2
    73a8:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    73ac:	0000      	nop
				/* Chip should reset upon LIN bus changes */
				/* We should never make it to here, as a backup we add a chip reset */
				MLX16_RESET();
    73ae:	82db 59dc 	callf	0x59dc <_MLX16_RESET>
    73b2:	001d      	jmp	0x73ee <_main+0x622>
			}
			else if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_STOP )
    73b4:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    73b6:	191b      	je	0x73ee <_main+0x622>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);	
    73b8:	7001      	lod	A, #1
    73ba:	82db 9296 	callf	0x9296 <_MotorDriverStop>
    73be:	0017      	jmp	0x73ee <_main+0x622>
			}
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SPEED_CHANGE) && (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) )
    73c0:	6211      	lod	AL, [S-18]
    73c2:	8c08      	cmp	AL, #8
    73c4:	1d14      	jne	0x73ee <_main+0x622>
    73c6:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    73c8:	8c01      	cmp	AL, #1
    73ca:	1d11      	jne	0x73ee <_main+0x622>
		{
			uint8 u8MotorSpeedIdx = (g_u8MotorCtrlSpeed & 0x07U);
    73cc:	61f0      	lod	AL, dp:0xf0 <_g_u8MotorCtrlSpeed>
    73ce:	b407      	and	A, #7
			g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    73d0:	4119      	mov	dp:0x19 <_g_u8MotorStatusSpeed>, AL
			g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[u8MotorSpeedIdx];
    73d2:	4422      	asl	A
    73d4:	7ae2      	lod	Y, A
    73d6:	e2da 0178 	add	Y, #376
    73da:	7ef0      	lod	X, [Y]
    73dc:	5ed8 0160 	mov	0x160 <_g_u16MotorSpeedRPS>, X
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[u8MotorSpeedIdx];
    73e0:	7ae2      	lod	Y, A
    73e2:	e2da 0168 	add	Y, #360
    73e6:	72f0      	lod	A, [Y]
    73e8:	5150      	mov	dp:0x50 <__data_size>, A
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    73ea:	6400      	lod	YL, #0
    73ec:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
			}
		}
#endif /* _SUPPORT_SPEED_AUTO */

		/* Update status actual-position (only in case not the initial position have been changed) */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0U) &&
    73ee:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    73f0:	b401      	and	A, #1
    73f2:	1905      	je	0x73fe <_main+0x632>
    73f4:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    73f6:	b408      	and	A, #8
    73f8:	1d02      	jne	0x73fe <_main+0x632>
			 ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0U) )
		{
			g_u16ActualPosition = g_u16ActuatorActPos;
    73fa:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    73fc:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
		}

		/* ********************************************************** */
		/* *** l. Threshold control (Stepper: Current-threshold) *** */
		/* ********************************************************** */
		ThresholdControl();													
    73fe:	82db 9db2 	callf	0x9db2 <_ThresholdControl>

		/* ************************************************* */
		/* *** m. PID control (Stepper: current-control) *** */
		/* ************************************************* */
		PID_Control();															/* PID-control (Current) */
    7402:	82db 9c78 	callf	0x9c78 <_PID_Control>
		{
			uint16 u16Mlx4CounterThreshold = C_MLX4_STATE_TIMEOUT;
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4)
			{
				/* MLX4 LIN-Bus activity check when not in LIN-AA mode (only __MLX_PLTF_VERSION_MAJOR__ == 4) */
				if ( (ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0U) )
    7406:	7009      	lod	A, #9
    7408:	82db 5c24 	callf	0x5c24 <_ml_GetState>
    740c:	acff      	cmp	A, #-1
    740e:	190e      	je	0x742c <_main+0x660>
    7410:	62d8 02a4 	lod	AL, 0x2a4 <_LinStatus>
    7414:	b401      	and	A, #1
    7416:	190a      	je	0x742c <_main+0x660>
				{
					/* MLX4 has detected a SYNC field */
					g_u16Mlx4StateCheckCounter = 0U;
    7418:	7c00      	lod	X, #0
    741a:	5ed8 00fe 	mov	0xfe <_g_u16Mlx4StateCheckCounter>, X
					g_u8ErrorCommBusTimeout = FALSE;
    741e:	6000      	lod	AL, #0
    7420:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
					(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    7424:	7008      	lod	A, #8
    7426:	82db 5c24 	callf	0x5c24 <_ml_GetState>
    742a:	0005      	jmp	0x7436 <_main+0x66a>
				}
				else
				{
					g_u16Mlx4StateCheckCounter++;								/* State check counter */
    742c:	72d8 00fe 	lod	A, 0xfe <_g_u16Mlx4StateCheckCounter>
    7430:	a001      	add	A, #1
    7432:	52d8 00fe 	mov	0xfe <_g_u16Mlx4StateCheckCounter>, A
				}
			}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4) */

			if ( (g_u16Mlx4StateCheckCounter >= u16Mlx4CounterThreshold) || ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0) )
    7436:	72d8 00fe 	lod	A, 0xfe <_g_u16Mlx4StateCheckCounter>
    743a:	aeda 03e8 	cmp	A, #1000
    743e:	1c05      	jnc	0x744a <_main+0x67e>
    7440:	62d8 00fd 	lod	AL, 0xfd <_g_u8Mlx4ErrorState>
    7444:	8c00      	cmp	AL, #0
    7446:	1a81      	jsl	0x744a <_main+0x67e>
    7448:	0037      	jmp	0x74b8 <_main+0x6ec>
			{
				/* Didn't receive MLX4 LIN command and/or data-request in the last period, or need immediate reset */
				g_u16Mlx4StateCheckCounter = 0U;								/* MLX4 State check counter reset; MLX4 still active */
    744a:	7800      	lod	Y, #0
    744c:	5ad8 00fe 	mov	0xfe <_g_u16Mlx4StateCheckCounter>, Y
				if ( ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0U) ||
    7450:	62d8 00fd 	lod	AL, 0xfd <_g_u8Mlx4ErrorState>
    7454:	8c00      	cmp	AL, #0
    7456:	1a8b      	jsl	0x746e <_main+0x6a2>
    7458:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    745a:	b440      	and	A, #64
    745c:	1d2a      	jne	0x74b2 <_main+0x6e6>
    745e:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    7460:	8c06      	cmp	AL, #6
    7462:	1927      	je	0x74b2 <_main+0x6e6>
    7464:	7009      	lod	A, #9
    7466:	82db 5c24 	callf	0x5c24 <_ml_GetState>
    746a:	acff      	cmp	A, #-1
    746c:	1d22      	jne	0x74b2 <_main+0x6e6>
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 4) */
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
						&& (ml_GetState() == ml_stINVALID) ) )
#endif /*((__MLX_PLTF_VERSION_MAJOR__ == 3) */
				{
					g_u8Mlx4ErrorState++;
    746e:	62d8 00fd 	lod	AL, 0xfd <_g_u8Mlx4ErrorState>
    7472:	8001      	add	AL, #1
    7474:	42d8 00fd 	mov	0xfd <_g_u8Mlx4ErrorState>, AL
					if ( g_u8Mlx4ErrorState >= (uint8) C_MLX4_STATE_ERROR_THRSHLD )
    7478:	8c03      	cmp	AL, #3
    747a:	1a1e      	jule	0x74b8 <_main+0x6ec>
					{
						/* Signal Error; Reset MLX4 */
						MLX4_RESET();
    747c:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7480:	94fe      	and	AL, #-2
    7482:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
						NOP();
    7486:	0000      	nop
						NOP();
    7488:	0000      	nop
						NOP();
    748a:	0000      	nop
						MLX4_START();
    748c:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7490:	8401      	or	AL, #1
    7492:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
						if ( (g_u8Mlx4ErrorState & C_MLX4_STATE_NOT_LOGGED) == 0U )
    7496:	62d8 00fd 	lod	AL, 0xfd <_g_u8Mlx4ErrorState>
    749a:	b440      	and	A, #64
    749c:	1d04      	jne	0x74a6 <_main+0x6da>
						{
							SetLastError( (uint8) C_ERR_MLX4_RESTART);
    749e:	72da 00fa 	lod	A, #250
    74a2:	82db 89e6 	callf	0x89e6 <_SetLastError>
						}
						LIN_Init( TRUE);										/* Re-initialise LIN interface w/o changing position */
    74a6:	7001      	lod	A, #1
    74a8:	1151      	call	0x774c <_LIN_Init>
						g_u8Mlx4ErrorState = 0U;
    74aa:	6000      	lod	AL, #0
    74ac:	42d8 00fd 	mov	0xfd <_g_u8Mlx4ErrorState>, AL
    74b0:	0003      	jmp	0x74b8 <_main+0x6ec>
					}
				}
				else
				{
					g_u8Mlx4ErrorState = 0U;
    74b2:	6400      	lod	YL, #0
    74b4:	46d8 00fd 	mov	0xfd <_g_u8Mlx4ErrorState>, YL
		}

		/* ********************************** */
		/* *** o. Background System check *** */
		/* ********************************** */
		if ( (u8BackgroundSchedulerTaskID == 0U) || (u8BackgroundSchedulerTaskID == 128U) )
    74b8:	7e17      	lod	X, [S-24]
    74ba:	1903      	je	0x74c2 <_main+0x6f6>
    74bc:	6217      	lod	AL, [S-24]
    74be:	8c80      	cmp	AL, #-128
    74c0:	1d13      	jne	0x74e8 <_main+0x71c>
		{
#if (LINPROT == LIN2J_VALVE_VW)
			if ( RamBackgroundTest( 0U) == FALSE )								/* Check RAM against NVRAM User-page */
    74c2:	7000      	lod	A, #0
    74c4:	82db 6cae 	callf	0x6cae <_RamBackgroundTest>
    74c8:	ac00      	cmp	A, #0
    74ca:	1d0a      	jne	0x74e0 <_main+0x714>
			if ( RamBackgroundTest( u8BackgroundSchedulerTaskID ? 1 : 0) == FALSE )	/* Check RAM against NVRAM User-page #1/#2 */
#endif /* (LINPROT == LIN2J_VALVE_VW) */
			{
				/* RAM g_NvramUser structure not same as NVRAM Page #1.1.
				 * Either System RAM is corrupted or the NVRAM. Allow one time NVRAM reload */
				if ( l_u8RamPreError == FALSE )
    74cc:	62d8 00f9 	lod	AL, 0xf9 <_l_u8RamPreError>
    74d0:	1d04      	jne	0x74da <_main+0x70e>
				{
					NVRAM_LoadAll();
    74d2:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
					l_u8RamPreError = TRUE;
    74d6:	6001      	lod	AL, #1
    74d8:	0004      	jmp	0x74e2 <_main+0x716>
				}
				else
				{
					SetLastError( (uint8) C_ERR_RAM_BG);						/* Log RAM failure */
    74da:	72da 00f8 	lod	A, #248
    74de:	000f      	jmp	0x74fe <_main+0x732>
#endif /* (LINPROT == LIN2J_VALVE_VW) */
				}
			}
			else
			{
				l_u8RamPreError = FALSE;										/* Error is gone (caused by wrong NVRAM shadow-RAM) */
    74e0:	6000      	lod	AL, #0
    74e2:	42d8 00f9 	mov	0xf9 <_l_u8RamPreError>, AL
    74e6:	0018      	jmp	0x7518 <_main+0x74c>
			}
		}
		else if ( (FL_CTRL0 & FL_DETECT) != 0U )
    74e8:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    74ec:	b401      	and	A, #1
    74ee:	1914      	je	0x7518 <_main+0x74c>
		{
			if ( FlashBackgroundTest( C_FLASH_SEGMENT_SZ) == C_FLASH_CRC_FAILED )	/* Check Flash/ROM Memory Checksum (max. 250us) */
    74f0:	7004      	lod	A, #4
    74f2:	82db 6cd8 	callf	0x6cd8 <_FlashBackgroundTest>
    74f6:	ac00      	cmp	A, #0
    74f8:	1d0f      	jne	0x7518 <_main+0x74c>
			{
				SetLastError( (uint8) C_ERR_FLASH_BG);
    74fa:	72da 00f9 	lod	A, #249
    74fe:	82db 89e6 	callf	0x89e6 <_SetLastError>
#if (LINPROT == LIN2J_VALVE_VW)
				MLX4_RESET();													/* Reset the Mlx4   */
    7502:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7506:	94fe      	and	AL, #-2
    7508:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    750c:	7ada 3072 	lod	Y, #12402
    7510:	5ad8 02ac 	mov	0x2ac <_bistResetInfo>, Y
				MLX16_RESET();													/* Reset the Mlx16  */
    7514:	82db 59dc 	callf	0x59dc <_MLX16_RESET>
		}
		else
		{
			/* Nothing */
		}
		u8BackgroundSchedulerTaskID++; 
    7518:	6217      	lod	AL, [S-24]
    751a:	8001      	add	AL, #1
    751c:	5cf2      	usex	A
    751e:	5217      	mov	[S-24], A

#if _SUPPORT_CHIP_TEMP_PROFILE
		/* ***************************************************** */
		/* *** q. Chip temperature stability (profile) check *** */
		/* ***************************************************** */
		if ( g_u16TemperatureStabilityCounter > C_TEMP_STABIL_TIMEOUT )
    7520:	72d8 0104 	lod	A, 0x104 <_g_u16TemperatureStabilityCounter>
    7524:	aeda 01f4 	cmp	A, #500
    7528:	1e01      	jug	0x752c <_main+0x760>
    752a:	0039      	jmp	0x759e <_main+0x7d2>
		{
			g_u16TemperatureStabilityCounter -= C_TEMP_STABIL_TIMEOUT;
    752c:	a2da fe0c 	add	A, #65036
    7530:	52d8 0104 	mov	0x104 <_g_u16TemperatureStabilityCounter>, A

			if ( l_i16ChipTemperaturePrev != 0 )
    7534:	7ad8 0102 	lod	Y, 0x102 <_l_i16ChipTemperaturePrev>
    7538:	192f      	je	0x7598 <_main+0x7cc>
			{
				/* Chip temperature profile check: 
				 * Take the delta between latest and previous measured chip temperature (differentiate)
				 * Integrate the delta, with a leakage of 1/2^n
				 */
				int i16DeltaTemperature = g_i16ChipTemperature - l_i16ChipTemperaturePrev;
    753a:	7120      	lod	A, dp:0x20 <__data_dp_size>
    753c:	7ee2      	lod	X, A
    753e:	2ae6      	sub	X, Y
				l_i16ChipTemperatureInt = (l_i16ChipTemperatureInt - ((l_i16ChipTemperatureInt + (1 << (C_TEMP_STABIL_INT_FILTER_COEF - 1))) >> C_TEMP_STABIL_INT_FILTER_COEF)) + (i16DeltaTemperature << C_TEMP_STABIL_INT_FILTER_COEF);
    7540:	7ad8 0100 	lod	Y, 0x100 <_l_i16ChipTemperatureInt>
    7544:	72e6      	lod	A, Y
    7546:	a2da 0080 	add	A, #128
    754a:	62e4      	lod	AL, AH
    754c:	5ce2      	ssex	A
    754e:	eae2      	sub	Y, A
    7550:	36da 00ff 	and	X, #255
    7554:	7eec      	swap	X
    7556:	72e6      	lod	A, Y
    7558:	a2ee      	add	A, X
    755a:	52d8 0100 	mov	0x100 <_l_i16ChipTemperatureInt>, A
				if ( l_i16ChipTemperatureInt < 0 )
    755e:	ac00      	cmp	A, #0
    7560:	1e84      	jsge	0x756a <_main+0x79e>
				{
					l_i16ChipTemperatureInt = 0;
    7562:	7c00      	lod	X, #0
    7564:	5ed8 0100 	mov	0x100 <_l_i16ChipTemperatureInt>, X
    7568:	0017      	jmp	0x7598 <_main+0x7cc>
    756a:	66d8 00fa 	lod	YL, 0xfa <_l_e8ErrorDebounceFilter>
				}
				else if ( l_i16ChipTemperatureInt > (int16)(C_TEMP_STABIL_THRESHOLD << C_TEMP_STABIL_INT_FILTER_COEF) )
    756e:	aeda 1400 	cmp	A, #5120
    7572:	1b0e      	jsle	0x7590 <_main+0x7c4>
				{
					if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_TEMP_PROFILE) == 0x00U )
    7574:	72e6      	lod	A, Y
    7576:	b410      	and	A, #16
    7578:	1d03      	jne	0x7580 <_main+0x7b4>
					{
						l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_TEMP_PROFILE;
    757a:	62e8      	lod	AL, YL
    757c:	8410      	or	AL, #16
    757e:	000a      	jmp	0x7594 <_main+0x7c8>
					else
					{
#if _SUPPORT_OVT_PED
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
#endif /* _SUPPORT_OVT_PED */
						MotorDriverStop( (uint16) C_STOP_IMMEDIATE);			/* Temperature increase dT/dt too much */
    7580:	7001      	lod	A, #1
    7582:	82db 9296 	callf	0x9296 <_MotorDriverStop>
						SetLastError( C_ERR_CHIP_TEMP_PROFILE);					
    7586:	72da 00e8 	lod	A, #232
    758a:	82db 89e6 	callf	0x89e6 <_SetLastError>
    758e:	0004      	jmp	0x7598 <_main+0x7cc>
					}
				}
				else
				{
					l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_TEMP_PROFILE;
    7590:	62e8      	lod	AL, YL
    7592:	94ef      	and	AL, #-17
    7594:	42d8 00fa 	mov	0xfa <_l_e8ErrorDebounceFilter>, AL
				}
			}
			l_i16ChipTemperaturePrev = g_i16ChipTemperature;
    7598:	7120      	lod	A, dp:0x20 <__data_dp_size>
    759a:	52d8 0102 	mov	0x102 <_l_i16ChipTemperaturePrev>, A
#if _SUPPORT_MLX16_HALT
		/* ************************************* */
		/* *** r. Power-saving (non-running) *** */
		/* ************************************* */
		/* In case MLX4 is inactive, don't enter HALT mode, because the chip enters SLEEP mode which will stop the Core-timer as well */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0U) &&
    759e:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    75a0:	b401      	and	A, #1
    75a2:	1901      	je	0x75a6 <_main+0x7da>
    75a4:	0062      	jmp	0x766a <_main+0x89e>
    75a6:	6132      	lod	AL, dp:0x32 <_g_u8MotorStopDelay>
    75a8:	1901      	je	0x75ac <_main+0x7e0>
    75aa:	005f      	jmp	0x766a <_main+0x89e>
    75ac:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    75b0:	b401      	and	A, #1
    75b2:	1d01      	jne	0x75b6 <_main+0x7ea>
    75b4:	005a      	jmp	0x766a <_main+0x89e>
    75b6:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
    75ba:	1901      	je	0x75be <_main+0x7f2>
    75bc:	0056      	jmp	0x766a <_main+0x89e>
			 (g_u8MotorStopDelay == 0U) &&
			 ((CONTROL & M4_RB) != 0U) &&
			 (g_u8LinInFrameBufState == C_LIN_IN_FREE) )
		{
			uint16 u16XI0_Mask = XI0_MASK;
    75be:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    75c2:	5209      	mov	[S-10], A
			uint16 u16IsrMask = MASK;
    75c4:	7ad8 2006 	lod	Y, 0x2006 <__ep__+0x1006>
    75c8:	5a07      	mov	[S-8], Y
			uint16 u16Timer1Ctrl = TMR1_CTRL;
    75ca:	72aa      	lod	A, io:0x2a <_g_e8ErrorElectric>
    75cc:	5205      	mov	[S-6], A

			ADC_PowerOff();														/* Stop ADC, including turning off reference voltage (Approx: 0.6mA) */
    75ce:	82db 85e8 	callf	0x85e8 <_ADC_PowerOff>
			DRVCFG |= DIS_SHOA;													/* Disable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    75d2:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    75d6:	a6da 0400 	or	A, #1024
    75da:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			/* Setup wake-up timer event */
			TMR1_CTRL = (2U * TMRx_DIV0) | (0U * TMRx_MODE0) | TMRx_T_EBLK;		/* Timer mode 0, Divider 256 */
    75de:	7ada 8001 	lod	Y, #32769
    75e2:	5aaa      	mov	io:0x2a <_g_e8ErrorElectric>, Y
			TMR1_REGB = C_SLEEP_PERIOD;											/* Set sleep-period */
    75e4:	7eda 155c 	lod	X, #5468
    75e8:	5eac      	mov	io:0x2c <_g_u8BufferOutID>, X
			XI0_PEND = CLR_T1_INT4;												/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    75ea:	7040      	lod	A, #64
    75ec:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
			XI0_MASK = EN_T1_INT4;												/* Disable Timer1 all 2nd level interrupts, except INT4 (CMP) */
    75f0:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
			PEND = CLR_EXT0_IT;
    75f4:	7ada 0100 	lod	Y, #256
    75f8:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y
			MASK = EN_EXT4_IT | EN_EXT0_IT | EN_M4_SHE_IT;						/* Enable Diagnostics, Timer1 and MLX4 IRQ's only */
    75fc:	7eda 1110 	lod	X, #4368
    7600:	5ed8 2006 	mov	0x2006 <__ep__+0x1006>, X
			TMR1_CTRL = (2U * TMRx_DIV0) | (0U * TMRx_MODE0) | TMRx_T_EBLK | TMRx_START;	/* Start timer */
    7604:	72da 8003 	lod	A, #32771
    7608:	52aa      	mov	io:0x2a <_g_e8ErrorElectric>, A
			 * the LinInFrameBufState check and before the actual entering of
			 * the HALT-state. The LIN message is not lost, but delayed by the
			 * HALT time-out period. Below code blocks the IRQ's (post-pone)
			 * until the MLX16 enters HALT-state.
			 */
			__asm__("psup #0");													/* Block IRQ's */
    760a:	54d0      	psup	#0
			__asm__("lod AL, _g_u8LinInFrameBufState");							/* Check for LIN message received */
    760c:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
			__asm__("jne _HALT_10");											/* Skip HALT in case LIN message received */
    7610:	1d0b      	jne	0x7628 <_main+0x85c>
			__asm__("lod X, #_au16HaltZero");									/* X pointer to flash memory with 0x0000 */
    7612:	7eda a0bc 	lod	X, #41148
			__asm__("lod AL, 0x2000");											/* Get MLX16 Control-state */
    7616:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
			__asm__("or  AL, #0x02");											/* Set HALT-state */
    761a:	8402      	or	AL, #2
			__asm__("mov R, #0");												/* Restore IRQ-state */
    761c:	4407      	mov	R, #0
			__asm__("pop M");
    761e:	72cb      	pop	M
			__asm__("mov 0x2000, AL");											/* Enter HALT-state */
    7620:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			__asm__("mov A,[X]");
    7624:	72f8      	lod	A, [X]
			__asm__("jmp _HALT_20");											/* Leave HALT-state */
    7626:	0002      	jmp	0x762c <_main+0x860>
			__asm__("_HALT_10:");
			__asm__("mov R, #0");
    7628:	4407      	mov	R, #0
			__asm__("pop M");
    762a:	72cb      	pop	M
			__asm__("_HALT_20:");

			DRVCFG &= ~DIS_SHOA;												/* Enable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    762c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7630:	b6da fbff 	and	A, #64511
    7634:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			{
				uint16 u16TimerCnt = TMR1_CNT;									/* Take a copy of the Timer-count value */
    7638:	7ab0      	lod	Y, io:0x30 <_l_u16VTIdx>
    763a:	5a03      	mov	[S-4], Y
				TMR1_CTRL = u16Timer1Ctrl & ~TMRx_START;						/* Stop Timer */
    763c:	7205      	lod	A, [S-6]
    763e:	b4fd      	and	A, #-3
    7640:	52aa      	mov	io:0x2a <_g_e8ErrorElectric>, A
				XI0_PEND = u16XI0_Mask;											/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    7642:	7e09      	lod	X, [S-10]
    7644:	5ed8 2034 	mov	0x2034 <__ep__+0x1034>, X
				XI0_MASK = u16XI0_Mask;											/* Restore Timer1 interrupt mask */
    7648:	5ed8 202a 	mov	0x202a <__ep__+0x102a>, X
				PEND = CLR_EXT0_IT;
    764c:	72da 0100 	lod	A, #256
    7650:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
				MASK = u16IsrMask;												/* Restore 1st level interrupt mask */
    7654:	7a07      	lod	Y, [S-8]
    7656:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y

				if ( g_u8MotorHoldingCurrState != FALSE )
    765a:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    765e:	1902      	je	0x7664 <_main+0x898>
							l_u16AdcHoldMode = (l_u16AdcHoldMode + 1U);
						}
					}
					ADC_Start( l_u16AdcHoldMode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					ADC_Start();
    7660:	82db 85b8 	callf	0x85b8 <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				Timer_SleepCompensation( u16TimerCnt);							/* Compensate Timer counters for sleep-period */
    7664:	7203      	lod	A, [S-4]
    7666:	82db 9f76 	callf	0x9f76 <_Timer_SleepCompensation>

#if _SUPPORT_IOREG_CHECK
		/* ************************************ */
		/* *** s. Critical peripheral check *** */
		/* ************************************ */
		if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_APPL_STOP) == 0x00 )	/* If application is NOT stopped ... */
    766a:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    766c:	b440      	and	A, #64
    766e:	1901      	je	0x7672 <_main+0x8a6>
    7670:	0484      	jmp	0x6f7a <_main+0x1ae>
		{
			/* Check: Motor commutation timer disabled */
			if ( (TMR1_CTRL & TMRx_T_EBLK) == 0U )
    7672:	72aa      	lod	A, io:0x2a <_g_e8ErrorElectric>
    7674:	b401      	and	A, #1
    7676:	1d0e      	jne	0x7694 <_main+0x8c8>
			{
				/* Communication timer is disabled; Motor is stopped too */
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    7678:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    767a:	b401      	and	A, #1
    767c:	1904      	je	0x7686 <_main+0x8ba>
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;					/* Start timer mode 0 */
    767e:	7eda 4003 	lod	X, #16387
    7682:	5eaa      	mov	io:0x2a <_g_e8ErrorElectric>, X
    7684:	0003      	jmp	0x768c <_main+0x8c0>
				}
				else
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0;								/* Timer mode 0 */
    7686:	72da 4001 	lod	A, #16385
    768a:	52aa      	mov	io:0x2a <_g_e8ErrorElectric>, A
				}
				SetLastError( (uint8) C_ERR_IOREG);
    768c:	72da 00fc 	lod	A, #252
    7690:	82db 89e6 	callf	0x89e6 <_SetLastError>
			}
			/* Check: Administrative timer disabled */
			if ( (TIMER & TMR_EN) == 0U )
    7694:	7286      	lod	A, io:0x6 <_LinMess2>
    7696:	ac00      	cmp	A, #0
    7698:	1a87      	jsl	0x76a8 <_main+0x8dc>
			{
				TIMER = TMR_EN | CT_PERIODIC_RATE;
    769a:	7ada 81f4 	lod	Y, #33268
    769e:	5a86      	mov	io:0x6 <_LinMess2>, Y
				SetLastError( (uint8) C_ERR_IOREG);
    76a0:	72da 00fc 	lod	A, #252
    76a4:	82db 89e6 	callf	0x89e6 <_SetLastError>
			}
			/* Check: IRQ-Mask (Respectively: Diagnostics, Timer1, CoreTimer and LIN-Communication */
			if ( (MASK & (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT)) != (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT) )
    76a8:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    76ac:	b6da 1130 	and	A, #4400
    76b0:	aeda 1130 	cmp	A, #4400
    76b4:	190e      	je	0x76d2 <_main+0x906>
			{
				PEND = (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    76b6:	7eda 1130 	lod	X, #4400
    76ba:	5ed8 2008 	mov	0x2008 <__ep__+0x1008>, X
				MASK |= (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    76be:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    76c2:	a6da 1130 	or	A, #4400
    76c6:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
				SetLastError( (uint8) C_ERR_IOREG);
    76ca:	72da 00fc 	lod	A, #252
    76ce:	82db 89e6 	callf	0x89e6 <_SetLastError>
			}
			/* Check: IRQ-priority (Respectively: Diagnostics, Timer1, CoreTimer) */
			if ( (PRIO & ((3U << 14) | (3U << 6) | (3U << 0))) != (/*((3U-3U) << 14) |*/ ((4U-3U) << 6) | ((6U-3U) << 0)) )
    76d2:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    76d6:	b6da c0c3 	and	A, #49347
    76da:	ac43      	cmp	A, #67
    76dc:	190b      	je	0x76f4 <_main+0x928>
			{
				PRIO = (PRIO & ~((3u << 14) | (3u << 6) | (3u << 0))) | (/*((3U-3U) << 14) |*/ ((4U-3U) << 6) | ((6U-3U) << 0));
    76de:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    76e2:	b6da 3f3c 	and	A, #16188
    76e6:	a443      	or	A, #67
    76e8:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
				SetLastError( (uint8) C_ERR_IOREG);
    76ec:	72da 00fc 	lod	A, #252
    76f0:	82db 89e6 	callf	0x89e6 <_SetLastError>
			}
			/* Check: 2nd level IRQ Timer1 */
			if ( (XI0_MASK & EN_T1_INT4) == 0U )
    76f4:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    76f8:	b440      	and	A, #64
    76fa:	1d09      	jne	0x770e <_main+0x942>
			{
				XI0_PEND = EN_T1_INT4;
    76fc:	7040      	lod	A, #64
    76fe:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
				XI0_MASK = EN_T1_INT4;
    7702:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7706:	72da 00fc 	lod	A, #252
    770a:	82db 89e6 	callf	0x89e6 <_SetLastError>
			}
			/* Check: 2nd level IRQ Diagnostics */
			if ( (XI4_MASK & (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV)) != C_DIAG_MASK )
    770e:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    7712:	b6da e100 	and	A, #57600
    7716:	aeda e100 	cmp	A, #57600
    771a:	190a      	je	0x7730 <_main+0x964>
			{
				XI4_PEND = C_DIAG_MASK;
    771c:	7ada e100 	lod	Y, #57600
    7720:	5ad8 203c 	mov	0x203c <__ep__+0x103c>, Y
				XI4_MASK = C_DIAG_MASK;
    7724:	5ad8 2032 	mov	0x2032 <__ep__+0x1032>, Y
				SetLastError( (uint8) C_ERR_IOREG);
    7728:	72da 00fc 	lod	A, #252
    772c:	82db 89e6 	callf	0x89e6 <_SetLastError>
			{
				ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
				SetLastError( (uint8) C_ERR_IOREG);
			}
#endif /* 0 */
			if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0U) && ((DRVCFG & (DRV_CFG_T|DRV_CFG_W|DRV_CFG_V|DRV_CFG_U)) == 0U) )
    7730:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7732:	b401      	and	A, #1
    7734:	1d01      	jne	0x7738 <_main+0x96c>
    7736:	0421      	jmp	0x6f7a <_main+0x1ae>
    7738:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    773c:	8c00      	cmp	AL, #0
    773e:	1901      	je	0x7742 <_main+0x976>
    7740:	041c      	jmp	0x6f7a <_main+0x1ae>
			{
				/* Driver have been disabled */
				SetLastError( (uint8) C_ERR_IOREG);
    7742:	72da 00fc 	lod	A, #252
    7746:	82db 89e6 	callf	0x89e6 <_SetLastError>
#endif /* _SUPPORT_CRASH_RECOVERY */

	/* ******************************** */
	/* *** U. Main application loop *** */
	/* ******************************** */
	for(;;)
    774a:	0417      	jmp	0x6f7a <_main+0x1ae>

0000774c <_LIN_Init>:
 *
 * Initialise LIN communication interface.
 * Default start-up, at 9600 Baud
 * ****************************************************************************	*/
void LIN_Init( uint16 u16WarmStart)
{
    774c:	5801      	inc	S, #2
    774e:	5201      	mov	[S-2], A
	/* Initialise LIN Communication */
	LIN_XCFG &= ~DISTERM;														/* Enable LIN pull-up resistor */
    7750:	72a0      	lod	A, io:0x20 <__data_dp_size>
    7752:	b4fb      	and	A, #-5
    7754:	52a0      	mov	io:0x20 <__data_dp_size>, A
	(void) ml_InitLinModule();													/* Initialise the LIN module */
    7756:	82db 5e96 	callf	0x5e96 <_ml_InitLinModule>
#if (_SUPPORT_AUTO_BAUDRATE != FALSE)
	/* Auto baudrate only on first LIN frame */
	(void) ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);
#else  /* (_SUPPORT_AUTO_BAUDRATE != FALSE) */
	/* Fixed baudrate */
	(void) ml_SetBaudRate( (ml_uint8) LIN_BR_PRESCALER, (ml_uint8)LIN_BR_DIV);	/* Program the baudrate : default startup : 9600baud @ 20.0 Mhz	*/
    775a:	54ca 00a8 	pushw	#168
    775e:	7003      	lod	A, #3
    7760:	82db 5c4a 	callf	0x5c4a <_ml_SetBaudRate>
						  ML_ENABLED,											/* StateChangeSignal */
						  1,													/* Light-sleep mode with timeout */
						  ML_SLEWHIGH);											/* SlewRate: ML_SLEWHIGH=20kbps / ML_SLEWLOW=10kbps */
#endif /* ((LIN_BR < 10000) && (_SUPPORT_AUTO_BAUDRATE == FALSE)) */
#elif (__MLX_PLTF_VERSION_MAJOR__ == 4)
	(void) ml_SetOptions( 1U,													/* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    7764:	54ca 0000 	pushw	#0
    7768:	54ca 0001 	pushw	#1
    776c:	54ca 0000 	pushw	#0
    7770:	7001      	lod	A, #1
    7772:	82db 5b9c 	callf	0x5b9c <_ml_SetOptions>
						  0U,													/* TXStopBitLength = 1 Bit */
						  ML_ENABLED,											/* StateChangeSignal */
						  ML_LIGHTSLEEP);										/* SleepMode: light-sleep mode */

#if ((LIN_BR < 12000) && (_SUPPORT_AUTO_BAUDRATE == FALSE))
	(void) ml_SetSlewRate( ML_SLEWLOW);
    7776:	7002      	lod	A, #2
    7778:	82db 5b94 	callf	0x5b94 <_ml_SetSlewRate>
#if ((LINPROT & LINXX) == LIN2X)
	LIN_2x_Init( u16WarmStart);
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)
	LIN_SAE_J2602_Init( u16WarmStart);
    777c:	7209      	lod	A, [S-10]
    777e:	10ce      	call	0x791c <_LIN_SAE_J2602_Init>
#endif /* ((LINPROT & LINXX) == LIN2J) */

	(void) ml_Connect();
    7780:	82db 5c5e 	callf	0x5c5e <_ml_Connect>
	g_u8ErrorCommBusTimeout = FALSE;
    7784:	6000      	lod	AL, #0
    7786:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
    778a:	5c07      	dec	S, #8
    778c:	5403      	ret	#4

0000778e <_mlu_ApplicationStop>:
 *  LIN API event: mlu_ApplicationStop
 * ****************************************************************************	*/
ml_Status mlu_ApplicationStop(void)
{
	/* Stop motor (e.g. disconnect drivers) */
	MotorDriverStop( (uint16) C_STOP_IMMEDIATE);								/* Application stop */
    778e:	7001      	lod	A, #1
    7790:	82db 9296 	callf	0x9296 <_MotorDriverStop>
	SetLastError( (uint8) C_ERR_APPL_STOP);
    7794:	72da 00a8 	lod	A, #168
    7798:	82db 89e6 	callf	0x89e6 <_SetLastError>

	/* Disable all IRQ's, except LIN */
	XI0_MASK = 0;
    779c:	7000      	lod	A, #0
    779e:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	XI1_MASK = 0;
    77a2:	52d8 202c 	mov	0x202c <__ep__+0x102c>, A
	XI2_MASK = 0;
    77a6:	52d8 202e 	mov	0x202e <__ep__+0x102e>, A
	XI3_MASK = 0;
    77aa:	52d8 2030 	mov	0x2030 <__ep__+0x1030>, A
	XI4_MASK = 0;
    77ae:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	MASK = EN_M4_SHE_IT;														/* Disable all interrupts, except LIN M4_SHE_IT */
    77b2:	7010      	lod	A, #16
    77b4:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_APPL_STOP;					/* Don't perform periodic MLX4 Status checks */
    77b8:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    77ba:	8440      	or	AL, #64
    77bc:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL

	return ( ML_SUCCESS );														/* Return that the application has stopped */
} /* End of mlu_ApplicationStop */
    77be:	7000      	lod	A, #0
    77c0:	5401      	ret

000077c2 <_mlu_DataRequest>:

/* ****************************************************************************	*
 *  LIN API event: Data Request (slave TX)
 * ****************************************************************************	*/
void mlu_DataRequest( ml_MessageID MessageID) 
{
    77c2:	7ae2      	lod	Y, A
	g_u8ErrorCommBusTimeout = FALSE;											/* Data requested; No longer Bus time-out */
    77c4:	6000      	lod	AL, #0
    77c6:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
	(void) ml_ReleaseBuffer();													/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)												/* LIN 2.x_J2602 */
	if ( MessageID == (uint8) mlxRFR_DIAG )
    77ca:	62e8      	lod	AL, YL
    77cc:	8c11      	cmp	AL, #17
    77ce:	1d14      	jne	0x77f8 <_mlu_DataRequest+0x36>
	{
		/* Diagnostic */
		if ( g_u8BufferOutID == (uint8) QR_RFR_DIAG )
    77d0:	612c      	lod	AL, dp:0x2c <_g_u8BufferOutID>
    77d2:	8c07      	cmp	AL, #7
    77d4:	1d0e      	jne	0x77f2 <_mlu_DataRequest+0x30>
		{
			RFR_DIAG *pDiag = &g_DiagResponse;
			uint16 *src = (uint16 *) pDiag;
			uint16 *dst = (uint16 *) LinFrameDataBuffer;
			dst[0] = src[0];
    77d6:	7140      	lod	A, dp:0x40 <_g_DiagResponse>
    77d8:	51c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, A
			dst[1] = src[1];
    77da:	7142      	lod	A, dp:0x42 <_g_DiagResponse+0x2>
    77dc:	51ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, A
			dst[2] = src[2];
    77de:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x4>
    77e0:	51cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x4>, A
			dst[3] = src[3];
    77e2:	7146      	lod	A, dp:0x46 <_g_DiagResponse+0x6>
    77e4:	51ce      	mov	dp:0xce <_LinFrameDataBuffer+0x6>, A

			(void) ml_DataReady( ML_END_OF_TX_DISABLED);
    77e6:	7000      	lod	A, #0
    77e8:	82db 5b60 	callf	0x5b60 <_ml_DataReady>
			g_u8BufferOutID = (uint8) QR_INVALID;								/* Invalidate LIN output buffer */
    77ec:	60ff      	lod	AL, #-1
    77ee:	412c      	mov	dp:0x2c <_g_u8BufferOutID>, AL
    77f0:	5401      	ret
		}
		else
		{
			(void) ml_DiscardFrame();											/* Output buffer response doesn't match requested response */
    77f2:	82db 5bb2 	callf	0x5bb2 <_ml_DiscardFrame>
    77f6:	5401      	ret
		}
	}
#if (LINPROT == LIN2J_VALVE_VW)
	else if ( (g_u8NAD >= (uint8) C_MIN_J2602_NAD) && (g_u8NAD <= (uint8) C_MAX_J2602_NAD) )
    77f8:	62d8 002f 	lod	AL, 0x2f <_g_u8NAD>
    77fc:	80a0      	add	AL, #-96
    77fe:	8c0d      	cmp	AL, #13
    7800:	1e07      	jug	0x7810 <_mlu_DataRequest+0x4e>
	{
		if ( MessageID == (uint8) mlxACT_STATUS )
    7802:	62e8      	lod	AL, YL
    7804:	8c02      	cmp	AL, #2
    7806:	1d04      	jne	0x7810 <_mlu_DataRequest+0x4e>
		{
			/* Status AGS */
			HandleActRfrSta();
    7808:	11fa      	call	0x7bfe <_HandleActRfrSta>
			(void) ml_DataReady( ML_END_OF_TX_ENABLED);
    780a:	7001      	lod	A, #1
    780c:	82db 5b60 	callf	0x5b60 <_ml_DataReady>
    7810:	5401      	ret

00007812 <_mlu_DataTransmitted>:
	if ( g_u8SAE_SendErrorState )
	{
		g_u8SAE_ErrorFlags &= ~(uint8)(1 << g_u8SAE_SendErrorState);			/* Clear error-flags which have been transmitted */
	}
#else  /* (LINPROT != LIN2J_VALVE_VW) */
	if ( g_u8SAE_SendErrorState )
    7812:	62d8 002e 	lod	AL, 0x2e <_g_u8SAE_SendErrorState>
    7816:	1903      	je	0x781e <_mlu_DataTransmitted+0xc>
	{
		g_u8ErrorCommunication = FALSE;
    7818:	6000      	lod	AL, #0
    781a:	42d8 0111 	mov	0x111 <_g_u8ErrorCommunication>, AL
    781e:	5401      	ret

00007820 <_mlu_ErrorDetected>:

/* ****************************************************************************	*
 *  LIN API event: mlu_ErrorDetected
 * ****************************************************************************	*/
void mlu_ErrorDetected( ml_LinError Error)
{
    7820:	5801      	inc	S, #2
    7822:	5201      	mov	[S-2], A
	SetLastError( (uint8) C_ERR_LIN_COMM | ((uint8)Error & 0x1F));
    7824:	a6da 0080 	or	A, #128
    7828:	b6da 009f 	and	A, #159
    782c:	82db 89e6 	callf	0x89e6 <_SetLastError>
	LIN2x_ErrorHandling( Error);
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
	(void) ml_ReleaseBuffer(); 													/* Release the buffer in case there was a reception overflow */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
#elif (LINPROT == LIN2J_VALVE_VW)
	LIN2J_ErrorHandling( Error);
    7830:	7201      	lod	A, [S-2]
    7832:	1272      	call	0x7d18 <_LIN2J_ErrorHandling>
    7834:	5403      	ret	#4

00007836 <_mlu_LinSleepMode>:
{
	/*
	 * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
	 * and does not report it via mlu_MessageReceived event.
	 */
	if ( (Reason == ml_reasonMaster) || (Reason == ml_reasonCommand) )
    7836:	7ae2      	lod	Y, A
    7838:	a0ff      	add	A, #-1
    783a:	ac01      	cmp	A, #1
    783c:	1e02      	jug	0x7842 <_mlu_LinSleepMode+0xc>
	{
		{
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    783e:	6006      	lod	AL, #6
    7840:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
		}
	}

	if ( (Reason == ml_reasonTimeOut) || (Reason == ml_reasonTimeOutDominant) )
    7842:	72e6      	lod	A, Y
    7844:	a0fa      	add	A, #-6
    7846:	ac01      	cmp	A, #1
    7848:	1e01      	jug	0x784c <_mlu_LinSleepMode+0x16>
		/*
		 * LIN bus was inactive for 4 seconds without receiving an explicit
		 * "Go-to-Sleep frame". This can be considered as a failure of the Master or
		 * PHY layer. Slave can enter limp-home mode.
		 */
		HandleBusTimeout();
    784a:	124e      	call	0x7ce8 <_HandleBusTimeout>
    784c:	5401      	ret

0000784e <_mlu_MessageReceived>:

/* ****************************************************************************	*
 *  LIN API event: MessageReceived (slave RX)
 * ****************************************************************************	*/
void mlu_MessageReceived( ml_MessageID byMessageID)
{
    784e:	7ae2      	lod	Y, A
	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_FULL )
    7850:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
    7854:	8c01      	cmp	AL, #1
    7856:	1910      	je	0x7878 <_mlu_MessageReceived+0x2a>
	{
		/* Buffer is either empty or message is postpone (overwrite allowed) */
		l_u8LinInFrameMsgID = byMessageID;
    7858:	4548      	mov	dp:0x48 <_l_u8LinInFrameMsgID>, YL

		/* LIN In-frame buffer to a Copy LIN In-frame buffer */
		{
			uint16 *pu16Source = (uint16 *) LinFrameDataBuffer;
			uint16 *pu16Target = (uint16 *) &g_LinCmdFrameBuffer;
			*pu16Target = *pu16Source;
    785a:	71c8      	lod	A, dp:0xc8 <_LinFrameDataBuffer>
    785c:	5138      	mov	dp:0x38 <__data_dp_end>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    785e:	71ca      	lod	A, dp:0xca <_LinFrameDataBuffer+0x2>
    7860:	513a      	mov	dp:0x3a <__data_dp_end+0x2>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7862:	71cc      	lod	A, dp:0xcc <_LinFrameDataBuffer+0x4>
    7864:	513c      	mov	dp:0x3c <__data_dp_end+0x4>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7866:	71ce      	lod	A, dp:0xce <_LinFrameDataBuffer+0x6>
    7868:	513e      	mov	dp:0x3e <__data_dp_end+0x6>, A
		}
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
		(void) ml_ReleaseBuffer();												/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    786a:	6001      	lod	AL, #1
    786c:	42d8 0112 	mov	0x112 <_g_u8LinInFrameBufState>, AL
		g_u8ErrorCommBusTimeout = FALSE;										/* Frame received; No longer Bus time-out */
    7870:	6000      	lod	AL, #0
    7872:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
		LinFrame[0] = 0x00;														/* Clear NAD address */
    7876:	4108      	mov	dp:0x8 <__bist_stat_size>, AL
    7878:	5401      	ret

0000787a <_HandleLinInMsg>:
	}
} /* End of mlu_MessageReceived() */

void HandleLinInMsg( void)
{
    787a:	5801      	inc	S, #2
	if ( g_u8LinInFrameBufState == (uint8) C_LIN_IN_POSTPONE )
    787c:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
    7880:	8c02      	cmp	AL, #2
    7882:	1d03      	jne	0x788a <_HandleLinInMsg+0x10>
	{
		/* Last message postponed; Try again (without overwritten by LIN message ISR */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7884:	6001      	lod	AL, #1
    7886:	42d8 0112 	mov	0x112 <_g_u8LinInFrameBufState>, AL
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */
#endif /* (LINPROT == LIN2X_ACT44) */
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)												/* LIN 2.x_J2602 */
	if ( l_u8LinInFrameMsgID == (uint8) mlxDFR_DIAG )
    788a:	6148      	lod	AL, dp:0x48 <_l_u8LinInFrameMsgID>
    788c:	4201      	mov	[S-2], AL
    788e:	8c10      	cmp	AL, #16
    7890:	1d02      	jne	0x7896 <_HandleLinInMsg+0x1c>
	{
		/* Diagnostic frame */
		HandleDfrDiag();
    7892:	12af      	call	0x7df2 <_HandleDfrDiag>
    7894:	0009      	jmp	0x78a8 <_HandleLinInMsg+0x2e>
	}
#if (LINPROT == LIN2J_VALVE_VW)
	else if ( (g_u8NAD >= (uint8) C_MIN_J2602_NAD) && (g_u8NAD <= (uint8) C_MAX_J2602_NAD) && (l_u8LinInFrameMsgID == (uint8) mlxACT_CTRL) )
    7896:	62d8 002f 	lod	AL, 0x2f <_g_u8NAD>
    789a:	80a0      	add	AL, #-96
    789c:	8c0d      	cmp	AL, #13
    789e:	1e04      	jug	0x78a8 <_HandleLinInMsg+0x2e>
    78a0:	6201      	lod	AL, [S-2]
    78a2:	8c01      	cmp	AL, #1
    78a4:	1d01      	jne	0x78a8 <_HandleLinInMsg+0x2e>
	{
		/* Control */
		HandleActCfrCtrl();
    78a6:	112b      	call	0x7afe <_HandleActCfrCtrl>
	}
#endif /* (LINPROT == LIN2J_VALVE_VW) */
#endif /* ((LINPROT & LINXX) == LIN2J) */

	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_POSTPONE )
    78a8:	62d8 0112 	lod	AL, 0x112 <_g_u8LinInFrameBufState>
    78ac:	8c02      	cmp	AL, #2
    78ae:	1903      	je	0x78b6 <_HandleLinInMsg+0x3c>
	{
		/* LIN Message is handled; Release LIN message buffer */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FREE;
    78b0:	6000      	lod	AL, #0
    78b2:	42d8 0112 	mov	0x112 <_g_u8LinInFrameBufState>, AL
    78b6:	5403      	ret	#4

000078b8 <_mlu_AutoAddressingStep>:
/* ****************************************************************************	*
 *  LIN API event: mlu_AutoAddressingStep
 * ****************************************************************************	*/
void mlu_AutoAddressingStep( ml_uint8 StepNumber)
{
	(void) StepNumber; 
    78b8:	5401      	ret

000078ba <_CalcProtectionBits>:
/* ****************************************************************************	*
 * CalcProtectionBits
 *
 * ****************************************************************************	*/
uint8 CalcProtectionBits( uint8 byFrameID)
{
    78ba:	7ee2      	lod	X, A
	byFrameID |= ((byFrameID & 0x01) ^ ((byFrameID & 0x02) >> 1) ^ ((byFrameID & 0x04) >> 2) ^ ((byFrameID & 0x10) >> 4)) ? 0x40 : 0x00;
    78bc:	7ae2      	lod	Y, A
    78be:	f401      	and	Y, #1
    78c0:	b402      	and	A, #2
    78c2:	4472      	asr	A
    78c4:	fee2      	xor	Y, A
    78c6:	72ee      	lod	A, X
    78c8:	b404      	and	A, #4
    78ca:	44f2      	asr	A, #2
    78cc:	fee2      	xor	Y, A
    78ce:	72ee      	lod	A, X
    78d0:	b410      	and	A, #16
    78d2:	44f2      	asr	A, #2
    78d4:	44f2      	asr	A, #2
    78d6:	eee2      	cmp	Y, A
    78d8:	1903      	je	0x78e0 <_CalcProtectionBits+0x26>
    78da:	72ee      	lod	A, X
    78dc:	a440      	or	A, #64
    78de:	0002      	jmp	0x78e4 <_CalcProtectionBits+0x2a>
    78e0:	72ee      	lod	A, X
    78e2:	5cf2      	usex	A
    78e4:	7ee2      	lod	X, A
	byFrameID |= (((byFrameID & 0x02) >> 1) ^ ((byFrameID & 0x08) >> 3) ^ ((byFrameID & 0x10) >> 4) ^ ((byFrameID & 0x20) >> 5)) ? 0x00 : 0x80;
    78e6:	7ae2      	lod	Y, A
    78e8:	f402      	and	Y, #2
    78ea:	4476      	asr	Y
    78ec:	b408      	and	A, #8
    78ee:	44f2      	asr	A, #2
    78f0:	4472      	asr	A
    78f2:	fee2      	xor	Y, A
    78f4:	72ee      	lod	A, X
    78f6:	b410      	and	A, #16
    78f8:	44f2      	asr	A, #2
    78fa:	44f2      	asr	A, #2
    78fc:	fee2      	xor	Y, A
    78fe:	72ee      	lod	A, X
    7900:	b420      	and	A, #32
    7902:	44f2      	asr	A, #2
    7904:	44f2      	asr	A, #2
    7906:	4472      	asr	A
    7908:	eee2      	cmp	Y, A
    790a:	1903      	je	0x7912 <_CalcProtectionBits+0x58>
    790c:	72ee      	lod	A, X
    790e:	5cf2      	usex	A
    7910:	5401      	ret
    7912:	26da 0080 	or	X, #128
    7916:	72ee      	lod	A, X
    7918:	5cf2      	usex	A
	return ( byFrameID );
} /* End of CalcProtectionBits() */
    791a:	5401      	ret

0000791c <_LIN_SAE_J2602_Init>:
 *
 * This routine initialise the SAE-J2602 interface.
 * 	Based on the NAD, the LIN frame-ID are defined for CONTROL and STATUS.
 * ****************************************************************************	*/
void LIN_SAE_J2602_Init( uint16 u16WarmStart)
{
    791c:	5807      	inc	S, #8
	(void) u16WarmStart;

#if (LINPROT == LIN2J_VALVE_VW)
	/* Check wake-up from SLEEP (MMP160613-2) */
	if ( ANA_INB & WAKEUP_LIN )
    791e:	729e      	lod	A, io:0x1e <__ramfunc_size>
    7920:	b6da 0100 	and	A, #256
    7924:	6558      	lod	YL, dp:0x58 <_g_NvramUser+0x2>
    7926:	ac00      	cmp	A, #0
    7928:	1d01      	jne	0x792c <_LIN_SAE_J2602_Init+0x10>
    792a:	0044      	jmp	0x79b4 <_LIN_SAE_J2602_Init+0x98>
	{
		/* Restore: NAD, Motor-direction, CPOS and Status */
		g_u8NAD = g_NvramUser.NAD;
    792c:	452f      	mov	dp:0x2f <_g_u8NAD>, YL
		l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
    792e:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    7930:	b401      	and	A, #1
    7932:	5207      	mov	[S-8], A
    7934:	412d      	mov	dp:0x2d <_l_u8ActDirection>, AL

		/* The valve shall attempt to move and hit the Link/Bypass end stop if
		 * it was parked at 0%/100% position before sleep */
		{
			uint16 u16Pos = g_NvramUser.CPOS;
    7936:	6172      	lod	AL, dp:0x72 <_g_NvramUser+0x1c>
    7938:	5cf2      	usex	A
    793a:	5201      	mov	[S-2], A
			if ( l_u8ActDirection != FALSE )
    793c:	6207      	lod	AL, [S-8]
    793e:	1904      	je	0x7948 <_LIN_SAE_J2602_Init+0x2c>
			{
				u16Pos = C_MAX_POS - u16Pos;
    7940:	72da 00ff 	lod	A, #255
    7944:	aa01      	sub	A, [S-2]
    7946:	5201      	mov	[S-2], A
			}
			if ( u16Pos == C_MIN_POS )
    7948:	7a01      	lod	Y, [S-2]
    794a:	1d06      	jne	0x7958 <_LIN_SAE_J2602_Init+0x3c>
			{
				g_u16TargetPosition = 0;
    794c:	7000      	lod	A, #0
    794e:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
				g_u16ActualPosition = (2 * C_PERC_OFFSET);
    7950:	7ada 1200 	lod	Y, #4608
    7954:	59ec      	mov	dp:0xec <_g_u16ActualPosition>, Y
    7956:	000b      	jmp	0x796e <_LIN_SAE_J2602_Init+0x52>
    7958:	71f2      	lod	A, dp:0xf2 <_g_u16CalibTravel>
    795a:	5203      	mov	[S-4], A
				else
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
				}
			}
			else if ( u16Pos == C_MAX_POS )
    795c:	7a01      	lod	Y, [S-2]
    795e:	eeda 00ff 	cmp	Y, #255
    7962:	1d10      	jne	0x7984 <_LIN_SAE_J2602_Init+0x68>
			{
				g_u16TargetPosition = g_u16CalibTravel + (2 * C_PERC_OFFSET);
    7964:	a2da 1200 	add	A, #4608
    7968:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
				g_u16ActualPosition = g_u16CalibTravel;
    796a:	7203      	lod	A, [S-4]
    796c:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
				g_e8CalibrationStep = (uint8) C_CALIB_START;
    796e:	6001      	lod	AL, #1
    7970:	4118      	mov	dp:0x18 <__data_dp_start>, AL
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7972:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7974:	8c00      	cmp	AL, #0
    7976:	1e83      	jsge	0x797e <_LIN_SAE_J2602_Init+0x62>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7978:	6003      	lod	AL, #3
    797a:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
    797c:	000e      	jmp	0x799a <_LIN_SAE_J2602_Init+0x7e>
				}
				else
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    797e:	6003      	lod	AL, #3
    7980:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
    7982:	000b      	jmp	0x799a <_LIN_SAE_J2602_Init+0x7e>
    7984:	7eda 00ff 	lod	X, #255
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    7988:	7203      	lod	A, [S-4]
    798a:	7a01      	lod	Y, [S-2]
    798c:	4821      	mulu	YA, A, Y
    798e:	4c63      	divu	YA, X
    7990:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    7992:	a2da 0900 	add	A, #2304
    7996:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
			}
			else
			{
				/* Not Link/Bypass end stop */
				g_u16ActualPosition = muldivU16_U16byU16byU16( u16Pos, g_u16CalibTravel, (C_MAX_POS - C_MIN_POS)) + C_PERC_OFFSET;
				g_u16TargetPosition = g_u16ActualPosition;
    7998:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
			}
		}

		{
			uint8 u8AppStatus = g_NvramUser.AppStatus;
    799a:	6173      	lod	AL, dp:0x73 <_g_NvramUser+0x1d>
    799c:	5cf2      	usex	A
			if ( u8AppStatus & 0x03 )
    799e:	7ae2      	lod	Y, A
    79a0:	f403      	and	Y, #3
    79a2:	1901      	je	0x79a6 <_LIN_SAE_J2602_Init+0x8a>
				g_e8ErrorElectric = (uint8) (u8AppStatus & 0x03U);
    79a4:	452a      	mov	dp:0x2a <_g_e8ErrorElectric>, YL
			if ( u8AppStatus & 0x08 )
    79a6:	b408      	and	A, #8
    79a8:	1902      	je	0x79ae <_LIN_SAE_J2602_Init+0x92>
				g_u8EmergencyRunOcc = TRUE;
    79aa:	6001      	lod	AL, #1
    79ac:	4125      	mov	dp:0x25 <_g_u8EmergencyRunOcc>, AL
		}
		g_u8ChipResetOcc = FALSE;
    79ae:	6000      	lod	AL, #0
    79b0:	4127      	mov	dp:0x27 <_g_u8ChipResetOcc>, AL
    79b2:	0009      	jmp	0x79c6 <_LIN_SAE_J2602_Init+0xaa>
	}
	else if ( (g_NvramUser.NAD >= C_MIN_J2602_NAD) && (g_NvramUser.NAD <= C_MAX_J2602_NAD) && ((g_NvramUser.NAD & (C_STEP_J2602_NAD - 1)) == 0) ) /*lint !e587 */
    79b4:	5cf6      	usex	Y
    79b6:	72e6      	lod	A, Y
    79b8:	a0a0      	add	A, #-96
    79ba:	ac0d      	cmp	A, #13
    79bc:	1e04      	jug	0x79c6 <_LIN_SAE_J2602_Init+0xaa>
	{
		g_u8NAD = g_NvramUser.NAD;
    79be:	452f      	mov	dp:0x2f <_g_u8NAD>, YL
		l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
    79c0:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    79c2:	b401      	and	A, #1
    79c4:	412d      	mov	dp:0x2d <_l_u8ActDirection>, AL
#if (LINPROT != LIN2J_VALVE_VW)
		g_u8SAE_ErrorFlags = (1 << C_SAE_RESET_ERROR);
#endif /* (LINPROT != LIN2J_VALVE_VW) */
	}

	if ( (g_u8NAD & 0x0F) != 0x0F )
    79c6:	652f      	lod	YL, dp:0x2f <_g_u8NAD>
    79c8:	72e6      	lod	A, Y
    79ca:	b40f      	and	A, #15
    79cc:	ac0f      	cmp	A, #15
    79ce:	1915      	je	0x79fa <_LIN_SAE_J2602_Init+0xde>
	{
		uint8 byFrameID = ((g_u8NAD & 0x0F) << 2) + 0x00;
    79d0:	72e6      	lod	A, Y
    79d2:	44a2      	asl	A, #2
    79d4:	b43c      	and	A, #60
		byFrameID = CalcProtectionBits( byFrameID);
    79d6:	1771      	call	0x78ba <_CalcProtectionBits>
    79d8:	5cf2      	usex	A
		(void) ml_AssignFrameToMessageID( mlxACT_CTRL, byFrameID);
    79da:	52df      	push	A
    79dc:	7001      	lod	A, #1
    79de:	82db 5b76 	callf	0x5b76 <_ml_AssignFrameToMessageID>
		byFrameID = ((g_u8NAD & 0x0F) << 2) + 0x01;
    79e2:	612f      	lod	AL, dp:0x2f <_g_u8NAD>
    79e4:	b40f      	and	A, #15
    79e6:	44a2      	asl	A, #2
    79e8:	8001      	add	AL, #1
    79ea:	5cf2      	usex	A
		byFrameID = CalcProtectionBits( byFrameID);
    79ec:	1766      	call	0x78ba <_CalcProtectionBits>
    79ee:	5cf2      	usex	A
		(void) ml_AssignFrameToMessageID( mlxACT_STATUS, byFrameID);
    79f0:	52df      	push	A
    79f2:	7002      	lod	A, #2
    79f4:	82db 5b76 	callf	0x5b76 <_ml_AssignFrameToMessageID>
    79f8:	5c03      	dec	S, #4
		SetLastError( (uint8) C_ERR_INV_NAD);
	}
	l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
#endif /* (LINPROT == LIN2J_HVAC_VW) */

	(void) ml_SetLoaderNAD( g_u8NAD);											/* Setup NAD at power-up */
    79fa:	612f      	lod	AL, dp:0x2f <_g_u8NAD>
    79fc:	5cf2      	usex	A
    79fe:	82db 5e5c 	callf	0x5e5c <_ml_SetLoaderNAD>
    7a02:	5409      	ret	#10

00007a04 <_ConvertMicroStepPosToPct>:
/* ****************************************************************************	*
 * ConvertMicroStepPosToPct
 *
 * ****************************************************************************	*/
uint8 ConvertMicroStepPosToPct( uint16 u16Position)
{
    7a04:	5803      	inc	S, #4
    7a06:	5203      	mov	[S-4], A
	if ( u16Position < (C_PERC_OFFSET + C_HALFPERC_OFFSET) )
    7a08:	aeda 09e5 	cmp	A, #2533
    7a0c:	1e02      	jug	0x7a12 <_ConvertMicroStepPosToPct+0xe>
	{
		u16Position = 0U;
    7a0e:	7000      	lod	A, #0
    7a10:	0010      	jmp	0x7a32 <_ConvertMicroStepPosToPct+0x2e>
	}
	else if ( g_u16ActualPosition > ((g_u16CalibTravel + C_PERC_OFFSET) - C_HALFPERC_OFFSET) )
    7a12:	79f2      	lod	Y, dp:0xf2 <_g_u16CalibTravel>
    7a14:	72e6      	lod	A, Y
    7a16:	a2da 081a 	add	A, #2074
    7a1a:	adec      	cmp	A, dp:0xec <_g_u16ActualPosition>
    7a1c:	1c02      	jnc	0x7a22 <_ConvertMicroStepPosToPct+0x1e>
	{
		u16Position = g_u16CalibTravel;
    7a1e:	5a03      	mov	[S-4], Y
    7a20:	0009      	jmp	0x7a34 <_ConvertMicroStepPosToPct+0x30>
	}
	else
	{
		u16Position -= (C_PERC_OFFSET - (g_u16CalibTravel >> 9));
    7a22:	7ae8      	swap	Y
    7a24:	f6da 00ff 	and	Y, #255
    7a28:	4436      	lsr	Y
    7a2a:	7203      	lod	A, [S-4]
    7a2c:	a2e6      	add	A, Y
    7a2e:	a2da f700 	add	A, #63232
    7a32:	5203      	mov	[S-4], A
	}
	if ( l_u8ActDirection )
    7a34:	612d      	lod	AL, dp:0x2d <_l_u8ActDirection>
    7a36:	1903      	je	0x7a3e <_ConvertMicroStepPosToPct+0x3a>
	{
		u16Position = g_u16CalibTravel - u16Position;
    7a38:	71f2      	lod	A, dp:0xf2 <_g_u16CalibTravel>
    7a3a:	aa03      	sub	A, [S-4]
    7a3c:	5203      	mov	[S-4], A
    7a3e:	7ada 00ff 	lod	Y, #255
    7a42:	7df2      	lod	X, dp:0xf2 <_g_u16CalibTravel>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    7a44:	7203      	lod	A, [S-4]
    7a46:	4821      	mulu	YA, A, Y
    7a48:	4c63      	divu	YA, X
    7a4a:	4c63      	divu	YA, X
    7a4c:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    7a4e:	6201      	lod	AL, [S-2]
    7a50:	5cf2      	usex	A
	}
	return ( (uint8) muldivU16_U16byU16byU16( u16Position, (C_MAX_POS - C_MIN_POS), g_u16CalibTravel) );
} /* End of ConvertMicroStepPosToPct() */
    7a52:	5405      	ret	#6

00007a54 <_LIN_SAE_J2602_Store>:
 * Before the actuator enters in Sleep, it saves in EEPROM/NVRAM the CPOS,
 * the Status, and the NAD only if the value of cells is different as the RAM value.
 * MMP160613-2
 * ****************************************************************************	*/
void LIN_SAE_J2602_Store( void)
{
    7a54:	5809      	inc	S, #10
	uint16 u16Store = FALSE;
    7a56:	7000      	lod	A, #0
    7a58:	5209      	mov	[S-10], A

	uint8 u8Value = ConvertMicroStepPosToPct( g_u16ActualPosition);
    7a5a:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    7a5c:	17d3      	call	0x7a04 <_ConvertMicroStepPosToPct>
    7a5e:	4203      	mov	[S-4], AL
	/* Round actual position */
	if ( g_NvramUser.CPOS != u8Value )
    7a60:	6172      	lod	AL, dp:0x72 <_g_NvramUser+0x1c>
    7a62:	6603      	lod	YL, [S-4]
    7a64:	5cf6      	usex	Y
    7a66:	8e03      	cmp	AL, [S-4]
    7a68:	1903      	je	0x7a70 <_LIN_SAE_J2602_Store+0x1c>
	{
		g_NvramUser.CPOS = u8Value;
    7a6a:	4572      	mov	dp:0x72 <_g_NvramUser+0x1c>, YL
		u16Store = TRUE;
    7a6c:	7001      	lod	A, #1
    7a6e:	5209      	mov	[S-10], A
	}

	u8Value = g_NvramUser.AppStatus & 0x80U;
    7a70:	6173      	lod	AL, dp:0x73 <_g_NvramUser+0x1d>
    7a72:	5cf2      	usex	A
    7a74:	7ee2      	lod	X, A
    7a76:	7ae2      	lod	Y, A
    7a78:	f6da 0080 	and	Y, #128
	if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )
    7a7c:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    7a7e:	1903      	je	0x7a86 <_LIN_SAE_J2602_Store+0x32>
	{
		u8Value |= (g_e8ErrorElectric & 0x03);
    7a80:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    7a82:	b403      	and	A, #3
    7a84:	e6e2      	or	Y, A
	}
	if ( g_u8EmergencyRunOcc != FALSE )
    7a86:	6125      	lod	AL, dp:0x25 <_g_u8EmergencyRunOcc>
    7a88:	1904      	je	0x7a92 <_LIN_SAE_J2602_Store+0x3e>
	{
		u8Value |= 0x08U;
    7a8a:	62e8      	lod	AL, YL
    7a8c:	8408      	or	AL, #8
    7a8e:	66e0      	lod	YL, AL
    7a90:	5cf6      	usex	Y
	}
	if ( u8Value != g_NvramUser.AppStatus )
    7a92:	eeee      	cmp	Y, X
    7a94:	1903      	je	0x7a9c <_LIN_SAE_J2602_Store+0x48>
	{
		g_NvramUser.AppStatus = u8Value;
    7a96:	4573      	mov	dp:0x73 <_g_NvramUser+0x1d>, YL
		u16Store = TRUE;
    7a98:	7001      	lod	A, #1
    7a9a:	5209      	mov	[S-10], A
	}

	if ( g_u8NAD != g_NvramUser.NAD )
    7a9c:	652f      	lod	YL, dp:0x2f <_g_u8NAD>
    7a9e:	6158      	lod	AL, dp:0x58 <_g_NvramUser+0x2>
    7aa0:	8ee8      	cmp	AL, YL
    7aa2:	1902      	je	0x7aa8 <_LIN_SAE_J2602_Store+0x54>
	{
		g_NvramUser.NAD = g_u8NAD;
    7aa4:	4558      	mov	dp:0x58 <_g_NvramUser+0x2>, YL
    7aa6:	0002      	jmp	0x7aac <_LIN_SAE_J2602_Store+0x58>
		u16Store = TRUE;
	}

	if ( u16Store != FALSE )
    7aa8:	7209      	lod	A, [S-10]
    7aaa:	1928      	je	0x7afc <_LIN_SAE_J2602_Store+0xa8>
		 * 						  0		  0		Write C_NVRAM_USER_PAGE_1
		 * 						  0		  1		Write C_NVRAM_USER_PAGE_2
		 * 						  1		  0		Write C_NVRAM_USER_PAGE_2
		 * 						  1		  1		Write C_NVRAM_USER_PAGE_1
		 */
		if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    7aac:	7ada 101d 	lod	Y, #4125
    7ab0:	66f0      	lod	YL, [Y]
    7ab2:	f6da 0080 	and	Y, #128
    7ab6:	7ee6      	lod	X, Y
    7ab8:	7ada 111d 	lod	Y, #4381
    7abc:	62f0      	lod	AL, [Y]
    7abe:	4201      	mov	[S-2], AL
    7ac0:	66e0      	lod	YL, AL
    7ac2:	f6da 0080 	and	Y, #128
    7ac6:	6173      	lod	AL, dp:0x73 <_g_NvramUser+0x1d>
    7ac8:	4205      	mov	[S-6], AL
    7aca:	6201      	lod	AL, [S-2]
    7acc:	9480      	and	AL, #-128
    7ace:	4204      	mov	[S-5], AL
    7ad0:	2ee6      	cmp	X, Y
    7ad2:	1908      	je	0x7ae4 <_LIN_SAE_J2602_Store+0x90>
		{
			g_NvramUser.AppStatus = (g_NvramUser.AppStatus & 0x7F) | (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80);
    7ad4:	6205      	lod	AL, [S-6]
    7ad6:	947f      	and	AL, #127
    7ad8:	8604      	or	AL, [S-5]
    7ada:	4173      	mov	dp:0x73 <_g_NvramUser+0x1d>, AL
			(void) NVRAM_Store( C_NVRAM_USER_PAGE_1);
    7adc:	7001      	lod	A, #1
    7ade:	82db 98f8 	callf	0x98f8 <_NVRAM_Store>
    7ae2:	540b      	ret	#12
		}
		else
		{
			g_NvramUser.AppStatus = (g_NvramUser.AppStatus & 0x7F) | ((((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) ^ 0x80);
    7ae4:	6205      	lod	AL, [S-6]
    7ae6:	947f      	and	AL, #127
    7ae8:	4201      	mov	[S-2], AL
    7aea:	6204      	lod	AL, [S-5]
    7aec:	9c80      	xor	AL, #-128
    7aee:	4206      	mov	[S-7], AL
    7af0:	6201      	lod	AL, [S-2]
    7af2:	8606      	or	AL, [S-7]
    7af4:	4173      	mov	dp:0x73 <_g_NvramUser+0x1d>, AL
			(void) NVRAM_Store( C_NVRAM_USER_PAGE_2);
    7af6:	7002      	lod	A, #2
    7af8:	82db 98f8 	callf	0x98f8 <_NVRAM_Store>
    7afc:	540b      	ret	#12

00007afe <_HandleActCfrCtrl>:
 *			+-----------------------+-------------------------------+-------+
 *
 * MMP160614-2 & MMP160614-3
 * ****************************************************************************	*/
void HandleActCfrCtrl( void)
{
    7afe:	5817      	inc	S, #24
	ACT_CFR_CTRL *pCfrCtrl = &g_LinCmdFrameBuffer.cfrCtrl;

	if ( (pCfrCtrl->byMovEn == C_CTRL_MOVE_ENA) && (pCfrCtrl->byTorqueLevel != C_CTRL_TORQUE_UNCHANGED) )
    7b00:	6139      	lod	AL, dp:0x39 <__data_dp_end+0x1>
    7b02:	4217      	mov	[S-24], AL
    7b04:	9401      	and	AL, #1
    7b06:	1d01      	jne	0x7b0a <_HandleActCfrCtrl+0xc>
    7b08:	0075      	jmp	0x7bf4 <_HandleActCfrCtrl+0xf6>
    7b0a:	6217      	lod	AL, [S-24]
    7b0c:	941e      	and	AL, #30
    7b0e:	1d01      	jne	0x7b12 <_HandleActCfrCtrl+0x14>
    7b10:	0071      	jmp	0x7bf4 <_HandleActCfrCtrl+0xf6>
	{
		uint16 u16Pos = pCfrCtrl->byPosition;
    7b12:	6538      	lod	YL, dp:0x38 <__data_dp_end>
    7b14:	5cf6      	usex	Y
    7b16:	5a13      	mov	[S-20], Y
		if ( l_u8ActDirection != FALSE )
    7b18:	612d      	lod	AL, dp:0x2d <_l_u8ActDirection>
    7b1a:	1904      	je	0x7b24 <_HandleActCfrCtrl+0x26>
		{
			u16Pos = C_MAX_POS - u16Pos;
    7b1c:	7ada 00ff 	lod	Y, #255
    7b20:	ea13      	sub	Y, [S-20]
    7b22:	5a13      	mov	[S-20], Y
		}
		if ( g_e8CalibrationStep != (uint8) C_CALIB_DONE )
    7b24:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    7b26:	8c07      	cmp	AL, #7
    7b28:	1916      	je	0x7b56 <_HandleActCfrCtrl+0x58>
		{
			/* Not initialised; Only allow to move towards the end-stops */
			if ( u16Pos == C_MIN_POS )
    7b2a:	7a13      	lod	Y, [S-20]
    7b2c:	1d07      	jne	0x7b3c <_HandleActCfrCtrl+0x3e>
			{
				g_u16TargetPosition = 0;
    7b2e:	7000      	lod	A, #0
    7b30:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
				g_u16ActualPosition = g_u16CalibTravel + (2 * C_PERC_OFFSET);
    7b32:	79f2      	lod	Y, dp:0xf2 <_g_u16CalibTravel>
    7b34:	e2da 1200 	add	Y, #4608
    7b38:	59ec      	mov	dp:0xec <_g_u16ActualPosition>, Y
    7b3a:	000a      	jmp	0x7b50 <_HandleActCfrCtrl+0x52>
				else
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
				}
			}
			else if ( u16Pos == C_MAX_POS )
    7b3c:	7a13      	lod	Y, [S-20]
    7b3e:	eeda 00ff 	cmp	Y, #255
    7b42:	1d28      	jne	0x7b94 <_HandleActCfrCtrl+0x96>
			{
				g_u16TargetPosition = g_u16CalibTravel + (2 * C_PERC_OFFSET);
    7b44:	79f2      	lod	Y, dp:0xf2 <_g_u16CalibTravel>
    7b46:	e2da 1200 	add	Y, #4608
    7b4a:	59ee      	mov	dp:0xee <_g_u16TargetPosition>, Y
				g_u16ActualPosition = 0;
    7b4c:	7000      	lod	A, #0
    7b4e:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
				g_e8CalibrationStep = (uint8) C_CALIB_START;
    7b50:	6401      	lod	YL, #1
    7b52:	4518      	mov	dp:0x18 <__data_dp_start>, YL
    7b54:	0017      	jmp	0x7b84 <_HandleActCfrCtrl+0x86>
    7b56:	7eda 00ff 	lod	X, #255
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    7b5a:	7213      	lod	A, [S-20]
    7b5c:	79f2      	lod	Y, dp:0xf2 <_g_u16CalibTravel>
    7b5e:	4821      	mulu	YA, A, Y
    7b60:	4c63      	divu	YA, X
    7b62:	4c63      	divu	YA, X
    7b64:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    7b66:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
		}
		else
		{
			/* Initialised; Any position allowed */
			g_u16TargetPosition = muldivU16_U16byU16byU16( u16Pos, g_u16CalibTravel, (C_MAX_POS - C_MIN_POS));
			if ( u16Pos == C_MAX_POS )										/* Upper end-position: Stall-detection */
    7b68:	7213      	lod	A, [S-20]
    7b6a:	aeda 00ff 	cmp	A, #255
    7b6e:	1d04      	jne	0x7b78 <_HandleActCfrCtrl+0x7a>
			{
				g_u16TargetPosition += C_PERC_OFFSET;
    7b70:	22da 0900 	add	X, #2304
    7b74:	5dee      	mov	dp:0xee <_g_u16TargetPosition>, X
    7b76:	0002      	jmp	0x7b7c <_HandleActCfrCtrl+0x7e>
			}
			if ( u16Pos != C_MIN_POS )										/* Lower end-position: Stall-detection */
    7b78:	7a13      	lod	Y, [S-20]
    7b7a:	1904      	je	0x7b84 <_HandleActCfrCtrl+0x86>
			{
				g_u16TargetPosition += C_PERC_OFFSET;
    7b7c:	79ee      	lod	Y, dp:0xee <_g_u16TargetPosition>
    7b7e:	e2da 0900 	add	Y, #2304
    7b82:	59ee      	mov	dp:0xee <_g_u16TargetPosition>, Y
			}
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7b84:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7b86:	8c00      	cmp	AL, #0
    7b88:	1e83      	jsge	0x7b90 <_HandleActCfrCtrl+0x92>
			{
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7b8a:	6403      	lod	YL, #3
    7b8c:	4523      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, YL
    7b8e:	0002      	jmp	0x7b94 <_HandleActCfrCtrl+0x96>
			}
			else
			{
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7b90:	6403      	lod	YL, #3
    7b92:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
			}
		}
		if ( (pCfrCtrl->byTorqueLevel >= C_CTRL_TORQUE_NOMINAL) && (pCfrCtrl->byTorqueLevel <= C_CTRL_TORQUE_BOOST_100PCT) )
    7b94:	6217      	lod	AL, [S-24]
    7b96:	941e      	and	AL, #30
    7b98:	192f      	je	0x7bf8 <_HandleActCfrCtrl+0xfa>
    7b9a:	6217      	lod	AL, [S-24]
    7b9c:	4430      	lsr	AL
    7b9e:	940f      	and	AL, #15
    7ba0:	420a      	mov	[S-11], AL
    7ba2:	8c0b      	cmp	AL, #11
    7ba4:	1e29      	jug	0x7bf8 <_HandleActCfrCtrl+0xfa>
		{
			g_u8TorqueBoostRequest = (pCfrCtrl->byTorqueLevel - C_CTRL_TORQUE_NOMINAL) * 10U;	/* Percentage */
    7ba6:	640a      	lod	YL, #10
    7ba8:	4829      	mulu	Y, AL, YL
    7baa:	5a09      	mov	[S-10], Y
    7bac:	6209      	lod	AL, [S-10]
    7bae:	80f6      	add	AL, #-10
    7bb0:	66e0      	lod	YL, AL
    7bb2:	42d8 00fb 	mov	0xfb <_g_u8TorqueBoostRequest>, AL
			g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL + muldivU16_U16byU16byU16( NVRAM_RUNNING_CURR_LEVEL, g_u8TorqueBoostRequest, 100U);
    7bb6:	61a5      	lod	AL, dp:0xa5 <_g_NvramUser+0x4f>
    7bb8:	44a2      	asl	A, #2
    7bba:	b6da 03fc 	and	A, #1020
    7bbe:	5205      	mov	[S-6], A
    7bc0:	5cf6      	usex	Y
    7bc2:	7c64      	lod	X, #100
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    7bc4:	4821      	mulu	YA, A, Y
    7bc6:	4c63      	divu	YA, X
    7bc8:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    7bca:	7a05      	lod	Y, [S-6]
    7bcc:	e2e2      	add	Y, A
    7bce:	5a03      	mov	[S-4], Y
    7bd0:	5ad8 0296 	mov	0x296 <_g_u16PidRunningThreshold>, Y
    7bd4:	7ad8 11d0 	lod	Y, 0x11d0 <__ep__+0x1d0>
    7bd8:	f6da 00ff 	and	Y, #255
    7bdc:	7ee6      	lod	X, Y
    7bde:	22da 0100 	add	X, #256
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    7be2:	7203      	lod	A, [S-4]
    7be4:	7ada 0080 	lod	Y, #128
    7be8:	4821      	mulu	YA, A, Y
    7bea:	4c63      	divu	YA, X
    7bec:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    7bee:	52d8 0298 	mov	0x298 <_g_u16PidRunningThresholdADC>, A
    7bf2:	0002      	jmp	0x7bf8 <_HandleActCfrCtrl+0xfa>
			g_u16PidRunningThresholdADC = muldivU16_U16byU16byU16( g_u16PidRunningThreshold, C_GMCURR_DIV, EE_GMCURR);	/* Convert [mA] to [ADC-lsb] */
		}
	}
	else
	{
		g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    7bf4:	6401      	lod	YL, #1
    7bf6:	452b      	mov	dp:0x2b <_g_e8MotorRequest>, YL
	}

	g_u8ChipResetOcc = FALSE;											/* Clear 'reset'-flag only after CFR_INI (4.2.6.3) */
    7bf8:	6000      	lod	AL, #0
    7bfa:	4127      	mov	dp:0x27 <_g_u8ChipResetOcc>, AL
    7bfc:	5419      	ret	#26

00007bfe <_HandleActRfrSta>:
 *	Byte 3	|			Reserved			|	ArcState	|	InitState	|
 *			+-------------------------------+---------------+---------------+
 *
 * ****************************************************************************	*/
void HandleActRfrSta( void)
{
    7bfe:	580f      	inc	S, #16
	ACT_RFR_STA *pRfrSta = (ACT_RFR_STA *)LinFrameDataBuffer;

	/* Byte 2 */
	pRfrSta->byActPosition = ConvertMicroStepPosToPct( g_u16ActualPosition);
    7c00:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    7c02:	1700      	call	0x7a04 <_ConvertMicroStepPosToPct>
    7c04:	41c9      	mov	dp:0xc9 <_LinFrameDataBuffer+0x1>, AL

	/* Byte 1 */
	if ( g_u8ErrorCommunication != FALSE )
    7c06:	62d8 0111 	lod	AL, 0x111 <_g_u8ErrorCommunication>
    7c0a:	4207      	mov	[S-8], AL
    7c0c:	61c8      	lod	AL, dp:0xc8 <_LinFrameDataBuffer>
    7c0e:	420a      	mov	[S-11], AL
    7c10:	6207      	lod	AL, [S-8]
    7c12:	1903      	je	0x7c1a <_HandleActRfrSta+0x1c>
	{
		pRfrSta->byLinErr = C_STATUS_LIN_ERR;
    7c14:	620a      	lod	AL, [S-11]
    7c16:	8401      	or	AL, #1
    7c18:	0002      	jmp	0x7c1e <_HandleActRfrSta+0x20>
	}
	else
	{
		pRfrSta->byLinErr = C_STATUS_LIN_OK;
    7c1a:	620a      	lod	AL, [S-11]
    7c1c:	94fe      	and	AL, #-2
    7c1e:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
	}
	g_u8SAE_SendErrorState = g_u8ErrorCommunication;
    7c20:	62d8 0111 	lod	AL, 0x111 <_g_u8ErrorCommunication>
    7c24:	412e      	mov	dp:0x2e <_g_u8SAE_SendErrorState>, AL
	if ( g_e8ErrorElectric == C_ERR_ELECTRIC_PERM )
    7c26:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    7c28:	8c02      	cmp	AL, #2
    7c2a:	190b      	je	0x7c42 <_HandleActRfrSta+0x44>
	{
		pRfrSta->byFaultState = C_STATUS_FAULT;
	}
	else if ( (g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO) || (g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE) ||
    7c2c:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    7c2e:	1d09      	jne	0x7c42 <_HandleActRfrSta+0x44>
    7c30:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    7c32:	1d07      	jne	0x7c42 <_HandleActRfrSta+0x44>
    7c34:	6124      	lod	AL, dp:0x24 <_g_e8ErrorOverTemperature>
    7c36:	1d05      	jne	0x7c42 <_HandleActRfrSta+0x44>
    7c38:	62d8 00f8 	lod	AL, 0xf8 <__dp_noinit_end>
    7c3c:	1d02      	jne	0x7c42 <_HandleActRfrSta+0x44>
    7c3e:	6126      	lod	AL, dp:0x26 <_g_u8StallOcc>
    7c40:	1904      	je	0x7c4a <_HandleActRfrSta+0x4c>
			  /* (g_u8ChipResetOcc != FALSE) || */ (g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_NO) ||
			  (g_u8MechError != FALSE) || (g_u8StallOcc != FALSE))
	{
		pRfrSta->byFaultState = C_STATUS_FAULT;
    7c42:	61c8      	lod	AL, dp:0xc8 <_LinFrameDataBuffer>
    7c44:	94f9      	and	AL, #-7
    7c46:	8402      	or	AL, #2
    7c48:	0002      	jmp	0x7c4e <_HandleActRfrSta+0x50>
	}
	else
	{
		pRfrSta->byFaultState = C_STATUS_NO_FAULT;
    7c4a:	61c8      	lod	AL, dp:0xc8 <_LinFrameDataBuffer>
    7c4c:	94f9      	and	AL, #-7
    7c4e:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
	}
	if ( (g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0 )
    7c50:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7c52:	7ae2      	lod	Y, A
    7c54:	f401      	and	Y, #1
    7c56:	61c8      	lod	AL, dp:0xc8 <_LinFrameDataBuffer>
    7c58:	420a      	mov	[S-11], AL
    7c5a:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    7c5c:	4209      	mov	[S-10], AL
    7c5e:	ec00      	cmp	Y, #0
    7c60:	1d03      	jne	0x7c68 <_HandleActRfrSta+0x6a>
	{
		pRfrSta->byMoveState = C_STATUS_MOVE_IDLE;
		pRfrSta->byTorqueLevel = 0U;
    7c62:	620a      	lod	AL, [S-11]
    7c64:	9407      	and	AL, #7
    7c66:	0018      	jmp	0x7c98 <_HandleActRfrSta+0x9a>
	}
	else
	{
		pRfrSta->byMoveState = C_STATUS_MOVE_ACTIVE;
    7c68:	620a      	lod	AL, [S-11]
    7c6a:	8408      	or	AL, #8
    7c6c:	420f      	mov	[S-16], AL
    7c6e:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    7c70:	66d8 00fb 	lod	YL, 0xfb <_g_u8TorqueBoostRequest>
    7c74:	5cf6      	usex	Y
    7c76:	5a05      	mov	[S-6], Y
    7c78:	7205      	lod	A, [S-6]
    7c7a:	7800      	lod	Y, #0
    7c7c:	5205      	mov	[S-6], A
    7c7e:	5a03      	mov	[S-4], Y
    7c80:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    7c82:	4c63      	divu	YA, X
    7c84:	4c63      	divu	YA, X
    7c86:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    7c88:	6205      	lod	AL, [S-6]
    7c8a:	8001      	add	AL, #1
    7c8c:	44a0      	asl	AL, #2
    7c8e:	44a0      	asl	AL, #2
    7c90:	420e      	mov	[S-15], AL
    7c92:	620f      	lod	AL, [S-16]
    7c94:	940f      	and	AL, #15
    7c96:	860e      	or	AL, [S-15]
    7c98:	41c8      	mov	dp:0xc8 <_LinFrameDataBuffer>, AL
		pRfrSta->byTorqueLevel = (uint8) divU16_U32byU16( (uint32) g_u8TorqueBoostRequest, 10U) + C_CTRL_TORQUE_NOMINAL;
	}

	/* Byte #3 */
	if ( g_e8CalibrationStep == (uint8) C_CALIB_DONE )
    7c9a:	6209      	lod	AL, [S-10]
    7c9c:	8c07      	cmp	AL, #7
    7c9e:	1d04      	jne	0x7ca8 <_HandleActRfrSta+0xaa>
	{
		pRfrSta->byInitState = C_STATUS_INIT_DONE;
    7ca0:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer+0x2>
    7ca2:	94fc      	and	AL, #-4
    7ca4:	8402      	or	AL, #2
    7ca6:	000e      	jmp	0x7cc4 <_HandleActRfrSta+0xc6>
	}
	else if ( (g_e8CalibrationStep == (uint8) C_CALIB_NONE) || (g_e8CalibrationStep >= (uint8) C_CALIB_FAILED) )
    7ca8:	6209      	lod	AL, [S-10]
    7caa:	80ff      	add	AL, #-1
    7cac:	4205      	mov	[S-6], AL
    7cae:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer+0x2>
    7cb0:	4208      	mov	[S-9], AL
    7cb2:	6205      	lod	AL, [S-6]
    7cb4:	8c06      	cmp	AL, #6
    7cb6:	1a03      	jule	0x7cbe <_HandleActRfrSta+0xc0>
	{
		pRfrSta->byInitState = C_STATUS_NOT_INIT;
    7cb8:	6208      	lod	AL, [S-9]
    7cba:	94fc      	and	AL, #-4
    7cbc:	0003      	jmp	0x7cc4 <_HandleActRfrSta+0xc6>
	}
	else
	{
		pRfrSta->byInitState = C_STATUS_INIT_BUSY;
    7cbe:	6208      	lod	AL, [S-9]
    7cc0:	94fc      	and	AL, #-4
    7cc2:	8401      	or	AL, #1
    7cc4:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
	}
	pRfrSta->byArcState = l_u8StaCounter;
    7cc6:	62d8 0113 	lod	AL, 0x113 <_l_u8StaCounter>
    7cca:	420d      	mov	[S-14], AL
    7ccc:	9403      	and	AL, #3
    7cce:	44a0      	asl	AL, #2
    7cd0:	420c      	mov	[S-13], AL
    7cd2:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer+0x2>
    7cd4:	9403      	and	AL, #3
    7cd6:	420b      	mov	[S-12], AL
	l_u8StaCounter++;
    7cd8:	620d      	lod	AL, [S-14]
    7cda:	8001      	add	AL, #1
    7cdc:	42d8 0113 	mov	0x113 <_l_u8StaCounter>, AL
	pRfrSta->byReserved2_4 = 0;													/* Reserved field filled with '0' */
    7ce0:	620b      	lod	AL, [S-12]
    7ce2:	860c      	or	AL, [S-13]
    7ce4:	41ca      	mov	dp:0xca <_LinFrameDataBuffer+0x2>, AL
    7ce6:	5411      	ret	#18

00007ce8 <_HandleBusTimeout>:
 *  Bus-timeout
 * ****************************************************************************	*/
void HandleBusTimeout( void)
{
#if _SUPPORT_BUSTIMEOUT
	if ( g_u8ErrorCommBusTimeout == FALSE )
    7ce8:	62d8 0110 	lod	AL, 0x110 <_g_u8ErrorCommBusTimeout>
    7cec:	1d14      	jne	0x7d16 <_HandleBusTimeout+0x2e>
	{
		/* Emergency run is enabled */
		g_u8ErrorCommBusTimeout = TRUE;
    7cee:	6001      	lod	AL, #1
    7cf0:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
		SetLastError( (uint8) C_ERR_LIN_BUS_TIMEOUT);
    7cf4:	72da 00bf 	lod	A, #191
    7cf8:	82db 89e6 	callf	0x89e6 <_SetLastError>

		if ( g_NvramUser.EmergencyRunEna != FALSE )
    7cfc:	6166      	lod	AL, dp:0x66 <_g_NvramUser+0x10>
    7cfe:	4432      	lsr	A
    7d00:	b401      	and	A, #1
    7d02:	1909      	je	0x7d16 <_HandleBusTimeout+0x2e>
		{
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7d04:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7d06:	8c00      	cmp	AL, #0
    7d08:	1e84      	jsge	0x7d12 <_HandleBusTimeout+0x2a>
			{
				/* Module is in degraded-mode; Postpone emergency-run till after degraded-mode have been obsoleted */
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    7d0a:	6007      	lod	AL, #7
    7d0c:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
				g_e8DegradedMotorRequest = g_e8MotorRequest;
    7d0e:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
    7d10:	5401      	ret
			}
			else
			{
				/* Perform emergency-run immediately */
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    7d12:	6007      	lod	AL, #7
    7d14:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
    7d16:	5401      	ret

00007d18 <_LIN2J_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2J_ErrorHandling( ml_LinError Error)
{
    7d18:	5803      	inc	S, #4
    7d1a:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) (LinProtectedID & 0x3F);							/* Get Frame-ID without parity bits */
    7d1c:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    7d1e:	b43f      	and	A, #63
    7d20:	5203      	mov	[S-4], A
	if ( (u8FrameID == (uint8) ML_MRF_ID) && ((Error == ml_erDataFraming) || (Error == ml_erCheckSum)) )
    7d22:	8c3c      	cmp	AL, #60
    7d24:	1d06      	jne	0x7d32 <_LIN2J_ErrorHandling+0x1a>
    7d26:	ec06      	cmp	Y, #6
    7d28:	1902      	je	0x7d2e <_LIN2J_ErrorHandling+0x16>
    7d2a:	ec04      	cmp	Y, #4
    7d2c:	1d02      	jne	0x7d32 <_LIN2J_ErrorHandling+0x1a>
	{
		/*
		 * Abort Diagnostic communication with corrupted Diagnostic request
		 * Checked by LIN2.1 CT test case 13.2.2
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    7d2e:	60ff      	lod	AL, #-1
    7d30:	412c      	mov	dp:0x2c <_g_u8BufferOutID>, AL
	}

	/* ---- ml_erLinModuleReset -------------------------------------------- */
	if ( Error == ml_erLinModuleReset )
    7d32:	ec02      	cmp	Y, #2
    7d34:	1d01      	jne	0x7d38 <_LIN2J_ErrorHandling+0x20>
    7d36:	0027      	jmp	0x7d86 <_LIN2J_ErrorHandling+0x6e>
	{
		/* Non-recoverable failure has occurred in the LIN Module */
		/* switch to System Mode and reinitialise LIN module */
	}
	/* ---- ml_erIdParity -------------------------------------------------- */
	else if ( (Error == ml_erIdParity) || (Error == ml_erIdFraming ) )
    7d38:	ec03      	cmp	Y, #3
    7d3a:	191c      	je	0x7d74 <_LIN2J_ErrorHandling+0x5c>
    7d3c:	ec07      	cmp	Y, #7
    7d3e:	191a      	je	0x7d74 <_LIN2J_ErrorHandling+0x5c>
//			 ((u8FrameID == ML_SRF_ID) && (g_u8BufferOutID == (uint8) QR_RFR_DIAG) && (g_DiagResponse.byNAD == g_u8NAD)) )	/* DIAG_3D_MSG */
		{
			g_u8ErrorCommunication = TRUE;
		}
	}
	else if ( (Error == ml_erCheckSum) || (Error == ml_erDataFraming) )
    7d40:	ec04      	cmp	Y, #4
    7d42:	1902      	je	0x7d48 <_LIN2J_ErrorHandling+0x30>
    7d44:	ec06      	cmp	Y, #6
    7d46:	1d0e      	jne	0x7d64 <_LIN2J_ErrorHandling+0x4c>
	{
		/* Checksum error in message received -OR- Stop or Start bit error while receiving data (SAE_J2602-2: 5.4.1.2 & 5.4.1.3) */
		if ( (u8FrameID == (((g_u8NAD & 0x0F) << 2) + 0x00)) ||					/* CONTROL_MSG */
    7d48:	652f      	lod	YL, dp:0x2f <_g_u8NAD>
    7d4a:	72e6      	lod	A, Y
    7d4c:	b40f      	and	A, #15
    7d4e:	44a2      	asl	A, #2
    7d50:	7e03      	lod	X, [S-4]
    7d52:	2ee2      	cmp	X, A
    7d54:	190f      	je	0x7d74 <_LIN2J_ErrorHandling+0x5c>
    7d56:	6203      	lod	AL, [S-4]
    7d58:	8c3c      	cmp	AL, #60
    7d5a:	1d15      	jne	0x7d86 <_LIN2J_ErrorHandling+0x6e>
    7d5c:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
    7d5e:	8ee8      	cmp	AL, YL
    7d60:	1d12      	jne	0x7d86 <_LIN2J_ErrorHandling+0x6e>
    7d62:	0008      	jmp	0x7d74 <_LIN2J_ErrorHandling+0x5c>
			 ((u8FrameID == ML_MRF_ID) && (LinFrame[0] == g_u8NAD)) )			/* DIAG_3C_MSG */
		{
			g_u8ErrorCommunication = TRUE;
		}
	}
	else if ( Error == ml_erSynchField )
    7d64:	ec08      	cmp	Y, #8
    7d66:	1d0a      	jne	0x7d7c <_LIN2J_ErrorHandling+0x64>
	{
		/* Sync field timing error;
		 * In case: BufferOutID is QR_RFR_DIAG, and NAD is real-NAD (SAE_J2602-2: 5.4.1.4) */
		if ( (g_u8BufferOutID == (uint8) QR_RFR_DIAG) && (g_DiagResponse.byNAD == g_u8NAD) )
    7d68:	612c      	lod	AL, dp:0x2c <_g_u8BufferOutID>
    7d6a:	8c07      	cmp	AL, #7
    7d6c:	1d0c      	jne	0x7d86 <_LIN2J_ErrorHandling+0x6e>
    7d6e:	6140      	lod	AL, dp:0x40 <_g_DiagResponse>
    7d70:	8d2f      	cmp	AL, dp:0x2f <_g_u8NAD>
    7d72:	1d09      	jne	0x7d86 <_LIN2J_ErrorHandling+0x6e>
		{
			g_u8ErrorCommunication = TRUE;
    7d74:	6001      	lod	AL, #1
    7d76:	42d8 0111 	mov	0x111 <_g_u8ErrorCommunication>, AL
    7d7a:	5405      	ret	#6
		}
	}
	else if ( Error == ml_erBit )
    7d7c:	ec05      	cmp	Y, #5
    7d7e:	1d03      	jne	0x7d86 <_LIN2J_ErrorHandling+0x6e>
	{
		/* Data collision during the transmit cycle (SAE_J2602-2: 5.4.1.5) */
		g_u8ErrorCommunication = TRUE;
    7d80:	6001      	lod	AL, #1
    7d82:	42d8 0111 	mov	0x111 <_g_u8ErrorCommunication>, AL
    7d86:	5405      	ret	#6

00007d88 <_SetupDiagResponse>:

/* ****************************************************************************	*
 * SetupDiagResponse
 * ****************************************************************************	*/
void SetupDiagResponse( uint8 u8NAD, uint8 u8SID, uint8 u8ResponseCode)
{
    7d88:	5801      	inc	S, #2
    7d8a:	6605      	lod	YL, [S-6]
    7d8c:	5cf6      	usex	Y
    7d8e:	5a01      	mov	[S-2], Y
    7d90:	6607      	lod	YL, [S-8]
    7d92:	5cf6      	usex	Y
	g_DiagResponse.byNAD = u8NAD;
    7d94:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
	if ( u8ResponseCode == (uint8) C_ERRCODE_POSITIVE_RESPONSE )
    7d96:	1d09      	jne	0x7daa <_SetupDiagResponse+0x22>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x01|  SID | Reserved | Reserved | Reserved | Reserved | Reserved |
		 *	|  NAD  |     | |0x40|   0xFF   |   0xFF   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_REASSIGN_NAD;
    7d98:	6001      	lod	AL, #1
    7d9a:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (u8SID | C_RSID_OK);
    7d9c:	6201      	lod	AL, [S-2]
    7d9e:	8440      	or	AL, #64
    7da0:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    7da2:	60ff      	lod	AL, #-1
    7da4:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    7da6:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
    7da8:	0007      	jmp	0x7db8 <_SetupDiagResponse+0x30>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x03| 0x7F | Requested| Response | Reserved | Reserved | Reserved |
		 *	|  NAD  |     |      |    SID   |   Code   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_NOK;
    7daa:	6003      	lod	AL, #3
    7dac:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_RSID_NOK;
    7dae:	607f      	lod	AL, #127
    7db0:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = u8SID;
    7db2:	6201      	lod	AL, [S-2]
    7db4:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = u8ResponseCode;
    7db6:	4544      	mov	dp:0x44 <_g_DiagResponse+0x4>, YL
	}

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    7db8:	6007      	lod	AL, #7
    7dba:	412c      	mov	dp:0x2c <_g_u8BufferOutID>, AL
    7dbc:	5403      	ret	#4

00007dbe <_CheckSupplier>:
/* ****************************************************************************	*
 * CheckSupplier
 * ****************************************************************************	*/
uint16 CheckSupplier( uint16 const u16SupplierID)
{
	uint16 u16Result = FALSE;
    7dbe:	7800      	lod	Y, #0
	if ( (u16SupplierID == (uint16) C_WILDCARD_SUPPLIER_ID)
    7dc0:	aeda 7fff 	cmp	A, #32767
    7dc4:	1903      	je	0x7dcc <_CheckSupplier+0xe>
    7dc6:	aeda 0124 	cmp	A, #292
    7dca:	1d01      	jne	0x7dce <_CheckSupplier+0x10>
		|| (u16SupplierID == (uint16)C_SUPPLIER_ID) )
	{
		u16Result = TRUE;
    7dcc:	7801      	lod	Y, #1
	}
	return ( u16Result );
} /* End of CheckSupplier() */
    7dce:	72e6      	lod	A, Y
    7dd0:	5401      	ret

00007dd2 <_ValidSupplierFunctionID>:
 * Pre:		Pointer to address of supplier and function ID
 * Post:	FALSE: Incorrect supplier and/or function ID
 *			TRUE: Correct supplier and function ID
 * ****************************************************************************	*/
uint16 ValidSupplierFunctionID( uint16 const u16SupplierID, uint16 const u16FunctionID )
{
    7dd2:	7a03      	lod	Y, [S-4]
	uint16 u16Result = FALSE;
    7dd4:	7c00      	lod	X, #0
	if ( ((u16SupplierID == C_SUPPLIER_ID)
    7dd6:	aeda 0124 	cmp	A, #292
    7dda:	1903      	je	0x7de2 <_ValidSupplierFunctionID+0x10>
    7ddc:	aeda 7fff 	cmp	A, #32767
    7de0:	1d06      	jne	0x7dee <_ValidSupplierFunctionID+0x1c>
    7de2:	eeda 00b0 	cmp	Y, #176
    7de6:	1902      	je	0x7dec <_ValidSupplierFunctionID+0x1a>
    7de8:	ecff      	cmp	Y, #-1
    7dea:	1d01      	jne	0x7dee <_ValidSupplierFunctionID+0x1c>
		|| (u16SupplierID == C_WILDCARD_SUPPLIER_ID)) &&
		((u16FunctionID == C_FUNCTION_ID)
		|| (u16FunctionID == C_WILDCARD_FUNCTION_ID)) )
	{
		u16Result = TRUE;
    7dec:	7c01      	lod	X, #1
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */
    7dee:	72ee      	lod	A, X
    7df0:	5401      	ret

00007df2 <_HandleDfrDiag>:

/* ****************************************************************************	*
 * Diagnostic
 * ****************************************************************************	*/
void HandleDfrDiag( void)
{
    7df2:	581b      	inc	S, #28
	}
	else if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == (uint8) C_BROADCAST_NAD) )
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
	/* Targeted or Broadcast */
	if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == C_BROADCAST_J2602_NAD) )
    7df4:	6138      	lod	AL, dp:0x38 <__data_dp_end>
    7df6:	4203      	mov	[S-4], AL
    7df8:	62d8 002f 	lod	AL, 0x2f <_g_u8NAD>
    7dfc:	421b      	mov	[S-28], AL
    7dfe:	6203      	lod	AL, [S-4]
    7e00:	8e1b      	cmp	AL, [S-28]
    7e02:	1903      	je	0x7e0a <_HandleDfrDiag+0x18>
    7e04:	8c7f      	cmp	AL, #127
    7e06:	1901      	je	0x7e0a <_HandleDfrDiag+0x18>
    7e08:	02d0      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		uint16 u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8) | ((uint16)pDiag->bySID);
    7e0a:	6d39      	lod	YH, dp:0x39 <__data_dp_end+0x1>
    7e0c:	6400      	lod	YL, #0
    7e0e:	613a      	lod	AL, dp:0x3a <__data_dp_end+0x2>
    7e10:	4217      	mov	[S-24], AL
    7e12:	5cf2      	usex	A
    7e14:	5219      	mov	[S-26], A
    7e16:	e6e2      	or	Y, A

		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    7e18:	60ff      	lod	AL, #-1
    7e1a:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    7e1c:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    7e1e:	4145      	mov	dp:0x45 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    7e20:	4146      	mov	dp:0x46 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    7e22:	4147      	mov	dp:0x47 <_g_DiagResponse+0x7>, AL
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_COND_SEQ);	/* Status = Negative feedback */
			SetLastError( (uint8) C_ERR_LIN2X_WRITE);
		}
		else if ( (u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD) && (pDiag->byNAD != (uint8) C_DEFAULT_NAD) )
#else  /* (LINPROT == LIN2X_ACT44) */
		if ( u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD )
    7e24:	eeda 06b0 	cmp	Y, #1712
    7e28:	1901      	je	0x7e2c <_HandleDfrDiag+0x3a>
    7e2a:	0038      	jmp	0x7e9c <_HandleDfrDiag+0xaa>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB0 | Supplier | Supplier | Function | Function |  New NAD |
			 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8)) )
    7e2c:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    7e2e:	5cf2      	usex	A
    7e30:	7ee2      	lod	X, A
    7e32:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x6>
    7e34:	6000      	lod	AL, #0
    7e36:	26e2      	or	X, A
    7e38:	693c      	lod	AH, dp:0x3c <__data_dp_end+0x4>
    7e3a:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
    7e3c:	5edf      	push	X
    7e3e:	17c9      	call	0x7dd2 <_ValidSupplierFunctionID>
    7e40:	5c01      	dec	S, #2
    7e42:	ac00      	cmp	A, #0
    7e44:	1d01      	jne	0x7e48 <_HandleDfrDiag+0x56>
    7e46:	02b1      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
			{
				uint8 byInitialNAD = g_NvramUser.NAD;
    7e48:	6158      	lod	AL, dp:0x58 <_g_NvramUser+0x2>
    7e4a:	5cf2      	usex	A
    7e4c:	5215      	mov	[S-22], A
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);		/* Status = Negative feedback */
				}
				else
#endif /* ((LINPROT & LINXX) == LIN2J) */
				{
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);				/* Status = Pending */
    7e4e:	54ca 0078 	pushw	#120
    7e52:	7a1b      	lod	Y, [S-28]
    7e54:	5adf      	push	Y
    7e56:	7219      	lod	A, [S-26]
    7e58:	1797      	call	0x7d88 <_SetupDiagResponse>
					g_NvramUser.NAD = pDiag->byD5;
    7e5a:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x7>
    7e5c:	4158      	mov	dp:0x58 <_g_NvramUser+0x2>, AL
					g_u8NAD = g_NvramUser.NAD;
    7e5e:	42d8 002f 	mov	0x2f <_g_u8NAD>, AL
					/* Store NVRAM */
					if ( (NVRAM_Store( (uint16) C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.NAD == pDiag->byD5) )
    7e62:	7003      	lod	A, #3
    7e64:	82db 98f8 	callf	0x98f8 <_NVRAM_Store>
    7e68:	5c03      	dec	S, #4
    7e6a:	ac00      	cmp	A, #0
    7e6c:	1d0a      	jne	0x7e82 <_HandleDfrDiag+0x90>
    7e6e:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x7>
    7e70:	8d58      	cmp	AL, dp:0x58 <_g_NvramUser+0x2>
    7e72:	1d07      	jne	0x7e82 <_HandleDfrDiag+0x90>
					{
						/* NAD changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    7e74:	54ca 0000 	pushw	#0
    7e78:	613a      	lod	AL, dp:0x3a <__data_dp_end+0x2>
    7e7a:	5cf2      	usex	A
    7e7c:	52df      	push	A
    7e7e:	7219      	lod	A, [S-26]
    7e80:	020f      	jmp	0x82a0 <_HandleDfrDiag+0x4ae>
					}
					else
					{
						/* NAD couldn't be changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);		/* Status = Negative feedback */
    7e82:	54ca 0012 	pushw	#18
    7e86:	613a      	lod	AL, dp:0x3a <__data_dp_end+0x2>
    7e88:	5cf2      	usex	A
    7e8a:	52df      	push	A
    7e8c:	7219      	lod	A, [S-26]
    7e8e:	177c      	call	0x7d88 <_SetupDiagResponse>
						SetLastError( (uint8) C_ERR_LIN2X_B0);
    7e90:	72da 00b0 	lod	A, #176
    7e94:	82db 89e6 	callf	0x89e6 <_SetLastError>
    7e98:	5c03      	dec	S, #4
    7e9a:	541d      	ret	#30
					SetLastError( (uint8) C_ERR_LIN2X_B1);
				}
			}
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else if ( u16DiagPCI_SID == C_PCI_SID_READ_BY_ID )
    7e9c:	eeda 06b2 	cmp	Y, #1714
    7ea0:	1901      	je	0x7ea4 <_HandleDfrDiag+0xb2>
    7ea2:	0042      	jmp	0x7f28 <_HandleDfrDiag+0x136>
			 * (0x40-0xFF: Reserved)
			 * (M) = Mandatory
			 * (O) = Optional
			 * (U) = User defined
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD2) | ((uint16)(pDiag->byD3) << 8), (pDiag->byD4) | ((uint16)(pDiag->byD5) << 8)) )
    7ea4:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x6>
    7ea6:	5cf2      	usex	A
    7ea8:	7ee2      	lod	X, A
    7eaa:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x7>
    7eac:	6000      	lod	AL, #0
    7eae:	26e2      	or	X, A
    7eb0:	693d      	lod	AH, dp:0x3d <__data_dp_end+0x5>
    7eb2:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x4>
    7eb4:	5edf      	push	X
    7eb6:	178d      	call	0x7dd2 <_ValidSupplierFunctionID>
    7eb8:	5c01      	dec	S, #2
    7eba:	ac00      	cmp	A, #0
    7ebc:	192b      	je	0x7f14 <_HandleDfrDiag+0x122>
			{
				if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    7ebe:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
    7ec0:	1d0d      	jne	0x7edc <_HandleDfrDiag+0xea>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xF2 | Supplier | Supplier | Function | Function |  Variant |
					 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    7ec2:	621b      	lod	AL, [S-28]
    7ec4:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
    7ec6:	6006      	lod	AL, #6
    7ec8:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7eca:	60f2      	lod	AL, #-14
    7ecc:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
    7ece:	60b0      	lod	AL, #-80
    7ed0:	4147      	mov	dp:0x47 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7ed2:	72da 0124 	lod	A, #292
    7ed6:	7ada 00b0 	lod	Y, #176
    7eda:	000a      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
					StoreD1to4( C_SUPPLIER_ID, C_FUNCTION_ID);					/* Supplier & Function-ID */
				}
				else if ( pDiag->byD1 == C_SERIAL_NR_ID )
    7edc:	8c01      	cmp	AL, #1
    7ede:	1d0f      	jne	0x7efe <_HandleDfrDiag+0x10c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x05| 0xF2 | SerialNr | SerialNr | SerialNr | SerialNr | Reserved |
					 *	|     |     |      |   (LSB)  |		     |          |   (MSB)  |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    7ee0:	661b      	lod	YL, [S-28]
    7ee2:	4540      	mov	dp:0x40 <_g_DiagResponse>, YL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
    7ee4:	6005      	lod	AL, #5
    7ee6:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7ee8:	60f2      	lod	AL, #-14
    7eea:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7eec:	7162      	lod	A, dp:0x62 <_g_NvramUser+0xc>
    7eee:	7964      	lod	Y, dp:0x64 <_g_NvramUser+0xe>
	__asm__ __volatile__
    7ef0:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
    7ef2:	4944      	mov	dp:0x44 <_g_DiagResponse+0x4>, AH
    7ef4:	4545      	mov	dp:0x45 <_g_DiagResponse+0x5>, YL
    7ef6:	4d46      	mov	dp:0x46 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    7ef8:	6007      	lod	AL, #7
    7efa:	412c      	mov	dp:0x2c <_g_u8BufferOutID>, AL
    7efc:	541d      	ret	#30
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
					StoreD1to4( g_NvramUser.SerialNumberLSW, g_NvramUser.SerialNumberMSW);	/* Serial-number */
				}
#if (LINPROT == LIN2J_VALVE_VW)
				else if ( pDiag->byD1 == (uint8) C_SVN_ID )
    7efe:	8c30      	cmp	AL, #48
    7f00:	1d09      	jne	0x7f14 <_HandleDfrDiag+0x122>
				{
					g_DiagResponse.byNAD = g_u8NAD;
    7f02:	621b      	lod	AL, [S-28]
    7f04:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
    7f06:	6005      	lod	AL, #5
    7f08:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7f0a:	60f2      	lod	AL, #-14
    7f0c:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7f0e:	7004      	lod	A, #4
    7f10:	78ff      	lod	Y, #-1
    7f12:	07ee      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
				}
			}
			else
			{
				/* Invalid vendor/Function ID (MMP170329-1) */
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    7f14:	621b      	lod	AL, [S-28]
    7f16:	5cf2      	usex	A
    7f18:	54ca 0012 	pushw	#18
    7f1c:	7a1b      	lod	Y, [S-28]
    7f1e:	5adf      	push	Y
    7f20:	1733      	call	0x7d88 <_SetupDiagResponse>
				SetLastError( (uint8) C_ERR_LIN2X_B2);
    7f22:	72da 00b2 	lod	A, #178
    7f26:	07b6      	jmp	0x7e94 <_HandleDfrDiag+0xa2>
				SetLastError( (uint8) C_ERR_LIN2X_CB);
			}
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
		else if ( u16DiagPCI_SID == C_SID_PCI_RESET )	/* Targeted or Broadcast reset */
    7f28:	eeda 01b5 	cmp	Y, #437
    7f2c:	1d0a      	jne	0x7f42 <_HandleDfrDiag+0x150>
		{
			/* Reset Target */
			MLX4_RESET();														/* Reset the Mlx4   */
    7f2e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7f32:	94fe      	and	AL, #-2
    7f34:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    7f38:	72da 3072 	lod	A, #12402
    7f3c:	52d8 02ac 	mov	0x2ac <_bistResetInfo>, A
    7f40:	0132      	jmp	0x81a6 <_HandleDfrDiag+0x3b4>
			MLX16_RESET();														/* Reset the Mlx16  */
			/* This reset restart the chip as POR, and doesn't come back (no answer) */
		}
#endif /* ((LINPROT & LINXX) == LIN2J) */
#if _SUPPORT_MLX_DEBUG_MODE
		else if ( pDiag->bySID == C_SID_MLX_DEBUG )
    7f42:	6217      	lod	AL, [S-24]
    7f44:	8cdb      	cmp	AL, #-37
    7f46:	1901      	je	0x7f4a <_HandleDfrDiag+0x158>
    7f48:	01ad      	jmp	0x82a4 <_HandleDfrDiag+0x4b2>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| Debug| Supplier | Supplier | Param #1 | Param #2 | Function |
			 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |    ID    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			uint16 u16SupplierID = (((uint16) pDiag->byD2) << 8) | ((uint16) pDiag->byD1);
    7f4a:	693c      	lod	AH, dp:0x3c <__data_dp_end+0x4>
    7f4c:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
			if ( u16SupplierID == C_SUPPLIER_ID )
    7f4e:	aeda 0124 	cmp	A, #292
    7f52:	1901      	je	0x7f56 <_HandleDfrDiag+0x164>
    7f54:	019f      	jmp	0x8294 <_HandleDfrDiag+0x4a2>
			{
				/* Reply diagnostics response with NAD, length and RSID.*/
				g_DiagResponse.byNAD = g_u8NAD;
    7f56:	661b      	lod	YL, [S-28]
    7f58:	4540      	mov	dp:0x40 <_g_DiagResponse>, YL
				g_DiagResponse.byPCI = 0x06U;
    7f5a:	6006      	lod	AL, #6
    7f5c:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
    7f5e:	6217      	lod	AL, [S-24]
    7f60:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
				 * 0xF8: NVRAM Clear function
				 * 0xFC: Clear Fatal-handler error logging
				 * 0xFD: Get I/O-register value (16-bits)
				 * 0xFE: Get Fatal-error: error-code, info and address
				 */
				if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT )
    7f62:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x7>
    7f64:	4213      	mov	[S-20], AL
    7f66:	1d07      	jne	0x7f76 <_HandleDfrDiag+0x184>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  |MLX DBG[i]|MLX DBG[i]| Reserved | Reserved |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0FU);
    7f68:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    7f6a:	b40f      	and	A, #15
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7f6c:	4422      	asl	A
    7f6e:	7ae2      	lod	Y, A
    7f70:	e2da a0c0 	add	Y, #41152
    7f74:	00ad      	jmp	0x80d0 <_HandleDfrDiag+0x2de>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0FU);
					StoreD1to2( tMlxDbgSupport[u16Index]);
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_STALLDET )
    7f76:	6213      	lod	AL, [S-20]
    7f78:	8c5d      	cmp	AL, #93
    7f7a:	1d30      	jne	0x7fdc <_HandleDfrDiag+0x1ea>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    7f7c:	72d8 0212 	lod	A, 0x212 <_l_u16MotorCurrentStallThrshldxN>
    7f80:	44b2      	lsr	A, #2
    7f82:	44b2      	lsr	A, #2
    7f84:	44b2      	lsr	A, #2
    7f86:	7ed8 011e 	lod	X, 0x11e <_g_u16MCurrgain>
    uint32 result;

    __asm__ __volatile__ (
    7f8a:	4803      	mulu	D, A, X
    7f8c:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    7f8e:	4c22 0040 	add	YA, #64
    7f92:	0000 
    7f94:	48a6      	lsr	YA, #7
					 *	| NAD | 0x06| 0xDB |Stallcurrent|Stallcurrent|Motorcurrent|Motorcurrent|StallFlags|
					 *	|     |     |      |Thrshld(LSB)|Thrshld(LSB)|MovAvg (LSB)|MovAvg (MSB)|          |
					 *	+-----+-----+------+------------+------------+------------+------------+----------+
					 */
					uint16 u16Value = (uint16) ((mulU32_U16byU16( (l_u16MotorCurrentStallThrshldxN >> C_MOVAVG_SSZ), g_u16MCurrgain) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Stall motor-current threshold [mA] */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFFU);
    7f96:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
					g_DiagResponse.byD2 = (uint8) (u16Value >> 8);
    7f98:	4944      	mov	dp:0x44 <_g_DiagResponse+0x4>, AH
    7f9a:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    7f9c:	44b2      	lsr	A, #2
    7f9e:	44b2      	lsr	A, #2
    7fa0:	44b2      	lsr	A, #2
    uint32 result;

    __asm__ __volatile__ (
    7fa2:	4803      	mulu	D, A, X
    7fa4:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    7fa6:	4c22 0040 	add	YA, #64
    7faa:	0000 
    7fac:	48a6      	lsr	YA, #7
					u16Value = (uint16) ((mulU32_U16byU16( (g_u16MotorCurrentMovAvgxN >> C_MOVAVG_SSZ), g_u16MCurrgain) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Moving average-motor current [mA] */
					g_DiagResponse.byD3 = (uint8) (u16Value & 0xFFU);
    7fae:	4145      	mov	dp:0x45 <_g_DiagResponse+0x5>, AL
					g_DiagResponse.byD4 = (uint8) (u16Value >> 8);
    7fb0:	4946      	mov	dp:0x46 <_g_DiagResponse+0x6>, AH
#if _SUPPORT_STALLDET_O
					if ( g_u8StallTypeComm & C_STALL_FOUND_O )
    7fb2:	611a      	lod	AL, dp:0x1a <_g_u8StallTypeComm>
    7fb4:	7ae2      	lod	Y, A
    7fb6:	f408      	and	Y, #8
    7fb8:	9478      	and	AL, #120
    7fba:	4207      	mov	[S-8], AL
    7fbc:	61e9      	lod	AL, dp:0xe9 <_g_e8StallDetectorEna>
    7fbe:	4206      	mov	[S-7], AL
    7fc0:	ec00      	cmp	Y, #0
    7fc2:	1902      	je	0x7fc8 <_HandleDfrDiag+0x1d6>
					{
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountO & 0x07U);	/* Stall detection & count */
    7fc4:	6136      	lod	AL, dp:0x36 <_l_u8StallCountO>
    7fc6:	0001      	jmp	0x7fca <_HandleDfrDiag+0x1d8>
					}
					else
#endif /* _SUPPORT_STALLDET_O */
					{
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountA & 0x07U);	/* Stall detection & count */
    7fc8:	6137      	lod	AL, dp:0x37 <_l_u8StallCountA>
    7fca:	9407      	and	AL, #7
    7fcc:	8607      	or	AL, [S-8]
    7fce:	4147      	mov	dp:0x47 <_g_DiagResponse+0x7>, AL
					}
					if ( g_e8StallDetectorEna != C_STALLDET_NONE )
    7fd0:	6206      	lod	AL, [S-7]
    7fd2:	1d01      	jne	0x7fd6 <_HandleDfrDiag+0x1e4>
    7fd4:	0791      	jmp	0x7ef8 <_HandleDfrDiag+0x106>
					{
						g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;
    7fd6:	6400      	lod	YL, #0
    7fd8:	451a      	mov	dp:0x1a <_g_u8StallTypeComm>, YL
    7fda:	078e      	jmp	0x7ef8 <_HandleDfrDiag+0x106>
					}
					StoreD2to5( pu16CMDM[0], pu16CMDM[1]); /*lint !e415 */
				}
#endif /* (LIN_AA_SCREENTEST != FALSE) */
#endif /* _SUPPORT_LIN_AA && (LIN_AA_INFO != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APPLSTATE )
    7fdc:	6213      	lod	AL, [S-20]
    7fde:	8ca5      	cmp	AL, #-91
    7fe0:	1d20      	jne	0x8022 <_HandleDfrDiag+0x230>
					 *	bit 5: Emergency Run occurred
					 *	bit 4: Over-temperature
					 *  bit 3:2: Voltage (In-range, UV and OV)
					 *  bit 1:0: Electric Error (Ok, Error, Permanent)
					 */
					g_DiagResponse.byD1 = g_e8MotorStatusMode;
    7fe2:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    7fe4:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
					{
						uint16 u16CopyPosition = g_u16ActualPosition;
    7fe6:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
						g_DiagResponse.byD2 = (uint8) (u16CopyPosition & 0xFFU);
    7fe8:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
						g_DiagResponse.byD3 = (uint8) (u16CopyPosition >> 8);
    7fea:	4945      	mov	dp:0x45 <_g_DiagResponse+0x5>, AH
					}
					g_DiagResponse.byD4 = (g_e8MotorRequest & 0x0F);
    7fec:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    7fee:	940f      	and	AL, #15
    7ff0:	4146      	mov	dp:0x46 <_g_DiagResponse+0x6>, AL
					{
						uint8 u8D5 = ((g_e8ErrorVoltage & 0x03U) << 2) | (g_e8ErrorElectric & 0x03U);
    7ff2:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    7ff4:	9403      	and	AL, #3
    7ff6:	44a0      	asl	AL, #2
    7ff8:	4211      	mov	[S-18], AL
    7ffa:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    7ffc:	9403      	and	AL, #3
    7ffe:	8611      	or	AL, [S-18]
    8000:	66e0      	lod	YL, AL
    8002:	5cf6      	usex	Y
						if ( g_e8ErrorOverTemperature != FALSE )
    8004:	6124      	lod	AL, dp:0x24 <_g_e8ErrorOverTemperature>
    8006:	1901      	je	0x800a <_HandleDfrDiag+0x218>
						{
							u8D5 |= 0x10U;
    8008:	e410      	or	Y, #16
						}
						if ( g_u8EmergencyRunOcc != FALSE )
    800a:	6125      	lod	AL, dp:0x25 <_g_u8EmergencyRunOcc>
    800c:	1901      	je	0x8010 <_HandleDfrDiag+0x21e>
						{
							u8D5 |= 0x20U;
    800e:	e420      	or	Y, #32
						}
						if ( g_u8StallOcc != FALSE )
    8010:	6126      	lod	AL, dp:0x26 <_g_u8StallOcc>
    8012:	1901      	je	0x8016 <_HandleDfrDiag+0x224>
						{
							u8D5 |= 0x40U;
    8014:	e440      	or	Y, #64
						}
						if (g_u8ChipResetOcc != FALSE)
    8016:	6127      	lod	AL, dp:0x27 <_g_u8ChipResetOcc>
    8018:	1902      	je	0x801e <_HandleDfrDiag+0x22c>
						{
							u8D5 |= 0x80U;
    801a:	e6da 0080 	or	Y, #128
						}
						g_DiagResponse.byD5 = u8D5;
    801e:	4547      	mov	dp:0x47 <_g_DiagResponse+0x7>, YL
    8020:	076b      	jmp	0x7ef8 <_HandleDfrDiag+0x106>
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK
					g_u8Mlx4ErrorState = C_MLX4_STATE_IMMEDIATE_RST;			/* Reset MLX4 too */
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK */
				}
#endif /* (_SUPPORT_AUTO_BAUDRATE != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_ADC_RAW )
    8022:	6213      	lod	AL, [S-20]
    8024:	8cac      	cmp	AL, #-84
    8026:	1d06      	jne	0x8034 <_HandleDfrDiag+0x242>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8028:	1376      	call	0x8716 <_GetRawTemperature>
    802a:	520f      	mov	[S-16], A
    802c:	130d      	call	0x8648 <_GetRawChipSupply>
    802e:	7ae2      	lod	Y, A
	__asm__ __volatile__
    8030:	720f      	lod	A, [S-16]
    8032:	075e      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					 *	|     |     |      |   (LSB)   |   (MSB)   |  (LSB)  |  (MSB)  |          |
					 *	+-----+-----+------+-----------+-----------+---------+---------+----------+
					 */
					StoreD1to4( GetRawTemperature(), GetRawChipSupply());
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_AMBJENV )
    8034:	6213      	lod	AL, [S-20]
    8036:	8cae      	cmp	AL, #-82
    8038:	1d06      	jne	0x8046 <_HandleDfrDiag+0x254>
					 *	| NAD | 0x06| 0xDB | Ambj-Temp|Motor-volt|Motor-volt| Reserved | Reserved |
					 *	|     |     |      |          |  (LSB)   |   (MSB)  |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
#if _SUPPORT_AMBIENT_TEMP
					uint16 u16Value = (uint16) (g_i16AmbjTemperature + C_TEMPOFF);				/* Ambient Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
    803a:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    803c:	a03c      	add	A, #60
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFFU);
    803e:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8040:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    8042:	78ff      	lod	Y, #-1
    8044:	018e      	jmp	0x8362 <_HandleDfrDiag+0x570>
					StoreD2to5( (uint16) g_i16MotorVoltage, (uint16) g_i16PhaseVoltage);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					StoreD2to5( (uint16) g_i16MotorVoltage, 0xFFFFU);
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX16_CLK )
    8046:	6213      	lod	AL, [S-20]
    8048:	8cc0      	cmp	AL, #-64
    804a:	1d30      	jne	0x80ac <_HandleDfrDiag+0x2ba>
    804c:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    8050:	5ce2      	ssex	A
    8052:	a2da 0800 	add	A, #2048
    8056:	5201      	mov	[S-2], A
    8058:	7ada 03e8 	lod	Y, #1000
    805c:	7eda 0800 	lod	X, #2048
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8060:	4821      	mulu	YA, A, Y
    8062:	4c63      	divu	YA, X
    8064:	4c63      	divu	YA, X
    8066:	520d      	mov	[S-14], A
					 *	| NAD | 0x06| 0xDB |MLX16Clock|MLX16Clock| Reserved | Reserved | Reserved |
					 *	|     |     |      |[kHz](LSB)|[kHz](MSB)|   0xFF   |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16RC_Clock = muldivU16_U16byU16byU16( (2048U + EE_OCLOCK), 1000U, 2048U);
					int16 i16ADC_Temp = (int16) (GetRawTemperature() - EE_OTEMP);
    8068:	1356      	call	0x8716 <_GetRawTemperature>
    806a:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    806e:	aae6      	sub	A, Y
    8070:	7ae2      	lod	Y, A
					int16 i16Coef;
					if ( i16ADC_Temp <= 0 )
    8072:	ac00      	cmp	A, #0
    8074:	1f05      	jsg	0x8080 <_HandleDfrDiag+0x28e>
					{
						/* ((dTemp * Gp) * 1000)/131072 --> ((dTemp * Gp) * 125)/16384 */
						i16Coef = EE_GPCLOCK;
    8076:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    807a:	62e4      	lod	AL, AH
    807c:	5ce2      	ssex	A
    807e:	0003      	jmp	0x8086 <_HandleDfrDiag+0x294>
					}
					else
					{
						/* ((dTemp * Gn) * 1000)/131072 --> ((dTemp * Gn) * 125)/16384 */
						i16Coef = EE_GNCLOCK;
    8080:	72d8 11c6 	lod	A, 0x11c6 <__ep__+0x1c6>
    8084:	5ce2      	ssex	A
					}
					i16Coef = (125 * i16Coef);
    8086:	4872 007d 	muls	A, A, #125
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    808a:	7eda 4000 	lod	X, #16384
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    808e:	4831      	muls	YA, A, Y
    8090:	4c73      	divs	YA, X
    8092:	4c73      	divs	YA, X
    8094:	4c7b      	dadjs	YA, X
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    8096:	7a0d      	lod	Y, [S-14]
    8098:	e2e2      	add	Y, A
    809a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    809e:	6000      	lod	AL, #0
    80a0:	72e4      	swap	A
    80a2:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    80a4:	4801      	mulu	D, A, Y
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    80a6:	4881      	lsr	D, #2
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
	__asm__ __volatile__
    80a8:	4c88      	mov	A, DL
    80aa:	0013      	jmp	0x80d2 <_HandleDfrDiag+0x2e0>
					}
					i16Coef = (125 * i16Coef);
					u16RC_Clock += muldivI16_I16byI16byI16( i16ADC_Temp, i16Coef, 16384);
					StoreD1to2( (uint16) (mulU32_U16byU16( u16RC_Clock, ((PLL_CTRL >> 8) + 1U)) >> 2));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPID )
    80ac:	6213      	lod	AL, [S-20]
    80ae:	8cc1      	cmp	AL, #-63
    80b0:	1d08      	jne	0x80c2 <_HandleDfrDiag+0x2d0>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x02U);
    80b2:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    80b4:	b402      	and	A, #2
					g_DiagResponse.byD1 = (uint8) u16Index;
    80b6:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLX_CHIPID) + u16Index;			/* NVRAM 16-bit pointer */
    80b8:	4422      	asl	A
    80ba:	7ae2      	lod	Y, A
    80bc:	e2da 1188 	add	Y, #4488
    80c0:	014e      	jmp	0x835e <_HandleDfrDiag+0x56c>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_HWSWID )
    80c2:	6213      	lod	AL, [S-20]
    80c4:	8cc2      	cmp	AL, #-62
    80c6:	1d08      	jne	0x80d8 <_HandleDfrDiag+0x2e6>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | HW/SW ID | HW/SW ID | CPU-Clock| Reserved | Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |          |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
    80c8:	6070      	lod	AL, #112
    80ca:	4145      	mov	dp:0x45 <_g_DiagResponse+0x5>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    80cc:	7ada 1182 	lod	Y, #4482
    80d0:	72f0      	lod	A, [Y]
	__asm__ __volatile__
    80d2:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
    80d4:	4944      	mov	dp:0x44 <_g_DiagResponse+0x4>, AH
    80d6:	0710      	jmp	0x7ef8 <_HandleDfrDiag+0x106>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
					StoreD1to2( *((uint16 *) C_ADDR_MLX_HWSWID));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT_OPTIONS )
    80d8:	6213      	lod	AL, [S-20]
    80da:	8cc6      	cmp	AL, #-58
    80dc:	1d0a      	jne	0x80f2 <_HandleDfrDiag+0x300>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | SUPPORT  | SUPPORT  |  SUPPORT |  SUPPORT | Reserved |
					 *	|     |     |      |   (LSB)  |          |          |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD1 = (uint8) (C_DIAG_RES
    80de:	6004      	lod	AL, #4
    80e0:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
#endif /* _SUPPORT_MLX16_HALT */
#if _SUPPORT_CHIP_TEMP_PROFILE
													& ~(1U << 7)				/* bit 7: Chip temperature profile check (dT/dt) support */
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */
																);
					g_DiagResponse.byD2 = (uint8) (C_DIAG_RES
    80e2:	60f9      	lod	AL, #-7
    80e4:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
#endif /* _SUPPORT_LINNETWORK_LOADER */
#if _SUPPORT_BUSTIMEOUT_SLEEP
													& ~(1U << 3)				/* bit 3: Bus-time-out to sleep support */
#endif /* _SUPPORT_BUSTIMEOUT_SLEEP */
																);
					g_DiagResponse.byD3 = (uint8) (C_DIAG_RES
    80e6:	6045      	lod	AL, #69
    80e8:	4145      	mov	dp:0x45 <_g_DiagResponse+0x5>, AL
#endif /* _SUPPORT_PHASE_SHORT_DET */
#if _SUPPORT_STALLDET_O
													& ~(1U << 7)				/* bit 7: Current-oscillation stall-detection support */
#endif /* _SUPPORT_STALLDET_O */
																);
					g_DiagResponse.byD4 = (uint8) (C_DIAG_RES
    80ea:	60f4      	lod	AL, #-12
    80ec:	4146      	mov	dp:0x46 <_g_DiagResponse+0x6>, AL
#endif /* (defined __MLX81315_A__) && _SUPPORT_QUADRUPLE_MOTOR_CURRENT */
#if _SUPPORT_DOUBLE_USTEP
													& ~(1U << 3)				/* bit 3: Double uStep support */
#endif /* _SUPPORT_DOUBLE_USTEP */
																);
					g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    80ee:	60ff      	lod	AL, #-1
    80f0:	00eb      	jmp	0x82c8 <_HandleDfrDiag+0x4d6>
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX4_VERSION )
    80f2:	6213      	lod	AL, [S-20]
    80f4:	8cc7      	cmp	AL, #-57
    80f6:	1d07      	jne	0x8106 <_HandleDfrDiag+0x314>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    80f8:	7ada 4018 	lod	Y, #16408
    80fc:	72f0      	lod	A, [Y]
    80fe:	7ada 401a 	lod	Y, #16410
    8102:	7af0      	lod	Y, [Y]
    8104:	06f5      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( *((uint16 *) 0x4018U), *((uint16 *) 0x401AU));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_PLTF_VERSION )
    8106:	6213      	lod	AL, [S-20]
    8108:	8cc8      	cmp	AL, #-56
    810a:	1d04      	jne	0x8114 <_HandleDfrDiag+0x322>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    810c:	72da 0104 	lod	A, #260
    8110:	7800      	lod	Y, #0
    8112:	06ee      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( (__MLX_PLTF_VERSION_MAJOR__ | (__MLX_PLTF_VERSION_MINOR__ << 8)),
								(__MLX_PLTF_VERSION_REVISION__ | (__MLX_PLTF_VERSION_CUSTOMER_BUILD__ << 8)));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APP_VERSION )
    8114:	6213      	lod	AL, [S-20]
    8116:	8cc9      	cmp	AL, #-55
    8118:	1d15      	jne	0x8144 <_HandleDfrDiag+0x352>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Appl ver | Appl ver | Appl ver | Appl ver | Appl ver |
					 *	|     |     |      |  (Major) |  (Minor) | (Rev LSB)| (Rev MSB)|   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					if ( pDiag->byD3 == 0U )
    811a:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    811c:	1d04      	jne	0x8126 <_HandleDfrDiag+0x334>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    811e:	7001      	lod	A, #1
    8120:	7ada e004 	lod	Y, #57348
    8124:	06e5      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					 */
					if ( pDiag->byD3 == 0U )
					{
						StoreD1to4( (__APP_VERSION_MAJOR__ | (__APP_VERSION_MINOR__ << 8)), __APP_VERSION_REVISION__);
					}
					else if ( pDiag->byD3 == 1U )
    8126:	8c01      	cmp	AL, #1
    8128:	1d05      	jne	0x8134 <_HandleDfrDiag+0x342>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    812a:	72d8 bf50 	lod	A, 0xbf50 <_product_id>
    812e:	7ad8 bf52 	lod	Y, 0xbf52 <_product_id+0x2>
    8132:	06de      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					}
					else if ( pDiag->byD3 == 1U )
					{
						StoreD1to4( *((uint16 *) &product_id[0]), *((uint16 *) &product_id[2]));
					}
					else if ( pDiag->byD3 == 2U )
    8134:	8c02      	cmp	AL, #2
    8136:	1901      	je	0x813a <_HandleDfrDiag+0x348>
    8138:	0138      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    813a:	72d8 bf54 	lod	A, 0xbf54 <_product_id+0x4>
    813e:	7ad8 bf56 	lod	Y, 0xbf56 <_product_id+0x6>
    8142:	06d6      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					else
					{
						/* Nothing */
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPAGE )
    8144:	6213      	lod	AL, [S-20]
    8146:	8cca      	cmp	AL, #-54
    8148:	1d08      	jne	0x815a <_HandleDfrDiag+0x368>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x3EU);
    814a:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    814c:	b43e      	and	A, #62
					g_DiagResponse.byD1 = (uint8) u16Index;
    814e:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLXF_PAGE) + u16Index;			/* NVRAM 16-bit pointer */
    8150:	4422      	asl	A
    8152:	7ae2      	lod	Y, A
    8154:	e2da 1180 	add	Y, #4480
    8158:	0102      	jmp	0x835e <_HandleDfrDiag+0x56c>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPID )
    815a:	6213      	lod	AL, [S-20]
    815c:	8ccb      	cmp	AL, #-53
    815e:	1d04      	jne	0x8168 <_HandleDfrDiag+0x376>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8160:	72d8 0294 	lod	A, 0x294 <_g_u16PidCtrlRatio>
    8164:	79c6      	lod	Y, dp:0xc6 <_g_u16PID_I>
    8166:	00fd      	jmp	0x8362 <_HandleDfrDiag+0x570>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					NVRAM_ClearErrorLog();
				}
#endif /* _SUPPORT_LOG_NVRAM */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPENV )
    8168:	6213      	lod	AL, [S-20]
    816a:	8cce      	cmp	AL, #-50
    816c:	1d08      	jne	0x817e <_HandleDfrDiag+0x38c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Chip-Temp|  Current |  Current |  Voltage |  Voltage |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
    816e:	7120      	lod	A, dp:0x20 <__data_dp_size>
    8170:	a03c      	add	A, #60
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFFU);
    8172:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8174:	72d8 0106 	lod	A, 0x106 <_g_i16Current>
    8178:	7ad8 010a 	lod	Y, 0x10a <_g_i16SupplyVoltage>
    817c:	00f2      	jmp	0x8362 <_HandleDfrDiag+0x570>
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFFU);
					StoreD2to5( (uint16) g_i16Current, (uint16) g_i16SupplyVoltage); /* Motor driver current [mA] & Supply voltage [10mV] */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FUNC )
    817e:	6213      	lod	AL, [S-20]
    8180:	8ccf      	cmp	AL, #-49
    8182:	1d14      	jne	0x81ac <_HandleDfrDiag+0x3ba>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | Function | Function |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xCF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint16 u16FunctionID = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8184:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x6>
    8186:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>

					if ( u16FunctionID == C_DBG_DBGFUNC_RESET )
    8188:	aeda 4a74 	cmp	A, #19060
    818c:	1901      	je	0x8190 <_HandleDfrDiag+0x39e>
    818e:	010d      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
					{
						/* Function ID = Chip reset */
						(void) mlu_ApplicationStop();
    8190:	82db 778e 	callf	0x778e <_mlu_ApplicationStop>
						MLX4_RESET();											/* Reset the Mlx4   */
    8194:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8198:	94fe      	and	AL, #-2
    819a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
						bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    819e:	7ada 3072 	lod	Y, #12402
    81a2:	5ad8 02ac 	mov	0x2ac <_bistResetInfo>, Y
						MLX16_RESET();											/* Reset the Mlx16  */
    81a6:	82db 59dc 	callf	0x59dc <_MLX16_RESET>
    81aa:	541d      	ret	#30
					}
				}
				else if ( (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_SET_ANAOUTA) && (pDiag->byD5 <= (uint8) C_DBG_SUBFUNC_SET_ANAOUTH) )
    81ac:	6213      	lod	AL, [S-20]
    81ae:	8030      	add	AL, #48
    81b0:	8c07      	cmp	AL, #7
    81b2:	1e15      	jug	0x81de <_HandleDfrDiag+0x3ec>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| Debug| Supplier | Supplier |   Value  |   Value  |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |   (LSB)  |   (MSB)  | 0xD0-0xD7|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 *pu16IoReg = (uint16*) au16AnaOutRegs[pDiag->byD5 & 0x07U];
    81b4:	6213      	lod	AL, [S-20]
    81b6:	b407      	and	A, #7
    81b8:	4422      	asl	A
    81ba:	7ae2      	lod	Y, A
    81bc:	e2da a0e0 	add	Y, #41184
    81c0:	7ef0      	lod	X, [Y]
					CONTROL |= (OUTA_WE | OUTB_WE | OUTC_WE);					/* Grant access to ANA_OUTx registers */
    81c2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    81c6:	8438      	or	AL, #56
    81c8:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
					*pu16IoReg = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    81cc:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x6>
    81ce:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    81d0:	52f8      	mov	[X], A
					CONTROL &= ~(OUTA_WE | OUTB_WE | OUTC_WE);
    81d2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    81d6:	94c7      	and	AL, #-57
    81d8:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    81dc:	541d      	ret	#30
					{
						/* Nothing */
					}
				}
#endif /* _DEBUG_MOTOR_CURRENT_FLT */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FILLNVRAM )
    81de:	6213      	lod	AL, [S-20]
    81e0:	8cf8      	cmp	AL, #-8
    81e2:	1901      	je	0x81e6 <_HandleDfrDiag+0x3f4>
    81e4:	0035      	jmp	0x8250 <_HandleDfrDiag+0x45e>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | NVRAM ID |  Pattern |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |   0xF8   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint8 u8NvramID = pDiag->byD3;
    81e6:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    81e8:	5cf2      	usex	A
    81ea:	520b      	mov	[S-12], A
					uint16 u16Pattern = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD4);
    81ec:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x6>
    81ee:	5cf2      	usex	A
    81f0:	7ae2      	lod	Y, A
    81f2:	6c00      	lod	YH, #0
    81f4:	7ae8      	swap	Y
    81f6:	a6e6      	or	A, Y
    81f8:	5209      	mov	[S-10], A
					if ( (u8NvramID & 0x01U) != 0U )
    81fa:	720b      	lod	A, [S-12]
    81fc:	b401      	and	A, #1
    81fe:	1909      	je	0x8212 <_HandleDfrDiag+0x420>
					{
						/* Fill NVRAM #1, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE1_ADDRESS);
    8200:	7ada 1000 	lod	Y, #4096
    8204:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    8206:	7209      	lod	A, [S-10]
    8208:	52d6      	mov	[Y++], A
    820a:	1bfd      	djnz	X, 0x8206 <_HandleDfrDiag+0x414>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE1);
    820c:	7000      	lod	A, #0
    820e:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>
					}
					if ( (u8NvramID & 0x02) != 0U )
    8212:	720b      	lod	A, [S-12]
    8214:	b402      	and	A, #2
    8216:	1909      	je	0x822a <_HandleDfrDiag+0x438>
					{
						/* Fill NVRAM #1, 2 (Don't overwrite the NVRAM1 trim value) */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE2_ADDRESS);
    8218:	7ada 1080 	lod	Y, #4224
    821c:	7c3e      	lod	X, #62
						do
						{
							*pu16NvramData++ = u16Pattern;
    821e:	7209      	lod	A, [S-10]
    8220:	52d6      	mov	[Y++], A
    8222:	1bfd      	djnz	X, 0x821e <_HandleDfrDiag+0x42c>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE2_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE2);
    8224:	7001      	lod	A, #1
    8226:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>
					}
					if ( (u8NvramID & 0x04U) != 0U )
    822a:	720b      	lod	A, [S-12]
    822c:	b404      	and	A, #4
    822e:	1909      	je	0x8242 <_HandleDfrDiag+0x450>
					{
						/* Fill NVRAM #2, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM2_PAGE1_ADDRESS);
    8230:	7ada 1100 	lod	Y, #4352
    8234:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    8236:	7209      	lod	A, [S-10]
    8238:	52d6      	mov	[Y++], A
    823a:	1bfd      	djnz	X, 0x8236 <_HandleDfrDiag+0x444>
						} while (pu16NvramData < (uint16 *) END_NVRAM2_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM2_PAGE1);
    823c:	7002      	lod	A, #2
    823e:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>
					}
					if ( (u8NvramID & 0x80U) != 0U )
    8242:	620b      	lod	AL, [S-12]
    8244:	8c00      	cmp	AL, #0
    8246:	1a81      	jsl	0x824a <_HandleDfrDiag+0x458>
    8248:	00b0      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
					{
						NVRAM_LoadUserPage();
    824a:	82db 9a02 	callf	0x9a02 <_NVRAM_LoadUserPage>
    824e:	541d      	ret	#30
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_GET_IO_REG )
    8250:	6213      	lod	AL, [S-20]
    8252:	8cfd      	cmp	AL, #-3
    8254:	1901      	je	0x8258 <_HandleDfrDiag+0x466>
    8256:	00a9      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |  I/O-reg |  I/O-reg | I/O-value| I/O-value| Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |  (0xFF)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16IoAddress = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8258:	6d3e      	lod	YH, dp:0x3e <__data_dp_end+0x6>
    825a:	6400      	lod	YL, #0
    825c:	7ee6      	lod	X, Y
    825e:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x5>
    8260:	5cf2      	usex	A
    8262:	26e2      	or	X, A
					if ( ((u16IoAddress >= 0x2000U) && (u16IoAddress <= 0x2056U)) ||	/* System I/O */
    8264:	72ee      	lod	A, X
    8266:	a2da e000 	add	A, #57344
    826a:	ac56      	cmp	A, #86
    826c:	1a10      	jule	0x828e <_HandleDfrDiag+0x49c>
    826e:	2eda 07fe 	cmp	X, #2046
    8272:	1a0d      	jule	0x828e <_HandleDfrDiag+0x49c>
    8274:	72ee      	lod	A, X
    8276:	a2da d800 	add	A, #55296
    827a:	aeda 00da 	cmp	A, #218
    827e:	1a07      	jule	0x828e <_HandleDfrDiag+0x49c>
    8280:	72ee      	lod	A, X
    8282:	a2da f000 	add	A, #61440
    8286:	aeda 01fe 	cmp	A, #510
    828a:	1a01      	jule	0x828e <_HandleDfrDiag+0x49c>
    828c:	008e      	jmp	0x83aa <_HandleDfrDiag+0x5b8>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    828e:	7af8      	lod	Y, [X]
	__asm__ __volatile__
    8290:	72ee      	lod	A, X
    8292:	062e      	jmp	0x7ef0 <_HandleDfrDiag+0xfe>
					}
				}
			}
			else
			{
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    8294:	621b      	lod	AL, [S-28]
    8296:	5cf2      	usex	A
    8298:	54ca 0012 	pushw	#18
    829c:	54ca 00db 	pushw	#219
    82a0:	1573      	call	0x7d88 <_SetupDiagResponse>
    82a2:	05fa      	jmp	0x7e98 <_HandleDfrDiag+0xa6>
			}
		}
#endif /* _SUPPORT_MLX_DEBUG_MODE */
		else if ( pDiag->bySID == (uint8) C_SID_MLX_ERROR_CODES )
    82a4:	6217      	lod	AL, [S-24]
    82a6:	8cec      	cmp	AL, #-20
    82a8:	1d11      	jne	0x82cc <_HandleDfrDiag+0x4da>
			 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xEC | Error[0] | Error[1] | Error[2] | Error[3] | Error[4] |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    82aa:	661b      	lod	YL, [S-28]
    82ac:	4540      	mov	dp:0x40 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = 0x06U;
    82ae:	6006      	lod	AL, #6
    82b0:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_SID_MLX_ERROR_CODES;
    82b2:	6217      	lod	AL, [S-24]
    82b4:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = GetLastError();													/* Oldest Error-code */
    82b6:	13b2      	call	0x8a1c <_GetLastError>
    82b8:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
			g_DiagResponse.byD2 = GetLastError();
    82ba:	13b0      	call	0x8a1c <_GetLastError>
    82bc:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
			g_DiagResponse.byD3 = GetLastError();
    82be:	13ae      	call	0x8a1c <_GetLastError>
    82c0:	4145      	mov	dp:0x45 <_g_DiagResponse+0x5>, AL
			g_DiagResponse.byD4 = GetLastError();
    82c2:	13ac      	call	0x8a1c <_GetLastError>
    82c4:	4146      	mov	dp:0x46 <_g_DiagResponse+0x6>, AL
			g_DiagResponse.byD5 = GetLastError();
    82c6:	13aa      	call	0x8a1c <_GetLastError>
    82c8:	4147      	mov	dp:0x47 <_g_DiagResponse+0x7>, AL
    82ca:	0616      	jmp	0x7ef8 <_HandleDfrDiag+0x106>

			g_u8BufferOutID = (uint8) QR_RFR_DIAG;													/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( (pDiag->bySID == (uint8) C_SID_MLX_EE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0U) )
    82cc:	6217      	lod	AL, [S-24]
    82ce:	8ced      	cmp	AL, #-19
    82d0:	1d26      	jne	0x831e <_HandleDfrDiag+0x52c>
    82d2:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    82d6:	b401      	and	A, #1
    82d8:	1d22      	jne	0x831e <_HandleDfrDiag+0x52c>
			/* EEPROM/NVRAM Patch support
			 * D1.bit 7 = 0 : Read Patch area
			 *			  1 : Write Patch area
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3D.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3F);
    82da:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
    82dc:	4201      	mov	[S-2], AL
    82de:	66e0      	lod	YL, AL
    82e0:	f43f      	and	Y, #63
    82e2:	72e6      	lod	A, Y
    82e4:	4422      	asl	A
    82e6:	5205      	mov	[S-6], A
			if ( (pDiag->byD1 & 0x80U) != 0U )
    82e8:	6201      	lod	AL, [S-2]
    82ea:	8c00      	cmp	AL, #0
    82ec:	1e8d      	jsge	0x8308 <_HandleDfrDiag+0x516>
				 *	| NAD | 0x06| 0xED |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    82ee:	7e05      	lod	X, [S-6]
    82f0:	22da 1080 	add	X, #4224
				*pu16NvramData = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    82f4:	693d      	lod	AH, dp:0x3d <__data_dp_end+0x5>
    82f6:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x4>
    82f8:	52f8      	mov	[X], A
				pu16NvramData++;
    82fa:	7e05      	lod	X, [S-6]
    82fc:	22da 1082 	add	X, #4226
				*pu16NvramData = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8300:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x7>
    8302:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x6>
    8304:	52f8      	mov	[X], A
    8306:	541d      	ret	#30
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xED |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    8308:	621b      	lod	AL, [S-28]
    830a:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06U;
    830c:	6006      	lod	AL, #6
    830e:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_PATCH;
    8310:	6217      	lod	AL, [S-24]
    8312:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    8314:	4543      	mov	dp:0x43 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    8316:	7a05      	lod	Y, [S-6]
    8318:	e2da 1080 	add	Y, #4224
    831c:	0020      	jmp	0x835e <_HandleDfrDiag+0x56c>
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_USERPG1 )
    831e:	6217      	lod	AL, [S-24]
    8320:	8cee      	cmp	AL, #-18
    8322:	1d24      	jne	0x836c <_HandleDfrDiag+0x57a>
			/* EEPROM/NVRAM User-page #1 support
			 * D1.bit 7 = 0 : Read User-page #1
			 *			  1 : Write User-page #1
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3F.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3FU);
    8324:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
    8326:	4201      	mov	[S-2], AL
    8328:	66e0      	lod	YL, AL
    832a:	f43f      	and	Y, #63
    832c:	72e6      	lod	A, Y
    832e:	4422      	asl	A
    8330:	7ee2      	lod	X, A
			if ( (pDiag->byD1 & 0x80U) != 0U )
    8332:	6201      	lod	AL, [S-2]
    8334:	8c00      	cmp	AL, #0
    8336:	1e89      	jsge	0x834a <_HandleDfrDiag+0x558>
				 *	| NAD | 0x06| 0xEE |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    8338:	22da 0056 	add	X, #86
				pu16NvramData[0] = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    833c:	693d      	lod	AH, dp:0x3d <__data_dp_end+0x5>
    833e:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x4>
    8340:	52f8      	mov	[X], A
				pu16NvramData[1] = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8342:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x7>
    8344:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x6>
    8346:	52fa      	mov	[X+2], A
    8348:	541d      	ret	#30
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xEE |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    834a:	621b      	lod	AL, [S-28]
    834c:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06U;
    834e:	6006      	lod	AL, #6
    8350:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_USERPG1;
    8352:	6217      	lod	AL, [S-24]
    8354:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    8356:	4543      	mov	dp:0x43 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    8358:	7aee      	lod	Y, X
    835a:	e2da 0056 	add	Y, #86
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    835e:	72f0      	lod	A, [Y]
    8360:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    8362:	4144      	mov	dp:0x44 <_g_DiagResponse+0x4>, AL
    8364:	4945      	mov	dp:0x45 <_g_DiagResponse+0x5>, AH
    8366:	4546      	mov	dp:0x46 <_g_DiagResponse+0x6>, YL
    8368:	4d47      	mov	dp:0x47 <_g_DiagResponse+0x7>, YH
    836a:	05c6      	jmp	0x7ef8 <_HandleDfrDiag+0x106>
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_STORE )
    836c:	6217      	lod	AL, [S-24]
    836e:	8cef      	cmp	AL, #-17
    8370:	1d1c      	jne	0x83aa <_HandleDfrDiag+0x5b8>
		{
			if ( pDiag->byD1 == (uint8) C_EE_STORE_USERPG1 )
    8372:	613b      	lod	AL, dp:0x3b <__data_dp_end+0x3>
    8374:	8cee      	cmp	AL, #-18
    8376:	1d11      	jne	0x839a <_HandleDfrDiag+0x5a8>
				 *	| NAD | 0x06| 0xEF |   0xEE   | Pages &  |          |          |          |
				 *	|     |     |      |          | ResetFlg |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				(void) NVRAM_Store( pDiag->byD2);
    8378:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x4>
    837a:	5cf2      	usex	A
    837c:	82db 98f8 	callf	0x98f8 <_NVRAM_Store>
				if ( (pDiag->byD2 != 0xFFU) && ((pDiag->byD2 & C_NVRAM_USER_PAGE_RESET) != 0U) )
    8380:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x4>
    8382:	8cff      	cmp	AL, #-1
    8384:	1912      	je	0x83aa <_HandleDfrDiag+0x5b8>
    8386:	b420      	and	A, #32
    8388:	1910      	je	0x83aa <_HandleDfrDiag+0x5b8>
				{
					(void) mlu_ApplicationStop();
    838a:	82db 778e 	callf	0x778e <_mlu_ApplicationStop>
					MLX4_RESET();												/* Reset the Mlx4   */
    838e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8392:	94fe      	and	AL, #-2
    8394:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    8398:	0706      	jmp	0x81a6 <_HandleDfrDiag+0x3b4>
					MLX16_RESET();												/* Reset the Mlx16  */
				}
			}
			else if ( (pDiag->byD1 == (uint8) C_EE_STORE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0U) )
    839a:	8ced      	cmp	AL, #-19
    839c:	1d06      	jne	0x83aa <_HandleDfrDiag+0x5b8>
    839e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    83a2:	b401      	and	A, #1
    83a4:	1d02      	jne	0x83aa <_HandleDfrDiag+0x5b8>
				 *	| NAD | 0x06| 0xEF |   0xED   |          |          |          |          |
				 *	|     |     |      |          |          |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				NVRAM_StorePatch();
    83a6:	82db 9b4e 	callf	0x9b4e <_NVRAM_StorePatch>
    83aa:	541d      	ret	#30

000083ac <_RfrDiagReset>:
#if ((LINPROT & LINXX) == LIN2X)
	if ( g_u8NAD != (uint8) C_BROADCAST_NAD )
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	if ( pDiag->byNAD != C_BROADCAST_J2602_NAD )
    83ac:	6138      	lod	AL, dp:0x38 <__data_dp_end>
    83ae:	8c7f      	cmp	AL, #127
    83b0:	1913      	je	0x83d8 <_RfrDiagReset+0x2c>
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		/* Positive Response */
		g_DiagResponse.byNAD = g_u8NAD;
    83b2:	62d8 002f 	lod	AL, 0x2f <_g_u8NAD>
    83b6:	4140      	mov	dp:0x40 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06U;
    83b8:	6006      	lod	AL, #6
    83ba:	4141      	mov	dp:0x41 <_g_DiagResponse+0x1>, AL
#if (LINPROT == LIN2J_VALVE_VW)
		g_DiagResponse.byRSID = (uint8) (C_SID_RESET | C_RSID_OK);
    83bc:	60f5      	lod	AL, #-11
    83be:	4142      	mov	dp:0x42 <_g_DiagResponse+0x2>, AL
#else  /* (LINPROT == LIN2J_VALVE_VW) */
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
#endif /* (LINPROT == LIN2J_VALVE_VW) */
		g_DiagResponse.byD5 = (uint8) g_NvramUser.Variant;
    83c0:	6159      	lod	AL, dp:0x59 <_g_NvramUser+0x3>
    83c2:	4147      	mov	dp:0x47 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    83c4:	72da 0124 	lod	A, #292
    83c8:	7ada 00b0 	lod	Y, #176
	__asm__ __volatile__
    83cc:	4143      	mov	dp:0x43 <_g_DiagResponse+0x3>, AL
    83ce:	4944      	mov	dp:0x44 <_g_DiagResponse+0x4>, AH
    83d0:	4545      	mov	dp:0x45 <_g_DiagResponse+0x5>, YL
    83d2:	4d46      	mov	dp:0x46 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    83d4:	6007      	lod	AL, #7
    83d6:	412c      	mov	dp:0x2c <_g_u8BufferOutID>, AL
    83d8:	5401      	ret

000083da <_ADC_StartSoftTrig>:
 *
 * Start ADC measurement using Software trigger.
 * ****************************************************************************	*/
void ADC_StartSoftTrig( void)
{
	PEND = CLR_ADC_IT;
    83da:	7040      	lod	A, #64
    83dc:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    83e0:	7001      	lod	A, #1
    83e2:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff != FALSE )
    83e4:	62d8 011c 	lod	AL, 0x11c <_l_u8AdcPowerOff>
    83e8:	1904      	je	0x83f2 <_ADC_StartSoftTrig+0x18>
    83ea:	7eda 008b 	lod	X, #139

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
	{
		NOP();
    83ee:	0000      	nop
    83f0:	1bfe      	djnz	X, 0x83ee <_ADC_StartSoftTrig+0x14>
	{
		NopDelay( DELAY_50us); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    83f2:	6000      	lod	AL, #0
    83f4:	42d8 011c 	mov	0x11c <_l_u8AdcPowerOff>, AL
    83f8:	7c06      	lod	X, #6
    83fa:	0000      	nop
    83fc:	1bfe      	djnz	X, 0x83fa <_ADC_StartSoftTrig+0x20>
	NopDelay( ADC_SETTING); /*lint !e522 */
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    83fe:	72da 0101 	lod	A, #257
    8402:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	while ( (ADC_CTRL & ADC_START) != 0U ) {}									/* Wait for ADC result */
    8404:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8406:	b401      	and	A, #1
    8408:	1d7d      	jne	0x8404 <_ADC_StartSoftTrig+0x2a>
    840a:	5401      	ret

0000840c <_ADC_Stop>:
 *
 * Stop ADC (with waiting for pending ADC conversions to be finished)
 * ****************************************************************************	*/
void ADC_Stop(void)
{	
	if ( (ADC_CTRL & ADC_START) != 0U )											/* In case ADC is active, wait to finish it */
    840c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    840e:	b401      	and	A, #1
    8410:	190f      	je	0x8430 <_ADC_Stop+0x24>
	{
		ADC_CTRL &= ~(ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);					/* Stop looping and HW-triggers */
    8412:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8414:	b6da ff79 	and	A, #65401
    8418:	5290      	mov	io:0x10 <__dp_noinit_size>, A
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    841a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    841c:	b401      	and	A, #1
    841e:	1908      	je	0x8430 <_ADC_Stop+0x24>
		while ( (ADC_CTRL & ADC_START) != 0U )									/* As long as the ADC is active ... */
		{
			ADC_CTRL |= ADC_SOFT_TRIG;											/* ... Set S/W trigger */
    8420:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8422:	a6da 0100 	or	A, #256
    8426:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    8428:	7c12      	lod	X, #18
	{
		NOP();
    842a:	0000      	nop
    842c:	1bfe      	djnz	X, 0x842a <_ADC_Stop+0x1e>
    842e:	07f5      	jmp	0x841a <_ADC_Stop+0xe>
			NopDelay( DELAY_7us); /*lint !e522 */
		}
	}
	ADC_CTRL = 0U;																/* Clear the ADC control register */
    8430:	7000      	lod	A, #0
    8432:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	BEGIN_CRITICAL_SECTION();
    8434:	54d0      	psup	#0
	MASK &= ~EN_ADC_IT;															/* Disable ADC Interrupt */
    8436:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    843a:	b4bf      	and	A, #-65
    843c:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	END_CRITICAL_SECTION();
    8440:	72cb      	pop	M
    8442:	5401      	ret

00008444 <_ADC_Init>:
 *
 * Measure Zero-current offset
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Init( void)
{
    8444:	580f      	inc	S, #16
	uint16 volatile u16VDDA;
	uint16 volatile u16ZCO;

	ADC_Stop();																	/* Clear the ADC control register */
    8446:	17e2      	call	0x840c <_ADC_Stop>

	/* VDDA and VDDD check (MMP170222-4) */
	ADC_SBASE = (uint16) SBASE_VDDA;
    8448:	72da a158 	lod	A, #41304
    844c:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) ((uint16 *) &u16VDDA);
    844e:	7aef      	lod	Y, S
    8450:	e0f0      	add	Y, #-16
    8452:	5a94      	mov	io:0x14 <__dp_noinit_size+0x4>, Y
	ADC_StartSoftTrig();
    8454:	17c2      	call	0x83da <_ADC_StartSoftTrig>
	if ( (u16VDDA < C_MIN_VDDA) || (u16VDDA > C_MAX_VDDA) )
    8456:	720f      	lod	A, [S-16]
    8458:	aeda 0283 	cmp	A, #643
    845c:	1a04      	jule	0x8466 <_ADC_Init+0x22>
    845e:	720f      	lod	A, [S-16]
    8460:	aeda 02c2 	cmp	A, #706
    8464:	1a05      	jule	0x8470 <_ADC_Init+0x2c>
	{
		/* TODO[MMP]: What to do? E.g. enter SLEEP (below error is lost) */
		g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8466:	6002      	lod	AL, #2
    8468:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
#if _SUPPORT_LOG_ERRORS
		SetLastError( (uint8) C_ERR_VDDA);
    846a:	72da 00d6 	lod	A, #214
    846e:	12bb      	call	0x89e6 <_SetLastError>
#endif /* _SUPPORT_LOG_ERRORS */
	}

	ADC_SBASE = (uint16) SBASE_VDDD;
    8470:	72da a154 	lod	A, #41300
    8474:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) ((uint16 *) &u16ZCO);
    8476:	7aef      	lod	Y, S
    8478:	e0f2      	add	Y, #-14
    847a:	5a94      	mov	io:0x14 <__dp_noinit_size+0x4>, Y
	ADC_StartSoftTrig();
    847c:	17ae      	call	0x83da <_ADC_StartSoftTrig>
	if ( (u16ZCO < C_MIN_VDDD) || (u16ZCO > C_MAX_VDDD) )
    847e:	720d      	lod	A, [S-14]
    8480:	aeda 02d3 	cmp	A, #723
    8484:	1a04      	jule	0x848e <_ADC_Init+0x4a>
    8486:	720d      	lod	A, [S-14]
    8488:	aeda 0384 	cmp	A, #900
    848c:	1a05      	jule	0x8498 <_ADC_Init+0x54>
	{
		/* TODO[MMP]: What to do? E.g. enter SLEEP (below error is lost) */
		g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    848e:	6002      	lod	AL, #2
    8490:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
#if _SUPPORT_LOG_ERRORS
		SetLastError( (uint8) C_ERR_VDDD);
    8492:	72da 00d7 	lod	A, #215
    8496:	12a7      	call	0x89e6 <_SetLastError>
#endif /* _SUPPORT_LOG_ERRORS */
	}

	/* I/O Output check (MMP170302-1) */
	if ( (ANA_OUTF & (IO5_ENA | IO4_ENA | IO3_ENA | IO2_ENA | IO1_ENA | IO0_ENA)) != 0U )
    8498:	72d8 204e 	lod	A, 0x204e <__ep__+0x104e>
    849c:	b43f      	and	A, #63
    849e:	1d01      	jne	0x84a2 <_ADC_Init+0x5e>
    84a0:	004f      	jmp	0x8540 <_ADC_Init+0xfc>
	{
		/* At least one or more I/O's are defined as output */
		uint16 u16Idx;
		for ( u16Idx = 0U; u16Idx < 6; u16Idx++ )
    84a2:	7000      	lod	A, #0
    84a4:	520b      	mov	[S-12], A
    84a6:	7ada a13c 	lod	Y, #41276
    84aa:	5a01      	mov	[S-2], Y
		{
			uint16 u16Mask = (IO0_ENA << u16Idx);
    84ac:	720b      	lod	A, [S-12]
    84ae:	44e2      	sfb	A
    84b0:	5209      	mov	[S-10], A
			if ( (ANA_OUTF & u16Mask) != 0U )
    84b2:	72d8 204e 	lod	A, 0x204e <__ep__+0x104e>
    84b6:	b609      	and	A, [S-10]
    84b8:	1d01      	jne	0x84bc <_ADC_Init+0x78>
    84ba:	0039      	jmp	0x852e <_ADC_Init+0xea>
			{
				uint16 u16OrgOutState = ANA_OUTN;
    84bc:	7ad8 28d8 	lod	Y, 0x28d8 <__io__+0xd8>
    84c0:	5a07      	mov	[S-8], Y

				/* Check high level; May cause VDDA overload */
				ANA_OUTN = u16OrgOutState | u16Mask;
    84c2:	72e6      	lod	A, Y
    84c4:	a609      	or	A, [S-10]
    84c6:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
				ADC_SBASE = (uint16) &SBASE_VIO[u16Idx][0];
    84ca:	7201      	lod	A, [S-2]
    84cc:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
				ADC_DBASE = (uint16) ((uint16 *) &u16ZCO);
    84ce:	7aef      	lod	Y, S
    84d0:	e0f2      	add	Y, #-14
    84d2:	5a94      	mov	io:0x14 <__dp_noinit_size+0x4>, Y
				ADC_StartSoftTrig();
    84d4:	1782      	call	0x83da <_ADC_StartSoftTrig>
				ANA_OUTN = u16OrgOutState;
    84d6:	7207      	lod	A, [S-8]
    84d8:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
				if ( u16ZCO < C_ADC_MAX )
    84dc:	720d      	lod	A, [S-14]
    84de:	7a09      	lod	Y, [S-10]
    84e0:	fcff      	xor	Y, #-1
    84e2:	5a03      	mov	[S-4], Y
    84e4:	aeda 03fe 	cmp	A, #1022
    84e8:	1e06      	jug	0x84f6 <_ADC_Init+0xb2>
				{
					/* ADC Vref=2.5V, I/O-output voltage is 3.3V */
					g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    84ea:	6002      	lod	AL, #2
    84ec:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
					ANA_OUTF &= ~u16Mask;										/* Disable I/O Output-mode */
    84ee:	72d8 204e 	lod	A, 0x204e <__ep__+0x104e>
    84f2:	b6e6      	and	A, Y
    84f4:	0016      	jmp	0x8522 <_ADC_Init+0xde>
#endif /* _SUPPORT_LOG_ERRORS */
				}
				else
				{
					/* Check low level */
					ANA_OUTN = u16OrgOutState & ~u16Mask;
    84f6:	7207      	lod	A, [S-8]
    84f8:	b603      	and	A, [S-4]
    84fa:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
					ADC_SBASE = (uint16) &SBASE_VIO[u16Idx][0];
    84fe:	7201      	lod	A, [S-2]
    8500:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
					ADC_DBASE = (uint16) ((uint16 *) &u16ZCO);
    8502:	7aef      	lod	Y, S
    8504:	e0f2      	add	Y, #-14
    8506:	5a94      	mov	io:0x14 <__dp_noinit_size+0x4>, Y
					ADC_StartSoftTrig();
    8508:	1768      	call	0x83da <_ADC_StartSoftTrig>
					ANA_OUTN = u16OrgOutState;
    850a:	7207      	lod	A, [S-8]
    850c:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
					if ( (u16ZCO > C_MAX_IO_LOW) )
    8510:	720d      	lod	A, [S-14]
    8512:	aeda 00a4 	cmp	A, #164
    8516:	1a0b      	jule	0x852e <_ADC_Init+0xea>
					{
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8518:	6002      	lod	AL, #2
    851a:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
						ANA_OUTF &= ~u16Mask;										/* Disable I/O Output-mode */
    851c:	72d8 204e 	lod	A, 0x204e <__ep__+0x104e>
    8520:	b603      	and	A, [S-4]
    8522:	52d8 204e 	mov	0x204e <__ep__+0x104e>, A
#if _SUPPORT_LOG_ERRORS
						SetLastError( (uint8) (C_ERR_VIO_0 + u16Idx));
    8526:	620b      	lod	AL, [S-12]
    8528:	80d8      	add	AL, #-40
    852a:	5cf2      	usex	A
    852c:	125c      	call	0x89e6 <_SetLastError>
	/* I/O Output check (MMP170302-1) */
	if ( (ANA_OUTF & (IO5_ENA | IO4_ENA | IO3_ENA | IO2_ENA | IO1_ENA | IO0_ENA)) != 0U )
	{
		/* At least one or more I/O's are defined as output */
		uint16 u16Idx;
		for ( u16Idx = 0U; u16Idx < 6; u16Idx++ )
    852e:	7a0b      	lod	Y, [S-12]
    8530:	e001      	add	Y, #1
    8532:	5a0b      	mov	[S-12], Y
    8534:	7201      	lod	A, [S-2]
    8536:	a004      	add	A, #4
    8538:	5201      	mov	[S-2], A
    853a:	ec05      	cmp	Y, #5
    853c:	1e01      	jug	0x8540 <_ADC_Init+0xfc>
    853e:	07b6      	jmp	0x84ac <_ADC_Init+0x68>
			}
		}
	}

	{
		uint16 u16DrvCfg = DRVCFG;												/* Save driver state (MMP170405-1 - Begin) */
    8540:	7ad8 28c6 	lod	Y, 0x28c6 <__io__+0xc6>
    8544:	5a05      	mov	[S-6], Y
		DRVCFG &= ~DIS_DRV;														/* Enable driver to allow current measurement */
    8546:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    854a:	b6da feff 	and	A, #65279
    854e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		ADC_SBASE = (uint16) SBASE_CURROFF;
    8552:	72da a15c 	lod	A, #41308
    8556:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
		ADC_DBASE = (uint16) &u16ZCO;
    8558:	72ef      	lod	A, S
    855a:	a0f2      	add	A, #-14
    855c:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
		ADC_StartSoftTrig();
    855e:	173d      	call	0x83da <_ADC_StartSoftTrig>
		l_u16CurrentZeroOffset = /* lint -e{530} */ u16ZCO;
    8560:	720d      	lod	A, [S-14]
    8562:	52d8 0120 	mov	0x120 <_l_u16CurrentZeroOffset>, A
		ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);									/* Single shot */
    8566:	7ada 0101 	lod	Y, #257
    856a:	5a90      	mov	io:0x10 <__dp_noinit_size>, Y
		while ( (ADC_CTRL & ADC_START) != 0U) {}								/* Wait for ADC result */
    856c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    856e:	b401      	and	A, #1
    8570:	1d7d      	jne	0x856c <_ADC_Init+0x128>
		l_u16CurrentZeroOffset = (l_u16CurrentZeroOffset + u16ZCO) >> 1;
    8572:	72d8 0120 	lod	A, 0x120 <_l_u16CurrentZeroOffset>
    8576:	7a0d      	lod	Y, [S-14]
    8578:	a2e6      	add	A, Y
    857a:	4432      	lsr	A
    857c:	52d8 0120 	mov	0x120 <_l_u16CurrentZeroOffset>, A
		DRVCFG = u16DrvCfg;														/* Restore Driver state (MMP170405-1 - End) */
    8580:	7205      	lod	A, [S-6]
    8582:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	}

	g_u16MCurrgain = EE_GMCURR_NEW;												/* MMP160616-1 */
    8586:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    858a:	8c63      	cmp	AL, #99
    858c:	1e07      	jug	0x859c <_ADC_Init+0x158>
    858e:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    8592:	b6da 00ff 	and	A, #255
    8596:	a2da 0100 	add	A, #256
    859a:	0005      	jmp	0x85a6 <_ADC_Init+0x162>
    859c:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    85a0:	b6da 00ff 	and	A, #255
    85a4:	4422      	asl	A
    85a6:	52d8 011e 	mov	0x11e <_g_u16MCurrgain>, A
	{
		l_u16CurrentZeroOffset = EE_OMCURR;										/* Take calibrated current offset, instead of measured offset */
	}
#endif /* SUPPORT_CALIBRATED_ZERO_CURRENT */

	PRIO = (PRIO & ~(3U << 2)) | ((5U - 3U) << 2);								/* ADC IRQ Priority: 5 (3..6) */
    85aa:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    85ae:	b4f3      	and	A, #-13
    85b0:	a408      	or	A, #8
    85b2:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
    85b6:	5411      	ret	#18

000085b8 <_ADC_Start>:
void ADC_Start( uint16 u16Mode)
#else  /* _SUPPORT_PHASE_SHORT_DET */
void ADC_Start( void)
#endif /* _SUPPORT_PHASE_SHORT_DET */
{
	ADC_Stop();																	/* clear the ADC control register */
    85b8:	1729      	call	0x840c <_ADC_Stop>
#if _SUPPORT_PHASE_SHORT_DET
	ADC_SetupShortDetection( u16Mode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_SBASE = (uint16) SBASE_INIT_4PH;
    85ba:	72da a120 	lod	A, #41248
    85be:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
#endif /* _SUPPORT_PHASE_SHORT_DET */
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4;
    85c0:	72da 014c 	lod	A, #332
    85c4:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_CTRL  = (ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);						/* Loop cycle of conversion is done */
    85c6:	72da 0086 	lod	A, #134
    85ca:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_CTRL |= ADC_START;														/* Start ADC */
    85cc:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    85ce:	a401      	or	A, #1
    85d0:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff != FALSE )												/* Add delay */
    85d2:	62d8 011c 	lod	AL, 0x11c <_l_u8AdcPowerOff>
    85d6:	1904      	je	0x85e0 <_ADC_Start+0x28>
    85d8:	7eda 009b 	lod	X, #155
    85dc:	0000      	nop
    85de:	1bfe      	djnz	X, 0x85dc <_ADC_Start+0x24>
	{
		NopDelay( DELAY_mPWM); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    85e0:	6000      	lod	AL, #0
    85e2:	42d8 011c 	mov	0x11c <_l_u8AdcPowerOff>, AL
    85e6:	5401      	ret

000085e8 <_ADC_PowerOff>:
 * ADC_PowerOff()
 *
 * Power-off ADC, by disabling reference voltage
 * ****************************************************************************	*/
void ADC_PowerOff( void)
{
    85e8:	5801      	inc	S, #2
	int16 u16Scratch;															/* MMP170404-2 */

	ADC_Stop();																	/* Stop ADC conversion, and disable ADC-IRQ */
    85ea:	1710      	call	0x840c <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_VREF_OFF;
    85ec:	72da a160 	lod	A, #41312
    85f0:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16Scratch;											/* MMP170404-2 */
    85f2:	72ef      	lod	A, S
    85f4:	a0fe      	add	A, #-2
    85f6:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	PEND = CLR_ADC_IT;
    85f8:	7040      	lod	A, #64
    85fa:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    85fe:	7001      	lod	A, #1
    8600:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_Stop();
    8602:	1704      	call	0x840c <_ADC_Stop>
	l_u8AdcPowerOff = TRUE;
    8604:	6001      	lod	AL, #1
    8606:	42d8 011c 	mov	0x11c <_l_u8AdcPowerOff>, AL
    860a:	5403      	ret	#4

0000860c <_ADC_IT>:
 * ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead (is approx: 9.5% at 24kHz PWM)
 * (push/pop + check for LIN-AA + Check BEMF ZC)
 * ****************************************************************************	*/
__interrupt__ void ADC_IT(void) 
{
    860c:	4407      	mov	R, #0
    860e:	72cb      	pop	M
    8610:	5401      	ret

00008612 <_GetVsupply>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8612:	7ad8 014e 	lod	Y, 0x14e <_g_AdcMotorRunStepper4+0x2>
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8616:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    861a:	5ce2      	ssex	A
    861c:	eae2      	sub	Y, A
    861e:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8622:	6000      	lod	AL, #0
    8624:	72e4      	swap	A
    int32 result;

    __asm__ __volatile__ (
    8626:	4811      	muls	D, A, Y
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8628:	4c80      	mov	YA, D
    862a:	4c22 0020 	add	YA, #32
    862e:	0000 
    8630:	4cb2 0000 	cmp	YA, #0
    8634:	0000 
    8636:	1e84      	jsge	0x8640 <_GetVsupply+0x2e>
    8638:	4c80      	mov	YA, D
    863a:	4c22 005f 	add	YA, #95
    863e:	0000 
    8640:	48b5      	asr	YA, #6
    8642:	52d8 010a 	mov	0x10a <_g_i16SupplyVoltage>, A
    8646:	5401      	ret

00008648 <_GetRawChipSupply>:
} /* End of GetVsupply() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawChipSupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8648:	72d8 014e 	lod	A, 0x14e <_g_AdcMotorRunStepper4+0x2>
	return ( u16FilteredSupplyVoltage );
} /* End of GetRawChipSupply() */
    864c:	5401      	ret

0000864e <_GetVsupplyMotor>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupplyMotor( void)
{
	uint16 u16FilteredDriverVoltage = g_AdcMotorRunStepper4.FilteredDriverVoltage;
    864e:	72d8 0152 	lod	A, 0x152 <_g_AdcMotorRunStepper4+0x6>
#if _SUPPORT_VSMFILTERED
	g_i16MotorVoltage = (int16) ((mulI32_I16byU16( (int16)(u16FilteredDriverVoltage - EE_OVOLTAGE), EE_GVOLTAGE) + (C_GVOLTAGE_DIV/2)) / C_GVOLTAGE_DIV);
    8652:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    8656:	5ce6      	ssex	Y
    8658:	aae6      	sub	A, Y
    865a:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    865e:	6400      	lod	YL, #0
    8660:	7ae8      	swap	Y
    8662:	5adf      	push	Y
    8664:	82db 6c42 	callf	0x6c42 <_mulI32_I16byU16>
    8668:	4cc0      	mov	D, YA
    866a:	4c22 0020 	add	YA, #32
    866e:	0000 
    8670:	4cb2 0000 	cmp	YA, #0
    8674:	0000 
    8676:	1e84      	jsge	0x8680 <_GetVsupplyMotor+0x32>
    8678:	4c80      	mov	YA, D
    867a:	4c22 005f 	add	YA, #95
    867e:	0000 
    8680:	48b5      	asr	YA, #6
    8682:	511c      	mov	dp:0x1c <_g_i16MotorVoltage>, A
    8684:	5c01      	dec	S, #2
    8686:	5401      	ret

00008688 <_ResetChipTemperature>:
 *
 * Reset Chip temperature
 * ****************************************************************************	*/
void ResetChipTemperature( void)
{
	g_AdcMotorRunStepper4.IntTemperatureSensor = 0U;
    8688:	7ada 014c 	lod	Y, #332
    868c:	7000      	lod	A, #0
    868e:	52f0      	mov	[Y], A
    8690:	5401      	ret

00008692 <_GetChipTemperature>:
 * GetChipTemperature()
 *
 * Get Chip temperature [C]
 * ****************************************************************************	*/
void GetChipTemperature( uint16 u16Init)
{
    8692:	580b      	inc	S, #12
    8694:	520b      	mov	[S-12], A
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    8696:	7ad8 014c 	lod	Y, 0x14c <_g_AdcMotorRunStepper4>
	int16 i16ChipTemperature, i16ChipTempDelta;

#if _SUPPORT_TWO_LINE_TEMP_INTERPOLATION
	if ( u16ChipTemperatureSensor < EE_OTEMP )
    869a:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    869e:	eee2      	cmp	Y, A
    86a0:	1c11      	jnc	0x86c4 <_GetChipTemperature+0x32>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    86a2:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    86a6:	aae6      	sub	A, Y
    86a8:	5203      	mov	[S-4], A
    86aa:	785a      	lod	Y, #90
    86ac:	7ed8 11ba 	lod	X, 0x11ba <__ep__+0x1ba>
    86b0:	72d8 11bc 	lod	A, 0x11bc <__ep__+0x1bc>
    86b4:	2ae2      	sub	X, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    86b6:	7203      	lod	A, [S-4]
    86b8:	4821      	mulu	YA, A, Y
    86ba:	4c63      	divu	YA, X
    86bc:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    86be:	7ae2      	lod	Y, A
    86c0:	e023      	add	Y, #35
    86c2:	0012      	jmp	0x86e8 <_GetChipTemperature+0x56>
    86c4:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    86c8:	eae2      	sub	Y, A
    86ca:	5a01      	mov	[S-2], Y
    86cc:	7ed8 11b8 	lod	X, 0x11b8 <__ep__+0x1b8>
    86d0:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    86d4:	2ae6      	sub	X, Y
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    86d6:	704b      	lod	A, #75
    86d8:	7a01      	lod	Y, [S-2]
    86da:	4821      	mulu	YA, A, Y
    86dc:	4c63      	divu	YA, X
    86de:	4c63      	divu	YA, X
    86e0:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    86e2:	7023      	lod	A, #35
    86e4:	7ae2      	lod	Y, A
    86e6:	eaee      	sub	Y, X
	}
#else  /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */
	i16ChipTemperature = (mulI32_I16byI16( (EE_OTEMP - u16ChipTemperatureSensor), EE_GTEMP) / C_GTEMP_DIV) + EE_MIDTEMP;
#endif /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */

	if ( u16Init == FALSE )
    86e8:	7e0b      	lod	X, [S-12]
    86ea:	1d13      	jne	0x8712 <_GetChipTemperature+0x80>
	{
		i16ChipTempDelta = i16ChipTemperature - g_i16ChipTemperature;			/* Delta-temperature = new-temperature - previous-temperature */
    86ec:	7120      	lod	A, dp:0x20 <__data_dp_size>
    86ee:	7ee6      	lod	X, Y
    86f0:	2ae2      	sub	X, A
    86f2:	72ee      	lod	A, X
		if ( i16ChipTempDelta < 0 )
		{
			i16ChipTempDelta = -i16ChipTempDelta;								/* Absolute temperature change */
    86f4:	ac00      	cmp	A, #0
    86f6:	1e81      	jsge	0x86fa <_GetChipTemperature+0x68>
    86f8:	5cc2      	neg	A
		}
		if ( (uint16) i16ChipTempDelta > C_TEMPERATURE_JUMP )					/* Temperature change small, then accept new temperature */
    86fa:	ac0a      	cmp	A, #10
    86fc:	1a0a      	jule	0x8712 <_GetChipTemperature+0x80>
		{
			if ( i16ChipTemperature > g_i16ChipTemperature )					/* To great temperature change; Check temperature change "direction" */
    86fe:	7120      	lod	A, dp:0x20 <__data_dp_size>
    8700:	eee2      	cmp	Y, A
    8702:	1b04      	jsle	0x870c <_GetChipTemperature+0x7a>
			{
				i16ChipTemperature = g_i16ChipTemperature + 1;					/* Increase by one degree */
    8704:	7120      	lod	A, dp:0x20 <__data_dp_size>
    8706:	7ae2      	lod	Y, A
    8708:	e001      	add	Y, #1
    870a:	0003      	jmp	0x8712 <_GetChipTemperature+0x80>
			}
			else
			{
				i16ChipTemperature = g_i16ChipTemperature - 1;					/* Decrease by one degree */
    870c:	7120      	lod	A, dp:0x20 <__data_dp_size>
    870e:	7ae2      	lod	Y, A
    8710:	e0ff      	add	Y, #-1
			}
		}
	}
	g_i16ChipTemperature = i16ChipTemperature;
    8712:	5920      	mov	dp:0x20 <__data_dp_size>, Y
    8714:	540d      	ret	#14

00008716 <_GetRawTemperature>:
} /* End of GetChipTemperature() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawTemperature( void)
{
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    8716:	7ada 014c 	lod	Y, #332
    871a:	72f0      	lod	A, [Y]
	return ( u16ChipTemperatureSensor );
} /* End of GetRawTemperature() */
    871c:	5401      	ret

0000871e <_GetRawMotorDriverCurrent>:
 * GetRawMotorDriverCurrent()
 *
 * Get (raw) Motor Driver Current [ADC-LSB]
 * ****************************************************************************	*/
uint16 GetRawMotorDriverCurrent( void)
{
    871e:	5801      	inc	S, #2
	uint16 u16Current = 0U;
    8720:	7000      	lod	A, #0
    8722:	5201      	mov	[S-2], A
#if ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL))
	g_u16CurrentMotorCoilA = g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    8724:	7ad8 0154 	lod	Y, 0x154 <_g_AdcMotorRunStepper4+0x8>
    8728:	5ad8 011a 	mov	0x11a <_g_u16CurrentMotorCoilA>, Y
	if ( g_u16CurrentMotorCoilA > l_u16CurrentZeroOffset )
    872c:	7ed8 0120 	lod	X, 0x120 <_l_u16CurrentZeroOffset>
    8730:	eeee      	cmp	Y, X
    8732:	1a02      	jule	0x8738 <_GetRawMotorDriverCurrent+0x1a>
	{
		u16Current = g_u16CurrentMotorCoilA - (int16) l_u16CurrentZeroOffset;
    8734:	eaee      	sub	Y, X
    8736:	5a01      	mov	[S-2], Y
	}
	g_u16CurrentMotorCoilB = g_AdcMotorRunStepper4.UnfilteredDriverCurrent2;
    8738:	72d8 0150 	lod	A, 0x150 <_g_AdcMotorRunStepper4+0x4>
    873c:	52d8 0118 	mov	0x118 <_g_u16CurrentMotorCoilB>, A
	if ( g_u16CurrentMotorCoilB > l_u16CurrentZeroOffset )
    8740:	aeee      	cmp	A, X
    8742:	1a03      	jule	0x874a <_GetRawMotorDriverCurrent+0x2c>
	{
		u16Current = u16Current + (g_u16CurrentMotorCoilB - l_u16CurrentZeroOffset);
    8744:	aaee      	sub	A, X
    8746:	a201      	add	A, [S-2]
    8748:	5201      	mov	[S-2], A
	{
		u16Current = u16Current - (int16) l_u16CurrentZeroOffset;
	}
#endif /* ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)) */
	return ( u16Current );
} /* End of GetRawMotorDriverCurrent() */
    874a:	7201      	lod	A, [S-2]
    874c:	5403      	ret	#4

0000874e <_GetMotorDriverCurrent>:
 *
 * Get Motor Driver Current [mA]
 * ****************************************************************************	*/
int16 GetMotorDriverCurrent( void)
{
	uint16 u16Current = GetRawMotorDriverCurrent();
    874e:	17e7      	call	0x871e <_GetRawMotorDriverCurrent>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8750:	7ad8 011e 	lod	Y, 0x11e <_g_u16MCurrgain>
    uint32 result;

    __asm__ __volatile__ (
    8754:	4801      	mulu	D, A, Y
    8756:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8758:	4c22 0040 	add	YA, #64
    875c:	0000 
    875e:	48a6      	lsr	YA, #7
	u16Current = (uint16) ((mulU32_U16byU16( u16Current, g_u16MCurrgain) + (C_GMCURR_DIV / 2U)) / C_GMCURR_DIV);
	return ( (int16) u16Current);
} /* End of GetMotorDriverCurrent() */
    8760:	5401      	ret

00008762 <_MeasureVsupplyAndTemperature>:
 *
 * Measure Vbat and Temperature (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureVsupplyAndTemperature( void)
{	
	ADC_Stop();
    8762:	1654      	call	0x840c <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_MOTORVOLT;										/* switch ADC input source to Voltage */
    8764:	72da a130 	lod	A, #41264
    8768:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredDriverVoltage;
    876a:	72da 0152 	lod	A, #338
    876e:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();
    8770:	1634      	call	0x83da <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_SUPPLYVOLT;										/* switch ADC input source to Voltage */
    8772:	72da a134 	lod	A, #41268
    8776:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8778:	72da 014e 	lod	A, #334
    877c:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();
    877e:	162d      	call	0x83da <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_TEMP;											/* switch ADC input source to Temperature */
    8780:	72da a138 	lod	A, #41272
    8784:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.IntTemperatureSensor;
    8786:	72da 014c 	lod	A, #332
    878a:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();
    878c:	1626      	call	0x83da <_ADC_StartSoftTrig>
    878e:	5401      	ret

00008790 <_MeasureMotorCurrent>:
 * MeasureMotorCurrent()
 *
 * Measure Motor-current (filtered) (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureMotorCurrent( void)
{
    8790:	5801      	inc	S, #2
	ADC_Stop();
    8792:	163c      	call	0x840c <_ADC_Stop>
	uint16 u16DrvCfg = DRVCFG;													/* MMP170405-1 - Begin */
    8794:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8798:	5201      	mov	[S-2], A
	DRVCFG &= ~DIS_DRV;															/* Enable driver to allow current measurement */
    879a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    879e:	b6da feff 	and	A, #65279
    87a2:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	g_AdcMotorRunStepper4.UnfilteredDriverCurrent = l_u16CurrentZeroOffset;
    87a6:	72d8 0120 	lod	A, 0x120 <_l_u16CurrentZeroOffset>
    87aa:	52d8 0154 	mov	0x154 <_g_AdcMotorRunStepper4+0x8>, A
	g_AdcMotorRunStepper4.UnfilteredDriverCurrent2 = l_u16CurrentZeroOffset;
    87ae:	52d8 0150 	mov	0x150 <_g_AdcMotorRunStepper4+0x4>, A
	ADC_SBASE = (uint16) SBASE_CURRENT;											/* Switch ADC input source to Motor-driver current */
    87b2:	72da a12c 	lod	A, #41260
    87b6:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    87b8:	72da 0154 	lod	A, #340
    87bc:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();
    87be:	160d      	call	0x83da <_ADC_StartSoftTrig>
	DRVCFG = u16DrvCfg;															/* MMP170405-1 - End */
    87c0:	7201      	lod	A, [S-2]
    87c2:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    87c6:	5403      	ret	#4

000087c8 <_MeasurePhaseVoltage>:
 * MeasurePhaseVoltage()
 *
 * Measure Phase voltage (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasurePhaseVoltage( uint16 u16AdcSbase)
{
    87c8:	5803      	inc	S, #4
    87ca:	5201      	mov	[S-2], A
	uint16 u16PhaseVoltage;
	ADC_Stop();
    87cc:	161f      	call	0x840c <_ADC_Stop>
	ADC_SBASE = (uint16) u16AdcSbase;											/* switch ADC input source to Motor-driver current */
    87ce:	7201      	lod	A, [S-2]
    87d0:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16PhaseVoltage;
    87d2:	72ef      	lod	A, S
    87d4:	a0fc      	add	A, #-4
    87d6:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();
    87d8:	1600      	call	0x83da <_ADC_StartSoftTrig>
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    87da:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    87de:	5ce2      	ssex	A
    87e0:	7a03      	lod	Y, [S-4]
    87e2:	eae2      	sub	Y, A
    87e4:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    87e8:	6000      	lod	AL, #0
    87ea:	72e4      	swap	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    87ec:	4831      	muls	YA, A, Y
    87ee:	48b5      	asr	YA, #6
    87f0:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    87f2:	52d8 0108 	mov	0x108 <_g_i16PhaseVoltage>, A
    87f6:	5405      	ret	#6

000087f8 <_HandleDiagnosticEvent>:
 * HandleDiagnosticEvent()
 *
 * Handle Diagnostic Events
 * ****************************************************************************	*/
void HandleDiagnosticEvent( uint16 u16Event)
{
    87f8:	5803      	inc	S, #4
    87fa:	5203      	mov	[S-4], A
	if ( u16Event & (XI4_OC_DRV | XI4_OVT) )
    87fc:	b6da 8100 	and	A, #33024
    8800:	1d01      	jne	0x8804 <_HandleDiagnosticEvent+0xc>
    8802:	0040      	jmp	0x8884 <_HandleDiagnosticEvent+0x8c>
	{
		/* In case over-current or over-temperature, switch off motor */
#if _SUPPORT_DIAG_OC
		if ( u16Event & XI4_OC_DRV )
    8804:	7203      	lod	A, [S-4]
    8806:	b6da 0100 	and	A, #256
    880a:	191c      	je	0x8844 <_HandleDiagnosticEvent+0x4c>
			/* Chip over-current */
			/* The over-current may occur then chips has entered test-mode. The test-mode freezes the
			 * complete digital part of the chip, including the Motor PWM and driver. This may result
			 * in a phase H and a phase L, having a DC-current flow!!
			 */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    880c:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    880e:	8c01      	cmp	AL, #1
    8810:	1903      	je	0x8818 <_HandleDiagnosticEvent+0x20>
    8812:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    8816:	1916      	je	0x8844 <_HandleDiagnosticEvent+0x4c>
    8818:	7eda 009b 	lod	X, #155
    881c:	0000      	nop
    881e:	1bfe      	djnz	X, 0x881c <_HandleDiagnosticEvent+0x24>
			{
				/* Average between two driver-current measurements */
				NopDelay( DELAY_mPWM); /*lint !e522 */							/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
				g_i16Current = GetMotorDriverCurrent();
    8820:	1796      	call	0x874e <_GetMotorDriverCurrent>
    8822:	52d8 0106 	mov	0x106 <_g_i16Current>, A
#if (defined __MLX81315_A__)
				if ( g_i16Current > 1400 )										/* MLX81315 */
    8826:	72d8 0106 	lod	A, 0x106 <_g_i16Current>
    882a:	aeda 0578 	cmp	A, #1400
    882e:	1b0a      	jsle	0x8844 <_HandleDiagnosticEvent+0x4c>
#else  /* (defined __MLX81315_A__) */
				if ( g_i16Current > 700 )										/* MLX81310 */
#endif /* (defined __MLX81315_A__) */
				{
					g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_YES;
    8830:	6001      	lod	AL, #1
    8832:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Over-current */
    8834:	7002      	lod	A, #2
    8836:	82db 9296 	callf	0x9296 <_MotorDriverStop>
					g_u16TargetPosition = g_u16ActualPosition;
    883a:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    883c:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
					SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    883e:	72da 00d0 	lod	A, #208
    8842:	10d1      	call	0x89e6 <_SetLastError>
//				g_u16TargetPosition = g_u16ActualPosition;
//				SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
//			}
		}
#endif /* _SUPPORT_DIAG_OC */
		if ( u16Event & XI4_OVT )
    8844:	7203      	lod	A, [S-4]
    8846:	ac00      	cmp	A, #0
    8848:	1e9d      	jsge	0x8884 <_HandleDiagnosticEvent+0x8c>
		{
			/* Chip over-temperature */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    884a:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    884c:	8c01      	cmp	AL, #1
    884e:	1903      	je	0x8856 <_HandleDiagnosticEvent+0x5e>
    8850:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    8854:	1906      	je	0x8862 <_HandleDiagnosticEvent+0x6a>
			{
				ResetChipTemperature();
    8856:	1718      	call	0x8688 <_ResetChipTemperature>
    8858:	7eda 009b 	lod	X, #155
    885c:	0000      	nop
    885e:	1bfe      	djnz	X, 0x885c <_HandleDiagnosticEvent+0x64>
    8860:	0001      	jmp	0x8864 <_HandleDiagnosticEvent+0x6c>
				NopDelay( DELAY_mPWM); /*lint !e522 */
				GetChipTemperature( FALSE);
			}
			else
			{
				MeasureVsupplyAndTemperature();
    8862:	177f      	call	0x8762 <_MeasureVsupplyAndTemperature>
				GetChipTemperature( FALSE);
    8864:	7000      	lod	A, #0
    8866:	1715      	call	0x8692 <_GetChipTemperature>
			}
			if ( g_i16ChipTemperature > (int16) C_CHIP_OVERTEMP_LEVEL )
    8868:	7120      	lod	A, dp:0x20 <__data_dp_size>
    886a:	aeda 0096 	cmp	A, #150
    886e:	1b0a      	jsle	0x8884 <_HandleDiagnosticEvent+0x8c>
			{
				/* Over-temperature level */
				g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    8870:	6001      	lod	AL, #1
    8872:	4124      	mov	dp:0x24 <_g_e8ErrorOverTemperature>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Over-temperature */
    8874:	7002      	lod	A, #2
    8876:	82db 9296 	callf	0x9296 <_MotorDriverStop>
				g_u16TargetPosition = g_u16ActualPosition;
    887a:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    887c:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
					{
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
					}
				}
#endif /* _SUPPORT_OVT_PED */
				SetLastError( (uint8) C_ERR_DIAG_OVER_TEMP);
    887e:	72da 00d1 	lod	A, #209
    8882:	10b1      	call	0x89e6 <_SetLastError>
			}
		}
	}
	if ( u16Event & (XI4_UV | XI4_OV) )
    8884:	7203      	lod	A, [S-4]
    8886:	b6da 6000 	and	A, #24576
    888a:	1d01      	jne	0x888e <_HandleDiagnosticEvent+0x96>
    888c:	0040      	jmp	0x890e <_HandleDiagnosticEvent+0x116>
	{
		/* Chip under- or over-voltage */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    888e:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    8890:	8c01      	cmp	AL, #1
    8892:	1903      	je	0x889a <_HandleDiagnosticEvent+0xa2>
    8894:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    8898:	1905      	je	0x88a4 <_HandleDiagnosticEvent+0xac>
    889a:	7eda 009b 	lod	X, #155
    889e:	0000      	nop
    88a0:	1bfe      	djnz	X, 0x889e <_HandleDiagnosticEvent+0xa6>
    88a2:	0001      	jmp	0x88a6 <_HandleDiagnosticEvent+0xae>
			NopDelay( DELAY_mPWM); /*lint !e522 */								/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
			GetVsupply();
		}
		else
		{
			MeasureVsupplyAndTemperature();
    88a4:	175e      	call	0x8762 <_MeasureVsupplyAndTemperature>
			GetVsupply();
    88a6:	16b5      	call	0x8612 <_GetVsupply>
		}
		{
			uint8 e8DiagVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
			if ( g_i16SupplyVoltage < (int16)((6 + NVRAM_BROWNOUT_LEVEL) * 100) )
    88a8:	6186      	lod	AL, dp:0x86 <_g_NvramUser+0x30>
    88aa:	44b2      	lsr	A, #2
    88ac:	44b2      	lsr	A, #2
    88ae:	44b2      	lsr	A, #2
    88b0:	b403      	and	A, #3
    88b2:	4872 0064 	muls	A, A, #100
    88b6:	a2da 0258 	add	A, #600
    88ba:	7ad8 010a 	lod	Y, 0x10a <_g_i16SupplyVoltage>
    88be:	eee2      	cmp	Y, A
    88c0:	1e85      	jsge	0x88cc <_HandleDiagnosticEvent+0xd4>
			{
				/* Chip under-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_UNDER;
    88c2:	7001      	lod	A, #1
    88c4:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_UNDER_VOLT);
    88c6:	72da 00d2 	lod	A, #210
    88ca:	0009      	jmp	0x88de <_HandleDiagnosticEvent+0xe6>
			}
			else if ( g_i16SupplyVoltage > 2800 )
    88cc:	72d8 010a 	lod	A, 0x10a <_g_i16SupplyVoltage>
    88d0:	aeda 0af0 	cmp	A, #2800
    88d4:	1b1c      	jsle	0x890e <_HandleDiagnosticEvent+0x116>
			{
				/* Chip over-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_OVER;
    88d6:	7002      	lod	A, #2
    88d8:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_OVER_VOLT);
    88da:	72da 00d3 	lod	A, #211
    88de:	1083      	call	0x89e6 <_SetLastError>
			}
			if ( e8DiagVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE)
			{
				g_e8ErrorVoltage = e8DiagVoltage;
    88e0:	6201      	lod	AL, [S-2]
    88e2:	4129      	mov	dp:0x29 <_g_e8ErrorVoltage>, AL
#if (LINPROT == LIN2X_ACT44)
				g_e8ErrorVoltageComm = g_e8ErrorVoltage;
#endif /* (LINPROT == LIN2X_ACT44) */
				if ( g_e8MotorRequest != C_MOTOR_REQUEST_NONE )
    88e4:	612b      	lod	AL, dp:0x2b <_g_e8MotorRequest>
    88e6:	1904      	je	0x88f0 <_HandleDiagnosticEvent+0xf8>
				{
					g_e8DegradedMotorRequest = g_e8MotorRequest;
    88e8:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
					g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    88ea:	6000      	lod	AL, #0
    88ec:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
    88ee:	0009      	jmp	0x8902 <_HandleDiagnosticEvent+0x10a>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )
    88f0:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    88f2:	8c01      	cmp	AL, #1
    88f4:	1d02      	jne	0x88fa <_HandleDiagnosticEvent+0x102>
				{
					/* Enter degraded-mode; Stop motor and resume when voltage decreases below upper-application threshold or raise above lower-application threshold */
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    88f6:	6003      	lod	AL, #3
    88f8:	0003      	jmp	0x8900 <_HandleDiagnosticEvent+0x108>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    88fa:	6123      	lod	AL, dp:0x23 <_g_e8DegradedMotorRequest>
    88fc:	1d05      	jne	0x8908 <_HandleDiagnosticEvent+0x110>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    88fe:	6001      	lod	AL, #1
    8900:	4123      	mov	dp:0x23 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Degraded-mode */
    8902:	7002      	lod	A, #2
    8904:	82db 9296 	callf	0x9296 <_MotorDriverStop>
				}
				g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    8908:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    890a:	8480      	or	AL, #-128
    890c:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
    890e:	5405      	ret	#6

00008910 <_DiagnosticsInit>:
 * Don't automatically shut-off motor-driver on over- or under-voltage, or over-temperature.
 * Diagnostic ISR priority: 3 
 * ****************************************************************************	*/
void DiagnosticsInit( void)
{
	DRVCFG = (DRVCFG | (DIS_OC | DIS_OT | DIS_OV | DIS_UV));					/* Disable over-current, over-temperature, over-voltage, under-voltage */
    8910:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8914:	a6da f000 	or	A, #61440
    8918:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	ANA_OUTI &= ~SEL_UV_VS;														/* Enable UV & OV debounce circuitry */
    891c:	72d8 28d0 	lod	A, 0x28d0 <__io__+0xd0>
    8920:	b6da efff 	and	A, #61439
    8924:	52d8 28d0 	mov	0x28d0 <__io__+0xd0>, A
	ANA_OUTG = (ANA_OUTG & 0xFCFF) | (NVRAM_BROWNOUT_LEVEL << 8);				/* Brown-out UV-level = 6V + n * 1V; */
    8928:	7ad8 28cc 	lod	Y, 0x28cc <__io__+0xcc>
    892c:	f6da fcff 	and	Y, #64767
    8930:	6186      	lod	AL, dp:0x86 <_g_NvramUser+0x30>
    8932:	44a2      	asl	A, #2
    8934:	b6da 0300 	and	A, #768
    8938:	e6e2      	or	Y, A
    893a:	5ad8 28cc 	mov	0x28cc <__io__+0xcc>, Y
	{
		/* IO[5] is low; Set IRQ-event on rising-edge */
		IO_CFG &= ~FRB_IO5;
	}
#else  /* (_SUPPORT_HALL_SENSOR) */
	XI4_PEND = C_DIAG_MASK;
    893e:	72da e100 	lod	A, #57600
    8942:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	XI4_MASK |= C_DIAG_MASK;
    8946:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    894a:	a6da e100 	or	A, #57600
    894e:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
#endif /* (_SUPPORT_HALL_SENSOR) */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */						/* EXT4_IT Priority: 3 (3..6) */
	PRIO = (PRIO & ~(3U << 14));												/* EXT4_IT Priority: 3 (3..6) */
    8952:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8956:	b6da 3fff 	and	A, #16383
    895a:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT4_IT;
    895e:	72da 1000 	lod	A, #4096
    8962:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    8966:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    896a:	a6da 1000 	or	A, #4096
    896e:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* Check for OVT and OV. Perform Diagnostics handling if required */
	{
#if (_SUPPORT_DIAG_OVT == FALSE)
		uint16 u16DiagnosticEvent = (ANA_INA & XI4_OV);
#else  /* (_SUPPORT_DIAG_OVT == FALSE) */
		uint16 u16DiagnosticEvent = (ANA_INA & (XI4_OVT | XI4_OV));
    8972:	729c      	lod	A, io:0x1c <_g_i16MotorVoltage>
    8974:	b6da a000 	and	A, #40960
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */
		if ( u16DiagnosticEvent != 0 )
    8978:	1901      	je	0x897c <_DiagnosticsInit+0x6c>
		{
			HandleDiagnosticEvent( u16DiagnosticEvent);
    897a:	173e      	call	0x87f8 <_HandleDiagnosticEvent>
    897c:	5401      	ret

0000897e <_EXT4_IT>:
 * EXT4_IT()
 *
 * Diagnostic & IO Interrupt Service Routine.
 * ****************************************************************************	*/
__interrupt__ void EXT4_IT(void)
{
    897e:	52df      	push	A
    8980:	5edf      	push	X
    8982:	5adf      	push	Y
    8984:	4c83      	push	D
	uint16 u16Pending = (XI4_PEND & XI4_MASK);									/* Copy interrupt requests which are not masked   */
    8986:	7ad8 203c 	lod	Y, 0x203c <__ep__+0x103c>
    898a:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    898e:	f6e2      	and	Y, A
	do
	{
		XI4_PEND = u16Pending;													/* Clear requests which are going to be processed */
    8990:	5ad8 203c 	mov	0x203c <__ep__+0x103c>, Y
	} while (XI4_PEND & u16Pending);
    8994:	72d8 203c 	lod	A, 0x203c <__ep__+0x103c>
    8998:	b6e6      	and	A, Y
    899a:	1d7a      	jne	0x8990 <_EXT4_IT+0x12>

	/* Multiple diagnostics events is most likely caused by Rinnen/ESD-pulse */
	if ( ((u16Pending & XI4_UV) != 0) && ((u16Pending & (XI4_OC_DRV | XI4_OVT | XI4_OV)) != 0) )
    899c:	72e6      	lod	A, Y
    899e:	b6da 4000 	and	A, #16384
    89a2:	1904      	je	0x89ac <_EXT4_IT+0x2e>
    89a4:	72e6      	lod	A, Y
    89a6:	b6da a100 	and	A, #41216
    89aa:	1d02      	jne	0x89b0 <_EXT4_IT+0x32>
	{
		/* Under-voltage together with any other diagnostic event is strange */
	}
	else
	{
		HandleDiagnosticEvent( u16Pending);
    89ac:	72e6      	lod	A, Y
    89ae:	1724      	call	0x87f8 <_HandleDiagnosticEvent>
    89b0:	4cc3      	pop	D
    89b2:	7acf      	pop	Y
    89b4:	7ecf      	pop	X
    89b6:	72cf      	pop	A
    89b8:	4407      	mov	R, #0
    89ba:	72cb      	pop	M
    89bc:	5401      	ret

000089be <_ErrorLogInit>:
 *
 *	Comments:	Clear Error-FiFo-buffer, in case watchdog reset occurred, 
 *				otherwise leave untouched.
 * ****************************************************************************	*/
void ErrorLogInit( void)
{
    89be:	5803      	inc	S, #4
	if ( (AWD_CTRL & AWD_RST) != 0U )
    89c0:	729a      	lod	A, io:0x1a <_g_u8StallTypeComm>
    89c2:	ac00      	cmp	A, #0
    89c4:	1e8f      	jsge	0x89e4 <_ErrorLogInit+0x26>
	{
		uint16 i;
		for ( i = 0U; i < C_ERR_LOG_SZ; i++ )
    89c6:	7000      	lod	A, #0
    89c8:	780a      	lod	Y, #10
    89ca:	5a01      	mov	[S-2], Y
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
    89cc:	7ee2      	lod	X, A
    89ce:	22da 0156 	add	X, #342
    89d2:	6400      	lod	YL, #0
    89d4:	46f8      	mov	[X], YL
void ErrorLogInit( void)
{
	if ( (AWD_CTRL & AWD_RST) != 0U )
	{
		uint16 i;
		for ( i = 0U; i < C_ERR_LOG_SZ; i++ )
    89d6:	a001      	add	A, #1
    89d8:	7e01      	lod	X, [S-2]
    89da:	20ff      	add	X, #-1
    89dc:	5e01      	mov	[S-2], X
    89de:	1d76      	jne	0x89cc <_ErrorLogInit+0xe>
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
		}
		l_u8ErrorLogIdx = 0U;
    89e0:	46d8 0122 	mov	0x122 <_l_u8ErrorLogIdx>, YL
    89e4:	5405      	ret	#6

000089e6 <_SetLastError>:
 *
 *	Comments:	Save error-code in Error-FiFo-buffer, unless last error is the 
 *				same as error posted.
 * ****************************************************************************	*/
void SetLastError( uint8 u8ErrorCode)
{
    89e6:	5803      	inc	S, #4
    89e8:	5203      	mov	[S-4], A
	if ( (l_u8ErrorLogIdx == 0U) || (l_au8FiFoErrorLog[l_u8ErrorLogIdx - 1U] != u8ErrorCode) )
    89ea:	62d8 0122 	lod	AL, 0x122 <_l_u8ErrorLogIdx>
    89ee:	4201      	mov	[S-2], AL
    89f0:	1907      	je	0x8a00 <_SetLastError+0x1a>
    89f2:	5cf2      	usex	A
    89f4:	7ae2      	lod	Y, A
    89f6:	e2da 0155 	add	Y, #341
    89fa:	62f0      	lod	AL, [Y]
    89fc:	8e03      	cmp	AL, [S-4]
    89fe:	190d      	je	0x8a1a <_SetLastError+0x34>
	{
		/* Don't log the same error over and over again */
		l_au8FiFoErrorLog[l_u8ErrorLogIdx] = u8ErrorCode;
    8a00:	6201      	lod	AL, [S-2]
    8a02:	5cf2      	usex	A
    8a04:	7ae2      	lod	Y, A
    8a06:	e2da 0156 	add	Y, #342
    8a0a:	6203      	lod	AL, [S-4]
    8a0c:	42f0      	mov	[Y], AL
		if ( l_u8ErrorLogIdx < (C_ERR_LOG_SZ - 1U) )
    8a0e:	6201      	lod	AL, [S-2]
    8a10:	8c08      	cmp	AL, #8
    8a12:	1e03      	jug	0x8a1a <_SetLastError+0x34>
		{
			l_u8ErrorLogIdx++;
    8a14:	8001      	add	AL, #1
    8a16:	42d8 0122 	mov	0x122 <_l_u8ErrorLogIdx>, AL
    8a1a:	5405      	ret	#6

00008a1c <_GetLastError>:
#endif /* _SUPPORT_LOG_NVRAM */
	}
} /* End of SetLastError() */

uint8 GetLastError( void)
{
    8a1c:	5809      	inc	S, #10
	uint8 u8Reply = l_au8FiFoErrorLog[0];
    8a1e:	62d8 0156 	lod	AL, 0x156 <_l_au8FiFoErrorLog>
    8a22:	5cf2      	usex	A
    8a24:	5209      	mov	[S-10], A
	if ( l_u8ErrorLogIdx != 0 )
    8a26:	62d8 0122 	lod	AL, 0x122 <_l_u8ErrorLogIdx>
    8a2a:	4207      	mov	[S-8], AL
    8a2c:	1924      	je	0x8a76 <_GetLastError+0x5a>
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8a2e:	72e3      	lod	A, M
    8a30:	5203      	mov	[S-4], A
	{
		uint16 i;
		ATOMIC_CODE
    8a32:	4407      	mov	R, #0
    8a34:	500c      	call	fp0:0x60
    8a36:	54f0      	mov	UPr, #0
    8a38:	7001      	lod	A, #1
    8a3a:	5205      	mov	[S-6], A
    8a3c:	6207      	lod	AL, [S-8]
    8a3e:	5cf2      	usex	A
    8a40:	5201      	mov	[S-2], A
    8a42:	7001      	lod	A, #1
    8a44:	ae01      	cmp	A, [S-2]
    8a46:	1c0b      	jnc	0x8a5e <_GetLastError+0x42>
    8a48:	7a05      	lod	Y, [S-6]
    8a4a:	e2da 0156 	add	Y, #342
    8a4e:	7ee6      	lod	X, Y
    8a50:	20ff      	add	X, #-1
    8a52:	62f0      	lod	AL, [Y]
    8a54:	42f8      	mov	[X], AL
    8a56:	7205      	lod	A, [S-6]
    8a58:	a001      	add	A, #1
    8a5a:	5205      	mov	[S-6], A
    8a5c:	07f3      	jmp	0x8a44 <_GetLastError+0x28>
    8a5e:	6207      	lod	AL, [S-8]
    8a60:	80ff      	add	AL, #-1
    8a62:	42d8 0122 	mov	0x122 <_l_u8ErrorLogIdx>, AL
    8a66:	5cf2      	usex	A
    8a68:	7ae2      	lod	Y, A
    8a6a:	e2da 0156 	add	Y, #342
    8a6e:	6000      	lod	AL, #0
    8a70:	42f0      	mov	[Y], AL
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8a72:	7203      	lod	A, [S-4]
    8a74:	52e3      	mov	M, A
			l_u8ErrorLogIdx--;
			l_au8FiFoErrorLog[l_u8ErrorLogIdx] = C_ERR_NONE;
		);
	}
	return ( u8Reply );
} /* End of GetLastError() */
    8a76:	7209      	lod	A, [S-10]
    8a78:	540b      	ret	#12

00008a7a <_MotorDriverInit>:
 * MotorDriverInit()
 *
 * Initialise Motor Driver
 * ****************************************************************************	*/
void MotorDriverInit( void)
{
    8a7a:	5835      	inc	S, #54
#if _SUPPORT_DOUBLE_USTEP
	uint16 u16MotorMicroStepsPerFullStep = (1U << (NVRAM_MICRO_STEPS + 1U));	/* Number of micro-steps per full-step (2, 4, 8 or 16) */
    8a7c:	618a      	lod	AL, dp:0x8a <_g_NvramUser+0x34>
    8a7e:	4233      	mov	[S-52], AL
    8a80:	44b0      	lsr	AL, #2
    8a82:	44b0      	lsr	AL, #2
    8a84:	4430      	lsr	AL
    8a86:	b403      	and	A, #3
    8a88:	a001      	add	A, #1
    8a8a:	44e2      	sfb	A
    8a8c:	5235      	mov	[S-54], A
    8a8e:	6233      	lod	AL, [S-52]
    8a90:	4440      	rl	AL
    8a92:	9401      	and	AL, #1
    8a94:	5cf2      	usex	A
    8a96:	7ae2      	lod	Y, A
    8a98:	e002      	add	Y, #2
    8a9a:	4426      	asl	Y
    uint32 result;

    __asm__ __volatile__ (
    8a9c:	7235      	lod	A, [S-54]
    8a9e:	4801      	mulu	D, A, Y
    8aa0:	72ef      	lod	A, S
    8aa2:	a0ce      	add	A, #-50
    8aa4:	4cf3      	swap	YA
    8aa6:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8aa8:	7a31      	lod	Y, [S-50]
    8aaa:	5ad8 0162 	mov	0x162 <__bss_size>, Y
    8aae:	6189      	lod	AL, dp:0x89 <_g_NvramUser+0x33>
    8ab0:	44b2      	lsr	A, #2
    8ab2:	44b2      	lsr	A, #2
    8ab4:	b40f      	and	A, #15
    8ab6:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    8ab8:	4801      	mulu	D, A, Y
    8aba:	7aef      	lod	Y, S
    8abc:	e0d2      	add	Y, #-46
    8abe:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8ac0:	7e2d      	lod	X, [S-46]
    8ac2:	5ed8 0164 	mov	0x164 <_g_u16MotorMicroStepsPerMechRotation>, X
	uint16 u16MotorMicroStepsPerFullStep = (1U << NVRAM_MICRO_STEPS);			/* Number of micro-steps per full-step (1, 2, 4 or 8) */
#endif /* _SUPPORT_DOUBLE_USTEP */
	g_u16MotorMicroStepsPerElecRotation = (uint16) mulU32_U16byU16( u16MotorMicroStepsPerFullStep, (NVRAM_MOTOR_PHASES + 2) << 1);
	g_u16MotorMicroStepsPerMechRotation = (uint16) mulU32_U16byU16( NVRAM_POLE_PAIRS, g_u16MotorMicroStepsPerElecRotation);
	{
		uint16 u16ConstAccelaration = NVRAM_ACCELERATION_CONST;
    8ac6:	719e      	lod	A, dp:0x9e <_g_NvramUser+0x48>
		if ( u16ConstAccelaration != 0U )
    8ac8:	1d01      	jne	0x8acc <_MotorDriverInit+0x52>
    8aca:	0085      	jmp	0x8bd6 <_MotorDriverInit+0x15c>
		{
			l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    8acc:	722d      	lod	A, [S-46]
    8ace:	52df      	push	A
    8ad0:	4ce2 2c40 	mov	YA, #105000000
    8ad4:	0642 
    8ad6:	82db 6c2a 	callf	0x6c2a <_divU32_U32byU16>
    8ada:	4cc0      	mov	D, YA
    8adc:	52d8 020c 	mov	0x20c <_l_u32Temp>, A
    8ae0:	5ad8 020e 	mov	0x20e <_l_u32Temp+0x2>, Y
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8ae4:	5c01      	dec	S, #2
    8ae6:	799c      	lod	Y, dp:0x9c <_g_NvramUser+0x46>
    8ae8:	5a29      	mov	[S-42], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8aea:	4c80      	mov	YA, D
    8aec:	7e29      	lod	X, [S-42]
    8aee:	4c63      	divu	YA, X
    8af0:	4c63      	divu	YA, X
    8af2:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8af4:	a0ff      	add	A, #-1
    8af6:	52d8 0176 	mov	0x176 <_g_au16MotorSpeedCommutTimerPeriod+0xe>, A
    8afa:	52d8 0168 	mov	0x168 <_g_au16MotorSpeedCommutTimerPeriod>, A
    8afe:	79c0      	lod	Y, dp:0xc0 <__bss_dp_size+0x10>
    8b00:	5a25      	mov	[S-38], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b02:	4c80      	mov	YA, D
    8b04:	7e25      	lod	X, [S-38]
    8b06:	4c63      	divu	YA, X
    8b08:	4c63      	divu	YA, X
    8b0a:	5223      	mov	[S-36], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b0c:	a0ff      	add	A, #-1
    8b0e:	52d8 0174 	mov	0x174 <_g_au16MotorSpeedCommutTimerPeriod+0xc>, A
    8b12:	52d8 016a 	mov	0x16a <_g_au16MotorSpeedCommutTimerPeriod+0x2>, A
    8b16:	798c      	lod	Y, dp:0x8c <_g_NvramUser+0x36>
    8b18:	5a1f      	mov	[S-32], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b1a:	4c80      	mov	YA, D
    8b1c:	7e1f      	lod	X, [S-32]
    8b1e:	4c63      	divu	YA, X
    8b20:	4c63      	divu	YA, X
    8b22:	521d      	mov	[S-30], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b24:	a0ff      	add	A, #-1
    8b26:	514e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, A
    8b28:	52d8 016c 	mov	0x16c <_g_au16MotorSpeedCommutTimerPeriod+0x4>, A
    8b2c:	798e      	lod	Y, dp:0x8e <_g_NvramUser+0x38>
    8b2e:	5a19      	mov	[S-26], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b30:	4c80      	mov	YA, D
    8b32:	7e19      	lod	X, [S-26]
    8b34:	4c63      	divu	YA, X
    8b36:	4c63      	divu	YA, X
    8b38:	5217      	mov	[S-24], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b3a:	a0ff      	add	A, #-1
    8b3c:	52d8 016e 	mov	0x16e <_g_au16MotorSpeedCommutTimerPeriod+0x6>, A
    8b40:	7990      	lod	Y, dp:0x90 <_g_NvramUser+0x3a>
    8b42:	5a13      	mov	[S-20], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b44:	4c80      	mov	YA, D
    8b46:	7e13      	lod	X, [S-20]
    8b48:	4c63      	divu	YA, X
    8b4a:	4c63      	divu	YA, X
    8b4c:	5211      	mov	[S-18], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b4e:	a0ff      	add	A, #-1
    8b50:	52d8 0170 	mov	0x170 <_g_au16MotorSpeedCommutTimerPeriod+0x8>, A
    8b54:	7992      	lod	Y, dp:0x92 <_g_NvramUser+0x3c>
    8b56:	5a0d      	mov	[S-14], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b58:	4c80      	mov	YA, D
    8b5a:	7e0d      	lod	X, [S-14]
    8b5c:	4c63      	divu	YA, X
    8b5e:	4c63      	divu	YA, X
    8b60:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b62:	a0ff      	add	A, #-1
    8b64:	52d8 0172 	mov	0x172 <_g_au16MotorSpeedCommutTimerPeriod+0xa>, A
			g_au16MotorSpeedCommutTimerPeriod[3] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED1) - 1U;
			g_au16MotorSpeedCommutTimerPeriod[4] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED2) - 1U;
			g_au16MotorSpeedCommutTimerPeriod[5] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED3) - 1U;
			g_au16MotorSpeedCommutTimerPeriod[6] = g_au16MotorSpeedCommutTimerPeriod[1];
			g_au16MotorSpeedCommutTimerPeriod[7] = g_au16MotorSpeedCommutTimerPeriod[0];
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[2];	/* Target commutation timer period (target speed) */
    8b68:	794e      	lod	Y, dp:0x4e <_g_u16CommutTimerPeriod>
    8b6a:	5950      	mov	dp:0x50 <__data_size>, Y
    8b6c:	7229      	lod	A, [S-42]
    8b6e:	a01e      	add	A, #30
    8b70:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b72:	4c80      	mov	YA, D
    8b74:	7c3c      	lod	X, #60
    8b76:	4c63      	divu	YA, X
    8b78:	4c63      	divu	YA, X
    8b7a:	520b      	mov	[S-12], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b7c:	52d8 0178 	mov	0x178 <_g_au16MotorSpeedRPS>, A
    8b80:	7225      	lod	A, [S-38]
    8b82:	a01e      	add	A, #30
    8b84:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b86:	4c80      	mov	YA, D
    8b88:	4c63      	divu	YA, X
    8b8a:	4c63      	divu	YA, X
    8b8c:	5209      	mov	[S-10], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b8e:	52d8 017a 	mov	0x17a <_g_au16MotorSpeedRPS+0x2>, A
    8b92:	721f      	lod	A, [S-32]
    8b94:	a01e      	add	A, #30
    8b96:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8b98:	4c63      	divu	YA, X
    8b9a:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8b9c:	52d8 017c 	mov	0x17c <_g_au16MotorSpeedRPS+0x4>, A
    8ba0:	7219      	lod	A, [S-26]
    8ba2:	a01e      	add	A, #30
    8ba4:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8ba6:	4c63      	divu	YA, X
    8ba8:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8baa:	52d8 017e 	mov	0x17e <_g_au16MotorSpeedRPS+0x6>, A
    8bae:	7213      	lod	A, [S-20]
    8bb0:	a01e      	add	A, #30
    8bb2:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8bb4:	4c63      	divu	YA, X
    8bb6:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8bb8:	52d8 0180 	mov	0x180 <_g_au16MotorSpeedRPS+0x8>, A
    8bbc:	720d      	lod	A, [S-14]
    8bbe:	a01e      	add	A, #30
    8bc0:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8bc2:	4c63      	divu	YA, X
    8bc4:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8bc6:	52d8 0182 	mov	0x182 <_g_au16MotorSpeedRPS+0xa>, A
			g_au16MotorSpeedRPS[1] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED_TORQUE_BOOST + 30U), 60U);
			g_au16MotorSpeedRPS[2] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED0 + 30U), 60U);
			g_au16MotorSpeedRPS[3] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED1 + 30U), 60U);
			g_au16MotorSpeedRPS[4] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED2 + 30U), 60U);
			g_au16MotorSpeedRPS[5] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60U);
			g_au16MotorSpeedRPS[6] = g_au16MotorSpeedRPS[1];
    8bca:	7a09      	lod	Y, [S-10]
    8bcc:	5ad8 0184 	mov	0x184 <_g_au16MotorSpeedRPS+0xc>, Y
			g_au16MotorSpeedRPS[7] = g_au16MotorSpeedRPS[0];
    8bd0:	7e0b      	lod	X, [S-12]
    8bd2:	5ed8 0186 	mov	0x186 <_g_au16MotorSpeedRPS+0xe>, X
		}
	}

	g_u16CorrectionRatio = NVRAM_MIN_CORR_RATIO;
    8bd6:	61ba      	lod	AL, dp:0xba <__bss_dp_size+0xa>
    8bd8:	5cf2      	usex	A
    8bda:	4832 0618 	muls	YA, A, #1560
    8bde:	48a3      	lsr	YA, #4
    8be0:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
	/* BLDC motor Commutation/Stepper timer */
	g_u16MicroStepIdx = 0U;
    8be2:	7000      	lod	A, #0
    8be4:	514c      	mov	dp:0x4c <_g_u16MicroStepIdx>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0;												/* Timer mode 0 */
    8be6:	7ada 4001 	lod	Y, #16385
    8bea:	5aaa      	mov	io:0x2a <_g_e8ErrorElectric>, Y
	TMR1_REGB = g_u16CommutTimerPeriod;											/* Will be overwritten by MotorDriverStart() */
    8bec:	714e      	lod	A, dp:0x4e <_g_u16CommutTimerPeriod>
    8bee:	52ac      	mov	io:0x2c <_g_u8BufferOutID>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    8bf0:	7c40      	lod	X, #64
    8bf2:	5ed8 2034 	mov	0x2034 <__ep__+0x1034>, X
	XI0_MASK |= EN_T1_INT4;														/* Enable Timer1, CompareB (T1_INT4) */
    8bf6:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    8bfa:	a440      	or	A, #64
    8bfc:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	PRIO = (PRIO & ~(3U << 6)) | ((4U - 3U) << 6);								/* Set Timer1 priority to 4 (3..6) */
    8c00:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8c04:	b6da ff3f 	and	A, #65343
    8c08:	a440      	or	A, #64
    8c0a:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT0_IT;
    8c0e:	72da 0100 	lod	A, #256
    8c12:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT0_IT;
    8c16:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    8c1a:	a6da 0100 	or	A, #256
    8c1e:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8c22:	61be      	lod	AL, dp:0xbe <__bss_dp_size+0xe>
    8c24:	5cf2      	usex	A
    uint32 result;

    __asm__ __volatile__ (
    8c26:	7a35      	lod	Y, [S-54]
    8c28:	4801      	mulu	D, A, Y
    8c2a:	7aef      	lod	Y, S
    8c2c:	e0fa      	add	Y, #-6
    8c2e:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8c30:	7e05      	lod	X, [S-6]
    8c32:	5ed8 0166 	mov	0x166 <_g_u16MotorRewindSteps>, X

	g_u16MotorRewindSteps = (uint16) mulU32_U16byU16( NVRAM_REWIND_STEPS, u16MotorMicroStepsPerFullStep);

	/* Setup Motor PWM */	
	PWM1_CTRL = 0U;																/* Disable master */
    8c36:	6000      	lod	AL, #0
    8c38:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = 0U;																/* Disable Slave 1 */
    8c3c:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = 0U;																/* Disable Slave 2 */
    8c40:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = 0U;																/* Disable Slave 3 */
    8c44:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = 0U;																/* Disable Slave 4 */
    8c48:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
	PWM1_PSCL = PWM_PRESCALER;													/* Initialise the master pre-scaler ratio (Fck/8) */
    8c4c:	42d8 284b 	mov	0x284b <__io__+0x4b>, AL
	PWM1_PER = PWM_REG_PERIOD;
    8c50:	7ada 0618 	lod	Y, #1560
    8c54:	5ad8 284c 	mov	0x284c <__io__+0x4c>, Y
	PWM2_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8c58:	5ad8 2856 	mov	0x2856 <__io__+0x56>, Y
	PWM3_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8c5c:	5ad8 2860 	mov	0x2860 <__io__+0x60>, Y
	PWM4_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8c60:	5ad8 286a 	mov	0x286a <__io__+0x6a>, Y
	PWM5_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8c64:	5ad8 2874 	mov	0x2874 <__io__+0x74>, Y
	PWM5_CMP = (((83UL * PWM_REG_PERIOD) + 50U)/100U);	/*  7.0us */			/* 83% of period */
#else  /* _SUPPORT_PHASE_SHORT_DET */
	/* (Single PWM)	17%			33%			50%			75%			100%		(7.0us/ADC-conversion)
	 * MF_STEPPER:	Temperature	Vs-filt		Imotor1		Vsm-unfilt	Imotor2
	 */
	PWM1_CMP = (((17UL * PWM_REG_PERIOD) + 50U)/100U);	/*  7.0us */			/* 17% of period */
    8c68:	7eda 0109 	lod	X, #265
    8c6c:	5ed8 2852 	mov	0x2852 <__io__+0x52>, X
	PWM2_CMP = (((33UL * PWM_REG_PERIOD) + 50U)/100U);	/*  7.0us */			/* 33% of period */
    8c70:	72da 0203 	lod	A, #515
    8c74:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
	PWM3_CMP = (((50UL * PWM_REG_PERIOD) + 50U)/100U);	/*  10.5us */			/* 50% of period */
    8c78:	7ada 030c 	lod	Y, #780
    8c7c:	5ad8 2866 	mov	0x2866 <__io__+0x66>, Y
	PWM4_CMP = (((75UL * PWM_REG_PERIOD) + 50U)/100U);	/*  10.5us */			/* 75% of period */
    8c80:	7eda 0492 	lod	X, #1170
    8c84:	5ed8 2870 	mov	0x2870 <__io__+0x70>, X
	PWM3_CTRL = ((uint8) MODE | (uint8) ECI | (uint8) EXT | (uint8) EBLK);		/* Initialise the slave 2 control register - CMPI enabled */
	PWM4_CTRL = ((uint8) MODE | (uint8) ECI | (uint8) EXT | (uint8) EBLK);		/* Initialise the slave 3 control register - CMPI enabled */
	PWM5_CTRL = ((uint8) MODE | (uint8) EXT | (uint8) EBLK);					/* Initialise the slave 4 control register - CMPI disabled */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	/* In-depended mode */
	PWM1_CTRL = ((uint8) EBLK | (uint8) ECI | (uint8) EPI);						/* Initialise the master control register - CMPI and PWMI enabled */
    8c88:	6019      	lod	AL, #25
    8c8a:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = ((uint8) ECI | (uint8) EXT | (uint8) EBLK);						/* Initialise the slave 1 control register - CMPI enabled */
    8c8e:	6013      	lod	AL, #19
    8c90:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = ((uint8) ECI | (uint8) EXT | (uint8) EBLK);						/* Initialise the slave 2 control register - CMPI enabled */
    8c94:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = ((uint8) ECI | (uint8) EXT | (uint8) EBLK);						/* Initialise the slave 3 control register - CMPI enabled */
    8c98:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = ((uint8) ECI | (uint8) EXT | (uint8) EBLK);						/* Initialise the slave 4 control register - CMPI enabled */
    8c9c:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	PWM1_CTRL |= EBLK;															/* Start PWM in application mode */
    8ca0:	62d8 284a 	lod	AL, 0x284a <__io__+0x4a>
    8ca4:	8401      	or	AL, #1
    8ca6:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
    8caa:	5437      	ret	#56

00008cac <_MotorDriverSelfTest>:
 * 3. Test Open connection with motor-phase
 * 4. Test BEMF Voltage levels
 * ****************************************************************************	*/
#define FET_SETTING (((10U*PLL_freq)/(1000000UL*CYCLES_PER_INSTR*2U)) + 1U)			/* 10us: 10us*PLL-freq/(10000000us/s * #cycles/instruction) * instructions */
void MotorDriverSelfTest( void)
{
    8cac:	5827      	inc	S, #40
	uint16 u16SelfTestIdx;
	uint16 u16VdsThreshold;
	T_ADC_SELFTEST_4PH adcMotorSelfTest4Ph;
	uint16 u16Pwm2Storage = PWM2_CMP;											/* Save PWM2 ADC trigger CMP time */
    8cae:	72d8 285c 	lod	A, 0x285c <__io__+0x5c>
    8cb2:	520d      	mov	[S-14], A
	PWM2_CMP = (((50UL * PWM_REG_PERIOD) + 50U)/100U);							/* Set PWM2 ADC trigger CMP time at 50% or period */
    8cb4:	7eda 030c 	lod	X, #780
    8cb8:	5ed8 285c 	mov	0x285c <__io__+0x5c>, X

	MeasureVsupplyAndTemperature();
    8cbc:	1552      	call	0x8762 <_MeasureVsupplyAndTemperature>
	GetVsupplyMotor();
    8cbe:	14c7      	call	0x864e <_GetVsupplyMotor>
	if ( NVRAM_VDS_THRESHOLD != 0U )
    8cc0:	61c5      	lod	AL, dp:0xc5 <__bss_dp_size+0x15>
    8cc2:	b43f      	and	A, #63
    8cc4:	4872 0019 	muls	A, A, #25
    8cc8:	4432      	lsr	A
    8cca:	1916      	je	0x8cf8 <_MotorDriverSelfTest+0x4c>
    8ccc:	0017      	jmp	0x8cfc <_MotorDriverSelfTest+0x50>
		DRVCFG_GND_UVWT();

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
		{
			/* Over-current trigger; Phase makes short with other phase */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8cce:	6002      	lod	AL, #2
    8cd0:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_B);
    8cd2:	72da 00eb 	lod	A, #235
    8cd6:	000e      	jmp	0x8cf4 <_MotorDriverSelfTest+0x48>
		{
			u16Vds = u16VphH - u16Vsm;
		}
		if ( u16Vds > u16VdsThreshold )
		{
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8cd8:	6002      	lod	AL, #2
    8cda:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_D);
    8cdc:	72da 00ed 	lod	A, #237
    8ce0:	0009      	jmp	0x8cf4 <_MotorDriverSelfTest+0x48>
			break;
		}
		if ( u16VphL > u16VdsThreshold )
		{
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8ce2:	6002      	lod	AL, #2
    8ce4:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_E);
    8ce6:	72da 00ee 	lod	A, #238
    8cea:	0004      	jmp	0x8cf4 <_MotorDriverSelfTest+0x48>
			break;
		}
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
		{
			/* No current (less than 10 LSB's); Coil Open */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8cec:	6002      	lod	AL, #2
    8cee:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_C);
    8cf0:	72da 00ec 	lod	A, #236
    8cf4:	1678      	call	0x89e6 <_SetLastError>
			break;
    8cf6:	00df      	jmp	0x8eb6 <_MotorDriverSelfTest+0x20a>
	{
		u16VdsThreshold = NVRAM_VDS_THRESHOLD;
	}
	else
	{
		u16VdsThreshold = 200U;
    8cf8:	72da 00c8 	lod	A, #200
    8cfc:	520f      	mov	[S-16], A
	}

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    8cfe:	7000      	lod	A, #0
    8d00:	5211      	mov	[S-18], A
    8d02:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8d04:	1901      	je	0x8d08 <_MotorDriverSelfTest+0x5c>
    8d06:	003b      	jmp	0x8d7e <_MotorDriverSelfTest+0xd2>
	{
		int16 i16DriverCurrent = 0;
    8d08:	7000      	lod	A, #0
    8d0a:	520b      	mov	[S-12], A

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestA[u16SelfTestIdx]);
    8d0c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d10:	b6da fe00 	and	A, #65024
    8d14:	7a11      	lod	Y, [S-18]
    8d16:	e2da a21e 	add	Y, #41502
    8d1a:	66f0      	lod	YL, [Y]
    8d1c:	5cf6      	usex	Y
    8d1e:	a6e6      	or	A, Y
    8d20:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		MeasurePhaseVoltage( (uint16)c_au16DrvAdcSelfTestA[u16SelfTestIdx>>1]);
    8d24:	7211      	lod	A, [S-18]
    8d26:	4432      	lsr	A
    8d28:	44a2      	asl	A, #2
    8d2a:	a2da a20e 	add	A, #41486
    8d2e:	154c      	call	0x87c8 <_MeasurePhaseVoltage>
		if ( (u16SelfTestIdx & 1U) == 0U )
    8d30:	7211      	lod	A, [S-18]
    8d32:	b401      	and	A, #1
    8d34:	5209      	mov	[S-10], A
    8d36:	1d03      	jne	0x8d3e <_MotorDriverSelfTest+0x92>
		{
			/* Even-index (0,2,4,6) are phase to ground: Check current too (< 20 mA) */
			MeasureMotorCurrent();
    8d38:	152b      	call	0x8790 <_MeasureMotorCurrent>
			i16DriverCurrent = GetMotorDriverCurrent();
    8d3a:	1509      	call	0x874e <_GetMotorDriverCurrent>
    8d3c:	520b      	mov	[S-12], A
		}
		/* Even-index (0,2,4,6) are phase to ground: Vphase < Vds; Odd-index (1,3,5,7) are phase to supply: Vphase > (Vsup - Vds) */
		if ( (g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO) ||
    8d3e:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8d40:	1d10      	jne	0x8d62 <_MotorDriverSelfTest+0xb6>
    8d42:	7209      	lod	A, [S-10]
    8d44:	1d08      	jne	0x8d56 <_MotorDriverSelfTest+0xaa>
    8d46:	72d8 0108 	lod	A, 0x108 <_g_i16PhaseVoltage>
    8d4a:	ae0f      	cmp	A, [S-16]
    8d4c:	1f0a      	jsg	0x8d62 <_MotorDriverSelfTest+0xb6>
    8d4e:	7e0b      	lod	X, [S-12]
    8d50:	2c14      	cmp	X, #20
    8d52:	1f07      	jsg	0x8d62 <_MotorDriverSelfTest+0xb6>
    8d54:	000c      	jmp	0x8d6e <_MotorDriverSelfTest+0xc2>
    8d56:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    8d58:	aa0f      	sub	A, [S-16]
    8d5a:	7ad8 0108 	lod	Y, 0x108 <_g_i16PhaseVoltage>
    8d5e:	eee2      	cmp	Y, A
    8d60:	1e86      	jsge	0x8d6e <_MotorDriverSelfTest+0xc2>
			(((u16SelfTestIdx & 1U) == 0U) && ((g_i16PhaseVoltage > (int16)u16VdsThreshold) || (i16DriverCurrent > 20))) ||
			(((u16SelfTestIdx & 1U) != 0U) && (g_i16PhaseVoltage < (int16)(g_i16MotorVoltage - u16VdsThreshold))) )
		{
			/* Over-current trigger; Phase makes short with supply or Ground */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8d62:	6002      	lod	AL, #2
    8d64:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
			SetLastError( (uint8) C_ERR_SELFTEST_A);
    8d66:	72da 00ea 	lod	A, #234
    8d6a:	163d      	call	0x89e6 <_SetLastError>
			break;
    8d6c:	0008      	jmp	0x8d7e <_MotorDriverSelfTest+0xd2>
	{
		u16VdsThreshold = 200U;
	}

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    8d6e:	7211      	lod	A, [S-18]
    8d70:	a001      	add	A, #1
    8d72:	5211      	mov	[S-18], A
    8d74:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8d76:	1d03      	jne	0x8d7e <_MotorDriverSelfTest+0xd2>
    8d78:	7211      	lod	A, [S-18]
    8d7a:	ac07      	cmp	A, #7
    8d7c:	1a45      	jule	0x8d08 <_MotorDriverSelfTest+0x5c>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8d7e:	7840      	lod	Y, #64
    8d80:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8d84:	6000      	lod	AL, #0
    8d86:	72e4      	swap	A
    8d88:	5201      	mov	[S-2], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8d8a:	720f      	lod	A, [S-16]
    8d8c:	7e01      	lod	X, [S-2]
    8d8e:	4821      	mulu	YA, A, Y
    8d90:	4c63      	divu	YA, X
    8d92:	4c63      	divu	YA, X
    8d94:	5207      	mov	[S-8], A
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0U; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    8d96:	7000      	lod	A, #0
    8d98:	5211      	mov	[S-18], A
    8d9a:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8d9c:	1901      	je	0x8da0 <_MotorDriverSelfTest+0xf4>
    8d9e:	008b      	jmp	0x8eb6 <_MotorDriverSelfTest+0x20a>
		uint16 u16VphH;
		uint16 u16VphL;
		uint16 u16Vds;
		uint16 u16MotorCoilCurrent;
		register uint16 u16DC;
		if ( (u16SelfTestIdx & 0x02U) != 0U )
    8da0:	7211      	lod	A, [S-18]
    8da2:	b402      	and	A, #2
    8da4:	5203      	mov	[S-4], A
    8da6:	1903      	je	0x8dae <_MotorDriverSelfTest+0x102>
		{
			/* Phase LOW + phase -PWM */
			u16DC = (PWM_REG_PERIOD >> 3);
    8da8:	7ada 00c3 	lod	Y, #195
    8dac:	0002      	jmp	0x8db2 <_MotorDriverSelfTest+0x106>
		}
		else
		{
			/* Phase HIGH + phase PWM */
			u16DC = PWM_REG_PERIOD - (PWM_REG_PERIOD >> 3);						/* Approx. 12.5% */
    8dae:	7ada 0555 	lod	Y, #1365
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
		u16DC = u16DC/2U;
    8db2:	4436      	lsr	Y
		PWM2_LT = u16DC;														/* Copy the results into the PWM register for phase U */
    8db4:	5ad8 2858 	mov	0x2858 <__io__+0x58>, Y
		PWM2_HT = PWM_REG_PERIOD - u16DC;
    8db8:	72da 0618 	lod	A, #1560
    8dbc:	aae6      	sub	A, Y
    8dbe:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
    8dc2:	5ad8 2862 	mov	0x2862 <__io__+0x62>, Y
		PWM3_HT = PWM_REG_PERIOD - u16DC;
    8dc6:	52d8 2864 	mov	0x2864 <__io__+0x64>, A
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
    8dca:	5ad8 286c 	mov	0x286c <__io__+0x6c>, Y
		PWM4_HT = PWM_REG_PERIOD - u16DC;
    8dce:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
    8dd2:	5ad8 2876 	mov	0x2876 <__io__+0x76>, Y
		PWM5_HT = PWM_REG_PERIOD - u16DC;
    8dd6:	52d8 2878 	mov	0x2878 <__io__+0x78>, A
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
    8dda:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestB4[u16SelfTestIdx]);
    8dde:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8de2:	b6da fe00 	and	A, #65024
    8de6:	7a11      	lod	Y, [S-18]
    8de8:	e2da a204 	add	Y, #41476
    8dec:	66f0      	lod	YL, [Y]
    8dee:	5cf6      	usex	Y
    8df0:	a6e6      	or	A, Y
    8df2:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		ADC_Stop();																/* clear the ADC control register */
    8df6:	82db 840c 	callf	0x840c <_ADC_Stop>
		if ( (u16SelfTestIdx & 2U) != 0U )
    8dfa:	7203      	lod	A, [S-4]
    8dfc:	1904      	je	0x8e06 <_MotorDriverSelfTest+0x15a>
		{
			ADC_SBASE = (uint16) tAdcSelfTest4B;								/* Phase = Low */
    8dfe:	7eda a0f0 	lod	X, #41200
    8e02:	5e92      	mov	io:0x12 <__dp_noinit_size+0x2>, X
    8e04:	0003      	jmp	0x8e0c <_MotorDriverSelfTest+0x160>
		}
		else
		{
			ADC_SBASE = (uint16) tAdcSelfTest4A;								/* Phase = High */
    8e06:	72da a108 	lod	A, #41224
    8e0a:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
		}
		ADC_DBASE = (uint16) &adcMotorSelfTest4Ph;
    8e0c:	7eef      	lod	X, S
    8e0e:	20d8      	add	X, #-40
    8e10:	5e94      	mov	io:0x14 <__dp_noinit_size+0x4>, X
		ADC_CTRL |= (ADC_TRIG_SRC | ADC_SYNC_SOC);								/* Single cycle of conversion is done */
    8e12:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e14:	a6da 0082 	or	A, #130
    8e18:	5290      	mov	io:0x10 <__dp_noinit_size>, A
		ADC_CTRL |= ADC_START;													/* Start ADC */
    8e1a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e1c:	a401      	or	A, #1
    8e1e:	5290      	mov	io:0x10 <__dp_noinit_size>, A

		/* This takes about 4 Motor PWM-periods per self-test */
		while ((ADC_CTRL & ADC_START) != 0U) {}									/* Wait for ADC result (Time-out?) */
    8e20:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e22:	b401      	and	A, #1
    8e24:	1d7d      	jne	0x8e20 <_MotorDriverSelfTest+0x174>

		DRVCFG_GND_UVWT();
    8e26:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8e2a:	b6da fe00 	and	A, #65024
    8e2e:	a6da 00aa 	or	A, #170
    8e32:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
    8e36:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8e38:	1901      	je	0x8e3c <_MotorDriverSelfTest+0x190>
    8e3a:	0749      	jmp	0x8cce <_MotorDriverSelfTest+0x22>
    8e3c:	7eef      	lod	X, S
    8e3e:	20ea      	add	X, #-22
    8e40:	7a11      	lod	Y, [S-18]
    8e42:	f4fd      	and	Y, #-3
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
			SetLastError( C_ERR_SELFTEST_B);
			break;
		}

		if ( (u16SelfTestIdx & 2U) != 0U )
    8e44:	7203      	lod	A, [S-4]
    8e46:	1904      	je	0x8e50 <_MotorDriverSelfTest+0x1a4>
		{
			/* Use tAdcSelfTest4B */
			u16Vsm = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;				/* Current becomes voltage */
    8e48:	7213      	lod	A, [S-20]
    8e4a:	5201      	mov	[S-2], A
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
    8e4c:	72f8      	lod	A, [X]
    8e4e:	0003      	jmp	0x8e56 <_MotorDriverSelfTest+0x1aa>
		}
		else
		{
			/* Use tAdcSelfTest4A */
			u16Vsm = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
    8e50:	72f8      	lod	A, [X]
    8e52:	5201      	mov	[S-2], A
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;
    8e54:	7213      	lod	A, [S-20]
    8e56:	5205      	mov	[S-6], A
		}

		switch ( u16SelfTestIdx & ~2 )
    8e58:	ec04      	cmp	Y, #4
    8e5a:	190c      	je	0x8e74 <_MotorDriverSelfTest+0x1c8>
    8e5c:	1e03      	jug	0x8e64 <_MotorDriverSelfTest+0x1b8>
    8e5e:	ec01      	cmp	Y, #1
    8e60:	1906      	je	0x8e6e <_MotorDriverSelfTest+0x1c2>
    8e62:	0002      	jmp	0x8e68 <_MotorDriverSelfTest+0x1bc>
    8e64:	ec05      	cmp	Y, #5
    8e66:	1909      	je	0x8e7a <_MotorDriverSelfTest+0x1ce>
		{
		default:
		case 0:
			u16VphH = adcMotorSelfTest4Ph.PhaseU_HighVoltage;
    8e68:	7a25      	lod	Y, [S-38]
			u16VphL = adcMotorSelfTest4Ph.PhaseU_LowVoltage;
    8e6a:	7e23      	lod	X, [S-36]
			break;
    8e6c:	0008      	jmp	0x8e7e <_MotorDriverSelfTest+0x1d2>
		case 1:
			u16VphH = adcMotorSelfTest4Ph.PhaseV_HighVoltage;
    8e6e:	7a21      	lod	Y, [S-34]
			u16VphL = adcMotorSelfTest4Ph.PhaseV_LowVoltage;
    8e70:	7e1f      	lod	X, [S-32]
			break;
    8e72:	0005      	jmp	0x8e7e <_MotorDriverSelfTest+0x1d2>
		case 4:
			u16VphH = adcMotorSelfTest4Ph.PhaseW_HighVoltage;
    8e74:	7a1d      	lod	Y, [S-30]
			u16VphL = adcMotorSelfTest4Ph.PhaseW_LowVoltage;
    8e76:	7e1b      	lod	X, [S-28]
			break;
    8e78:	0002      	jmp	0x8e7e <_MotorDriverSelfTest+0x1d2>
		case 5:
			u16VphH = adcMotorSelfTest4Ph.PhaseT_HighVoltage;
    8e7a:	7a19      	lod	Y, [S-26]
			u16VphL = adcMotorSelfTest4Ph.PhaseT_LowVoltage;
    8e7c:	7e17      	lod	X, [S-24]
			break;
		}

		if ( u16Vsm > u16VphH )
    8e7e:	7201      	lod	A, [S-2]
    8e80:	aee6      	cmp	A, Y
    8e82:	1a03      	jule	0x8e8a <_MotorDriverSelfTest+0x1de>
		{
			u16Vds = u16Vsm - u16VphH;
    8e84:	aae6      	sub	A, Y
    8e86:	7ae2      	lod	Y, A
    8e88:	0001      	jmp	0x8e8c <_MotorDriverSelfTest+0x1e0>
		}
		else
		{
			u16Vds = u16VphH - u16Vsm;
    8e8a:	ea01      	sub	Y, [S-2]
		}
		if ( u16Vds > u16VdsThreshold )
    8e8c:	ee07      	cmp	Y, [S-8]
    8e8e:	1a01      	jule	0x8e92 <_MotorDriverSelfTest+0x1e6>
    8e90:	0723      	jmp	0x8cd8 <_MotorDriverSelfTest+0x2c>
		{
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
			SetLastError( C_ERR_SELFTEST_D);
			break;
		}
		if ( u16VphL > u16VdsThreshold )
    8e92:	2e07      	cmp	X, [S-8]
    8e94:	1a01      	jule	0x8e98 <_MotorDriverSelfTest+0x1ec>
    8e96:	0725      	jmp	0x8ce2 <_MotorDriverSelfTest+0x36>
		{
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
			SetLastError( C_ERR_SELFTEST_E);
			break;
		}
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
    8e98:	7205      	lod	A, [S-6]
    8e9a:	aad8 0120 	sub	A, 0x120 <_l_u16CurrentZeroOffset>
    8e9e:	ac09      	cmp	A, #9
    8ea0:	1f01      	jsg	0x8ea4 <_MotorDriverSelfTest+0x1f8>
    8ea2:	0724      	jmp	0x8cec <_MotorDriverSelfTest+0x40>
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0U; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    8ea4:	7211      	lod	A, [S-18]
    8ea6:	a001      	add	A, #1
    8ea8:	5211      	mov	[S-18], A
    8eaa:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    8eac:	1d04      	jne	0x8eb6 <_MotorDriverSelfTest+0x20a>
    8eae:	7211      	lod	A, [S-18]
    8eb0:	ac09      	cmp	A, #9
    8eb2:	1e01      	jug	0x8eb6 <_MotorDriverSelfTest+0x20a>
    8eb4:	0775      	jmp	0x8da0 <_MotorDriverSelfTest+0xf4>
			SetLastError( C_ERR_SELFTEST_C);
			break;
		}
	}	

	DRVCFG_DIS_UVWT();
    8eb6:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8eba:	b6da fe00 	and	A, #65024
    8ebe:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase U */
    8ec2:	7eda 030c 	lod	X, #780
    8ec6:	5ed8 2858 	mov	0x2858 <__io__+0x58>, X
	PWM3_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase V */
    8eca:	5ed8 2862 	mov	0x2862 <__io__+0x62>, X
	PWM4_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase W */
    8ece:	5ed8 286c 	mov	0x286c <__io__+0x6c>, X
	PWM5_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase T */
    8ed2:	5ed8 2876 	mov	0x2876 <__io__+0x76>, X
	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    8ed6:	5ed8 284e 	mov	0x284e <__io__+0x4e>, X
	DRVCFG_DIS();
    8eda:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8ede:	a6da 0100 	or	A, #256
    8ee2:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_CMP = u16Pwm2Storage;													/* Restore PWM2 ADC trigger CMP time */
    8ee6:	720d      	lod	A, [S-14]
    8ee8:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
    8eec:	5429      	ret	#42

00008eee <_MotorDriverCurrentMeasureInit>:
 * Performance: <10us
 * ****************************************************************************	*/
void MotorDriverCurrentMeasureInit( void)
{
	uint16 u16Count;
	l_u16StartupDelayInit = 64U * NVRAM_ACCELERATION_POINTS;						/* Calculate the startup-delay, based on acceleration steps */
    8eee:	61a0      	lod	AL, dp:0xa0 <_g_NvramUser+0x4a>
    8ef0:	b43f      	and	A, #63
    8ef2:	487a 0040 	muls	Y, A, #64
    8ef6:	5ad8 0128 	mov	0x128 <_l_u16StartupDelayInit>, Y
	if ( l_u16StartupDelayInit < (2U*C_MOVAVG_SZ) )
    8efa:	ec7f      	cmp	Y, #127
    8efc:	1e03      	jug	0x8f04 <_MotorDriverCurrentMeasureInit+0x16>
	{
		l_u16StartupDelayInit = (2U*C_MOVAVG_SZ);								/* Minimum of twice the moving-average filter size */
    8efe:	72da 0080 	lod	A, #128
    8f02:	0007      	jmp	0x8f12 <_MotorDriverCurrentMeasureInit+0x24>
	}
	else if ( l_u16StartupDelayInit > NVRAM_STALL_DETECTOR_DELAY )
    8f04:	61c2      	lod	AL, dp:0xc2 <__bss_dp_size+0x12>
    8f06:	44a2      	asl	A, #2
    8f08:	4422      	asl	A
    8f0a:	b6da 07f8 	and	A, #2040
    8f0e:	eee2      	cmp	Y, A
    8f10:	1a02      	jule	0x8f16 <_MotorDriverCurrentMeasureInit+0x28>
	{
		l_u16StartupDelayInit = NVRAM_STALL_DETECTOR_DELAY;						/* Maximum of NVRAM specified */
    8f12:	52d8 0128 	mov	0x128 <_l_u16StartupDelayInit>, A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8f16:	72e3      	lod	A, M
	else
	{
		/* Nothing */
	}

	ATOMIC_CODE
    8f18:	4407      	mov	R, #0
    8f1a:	500c      	call	fp0:0x60
    8f1c:	54f0      	mov	UPr, #0
    8f1e:	7ad8 0128 	lod	Y, 0x128 <_l_u16StartupDelayInit>
    8f22:	5934      	mov	dp:0x34 <_g_u16StartupDelay>, Y
    8f24:	7800      	lod	Y, #0
    8f26:	5954      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, Y
    8f28:	5ad8 0188 	mov	0x188 <_l_u16MotorCurrentRawIdx>, Y
    8f2c:	5952      	mov	dp:0x52 <_g_u16MotorCurrentMovAvgxN>, Y
    8f2e:	5ad8 018a 	mov	0x18a <_l_au16MotorCurrentRaw>, Y
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8f32:	52e3      	mov	M, A
		l_u16MotorCurrentRawIdx = 0U;											/* Raw current moving average index */
		g_u16MotorCurrentMovAvgxN = 0U;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0U;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
    8f34:	7ada 018c 	lod	Y, #396
    8f38:	7c3f      	lod	X, #63
		for ( u16Count = 1U; u16Count < C_MOVAVG_SZ; u16Count++ )
		{
			*pStallCurrentRaw = 0U;
    8f3a:	7000      	lod	A, #0
    8f3c:	52d6      	mov	[Y++], A
    8f3e:	1bfd      	djnz	X, 0x8f3a <_MotorDriverCurrentMeasureInit+0x4c>
		g_u16MotorCurrentMovAvgxN = 0U;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0U;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
		for ( u16Count = 1U; u16Count < C_MOVAVG_SZ; u16Count++ )
    8f40:	5401      	ret

00008f42 <_MotorDriverCurrentMeasure>:
 *
 * Measure a average motor current, based on ADC current's
 * Performance: Approximate: 10us @ 20MHz
 * ****************************************************************************	*/
void MotorDriverCurrentMeasure( uint16 u16RunningMode)
{
    8f42:	5807      	inc	S, #8
    8f44:	5207      	mov	[S-8], A
#if (C_MOVAVG_SSZ < 6)
	uint16 u16MotorCurrentAcc;
#endif /* (C_MOVAVG_SSZ < 6 ) */
	uint16 u16MicroStepMotorCurrent = GetRawMotorDriverCurrent();
    8f46:	82db 871e 	callf	0x871e <_GetRawMotorDriverCurrent>
    8f4a:	5203      	mov	[S-4], A
#if _DEBUG_SPI
	SpiDebugWriteFirst( u16MicroStepMotorCurrent);
#endif /* _DEBUG_SPI */

	/* Moving average (sum) of motor-driver current */
	uint16 *pu16MotorCurrentElement = &l_au16MotorCurrentRaw[l_u16MotorCurrentRawIdx];
    8f4c:	7ad8 0188 	lod	Y, 0x188 <_l_u16MotorCurrentRawIdx>
    8f50:	72e6      	lod	A, Y
    8f52:	4422      	asl	A
    8f54:	7ee2      	lod	X, A
    8f56:	22da 018a 	add	X, #394
    8f5a:	5e05      	mov	[S-6], X
	uint16 u16PrevMotorCurrent = *pu16MotorCurrentElement;
    8f5c:	72f8      	lod	A, [X]
	l_u16MotorCurrentRawIdx = (l_u16MotorCurrentRawIdx + 1U) & (C_MOVAVG_SZ - 1U);
    8f5e:	e001      	add	Y, #1
    8f60:	f43f      	and	Y, #63
    8f62:	5ad8 0188 	mov	0x188 <_l_u16MotorCurrentRawIdx>, Y
//	if ( (g_u16StartupDelay != 0) || (u16MicroStepMotorCurrent < (u16PrevMotorCurrent << 1)) )	/* Check for valid motor-driver current (at least smaller than 2x previous current)  */
	{
		g_u16MotorCurrentMovAvgxN -= u16PrevMotorCurrent;						/* Subtract oldest raw motor-driver current */
    8f66:	7952      	lod	Y, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    8f68:	eae2      	sub	Y, A
		g_u16MotorCurrentMovAvgxN += u16MicroStepMotorCurrent;					/* Add newest raw motor-driver current */
    8f6a:	7e03      	lod	X, [S-4]
    8f6c:	22e6      	add	X, Y
    8f6e:	5d52      	mov	dp:0x52 <_g_u16MotorCurrentMovAvgxN>, X
		*pu16MotorCurrentElement = u16MicroStepMotorCurrent;					/* Overwrite oldest with newest motor-driver current */
    8f70:	7203      	lod	A, [S-4]
    8f72:	7a05      	lod	Y, [S-6]
    8f74:	52f0      	mov	[Y], A
	}

	if ( u16RunningMode )
    8f76:	7a07      	lod	Y, [S-8]
    8f78:	191c      	je	0x8fb2 <_MotorDriverCurrentMeasure+0x70>
		{
			g_u16MotorCurrentLPFx64 = u16MotorCurrentAcc;
		}
#endif /* (C_MOVAVG_SSZ < 6 ) */
#if (C_MOVAVG_SSZ == 6 )
		if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2U*C_MOVAVG_SZ))) || (g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || ((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (g_u16MotorCurrentMovAvgxN < g_u16MotorCurrentLPFx64)) )
    8f7a:	72d8 0128 	lod	A, 0x128 <_l_u16StartupDelayInit>
    8f7e:	a080      	add	A, #-128
    8f80:	ad34      	cmp	A, dp:0x34 <_g_u16StartupDelay>
    8f82:	1808      	jc	0x8f94 <_MotorDriverCurrentMeasure+0x52>
    8f84:	62d8 012d 	lod	AL, 0x12d <_g_u8MotorStartupMode>
    8f88:	8c02      	cmp	AL, #2
    8f8a:	1904      	je	0x8f94 <_MotorDriverCurrentMeasure+0x52>
    8f8c:	8c01      	cmp	AL, #1
    8f8e:	1d05      	jne	0x8f9a <_MotorDriverCurrentMeasure+0x58>
    8f90:	2d54      	cmp	X, dp:0x54 <_g_u16MotorCurrentLPFx64>
    8f92:	1c03      	jnc	0x8f9a <_MotorDriverCurrentMeasure+0x58>
		{
			g_u16MotorCurrentLPFx64 = g_u16MotorCurrentMovAvgxN;
    8f94:	7d52      	lod	X, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    8f96:	5d54      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, X
    8f98:	001a      	jmp	0x8fce <_MotorDriverCurrentMeasure+0x8c>
#if (MOTOR_MICROSTEPS < 3)
			/* LPF_B: IIR of 0.9921875 (127/128) & 0.0078125 (1/128) */
			g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63U) >> 7)) + ((g_u16MotorCurrentMovAvgxN + (1U << C_MOVAVG_SSZ)) >> (1U + C_MOVAVG_SSZ));
#else  /* (MOTOR_MICROSTEPS < 3) */
			/* LPF_B: IIR of 0.99609375 (255/256) & 0.00390625 (1/256) */
			g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63U) >> 8)) + ((g_u16MotorCurrentMovAvgxN + ((1U << (2U + C_MOVAVG_SSZ)) >> 1)) >> (2U + C_MOVAVG_SSZ));
    8f9a:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    8f9c:	7ae2      	lod	Y, A
    8f9e:	e03f      	add	Y, #63
    8fa0:	6400      	lod	YL, #0
    8fa2:	7ae8      	swap	Y
    8fa4:	aae6      	sub	A, Y
    8fa6:	7952      	lod	Y, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    8fa8:	e2da 0080 	add	Y, #128
    8fac:	6400      	lod	YL, #0
    8fae:	7ae8      	swap	Y
    8fb0:	000c      	jmp	0x8fca <_MotorDriverCurrentMeasure+0x88>
		}
	}
	else
	{
		/* LPF_B: IIR of 0.984375 (63/64) & 0.015625 (1/64) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 16U) >> 5)) + ((g_u16MotorCurrentMovAvgxN + ((1U << (C_MOVAVG_SSZ - 1U)) >> 1)) >> (C_MOVAVG_SSZ - 1U));
    8fb2:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    8fb4:	7ae2      	lod	Y, A
    8fb6:	e010      	add	Y, #16
    8fb8:	44b6      	lsr	Y, #2
    8fba:	44b6      	lsr	Y, #2
    8fbc:	4436      	lsr	Y
    8fbe:	aae6      	sub	A, Y
    8fc0:	7aee      	lod	Y, X
    8fc2:	e010      	add	Y, #16
    8fc4:	44b6      	lsr	Y, #2
    8fc6:	44b6      	lsr	Y, #2
    8fc8:	4436      	lsr	Y
    8fca:	a2e6      	add	A, Y
    8fcc:	5154      	mov	dp:0x54 <_g_u16MotorCurrentLPFx64>, A
	}


	if ( g_u16StartupDelay > 0U )
    8fce:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    8fd0:	1902      	je	0x8fd6 <_MotorDriverCurrentMeasure+0x94>
	{
		g_u16StartupDelay--;
    8fd2:	a0ff      	add	A, #-1
    8fd4:	5134      	mov	dp:0x34 <_g_u16StartupDelay>, A
    8fd6:	5409      	ret	#10

00008fd8 <_MotorDriver_InitialPwmDutyCycle>:
 * MotorDriver_InitialPwmDutyCycle()
 *
 * Calculate Motor PWM (initial) Duty-cycle, based on current threshold level and speed
 * ****************************************************************************	*/
void MotorDriver_InitialPwmDutyCycle( uint16 u16CurrentLevel, uint16 u16MotorSpeed)
{
    8fd8:	5807      	inc	S, #8
    8fda:	7ae2      	lod	Y, A
    8fdc:	7e0b      	lod	X, [S-12]
    8fde:	61a3      	lod	AL, dp:0xa3 <_g_NvramUser+0x4d>
    8fe0:	4205      	mov	[S-6], AL
    8fe2:	6187      	lod	AL, dp:0x87 <_g_NvramUser+0x31>
    8fe4:	4207      	mov	[S-8], AL
	if ( u16MotorSpeed == 0U )
    8fe6:	2c00      	cmp	X, #0
    8fe8:	1d09      	jne	0x8ffc <_MotorDriver_InitialPwmDutyCycle+0x24>
	{
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + 2U * C_FETS_RTOT) * u16CurrentLevel);
    8fea:	6205      	lod	AL, [S-6]
    8fec:	5cf2      	usex	A
    8fee:	a002      	add	A, #2
    8ff0:	4871      	muls	A, A, Y
    8ff2:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 8U;
    8ff4:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    8ff6:	44b2      	lsr	A, #2
    8ff8:	4432      	lsr	A
    8ffa:	0013      	jmp	0x9022 <_MotorDriver_InitialPwmDutyCycle+0x4a>
	}
	else
	{
		/* Ohmic losses: Ur-losses = (0.5 * R[ohm] * I[mA])/10 [10mV] = (R[ohm] * I[mA])/20 [10mV]
		 * FET losses: Ufet-losses = (Rfet * I[mA])/10 [10mV] = (2 * Rfet * I[mA])/20 [10mV]*/
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2U * C_FETS_RTOT)) * u16CurrentLevel);
    8ffc:	6205      	lod	AL, [S-6]
    8ffe:	5cf2      	usex	A
    9000:	a002      	add	A, #2
    9002:	4871      	muls	A, A, Y
    9004:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 20U;											/* Divided by 20 */
    9006:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    9008:	4822 cccd 	mulu	YA, A, #52429
    900c:	72e6      	lod	A, Y
    900e:	44b2      	lsr	A, #2
    9010:	44b2      	lsr	A, #2
    9012:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio += (NVRAM_MOTOR_CONSTANT * u16MotorSpeed);			/* BEMF = Kmotor[10mV/RPS] * Speed[RPS] */
    9014:	61a2      	lod	AL, dp:0xa2 <_g_NvramUser+0x4c>
    9016:	66e0      	lod	YL, AL
    9018:	5cf6      	usex	Y
    901a:	72e6      	lod	A, Y
    901c:	487b      	muls	Y, A, X
    901e:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    9020:	a2e6      	add	A, Y
    9022:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9024:	794a      	lod	Y, dp:0x4a <_g_u16CorrectionRatio>
    9026:	44a6      	asl	Y, #2
    9028:	4426      	asl	Y
    902a:	6207      	lod	AL, [S-8]
    902c:	5cf2      	usex	A
    902e:	4872 0019 	muls	A, A, #25
    9032:	4432      	lsr	A
    9034:	5205      	mov	[S-6], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9036:	72da 0c30 	lod	A, #3120
    903a:	7e05      	lod	X, [S-6]
    903c:	4821      	mulu	YA, A, Y
    903e:	4c63      	divu	YA, X
    9040:	4c63      	divu	YA, X
    9042:	5203      	mov	[S-4], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9044:	52d8 0294 	mov	0x294 <_g_u16PidCtrlRatio>, A
	}
	g_u16PidCtrlRatio =  muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1U + PWM_PRESCALER_N), NVRAM_VSUP_REF);
	g_u16PID_I = g_u16PidCtrlRatio;
    9048:	51c6      	mov	dp:0xc6 <_g_u16PID_I>, A
	if ( g_i16MotorVoltage > 0 )
    904a:	711c      	lod	A, dp:0x1c <_g_i16MotorVoltage>
    904c:	ac00      	cmp	A, #0
    904e:	1b0b      	jsle	0x9066 <_MotorDriver_InitialPwmDutyCycle+0x8e>
    9050:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    9052:	44a2      	asl	A, #2
    9054:	4422      	asl	A
    9056:	7d1c      	lod	X, dp:0x1c <_g_i16MotorVoltage>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9058:	7ada 0c30 	lod	Y, #3120
    905c:	4821      	mulu	YA, A, Y
    905e:	4c63      	divu	YA, X
    9060:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9062:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
    9064:	0002      	jmp	0x906a <_MotorDriver_InitialPwmDutyCycle+0x92>
	{
		g_u16CorrectionRatio = muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1U + PWM_PRESCALER_N), (uint16) g_i16MotorVoltage);
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    9066:	7e03      	lod	X, [S-4]
    9068:	5d4a      	mov	dp:0x4a <_g_u16CorrectionRatio>, X
	}
	g_i16PID_D = 0;
    906a:	7000      	lod	A, #0
    906c:	52d8 0140 	mov	0x140 <_g_i16PID_D>, A
	g_i16PID_E = 0;
    9070:	52d8 013e 	mov	0x13e <_g_i16PID_E>, A
	g_u16PID_CtrlCounter = 0U;													/* Re-start Current-control PID */
    9074:	52d8 013c 	mov	0x13c <_g_u16PID_CtrlCounter>, A
    9078:	5409      	ret	#10

0000907a <_MotorDriver_4PhaseStepper>:
 * Performance: 13.5us @ 28MHz (BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
 *
 * Based on a 32-step c_ai16MicroStepVector4PH-table!!
 * ****************************************************************************	*/
void MotorDriver_4PhaseStepper( void)
{
    907a:	5805      	inc	S, #6
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) */

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
	/* EMC CE/RE reduction */
	int16 iPwm1, iPwm2;
	int16 *pi16Vector = (int16 *) &c_ai16MicroStepVector4PH[g_u16MicroStepIdx];
    907c:	714c      	lod	A, dp:0x4c <_g_u16MicroStepIdx>
    907e:	5203      	mov	[S-4], A
    9080:	487a 0002 	muls	Y, A, #2
    9084:	7ee6      	lod	X, Y
    9086:	22da a164 	add	X, #41316
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    908a:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    908c:	7af8      	lod	Y, [X]
    908e:	4831      	muls	YA, A, Y
    9090:	48b3      	asr	YA, #4
    9092:	5a01      	mov	[S-2], Y
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    9094:	5a05      	mov	[S-6], Y
	iPwm1 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	iPwm2 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
#elif (PWM_PRESCALER_N == 0)
	iPwm1 = mulI16_I16byI16Shft4( *pi16Vector, (int16) g_u16CorrectionRatio);	/* Coil-A */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
    9096:	2020      	add	X, #32
    9098:	7af8      	lod	Y, [X]
    909a:	714a      	lod	A, dp:0x4a <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    909c:	4831      	muls	YA, A, Y
    909e:	48b3      	asr	YA, #4
#else
	i16PwmU = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* Coil-A */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	i16PwmV = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* Coil-B */
#endif
	if ( g_u16MicroStepIdx & (2*C_MICROSTEP_PER_FULLSTEP) )
    90a0:	7203      	lod	A, [S-4]
    90a2:	b420      	and	A, #32
    90a4:	1913      	je	0x90cc <_MotorDriver_4PhaseStepper+0x52>
	{
		/* 3rd and 4th Quadrant (Pwm1) */
		iPwm1 = (PWM_SCALE_OFFSET + iPwm1);
    90a6:	7205      	lod	A, [S-6]
    90a8:	a2da 030c 	add	A, #780
    90ac:	5205      	mov	[S-6], A
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = PWM */
		PWM4_LT = (uint16) iPwm1;
    90ae:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM4_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    90b2:	72da 0618 	lod	A, #1560
    90b6:	aa05      	sub	A, [S-6]
    90b8:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM3_LT = (uint16) iPwm1;
		PWM3_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */

		/* W = LOW */
		PWM2_HT = 0U;
    90bc:	7000      	lod	A, #0
    90be:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM2_LT = PWM_REG_PERIOD + 1U;
    90c2:	72da 0619 	lod	A, #1561
    90c6:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
    90ca:	0012      	jmp	0x90f0 <_MotorDriver_4PhaseStepper+0x76>
	}
	else
	{
		/* 1st and 2nd Quadrant (Pwm1)*/
		/* W = PWM */
		iPwm1 = ((int16) PWM_SCALE_OFFSET - iPwm1);
    90cc:	72da 030c 	lod	A, #780
    90d0:	aa01      	sub	A, [S-2]
    90d2:	5205      	mov	[S-6], A
		PWM2_LT = (uint16) iPwm1;
    90d4:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
		PWM2_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    90d8:	72da 0618 	lod	A, #1560
    90dc:	aa05      	sub	A, [S-6]
    90de:	52d8 285a 	mov	0x285a <__io__+0x5a>, A

#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = LOW */
		PWM4_HT = 0U;
    90e2:	7000      	lod	A, #0
    90e4:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM4_LT = PWM_REG_PERIOD + 1U;
    90e8:	72da 0619 	lod	A, #1561
    90ec:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM3_LT = PWM_REG_PERIOD + 1U;
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}

	{
		uint16 u16Quad = g_u16MicroStepIdx & (3*C_MICROSTEP_PER_FULLSTEP);
    90f0:	714c      	lod	A, dp:0x4c <_g_u16MicroStepIdx>
    90f2:	b430      	and	A, #48
		if ( (u16Quad == 0) || (u16Quad == (3*C_MICROSTEP_PER_FULLSTEP)) )
    90f4:	1902      	je	0x90fa <_MotorDriver_4PhaseStepper+0x80>
    90f6:	ac30      	cmp	A, #48
    90f8:	1d0f      	jne	0x9118 <_MotorDriver_4PhaseStepper+0x9e>
		{
			/* 1st and 4th Quadrant (Pwm2) */
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* T = PWM */
			PWM5_HT = (uint16) iPwm2;
    90fa:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    90fe:	72da 0618 	lod	A, #1560
    9102:	aae6      	sub	A, Y
    9104:	52d8 2876 	mov	0x2876 <__io__+0x76>, A

			/* V = LOW */
			PWM3_HT = 0U;
    9108:	7800      	lod	Y, #0
    910a:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = PWM_REG_PERIOD + 1U;
    910e:	72da 0619 	lod	A, #1561
    9112:	52d8 2862 	mov	0x2862 <__io__+0x62>, A
    9116:	000f      	jmp	0x9136 <_MotorDriver_4PhaseStepper+0xbc>
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
		}
		else
		{
			/* 3rd Quadrant (Pwm2) */
			iPwm2 = (0 - iPwm2);
    9118:	5cc6      	neg	Y
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* V = PWM */
			PWM3_HT = (uint16) iPwm2;
    911a:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    911e:	72da 0618 	lod	A, #1560
    9122:	aae6      	sub	A, Y
    9124:	52d8 2862 	mov	0x2862 <__io__+0x62>, A

			/* T = LOW */
			PWM5_HT = 0U;
    9128:	7800      	lod	Y, #0
    912a:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = PWM_REG_PERIOD + 1U;
    912e:	72da 0619 	lod	A, #1561
    9132:	52d8 2876 	mov	0x2876 <__io__+0x76>, A
		PWM4_LT = (uint16) (0 - iPwm);						/* U = PWM */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */

	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    9136:	7ada 030c 	lod	Y, #780
    913a:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
    913e:	5407      	ret	#8

00009140 <_MotorDriverStart>:
 * MotorDriverStart()
 *
 * Start Motor Driver
 * ****************************************************************************	*/
void MotorDriverStart( void)
{
    9140:	5807      	inc	S, #8
	if ( g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM )						/* Don't start motor in case of permanent electric failure */
    9142:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    9144:	8c02      	cmp	AL, #2
    9146:	1d01      	jne	0x914a <_MotorDriverStart+0xa>
    9148:	00a5      	jmp	0x9294 <_MotorDriverStart+0x154>
		return;
	}

	/* Fill multi-purpose buffer with acceleration-data */
	{
		l_u16SpeedRPM = NVRAM_MIN_SPEED;
    914a:	719c      	lod	A, dp:0x9c <_g_NvramUser+0x46>
    914c:	52d8 020a 	mov	0x20a <_l_u16SpeedRPM>, A
		l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    9150:	7ad8 0164 	lod	Y, 0x164 <_g_u16MotorMicroStepsPerMechRotation>
    9154:	5adf      	push	Y
    9156:	4ce2 2c40 	mov	YA, #105000000
    915a:	0642 
    915c:	82db 6c2a 	callf	0x6c2a <_divU32_U32byU16>
    9160:	5209      	mov	[S-10], A
    9162:	5a07      	mov	[S-8], Y
    9164:	52d8 020c 	mov	0x20c <_l_u32Temp>, A
    9168:	5ad8 020e 	mov	0x20e <_l_u32Temp+0x2>, Y
		if ( l_u16SpeedRPM >= (l_u32Temp >> 16))									/* MMP160915-1: Make sure no period overrun */
    916c:	72d8 020a 	lod	A, 0x20a <_l_u16SpeedRPM>
    9170:	4cc8      	movu	D, A
    9172:	7209      	lod	A, [S-10]
    9174:	7a07      	lod	Y, [S-8]
    9176:	48af      	lsr	YA, #16
    9178:	5c01      	dec	S, #2
    917a:	4c90      	cmp	D, YA
    917c:	180a      	jc	0x9192 <_MotorDriverStart+0x52>
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    917e:	7ed8 020a 	lod	X, 0x20a <_l_u16SpeedRPM>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9182:	7207      	lod	A, [S-8]
    9184:	7a05      	lod	Y, [S-6]
    9186:	4c63      	divu	YA, X
    9188:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    918a:	a0ff      	add	A, #-1
    918c:	52d8 0210 	mov	0x210 <_l_u16LowSpeedPeriod>, A
    9190:	0003      	jmp	0x9198 <_MotorDriverStart+0x58>
		{
			l_u16LowSpeedPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1U;
		}
		else
		{
			l_u16LowSpeedPeriod = 0xFFFEU;
    9192:	78fe      	lod	Y, #-2
    9194:	5ad8 0210 	mov	0x210 <_l_u16LowSpeedPeriod>, Y
		}
	}

	if ( g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT )
    9198:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    919a:	b402      	and	A, #2
    919c:	1d01      	jne	0x91a0 <_MotorDriverStart+0x60>
    919e:	0035      	jmp	0x920a <_MotorDriverStart+0xca>
	{
		if ( (g_u16MotorRewindSteps != 0U) &&
    91a0:	7ed8 0166 	lod	X, 0x166 <_g_u16MotorRewindSteps>
    91a4:	1929      	je	0x91f8 <_MotorDriverStart+0xb8>
    91a6:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    91a8:	7ae2      	lod	Y, A
    91aa:	f401      	and	Y, #1
    91ac:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    91ae:	4203      	mov	[S-4], AL
    91b0:	5cf2      	usex	A
    91b2:	eee2      	cmp	Y, A
    91b4:	1903      	je	0x91bc <_MotorDriverStart+0x7c>
    91b6:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    91b8:	b404      	and	A, #4
    91ba:	191e      	je	0x91f8 <_MotorDriverStart+0xb8>
			(((g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == g_e8MotorDirectionCCW) || (g_u8RewindFlags & C_REWIND_DIRECTION_AUTO)) )
		{
			/* Start rewind-function, with "rewinding" */
			g_u8RewindFlags = (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND);		/* Start rewind-process */
    91bc:	6028      	lod	AL, #40
    91be:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
			g_u16TargetPositionRewind = g_u16TargetPosition;
    91c0:	79ee      	lod	Y, dp:0xee <_g_u16TargetPosition>
    91c2:	5ad8 0148 	mov	0x148 <__data_end>, Y
    91c6:	79ec      	lod	Y, dp:0xec <_g_u16ActualPosition>
			if ( g_e8MotorDirectionCCW )
    91c8:	6203      	lod	AL, [S-4]
    91ca:	190b      	je	0x91e2 <_MotorDriverStart+0xa2>
			{
				if ( g_u16ActualPosition <= (uint16) (C_MAX_POS - g_u16MotorRewindSteps) )
    91cc:	72da 00ff 	lod	A, #255
    91d0:	aaee      	sub	A, X
    91d2:	eee2      	cmp	Y, A
    91d4:	1e18      	jug	0x9206 <_MotorDriverStart+0xc6>
				{
					g_u16TargetPosition = g_u16ActualPosition + g_u16MotorRewindSteps;
    91d6:	72e6      	lod	A, Y
    91d8:	a2ee      	add	A, X
    91da:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = FALSE;
    91dc:	6400      	lod	YL, #0
    91de:	4528      	mov	dp:0x28 <_g_e8MotorDirectionCCW>, YL
    91e0:	0014      	jmp	0x920a <_MotorDriverStart+0xca>
					g_u8RewindFlags = 0U;										/* No rewind possible */
				}
			}
			else
			{
				if ( g_u16ActualPosition >= g_u16MotorRewindSteps )
    91e2:	eeee      	cmp	Y, X
    91e4:	1806      	jc	0x91f2 <_MotorDriverStart+0xb2>
				{
					g_u16TargetPosition = g_u16ActualPosition - g_u16MotorRewindSteps;
    91e6:	72e6      	lod	A, Y
    91e8:	aaee      	sub	A, X
    91ea:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = TRUE;
    91ec:	6001      	lod	AL, #1
    91ee:	4128      	mov	dp:0x28 <_g_e8MotorDirectionCCW>, AL
    91f0:	000c      	jmp	0x920a <_MotorDriverStart+0xca>
				}
				else
				{
					g_u8RewindFlags = 0U;										/* No rewind possible */
    91f2:	6400      	lod	YL, #0
    91f4:	4522      	mov	dp:0x22 <_g_u8RewindFlags>, YL
    91f6:	0009      	jmp	0x920a <_MotorDriverStart+0xca>
				}
			}
		}
		else if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != g_e8MotorDirectionCCW )
    91f8:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    91fa:	7ae2      	lod	Y, A
    91fc:	f401      	and	Y, #1
    91fe:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    9200:	5cf2      	usex	A
    9202:	eee2      	cmp	Y, A
    9204:	1902      	je	0x920a <_MotorDriverStart+0xca>
		{
			g_u8RewindFlags = 0U;												/* Clear previous detected stall flags */
    9206:	6000      	lod	AL, #0
    9208:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
		{
			/* Nothing */
		}
	}

	g_u16ActuatorActPos = g_u16ActualPosition;
    920a:	71ec      	lod	A, dp:0xec <_g_u16ActualPosition>
    920c:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = g_u16TargetPosition;
    920e:	79ee      	lod	Y, dp:0xee <_g_u16TargetPosition>
    9210:	59f6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, Y
	g_u8StallOcc = FALSE;
    9212:	6000      	lod	AL, #0
    9214:	4126      	mov	dp:0x26 <_g_u8StallOcc>, AL
	g_u8MechError = FALSE;
    9216:	42d8 00f8 	mov	0xf8 <__dp_noinit_end>, AL

	/* Clear motor-driver current measurement */
	MotorDriverCurrentMeasureInit();
    921a:	1669      	call	0x8eee <_MotorDriverCurrentMeasureInit>
#if _DEBUG_MOTOR_CURRENT_FLT
	l_u16MotorCurrIdx = 0U;
#endif /* _DEBUG_MOTOR_CURRENT_FLT */

	g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;								/* Start-up in Acceleration stepper mode */
    921c:	6001      	lod	AL, #1
    921e:	42d8 012d 	mov	0x12d <_g_u8MotorStartupMode>, AL
	/* g_u16StartupDelay = NVRAM_STALL_DETECTOR_DELAY; */
	MotorStallInitA();
    9222:	1262      	call	0x96e8 <_MotorStallInitA>
#if _SUPPORT_STALLDET_O
	MotorStallInitO();
    9224:	129a      	call	0x975a <_MotorStallInitO>
#endif /* _SUPPORT_STALLDET_O */
#if _SUPPORT_STALLDET_H
	MotorStallInitH();
#endif /* _SUPPORT_STALLDET_H */

	l_u16CoilZeroCurrCountA = 0U;
    9226:	7800      	lod	Y, #0
    9228:	5ad8 0126 	mov	0x126 <_l_u16CoilZeroCurrCountA>, Y
	l_u16CoilZeroCurrCountB = 0U;
    922c:	5ad8 0124 	mov	0x124 <_l_u16CoilZeroCurrCountB>, Y

	/* Connect drivers: Stepper 4-phase/32-steps */
	MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_au16MotorSpeedRPS[1]);
    9230:	72d8 017a 	lod	A, 0x17a <_g_au16MotorSpeedRPS+0x2>
    9234:	52df      	push	A
    9236:	72d8 0296 	lod	A, 0x296 <_g_u16PidRunningThreshold>
    923a:	16ce      	call	0x8fd8 <_MotorDriver_InitialPwmDutyCycle>
	MotorDriver_4PhaseStepper();
    923c:	171e      	call	0x907a <_MotorDriver_4PhaseStepper>
	if ( g_u16MotorSpeedRPS > g_au16MotorSpeedRPS[1] )
	{
		MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_u16MotorSpeedRPS);
	}
#endif /* (_SUPPORT_PWM_DC_RAMPUP == FALSE) */
	DRVCFG_PWM_UVWT();															/* Enable the driver and the PWM phase W, V, U and T */
    923e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9242:	b6da fe00 	and	A, #65024
    9246:	a455      	or	A, #85
    9248:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	g_u8MotorHoldingCurrState = FALSE;
    924c:	6400      	lod	YL, #0
    924e:	46d8 012c 	mov	0x12c <_g_u8MotorHoldingCurrState>, YL

	/* Setup ADC for Motor Current/Voltage measurements */
#if _SUPPORT_PHASE_SHORT_DET
	ADC_Start( 0);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_Start();
    9252:	82db 85b8 	callf	0x85b8 <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */

	l_u16VTIdx = 0U;
    9256:	7000      	lod	A, #0
    9258:	5130      	mov	dp:0x30 <_l_u16VTIdx>, A
	if ( g_u8MotorStartupMode == (uint8) MSM_STEPPER_A )
    925a:	62d8 012d 	lod	AL, 0x12d <_g_u8MotorStartupMode>
    925e:	5c01      	dec	S, #2
    9260:	8c01      	cmp	AL, #1
    9262:	1d08      	jne	0x9274 <_MotorDriverStart+0x134>
	{
		if ( g_u16TargetCommutTimerPeriod < l_u16LowSpeedPeriod )
    9264:	7950      	lod	Y, dp:0x50 <__data_size>
    9266:	72d8 0210 	lod	A, 0x210 <_l_u16LowSpeedPeriod>
    926a:	eee2      	cmp	Y, A
    926c:	1c02      	jnc	0x9272 <_MotorDriverStart+0x132>
		{
			/* Target speed too fast for motor to start-up with */
			g_u16CommutTimerPeriod = l_u16LowSpeedPeriod;						/* Initial start-up speed */
    926e:	514e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, A
    9270:	0001      	jmp	0x9274 <_MotorDriverStart+0x134>
		}
		else
		{
			/* Target speed is slower than maximum motor start-up speed */
			g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9272:	594e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, Y
		}
	}
	TMR1_REGB = g_u16CommutTimerPeriod;
    9274:	714e      	lod	A, dp:0x4e <_g_u16CommutTimerPeriod>
    9276:	52ac      	mov	io:0x2c <_g_u8BufferOutID>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;									/* Start Timer mode 0 */
    9278:	7ada 4003 	lod	Y, #16387
    927c:	5aaa      	mov	io:0x2a <_g_e8ErrorElectric>, Y
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_RUNNING;
    927e:	6001      	lod	AL, #1
    9280:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
	g_u8MotorStopDelay = 0U;
    9282:	6000      	lod	AL, #0
    9284:	4132      	mov	dp:0x32 <_g_u8MotorStopDelay>, AL

	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) C_REWIND_ACTIVE )
    9286:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    9288:	b428      	and	A, #40
    928a:	ac08      	cmp	A, #8
    928c:	1d03      	jne	0x9294 <_MotorDriverStart+0x154>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_ACTIVE;							/* Rewind-function is finished */
    928e:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    9290:	94f7      	and	AL, #-9
    9292:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
    9294:	5409      	ret	#10

00009296 <_MotorDriverStop>:
 *						C_STOP_EMERGENCY : Immediate stop (without ramp-down) + delay
 *
 * Stop Motor Driver
 * ****************************************************************************	*/
void MotorDriverStop( uint16 u16Immediate)
{
    9296:	5809      	inc	S, #10
    9298:	5209      	mov	[S-10], A
	if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) != (uint8) C_MOTOR_STATUS_STOP )
    929a:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    929c:	b47f      	and	A, #127
    929e:	1d01      	jne	0x92a2 <_MotorDriverStop+0xc>
    92a0:	0046      	jmp	0x932e <_MotorDriverStop+0x98>
	{
		/* Not STOP status */
		if ( (u16Immediate == (uint16) C_STOP_RAMPDOWN) && (l_u16VTIdx > 1) ) /*lint !e845 */
    92a2:	7209      	lod	A, [S-10]
    92a4:	1901      	je	0x92a8 <_MotorDriverStop+0x12>
    92a6:	0035      	jmp	0x9312 <_MotorDriverStop+0x7c>
    92a8:	7d30      	lod	X, dp:0x30 <_l_u16VTIdx>
    92aa:	2c01      	cmp	X, #1
    92ac:	1e01      	jug	0x92b0 <_MotorDriverStop+0x1a>
    92ae:	003c      	jmp	0x9328 <_MotorDriverStop+0x92>
		{
			TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;							/* Start timer mode 0 */
    92b0:	7ada 4003 	lod	Y, #16387
    92b4:	5aaa      	mov	io:0x2a <_g_e8ErrorElectric>, Y

			/* Request to ramp-down */
			if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOPPING )
    92b6:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    92b8:	b47f      	and	A, #127
    92ba:	ac09      	cmp	A, #9
    92bc:	1d02      	jne	0x92c2 <_MotorDriverStop+0x2c>
			{
				/* Already stopping */
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;					/* Motor status change to STOP soon */
    92be:	6014      	lod	AL, #20
    92c0:	0025      	jmp	0x930c <_MotorDriverStop+0x76>
				return;
			}

			/* Set TargetPos near CurrentPos, including ramp-down */
			{
				if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    92c2:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    92c4:	5203      	mov	[S-4], A
    92c6:	79f6      	lod	Y, dp:0xf6 <_g_u16ActuatorTgtPos>
    92c8:	5a01      	mov	[S-2], Y
    92ca:	7130      	lod	A, dp:0x30 <_l_u16VTIdx>
    92cc:	7800      	lod	Y, #0
    92ce:	5207      	mov	[S-8], A
    92d0:	5a05      	mov	[S-6], Y
    92d2:	7a03      	lod	Y, [S-4]
    92d4:	ee01      	cmp	Y, [S-2]
    92d6:	1a0a      	jule	0x92ec <_MotorDriverStop+0x56>
				{
					uint32 u32DeltaPos = g_u16ActuatorActPos - g_u16ActuatorTgtPos;
    92d8:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    92da:	aa01      	sub	A, [S-2]
    92dc:	4cc8      	movu	D, A
					if ( u32DeltaPos > l_u16VTIdx )								/* MMP160915-2 */
    92de:	7207      	lod	A, [S-8]
    92e0:	7a05      	lod	Y, [S-6]
    92e2:	4c90      	cmp	D, YA
    92e4:	1a0e      	jule	0x9302 <_MotorDriverStop+0x6c>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos - l_u16VTIdx;	/* MMP160915-2 */
    92e6:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    92e8:	aaee      	sub	A, X
    92ea:	000a      	jmp	0x9300 <_MotorDriverStop+0x6a>
					}
				}
				else
				{
					uint32 u32DeltaPos = g_u16ActuatorTgtPos - g_u16ActuatorActPos;
    92ec:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    92ee:	7a01      	lod	Y, [S-2]
    92f0:	eae2      	sub	Y, A
    92f2:	4cc9      	movu	D, Y
					if ( u32DeltaPos > l_u16VTIdx )								/* MMP160915-2 */
    92f4:	7207      	lod	A, [S-8]
    92f6:	7a05      	lod	Y, [S-6]
    92f8:	4c90      	cmp	D, YA
    92fa:	1a03      	jule	0x9302 <_MotorDriverStop+0x6c>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos + l_u16VTIdx;	/* MMP160915-2 */
    92fc:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    92fe:	a2ee      	add	A, X
    9300:	51f6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, A
					}
				}
			}

			g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOPPING);
    9302:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9304:	9480      	and	AL, #-128
    9306:	8409      	or	AL, #9
    9308:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;						/* Motor status change to STOP when ramp-down is finished */
    930a:	6028      	lod	AL, #40
    930c:	42d8 00fc 	mov	0xfc <_g_u8MotorStartDelay>, AL
			return;
    9310:	540b      	ret	#12
		}
		else if ( u16Immediate == (uint16) C_STOP_EMERGENCY )
    9312:	7a09      	lod	Y, [S-10]
    9314:	ec02      	cmp	Y, #2
    9316:	1d08      	jne	0x9328 <_MotorDriverStop+0x92>
		{
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;						/* Wait 10 (up to 20 ms) before continue */
    9318:	6014      	lod	AL, #20
    931a:	42d8 00fc 	mov	0xfc <_g_u8MotorStartDelay>, AL
			if ( g_u8MotorStatusSpeed > (uint8) C_MOTOR_SPEED_MID )
    931e:	6119      	lod	AL, dp:0x19 <_g_u8MotorStatusSpeed>
    9320:	8c03      	cmp	AL, #3
    9322:	1a05      	jule	0x932e <_MotorDriverStop+0x98>
			{
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;
    9324:	6028      	lod	AL, #40
    9326:	0001      	jmp	0x932a <_MotorDriverStop+0x94>
			}
		}
		else
		{
			g_u8MotorStartDelay = 0U;
    9328:	6000      	lod	AL, #0
    932a:	42d8 00fc 	mov	0xfc <_g_u8MotorStartDelay>, AL
		}
	}

	/* Re-stall code */
	if ( (g_u8StallOcc != FALSE) && ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0U) )
    932e:	6126      	lod	AL, dp:0x26 <_g_u8StallOcc>
    9330:	190c      	je	0x934a <_MotorDriverStop+0xb4>
    9332:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    9334:	b408      	and	A, #8
    9336:	1d09      	jne	0x934a <_MotorDriverStop+0xb4>
			}
		}
#endif

		/* Set re-wind active */
		if ( g_e8MotorDirectionCCW )
    9338:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    933a:	1903      	je	0x9342 <_MotorDriverStop+0xac>
		{
			g_u8RewindFlags = g_u8RewindFlags | (uint8) (C_REWIND_DIRECTION_CCW | C_REWIND_STALL_DETECT);
    933c:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    933e:	8403      	or	AL, #3
    9340:	0003      	jmp	0x9348 <_MotorDriverStop+0xb2>
		}
		else
		{
			g_u8RewindFlags = (g_u8RewindFlags & (uint8) ~C_REWIND_DIRECTION_CCW) | (uint8) C_REWIND_STALL_DETECT;
    9342:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    9344:	94fe      	and	AL, #-2
    9346:	8402      	or	AL, #2
    9348:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
		}
	}

	/* First stop ADC, before stopping motor (trigger-event) */
	ADC_Stop();
    934a:	82db 840c 	callf	0x840c <_ADC_Stop>
	g_u8MotorStartupMode = (uint8) MSM_STOP;									/* Stop mode */
    934e:	6400      	lod	YL, #0
    9350:	46d8 012d 	mov	0x12d <_g_u8MotorStartupMode>, YL
	g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOP);
    9354:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9356:	9480      	and	AL, #-128
    9358:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
#if (LINPROT == LIN2J_VALVE_VW)
	if ( (g_u8StallOcc != 0U) && (g_u16TargetPosition == 0U) /* && (g_u16ActuatorActPos < (C_PERC_OFFSET+C_HALFPERC_OFFSET)) */ )
    935a:	6126      	lod	AL, dp:0x26 <_g_u8StallOcc>
    935c:	1908      	je	0x936e <_MotorDriverStop+0xd8>
    935e:	71ee      	lod	A, dp:0xee <_g_u16TargetPosition>
    9360:	1d06      	jne	0x936e <_MotorDriverStop+0xd8>
	{
		// TODO[MMP]: Add check g_u16ActuatorActPos is close to 0
		g_u16ActuatorActPos = (0U + C_PERC_OFFSET);
    9362:	72da 0900 	lod	A, #2304
    9366:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
		g_e8CalibrationStep = (uint8) C_CALIB_DONE;
    9368:	6007      	lod	AL, #7
    936a:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    936c:	000f      	jmp	0x938c <_MotorDriverStop+0xf6>
		g_u8StallOcc = FALSE;
	}
	else if ( (g_u8StallOcc) && (g_u16TargetPosition == (g_u16CalibTravel + (2*C_PERC_OFFSET))) /* && (g_u16ActuatorActPos >=  (g_u16CalibTravel-C_HALFPERC_OFFSET)) */ )
    936e:	6126      	lod	AL, dp:0x26 <_g_u8StallOcc>
    9370:	190f      	je	0x9390 <_MotorDriverStop+0xfa>
    9372:	79f2      	lod	Y, dp:0xf2 <_g_u16CalibTravel>
    9374:	72e6      	lod	A, Y
    9376:	a2da 1200 	add	A, #4608
    937a:	adee      	cmp	A, dp:0xee <_g_u16TargetPosition>
    937c:	1d09      	jne	0x9390 <_MotorDriverStop+0xfa>
	{
		// TODO[MMP]: Add check g_u16ActuatorActPos is close to g_u16CalibTravel
		g_u16ActuatorActPos = (g_u16CalibTravel + C_PERC_OFFSET);
    937e:	72e6      	lod	A, Y
    9380:	a2da 0900 	add	A, #2304
    9384:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
		g_e8CalibrationStep = (uint8) C_CALIB_DONE;
    9386:	6007      	lod	AL, #7
    9388:	4118      	mov	dp:0x18 <__data_dp_start>, AL
		g_u8StallOcc = FALSE;
    938a:	6400      	lod	YL, #0
    938c:	4526      	mov	dp:0x26 <_g_u8StallOcc>, YL
    938e:	0025      	jmp	0x93da <_MotorDriverStop+0x144>
	else
	{
		/* No stall or no end-stop request */

		/* Check for mechanical defect (1 = calculation rounding) */
		if ( (g_u16ActuatorActPos <= 1U) || (g_u16ActuatorActPos >= ((g_u16CalibTravel + (2U*C_PERC_OFFSET)) - 1U)) )
    9390:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    9392:	ac01      	cmp	A, #1
    9394:	1a07      	jule	0x93a4 <_MotorDriverStop+0x10e>
    9396:	7df2      	lod	X, dp:0xf2 <_g_u16CalibTravel>
    9398:	7aee      	lod	Y, X
    939a:	e2da 11ff 	add	Y, #4607
    939e:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    93a0:	aee6      	cmp	A, Y
    93a2:	1806      	jc	0x93b0 <_MotorDriverStop+0x11a>
		{
			g_u8MechError = TRUE;												/* Not initialised */
    93a4:	6001      	lod	AL, #1
    93a6:	42d8 00f8 	mov	0xf8 <__dp_noinit_end>, AL
			g_e8CalibrationStep = (uint8) C_CALIB_NONE;
    93aa:	6000      	lod	AL, #0
    93ac:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    93ae:	0015      	jmp	0x93da <_MotorDriverStop+0x144>
		}
		else if ( g_e8CalibrationStep == (uint8) C_CALIB_DONE )
    93b0:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    93b2:	8c07      	cmp	AL, #7
    93b4:	1d12      	jne	0x93da <_MotorDriverStop+0x144>
		{
			/* Round actual position */
			if ( g_u16ActuatorActPos < (C_PERC_OFFSET + C_HALFPERC_OFFSET) )
    93b6:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    93b8:	aeda 09e5 	cmp	A, #2533
    93bc:	1e04      	jug	0x93c6 <_MotorDriverStop+0x130>
			{
				g_u16ActuatorActPos = C_PERC_OFFSET;
    93be:	7ada 0900 	lod	Y, #2304
    93c2:	59f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, Y
    93c4:	000a      	jmp	0x93da <_MotorDriverStop+0x144>
			}
			else if ( g_u16ActuatorActPos > ((g_u16CalibTravel + C_PERC_OFFSET) - C_HALFPERC_OFFSET) )
    93c6:	7aee      	lod	Y, X
    93c8:	e2da 081a 	add	Y, #2074
    93cc:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    93ce:	aee6      	cmp	A, Y
    93d0:	1a04      	jule	0x93da <_MotorDriverStop+0x144>
			{
				g_u16ActuatorActPos = (g_u16CalibTravel + C_PERC_OFFSET);
    93d2:	72ee      	lod	A, X
    93d4:	a2da 0900 	add	A, #2304
    93d8:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
				/* Nothing */
			}
		}
	}
#endif /* (LINPROT == LIN2J_VALVE_VW) */
	if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    93da:	72d8 02ac 	lod	A, 0x2ac <_bistResetInfo>
    93de:	aeda 5c92 	cmp	A, #23698
    93e2:	1902      	je	0x93e8 <_MotorDriverStop+0x152>
	{
		/* make target-position same as actual position, except in case of WD-reset */
		g_u16ActuatorTgtPos = g_u16ActuatorActPos;								/* Stop: Target = Actual */
    93e4:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    93e6:	51f6      	mov	dp:0xf6 <_g_u16ActuatorTgtPos>, A
	}
	g_u16ActualPosition = g_u16ActuatorActPos;
    93e8:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    93ea:	51ec      	mov	dp:0xec <_g_u16ActualPosition>, A
	g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_STOP;							/* Stop */
    93ec:	6000      	lod	AL, #0
    93ee:	4119      	mov	dp:0x19 <_g_u8MotorStatusSpeed>, AL

	if ( (g_u8MotorHoldingCurrEna != FALSE) &&									/* Holding mode enabled */
    93f0:	61ea      	lod	AL, dp:0xea <_g_u8MotorHoldingCurrEna>
    93f2:	191f      	je	0x9432 <_MotorDriverStop+0x19c>
    93f4:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    93f6:	8c02      	cmp	AL, #2
    93f8:	191c      	je	0x9432 <_MotorDriverStop+0x19c>
    93fa:	6129      	lod	AL, dp:0x29 <_g_e8ErrorVoltage>
    93fc:	1d1a      	jne	0x9432 <_MotorDriverStop+0x19c>
    93fe:	7a09      	lod	Y, [S-10]
    9400:	ec03      	cmp	Y, #3
    9402:	1917      	je	0x9432 <_MotorDriverStop+0x19c>
		(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && (u16Immediate != (uint16) C_STOP_SLEEP) ) /*lint !e845 */
	{
		/* Keep Motor driver active with a specified amount of current (unless permanent electric error) */
		MotorDriver_InitialPwmDutyCycle( g_u16PidHoldingThreshold, 0U);
    9404:	54ca 0000 	pushw	#0
    9408:	72d8 029a 	lod	A, 0x29a <_g_u16PidHoldingThreshold>
    940c:	15e5      	call	0x8fd8 <_MotorDriver_InitialPwmDutyCycle>
	
		MotorDriver_4PhaseStepper();
    940e:	1635      	call	0x907a <_MotorDriver_4PhaseStepper>
		DRVCFG_PWM_UVWT();														/* Enable the driver and the PWM phase W, V and U */
    9410:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9414:	b6da fe00 	and	A, #65024
    9418:	a455      	or	A, #85
    941a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		g_u8MotorHoldingCurrState = TRUE;
    941e:	6001      	lod	AL, #1
    9420:	42d8 012c 	mov	0x12c <_g_u8MotorHoldingCurrState>, AL
		g_u16StartupDelay = l_u16StartupDelayInit;								/* MMP160615-1 */
    9424:	72d8 0128 	lod	A, 0x128 <_l_u16StartupDelayInit>
    9428:	5134      	mov	dp:0x34 <_g_u16StartupDelay>, A
//		g_u16MotorCurrentLPFx64 = (g_u16PidHoldingThreshold << 6);				/* Low-pass Filtered motor-current (x 64) */
#if _SUPPORT_PHASE_SHORT_DET
		ADC_Start( 0);															/* Start measuring motor current */
#else  /* _SUPPORT_PHASE_SHORT_DET */
		ADC_Start();
    942a:	82db 85b8 	callf	0x85b8 <_ADC_Start>
    942e:	5c01      	dec	S, #2
    9430:	0025      	jmp	0x947c <_MotorDriverStop+0x1e6>
#endif /* _SUPPORT_PHASE_SHORT_DET */
	}
	else
	{
		/* Disconnect drivers */
		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM )
    9432:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    9434:	8c02      	cmp	AL, #2
    9436:	1911      	je	0x945a <_MotorDriverStop+0x1c4>
		{
			if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_YES )
    9438:	612a      	lod	AL, dp:0x2a <_g_e8ErrorElectric>
    943a:	8c01      	cmp	AL, #1
    943c:	1907      	je	0x944c <_MotorDriverStop+0x1b6>
			{
				DRVCFG_GND_UVWT();												/* Make Low-side active, for a short time (recycle current) */
    943e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9442:	b6da fe00 	and	A, #65024
    9446:	a6da 00aa 	or	A, #170
    944a:	0011      	jmp	0x946e <_MotorDriverStop+0x1d8>
			}
			else
			{
				DRVCFG_VSUP_UVWT();												/* Make High-side active, for a short time (recycle current) */
    944c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9450:	b6da fe00 	and	A, #65024
    9454:	a6da 00ff 	or	A, #255
    9458:	000a      	jmp	0x946e <_MotorDriverStop+0x1d8>
			}
		}
		else
		{
			/* In case of a permanent error, don't connect drivers anymore */
			DRVCFG_DIS_UVWT();
    945a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    945e:	b6da fe00 	and	A, #65024
    9462:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();
    9466:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    946a:	a6da 0100 	or	A, #256
    946e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}
		g_u8MotorHoldingCurrState = FALSE;
    9472:	6400      	lod	YL, #0
    9474:	46d8 012c 	mov	0x12c <_g_u8MotorHoldingCurrState>, YL

		g_u8MotorStopDelay = 200U;												/* 200x 0.5ms = 100ms delay before driver is disconnected */
    9478:	60c8      	lod	AL, #-56
    947a:	4132      	mov	dp:0x32 <_g_u8MotorStopDelay>, AL
	}

	TMR1_CTRL &= ~TMRx_START;													/* Stop "commutation timer" */
    947c:	72aa      	lod	A, io:0x2a <_g_e8ErrorElectric>
    947e:	b4fd      	and	A, #-3
    9480:	52aa      	mov	io:0x2a <_g_e8ErrorElectric>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially pending) Timer1 second level interrupts (T1_INT4) */
    9482:	7040      	lod	A, #64
    9484:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
	PEND = CLR_EXT0_IT;															/* ... and first level interrupt */
    9488:	7ada 0100 	lod	Y, #256
    948c:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

	/* Re-stall code */
	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND) )
    9490:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    9492:	b428      	and	A, #40
    9494:	ac28      	cmp	A, #40
    9496:	1d0b      	jne	0x94ae <_MotorDriverStop+0x218>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_REWIND;							/* Rewinding of the Rewind-function is finished */
    9498:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    949a:	94df      	and	AL, #-33
    949c:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
		g_u16TargetPosition = g_u16TargetPositionRewind;
    949e:	72d8 0148 	lod	A, 0x148 <__data_end>
    94a2:	51ee      	mov	dp:0xee <_g_u16TargetPosition>, A
		g_u8MotorStopDelay = 0U;												/* Cancel stop delay */
    94a4:	6400      	lod	YL, #0
    94a6:	4532      	mov	dp:0x32 <_g_u8MotorStopDelay>, YL
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS )
				g_e8CalibrationStep = C_CALIB_SETUP_LO_ENDPOS;
		}
		else
#endif /* _SUPPORT_AUTO_CALIBRATION */
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    94a8:	6003      	lod	AL, #3
    94aa:	412b      	mov	dp:0x2b <_g_e8MotorRequest>, AL
    94ac:	540b      	ret	#12
	}
	else if ( (g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT) == 0U )
    94ae:	6122      	lod	AL, dp:0x22 <_g_u8RewindFlags>
    94b0:	b402      	and	A, #2
    94b2:	1d01      	jne	0x94b6 <_MotorDriverStop+0x220>
	{
		g_u8RewindFlags = 0U;													/* Clear all other flags in case no STALL have been detected */
    94b4:	4122      	mov	dp:0x22 <_g_u8RewindFlags>, AL
    94b6:	540b      	ret	#12

000094b8 <_EXT0_IT>:
 * The g_u8StallOcc flags can be set in this Commutation_ISR(), but cleared in the MotorDriverStop(),
 * before it is communicated back to the ECU/Master.
 * ****************************************************************************	*/
#define Commutation_ISR	EXT0_IT
__interrupt__ void Commutation_ISR(void)
{
    94b8:	52df      	push	A
    94ba:	5edf      	push	X
    94bc:	5adf      	push	Y
    94be:	4c83      	push	D
    94c0:	5807      	inc	S, #8
#if (_DEBUG_COMMUT_ISR != FALSE)
	DEBUG_SET_IO_B();
#endif /* (_DEBUG_COMMUT_ISR != FALSE) && (_DEBUG_HALLLATCH_ISR == FALSE) */

	uint16 pending = XI0_PEND & XI0_MASK;										/* Copy interrupt requests which are not masked   */
    94c2:	7ad8 2034 	lod	Y, 0x2034 <__ep__+0x1034>
    94c6:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    94ca:	f6e2      	and	Y, A
	do
	{
		XI0_PEND = pending;														/* Clear requests which are going to be processed */
    94cc:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
	} while ( (XI0_PEND & pending) != 0U );
    94d0:	72d8 2034 	lod	A, 0x2034 <__ep__+0x1034>
    94d4:	b6e6      	and	A, Y
    94d6:	1d7a      	jne	0x94cc <_EXT0_IT+0x14>

	if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0U )
    94d8:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    94da:	b401      	and	A, #1
    94dc:	1d01      	jne	0x94e0 <_EXT0_IT+0x28>
    94de:	00fc      	jmp	0x96d8 <_EXT0_IT+0x220>
	{
		return;		/* Used for CPU wake-up */
	}

	if ( g_e8MotorDirectionCCW )
    94e0:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    94e2:	1903      	je	0x94ea <_EXT0_IT+0x32>
	{
		g_u16ActuatorActPos--;													/* Closing */
    94e4:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    94e6:	a0ff      	add	A, #-1
    94e8:	0002      	jmp	0x94ee <_EXT0_IT+0x36>
	}
	else
	{
		g_u16ActuatorActPos++;													/* Opening */
    94ea:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    94ec:	a001      	add	A, #1
    94ee:	51f4      	mov	dp:0xf4 <_g_u16ActuatorActPos>, A
	}

	{
		uint16 u16DeltaPosition;												/* MMP160915-3 */
		if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    94f0:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    94f2:	79f6      	lod	Y, dp:0xf6 <_g_u16ActuatorTgtPos>
    94f4:	aee6      	cmp	A, Y
    94f6:	1a03      	jule	0x94fe <_EXT0_IT+0x46>
		{
			u16DeltaPosition = (g_u16ActuatorActPos - g_u16ActuatorTgtPos);
    94f8:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    94fa:	aae6      	sub	A, Y
    94fc:	0003      	jmp	0x9504 <_EXT0_IT+0x4c>
		}
		else
		{
			u16DeltaPosition = (g_u16ActuatorTgtPos - g_u16ActuatorActPos);
    94fe:	71f4      	lod	A, dp:0xf4 <_g_u16ActuatorActPos>
    9500:	eae2      	sub	Y, A
    9502:	72e6      	lod	A, Y
		}
		if ( u16DeltaPosition == 0U )
    9504:	ac00      	cmp	A, #0
    9506:	1d02      	jne	0x950c <_EXT0_IT+0x54>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    9508:	7001      	lod	A, #1
    950a:	00cd      	jmp	0x96a6 <_EXT0_IT+0x1ee>
			return;
		}
		if ( u16DeltaPosition <= l_u16VTIdx )									/* MMP160915-2 */
    950c:	ad30      	cmp	A, dp:0x30 <_l_u16VTIdx>
    950e:	1e07      	jug	0x951e <_EXT0_IT+0x66>
		{
			/* Decelerate motor speed (almost at target-position) */
			g_u16StartupDelay = u16DeltaPosition;
    9510:	5134      	mov	dp:0x34 <_g_u16StartupDelay>, A
			g_u16TargetCommutTimerPeriod = l_u16LowSpeedPeriod;
    9512:	72d8 0210 	lod	A, 0x210 <_l_u16LowSpeedPeriod>
    9516:	5150      	mov	dp:0x50 <__data_size>, A
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_STOPPING;
    9518:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    951a:	8409      	or	AL, #9
    951c:	41e8      	mov	dp:0xe8 <__bss_dp_end>, AL
		}
	}

	/* Current measurement used for Stall-detector "A" and current control (PID) */
	MotorDriverCurrentMeasure( TRUE);
    951e:	7001      	lod	A, #1
    9520:	1510      	call	0x8f42 <_MotorDriverCurrentMeasure>

	/* Coil current check */
	if ( g_u16StartupDelay == 0U )
    9522:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    9524:	1901      	je	0x9528 <_EXT0_IT+0x70>
    9526:	0039      	jmp	0x959a <_EXT0_IT+0xe2>
	{
		if ( g_u16CurrentMotorCoilA < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT) )
    9528:	72d8 0120 	lod	A, 0x120 <_l_u16CurrentZeroOffset>
    952c:	a00a      	add	A, #10
    952e:	7ad8 0126 	lod	Y, 0x126 <_l_u16CoilZeroCurrCountA>
    9532:	aed8 011a 	cmp	A, 0x11a <_g_u16CurrentMotorCoilA>
    9536:	1a07      	jule	0x9546 <_EXT0_IT+0x8e>
		{
			if ( ++l_u16CoilZeroCurrCountA >= C_COIL_ZERO_CURRENT_COUNT )
    9538:	72e6      	lod	A, Y
    953a:	a001      	add	A, #1
    953c:	52d8 0126 	mov	0x126 <_l_u16CoilZeroCurrCountA>, A
    9540:	ac1f      	cmp	A, #31
    9542:	1a07      	jule	0x9552 <_EXT0_IT+0x9a>
    9544:	0014      	jmp	0x956e <_EXT0_IT+0xb6>
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
				SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
				return;
			}
		}
		else if ( l_u16CoilZeroCurrCountA != 0U )
    9546:	ec00      	cmp	Y, #0
    9548:	1904      	je	0x9552 <_EXT0_IT+0x9a>
		{
			l_u16CoilZeroCurrCountA--;
    954a:	72e6      	lod	A, Y
    954c:	a0ff      	add	A, #-1
    954e:	52d8 0126 	mov	0x126 <_l_u16CoilZeroCurrCountA>, A
		else
		{
			/* Nothing */
		}

		if	( g_u16CurrentMotorCoilB < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT) )
    9552:	72d8 0120 	lod	A, 0x120 <_l_u16CurrentZeroOffset>
    9556:	a00a      	add	A, #10
    9558:	7ad8 0124 	lod	Y, 0x124 <_l_u16CoilZeroCurrCountB>
    955c:	aed8 0118 	cmp	A, 0x118 <_g_u16CurrentMotorCoilB>
    9560:	1a16      	jule	0x958e <_EXT0_IT+0xd6>
		{
			if ( ++l_u16CoilZeroCurrCountB >= C_COIL_ZERO_CURRENT_COUNT )
    9562:	72e6      	lod	A, Y
    9564:	a001      	add	A, #1
    9566:	52d8 0124 	mov	0x124 <_l_u16CoilZeroCurrCountB>, A
    956a:	ac1f      	cmp	A, #31
    956c:	1a16      	jule	0x959a <_EXT0_IT+0xe2>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);						/* Open coil connection */
    956e:	7001      	lod	A, #1
    9570:	1692      	call	0x9296 <_MotorDriverStop>
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    9572:	6002      	lod	AL, #2
    9574:	412a      	mov	dp:0x2a <_g_e8ErrorElectric>, AL
				SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
    9576:	72da 00e6 	lod	A, #230
    957a:	82db 89e6 	callf	0x89e6 <_SetLastError>
				return;
    957e:	5c07      	dec	S, #8
    9580:	4cc3      	pop	D
    9582:	7acf      	pop	Y
    9584:	7ecf      	pop	X
    9586:	72cf      	pop	A
    9588:	4407      	mov	R, #0
    958a:	72cb      	pop	M
    958c:	5401      	ret
			}
		}
		else if ( l_u16CoilZeroCurrCountB != 0U )
    958e:	ec00      	cmp	Y, #0
    9590:	1904      	je	0x959a <_EXT0_IT+0xe2>
		{
			l_u16CoilZeroCurrCountB--;
    9592:	72e6      	lod	A, Y
    9594:	a0ff      	add	A, #-1
    9596:	52d8 0124 	mov	0x124 <_l_u16CoilZeroCurrCountB>, A
		}
	}

	/* Update micro-step index */
	{
		uint16 u16MicroStepIdx = g_u16MicroStepIdx;
    959a:	794c      	lod	Y, dp:0x4c <_g_u16MicroStepIdx>
		if ( g_e8MotorDirectionCCW )
    959c:	6128      	lod	AL, dp:0x28 <_g_e8MotorDirectionCCW>
    959e:	1906      	je	0x95ac <_EXT0_IT+0xf4>
		{
			/* Counter Clock-wise (Closing) */
			if ( u16MicroStepIdx == 0U )
    95a0:	ec00      	cmp	Y, #0
    95a2:	1d02      	jne	0x95a8 <_EXT0_IT+0xf0>
			{
				u16MicroStepIdx = g_u16MotorMicroStepsPerElecRotation;
    95a4:	7ad8 0162 	lod	Y, 0x162 <__bss_size>
			}
			u16MicroStepIdx--;													/* Decrement the PWM vector pointer */
    95a8:	e0ff      	add	Y, #-1
    95aa:	0005      	jmp	0x95b6 <_EXT0_IT+0xfe>
		}
		else
		{
			/* Clock-wise (Opening) */
			u16MicroStepIdx++;													/* Increment the PWM vectors pointer */
    95ac:	e001      	add	Y, #1
			if ( u16MicroStepIdx >= g_u16MotorMicroStepsPerElecRotation )		/* Test the PWM vectors pointer: 48 usteps per electrical period */
    95ae:	eed8 0162 	cmp	Y, 0x162 <__bss_size>
    95b2:	1801      	jc	0x95b6 <_EXT0_IT+0xfe>
			{
				u16MicroStepIdx = 0U;											/* Re-initialise the PWM vectors pointer to 0 */
    95b4:	7800      	lod	Y, #0
			}
		}
		g_u16MicroStepIdx = u16MicroStepIdx;
    95b6:	594c      	mov	dp:0x4c <_g_u16MicroStepIdx>, Y
	}

	/* Check for speed update required */
	if ( g_u16CommutTimerPeriod == g_u16TargetCommutTimerPeriod )
    95b8:	7d4e      	lod	X, dp:0x4e <_g_u16CommutTimerPeriod>
    95ba:	7150      	lod	A, dp:0x50 <__data_size>
    95bc:	5207      	mov	[S-8], A
    95be:	2ee2      	cmp	X, A
    95c0:	1d04      	jne	0x95ca <_EXT0_IT+0x112>
	{
		g_u8MotorStartupMode = (uint8) MSM_STEPPER_C;
    95c2:	6003      	lod	AL, #3
    95c4:	42d8 012d 	mov	0x12d <_g_u8MotorStartupMode>, AL
    95c8:	0060      	jmp	0x968a <_EXT0_IT+0x1d2>
	}
	else
	{
		/* Update speed */
		uint16 u16Compensation = l_u16SpeedRPM;									/* MMP160606-1 */
    95ca:	72d8 020a 	lod	A, 0x20a <_l_u16SpeedRPM>
    95ce:	5205      	mov	[S-6], A
		if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    95d0:	2e07      	cmp	X, [S-8]
    95d2:	1c2a      	jnc	0x9628 <_EXT0_IT+0x170>
		{
			/* Deceleration per micro-step */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_D;					/* Too fast, decelerate */
    95d4:	6002      	lod	AL, #2
    95d6:	42d8 012d 	mov	0x12d <_g_u8MotorStartupMode>, AL
    95da:	719e      	lod	A, dp:0x9e <_g_NvramUser+0x48>
    95dc:	7800      	lod	Y, #0
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    95de:	7e05      	lod	X, [S-6]
    95e0:	4c63      	divu	YA, X
    95e2:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    95e4:	2ae2      	sub	X, A
    95e6:	5ed8 020a 	mov	0x20a <_l_u16SpeedRPM>, X
    95ea:	72d8 020c 	lod	A, 0x20c <_l_u32Temp>
    95ee:	7ad8 020e 	lod	Y, 0x20e <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    95f2:	4c63      	divu	YA, X
    95f4:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    95f6:	a0ff      	add	A, #-1
    95f8:	514e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, A
			l_u16SpeedRPM = l_u16SpeedRPM - divU16_U32byU16( (uint32) NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1U;	/* MMP160606-1 */
			if ( l_u16VTIdx != 0U )												/* MMP160915-2 */
    95fa:	7130      	lod	A, dp:0x30 <_l_u16VTIdx>
    95fc:	1909      	je	0x9610 <_EXT0_IT+0x158>
			{
				l_u16VTIdx--;													/* MMP160915-2 */
    95fe:	7ae2      	lod	Y, A
    9600:	e0ff      	add	Y, #-1
    9602:	5930      	mov	dp:0x30 <_l_u16VTIdx>, Y
				if ( g_u16StartupDelay < l_u16VTIdx )
    9604:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    9606:	aee6      	cmp	A, Y
    9608:	1c03      	jnc	0x9610 <_EXT0_IT+0x158>
				{
					g_u16StartupDelay = l_u16StartupDelayInit;					/* Speed reduction, stall detection post-poned */
    960a:	72d8 0128 	lod	A, 0x128 <_l_u16StartupDelayInit>
    960e:	5134      	mov	dp:0x34 <_g_u16StartupDelay>, A
				}
			}
			if ( g_u16CommutTimerPeriod > g_u16TargetCommutTimerPeriod )
    9610:	714e      	lod	A, dp:0x4e <_g_u16CommutTimerPeriod>
    9612:	7950      	lod	Y, dp:0x50 <__data_size>
    9614:	aee6      	cmp	A, Y
    9616:	1a01      	jule	0x961a <_EXT0_IT+0x162>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9618:	594e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, Y
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    961a:	714e      	lod	A, dp:0x4e <_g_u16CommutTimerPeriod>
    961c:	52ac      	mov	io:0x2c <_g_u8BufferOutID>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    961e:	7ad8 0294 	lod	Y, 0x294 <_g_u16PidCtrlRatio>
    9622:	72d8 020a 	lod	A, 0x20a <_l_u16SpeedRPM>
    9626:	002a      	jmp	0x967c <_EXT0_IT+0x1c4>
#if (_SUPPORT_PWM_DC_RAMPDOWN != FALSE)
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
#endif /* (_SUPPORT_PWM_DC_RAMPDOWN != FALSE) */
		}
		else if ( (g_u16MicroStepIdx == 0U) || ((g_u16MicroStepIdx > NVRAM_ACCELERATION_POINTS) && ((g_u16MicroStepIdx & NVRAM_ACCELERATION_POINTS) == 0)) )
    9628:	ec00      	cmp	Y, #0
    962a:	1906      	je	0x9638 <_EXT0_IT+0x180>
    962c:	61a0      	lod	AL, dp:0xa0 <_g_NvramUser+0x4a>
    962e:	b43f      	and	A, #63
    9630:	eee2      	cmp	Y, A
    9632:	1a2b      	jule	0x968a <_EXT0_IT+0x1d2>
    9634:	b6e6      	and	A, Y
    9636:	1d29      	jne	0x968a <_EXT0_IT+0x1d2>
		{
			/* Acceleration per acceleration_points ((multiple) full-step) */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;					/* Too slow, accelerate */
    9638:	6001      	lod	AL, #1
    963a:	42d8 012d 	mov	0x12d <_g_u8MotorStartupMode>, AL
    963e:	719e      	lod	A, dp:0x9e <_g_NvramUser+0x48>
    9640:	7800      	lod	Y, #0
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9642:	7e05      	lod	X, [S-6]
    9644:	4c63      	divu	YA, X
    9646:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9648:	a2ee      	add	A, X
    964a:	5203      	mov	[S-4], A
    964c:	52d8 020a 	mov	0x20a <_l_u16SpeedRPM>, A
    9650:	72d8 020c 	lod	A, 0x20c <_l_u32Temp>
    9654:	7ad8 020e 	lod	Y, 0x20e <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9658:	7e03      	lod	X, [S-4]
    965a:	4c63      	divu	YA, X
    965c:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    965e:	7ae2      	lod	Y, A
    9660:	e0ff      	add	Y, #-1
    9662:	594e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM + divU16_U32byU16( (uint32) NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;	/* MMP160606-1 */
			l_u16VTIdx++;														/* MMP160915-2 */
    9664:	7130      	lod	A, dp:0x30 <_l_u16VTIdx>
    9666:	a001      	add	A, #1
    9668:	5130      	mov	dp:0x30 <_l_u16VTIdx>, A
			if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    966a:	ee07      	cmp	Y, [S-8]
    966c:	1c02      	jnc	0x9672 <_EXT0_IT+0x1ba>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    966e:	7207      	lod	A, [S-8]
    9670:	514e      	mov	dp:0x4e <_g_u16CommutTimerPeriod>, A
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    9672:	714e      	lod	A, dp:0x4e <_g_u16CommutTimerPeriod>
    9674:	52ac      	mov	io:0x2c <_g_u8BufferOutID>, A
    9676:	72d8 0294 	lod	A, 0x294 <_g_u16PidCtrlRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    967a:	7a03      	lod	Y, [S-4]
    967c:	7e05      	lod	X, [S-6]
    967e:	4821      	mulu	YA, A, Y
    9680:	4c63      	divu	YA, X
    9682:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9684:	52d8 0294 	mov	0x294 <_g_u16PidCtrlRatio>, A
#if (_SUPPORT_PWM_DC_RAMPUP != FALSE)
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
    9688:	51c6      	mov	dp:0xc6 <_g_u16PID_I>, A
		{
			/* Nothing */
		}
	}

	VoltageCorrection();
    968a:	12ce      	call	0x9c28 <_VoltageCorrection>

	MotorDriver_4PhaseStepper();
    968c:	14f6      	call	0x907a <_MotorDriver_4PhaseStepper>
	if ( MotorStallCheckA() != (uint16) C_STALL_NOT_FOUND )						/* Stall-detector "A" */
    968e:	1030      	call	0x96f0 <_MotorStallCheckA>
    9690:	ac00      	cmp	A, #0
    9692:	1912      	je	0x96b8 <_EXT0_IT+0x200>
	{
		g_u8StallTypeComm |= (uint8) C_STALL_FOUND_A;
    9694:	611a      	lod	AL, dp:0x1a <_g_u8StallTypeComm>
    9696:	8440      	or	AL, #64
    9698:	411a      	mov	dp:0x1a <_g_u8StallTypeComm>, AL
		if ( g_e8StallDetectorEna & ((uint8) C_STALLDET_A | (uint8) C_STALLDET_CALIB))
    969a:	61e9      	lod	AL, dp:0xe9 <_g_e8StallDetectorEna>
    969c:	b409      	and	A, #9
    969e:	191c      	je	0x96d8 <_EXT0_IT+0x220>
		{
			g_u8StallOcc = TRUE;												/* Report stall and ...  */
    96a0:	6001      	lod	AL, #1
    96a2:	4126      	mov	dp:0x26 <_g_u8StallOcc>, AL
			MotorDriverStop( (uint16) C_STOP_EMERGENCY);						/* ... stop motor (Stall) */
    96a4:	7002      	lod	A, #2
    96a6:	15f7      	call	0x9296 <_MotorDriverStop>
    96a8:	5c07      	dec	S, #8
    96aa:	4cc3      	pop	D
    96ac:	7acf      	pop	Y
    96ae:	7ecf      	pop	X
    96b0:	72cf      	pop	A
    96b2:	4407      	mov	R, #0
    96b4:	72cb      	pop	M
    96b6:	5401      	ret
		}
	}
#if _SUPPORT_STALLDET_O
	else if ( (NVRAM_STALL_O != 0U) && (MotorStallCheckO() != C_STALL_NOT_FOUND) )	/* Stall-detector "O" */
    96b8:	61c5      	lod	AL, dp:0xc5 <__bss_dp_size+0x15>
    96ba:	9440      	and	AL, #64
    96bc:	190d      	je	0x96d8 <_EXT0_IT+0x220>
    96be:	1053      	call	0x9766 <_MotorStallCheckO>
    96c0:	ac00      	cmp	A, #0
    96c2:	190a      	je	0x96d8 <_EXT0_IT+0x220>
	{
		g_u8StallTypeComm |= (uint8) C_STALL_FOUND_O;
    96c4:	611a      	lod	AL, dp:0x1a <_g_u8StallTypeComm>
    96c6:	8408      	or	AL, #8
    96c8:	411a      	mov	dp:0x1a <_g_u8StallTypeComm>, AL
		if ( g_e8StallDetectorEna & ((uint8) C_STALLDET_O | (uint8) C_STALLDET_CALIB))
    96ca:	61e9      	lod	AL, dp:0xe9 <_g_e8StallDetectorEna>
    96cc:	b40a      	and	A, #10
    96ce:	1904      	je	0x96d8 <_EXT0_IT+0x220>
		{
			g_u8StallOcc = TRUE;												/* Report stall and ...  */
    96d0:	6001      	lod	AL, #1
    96d2:	4126      	mov	dp:0x26 <_g_u8StallOcc>, AL
			MotorDriverStop( (uint16) C_STOP_EMERGENCY);						/* ... stop motor (Stall) */
    96d4:	7002      	lod	A, #2
    96d6:	15df      	call	0x9296 <_MotorDriverStop>
    96d8:	5c07      	dec	S, #8
    96da:	4cc3      	pop	D
    96dc:	7acf      	pop	Y
    96de:	7ecf      	pop	X
    96e0:	72cf      	pop	A
    96e2:	4407      	mov	R, #0
    96e4:	72cb      	pop	M
    96e6:	5401      	ret

000096e8 <_MotorStallInitA>:
 *
 * Initialise Stall detector "A"
 * ****************************************************************************	*/
void MotorStallInitA( void)
{
	g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;								/* Used for communication */
    96e8:	6000      	lod	AL, #0
    96ea:	411a      	mov	dp:0x1a <_g_u8StallTypeComm>, AL

	l_u8StallCountA = 0U;														/* Stall-counter */
    96ec:	4137      	mov	dp:0x37 <_l_u8StallCountA>, AL
    96ee:	5401      	ret

000096f0 <_MotorStallCheckA>:
 * Check if motor is stalled
 * Stall detector "A" is based on fast current increase
 * Performance: 5us @ 20MHz
 * ****************************************************************************	*/
uint16 MotorStallCheckA( void)
{
    96f0:	5805      	inc	S, #6
	uint16 u16Result = C_STALL_NOT_FOUND;
    96f2:	7000      	lod	A, #0
    96f4:	5205      	mov	[S-6], A
	if ( (g_u16StartupDelay == 0) && (g_u16MotorCurrentMovAvgxN > (C_MIN_MOTORCURRENT << 4)) )
    96f6:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    96f8:	1d2e      	jne	0x9756 <_MotorStallCheckA+0x66>
    96fa:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    96fc:	5203      	mov	[S-4], A
    96fe:	aeda 00a0 	cmp	A, #160
    9702:	1a29      	jule	0x9756 <_MotorStallCheckA+0x66>
		   blocks, the BEMF drops to zero, and therefore the motor current increases.
		   This increase is monitored by calculating the difference (delta) between
		   a LPF filter (slowly increase) and the actual motor current. If this delta
		   increases above a specified threshold, stall is detected. */
		uint16 u16Threshold;
		if ( NVRAM_STALL_SPEED_DEPENDED )
    9704:	61c5      	lod	AL, dp:0xc5 <__bss_dp_size+0x15>
    9706:	65a1      	lod	YL, dp:0xa1 <_g_NvramUser+0x4b>
    9708:	7d54      	lod	X, dp:0x54 <_g_u16MotorCurrentLPFx64>
    970a:	8c00      	cmp	AL, #0
    970c:	1e8a      	jsge	0x9722 <_MotorStallCheckA+0x32>
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 120U) + (g_u8MotorStatusSpeed << 3);	/* Speed depended Threshold */
    970e:	f47f      	and	Y, #127
    9710:	6119      	lod	AL, dp:0x19 <_g_u8MotorStatusSpeed>
    9712:	44a2      	asl	A, #2
    9714:	4422      	asl	A
    9716:	b6da 07f8 	and	A, #2040
    971a:	e2e2      	add	Y, A
    971c:	72e6      	lod	A, Y
    971e:	a078      	add	A, #120
    9720:	0004      	jmp	0x972a <_MotorStallCheckA+0x3a>
		}
		else
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 128U);					/* Fixed Threshold */
    9722:	72e6      	lod	A, Y
    9724:	b47f      	and	A, #127
    9726:	a2da 0080 	add	A, #128
		}
		l_u16MotorCurrentStallThrshldxN = (uint16)(((uint32)g_u16MotorCurrentLPFx64 * u16Threshold) >> (13 - C_MOVAVG_SSZ));
    972a:	4823      	mulu	YA, A, X
    972c:	48a6      	lsr	YA, #7
    972e:	52d8 0212 	mov	0x212 <_l_u16MotorCurrentStallThrshldxN>, A
		if ( g_u16MotorCurrentMovAvgxN > l_u16MotorCurrentStallThrshldxN )
    9732:	7ae2      	lod	Y, A
    9734:	6137      	lod	AL, dp:0x37 <_l_u8StallCountA>
    9736:	4201      	mov	[S-2], AL
    9738:	7203      	lod	A, [S-4]
    973a:	aee6      	cmp	A, Y
    973c:	1a08      	jule	0x974e <_MotorStallCheckA+0x5e>
		{
			l_u8StallCountA++;
    973e:	6201      	lod	AL, [S-2]
    9740:	8001      	add	AL, #1
    9742:	4137      	mov	dp:0x37 <_l_u8StallCountA>, AL
			if ( l_u8StallCountA >= 3U )
    9744:	8c02      	cmp	AL, #2
    9746:	1a07      	jule	0x9756 <_MotorStallCheckA+0x66>
			{
				/* Real stall */
				u16Result = C_STALL_FOUND;
    9748:	7002      	lod	A, #2
    974a:	5205      	mov	[S-6], A
    974c:	0004      	jmp	0x9756 <_MotorStallCheckA+0x66>
			}
		}
		else if ( l_u8StallCountA )
    974e:	6201      	lod	AL, [S-2]
    9750:	1902      	je	0x9756 <_MotorStallCheckA+0x66>
		{
			l_u8StallCountA--;
    9752:	80ff      	add	AL, #-1
    9754:	4137      	mov	dp:0x37 <_l_u8StallCountA>, AL
		{
			/* Nothing */
		}
	}
	return ( u16Result );
} /* End of MotorStallCheckA() */
    9756:	7205      	lod	A, [S-6]
    9758:	5407      	ret	#8

0000975a <_MotorStallInitO>:
 *
 * Initialise Stall detector "O"
 * ****************************************************************************	*/
void MotorStallInitO( void)
{
	l_u8StallCountO = 0U;
    975a:	6000      	lod	AL, #0
    975c:	4136      	mov	dp:0x36 <_l_u8StallCountO>, AL
#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)
	l_i8StallIgnoreCount = -C_CURROSC_SZ;										/* MMP170201-1 */
    975e:	60e0      	lod	AL, #-32
    9760:	42d8 0130 	mov	0x130 <_l_i8StallIgnoreCount>, AL
    9764:	5401      	ret

00009766 <_MotorStallCheckO>:
 * Check if motor is stalled
 * Stall detector "O" is based on Current Oscillation feedback
 *
 * ****************************************************************************	*/
uint16 MotorStallCheckO()
{
    9766:	580d      	inc	S, #14
	uint16 u16Result = C_STALL_NOT_FOUND;
    9768:	7000      	lod	A, #0
    976a:	520d      	mov	[S-14], A

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)
	/* Dual motor-driver current measurement. Stall based on current per coil (A & B) */
	if ( l_i8StallIgnoreCount < 0 )
    976c:	62d8 0130 	lod	AL, 0x130 <_l_i8StallIgnoreCount>
    9770:	4203      	mov	[S-4], AL
    9772:	66e0      	lod	YL, AL
    9774:	5ce6      	ssex	Y
    9776:	7ee6      	lod	X, Y
    9778:	72d8 011a 	lod	A, 0x11a <_g_u16CurrentMotorCoilA>
    977c:	5209      	mov	[S-10], A
    977e:	7ad8 0118 	lod	Y, 0x118 <_g_u16CurrentMotorCoilB>
    9782:	5a07      	mov	[S-8], Y
    9784:	6203      	lod	AL, [S-4]
    9786:	8001      	add	AL, #1
    9788:	4205      	mov	[S-6], AL
    978a:	6203      	lod	AL, [S-4]
    978c:	8c00      	cmp	AL, #0
    978e:	1e91      	jsge	0x97b2 <_MotorStallCheckO+0x4c>
	{
		/* Fill buffer with current samples, for each coil a separate buffer */
		l_au16CurrentCoilA[C_CURROSC_SZ + l_i8StallIgnoreCount] = g_u16CurrentMotorCoilA;
    9790:	72ee      	lod	A, X
    9792:	4422      	asl	A
    9794:	7ee2      	lod	X, A
    9796:	7ae2      	lod	Y, A
    9798:	e2da 0254 	add	Y, #596
    979c:	7209      	lod	A, [S-10]
    979e:	52f0      	mov	[Y], A
		l_au16CurrentCoilB[C_CURROSC_SZ + l_i8StallIgnoreCount] = g_u16CurrentMotorCoilB;
    97a0:	7aee      	lod	Y, X
    97a2:	e2da 0294 	add	Y, #660
    97a6:	7207      	lod	A, [S-8]
    97a8:	52f0      	mov	[Y], A
		l_i8StallIgnoreCount++;
    97aa:	6605      	lod	YL, [S-6]
    97ac:	46d8 0130 	mov	0x130 <_l_i8StallIgnoreCount>, YL
    97b0:	0059      	jmp	0x9864 <_MotorStallCheckO+0xfe>
	}
	else
	{
		/* Determine difference between current measurements now and half a (electric) rotation backwards */
		uint16 u16CurrentCoilB_Prev;
		uint16 u16CurrentCoilA_Prev = l_au16CurrentCoilA[l_i8StallIgnoreCount];	/* Coil A previous-current */
    97b2:	72ee      	lod	A, X
    97b4:	4422      	asl	A
    97b6:	5201      	mov	[S-2], A
    97b8:	7ae2      	lod	Y, A
    97ba:	e2da 0214 	add	Y, #532
    97be:	7ef0      	lod	X, [Y]
		l_au16CurrentCoilA[l_i8StallIgnoreCount] = g_u16CurrentMotorCoilA;
    97c0:	7209      	lod	A, [S-10]
    97c2:	52f0      	mov	[Y], A
		u16CurrentCoilB_Prev = l_au16CurrentCoilB[l_i8StallIgnoreCount];	/* Coil B previous-current */
    97c4:	7a01      	lod	Y, [S-2]
    97c6:	e2da 0254 	add	Y, #596
    97ca:	72f0      	lod	A, [Y]
    97cc:	520b      	mov	[S-12], A
		l_au16CurrentCoilB[l_i8StallIgnoreCount] = g_u16CurrentMotorCoilB;
    97ce:	7207      	lod	A, [S-8]
    97d0:	52f0      	mov	[Y], A
		l_i8StallIgnoreCount = ((l_i8StallIgnoreCount + 1U) & (C_CURROSC_SZ - 1U));
    97d2:	6205      	lod	AL, [S-6]
    97d4:	941f      	and	AL, #31
    97d6:	42d8 0130 	mov	0x130 <_l_i8StallIgnoreCount>, AL
		if ( g_u16StartupDelay == 0U )
    97da:	7134      	lod	A, dp:0x34 <_g_u16StartupDelay>
    97dc:	1901      	je	0x97e0 <_MotorStallCheckO+0x7a>
    97de:	0042      	jmp	0x9864 <_MotorStallCheckO+0xfe>
		{
			if ( u16CurrentCoilA_Prev > g_u16CurrentMotorCoilA )
    97e0:	2e09      	cmp	X, [S-10]
    97e2:	1a03      	jule	0x97ea <_MotorStallCheckO+0x84>
			{
				g_u16CurrStallO = (u16CurrentCoilA_Prev - g_u16CurrentMotorCoilA);	/* Delta current Coil-A */
    97e4:	72ee      	lod	A, X
    97e6:	aa09      	sub	A, [S-10]
    97e8:	0002      	jmp	0x97ee <_MotorStallCheckO+0x88>
			}
			else
			{
				g_u16CurrStallO = (g_u16CurrentMotorCoilA - u16CurrentCoilA_Prev);
    97ea:	7209      	lod	A, [S-10]
    97ec:	aaee      	sub	A, X
    97ee:	52d8 012e 	mov	0x12e <_g_u16CurrStallO>, A
			}
			{
				uint16 u16StallCurrO_B;
				if ( u16CurrentCoilB_Prev > g_u16CurrentMotorCoilB )
    97f2:	72d8 0118 	lod	A, 0x118 <_g_u16CurrentMotorCoilB>
    97f6:	7a0b      	lod	Y, [S-12]
    97f8:	eee2      	cmp	Y, A
    97fa:	1a03      	jule	0x9802 <_MotorStallCheckO+0x9c>
				{
					u16StallCurrO_B = (u16CurrentCoilB_Prev - g_u16CurrentMotorCoilB);	/* Delta current Coil-B */
    97fc:	eae2      	sub	Y, A
    97fe:	72e6      	lod	A, Y
    9800:	0001      	jmp	0x9804 <_MotorStallCheckO+0x9e>
				}
				else
				{
					u16StallCurrO_B = (g_u16CurrentMotorCoilB - u16CurrentCoilB_Prev);
    9802:	aa0b      	sub	A, [S-12]
				}
				if ( u16StallCurrO_B > g_u16CurrStallO )
    9804:	aed8 012e 	cmp	A, 0x12e <_g_u16CurrStallO>
    9808:	1a02      	jule	0x980e <_MotorStallCheckO+0xa8>
				{
					g_u16CurrStallO = u16StallCurrO_B;
    980a:	52d8 012e 	mov	0x12e <_g_u16CurrStallO>, A
				}
			}
			{
				uint16 u16Threshold = NVRAM_STALL_O_THRSHLD;
    980e:	618b      	lod	AL, dp:0x8b <_g_NvramUser+0x35>
    9810:	66e0      	lod	YL, AL
    9812:	5cf6      	usex	Y
				if ( g_u8MotorStatusSpeed == C_MOTOR_SPEED_LOW )
    9814:	6119      	lod	AL, dp:0x19 <_g_u8MotorStatusSpeed>
    9816:	8c01      	cmp	AL, #1
    9818:	1d05      	jne	0x9824 <_MotorStallCheckO+0xbe>
				{
					u16Threshold -= (u16Threshold >> 3);						/* 87.5% */
    981a:	72e6      	lod	A, Y
    981c:	44b2      	lsr	A, #2
    981e:	4432      	lsr	A
    9820:	eae2      	sub	Y, A
    9822:	0005      	jmp	0x982e <_MotorStallCheckO+0xc8>
				}
				else if ( g_u8MotorStatusSpeed == C_MOTOR_SPEED_HIGH )
    9824:	8c05      	cmp	AL, #5
    9826:	1d03      	jne	0x982e <_MotorStallCheckO+0xc8>
				{
					u16Threshold += (u16Threshold >> 2);						/* 125% */
    9828:	72e6      	lod	A, Y
    982a:	44b2      	lsr	A, #2
    982c:	e2e2      	add	Y, A
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    982e:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    uint32 result;

    __asm__ __volatile__ (
    9830:	4801      	mulu	D, A, Y
    9832:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    9834:	48ad      	lsr	YA, #14
    9836:	7ae2      	lod	Y, A
				else
				{
					/* Nothing */
				}
				u16Threshold = (uint16)(mulU32_U16byU16( g_u16MotorCurrentLPFx64, u16Threshold) >> (8U + 6U));
				if ( g_u16CurrStallO > u16Threshold )
    9838:	7ed8 012e 	lod	X, 0x12e <_g_u16CurrStallO>
    983c:	6136      	lod	AL, dp:0x36 <_l_u8StallCountO>
    983e:	4204      	mov	[S-5], AL
    9840:	2ee6      	cmp	X, Y
    9842:	1a0c      	jule	0x985c <_MotorStallCheckO+0xf6>
				{
					l_u8StallCountO++;											/* Suspect current oscillation due to stall */
    9844:	8001      	add	AL, #1
    9846:	4136      	mov	dp:0x36 <_l_u8StallCountO>, AL
					if ( l_u8StallCountO >= NVRAM_STALL_O_WIDTH )				/* 1-8 uSteps out of 16 uSteps */
    9848:	66e0      	lod	YL, AL
    984a:	5cf6      	usex	Y
    984c:	618a      	lod	AL, dp:0x8a <_g_NvramUser+0x34>
    984e:	b407      	and	A, #7
    9850:	a001      	add	A, #1
    9852:	eee2      	cmp	Y, A
    9854:	1a87      	jsl	0x9864 <_MotorStallCheckO+0xfe>
					{
						u16Result = C_STALL_FOUND;
    9856:	7802      	lod	Y, #2
    9858:	5a0d      	mov	[S-14], Y
    985a:	0004      	jmp	0x9864 <_MotorStallCheckO+0xfe>
					}
				}
				else if ( l_u8StallCountO != 0U )
    985c:	6204      	lod	AL, [S-5]
    985e:	1902      	je	0x9864 <_MotorStallCheckO+0xfe>
				{
					l_u8StallCountO--;
    9860:	80ff      	add	AL, #-1
    9862:	4136      	mov	dp:0x36 <_l_u8StallCountO>, AL
		}
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */
	return ( u16Result );

} /* End of MotorStallCheckO() */
    9864:	720d      	lod	A, [S-14]
    9866:	540f      	ret	#16

00009868 <_NVRAM_CRC8>:
 *								TRUE: Calculated CRC8
 *
 *	Calculate CRC8 on User-NVRAM
 * ****************************************************************************	*/
uint8 NVRAM_CRC8( uint8 byReplaceCRC)
{
    9868:	5803      	inc	S, #4
    986a:	5201      	mov	[S-2], A
	uint16 u16CRC;

	if ( byReplaceCRC != FALSE )
    986c:	ac00      	cmp	A, #0
    986e:	1902      	je	0x9874 <_NVRAM_CRC8+0xc>
	{
		g_NvramUser.CRC8 = 0x00U;
    9870:	6000      	lod	AL, #0
    9872:	4156      	mov	dp:0x56 <_g_NvramUser>, AL
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    9874:	7ada 0056 	lod	Y, #86
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    9878:	7c38      	lod	X, #56
    987a:	7000      	lod	A, #0
    987c:	08a7      	clrb	ML.7
    987e:	b2d6      	adc	A, [Y++]
    9880:	1bfe      	djnz	X, 0x987e <_NVRAM_CRC8+0x16>
    9882:	92e4      	adc	AL, AH
    9884:	9000      	adc	AL, #0
    9886:	5cf2      	usex	A
    9888:	5203      	mov	[S-4], A
	}

	u16CRC = nvram_CalcCRC( (uint16 *) &g_NvramUser, (sizeof(g_NvramUser)/sizeof(uint16)));

	if ( byReplaceCRC != FALSE )
    988a:	7a01      	lod	Y, [S-2]
    988c:	1903      	je	0x9894 <_NVRAM_CRC8+0x2c>
	{
		g_NvramUser.CRC8 = (0xFFU - u16CRC);
    988e:	60ff      	lod	AL, #-1
    9890:	8a03      	sub	AL, [S-4]
    9892:	4156      	mov	dp:0x56 <_g_NvramUser>, AL
	}

	return ( (uint8) u16CRC );
    9894:	6203      	lod	AL, [S-4]
    9896:	5cf2      	usex	A
} /* End of NVRAM_CRC8() */
    9898:	5405      	ret	#6

0000989a <_NVRAM_CountCRC8>:
 *								TRUE: Calculated CRC8.
 *
 *	Calculate CRC8 on Write-cycle counter.
 * ****************************************************************************	*/
uint8 NVRAM_CountCRC8( PNVRAM_ERRORLOG pNVERRLOG, uint8 byReplaceCRC)
{
    989a:	5807      	inc	S, #8
    989c:	5203      	mov	[S-4], A
    989e:	620b      	lod	AL, [S-12]
    98a0:	5cf2      	usex	A
    98a2:	5201      	mov	[S-2], A
    98a4:	7c01      	lod	X, #1
    98a6:	7a03      	lod	Y, [S-4]
    98a8:	7000      	lod	A, #0
    98aa:	08a7      	clrb	ML.7
    98ac:	b2d6      	adc	A, [Y++]
    98ae:	1bfe      	djnz	X, 0x98ac <_NVRAM_CountCRC8+0x12>
    98b0:	92e4      	adc	AL, AH
    98b2:	9000      	adc	AL, #0
    98b4:	5cf2      	usex	A
    98b6:	5207      	mov	[S-8], A
	uint16 u16CRC = nvram_CalcCRC( (uint16 *) &pNVERRLOG->NvramProgramCycleCount, 1U);

	if ( byReplaceCRC != FALSE )
    98b8:	7201      	lod	A, [S-2]
    98ba:	190c      	je	0x98d4 <_NVRAM_CountCRC8+0x3a>
	{
		pNVERRLOG->ErrorLogIndex_CRC = (pNVERRLOG->ErrorLogIndex_CRC & 0x00FF) | ((0xFFU - u16CRC) << 8);
    98bc:	7a03      	lod	Y, [S-4]
    98be:	72f2      	lod	A, [Y+2]
    98c0:	b6da 00ff 	and	A, #255
    98c4:	7ee2      	lod	X, A
    98c6:	72da 00ff 	lod	A, #255
    98ca:	aa07      	sub	A, [S-8]
    98cc:	6800      	lod	AH, #0
    98ce:	72e4      	swap	A
    98d0:	26e2      	or	X, A
    98d2:	5ef2      	mov	[Y+2], X
	}
	return ( (uint8) ((pNVERRLOG->ErrorLogIndex_CRC >> 8) ^ u16CRC) );
    98d4:	7a03      	lod	Y, [S-4]
    98d6:	62f3      	lod	AL, [Y+3]
    98d8:	9e07      	xor	AL, [S-8]
    98da:	5cf2      	usex	A
} /* End of NVRAM_CountCRC8() */
    98dc:	5409      	ret	#10

000098de <_NVRAM_PageVerify>:
 *	Post:	FALSE: NVRAM shadow-RAM page structure and RAM-structure are not the same
 *			TRUE : NVRAM shadow-RAM page structure and RAM-structure are the same
 *
 * ****************************************************************************	*/
uint16 NVRAM_PageVerify( const uint16 *pMRAM)
{
    98de:	7ee2      	lod	X, A
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    98e0:	7ada 0056 	lod	Y, #86
	do
	{
		if ( *pMRAM++ != *pURAM++ )
    98e4:	72de      	lod	A, [X++]
    98e6:	aed6      	cmp	A, [Y++]
    98e8:	1902      	je	0x98ee <_NVRAM_PageVerify+0x10>
		{
			/* Error */
			return ( FALSE );
    98ea:	7000      	lod	A, #0
    98ec:	5401      	ret
		}
	} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    98ee:	eeda 00c6 	cmp	Y, #198
    98f2:	1878      	jc	0x98e4 <_NVRAM_PageVerify+0x6>
	return ( TRUE );
    98f4:	7001      	lod	A, #1
} /* End of NVRAM_PageVerify() */
    98f6:	5401      	ret

000098f8 <_NVRAM_Store>:
 *
 * C_ADDR_USERPAGE1+0x00:0x7F:	User page #1 (64x 16-bits words)
 * C_ADDR_USERPAGE2+0x00:0x7F:	User page #2 (64x 16-bits words) (Backup)
 * ****************************************************************************	*/
uint16 NVRAM_Store( uint16 u16Page)
{
    98f8:	5803      	inc	S, #4
    98fa:	5203      	mov	[S-4], A
	uint16 *pURAM;
	uint16 *pMRAM;
	uint16 u16Result = C_NVRAM_STORE_OKAY;
    98fc:	7000      	lod	A, #0
    98fe:	5201      	mov	[S-2], A

	/* Store NVRAM */
	if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0U )
    9900:	6203      	lod	AL, [S-4]
    9902:	8c00      	cmp	AL, #0
    9904:	1a82      	jsl	0x990a <_NVRAM_Store+0x12>
	{
		(void) NVRAM_CRC8( TRUE);												/* Update CRC8 */
    9906:	7001      	lod	A, #1
    9908:	17af      	call	0x9868 <_NVRAM_CRC8>
	}

	/* Copy NVRAM UserRAM-copy into NVRAM MirrorRAM */
	if ( ((u16Page & C_NVRAM_USER_PAGE_1) != 0U) &&
    990a:	7203      	lod	A, [S-4]
    990c:	b401      	and	A, #1
    990e:	1d01      	jne	0x9912 <_NVRAM_Store+0x1a>
    9910:	0039      	jmp	0x9984 <_NVRAM_Store+0x8c>
    9912:	7203      	lod	A, [S-4]
    9914:	b440      	and	A, #64
    9916:	1d05      	jne	0x9922 <_NVRAM_Store+0x2a>
    9918:	72da 1000 	lod	A, #4096
    991c:	17e0      	call	0x98de <_NVRAM_PageVerify>
    991e:	ac00      	cmp	A, #0
    9920:	1d31      	jne	0x9984 <_NVRAM_Store+0x8c>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    9922:	54ca 0000 	pushw	#0
    9926:	72da 1070 	lod	A, #4208
    992a:	17b7      	call	0x989a <_NVRAM_CountCRC8>
    992c:	5c01      	dec	S, #2
    992e:	8cff      	cmp	AL, #-1
    9930:	1906      	je	0x993e <_NVRAM_Store+0x46>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    9932:	7000      	lod	A, #0
    9934:	7ada 1070 	lod	Y, #4208
    9938:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    993a:	7802      	lod	Y, #2
    993c:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    993e:	7ada 1070 	lod	Y, #4208
    9942:	72f0      	lod	A, [Y]
    9944:	acfd      	cmp	A, #-3
    9946:	1e02      	jug	0x994c <_NVRAM_Store+0x54>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    9948:	a001      	add	A, #1
    994a:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);							/* Calculate Cycle-count CRC8 */
    994c:	54ca 0001 	pushw	#1
    9950:	72da 1070 	lod	A, #4208
    9954:	17a2      	call	0x989a <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 1 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    9956:	7ada 0056 	lod	Y, #86
				pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    995a:	7eda 1000 	lod	X, #4096
				do
    995e:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    9960:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    9962:	eeda 00c6 	cmp	Y, #198
    9966:	187c      	jc	0x9960 <_NVRAM_Store+0x68>
			}

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM1_PAGE1);
    9968:	7000      	lod	A, #0
    996a:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    996e:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE1) == FALSE )
    9972:	72da 1000 	lod	A, #4096
    9976:	17b3      	call	0x98de <_NVRAM_PageVerify>
    9978:	ac00      	cmp	A, #0
    997a:	1d04      	jne	0x9984 <_NVRAM_Store+0x8c>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG11);
    997c:	72da 00f4 	lod	A, #244
    9980:	82db 89e6 	callf	0x89e6 <_SetLastError>
		} while ( FALSE );
	}

#if _SUPPORT_NVRAM_BACKUP
	/* Duplicate NVRAM user page 1 into page 2 */
	if ( ((u16Page & C_NVRAM_USER_PAGE_2) != 0U) &&
    9984:	7203      	lod	A, [S-4]
    9986:	b402      	and	A, #2
    9988:	1d01      	jne	0x998c <_NVRAM_Store+0x94>
    998a:	0039      	jmp	0x99fe <_NVRAM_Store+0x106>
    998c:	7203      	lod	A, [S-4]
    998e:	b440      	and	A, #64
    9990:	1d05      	jne	0x999c <_NVRAM_Store+0xa4>
    9992:	72da 1100 	lod	A, #4352
    9996:	17a3      	call	0x98de <_NVRAM_PageVerify>
    9998:	ac00      	cmp	A, #0
    999a:	1d31      	jne	0x99fe <_NVRAM_Store+0x106>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    999c:	54ca 0000 	pushw	#0
    99a0:	72da 1170 	lod	A, #4464
    99a4:	177a      	call	0x989a <_NVRAM_CountCRC8>
    99a6:	5c01      	dec	S, #2
    99a8:	8cff      	cmp	AL, #-1
    99aa:	1906      	je	0x99b8 <_NVRAM_Store+0xc0>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    99ac:	7000      	lod	A, #0
    99ae:	7ada 1170 	lod	Y, #4464
    99b2:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    99b4:	7802      	lod	Y, #2
    99b6:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    99b8:	7ada 1170 	lod	Y, #4464
    99bc:	72f0      	lod	A, [Y]
    99be:	acfd      	cmp	A, #-3
    99c0:	1e02      	jug	0x99c6 <_NVRAM_Store+0xce>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    99c2:	a001      	add	A, #1
    99c4:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);
    99c6:	54ca 0001 	pushw	#1
    99ca:	72da 1170 	lod	A, #4464
    99ce:	1765      	call	0x989a <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 2 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    99d0:	7ada 0056 	lod	Y, #86
				pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    99d4:	7eda 1100 	lod	X, #4352
				do
    99d8:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    99da:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    99dc:	eeda 00c6 	cmp	Y, #198
    99e0:	187c      	jc	0x99da <_NVRAM_Store+0xe2>
			}

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1);
    99e2:	7002      	lod	A, #2
    99e4:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    99e8:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE2) == FALSE )
    99ec:	72da 1100 	lod	A, #4352
    99f0:	1776      	call	0x98de <_NVRAM_PageVerify>
    99f2:	ac00      	cmp	A, #0
    99f4:	1d04      	jne	0x99fe <_NVRAM_Store+0x106>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG21);
    99f6:	72da 00f6 	lod	A, #246
    99fa:	82db 89e6 	callf	0x89e6 <_SetLastError>
#endif /* _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE */
		} while ( FALSE );
	}
#endif /* _SUPPORT_NVRAM_BACKUP */
	return ( u16Result );
} /* NVRAM_Store() */
    99fe:	7201      	lod	A, [S-2]
    9a00:	5405      	ret	#6

00009a02 <_NVRAM_LoadUserPage>:
 * void NVRAM_LoadUserPage
 *
 * Load user NVRAM page (NVRAM to User-RAM).
 * ****************************************************************************	*/
void NVRAM_LoadUserPage( void)
{
    9a02:	5807      	inc	S, #8
	uint16 u16ErrorFlag;
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    9a04:	7ada 0056 	lod	Y, #86
    9a08:	5a05      	mov	[S-6], Y
#if (LINPROT == LIN2J_VALVE_VW)
	uint16 *pMRAM;
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80U) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    9a0a:	7ada 101d 	lod	Y, #4125
    9a0e:	66f0      	lod	YL, [Y]
    9a10:	f6da 0080 	and	Y, #128
    9a14:	7ee6      	lod	X, Y
    9a16:	7ada 111d 	lod	Y, #4381
    9a1a:	62f0      	lod	AL, [Y]
    9a1c:	b6da 0080 	and	A, #128
    9a20:	2ee2      	cmp	X, A
    9a22:	1904      	je	0x9a2c <_NVRAM_LoadUserPage+0x2a>
	{
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    9a24:	7eda 1100 	lod	X, #4352
    9a28:	5e03      	mov	[S-4], X
    9a2a:	0003      	jmp	0x9a32 <_NVRAM_LoadUserPage+0x30>
	}
	else
	{
		pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    9a2c:	7ada 1000 	lod	Y, #4096
    9a30:	5a03      	mov	[S-4], Y
	}
#else  /* (LINPROT == LIN2J_VALVE_VW) */
	uint16 *pMRAM = (uint16 *) C_ADDR_USERPAGE1;
#endif /* (LINPROT == LIN2J_VALVE_VW) */

	NVRAM_LoadAll();
    9a32:	82db 5a56 	callf	0x5a56 <_NVRAM_LoadAll>
	u16ErrorFlag = (VARIOUS_L & EENV_DED);										/* Double-bit error state */
    9a36:	6280      	lod	AL, io:0x0 <__dp__>
    9a38:	7ae2      	lod	Y, A
    9a3a:	f6da 0080 	and	Y, #128
    9a3e:	5a07      	mov	[S-8], Y
	/* Copy NVRAM MirrorRAM-copy into NVRAM UserRAM (to allow byte/bit access) */
	do
	{
		*pURAM++ = *pMRAM++;
    9a40:	7e05      	lod	X, [S-6]
    9a42:	7a03      	lod	Y, [S-4]
    9a44:	54c6      	movsw	[X++], [Y++]
    9a46:	5a03      	mov	[S-4], Y
    9a48:	5e05      	mov	[S-6], X
	} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9a4a:	2eda 00c6 	cmp	X, #198
    9a4e:	1878      	jc	0x9a40 <_NVRAM_LoadUserPage+0x3e>
	/* Check Double-bit NVRAM set, User-NVRAM structure-revision and User-NVRAM Checksum */
	if ( ((u16ErrorFlag == FALSE) && (VARIOUS_L & EENV_DED)) || (g_NvramUser.Revision != C_NVRAM_USER_REV) || (NVRAM_CRC8( FALSE) != 0xFF) || (g_NvramUser.ConfigurationID != CONFIGURATION_ID) )
    9a50:	7207      	lod	A, [S-8]
    9a52:	1d03      	jne	0x9a5a <_NVRAM_LoadUserPage+0x58>
    9a54:	6280      	lod	AL, io:0x0 <__dp__>
    9a56:	8c00      	cmp	AL, #0
    9a58:	1a8c      	jsl	0x9a72 <_NVRAM_LoadUserPage+0x70>
    9a5a:	6157      	lod	AL, dp:0x57 <_g_NvramUser+0x1>
    9a5c:	8c01      	cmp	AL, #1
    9a5e:	1d09      	jne	0x9a72 <_NVRAM_LoadUserPage+0x70>
    9a60:	7000      	lod	A, #0
    9a62:	1702      	call	0x9868 <_NVRAM_CRC8>
    9a64:	8cff      	cmp	AL, #-1
    9a66:	1d05      	jne	0x9a72 <_NVRAM_LoadUserPage+0x70>
    9a68:	715e      	lod	A, dp:0x5e <_g_NvramUser+0x8>
    9a6a:	aeda 5470 	cmp	A, #21616
    9a6e:	1d01      	jne	0x9a72 <_NVRAM_LoadUserPage+0x70>
    9a70:	006d      	jmp	0x9b4c <_NVRAM_LoadUserPage+0x14a>
	/* Check Double-Bit Error NVRAM, Wrong revision or Invalid Checksum */
	if ( u16ErrorFlag )
	{
		/* Double-bit error or incorrect revision or Invalid CRC; Copy NVRAM user page 2 into UserRAM */
		/* Note: EENV_DED can't be cleared !! In case of first user-page DBE, a second-page DBE can't be detected */
		u16ErrorFlag = (VARIOUS_L & EENV_DED);
    9a72:	6280      	lod	AL, io:0x0 <__dp__>
    9a74:	7ae2      	lod	Y, A
    9a76:	f6da 0080 	and	Y, #128
    9a7a:	5a07      	mov	[S-8], Y

#if (LINPROT == LIN2J_VALVE_VW)
		if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80U) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    9a7c:	7ada 101d 	lod	Y, #4125
    9a80:	66f0      	lod	YL, [Y]
    9a82:	f6da 0080 	and	Y, #128
    9a86:	7ee6      	lod	X, Y
    9a88:	7ada 111d 	lod	Y, #4381
    9a8c:	62f0      	lod	AL, [Y]
    9a8e:	b6da 0080 	and	A, #128
    9a92:	2ee2      	cmp	X, A
    9a94:	1904      	je	0x9a9e <_NVRAM_LoadUserPage+0x9c>
		{
			pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    9a96:	7eda 1000 	lod	X, #4096
    9a9a:	5e03      	mov	[S-4], X
    9a9c:	0003      	jmp	0x9aa4 <_NVRAM_LoadUserPage+0xa2>
		}
		else
		{
			pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    9a9e:	7ada 1100 	lod	Y, #4352
    9aa2:	5a03      	mov	[S-4], Y
		}
#else  /* (LINPROT == LIN2J_VALVE_VW) */
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
#endif /* (LINPROT == LIN2J_VALVE_VW) */
		pURAM = (uint16 *) &g_NvramUser;
    9aa4:	7eda 0056 	lod	X, #86
    9aa8:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    9aaa:	7e05      	lod	X, [S-6]
    9aac:	7a03      	lod	Y, [S-4]
    9aae:	54c6      	movsw	[X++], [Y++]
    9ab0:	5a03      	mov	[S-4], Y
    9ab2:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9ab4:	2eda 00c6 	cmp	X, #198
    9ab8:	1878      	jc	0x9aaa <_NVRAM_LoadUserPage+0xa8>
		if ( ((u16ErrorFlag != FALSE) || ((VARIOUS_L & EENV_DED) == 0U)) && (g_NvramUser.Revision == C_NVRAM_USER_REV) && (NVRAM_CRC8( FALSE) == 0xFF) && (g_NvramUser.ConfigurationID == CONFIGURATION_ID) )
    9aba:	7207      	lod	A, [S-8]
    9abc:	1d03      	jne	0x9ac4 <_NVRAM_LoadUserPage+0xc2>
    9abe:	6280      	lod	AL, io:0x0 <__dp__>
    9ac0:	8c00      	cmp	AL, #0
    9ac2:	1a92      	jsl	0x9ae8 <_NVRAM_LoadUserPage+0xe6>
    9ac4:	6157      	lod	AL, dp:0x57 <_g_NvramUser+0x1>
    9ac6:	8c01      	cmp	AL, #1
    9ac8:	1d0f      	jne	0x9ae8 <_NVRAM_LoadUserPage+0xe6>
    9aca:	7000      	lod	A, #0
    9acc:	16cd      	call	0x9868 <_NVRAM_CRC8>
    9ace:	8cff      	cmp	AL, #-1
    9ad0:	1d0b      	jne	0x9ae8 <_NVRAM_LoadUserPage+0xe6>
    9ad2:	715e      	lod	A, dp:0x5e <_g_NvramUser+0x8>
    9ad4:	aeda 5470 	cmp	A, #21616
    9ad8:	1d07      	jne	0x9ae8 <_NVRAM_LoadUserPage+0xe6>
		{
			/* Second User Page is correct; Rewrite 1st page */
			SetLastError( (uint8) C_ERR_INV_USERPAGE_1);
    9ada:	72da 00c0 	lod	A, #192
    9ade:	82db 89e6 	callf	0x89e6 <_SetLastError>
			(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_1 | C_NVRAM_USER_PAGE_FORCE));
    9ae2:	7041      	lod	A, #65
    9ae4:	1709      	call	0x98f8 <_NVRAM_Store>
			u16ErrorFlag = FALSE;
    9ae6:	5409      	ret	#10
#if (MOTOR_PARAMS == MP_NVRAM)
#if (_SUPPORT_CODE_PARAMS == FALSE)
	if ( u16ErrorFlag )
	{
		/* First and/or second page is corrupt; Log error and use default data */
		SetLastError( (uint8) C_ERR_INV_USERPAGE_BOTH);
    9ae8:	72da 00c2 	lod	A, #194
    9aec:	82db 89e6 	callf	0x89e6 <_SetLastError>
#else  /* (_SUPPORT_CODE_PARAMS == FALSE) */
		/* Always use hard-coded NVRAM value to be re-written in RAM-structure */
#endif /* (_SUPPORT_CODE_PARAMS == FALSE) */

		/* UniROM */
		pMRAM = (uint16 *) &defNvramUser;
    9af0:	7ada a226 	lod	Y, #41510
    9af4:	5a03      	mov	[S-4], Y
		pURAM = (uint16 *) &g_NvramUser;
    9af6:	7eda 0056 	lod	X, #86
    9afa:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    9afc:	7e05      	lod	X, [S-6]
    9afe:	7a03      	lod	Y, [S-4]
    9b00:	54c6      	movsw	[X++], [Y++]
    9b02:	5a03      	mov	[S-4], Y
    9b04:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9b06:	2eda 00c6 	cmp	X, #198
    9b0a:	1878      	jc	0x9afc <_NVRAM_LoadUserPage+0xfa>

#if (_SUPPORT_CODE_PARAMS == FALSE)
		{
			PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    9b0c:	7ada 1070 	lod	Y, #4208
    9b10:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFFU )				/* Check NVRAM User Page #1 Write-cycle counter CRC */
    9b12:	54ca 0000 	pushw	#0
    9b16:	72da 1070 	lod	A, #4208
    9b1a:	16bf      	call	0x989a <_NVRAM_CountCRC8>
    9b1c:	5c01      	dec	S, #2
    9b1e:	8cff      	cmp	AL, #-1
    9b20:	1904      	je	0x9b2a <_NVRAM_LoadUserPage+0x128>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0U;						/* Clear program cycle-counter */
    9b22:	7000      	lod	A, #0
    9b24:	7e01      	lod	X, [S-2]
    9b26:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0U;							/* Clear Error-log index & CRC */
    9b28:	52fa      	mov	[X+2], A
			}
			pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
    9b2a:	7ada 1170 	lod	Y, #4464
    9b2e:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFFU )				/* Check NVRAM User Page #2 Write-cycle counter CRC */
    9b30:	54ca 0000 	pushw	#0
    9b34:	72da 1170 	lod	A, #4464
    9b38:	16b0      	call	0x989a <_NVRAM_CountCRC8>
    9b3a:	5c01      	dec	S, #2
    9b3c:	8cff      	cmp	AL, #-1
    9b3e:	1904      	je	0x9b48 <_NVRAM_LoadUserPage+0x146>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0U;						/* Clear program cycle-counter */
    9b40:	7000      	lod	A, #0
    9b42:	7e01      	lod	X, [S-2]
    9b44:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0U;							/* Clear Error-log index & CRC */
    9b46:	52fa      	mov	[X+2], A
			}
		}
		(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_ALL | C_NVRAM_USER_PAGE_FORCE));	/* Write (both) user page(s) with default data */
    9b48:	7043      	lod	A, #67
    9b4a:	16d6      	call	0x98f8 <_NVRAM_Store>
    9b4c:	5409      	ret	#10

00009b4e <_NVRAM_StorePatch>:
 *
 * ****************************************************************************	*/
void NVRAM_StorePatch( void)
{
	//TODO[MMP]: Make sure NVRAM1 Trim value is correct
	NVRAM_SavePage( NVRAM1_PAGE2);
    9b4e:	7001      	lod	A, #1
    9b50:	82db 5abc 	callf	0x5abc <_NVRAM_SavePage>
	NVRAM_LoadUserPage();
    9b54:	1756      	call	0x9a02 <_NVRAM_LoadUserPage>
    9b56:	5401      	ret

00009b58 <_NVRAM_MlxCalibrationAreaCheck>:
 *	Post:	-
 * Comments: Check Melexis NVRAM-page gain-factors (non-zero)
 * ****************************************************************************	*/
void NVRAM_MlxCalibrationAreaCheck( void)
{
	if ( (EE_GLAA == 0U) ||														/* Auto addressing gain calibration */
    9b58:	72d8 11d6 	lod	A, 0x11d6 <__ep__+0x1d6>
    9b5c:	1913      	je	0x9b84 <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9b5e:	72d8 11d8 	lod	A, 0x11d8 <__ep__+0x1d8>
    9b62:	1910      	je	0x9b84 <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9b64:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    9b68:	b6da 00ff 	and	A, #255
    9b6c:	aeda ff00 	cmp	A, #65280
    9b70:	1909      	je	0x9b84 <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9b72:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9b76:	6000      	lod	AL, #0
    9b78:	72e4      	swap	A
    9b7a:	1904      	je	0x9b84 <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9b7c:	72d8 11ca 	lod	A, 0x11ca <__ep__+0x1ca>
    9b80:	8c00      	cmp	AL, #0
    9b82:	1d04      	jne	0x9b8c <_NVRAM_MlxCalibrationAreaCheck+0x34>
		 (EE_GDMCMAA == 0U) ||													/* Common Mode Rejection factor */
		 (EE_GMCURR == 0U) ||													/* CGAINCAL_FLT (Current sensor filter gain) */
		 (EE_GVOLTAGE == 0U) ||													/* VGAINCAL (supply sensor filter gain) */
		 (EE_GTEMP == 0U) )														/* Temperature Gain */
	{
		SetLastError( (uint8) C_ERR_NVRAM_MLX_CAL_GN);
    9b84:	72da 00cf 	lod	A, #207
    9b88:	82db 89e6 	callf	0x89e6 <_SetLastError>
    9b8c:	5401      	ret

00009b8e <_PID_Init>:

/* ***
 * PID_Init()
 * ***/
void PID_Init( void)
{
    9b8e:	5813      	inc	S, #20
	/* Convert [mA] to [ADC-lsb] */
	g_u16PidHoldingThreshold = NVRAM_HOLDING_CURR_LEVEL;
    9b90:	61a4      	lod	AL, dp:0xa4 <_g_NvramUser+0x4e>
    9b92:	5cf2      	usex	A
    9b94:	52d8 029a 	mov	0x29a <_g_u16PidHoldingThreshold>, A
    9b98:	7ed8 011e 	lod	X, 0x11e <_g_u16MCurrgain>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9b9c:	7ada 0080 	lod	Y, #128
    9ba0:	4821      	mulu	YA, A, Y
    9ba2:	4c63      	divu	YA, X
    9ba4:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9ba6:	52d8 029e 	mov	0x29e <_g_u16PidHoldingThresholdADC>, A
	g_u16PidHoldingThresholdADC = muldivU16_U16byU16byU16( g_u16PidHoldingThreshold, C_GMCURR_DIV, g_u16MCurrgain);
	g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL;
    9baa:	61a5      	lod	AL, dp:0xa5 <_g_NvramUser+0x4f>
    9bac:	44a2      	asl	A, #2
    9bae:	b6da 03fc 	and	A, #1020
    9bb2:	52d8 0296 	mov	0x296 <_g_u16PidRunningThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9bb6:	7ada 0080 	lod	Y, #128
    9bba:	4821      	mulu	YA, A, Y
    9bbc:	4c63      	divu	YA, X
    9bbe:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9bc0:	52d8 0298 	mov	0x298 <_g_u16PidRunningThresholdADC>, A
    9bc4:	6187      	lod	AL, dp:0x87 <_g_NvramUser+0x31>
    9bc6:	5cf2      	usex	A
    9bc8:	4872 0019 	muls	A, A, #25
    9bcc:	4432      	lsr	A
    9bce:	5205      	mov	[S-6], A
    9bd0:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9bd4:	6000      	lod	AL, #0
    9bd6:	72e4      	swap	A
    9bd8:	5203      	mov	[S-4], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9bda:	7040      	lod	A, #64
    9bdc:	7a05      	lod	Y, [S-6]
    9bde:	7e03      	lod	X, [S-4]
    9be0:	4821      	mulu	YA, A, Y
    9be2:	4c63      	divu	YA, X
    9be4:	4c63      	divu	YA, X
    9be6:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9be8:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9bec:	5ce2      	ssex	A
    9bee:	a201      	add	A, [S-2]
    9bf0:	52d8 0132 	mov	0x132 <_l_u16MotorRefVoltageADC>, A
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GVOLTAGE) + EE_OVOLTAGE;
#else  /* _SUPPORT_VSMFILTERED */
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GADC) + EE_OADC;
#endif /* _SUPPORT_VSMFILTERED */

	l_u16MinCorrectionRatio = NVRAM_MIN_CORR_RATIO;
    9bf4:	61ba      	lod	AL, dp:0xba <__bss_dp_size+0xa>
    9bf6:	5cf2      	usex	A
    9bf8:	4812 0618 	muls	D, A, #1560
    9bfc:	7aef      	lod	Y, S
    9bfe:	e0f2      	add	Y, #-14
    9c00:	4c85      	mov	[Y], D
    9c02:	720d      	lod	A, [S-14]
    9c04:	7a0b      	lod	Y, [S-12]
    9c06:	48a3      	lsr	YA, #4
    9c08:	52d8 02a0 	mov	0x2a0 <_l_u16MinCorrectionRatio>, A
	l_u16MaxCorrectionRatio = NVRAM_MAX_CORR_RATIO;
    9c0c:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    9c0e:	5cf2      	usex	A
    9c10:	a001      	add	A, #1
    9c12:	4812 0618 	muls	D, A, #1560
    9c16:	7aef      	lod	Y, S
    9c18:	e0f6      	add	Y, #-10
    9c1a:	4c85      	mov	[Y], D
    9c1c:	7209      	lod	A, [S-10]
    9c1e:	7a07      	lod	Y, [S-8]
    9c20:	48a3      	lsr	YA, #4
    9c22:	52d8 02a2 	mov	0x2a2 <_l_u16MaxCorrectionRatio>, A
    9c26:	5415      	ret	#22

00009c28 <_VoltageCorrection>:
 *
 *	Compensate Motor PWM Duty Cycle for voltage changes
 * Performance: 7.5us @ 20Mz
 * ***/
void VoltageCorrection( void)
{
    9c28:	5801      	inc	S, #2

#define ADC_SETTING (uint16)(((2U*PLL_freq)/(1000000U*(2U*CYCLES_PER_INSTR))) + 1U)	/* 2us: 2us*PLL-freq/(10000000us/s * #cycles/instruction) */

static INLINE uint16 GetRawVsupplyMotor( void)
{
extern T_ADC_MOTORRUN_STEPPER4 volatile g_AdcMotorRunStepper4;					/* ADC results Stepper mode */
    9c2a:	7ed8 0152 	lod	X, 0x152 <_g_AdcMotorRunStepper4+0x6>
	uint16 u16MotorVoltageADC = GetRawVsupplyMotor();
	if ( (u16MotorVoltageADC > 0) && (l_u16MotorRefVoltageADC > 0) )
    9c2e:	1920      	je	0x9c70 <_VoltageCorrection+0x48>
    9c30:	7ad8 0132 	lod	Y, 0x132 <_l_u16MotorRefVoltageADC>
    9c34:	191d      	je	0x9c70 <_VoltageCorrection+0x48>
    9c36:	72d8 0294 	lod	A, 0x294 <_g_u16PidCtrlRatio>
    uint32 result;

    __asm__ __volatile__ (
    9c3a:	4801      	mulu	D, A, Y
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9c3c:	4c80      	mov	YA, D
    9c3e:	4c63      	divu	YA, X
    9c40:	4c63      	divu	YA, X
    9c42:	7ee2      	lod	X, A
	{
		/* Correct Motor PWM duty cycle instantly based on change of supply voltage */
		uint16 u16NewCorrectionRatio = divU16_U32byU16( mulU32_U16byU16( g_u16PidCtrlRatio, l_u16MotorRefVoltageADC), u16MotorVoltageADC);
		if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    9c44:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9c46:	b401      	and	A, #1
    9c48:	1909      	je	0x9c5c <_VoltageCorrection+0x34>
		{
			if ( u16NewCorrectionRatio < l_u16MinCorrectionRatio )
    9c4a:	72d8 02a0 	lod	A, 0x2a0 <_l_u16MinCorrectionRatio>
    9c4e:	2ee2      	cmp	X, A
    9c50:	180c      	jc	0x9c6a <_VoltageCorrection+0x42>
			{
				/* Underflow */
				u16NewCorrectionRatio = l_u16MinCorrectionRatio;
			}
			else if ( u16NewCorrectionRatio > l_u16MaxPidCtrlRatio )
    9c52:	72d8 029c 	lod	A, 0x29c <_l_u16MaxPidCtrlRatio>
    9c56:	2ee2      	cmp	X, A
    9c58:	1a09      	jule	0x9c6c <_VoltageCorrection+0x44>
    9c5a:	0007      	jmp	0x9c6a <_VoltageCorrection+0x42>
			{
				/* Overflow */
				u16NewCorrectionRatio = l_u16MaxPidCtrlRatio;
			}
		}
		else if ( u16NewCorrectionRatio < NVRAM_MIN_HOLDCORR_RATIO )
    9c5c:	61b9      	lod	AL, dp:0xb9 <__bss_dp_size+0x9>
    9c5e:	5cf2      	usex	A
    9c60:	4832 0618 	muls	YA, A, #1560
    9c64:	48a3      	lsr	YA, #4
    9c66:	2ee2      	cmp	X, A
    9c68:	1c01      	jnc	0x9c6c <_VoltageCorrection+0x44>
		{
			/* Underflow */
			u16NewCorrectionRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9c6a:	7ee2      	lod	X, A
		}
		g_u16CorrectionRatio = u16NewCorrectionRatio;
    9c6c:	5d4a      	mov	dp:0x4a <_g_u16CorrectionRatio>, X
    9c6e:	5403      	ret	#4
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    9c70:	72d8 0294 	lod	A, 0x294 <_g_u16PidCtrlRatio>
    9c74:	514a      	mov	dp:0x4a <_g_u16CorrectionRatio>, A
    9c76:	5403      	ret	#4

00009c78 <_PID_Control>:
 *	DC: Motor PWM Duty Cycle; 
 *	Stepper: current-control;
 *	BEMF: speed-control
 * ***/
void PID_Control( void)
{
    9c78:	5801      	inc	S, #2
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) ||
    9c7a:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9c7c:	b401      	and	A, #1
    9c7e:	1d07      	jne	0x9c8e <_PID_Control+0x16>
    9c80:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9c82:	1901      	je	0x9c86 <_PID_Control+0xe>
    9c84:	0095      	jmp	0x9db0 <_PID_Control+0x138>
    9c86:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    9c8a:	1d01      	jne	0x9c8e <_PID_Control+0x16>
    9c8c:	0091      	jmp	0x9db0 <_PID_Control+0x138>
			 ((g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE)) ) 	/* Stop-mode & holding-current required */
	{
		/* Running-mode and NOT stall-mode "B" */
		if ( (((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) &&
    9c8e:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9c90:	b401      	and	A, #1
    9c92:	1906      	je	0x9ca0 <_PID_Control+0x28>
    9c94:	61b3      	lod	AL, dp:0xb3 <__bss_dp_size+0x3>
    9c96:	1904      	je	0x9ca0 <_PID_Control+0x28>
    9c98:	5cf2      	usex	A
    9c9a:	aed8 013c 	cmp	A, 0x13c <_g_u16PID_CtrlCounter>
    9c9e:	1a0f      	jule	0x9cbe <_PID_Control+0x46>
    9ca0:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9ca2:	1901      	je	0x9ca6 <_PID_Control+0x2e>
    9ca4:	007d      	jmp	0x9da0 <_PID_Control+0x128>
    9ca6:	61b4      	lod	AL, dp:0xb4 <__bss_dp_size+0x4>
    9ca8:	44a2      	asl	A, #2
    9caa:	7ae2      	lod	Y, A
    9cac:	f6da 03fc 	and	Y, #1020
    9cb0:	1d01      	jne	0x9cb4 <_PID_Control+0x3c>
    9cb2:	0076      	jmp	0x9da0 <_PID_Control+0x128>
    9cb4:	72d8 013c 	lod	A, 0x13c <_g_u16PID_CtrlCounter>
    9cb8:	aee6      	cmp	A, Y
    9cba:	1c01      	jnc	0x9cbe <_PID_Control+0x46>
    9cbc:	0071      	jmp	0x9da0 <_PID_Control+0x128>
			int16 i16PID_Ipart;
			int16 i16PID_Ppart;
			uint16 u16PidCtrlRatio;

			/* Current Control */
			uint16 u16MotorCurrentLPFFraction = ((g_u16MotorCurrentLPFx64 + 32) >> 6);
    9cbe:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentLPFx64>
    9cc0:	7ae2      	lod	Y, A
    9cc2:	e020      	add	Y, #32
    9cc4:	44b6      	lsr	Y, #2
    9cc6:	44b6      	lsr	Y, #2
    9cc8:	44b6      	lsr	Y, #2
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    9cca:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9ccc:	b401      	and	A, #1
    9cce:	1909      	je	0x9ce2 <_PID_Control+0x6a>
			{
				i16ControlError = (int16) (g_u16PidRunningThresholdADC - u16MotorCurrentLPFFraction);
    9cd0:	72d8 0298 	lod	A, 0x298 <_g_u16PidRunningThresholdADC>
    9cd4:	7ee2      	lod	X, A
    9cd6:	2ae6      	sub	X, Y
				l_u16MaxPidCtrlRatio = l_u16MaxCorrectionRatio;
    9cd8:	72d8 02a2 	lod	A, 0x2a2 <_l_u16MaxCorrectionRatio>
    9cdc:	52d8 029c 	mov	0x29c <_l_u16MaxPidCtrlRatio>, A
    9ce0:	0004      	jmp	0x9cea <_PID_Control+0x72>
			}
			else
			{
				i16ControlError = (int16) (g_u16PidHoldingThresholdADC - u16MotorCurrentLPFFraction);
    9ce2:	72d8 029e 	lod	A, 0x29e <_g_u16PidHoldingThresholdADC>
    9ce6:	7ee2      	lod	X, A
    9ce8:	2ae6      	sub	X, Y
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9cea:	7aee      	lod	Y, X
    9cec:	ead8 013e 	sub	Y, 0x13e <_g_i16PID_E>
    9cf0:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    9cf2:	5cf2      	usex	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9cf4:	4831      	muls	YA, A, Y
    9cf6:	48b5      	asr	YA, #6
    9cf8:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9cfa:	52d8 0140 	mov	0x140 <_g_i16PID_D>, A
			}

			/* Derivative-part */
			g_i16PID_D = mulI16_I16byI16RndDiv64( (i16ControlError - g_i16PID_E), NVRAM_PID_COEF_D);
			g_i16PID_E = i16ControlError;
    9cfe:	5ed8 013e 	mov	0x13e <_g_i16PID_E>, X
    9d02:	61b6      	lod	AL, dp:0xb6 <__bss_dp_size+0x6>
    9d04:	66e0      	lod	YL, AL
    9d06:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9d08:	72e6      	lod	A, Y
    9d0a:	4833      	muls	YA, A, X
    9d0c:	48b5      	asr	YA, #6
    9d0e:	b000      	adc	A, #0
    9d10:	5201      	mov	[S-2], A
			/* Integral-part */
			i16PID_Ipart = mulI16_I16byI16RndDiv64( i16ControlError, NVRAM_PID_COEF_I);
			if ( (i16PID_Ipart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ipart)) )
    9d12:	ac00      	cmp	A, #0
    9d14:	1e86      	jsge	0x9d22 <_PID_Control+0xaa>
    9d16:	7201      	lod	A, [S-2]
    9d18:	5cc2      	neg	A
    9d1a:	adc6      	cmp	A, dp:0xc6 <_g_u16PID_I>
    9d1c:	1a02      	jule	0x9d22 <_PID_Control+0xaa>
			{
				g_u16PID_I = 0;
    9d1e:	7000      	lod	A, #0
    9d20:	0002      	jmp	0x9d26 <_PID_Control+0xae>
			}
			else
			{
				g_u16PID_I = (uint16) (g_u16PID_I + i16PID_Ipart);
    9d22:	71c6      	lod	A, dp:0xc6 <_g_u16PID_I>
    9d24:	a201      	add	A, [S-2]
    9d26:	51c6      	mov	dp:0xc6 <_g_u16PID_I>, A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9d28:	61b5      	lod	AL, dp:0xb5 <__bss_dp_size+0x5>
    9d2a:	66e0      	lod	YL, AL
    9d2c:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9d2e:	72e6      	lod	A, Y
    9d30:	4833      	muls	YA, A, X
    9d32:	48b5      	asr	YA, #6
    9d34:	b000      	adc	A, #0
    9d36:	7ee2      	lod	X, A
			}
			/* Proportional-part */
			i16PID_Ppart = mulI16_I16byI16RndDiv64( i16ControlError, (int16) NVRAM_PID_COEF_P);
			if ( (i16PID_Ppart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ppart)) )
    9d38:	ac00      	cmp	A, #0
    9d3a:	1e92      	jsge	0x9d60 <_PID_Control+0xe8>
    9d3c:	5cc2      	neg	A
    9d3e:	adc6      	cmp	A, dp:0xc6 <_g_u16PID_I>
    9d40:	1a0f      	jule	0x9d60 <_PID_Control+0xe8>
			{
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    9d42:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9d44:	b401      	and	A, #1
    9d46:	1903      	je	0x9d4e <_PID_Control+0xd6>
				{
					u16PidCtrlRatio = l_u16MinCorrectionRatio;
    9d48:	7ed8 02a0 	lod	X, 0x2a0 <_l_u16MinCorrectionRatio>
    9d4c:	0006      	jmp	0x9d5a <_PID_Control+0xe2>
				}
				else
				{
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9d4e:	61b9      	lod	AL, dp:0xb9 <__bss_dp_size+0x9>
    9d50:	5cf2      	usex	A
    9d52:	4832 0618 	muls	YA, A, #1560
    9d56:	48a3      	lsr	YA, #4
    9d58:	7ee2      	lod	X, A
				}
				g_u16PID_I = 0;
    9d5a:	7000      	lod	A, #0
    9d5c:	51c6      	mov	dp:0xc6 <_g_u16PID_I>, A
    9d5e:	001b      	jmp	0x9d96 <_PID_Control+0x11e>
			}
			else
			{
				u16PidCtrlRatio = (uint16) (g_u16PID_I + i16PID_Ppart + g_i16PID_D);
    9d60:	71c6      	lod	A, dp:0xc6 <_g_u16PID_I>
    9d62:	a2ee      	add	A, X
    9d64:	7ee2      	lod	X, A
    9d66:	22d8 0140 	add	X, 0x140 <_g_i16PID_D>
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    9d6a:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9d6c:	b401      	and	A, #1
    9d6e:	190b      	je	0x9d86 <_PID_Control+0x10e>
				{
					if ( u16PidCtrlRatio < l_u16MinCorrectionRatio )
    9d70:	72d8 02a0 	lod	A, 0x2a0 <_l_u16MinCorrectionRatio>
    9d74:	2ee2      	cmp	X, A
    9d76:	180e      	jc	0x9d94 <_PID_Control+0x11c>
					{
						/* Underflow */
						u16PidCtrlRatio = l_u16MinCorrectionRatio;
					}
					else if ( u16PidCtrlRatio >= l_u16MaxPidCtrlRatio )
    9d78:	72d8 029c 	lod	A, 0x29c <_l_u16MaxPidCtrlRatio>
    9d7c:	2ee2      	cmp	X, A
    9d7e:	180b      	jc	0x9d96 <_PID_Control+0x11e>
					{
						/* Overflow */
						u16PidCtrlRatio = l_u16MaxPidCtrlRatio;
    9d80:	7ee2      	lod	X, A
						g_u16PID_I = u16PidCtrlRatio;
    9d82:	51c6      	mov	dp:0xc6 <_g_u16PID_I>, A
    9d84:	0008      	jmp	0x9d96 <_PID_Control+0x11e>
					}
				}
				else if ( u16PidCtrlRatio < NVRAM_MIN_HOLDCORR_RATIO )
    9d86:	61b9      	lod	AL, dp:0xb9 <__bss_dp_size+0x9>
    9d88:	5cf2      	usex	A
    9d8a:	4832 0618 	muls	YA, A, #1560
    9d8e:	48a3      	lsr	YA, #4
    9d90:	2ee2      	cmp	X, A
    9d92:	1c01      	jnc	0x9d96 <_PID_Control+0x11e>
				{
					/* Underflow */
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9d94:	7ee2      	lod	X, A
				}
			}
			g_u16PidCtrlRatio = u16PidCtrlRatio;
    9d96:	5ed8 0294 	mov	0x294 <_g_u16PidCtrlRatio>, X
			g_u16PID_CtrlCounter = 0;
    9d9a:	7000      	lod	A, #0
    9d9c:	52d8 013c 	mov	0x13c <_g_u16PID_CtrlCounter>, A
		}
		VoltageCorrection();
    9da0:	1743      	call	0x9c28 <_VoltageCorrection>

		/* Update motor-driver PWM duty-cycle in case of holding-mode with coil-current */

		/* Stop-mode & holding-current required */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE) )
    9da2:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9da4:	1d05      	jne	0x9db0 <_PID_Control+0x138>
    9da6:	62d8 012c 	lod	AL, 0x12c <_g_u8MotorHoldingCurrState>
    9daa:	1902      	je	0x9db0 <_PID_Control+0x138>
		{
			MotorDriver_4PhaseStepper();
    9dac:	82db 907a 	callf	0x907a <_MotorDriver_4PhaseStepper>
    9db0:	5403      	ret	#4

00009db2 <_ThresholdControl>:
 *	DC-Motor: Motor Power
 *	Stepper: Current Threshold Control
 *	BEMF: Nothing
 * ***/
void ThresholdControl( void)
{
    9db2:	583d      	inc	S, #62
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0) && (g_u16PID_ThrshldCtrlCounter >= NVRAM_PID_THRSHLDCTRL_PER) )
    9db4:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    9db6:	66e0      	lod	YL, AL
    9db8:	f401      	and	Y, #1
    9dba:	1901      	je	0x9dbe <_ThresholdControl+0xc>
    9dbc:	0098      	jmp	0x9eee <_ThresholdControl+0x13c>
    9dbe:	69b8      	lod	AH, dp:0xb8 <__bss_dp_size+0x8>
    9dc0:	6000      	lod	AL, #0
    9dc2:	4472      	asr	A
    9dc4:	aed8 013a 	cmp	A, 0x13a <_g_u16PID_ThrshldCtrlCounter>
    9dc8:	1a01      	jule	0x9dcc <_ThresholdControl+0x1a>
    9dca:	0091      	jmp	0x9eee <_ThresholdControl+0x13c>
	{
		uint16 u16CurrThrshldRatio;
		int16 i16TemperatureBgn = NVRAM_CURRTHRSHLD_TEMP_1;
    9dcc:	65aa      	lod	YL, dp:0xaa <_g_NvramUser+0x54>
    9dce:	5cf6      	usex	Y
    9dd0:	7ee6      	lod	X, Y
    9dd2:	e0c4      	add	Y, #-60
    9dd4:	5a37      	mov	[S-56], Y
		uint16 u16CurrThrshldRatioBgn = NVRAM_CURRTHRSHLD_RATIO_1;
    9dd6:	61ab      	lod	AL, dp:0xab <_g_NvramUser+0x55>
    9dd8:	5cf2      	usex	A
    9dda:	5235      	mov	[S-54], A

		g_u16PID_ThrshldCtrlCounter = 0;
    9ddc:	7800      	lod	Y, #0
    9dde:	5ad8 013a 	mov	0x13a <_g_u16PID_ThrshldCtrlCounter>, Y

#if _SUPPORT_AMBIENT_TEMP
		if ( g_i16AmbjTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
    9de2:	20c2      	add	X, #-62
    9de4:	5e33      	mov	[S-52], X
    9de6:	7d1e      	lod	X, dp:0x1e <__ramfunc_size>
    9de8:	61b2      	lod	AL, dp:0xb2 <__bss_dp_size+0x2>
    9dea:	420b      	mov	[S-12], AL
    9dec:	7ad8 029a 	lod	Y, 0x29a <_g_u16PidHoldingThreshold>
    9df0:	5a09      	mov	[S-10], Y
    9df2:	72d8 011e 	lod	A, 0x11e <_g_u16MCurrgain>
    9df6:	5207      	mov	[S-8], A
    9df8:	7ad8 0296 	lod	Y, 0x296 <_g_u16PidRunningThreshold>
    9dfc:	5a05      	mov	[S-6], Y
    9dfe:	2e33      	cmp	X, [S-52]
    9e00:	1e86      	jsge	0x9e0e <_ThresholdControl+0x5c>
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( g_i16ChipTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( NVRAM_CURRTHRSHLD_ZONE_1 != 0 )
    9e02:	620b      	lod	AL, [S-12]
    9e04:	b401      	and	A, #1
    9e06:	1901      	je	0x9e0a <_ThresholdControl+0x58>
    9e08:	0043      	jmp	0x9e90 <_ThresholdControl+0xde>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;					/* Same as point _1 */
			}
			else
			{
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
    9e0a:	7000      	lod	A, #0
    9e0c:	005b      	jmp	0x9ec4 <_ThresholdControl+0x112>
			}
		}
		else
		{
			uint8 u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_2;				/* Get current threshold compensation-type */
    9e0e:	620b      	lod	AL, [S-12]
    9e10:	4430      	lsr	AL
    9e12:	66e0      	lod	YL, AL
    9e14:	f403      	and	Y, #3
    9e16:	5a2f      	mov	[S-48], Y
			uint16 u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_2;			/* Get zone end point (_2) */
    9e18:	65ad      	lod	YL, dp:0xad <_g_NvramUser+0x57>
    9e1a:	5cf6      	usex	Y
    9e1c:	5a2b      	mov	[S-44], Y
			int16 i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_2;						
    9e1e:	65ac      	lod	YL, dp:0xac <_g_NvramUser+0x56>
    9e20:	5cf6      	usex	Y
    9e22:	7ee6      	lod	X, Y
    9e24:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
			if ( g_i16AmbjTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
    9e26:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    9e28:	aeee      	cmp	A, X
    9e2a:	1b2f      	jsle	0x9e8a <_ThresholdControl+0xd8>
#else  /* _SUPPORT_AMBIENT_TEMP */
			if ( g_i16ChipTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
#endif /* _SUPPORT_AMBIENT_TEMP */
			{
				i16TemperatureBgn = i16TemperatureEnd;							/* Next zone; begin point (_2) */
    9e2c:	5e37      	mov	[S-56], X
				u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    9e2e:	7a2b      	lod	Y, [S-44]
    9e30:	5a35      	mov	[S-54], Y
				u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_3;
    9e32:	620b      	lod	AL, [S-12]
    9e34:	44b0      	lsr	AL, #2
    9e36:	4430      	lsr	AL
    9e38:	66e0      	lod	YL, AL
    9e3a:	f403      	and	Y, #3
    9e3c:	5a2f      	mov	[S-48], Y
				u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_3;				/* Get zone end point (_3) */
    9e3e:	65af      	lod	YL, dp:0xaf <_g_NvramUser+0x59>
    9e40:	5cf6      	usex	Y
    9e42:	5a2b      	mov	[S-44], Y
				i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_3;
    9e44:	65ae      	lod	YL, dp:0xae <_g_NvramUser+0x58>
    9e46:	5cf6      	usex	Y
    9e48:	7ee6      	lod	X, Y
    9e4a:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
				if ( g_i16AmbjTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
    9e4c:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    9e4e:	aeee      	cmp	A, X
    9e50:	1b1c      	jsle	0x9e8a <_ThresholdControl+0xd8>
#else  /* _SUPPORT_AMBIENT_TEMP */
				if ( g_i16ChipTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
#endif /* _SUPPORT_AMBIENT_TEMP */
				{
					i16TemperatureBgn = i16TemperatureEnd;						/* Next zone; begin point (_3) */
    9e52:	5e37      	mov	[S-56], X
					u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    9e54:	7a2b      	lod	Y, [S-44]
    9e56:	5a35      	mov	[S-54], Y
					u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_4;
    9e58:	620b      	lod	AL, [S-12]
    9e5a:	44b0      	lsr	AL, #2
    9e5c:	44b0      	lsr	AL, #2
    9e5e:	4430      	lsr	AL
    9e60:	66e0      	lod	YL, AL
    9e62:	f403      	and	Y, #3
    9e64:	5a2f      	mov	[S-48], Y
					u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_4;			/* Get zone end point (_3) */
    9e66:	65b1      	lod	YL, dp:0xb1 <__bss_dp_size+0x1>
    9e68:	5cf6      	usex	Y
    9e6a:	5a2b      	mov	[S-44], Y
					i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_4;
    9e6c:	65b0      	lod	YL, dp:0xb0 <__bss_dp_size>
    9e6e:	5cf6      	usex	Y
    9e70:	7ee6      	lod	X, Y
    9e72:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
					if ( g_i16AmbjTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
    9e74:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    9e76:	aeee      	cmp	A, X
    9e78:	1b08      	jsle	0x9e8a <_ThresholdControl+0xd8>
#else  /* _SUPPORT_AMBIENT_TEMP */
					if ( g_i16ChipTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
#endif /* _SUPPORT_AMBIENT_TEMP */
					{
						u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_5;
    9e7a:	620b      	lod	AL, [S-12]
    9e7c:	4440      	rl	AL
    9e7e:	9401      	and	AL, #1
    9e80:	66e0      	lod	YL, AL
    9e82:	5cf6      	usex	Y
    9e84:	62e8      	lod	AL, YL
    9e86:	5cf2      	usex	A
    9e88:	522f      	mov	[S-48], A
					}
				}
			}
			if ( u8CurrThrshldCtrlType == 1 )
    9e8a:	622f      	lod	AL, [S-48]
    9e8c:	8c01      	cmp	AL, #1
    9e8e:	1d02      	jne	0x9e94 <_ThresholdControl+0xe2>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;
    9e90:	7a35      	lod	Y, [S-54]
    9e92:	001b      	jmp	0x9eca <_ThresholdControl+0x118>
			}
			else if ( u8CurrThrshldCtrlType == 2 )
    9e94:	622f      	lod	AL, [S-48]
    9e96:	8c02      	cmp	AL, #2
    9e98:	1d02      	jne	0x9e9e <_ThresholdControl+0xec>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioEnd;
    9e9a:	7a2b      	lod	Y, [S-44]
    9e9c:	0016      	jmp	0x9eca <_ThresholdControl+0x118>
			}
			else if ( u8CurrThrshldCtrlType == 3 )
    9e9e:	622f      	lod	AL, [S-48]
    9ea0:	8c03      	cmp	AL, #3
    9ea2:	1d12      	jne	0x9ec8 <_ThresholdControl+0x116>
			{
				i16TemperatureEnd = i16TemperatureEnd - i16TemperatureBgn;
    9ea4:	2a37      	sub	X, [S-56]
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    9ea6:	7a2b      	lod	Y, [S-44]
    9ea8:	ea35      	sub	Y, [S-54]
    9eaa:	5a15      	mov	[S-22], Y
    9eac:	711e      	lod	A, dp:0x1e <__ramfunc_size>
    9eae:	aa37      	sub	A, [S-56]
    9eb0:	5213      	mov	[S-20], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9eb2:	7215      	lod	A, [S-22]
    9eb4:	7a13      	lod	Y, [S-20]
    9eb6:	4831      	muls	YA, A, Y
    9eb8:	4c73      	divs	YA, X
    9eba:	4c73      	divs	YA, X
    9ebc:	4c7b      	dadjs	YA, X
    9ebe:	7ee2      	lod	X, A
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    9ec0:	7235      	lod	A, [S-54]
    9ec2:	a2ee      	add	A, X
    9ec4:	5203      	mov	[S-4], A
    9ec6:	0002      	jmp	0x9ecc <_ThresholdControl+0x11a>
				u16CurrThrshldRatio = (uint16) (muldivI16_I16byI16byI16( ((int16) u16CurrThrshldRatioEnd - (int16) u16CurrThrshldRatioBgn), (g_i16ChipTemperature - i16TemperatureBgn), i16TemperatureEnd) + u16CurrThrshldRatioBgn);
#endif /* _SUPPORT_AMBIENT_TEMP */
			}
			else
			{
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
    9ec8:	7800      	lod	Y, #0
    9eca:	5a03      	mov	[S-4], Y
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9ecc:	7209      	lod	A, [S-10]
    9ece:	7a03      	lod	Y, [S-4]
    9ed0:	7e07      	lod	X, [S-8]
    9ed2:	4821      	mulu	YA, A, Y
    9ed4:	4c63      	divu	YA, X
    9ed6:	4c63      	divu	YA, X
    9ed8:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9eda:	52d8 029e 	mov	0x29e <_g_u16PidHoldingThresholdADC>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9ede:	7205      	lod	A, [S-6]
    9ee0:	7a03      	lod	Y, [S-4]
    9ee2:	4821      	mulu	YA, A, Y
    9ee4:	4c63      	divu	YA, X
    9ee6:	4c63      	divu	YA, X
    9ee8:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9eea:	52d8 0298 	mov	0x298 <_g_u16PidRunningThresholdADC>, A
    9eee:	543f      	ret	#64

00009ef0 <_SelfHeatCompensation>:
 *	The self-heating compensation is split into two parts:
 *	1. Chip self-heating based on supply-voltage level (3-6C).
 *	2. Chip self-heating based on motor-current through FET's (up to 10-15C).
 * ***/
void SelfHeatCompensation( void)
{
    9ef0:	5803      	inc	S, #4
	if ( g_u16SelfHeatingCounter >= 500 )
    9ef2:	72d8 0138 	lod	A, 0x138 <_g_u16SelfHeatingCounter>
    9ef6:	aeda 01f3 	cmp	A, #499
    9efa:	1a2b      	jule	0x9f52 <_SelfHeatCompensation+0x62>
	{
		uint16 u16SelfHeating;

		g_u16SelfHeatingCounter -= 500;
    9efc:	a2da fe0c 	add	A, #65036
    9f00:	52d8 0138 	mov	0x138 <_g_u16SelfHeatingCounter>, A

		l_u32SelfHeatingIntegrator = (uint32) (mulU32hi_U32byU16( l_u32SelfHeatingIntegrator, 64600U) + ((g_u16MotorCurrentMovAvgxN + 8) >> 4));
    9f04:	54ca fc58 	pushw	#64600
    9f08:	72d8 0134 	lod	A, 0x134 <_l_u32SelfHeatingIntegrator>
    9f0c:	7ad8 0136 	lod	Y, 0x136 <_l_u32SelfHeatingIntegrator+0x2>
    9f10:	82db 6ca0 	callf	0x6ca0 <_mulU32hi_U32byU16>
    9f14:	5205      	mov	[S-6], A
    9f16:	5a03      	mov	[S-4], Y
    9f18:	7152      	lod	A, dp:0x52 <_g_u16MotorCurrentMovAvgxN>
    9f1a:	a008      	add	A, #8
    9f1c:	44b2      	lsr	A, #2
    9f1e:	44b2      	lsr	A, #2
    9f20:	4cc8      	movu	D, A
    9f22:	4c80      	mov	YA, D
    9f24:	a205      	add	A, [S-6]
    9f26:	f203      	adc	Y, [S-4]
    9f28:	5205      	mov	[S-6], A
    9f2a:	5a03      	mov	[S-4], Y
    9f2c:	52d8 0134 	mov	0x134 <_l_u32SelfHeatingIntegrator>, A
    9f30:	5ad8 0136 	mov	0x136 <_l_u32SelfHeatingIntegrator+0x2>, Y
		u16SelfHeating = (uint16) mulU32hi_U32byU16( l_u32SelfHeatingIntegrator, 52U);
    9f34:	54ca 0034 	pushw	#52
    9f38:	7207      	lod	A, [S-8]
    9f3a:	7a05      	lod	Y, [S-6]
    9f3c:	82db 6ca0 	callf	0x6ca0 <_mulU32hi_U32byU16>

		/* Chip-self-heating based on supply-level: Approx 1C per 3V */
		g_i16AmbjTemperature = (g_i16ChipTemperature - (int16)u16SelfHeating) - (g_i16SupplyVoltage >> 8);
    9f40:	7920      	lod	Y, dp:0x20 <__data_dp_size>
    9f42:	eae2      	sub	Y, A
    9f44:	72d8 010a 	lod	A, 0x10a <_g_i16SupplyVoltage>
    9f48:	62e4      	lod	AL, AH
    9f4a:	5ce2      	ssex	A
    9f4c:	eae2      	sub	Y, A
    9f4e:	591e      	mov	dp:0x1e <__ramfunc_size>, Y
    9f50:	5c03      	dec	S, #4
    9f52:	5405      	ret	#6

00009f54 <_Timer_Init>:
 *
 * Initialise the core timer (Mulan2-timer), at a periodic rate of 500us
 * ****************************************************************************	*/
void Timer_Init( void)
{
	TIMER = TMR_EN | CT_PERIODIC_RATE;											/* 500us timer */
    9f54:	72da 81f4 	lod	A, #33268
    9f58:	5286      	mov	io:0x6 <_LinMess2>, A
	PRIO = (PRIO & ~(3 << 0)) | ((6 - 3) << 0);									/* Set CoreTimer priority to 6 (3..6) */
    9f5a:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    9f5e:	a403      	or	A, #3
    9f60:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_TIMER_IT;
    9f64:	7020      	lod	A, #32
    9f66:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_TIMER_IT;														/* Enable Timer interrupt */
    9f6a:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    9f6e:	a420      	or	A, #32
    9f70:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    9f74:	5401      	ret

00009f76 <_Timer_SleepCompensation>:
 * Timer_SleepCompensation()
 *
 * Compensate the various timer-counters for the sleep-period
 * ****************************************************************************	*/
void Timer_SleepCompensation( uint16 u16SleepPeriod)
{
    9f76:	5805      	inc	S, #6
    9f78:	5205      	mov	[S-6], A
    9f7a:	7ada 0100 	lod	Y, #256
    9f7e:	7eda 36b0 	lod	X, #14000
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9f82:	4821      	mulu	YA, A, Y
    9f84:	4c63      	divu	YA, X
    9f86:	4c63      	divu	YA, X
    9f88:	5203      	mov	[S-4], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f8a:	5205      	mov	[S-6], A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    9f8c:	72e3      	lod	A, M
    9f8e:	5201      	mov	[S-2], A
	u16SleepPeriod = muldivU16_U16byU16byU16( u16SleepPeriod, 256U, (uint16)(CT_PERIODIC_RATE*(PLL_freq/1000000U)));
	ATOMIC_CODE
    9f90:	4407      	mov	R, #0
    9f92:	500c      	call	fp0:0x60
    9f94:	54f0      	mov	UPr, #0
    9f96:	72d8 0138 	lod	A, 0x138 <_g_u16SelfHeatingCounter>
    9f9a:	a205      	add	A, [S-6]
    9f9c:	52d8 0138 	mov	0x138 <_g_u16SelfHeatingCounter>, A
    9fa0:	7009      	lod	A, #9
    9fa2:	82db 5c24 	callf	0x5c24 <_ml_GetState>
    9fa6:	acff      	cmp	A, #-1
    9fa8:	190d      	je	0x9fc4 <_Timer_SleepCompensation+0x4e>
    9faa:	62d8 02a4 	lod	AL, 0x2a4 <_LinStatus>
    9fae:	b401      	and	A, #1
    9fb0:	1909      	je	0x9fc4 <_Timer_SleepCompensation+0x4e>
    9fb2:	7000      	lod	A, #0
    9fb4:	52d8 00fe 	mov	0xfe <_g_u16Mlx4StateCheckCounter>, A
    9fb8:	42d8 0110 	mov	0x110 <_g_u8ErrorCommBusTimeout>, AL
    9fbc:	7008      	lod	A, #8
    9fbe:	82db 5c24 	callf	0x5c24 <_ml_GetState>
    9fc2:	0005      	jmp	0x9fce <_Timer_SleepCompensation+0x58>
    9fc4:	72d8 00fe 	lod	A, 0xfe <_g_u16Mlx4StateCheckCounter>
    9fc8:	a203      	add	A, [S-4]
    9fca:	52d8 00fe 	mov	0xfe <_g_u16Mlx4StateCheckCounter>, A
    9fce:	72d8 013c 	lod	A, 0x13c <_g_u16PID_CtrlCounter>
    9fd2:	a203      	add	A, [S-4]
    9fd4:	52d8 013c 	mov	0x13c <_g_u16PID_CtrlCounter>, A
    9fd8:	72d8 013a 	lod	A, 0x13a <_g_u16PID_ThrshldCtrlCounter>
    9fdc:	a203      	add	A, [S-4]
    9fde:	52d8 013a 	mov	0x13a <_g_u16PID_ThrshldCtrlCounter>, A
    9fe2:	66d8 00fc 	lod	YL, 0xfc <_g_u8MotorStartDelay>
    9fe6:	62e8      	lod	AL, YL
    9fe8:	5cf2      	usex	A
    9fea:	ae03      	cmp	A, [S-4]
    9fec:	1a03      	jule	0x9ff4 <_Timer_SleepCompensation+0x7e>
    9fee:	62e8      	lod	AL, YL
    9ff0:	8a03      	sub	AL, [S-4]
    9ff2:	0001      	jmp	0x9ff6 <_Timer_SleepCompensation+0x80>
    9ff4:	6000      	lod	AL, #0
    9ff6:	42d8 00fc 	mov	0xfc <_g_u8MotorStartDelay>, AL
    9ffa:	72d8 0104 	lod	A, 0x104 <_g_u16TemperatureStabilityCounter>
    9ffe:	a203      	add	A, [S-4]
    a000:	52d8 0104 	mov	0x104 <_g_u16TemperatureStabilityCounter>, A
    a004:	72d8 0142 	lod	A, 0x142 <_g_u16LinUVTimeCounter>
    a008:	1903      	je	0xa010 <_Timer_SleepCompensation+0x9a>
    a00a:	a203      	add	A, [S-4]
    a00c:	52d8 0142 	mov	0x142 <_g_u16LinUVTimeCounter>, A
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    a010:	7201      	lod	A, [S-2]
    a012:	52e3      	mov	M, A
    a014:	5407      	ret	#8

0000a016 <_TIMER_IT>:
 * TIMER_IT()
 *
 * Periodic Timer ISR
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
    a016:	52df      	push	A
	{
		g_u16Mlx4StateCheckCounter++;										/* State check counter */
	}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 3) */

	if ( g_u8MotorStopDelay != 0 )
    a018:	6132      	lod	AL, dp:0x32 <_g_u8MotorStopDelay>
    a01a:	1912      	je	0xa040 <_TIMER_IT+0x2a>
	{
		if ( (--g_u8MotorStopDelay == 0) && ((g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) )
    a01c:	80ff      	add	AL, #-1
    a01e:	4132      	mov	dp:0x32 <_g_u8MotorStopDelay>, AL
    a020:	1d0f      	jne	0xa040 <_TIMER_IT+0x2a>
    a022:	61e8      	lod	AL, dp:0xe8 <__bss_dp_end>
    a024:	b47f      	and	A, #127
    a026:	1d0c      	jne	0xa040 <_TIMER_IT+0x2a>
		{
			DRVCFG_DIS_UVWT();
    a028:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    a02c:	b6da fe00 	and	A, #65024
    a030:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();
    a034:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    a038:	a6da 0100 	or	A, #256
    a03c:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}
	}

	if ( g_u8MotorStartDelay != 0 )
    a040:	62d8 00fc 	lod	AL, 0xfc <_g_u8MotorStartDelay>
    a044:	1903      	je	0xa04c <_TIMER_IT+0x36>
	{
		g_u8MotorStartDelay--;
    a046:	80ff      	add	AL, #-1
    a048:	42d8 00fc 	mov	0xfc <_g_u8MotorStartDelay>, AL
	}

	g_u16PID_CtrlCounter++;														/* PID Current/Speed control */
    a04c:	72d8 013c 	lod	A, 0x13c <_g_u16PID_CtrlCounter>
    a050:	a001      	add	A, #1
    a052:	52d8 013c 	mov	0x13c <_g_u16PID_CtrlCounter>, A
	g_u16PID_ThrshldCtrlCounter++;												/* PID Threshold control */
    a056:	72d8 013a 	lod	A, 0x13a <_g_u16PID_ThrshldCtrlCounter>
    a05a:	a001      	add	A, #1
    a05c:	52d8 013a 	mov	0x13a <_g_u16PID_ThrshldCtrlCounter>, A
#if _SUPPORT_AMBIENT_TEMP
	g_u16SelfHeatingCounter++;													/* Self-heating compensation (ambjient temperature) */
    a060:	72d8 0138 	lod	A, 0x138 <_g_u16SelfHeatingCounter>
    a064:	a001      	add	A, #1
    a066:	52d8 0138 	mov	0x138 <_g_u16SelfHeatingCounter>, A
	}
#endif /* _SUPPORT_LIN_AA */
#endif /* WATCHDOG == ENABLED */

#if _SUPPORT_CHIP_TEMP_PROFILE
	g_u16TemperatureStabilityCounter++;
    a06a:	72d8 0104 	lod	A, 0x104 <_g_u16TemperatureStabilityCounter>
    a06e:	a001      	add	A, #1
    a070:	52d8 0104 	mov	0x104 <_g_u16TemperatureStabilityCounter>, A
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */

#if _SUPPORT_LIN_UV
	if ( g_u16LinUVTimeCounter != 0 )
    a074:	72d8 0142 	lod	A, 0x142 <_g_u16LinUVTimeCounter>
    a078:	1903      	je	0xa080 <_TIMER_IT+0x6a>
	{
		g_u16LinUVTimeCounter++;
    a07a:	a001      	add	A, #1
    a07c:	52d8 0142 	mov	0x142 <_g_u16LinUVTimeCounter>, A
    a080:	72cf      	pop	A
    a082:	4407      	mov	R, #0
    a084:	72cb      	pop	M
    a086:	5401      	ret

0000a088 <_SpiDebugInit>:
 *
 *	Comments:	Initialise SPI Interface.
 * ****************************************************************************	*/
void SpiDebugInit( void)
{
	SPI1_PCR  = SPI_CKEN;													/* Set the bit SPI_CKEN to 1 */
    a088:	6001      	lod	AL, #1
    a08a:	42d8 289a 	mov	0x289a <__io__+0x9a>, AL
	SPI1_BRR  = ((PLL_freq / DEBUG_SPI_BAUDRATE) + 1);						/* 100, 200, 400, 800 or 1000 kBaud */
    a08e:	701d      	lod	A, #29
    a090:	52d8 289c 	mov	0x289c <__io__+0x9c>, A
	SPI1_CTRL = (SPI_FRSSOEN << 8) | (SPI_MSTRONLY << 8) | SPI_RFIE | SPI_TFIE | /* SPI_BYTEMOD | */ SPI_MSTR | SPI_EN | SPI_CKEN;	/* Mode 00 */
    a094:	72da 0ad3 	lod	A, #2771
    a098:	52d8 289a 	mov	0x289a <__io__+0x9a>, A
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
static INLINE void SpiDebugWriteFirst( uint16 u16Data)
{
	SPI1_PSCR |= SPI_FRSSOEN;													/* Toggle Slave-Select */
    a09c:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    a0a0:	8408      	or	AL, #8
    a0a2:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_PSCR &= ~SPI_FRSSOEN;
    a0a6:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    a0aa:	94f7      	and	AL, #-9
    a0ac:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_DR = u16Data;															/* Send SPI-Data */
    a0b0:	72da a55a 	lod	A, #42330
    a0b4:	52d8 289e 	mov	0x289e <__io__+0x9e>, A
    a0b8:	5401      	ret
    a0ba:	0000      	nop

0000a0bc <_au16HaltZero>:
    a0bc:	0000 0000                                   ....

0000a0c0 <_tMlxDbgSupport>:
    a0c0:	fffe 0007 0000 0000 0000 0000 0000 0000     ................
    a0d0:	0000 0000 d0ff 0000 ff87 c0ff 0001 7d07     ...............}

0000a0e0 <_au16AnaOutRegs>:
    a0e0:	201c 201e 2020 204a 204c 204e 28cc 28ce     . .   J L N .(.(

0000a0f0 <_tAdcSelfTest4B>:
    a0f0:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    a100:	1903 0d53 0003 ffff                         ..S.....

0000a108 <_tAdcSelfTest4A>:
    a108:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    a118:	1903 0053 0d03 ffff                         ..S.....

0000a120 <_SBASE_INIT_4PH>:
    a120:	0143 0053 0d63 0473 0d03 ffff               C.S.c.s.....

0000a12c <_SBASE_CURRENT>:
    a12c:	0d03 ffff                                   ....

0000a130 <_SBASE_MOTORVOLT>:
    a130:	0403 ffff                                   ....

0000a134 <_SBASE_SUPPLYVOLT>:
    a134:	0003 ffff                                   ....

0000a138 <_SBASE_TEMP>:
    a138:	0103 ffff                                   ....

0000a13c <_SBASE_VIO>:
    a13c:	0503 ffff 0603 ffff 0703 ffff 0803 ffff     ................
    a14c:	1503 ffff 1603 ffff                         ........

0000a154 <_SBASE_VDDD>:
    a154:	0203 ffff                                   ....

0000a158 <_SBASE_VDDA>:
    a158:	0303 ffff                                   ....

0000a15c <_SBASE_CURROFF>:
    a15c:	0d03 ffff                                   ....

0000a160 <_SBASE_VREF_OFF>:
    a160:	0100 ffff                                   ....

0000a164 <_c_ai16MicroStepVector4PH>:
    a164:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    a174:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..
    a184:	7ffe 7ec3 7c4f 78a8 73d8 6deb 66ee 5ef4     ...~O|.x.s.m.f.^
    a194:	560f 4c56 41e1 36ca 2b2c 1f23 12cd 0649     .VVL.A.6,+#...I.
    a1a4:	f9b7 ed33 e0dd d4d4 c936 be1f b3aa a9f1     ..3.....6.......
    a1b4:	a10c 9912 9215 8c28 8758 83b1 813d 8002     ......(.X...=...
    a1c4:	8002 813d 83b1 8758 8c28 9215 9912 a10c     ..=...X.(.......
    a1d4:	a9f1 b3aa be1f c936 d4d4 e0dd ed33 f9b7     ......6.....3...
    a1e4:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    a1f4:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..

0000a204 <_c_au8DrvCfgSelfTestB4>:
    a204:	c431 8421 4c13 4812 b5f5                    1.!..L.H..

0000a20e <_c_au16DrvAdcSelfTestA>:
    a20e:	0b03 ffff 0a03 ffff 0903 ffff 1903 ffff     ................

0000a21e <_c_au8DrvCfgSelfTestA>:
    a21e:	3020 0c08 0302 c080                          0......

0000a226 <_defNvramUser>:
    a226:	0100 b06c 8881 0000 5470 0000 ffff ffff     ..l.....pT......
    a236:	321c b400 9090 00b0 0124 ffff 0000 3000     .2......$......0
    a246:	0000 0000 0000 0000 0000 0000 0000 0000     ................
    a256:	6c40 513e 5067 0226 03b6 04e2 04e2 0000     @l>QgP&.........
    a266:	0000 0000 0000 007d 0cb2 141f 111e 6464     ......}.......dd
    a276:	c814 9840 801a 8044 8062 807a 0aef 3219     ..@...D.b.z....2
    a286:	1e1e 1a10 fa1a 0000 0000 0226 0210 1840     ..........&...@.
    a296:	0600 00b2 7fff ffff                         ........
