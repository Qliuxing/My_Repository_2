mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


MLX81315A_S03_VALVE.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00004000  00004000  00000274  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00005540  00005540  00001764  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000098  0000bf68  0000bf68  000068e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00006844  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  000068e4  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  000068de  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .protection_key 00000008  0000bf46  0000bf46  000068c4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .flash_crc    00000002  0000bf4e  0000bf4e  000068cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .product_no   00000008  0000bf50  0000bf50  000068ce  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .app_version  00000004  0000bf58  0000bf58  000068d6  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .pltf_version 00000004  0000bf5c  0000bf5c  000068da  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .ramfunc      0000001e  00000740  000055c8  000017ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         00004fbe  000055e8  000055e8  0000180c  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 13 .shared_ram   00000010  00000000  00000000  0000697e  2**0
                  CONTENTS, READONLY
 14 .ram_lin_fixed 00000006  00000010  00000010  00000274  2**1
                  ALLOC
 15 .dp.data      00000024  00000018  0000a5a6  000067ca  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 16 .dp           000000b0  0000003c  0000a5ca  000067ee  2**1
                  ALLOC
 17 .dp.noinit    00000010  000000ec  0000a5ca  000067ee  2**1
                  ALLOC
 18 .data         00000056  000000fc  0000a5ca  000067ee  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 19 .bss          000001e4  00000152  0000a620  00006844  2**1
                  ALLOC
 20 .bist_stat    00000008  00000336  0000a620  00006844  2**1
                  ALLOC
 21 .debug_abbrev 000028a5  00000000  00000000  0000698e  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_info   0000d400  00000000  00000000  00009233  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   00007de2  00000000  00000000  00016633  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  00001208  00000000  00000000  0001e416  2**1
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_pubnames 00001ade  00000000  00000000  0001f61e  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_aranges 00000464  00000000  00000000  000210fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_str    00003763  00000000  00000000  00021560  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .comment      00000011  00000000  00000000  00024cc3  2**0
                  CONTENTS, READONLY
 29 .debug_ranges 0000000c  00000000  00000000  00024cd4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .mlx4_flash:

00004000 <__mlx4_flash_start>:
    4000:	a55a      	or	A, dp:0x5a <_g_NvramUser>
    4002:	5aa5      	mov	io:0x25 <_g_e8DegradedMotorRequest>, Y
    4004:	0000      	nop
    4006:	0000      	nop
    4008:	2442      	or	X, #66
    400a:	2442      	or	X, #66
    400c:	243f      	or	X, #63
    400e:	243f      	or	X, #63
    4010:	0000      	nop
    4012:	0000      	nop
    4014:	0000      	nop
    4016:	0000      	nop
    4018:	4100      	mov	dp:0x0 <__dp__>, AL
    401a:	2000      	add	X, #0
    401c:	0000      	nop
    401e:	0000      	nop
    4020:	01e0      	jmp	0x43e2 <__mlx4_flash_start+0x3e2>
    4022:	0003      	jmp	0x402a <__mlx4_flash_start+0x2a>
    4024:	0005      	jmp	0x4030 <__mlx4_flash_start+0x30>
    4026:	0000      	nop
    4028:	4233      	mov	[S-52], AL
    402a:	5f50      	mov	ep:0x50 <_g_u16MicroStepIdx>, X
    402c:	7c6d      	lod	X, #109
    402e:	998a      	subc	AL, dp:0x8a <_g_NvramUser+0x30>
    4030:	140e      	call	0x384e <__io__+0x104e>
    4032:	201a      	add	X, #26
    4034:	2c26      	cmp	X, #38
    4036:	3832      	subc	X, #50
    4038:	0208      	jmp	0x444a <__mlx4_flash_start+0x44a>
    403a:	af52      	cmp	A, ep:0x52 <_g_u16CommutTimerPeriod>
    403c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    403e:	ff35      	xor	Y, ep:0x35 <_g_u8NAD+0x1>
    4040:	e0e0      	add	Y, #-32
    4042:	dba6      	subc	AH, ep:0xa6 <_g_NvramUser+0x4c>
    4044:	0000      	nop
    4046:	0200      	jmp	0x4448 <__mlx4_flash_start+0x448>
    4048:	7da0      	lod	X, dp:0xa0 <_g_NvramUser+0x46>
    404a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    404c:	39e4      	subc	X, dp:0xe4 <_ml_driver_mode+0xc>
    404e:	934e      	adc	AL, ep:0x4e <_g_u16CorrectionRatio>
    4050:	d3e0      	adc	AH, ep:0xe0 <_ml_driver_mode+0x8>
    4052:	a497      	or	A, #-105
    4054:	2c1f      	cmp	X, #31
    4056:	5b68      	mov	ep:0x68 <_g_NvramUser+0xe>, Y
    4058:	a81f      	sub	A, #31
    405a:	b47f      	and	A, #127
    405c:	00b2      	jmp	0x41c2 <__mlx4_flash_start+0x1c2>
    405e:	7c50      	lod	X, #80
    4060:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    4062:	773a      	lod	PC, ep:0x3a <_l_u8StallCountO>
    4064:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x34>
    4066:	773b      	lod	PC, ep:0x3b <_l_u8StallCountA>
    4068:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    406a:	34e9      	and	X, #-23
    406c:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    406e:	b76f      	and	A, ep:0x6f <_g_NvramUser+0x15>
    4070:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x3>
    4072:	4c02 b203 	add	D, #-1291603453
    4076:	b303 
    4078:	8684      	or	AL, io:0x4 <_LinMess>
    407a:	7203      	lod	A, [S-4]
    407c:	4c03      	add	D, ??
    407e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    4080:	380e      	subc	X, #14
    4082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    4084:	320a      	adc	X, [S-11]
    4086:	340a      	and	X, #10
    4088:	3eac      	xor	X, io:0x2c <_g_e8ErrorCoil>
    408a:	3b16      	subc	X, ep:0x16 <__dp_noinit_size+0x6>
    408c:	3730      	and	X, ep:0x30 <_l_u8SynchFieldErrorCounter>
    408e:	6193      	lod	AL, dp:0x93 <_g_NvramUser+0x39>
    4090:	b680      	and	A, io:0x0 <__dp__>
    4092:	7273      	lod	A, [S-116]
    4094:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4098:	7239      	lod	A, [S-58]
    409a:	726f      	lod	A, [S-112]
    409c:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    409e:	714c      	lod	A, dp:0x4c <_l_u8LinInFrameMsgID>
    40a0:	b588      	and	A, dp:0x88 <_g_NvramUser+0x2e>
    40a2:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    40a4:	0000      	nop
    40a6:	0000      	nop
    40a8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    40aa:	320a      	adc	X, [S-11]
    40ac:	580a      	inc	S, #11
    40ae:	0901      	clrb	io:0x00.1
    40b0:	2080      	add	X, #-128
    40b2:	623a      	lod	AL, [S-59]
    40b4:	7270      	lod	A, [S-113]
    40b6:	b637      	and	A, [S-56]
    40b8:	b373      	adc	A, ep:0x73 <_g_NvramUser+0x19>
    40ba:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    40bc:	e783      	or	Y, ep:0x83 <_g_NvramUser+0x29>
    40be:	1101      	call	0x42c2 <__mlx4_flash_start+0x2c2>
    40c0:	20b7      	add	X, #-73
    40c2:	6c03      	lod	YH, #3
    40c4:	206e      	add	X, #110
    40c6:	2066      	add	X, #102
    40c8:	2073      	add	X, #115
    40ca:	2050      	add	X, #80
    40cc:	e680      	or	Y, io:0x0 <__dp__>
    40ce:	1102      	call	0x42d4 <__mlx4_flash_start+0x2d4>
    40d0:	b782      	and	A, ep:0x82 <_g_NvramUser+0x28>
    40d2:	207a      	add	X, #122
    40d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    40d6:	110b      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40d8:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    40da:	207a      	add	X, #122
    40dc:	b270      	adc	A, [S-113]
    40de:	a688      	or	A, io:0x8 <__bist_stat_size>
    40e0:	1106      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40e2:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    40e4:	207a      	add	X, #122
    40e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    40e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    40ea:	1101      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40ec:	207c      	add	X, #124
    40ee:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    40f0:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x19>
    40f2:	2050      	add	X, #80
    40f4:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x19>
    40f6:	2056      	add	X, #86
    40f8:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    40fa:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x19>
    40fc:	3cc3      	xor	X, #-61
    40fe:	2050      	add	X, #80
    4100:	b384      	adc	A, ep:0x84 <_g_NvramUser+0x2a>
    4102:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    4104:	7380      	lod	A, ep:0x80 <_g_NvramUser+0x26>
    4106:	7334      	lod	A, ep:0x34 <_g_u8NAD>
    4108:	7235      	lod	A, [S-54]
    410a:	7ca7      	lod	X, #-89
    410c:	7d34      	lod	X, dp:0x34 <_g_u8NAD>
    410e:	6c03      	lod	YH, #3
    4110:	20b1      	add	X, #-79
    4112:	20ad      	add	X, #-83
    4114:	20b3      	add	X, #-77
    4116:	20b3      	add	X, #-77
    4118:	20b3      	add	X, #-77
    411a:	20a1      	add	X, #-95
    411c:	20b3      	add	X, #-77
    411e:	20b3      	add	X, #-77
    4120:	20b3      	add	X, #-77
    4122:	20b3      	add	X, #-77
    4124:	20b3      	add	X, #-77
    4126:	20b3      	add	X, #-77
    4128:	20b3      	add	X, #-77
    412a:	20b3      	add	X, #-77
    412c:	20b3      	add	X, #-77
    412e:	2098      	add	X, #-104
    4130:	a682      	or	A, io:0x2 <_LinCmnd>
    4132:	1106      	call	0x4340 <__mlx4_flash_start+0x340>
    4134:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x5>
    4136:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x34>
    4138:	a681      	or	A, io:0x1 <__dp__+0x1>
    413a:	0101      	jmp	0x433e <__mlx4_flash_start+0x33e>
    413c:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x27>
    413e:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    4140:	20b1      	add	X, #-79
    4142:	e682      	or	Y, io:0x2 <_LinCmnd>
    4144:	110d      	call	0x4360 <__mlx4_flash_start+0x360>
    4146:	b286      	adc	A, io:0x6 <_LinMess2>
    4148:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x5>
    414a:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x28>
    414c:	e681      	or	Y, io:0x1 <__dp__+0x1>
    414e:	0103      	jmp	0x4356 <__mlx4_flash_start+0x356>
    4150:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x33>
    4152:	b680      	and	A, io:0x0 <__dp__>
    4154:	7273      	lod	A, [S-116]
    4156:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    4158:	20b1      	add	X, #-79
    415a:	e681      	or	Y, io:0x1 <__dp__+0x1>
    415c:	1101      	call	0x4360 <__mlx4_flash_start+0x360>
    415e:	245d      	or	X, #93
    4160:	20b3      	add	X, #-77
    4162:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4164:	20b4      	add	X, #-76
    4166:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4168:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x27>
    416a:	5404      	ret	#5
    416c:	2056      	add	X, #86
    416e:	a681      	or	A, io:0x1 <__dp__+0x1>
    4170:	1104      	call	0x437a <__mlx4_flash_start+0x37a>
    4172:	b270      	adc	A, [S-113]
    4174:	a688      	or	A, io:0x8 <__bist_stat_size>
    4176:	1105      	call	0x4382 <__mlx4_flash_start+0x382>
    4178:	2048      	add	X, #72
    417a:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    417c:	622e      	lod	AL, [S-47]
    417e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4180:	0101      	jmp	0x4384 <__mlx4_flash_start+0x384>
    4182:	2056      	add	X, #86
    4184:	b139      	adc	A, dp:0x39 <_g_u16StartupDelay+0x1>
    4186:	e14c      	add	Y, dp:0x4c <_l_u8LinInFrameMsgID>
    4188:	1101      	call	0x438c <__mlx4_flash_start+0x38c>
    418a:	20e4      	add	X, #-28
    418c:	4592      	mov	dp:0x92 <_g_NvramUser+0x38>, YL
    418e:	76e5      	jmp	MH
    4190:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4192:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0xd>
    4194:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4196:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4198:	7139      	lod	A, dp:0x39 <_g_u16StartupDelay+0x1>
    419a:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x3e>
    419c:	e581      	or	Y, dp:0x81 <_g_NvramUser+0x27>
    419e:	110b      	call	0x43b6 <__mlx4_flash_start+0x3b6>
    41a0:	7cd5      	lod	X, #-43
    41a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    41a4:	b208      	adc	A, [S-9]
    41a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    41a8:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    41aa:	a783      	or	A, ep:0x83 <_g_NvramUser+0x29>
    41ac:	1105      	call	0x43b8 <__mlx4_flash_start+0x3b8>
    41ae:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x32>
    41b0:	f373      	adc	Y, ep:0x73 <_g_NvramUser+0x19>
    41b2:	7373      	lod	A, ep:0x73 <_g_NvramUser+0x19>
    41b4:	724c      	lod	A, [S-77]
    41b6:	2050      	add	X, #80
    41b8:	7271      	lod	A, [S-114]
    41ba:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    41bc:	e781      	or	Y, ep:0x81 <_g_NvramUser+0x27>
    41be:	0102      	jmp	0x43c4 <__mlx4_flash_start+0x3c4>
    41c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    41c2:	20da      	add	X, #-38
    41c4:	b686      	and	A, io:0x6 <_LinMess2>
    41c6:	20da      	add	X, #-38
    41c8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    41ca:	300a      	adc	X, #10
    41cc:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x3e>
    41ce:	ef80      	cmp	Y, ep:0x80 <_g_NvramUser+0x26>
    41d0:	0103      	jmp	0x43d8 <__mlx4_flash_start+0x3d8>
    41d2:	b684      	and	A, io:0x4 <_LinMess>
    41d4:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    41d6:	2030      	add	X, #48
    41d8:	b24e      	adc	A, [S-79]
    41da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    41dc:	724e      	lod	A, [S-79]
    41de:	6c02      	lod	YH, #2
    41e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    41e2:	20f4      	add	X, #-12
    41e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    41e6:	2100      	add	X, dp:0x0 <__dp__>
    41e8:	b78b      	and	A, ep:0x8b <_g_NvramUser+0x31>
    41ea:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    41ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    41ee:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x54>
    41f0:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    41f2:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    41f4:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    41f6:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    41f8:	b681      	and	A, io:0x1 <__dp__+0x1>
    41fa:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x54>
    41fc:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    41fe:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4200:	b682      	and	A, io:0x2 <_LinCmnd>
    4202:	724e      	lod	A, [S-79]
    4204:	b78d      	and	A, ep:0x8d <_g_NvramUser+0x33>
    4206:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4208:	b681      	and	A, io:0x1 <__dp__+0x1>
    420a:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x54>
    420c:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    420e:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4210:	b24c      	adc	A, [S-77]
    4212:	7271      	lod	A, [S-114]
    4214:	b78b      	and	A, ep:0x8b <_g_NvramUser+0x31>
    4216:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    4218:	b681      	and	A, io:0x1 <__dp__+0x1>
    421a:	61ae      	lod	AL, dp:0xae <_g_NvramUser+0x54>
    421c:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2b>
    421e:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    4220:	b24e      	adc	A, [S-79]
    4222:	b171      	adc	A, dp:0x71 <_g_NvramUser+0x17>
    4224:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4226:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    4228:	b56d      	and	A, dp:0x6d <_g_NvramUser+0x13>
    422a:	b685      	and	A, io:0x5 <_LinMess+0x1>
    422c:	b66e      	and	A, [S-111]
    422e:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4230:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4232:	b680      	and	A, io:0x0 <__dp__>
    4234:	738b      	lod	A, ep:0x8b <_g_NvramUser+0x31>
    4236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    4238:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    423a:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x2e>
    423c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    423e:	5408      	ret	#9
    4240:	b273      	adc	A, [S-116]
    4242:	a688      	or	A, io:0x8 <__bist_stat_size>
    4244:	1109      	call	0x4458 <__mlx4_flash_start+0x458>
    4246:	b24e      	adc	A, [S-79]
    4248:	e681      	or	Y, io:0x1 <__dp__+0x1>
    424a:	0103      	jmp	0x4452 <__mlx4_flash_start+0x452>
    424c:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x5>
    424e:	a582      	or	A, dp:0x82 <_g_NvramUser+0x28>
    4250:	0102      	jmp	0x4456 <__mlx4_flash_start+0x456>
    4252:	b680      	and	A, io:0x0 <__dp__>
    4254:	204a      	add	X, #74
    4256:	2048      	add	X, #72
    4258:	3806      	subc	X, #6
    425a:	380e      	subc	X, #14
    425c:	580c      	inc	S, #13
    425e:	0807      	clrb	dp:0x00.7
    4260:	62e6      	lod	AL, Y
    4262:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4264:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4266:	1108      	call	0x4478 <__mlx4_flash_start+0x478>
    4268:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    426a:	1105      	call	0x4476 <__mlx4_flash_start+0x476>
    426c:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    426e:	623a      	lod	AL, [S-59]
    4270:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    4272:	1101      	call	0x4476 <__mlx4_flash_start+0x476>
    4274:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    4276:	2030      	add	X, #48
    4278:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    427a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    427c:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    427e:	6223      	lod	AL, [S-36]
    4280:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x3e>
    4282:	b208      	adc	A, [S-9]
    4284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    4286:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    4288:	6c03      	lod	YH, #3
    428a:	2155      	add	X, dp:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    428c:	214a      	add	X, dp:0x4a <_g_DiagResponse+0x6>
    428e:	b688      	and	A, io:0x8 <__bist_stat_size>
    4290:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4292:	215a      	add	X, dp:0x5a <_g_NvramUser>
    4294:	b586      	and	A, dp:0x86 <_g_NvramUser+0x2c>
    4296:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x4e>
    4298:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    429a:	b6e5      	and	A, MH
    429c:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    429e:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xd>
    42a0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    42a2:	76e5      	jmp	MH
    42a4:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    42a6:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0xd>
    42a8:	b686      	and	A, io:0x6 <_LinMess2>
    42aa:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    42ac:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x4e>
    42ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    42b0:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    42b2:	3e10      	xor	X, [S-17]
    42b4:	724c      	lod	A, [S-77]
    42b6:	7139      	lod	A, dp:0x39 <_g_u16StartupDelay+0x1>
    42b8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    42ba:	34c0      	and	X, #-64
    42bc:	623a      	lod	AL, [S-59]
    42be:	38b7      	subc	X, #-73
    42c0:	357b      	and	X, dp:0x7b <_g_NvramUser+0x21>
    42c2:	3663      	and	X, [S-100]
    42c4:	7cd3      	lod	X, #-45
    42c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    42c8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    42ca:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    42cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    42ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    42d0:	b208      	adc	A, [S-9]
    42d2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    42d4:	4616      	mov	[S-23], YL
    42d6:	3561      	and	X, dp:0x61 <_g_NvramUser+0x7>
    42d8:	7208      	lod	A, [S-9]
    42da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    42dc:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    42de:	0103      	jmp	0x44e6 <__mlx4_flash_start+0x4e6>
    42e0:	b272      	adc	A, [S-115]
    42e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    42e4:	010a      	jmp	0x44fa <__mlx4_flash_start+0x4fa>
    42e6:	4500      	mov	dp:0x0 <__dp__>, YL
    42e8:	4584      	mov	dp:0x84 <_g_NvramUser+0x2a>, YL
    42ea:	8582      	or	AL, dp:0x82 <_g_NvramUser+0x28>
    42ec:	5802      	inc	S, #3
    42ee:	b739      	and	A, ep:0x39 <_g_u16StartupDelay+0x1>
    42f0:	b638      	and	A, [S-57]
    42f2:	7272      	lod	A, [S-115]
    42f4:	b737      	and	A, ep:0x37 <_g_u8MotorStopDelay>
    42f6:	0004      	jmp	0x4300 <__mlx4_flash_start+0x300>
    42f8:	2167      	add	X, dp:0x67 <_g_NvramUser+0xd>
    42fa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    42fc:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    42fe:	2047      	add	X, #71
    4300:	6217      	lod	AL, [S-24]
    4302:	0007      	jmp	0x4312 <__mlx4_flash_start+0x312>
    4304:	1102      	call	0x450a <__mlx4_flash_start+0x50a>
    4306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    4308:	7209      	lod	A, [S-10]
    430a:	b208      	adc	A, [S-9]
    430c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    430e:	6198      	lod	AL, dp:0x98 <_g_NvramUser+0x3e>
    4310:	2165      	add	X, dp:0x65 <_g_NvramUser+0xb>
    4312:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x15>
    4314:	bd83      	xor	A, dp:0x83 <_g_NvramUser+0x29>
    4316:	716f      	lod	A, dp:0x6f <_g_NvramUser+0x15>
    4318:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x5>
    431a:	a582      	or	A, dp:0x82 <_g_NvramUser+0x28>
    431c:	1101      	call	0x4520 <__mlx4_flash_start+0x520>
    431e:	2030      	add	X, #48
    4320:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2b>
    4322:	62d2      	lod	AL, [A++]
    4324:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    4326:	38b7      	subc	X, #-73
    4328:	3e18      	xor	X, [S-25]
    432a:	357b      	and	X, dp:0x7b <_g_NvramUser+0x21>
    432c:	367b      	and	X, [S-124]
    432e:	6800      	lod	AH, #0
    4330:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x16>
    4332:	b792      	and	A, ep:0x92 <_g_NvramUser+0x38>
    4334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4336:	b20a      	adc	A, [S-11]
    4338:	d667      	and	AH, [S-104]
    433a:	720b      	lod	A, [S-12]
    433c:	b76b      	and	A, ep:0x6b <_g_NvramUser+0x11>
    433e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    4340:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x16>
    4342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4344:	b20a      	adc	A, [S-11]
    4346:	d667      	and	AH, [S-104]
    4348:	720b      	lod	A, [S-12]
    434a:	b76b      	and	A, ep:0x6b <_g_NvramUser+0x11>
    434c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    434e:	6800      	lod	AH, #0
    4350:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xd>
    4352:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4354:	e78f      	or	Y, ep:0x8f <_g_NvramUser+0x35>
    4356:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xd>
    4358:	ef87      	cmp	Y, ep:0x87 <_g_NvramUser+0x2d>
    435a:	6800      	lod	AH, #0
    435c:	7270      	lod	A, [S-113]
    435e:	b6e7      	and	A, R
    4360:	8791      	or	AL, ep:0x91 <_g_NvramUser+0x37>
    4362:	76e7      	jmp	R
    4364:	c791      	or	AH, ep:0x91 <_g_NvramUser+0x37>
    4366:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    4368:	e370      	add	Y, ep:0x70 <_g_NvramUser+0x16>
    436a:	0109      	jmp	0x457e <__mlx4_flash_start+0x57e>
    436c:	21af      	add	X, dp:0xaf <_g_NvramUser+0x55>
    436e:	b587      	and	A, dp:0x87 <_g_NvramUser+0x2d>
    4370:	b66d      	and	A, [S-110]
    4372:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4374:	b56d      	and	A, dp:0x6d <_g_NvramUser+0x13>
    4376:	76e7      	jmp	R
    4378:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    437a:	75e7      	lod	PC, dp:0xe7 <_ml_driver_mode+0xf>
    437c:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    437e:	6800      	lod	AH, #0
    4380:	b140      	adc	A, dp:0x40 <__data_dp_end+0x4>
    4382:	814e      	add	AL, dp:0x4e <_g_u16CorrectionRatio>
    4384:	7140      	lod	A, dp:0x40 <__data_dp_end+0x4>
    4386:	b141      	adc	A, dp:0x41 <__data_dp_end+0x5>
    4388:	894f      	sub	AL, dp:0x4f <_g_u16CorrectionRatio+0x1>
    438a:	7141      	lod	A, dp:0x41 <__data_dp_end+0x5>
    438c:	b142      	adc	A, dp:0x42 <__data_dp_end+0x6>
    438e:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    4390:	7142      	lod	A, dp:0x42 <__data_dp_end+0x6>
    4392:	b143      	adc	A, dp:0x43 <__data_dp_end+0x7>
    4394:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    4396:	7143      	lod	A, dp:0x43 <__data_dp_end+0x7>
    4398:	b144      	adc	A, dp:0x44 <_g_DiagResponse>
    439a:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    439c:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    439e:	6800      	lod	AH, #0
    43a0:	b154      	adc	A, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    43a2:	814e      	add	AL, dp:0x4e <_g_u16CorrectionRatio>
    43a4:	7154      	lod	A, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    43a6:	b155      	adc	A, dp:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    43a8:	894f      	sub	AL, dp:0x4f <_g_u16CorrectionRatio+0x1>
    43aa:	7155      	lod	A, dp:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    43ac:	b156      	adc	A, dp:0x56 <__data_size>
    43ae:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    43b0:	7156      	lod	A, dp:0x56 <__data_size>
    43b2:	b157      	adc	A, dp:0x57 <__data_size+0x1>
    43b4:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    43b6:	7157      	lod	A, dp:0x57 <__data_size+0x1>
    43b8:	6800      	lod	AH, #0
    43ba:	b34e      	adc	A, ep:0x4e <_g_u16CorrectionRatio>
    43bc:	b24f      	adc	A, [S-80]
    43be:	b15a      	adc	A, dp:0x5a <_g_NvramUser>
    43c0:	e349      	add	Y, ep:0x49 <_g_DiagResponse+0x5>
    43c2:	ea4a      	sub	Y, [S-75]
    43c4:	e94b      	sub	Y, dp:0x4b <_g_DiagResponse+0x7>
    43c6:	1003      	call	0x43ce <__mlx4_flash_start+0x3ce>
    43c8:	7349      	lod	A, ep:0x49 <_g_DiagResponse+0x5>
    43ca:	724a      	lod	A, [S-75]
    43cc:	714b      	lod	A, dp:0x4b <_g_DiagResponse+0x7>
    43ce:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x2>
    43d0:	ea47      	sub	Y, [S-72]
    43d2:	e948      	sub	Y, dp:0x48 <_g_DiagResponse+0x4>
    43d4:	0003      	jmp	0x43dc <__mlx4_flash_start+0x3dc>
    43d6:	7346      	lod	A, ep:0x46 <_g_DiagResponse+0x2>
    43d8:	7247      	lod	A, [S-72]
    43da:	7148      	lod	A, dp:0x48 <_g_DiagResponse+0x4>
    43dc:	e684      	or	Y, io:0x4 <_LinMess>
    43de:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x26>
    43e0:	0009      	jmp	0x43f4 <__mlx4_flash_start+0x3f4>
    43e2:	8350      	add	AL, ep:0x50 <_g_u16MicroStepIdx>
    43e4:	8a51      	sub	AL, [S-82]
    43e6:	8952      	sub	AL, dp:0x52 <_g_u16CommutTimerPeriod>
    43e8:	7350      	lod	A, ep:0x50 <_g_u16MicroStepIdx>
    43ea:	7251      	lod	A, [S-82]
    43ec:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    43ee:	b353      	adc	A, ep:0x53 <_g_u16CommutTimerPeriod+0x1>
    43f0:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    43f2:	7353      	lod	A, ep:0x53 <_g_u16CommutTimerPeriod+0x1>
    43f4:	6800      	lod	AH, #0
    43f6:	b157      	adc	A, dp:0x57 <__data_size+0x1>
    43f8:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    43fa:	7157      	lod	A, dp:0x57 <__data_size+0x1>
    43fc:	b156      	adc	A, dp:0x56 <__data_size>
    43fe:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4400:	7156      	lod	A, dp:0x56 <__data_size>
    4402:	b155      	adc	A, dp:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    4404:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4406:	7155      	lod	A, dp:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    4408:	b154      	adc	A, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    440a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    440c:	7154      	lod	A, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    440e:	b144      	adc	A, dp:0x44 <_g_DiagResponse>
    4410:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4412:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    4414:	b143      	adc	A, dp:0x43 <__data_dp_end+0x7>
    4416:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4418:	7143      	lod	A, dp:0x43 <__data_dp_end+0x7>
    441a:	b142      	adc	A, dp:0x42 <__data_dp_end+0x6>
    441c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    441e:	7142      	lod	A, dp:0x42 <__data_dp_end+0x6>
    4420:	b141      	adc	A, dp:0x41 <__data_dp_end+0x5>
    4422:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4424:	7141      	lod	A, dp:0x41 <__data_dp_end+0x5>
    4426:	b140      	adc	A, dp:0x40 <__data_dp_end+0x4>
    4428:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    442a:	7140      	lod	A, dp:0x40 <__data_dp_end+0x4>
    442c:	6800      	lod	AH, #0
    442e:	b139      	adc	A, dp:0x39 <_g_u16StartupDelay+0x1>
    4430:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4432:	7139      	lod	A, dp:0x39 <_g_u16StartupDelay+0x1>
    4434:	e14c      	add	Y, dp:0x4c <_l_u8LinInFrameMsgID>
    4436:	0006      	jmp	0x4444 <__mlx4_flash_start+0x444>
    4438:	0102      	jmp	0x463e <__mlx4_flash_start+0x63e>
    443a:	4050      	jmp	fp2:0x80
    443c:	222a      	add	X, [S-43]
    443e:	b20a      	adc	A, [S-11]
    4440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    4442:	2226      	add	X, [S-39]
    4444:	4592      	mov	dp:0x92 <_g_NvramUser+0x38>, YL
    4446:	b6e5      	and	A, MH
    4448:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    444a:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xd>
    444c:	7234      	lod	A, [S-53]
    444e:	7335      	lod	A, ep:0x35 <_g_u8NAD+0x1>
    4450:	7208      	lod	A, [S-9]
    4452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    4454:	6800      	lod	AH, #0
    4456:	3e60      	xor	X, [S-97]
    4458:	3e90      	xor	X, io:0x10 <__dp_noinit_size>
    445a:	6800      	lod	AH, #0
    445c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    445e:	b208      	adc	A, [S-9]
    4460:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4462:	4616      	mov	[S-23], YL
    4464:	2228      	add	X, [S-41]
    4466:	820a      	add	AL, [S-11]
    4468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    446a:	8e80      	cmp	AL, io:0x0 <__dp__>
    446c:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    446e:	720a      	lod	A, [S-11]
    4470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    4472:	6800      	lod	AH, #0
    4474:	b739      	and	A, ep:0x39 <_g_u16StartupDelay+0x1>
    4476:	b638      	and	A, [S-57]
    4478:	6800      	lod	AH, #0
    447a:	b53e      	and	A, dp:0x3e <__data_dp_end+0x2>
    447c:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    447e:	753e      	lod	PC, dp:0x3e <__data_dp_end+0x2>
    4480:	6800      	lod	AH, #0
    4482:	b330      	adc	A, ep:0x30 <_l_u8SynchFieldErrorCounter>
    4484:	b231      	adc	A, [S-50]
    4486:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4488:	8e80      	cmp	AL, io:0x0 <__dp__>
    448a:	7330      	lod	A, ep:0x30 <_l_u8SynchFieldErrorCounter>
    448c:	7231      	lod	A, [S-50]
    448e:	e336      	add	Y, ep:0x36 <_l_u8VTIdx>
    4490:	ea37      	sub	Y, [S-56]
    4492:	6800      	lod	AH, #0
    4494:	0009      	jmp	0x44a8 <__mlx4_flash_start+0x4a8>
    4496:	b340      	adc	A, ep:0x40 <__data_dp_end+0x4>
    4498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    449a:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    449c:	b341      	adc	A, ep:0x41 <__data_dp_end+0x5>
    449e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    44a0:	7341      	lod	A, ep:0x41 <__data_dp_end+0x5>
    44a2:	b342      	adc	A, ep:0x42 <__data_dp_end+0x6>
    44a4:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    44a6:	2257      	add	X, [S-88]
    44a8:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    44aa:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    44ac:	7341      	lod	A, ep:0x41 <__data_dp_end+0x5>
    44ae:	7342      	lod	A, ep:0x42 <__data_dp_end+0x6>
    44b0:	6800      	lod	AH, #0
    44b2:	b354      	adc	A, ep:0x54 <_g_u16TargetCommutTimerPeriod>
    44b4:	b255      	adc	A, [S-86]
    44b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    44b8:	8a03      	sub	AL, [S-4]
    44ba:	7354      	lod	A, ep:0x54 <_g_u16TargetCommutTimerPeriod>
    44bc:	7255      	lod	A, [S-86]
    44be:	b356      	adc	A, ep:0x56 <__data_size>
    44c0:	b257      	adc	A, [S-88]
    44c2:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    44c4:	8e80      	cmp	AL, io:0x0 <__dp__>
    44c6:	7356      	lod	A, ep:0x56 <__data_size>
    44c8:	7257      	lod	A, [S-88]
    44ca:	6800      	lod	AH, #0
    44cc:	b354      	adc	A, ep:0x54 <_g_u16TargetCommutTimerPeriod>
    44ce:	b255      	adc	A, [S-86]
    44d0:	e330      	add	Y, ep:0x30 <_l_u8SynchFieldErrorCounter>
    44d2:	ea31      	sub	Y, [S-50]
    44d4:	b356      	adc	A, ep:0x56 <__data_size>
    44d6:	b257      	adc	A, [S-88]
    44d8:	eb32      	sub	Y, ep:0x32 <_l_u8ActDirection>
    44da:	ea33      	sub	Y, [S-52]
    44dc:	6800      	lod	AH, #0
    44de:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    44e0:	bf8f      	xor	A, ep:0x8f <_g_NvramUser+0x35>
    44e2:	4040      	jmp	fp2:0x00
    44e4:	0108      	jmp	0x46f6 <__mlx4_flash_start+0x6f6>
    44e6:	3cc3      	xor	X, #-61
    44e8:	b782      	and	A, ep:0x82 <_g_NvramUser+0x28>
    44ea:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    44ec:	833c      	add	AL, ep:0x3c <__data_dp_end>
    44ee:	733c      	lod	A, ep:0x3c <__data_dp_end>
    44f0:	b33d      	adc	A, ep:0x3d <__data_dp_end+0x1>
    44f2:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    44f4:	733d      	lod	A, ep:0x3d <__data_dp_end+0x1>
    44f6:	6800      	lod	AH, #0
    44f8:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    44fa:	a78f      	or	A, ep:0x8f <_g_NvramUser+0x35>
    44fc:	0101      	jmp	0x4700 <__mlx4_flash_start+0x700>
    44fe:	3cc3      	xor	X, #-61
    4500:	6800      	lod	AH, #0
    4502:	2939      	sub	X, dp:0x39 <_g_u16StartupDelay+0x1>
    4504:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4506:	493c      	mov	dp:0x3c <__data_dp_end>, AH
    4508:	b681      	and	A, io:0x1 <__dp__+0x1>
    450a:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x4>
    450c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    450e:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4510:	b680      	and	A, io:0x0 <__dp__>
    4512:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x4>
    4514:	b682      	and	A, io:0x2 <_LinCmnd>
    4516:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4518:	3b33      	subc	X, ep:0x33 <_g_u8SAE_SendErrorState>
    451a:	6800      	lod	AH, #0
    451c:	3b12      	subc	X, ep:0x12 <__dp_noinit_size+0x2>
    451e:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    4520:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    4522:	b682      	and	A, io:0x2 <_LinCmnd>
    4524:	bfbc      	xor	A, ep:0xbc <__bss_dp_size+0xc>
    4526:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4528:	6800      	lod	AH, #0
    452a:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    452c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    452e:	1106      	call	0x473c <__mlx4_flash_start+0x73c>
    4530:	e781      	or	Y, ep:0x81 <_g_NvramUser+0x27>
    4532:	1108      	call	0x4744 <__mlx4_flash_start+0x744>
    4534:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4536:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x27>
    4538:	5404      	ret	#5
    453a:	202f      	add	X, #47
    453c:	e78e      	or	Y, ep:0x8e <_g_NvramUser+0x34>
    453e:	0102      	jmp	0x4744 <__mlx4_flash_start+0x744>
    4540:	a752      	or	A, ep:0x52 <_g_u16CommutTimerPeriod>
    4542:	1104      	call	0x474c <__mlx4_flash_start+0x74c>
    4544:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4546:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x27>
    4548:	5404      	ret	#5
    454a:	6800      	lod	AH, #0
    454c:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    454e:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x27>
    4550:	5404      	ret	#5
    4552:	e684      	or	Y, io:0x4 <_LinMess>
    4554:	1102      	call	0x475a <__mlx4_flash_start+0x75a>
    4556:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4558:	29d4      	sub	X, dp:0xd4 <_LIN_nad>
    455a:	7201      	lod	A, [S-2]
    455c:	e682      	or	Y, io:0x2 <_LinCmnd>
    455e:	1101      	call	0x4762 <__mlx4_flash_start+0x762>
    4560:	248f      	or	X, #-113
    4562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    4564:	1101      	call	0x4768 <__mlx4_flash_start+0x768>
    4566:	2967      	sub	X, dp:0x67 <_g_NvramUser+0xd>
    4568:	2487      	or	X, #-121
    456a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    456c:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x33>
    456e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    4570:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4572:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    4574:	b782      	and	A, ep:0x82 <_g_NvramUser+0x28>
    4576:	22d2      	add	X, [A++]
    4578:	0b04      	setb	io:0x00.4
    457a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    457c:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x2e>
    457e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    4580:	22e5      	add	X, MH
    4582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    4584:	b20d      	adc	A, [S-14]
    4586:	7238      	lod	A, [S-57]
    4588:	b202      	adc	A, [S-3]
    458a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    458c:	b203      	adc	A, [S-4]
    458e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    4590:	b63e      	and	A, [S-63]
    4592:	22d7      	.word	0x22d7
    4594:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    4596:	7201      	lod	A, [S-2]
    4598:	7338      	lod	A, ep:0x38 <_g_u16StartupDelay>
    459a:	b365      	adc	A, ep:0x65 <_g_NvramUser+0xb>
    459c:	bf81      	xor	A, ep:0x81 <_g_NvramUser+0x27>
    459e:	0101      	jmp	0x47a2 <__mlx4_flash_start+0x7a2>
    45a0:	6800      	lod	AH, #0
    45a2:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    45a4:	0b04      	setb	io:0x00.4
    45a6:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    45a8:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x2e>
    45aa:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    45ac:	22e5      	add	X, MH
    45ae:	7334      	lod	A, ep:0x34 <_g_u8NAD>
    45b0:	7235      	lod	A, [S-54]
    45b2:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x2e>
    45b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    45b6:	718a      	lod	A, dp:0x8a <_g_NvramUser+0x30>
    45b8:	b338      	adc	A, ep:0x38 <_g_u16StartupDelay>
    45ba:	738b      	lod	A, ep:0x8b <_g_NvramUser+0x31>
    45bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    45be:	b20f      	adc	A, [S-16]
    45c0:	738e      	lod	A, ep:0x8e <_g_NvramUser+0x34>
    45c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    45c4:	5408      	ret	#9
    45c6:	7ca6      	lod	X, #-90
    45c8:	7d34      	lod	X, dp:0x34 <_g_u8NAD>
    45ca:	6800      	lod	AH, #0
    45cc:	b384      	adc	A, ep:0x84 <_g_NvramUser+0x2a>
    45ce:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    45d0:	7380      	lod	A, ep:0x80 <_g_NvramUser+0x26>
    45d2:	7334      	lod	A, ep:0x34 <_g_u8NAD>
    45d4:	7235      	lod	A, [S-54]
    45d6:	7ca7      	lod	X, #-89
    45d8:	7d34      	lod	X, dp:0x34 <_g_u8NAD>
    45da:	6c03      	lod	YH, #3
    45dc:	2300      	add	X, ep:0x0 <__dp__>
    45de:	2295      	add	X, io:0x15 <__dp_noinit_size+0x5>
    45e0:	23ee      	add	X, ep:0xee <_g_e8StallDetectorEna>
    45e2:	2300      	add	X, ep:0x0 <__dp__>
    45e4:	2300      	add	X, ep:0x0 <__dp__>
    45e6:	23a1      	add	X, ep:0xa1 <_g_NvramUser+0x47>
    45e8:	240b      	or	X, #11
    45ea:	23cb      	add	X, ep:0xcb <_g_u16PID_I+0x1>
    45ec:	2300      	add	X, ep:0x0 <__dp__>
    45ee:	2300      	add	X, ep:0x0 <__dp__>
    45f0:	2304      	add	X, ep:0x4 <_LinMess>
    45f2:	23c3      	add	X, ep:0xc3 <__bss_dp_size+0x13>
    45f4:	23e6      	add	X, ep:0xe6 <_ml_driver_mode+0xe>
    45f6:	23da      	add	X, ep:0xda <_ml_driver_mode+0x2>
    45f8:	2300      	add	X, ep:0x0 <__dp__>
    45fa:	23b7      	add	X, ep:0xb7 <__bss_dp_size+0x7>
    45fc:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    45fe:	2301      	add	X, ep:0x1 <__dp__+0x1>
    4600:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4602:	7381      	lod	A, ep:0x81 <_g_NvramUser+0x27>
    4604:	5404      	ret	#5
    4606:	6800      	lod	AH, #0
    4608:	e682      	or	Y, io:0x2 <_LinCmnd>
    460a:	0104      	jmp	0x4814 <__mlx4_flash_start+0x814>
    460c:	b681      	and	A, io:0x1 <__dp__+0x1>
    460e:	7282      	lod	A, io:0x2 <_LinCmnd>
    4610:	b684      	and	A, io:0x4 <_LinMess>
    4612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    4614:	b680      	and	A, io:0x0 <__dp__>
    4616:	7282      	lod	A, io:0x2 <_LinCmnd>
    4618:	b680      	and	A, io:0x0 <__dp__>
    461a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    461c:	22fe      	add	X, [X+6]
    461e:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4620:	a688      	or	A, io:0x8 <__bist_stat_size>
    4622:	0102      	jmp	0x4828 <__mlx4_flash_start+0x828>
    4624:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4626:	2315      	add	X, ep:0x15 <__dp_noinit_size+0x5>
    4628:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    462a:	7170      	lod	A, dp:0x70 <_g_NvramUser+0x16>
    462c:	a684      	or	A, io:0x4 <_LinMess>
    462e:	0101      	jmp	0x4832 <__mlx4_flash_start+0x832>
    4630:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    4634:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4636:	7271      	lod	A, [S-114]
    4638:	b286      	adc	A, io:0x6 <_LinMess2>
    463a:	4616      	mov	[S-23], YL
    463c:	7286      	lod	A, io:0x6 <_LinMess2>
    463e:	b271      	adc	A, [S-114]
    4640:	b5a3      	and	A, dp:0xa3 <_g_NvramUser+0x49>
    4642:	0009      	jmp	0x4656 <__mlx4_flash_start+0x656>
    4644:	6c02      	lod	YH, #2
    4646:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x34>
    4648:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    464a:	bd8d      	xor	A, dp:0x8d <_g_NvramUser+0x33>
    464c:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    464e:	bd8b      	xor	A, dp:0x8b <_g_NvramUser+0x31>
    4650:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    4652:	bd87      	xor	A, dp:0x87 <_g_NvramUser+0x2d>
    4654:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    4656:	6c02      	lod	YH, #2
    4658:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x27>
    465a:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    465c:	f582      	and	Y, dp:0x82 <_g_NvramUser+0x28>
    465e:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    4660:	f584      	and	Y, dp:0x84 <_g_NvramUser+0x2a>
    4662:	2333      	add	X, ep:0x33 <_g_u8SAE_SendErrorState>
    4664:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x2e>
    4666:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4668:	b170      	adc	A, dp:0x70 <_g_NvramUser+0x16>
    466a:	76a3      	jmp	io:0x23 <_g_i16ChipTemperature+0x1>
    466c:	e78a      	or	Y, ep:0x8a <_g_NvramUser+0x30>
    466e:	1008      	call	0x4680 <__mlx4_flash_start+0x680>
    4670:	8782      	or	AL, ep:0x82 <_g_NvramUser+0x28>
    4672:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4674:	a783      	or	A, ep:0x83 <_g_NvramUser+0x29>
    4676:	4794      	mov	ep:0x94 <_g_NvramUser+0x3a>, YL
    4678:	0101      	jmp	0x487c <__mlx4_flash_start+0x87c>
    467a:	231c      	add	X, ep:0x1c <_g_e8EXVMoveEnableRequestFlag>
    467c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    467e:	231d      	add	X, ep:0x1d <_g_e8CalibrationStep>
    4680:	e78c      	or	Y, ep:0x8c <_g_NvramUser+0x32>
    4682:	1003      	call	0x468a <__mlx4_flash_start+0x68a>
    4684:	8782      	or	AL, ep:0x82 <_g_NvramUser+0x28>
    4686:	4050      	jmp	fp2:0x80
    4688:	231f      	add	X, ep:0x1f <_g_u8StallTypeComm>
    468a:	22fe      	add	X, [X+6]
    468c:	b202      	adc	A, [S-3]
    468e:	b36b      	adc	A, ep:0x6b <_g_NvramUser+0x11>
    4690:	836a      	add	AL, ep:0x6a <_g_NvramUser+0x10>
    4692:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x11>
    4694:	bf81      	xor	A, ep:0x81 <_g_NvramUser+0x27>
    4696:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4698:	6c03      	lod	YH, #3
    469a:	2375      	add	X, ep:0x75 <_g_NvramUser+0x1b>
    469c:	2351      	add	X, ep:0x51 <_g_u16MicroStepIdx+0x1>
    469e:	236c      	add	X, ep:0x6c <_g_NvramUser+0x12>
    46a0:	2375      	add	X, ep:0x75 <_g_NvramUser+0x1b>
    46a2:	8681      	or	AL, io:0x1 <__dp__+0x1>
    46a4:	7202      	lod	A, [S-3]
    46a6:	b203      	adc	A, [S-4]
    46a8:	8e80      	cmp	AL, io:0x0 <__dp__>
    46aa:	f36b      	adc	Y, ep:0x6b <_g_NvramUser+0x11>
    46ac:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x11>
    46ae:	b786      	and	A, ep:0x86 <_g_NvramUser+0x2c>
    46b0:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x2>
    46b2:	0002      	jmp	0x46b8 <__mlx4_flash_start+0x6b8>
    46b4:	0106      	jmp	0x48c2 <__mlx4_flash_start+0x8c2>
    46b6:	2373      	add	X, ep:0x73 <_g_NvramUser+0x19>
    46b8:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    46ba:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x2>
    46bc:	1003      	call	0x46c4 <__mlx4_flash_start+0x6c4>
    46be:	b78f      	and	A, ep:0x8f <_g_NvramUser+0x35>
    46c0:	2362      	add	X, ep:0x62 <_g_NvramUser+0x8>
    46c2:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    46c4:	0000      	nop
    46c6:	0000      	nop
    46c8:	0000      	nop
    46ca:	0000      	nop
    46cc:	0000      	nop
    46ce:	0000      	nop
    46d0:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    46d2:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x26>
    46d4:	0108      	jmp	0x48e6 <__mlx4_flash_start+0x8e6>
    46d6:	2362      	add	X, ep:0x62 <_g_NvramUser+0x8>
    46d8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    46da:	7202      	lod	A, [S-3]
    46dc:	b203      	adc	A, [S-4]
    46de:	ce80      	cmp	AH, io:0x0 <__dp__>
    46e0:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x34>
    46e2:	bb6b      	subc	A, ep:0x6b <_g_NvramUser+0x11>
    46e4:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x11>
    46e6:	7203      	lod	A, [S-4]
    46e8:	4c02 6800 	add	D, #1920034816
    46ec:	7271 
    46ee:	b16d      	adc	A, dp:0x6d <_g_NvramUser+0x13>
    46f0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    46f2:	716d      	lod	A, dp:0x6d <_g_NvramUser+0x13>
    46f4:	0b04      	setb	io:0x00.4
    46f6:	b25e      	adc	A, [S-95]
    46f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    46fa:	725e      	lod	A, [S-95]
    46fc:	2388      	add	X, ep:0x88 <_g_NvramUser+0x2e>
    46fe:	7189      	lod	A, dp:0x89 <_g_NvramUser+0x2f>
    4700:	7134      	lod	A, dp:0x34 <_g_u8NAD>
    4702:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4704:	7335      	lod	A, ep:0x35 <_g_u8NAD+0x1>
    4706:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    4708:	7388      	lod	A, ep:0x88 <_g_NvramUser+0x2e>
    470a:	5408      	ret	#9
    470c:	7c55      	lod	X, #85
    470e:	7d34      	lod	X, dp:0x34 <_g_u8NAD>
    4710:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4712:	b588      	and	A, dp:0x88 <_g_NvramUser+0x2e>
    4714:	3beb      	subc	X, ep:0xeb <_ml_driver_mode+0x13>
    4716:	b5a6      	and	A, dp:0xa6 <_g_NvramUser+0x4c>
    4718:	716e      	lod	A, dp:0x6e <_g_NvramUser+0x14>
    471a:	a58f      	or	A, dp:0x8f <_g_NvramUser+0x35>
    471c:	1103      	call	0x4924 <__mlx4_flash_start+0x924>
    471e:	b16c      	adc	A, dp:0x6c <_g_NvramUser+0x12>
    4720:	bd84      	xor	A, dp:0x84 <_g_NvramUser+0x2a>
    4722:	716c      	lod	A, dp:0x6c <_g_NvramUser+0x12>
    4724:	b271      	adc	A, [S-114]
    4726:	6800      	lod	AH, #0
    4728:	a688      	or	A, io:0x8 <__bist_stat_size>
    472a:	110a      	call	0x4940 <__mlx4_flash_start+0x940>
    472c:	b23b      	adc	A, [S-60]
    472e:	f684      	and	Y, io:0x4 <_LinMess>
    4730:	723b      	lod	A, [S-60]
    4732:	b35a      	adc	A, ep:0x5a <_g_NvramUser>
    4734:	7342      	lod	A, ep:0x42 <__data_dp_end+0x6>
    4736:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4738:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    473a:	7341      	lod	A, ep:0x41 <__data_dp_end+0x5>
    473c:	7343      	lod	A, ep:0x43 <__data_dp_end+0x7>
    473e:	7344      	lod	A, ep:0x44 <_g_DiagResponse>
    4740:	6800      	lod	AH, #0
    4742:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4744:	b286      	adc	A, io:0x6 <_LinMess2>
    4746:	010a      	jmp	0x495c <__mlx4_flash_start+0x95c>
    4748:	000e      	jmp	0x4766 <__mlx4_flash_start+0x766>
    474a:	e680      	or	Y, io:0x0 <__dp__>
    474c:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x5>
    474e:	0103      	jmp	0x4956 <__mlx4_flash_start+0x956>
    4750:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x28>
    4752:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    4754:	22fe      	add	X, [X+6]
    4756:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x33>
    4758:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    475a:	22fe      	add	X, [X+6]
    475c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    475e:	f788      	and	Y, ep:0x88 <_g_NvramUser+0x2e>
    4760:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    4762:	7200      	lod	A, [S-1]
    4764:	22fe      	add	X, [X+6]
    4766:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4768:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2a>
    476a:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    476c:	22fe      	add	X, [X+6]
    476e:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    4770:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x33>
    4772:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    4774:	a682      	or	A, io:0x2 <_LinCmnd>
    4776:	1106      	call	0x4984 <__mlx4_flash_start+0x984>
    4778:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x5>
    477a:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x34>
    477c:	a681      	or	A, io:0x1 <__dp__+0x1>
    477e:	0101      	jmp	0x4982 <__mlx4_flash_start+0x982>
    4780:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x27>
    4782:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    4784:	22fe      	add	X, [X+6]
    4786:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4788:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    478a:	0101      	jmp	0x498e <__mlx4_flash_start+0x98e>
    478c:	2300      	add	X, ep:0x0 <__dp__>
    478e:	7264      	lod	A, [S-101]
    4790:	b286      	adc	A, io:0x6 <_LinMess2>
    4792:	7265      	lod	A, [S-102]
    4794:	22fe      	add	X, [X+6]
    4796:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4798:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    479a:	0101      	jmp	0x499e <__mlx4_flash_start+0x99e>
    479c:	2300      	add	X, ep:0x0 <__dp__>
    479e:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    47a0:	be86      	xor	A, io:0x6 <_LinMess2>
    47a2:	6c02      	lod	YH, #2
    47a4:	3e04      	xor	X, [S-5]
    47a6:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x1>
    47a8:	3e05      	xor	X, [S-6]
    47aa:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x1>
    47ac:	3e06      	xor	X, [S-7]
    47ae:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x1>
    47b0:	3e07      	xor	X, [S-8]
    47b2:	22fe      	add	X, [X+6]
    47b4:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    47b6:	e681      	or	Y, io:0x1 <__dp__+0x1>
    47b8:	0106      	jmp	0x49c6 <__mlx4_flash_start+0x9c6>
    47ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    47bc:	0102      	jmp	0x49c2 <__mlx4_flash_start+0x9c2>
    47be:	b680      	and	A, io:0x0 <__dp__>
    47c0:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0xc>
    47c2:	b682      	and	A, io:0x2 <_LinCmnd>
    47c4:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0xc>
    47c6:	b684      	and	A, io:0x4 <_LinMess>
    47c8:	726c      	lod	A, [S-109]
    47ca:	22fe      	add	X, [X+6]
    47cc:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    47ce:	7382      	lod	A, ep:0x82 <_g_NvramUser+0x28>
    47d0:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    47d2:	7383      	lod	A, ep:0x83 <_g_NvramUser+0x29>
    47d4:	f686      	and	Y, io:0x6 <_LinMess2>
    47d6:	bf92      	xor	A, ep:0x92 <_g_NvramUser+0x38>
    47d8:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    47da:	22fe      	add	X, [X+6]
    47dc:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    47de:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    47e0:	0101      	jmp	0x49e4 <__mlx4_flash_start+0x9e4>
    47e2:	2300      	add	X, ep:0x0 <__dp__>
    47e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    47e6:	010e      	jmp	0x4a04 <__mlx4_flash_start+0xa04>
    47e8:	763e      	jmp	[S-63]
    47ea:	7207      	lod	A, [S-8]
    47ec:	7206      	lod	A, [S-7]
    47ee:	b286      	adc	A, io:0x6 <_LinMess2>
    47f0:	7202      	lod	A, [S-3]
    47f2:	7204      	lod	A, [S-5]
    47f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    47f6:	7203      	lod	A, [S-4]
    47f8:	7205      	lod	A, [S-6]
    47fa:	b25c      	adc	A, [S-93]
    47fc:	f684      	and	Y, io:0x4 <_LinMess>
    47fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4800:	725c      	lod	A, [S-93]
    4802:	22fe      	add	X, [X+6]
    4804:	b25c      	adc	A, [S-93]
    4806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4808:	b386      	adc	A, ep:0x86 <_g_NvramUser+0x2c>
    480a:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x26>
    480c:	0101      	jmp	0x4a10 <__mlx4_flash_start+0xa10>
    480e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    4812:	725c      	lod	A, [S-93]
    4814:	22fe      	add	X, [X+6]
    4816:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4818:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    481a:	0101      	jmp	0x4a1e <__mlx4_flash_start+0xa1e>
    481c:	2300      	add	X, ep:0x0 <__dp__>
    481e:	b387      	adc	A, ep:0x87 <_g_NvramUser+0x2d>
    4820:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4822:	0001      	jmp	0x4826 <__mlx4_flash_start+0x826>
    4824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    4826:	7271      	lod	A, [S-114]
    4828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    482a:	4608      	mov	[S-9], YL
    482c:	6c02      	lod	YH, #2
    482e:	b11c      	adc	A, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4830:	241e      	or	X, #30
    4832:	b11d      	adc	A, dp:0x1d <_g_e8CalibrationStep>
    4834:	241e      	or	X, #30
    4836:	b12c      	adc	A, dp:0x2c <_g_e8ErrorCoil>
    4838:	241e      	or	X, #30
    483a:	b12d      	adc	A, dp:0x2d <_g_e8ErrorElectric>
    483c:	b387      	adc	A, ep:0x87 <_g_NvramUser+0x2d>
    483e:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4840:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4842:	b371      	adc	A, ep:0x71 <_g_NvramUser+0x17>
    4844:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    4846:	4788      	mov	ep:0x88 <_g_NvramUser+0x2e>, YL
    4848:	0009      	jmp	0x485c <__mlx4_flash_start+0x85c>
    484a:	6c03      	lod	YH, #3
    484c:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x34>
    484e:	2436      	or	X, #54
    4850:	bd8d      	xor	A, dp:0x8d <_g_NvramUser+0x33>
    4852:	2436      	or	X, #54
    4854:	bd8b      	xor	A, dp:0x8b <_g_NvramUser+0x31>
    4856:	2436      	or	X, #54
    4858:	bd87      	xor	A, dp:0x87 <_g_NvramUser+0x2d>
    485a:	2436      	or	X, #54
    485c:	6c03      	lod	YH, #3
    485e:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x27>
    4860:	2436      	or	X, #54
    4862:	f582      	and	Y, dp:0x82 <_g_NvramUser+0x28>
    4864:	2436      	or	X, #54
    4866:	f584      	and	Y, dp:0x84 <_g_NvramUser+0x2a>
    4868:	2436      	or	X, #54
    486a:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x2e>
    486c:	6c02      	lod	YH, #2
    486e:	711c      	lod	A, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4870:	243e      	or	X, #62
    4872:	711d      	lod	A, dp:0x1d <_g_e8CalibrationStep>
    4874:	243e      	or	X, #62
    4876:	712c      	lod	A, dp:0x2c <_g_e8ErrorCoil>
    4878:	243e      	or	X, #62
    487a:	712d      	lod	A, dp:0x2d <_g_e8ErrorElectric>
    487c:	22fe      	add	X, [X+6]
    487e:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4880:	b682      	and	A, io:0x2 <_LinCmnd>
    4882:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4884:	7c01      	lod	X, #1
    4886:	5018      	call	fp0:0xC0
    4888:	54c0      	.word	0x54c0
    488a:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    488c:	733e      	lod	A, ep:0x3e <__data_dp_end+0x2>
    488e:	733f      	lod	A, ep:0x3f <__data_dp_end+0x3>
    4890:	5401      	ret
    4892:	3e60      	xor	X, [S-97]
    4894:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4896:	773a      	lod	PC, ep:0x3a <_l_u8StallCountO>
    4898:	773b      	lod	PC, ep:0x3b <_l_u8StallCountA>
    489a:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x3>
    489c:	355b      	and	X, dp:0x5b <_g_NvramUser+0x1>
    489e:	365b      	and	X, [S-92]
    48a0:	3730      	and	X, ep:0x30 <_l_u8SynchFieldErrorCounter>
    48a2:	7736      	lod	PC, ep:0x36 <_l_u8VTIdx>
    48a4:	3ba0      	subc	X, ep:0xa0 <_g_NvramUser+0x46>
    48a6:	b78f      	and	A, ep:0x8f <_g_NvramUser+0x35>
    48a8:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    48aa:	b681      	and	A, io:0x1 <__dp__+0x1>
    48ac:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48ae:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x34>
    48b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    48b2:	b680      	and	A, io:0x0 <__dp__>
    48b4:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48b6:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    48b8:	7301      	lod	A, ep:0x1 <__dp__+0x1>
    48ba:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    48bc:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    48be:	494e      	mov	dp:0x4e <_g_u16CorrectionRatio>, AH
    48c0:	4930      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AH
    48c2:	493a      	mov	dp:0x3a <_l_u8StallCountO>, AH
    48c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    48c6:	4964      	mov	dp:0x64 <_g_NvramUser+0xa>, AH
    48c8:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x5>
    48ca:	736c      	lod	A, ep:0x6c <_g_NvramUser+0x12>
    48cc:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x2>
    48ce:	7338      	lod	A, ep:0x38 <_g_u16StartupDelay>
    48d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    48d2:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    48d4:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    48d6:	b58b      	and	A, dp:0x8b <_g_NvramUser+0x31>
    48d8:	7105      	lod	A, dp:0x5 <_LinMess+0x1>
    48da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    48dc:	b58c      	and	A, dp:0x8c <_g_NvramUser+0x32>
    48de:	7104      	lod	A, dp:0x4 <_LinMess>
    48e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    48e2:	b583      	and	A, dp:0x83 <_g_NvramUser+0x29>
    48e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    48e6:	7106      	lod	A, dp:0x6 <_LinMess2>
    48e8:	b680      	and	A, io:0x0 <__dp__>
    48ea:	77c6      	lod	PC, ep:0xc6 <__bss_dp_size+0x16>
    48ec:	77ca      	lod	PC, ep:0xca <_g_u16PID_I>
    48ee:	8681      	or	AL, io:0x1 <__dp__+0x1>
    48f0:	0101      	jmp	0x4af4 <__mlx4_flash_start+0xaf4>
    48f2:	2475      	or	X, #117
    48f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    48f6:	7336      	lod	A, ep:0x36 <_l_u8VTIdx>
    48f8:	7237      	lod	A, [S-56]
    48fa:	b788      	and	A, ep:0x88 <_g_NvramUser+0x2e>
    48fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    48fe:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4900:	738c      	lod	A, ep:0x8c <_g_NvramUser+0x32>
    4902:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2a>
    4904:	738d      	lod	A, ep:0x8d <_g_NvramUser+0x33>
    4906:	7c02      	lod	X, #2
    4908:	5820      	inc	S, #33
    490a:	b681      	and	A, io:0x1 <__dp__+0x1>
    490c:	62ca      	lod	AL, [--PC]
    490e:	622b      	lod	AL, [S-44]
    4910:	3448      	and	X, #72
    4912:	5809      	inc	S, #10
    4914:	62e6      	lod	AL, Y
    4916:	2489      	or	X, #-119
    4918:	b78a      	and	A, ep:0x8a <_g_NvramUser+0x30>
    491a:	b682      	and	A, io:0x2 <_LinCmnd>
    491c:	62ca      	lod	AL, [--PC]
    491e:	5018      	call	fp0:0xC0
    4920:	54c0      	.word	0x54c0
    4922:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4924:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    4926:	24a3      	or	X, #-93
    4928:	b680      	and	A, io:0x0 <__dp__>
    492a:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    492c:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    492e:	0106      	jmp	0x4b3c <__mlx4_flash_start+0xb3c>
    4930:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x34>
    4932:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    4934:	b239      	adc	A, [S-58]
    4936:	7238      	lod	A, [S-57]
    4938:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    493a:	b686      	and	A, io:0x6 <_LinMess2>
    493c:	e680      	or	Y, io:0x0 <__dp__>
    493e:	0101      	jmp	0x4b42 <__mlx4_flash_start+0xb42>
    4940:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4942:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4944:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    4946:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x15>
    4948:	bd88      	xor	A, dp:0x88 <_g_NvramUser+0x2e>
    494a:	716f      	lod	A, dp:0x6f <_g_NvramUser+0x15>
    494c:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    494e:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x33>
    4950:	1101      	call	0x4b54 <__mlx4_flash_start+0xb54>
    4952:	24c2      	or	X, #-62
    4954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    4956:	494e      	mov	dp:0x4e <_g_u16CorrectionRatio>, AH
    4958:	b58e      	and	A, dp:0x8e <_g_NvramUser+0x34>
    495a:	b561      	and	A, dp:0x61 <_g_NvramUser+0x7>
    495c:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x2>
    495e:	1101      	call	0x4b62 <__mlx4_flash_start+0xb62>
    4960:	24c2      	or	X, #-62
    4962:	b340      	adc	A, ep:0x40 <__data_dp_end+0x4>
    4964:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    4966:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    4968:	b341      	adc	A, ep:0x41 <__data_dp_end+0x5>
    496a:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    496c:	7341      	lod	A, ep:0x41 <__data_dp_end+0x5>
    496e:	b342      	adc	A, ep:0x42 <__data_dp_end+0x6>
    4970:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4972:	7342      	lod	A, ep:0x42 <__data_dp_end+0x6>
    4974:	b343      	adc	A, ep:0x43 <__data_dp_end+0x7>
    4976:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4978:	7343      	lod	A, ep:0x43 <__data_dp_end+0x7>
    497a:	b344      	adc	A, ep:0x44 <_g_DiagResponse>
    497c:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    497e:	7344      	lod	A, ep:0x44 <_g_DiagResponse>
    4980:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4982:	24ae      	or	X, #-82
    4984:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4986:	7166      	lod	A, dp:0x66 <_g_NvramUser+0xc>
    4988:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    498a:	7167      	lod	A, dp:0x67 <_g_NvramUser+0xd>
    498c:	b58e      	and	A, dp:0x8e <_g_NvramUser+0x34>
    498e:	b561      	and	A, dp:0x61 <_g_NvramUser+0x7>
    4990:	e106      	add	Y, dp:0x6 <_LinMess2>
    4992:	0108      	jmp	0x4ba4 <__mlx4_flash_start+0xba4>
    4994:	b266      	adc	A, [S-103]
    4996:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4998:	7266      	lod	A, [S-103]
    499a:	b267      	adc	A, [S-104]
    499c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    499e:	7267      	lod	A, [S-104]
    49a0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    49a2:	24c8      	or	X, #-56
    49a4:	4d66      	mov	dp:0x66 <_g_NvramUser+0xc>, YH
    49a6:	4968      	mov	dp:0x68 <_g_NvramUser+0xe>, AH
    49a8:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    49aa:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    49ac:	733a      	lod	A, ep:0x3a <_l_u8StallCountO>
    49ae:	623a      	lod	AL, [S-59]
    49b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    49b2:	1104      	call	0x4bbc <__mlx4_flash_start+0xbbc>
    49b4:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    49b6:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    49b8:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    49ba:	24f2      	or	X, #-14
    49bc:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    49be:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x33>
    49c0:	0103      	jmp	0x4bc8 <__mlx4_flash_start+0xbc8>
    49c2:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    49c4:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    49c6:	2494      	or	X, #-108
    49c8:	580e      	inc	S, #15
    49ca:	0803      	clrb	dp:0x00.3
    49cc:	0906      	clrb	io:0x00.6
    49ce:	62e6      	lod	AL, Y
    49d0:	24e4      	or	X, #-28
    49d2:	623a      	lod	AL, [S-59]
    49d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    49d6:	0106      	jmp	0x4be4 <__mlx4_flash_start+0xbe4>
    49d8:	24e4      	or	X, #-28
    49da:	626f      	lod	AL, [S-112]
    49dc:	0001      	jmp	0x49e0 <__mlx4_flash_start+0x9e0>
    49de:	24e9      	or	X, #-23
    49e0:	b586      	and	A, dp:0x86 <_g_NvramUser+0x2c>
    49e2:	29d4      	sub	X, dp:0xd4 <_LIN_nad>
    49e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    49e6:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    49e8:	380d      	subc	X, #13
    49ea:	3805      	subc	X, #5
    49ec:	3479      	and	X, #121
    49ee:	303a      	adc	X, #58
    49f0:	39f6      	subc	X, dp:0xf6 <_g_u16CalibTravel>
    49f2:	b26c      	adc	A, [S-109]
    49f4:	a686      	or	A, io:0x6 <_LinMess2>
    49f6:	0106      	jmp	0x4c04 <__mlx4_flash_start+0xc04>
    49f8:	f681      	and	Y, io:0x1 <__dp__+0x1>
    49fa:	726c      	lod	A, [S-109]
    49fc:	b26e      	adc	A, [S-111]
    49fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    4a00:	1101      	call	0x4c04 <__mlx4_flash_start+0xc04>
    4a02:	6376      	lod	AL, ep:0x76 <_g_NvramUser+0x1c>
    4a04:	3cc3      	xor	X, #-61
    4a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    4a08:	be38      	xor	A, [S-57]
    4a0a:	0101      	jmp	0x4c0e <__mlx4_flash_start+0xc0e>
    4a0c:	2494      	or	X, #-108
    4a0e:	580e      	inc	S, #15
    4a10:	0905      	clrb	io:0x00.5
    4a12:	0802      	clrb	dp:0x00.2
    4a14:	62e6      	lod	AL, Y
    4a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a18:	623a      	lod	AL, [S-59]
    4a1a:	2522      	or	X, dp:0x22 <_g_i16ChipTemperature>
    4a1c:	623a      	lod	AL, [S-59]
    4a1e:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x2>
    4a20:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x34>
    4a22:	a681      	or	A, io:0x1 <__dp__+0x1>
    4a24:	1102      	call	0x4c2a <__mlx4_flash_start+0xc2a>
    4a26:	a78c      	or	A, ep:0x8c <_g_NvramUser+0x32>
    4a28:	0101      	jmp	0x4c2c <__mlx4_flash_start+0xc2c>
    4a2a:	f581      	and	Y, dp:0x81 <_g_NvramUser+0x27>
    4a2c:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x2>
    4a2e:	4050      	jmp	fp2:0x80
    4a30:	6c04      	lod	YH, #4
    4a32:	2528      	or	X, dp:0x28 <_g_u8StallOcc>
    4a34:	2542      	or	X, dp:0x42 <__data_dp_end+0x6>
    4a36:	254f      	or	X, dp:0x4f <_g_u16CorrectionRatio+0x1>
    4a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a3a:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x2>
    4a3c:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    4a3e:	0107      	jmp	0x4c4e <__mlx4_flash_start+0xc4e>
    4a40:	bd8e      	xor	A, dp:0x8e <_g_NvramUser+0x34>
    4a42:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x2>
    4a44:	484f      	macu	D, AL, [X]
    4a46:	6c04      	lod	YH, #4
    4a48:	2557      	or	X, dp:0x57 <__data_size+0x1>
    4a4a:	2584      	or	X, dp:0x84 <_g_NvramUser+0x2a>
    4a4c:	25c6      	or	X, dp:0xc6 <__bss_dp_size+0x16>
    4a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a50:	484e      	macu	D, AL, [X++]
    4a52:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4a54:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x29>
    4a56:	1104      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a58:	b143      	adc	A, dp:0x43 <__data_dp_end+0x7>
    4a5a:	e585      	or	Y, dp:0x85 <_g_NvramUser+0x2b>
    4a5c:	1101      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a5e:	2918      	sub	X, dp:0x18 <__data_dp_start>
    4a60:	b16c      	adc	A, dp:0x6c <_g_NvramUser+0x12>
    4a62:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    4a64:	010e      	jmp	0x4c82 <__mlx4_flash_start+0xc82>
    4a66:	b168      	adc	A, dp:0x68 <_g_NvramUser+0xe>
    4a68:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4a6a:	7168      	lod	A, dp:0x68 <_g_NvramUser+0xe>
    4a6c:	b169      	adc	A, dp:0x69 <_g_NvramUser+0xf>
    4a6e:	cd80      	cmp	AH, dp:0x80 <_g_NvramUser+0x26>
    4a70:	7169      	lod	A, dp:0x69 <_g_NvramUser+0xf>
    4a72:	1107      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a74:	4d66      	mov	dp:0x66 <_g_NvramUser+0xc>, YH
    4a76:	4968      	mov	dp:0x68 <_g_NvramUser+0xe>, AH
    4a78:	b16e      	adc	A, dp:0x6e <_g_NvramUser+0x14>
    4a7a:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4a7c:	716e      	lod	A, dp:0x6e <_g_NvramUser+0x14>
    4a7e:	1101      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a80:	6376      	lod	AL, ep:0x76 <_g_NvramUser+0x1c>
    4a82:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4a84:	61d6      	lod	AL, dp:0xd6 <_LinMessage>
    4a86:	7271      	lod	A, [S-114]
    4a88:	b256      	adc	A, [S-87]
    4a8a:	c242      	add	AH, [S-67]
    4a8c:	c943      	sub	AH, dp:0x43 <__data_dp_end+0x7>
    4a8e:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4a90:	4616      	mov	[S-23], YL
    4a92:	e242      	add	Y, [S-67]
    4a94:	e943      	sub	Y, dp:0x43 <__data_dp_end+0x7>
    4a96:	1002      	call	0x4a9c <__mlx4_flash_start+0xa9c>
    4a98:	b271      	adc	A, [S-114]
    4a9a:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4a9c:	2494      	or	X, #-108
    4a9e:	b15a      	adc	A, dp:0x5a <_g_NvramUser>
    4aa0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4aa2:	715a      	lod	A, dp:0x5a <_g_NvramUser>
    4aa4:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x29>
    4aa6:	1001      	call	0x4aaa <__mlx4_flash_start+0xaaa>
    4aa8:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4aaa:	6394      	lod	AL, ep:0x94 <_g_NvramUser+0x3a>
    4aac:	25ee      	or	X, dp:0xee <_g_e8StallDetectorEna>
    4aae:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4ab2:	1102      	call	0x4cb8 <__mlx4_flash_start+0xcb8>
    4ab4:	7c06      	lod	X, #6
    4ab6:	2494      	or	X, #-108
    4ab8:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4aba:	e144      	add	Y, dp:0x44 <_g_DiagResponse>
    4abc:	0005      	jmp	0x4ac8 <__mlx4_flash_start+0xac8>
    4abe:	b142      	adc	A, dp:0x42 <__data_dp_end+0x6>
    4ac0:	e589      	or	Y, dp:0x89 <_g_NvramUser+0x2f>
    4ac2:	b143      	adc	A, dp:0x43 <__data_dp_end+0x7>
    4ac4:	ed81      	cmp	Y, dp:0x81 <_g_NvramUser+0x27>
    4ac6:	0003      	jmp	0x4ace <__mlx4_flash_start+0xace>
    4ac8:	623d      	lod	AL, [S-62]
    4aca:	6207      	lod	AL, [S-8]
    4acc:	255c      	or	X, dp:0x5c <_g_NvramUser+0x2>
    4ace:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x2>
    4ad0:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4ad2:	1107      	call	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad4:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    4ad6:	0105      	jmp	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    4ada:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x2>
    4adc:	1002      	call	0x4ae2 <__mlx4_flash_start+0xae2>
    4ade:	b681      	and	A, io:0x1 <__dp__+0x1>
    4ae0:	2495      	or	X, #-107
    4ae2:	b36c      	adc	A, ep:0x6c <_g_NvramUser+0x12>
    4ae4:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    4ae6:	0105      	jmp	0x4cf2 <__mlx4_flash_start+0xcf2>
    4ae8:	bf8e      	xor	A, ep:0x8e <_g_NvramUser+0x34>
    4aea:	736c      	lod	A, ep:0x6c <_g_NvramUser+0x12>
    4aec:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    4aee:	b680      	and	A, io:0x0 <__dp__>
    4af0:	62d2      	lod	AL, [A++]
    4af2:	4d40      	mov	dp:0x40 <__data_dp_end+0x4>, YH
    4af4:	4954      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, AH
    4af6:	4d42      	mov	dp:0x42 <__data_dp_end+0x6>, YH
    4af8:	4956      	mov	dp:0x56 <__data_size>, AH
    4afa:	7c4a      	lod	X, #74
    4afc:	380e      	subc	X, #14
    4afe:	3806      	subc	X, #6
    4b00:	344c      	and	X, #76
    4b02:	484f      	macu	D, AL, [X]
    4b04:	5c01      	dec	S, #2
    4b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b08:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    4b0a:	380f      	subc	X, #15
    4b0c:	3806      	subc	X, #6
    4b0e:	300a      	adc	X, #10
    4b10:	39f0      	subc	X, dp:0xf0 <_g_u16ActualPosition>
    4b12:	348f      	and	X, #-113
    4b14:	5c02      	dec	S, #3
    4b16:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4b18:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x18>
    4b1a:	715a      	lod	A, dp:0x5a <_g_NvramUser>
    4b1c:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4b1e:	4946      	mov	dp:0x46 <_g_DiagResponse+0x2>, AH
    4b20:	4948      	mov	dp:0x48 <_g_DiagResponse+0x4>, AH
    4b22:	b58f      	and	A, dp:0x8f <_g_NvramUser+0x35>
    4b24:	714b      	lod	A, dp:0x4b <_g_DiagResponse+0x7>
    4b26:	714a      	lod	A, dp:0x4a <_g_DiagResponse+0x6>
    4b28:	b343      	adc	A, ep:0x43 <__data_dp_end+0x7>
    4b2a:	b242      	adc	A, [S-67]
    4b2c:	b141      	adc	A, dp:0x41 <__data_dp_end+0x5>
    4b2e:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4b30:	4942      	mov	dp:0x42 <__data_dp_end+0x6>, AH
    4b32:	7342      	lod	A, ep:0x42 <__data_dp_end+0x6>
    4b34:	7241      	lod	A, [S-66]
    4b36:	7140      	lod	A, dp:0x40 <__data_dp_end+0x4>
    4b38:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4b3a:	4616      	mov	[S-23], YL
    4b3c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b3e:	8140      	add	AL, dp:0x40 <__data_dp_end+0x4>
    4b40:	8a41      	sub	AL, [S-66]
    4b42:	8b42      	sub	AL, ep:0x42 <__data_dp_end+0x6>
    4b44:	7140      	lod	A, dp:0x40 <__data_dp_end+0x4>
    4b46:	7241      	lod	A, [S-66]
    4b48:	7342      	lod	A, ep:0x42 <__data_dp_end+0x6>
    4b4a:	7150      	lod	A, dp:0x50 <_g_u16MicroStepIdx>
    4b4c:	7251      	lod	A, [S-82]
    4b4e:	7352      	lod	A, ep:0x52 <_g_u16CommutTimerPeriod>
    4b50:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x2>
    4b52:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x32>
    4b54:	e784      	or	Y, ep:0x84 <_g_NvramUser+0x2a>
    4b56:	0101      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4b58:	25c3      	or	X, dp:0xc3 <__bss_dp_size+0x13>
    4b5a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x2>
    4b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    4b5e:	100b      	call	0x4b76 <__mlx4_flash_start+0xb76>
    4b60:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4b62:	b152      	adc	A, dp:0x52 <_g_u16CommutTimerPeriod>
    4b64:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4b66:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    4b68:	b151      	adc	A, dp:0x51 <_g_u16MicroStepIdx+0x1>
    4b6a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b6c:	7151      	lod	A, dp:0x51 <_g_u16MicroStepIdx+0x1>
    4b6e:	b150      	adc	A, dp:0x50 <_g_u16MicroStepIdx>
    4b70:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b72:	7150      	lod	A, dp:0x50 <_g_u16MicroStepIdx>
    4b74:	25ae      	or	X, dp:0xae <_g_NvramUser+0x54>
    4b76:	b150      	adc	A, dp:0x50 <_g_u16MicroStepIdx>
    4b78:	e104      	add	Y, dp:0x4 <_LinMess>
    4b7a:	b151      	adc	A, dp:0x51 <_g_u16MicroStepIdx+0x1>
    4b7c:	e905      	sub	Y, dp:0x5 <_LinMess+0x1>
    4b7e:	b152      	adc	A, dp:0x52 <_g_u16CommutTimerPeriod>
    4b80:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x26>
    4b82:	1001      	call	0x4b86 <__mlx4_flash_start+0xb86>
    4b84:	2494      	or	X, #-108
    4b86:	4950      	mov	dp:0x50 <_g_u16MicroStepIdx>, AH
    4b88:	4952      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, AH
    4b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b8c:	61dd      	lod	AL, dp:0xdd <_ml_driver_mode+0x5>
    4b8e:	1001      	call	0x4b92 <__mlx4_flash_start+0xb92>
    4b90:	25ee      	or	X, dp:0xee <_g_e8StallDetectorEna>
    4b92:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4b94:	715a      	lod	A, dp:0x5a <_g_NvramUser>
    4b96:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x18>
    4b98:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4b9a:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x18>
    4b9c:	e588      	or	Y, dp:0x88 <_g_NvramUser+0x2e>
    4b9e:	0101      	jmp	0x4da2 <__mlx4_flash_start+0xda2>
    4ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4ba2:	b150      	adc	A, dp:0x50 <_g_u16MicroStepIdx>
    4ba4:	4592      	mov	dp:0x92 <_g_NvramUser+0x38>, YL
    4ba6:	716a      	lod	A, dp:0x6a <_g_NvramUser+0x10>
    4ba8:	b153      	adc	A, dp:0x53 <_g_u16CommutTimerPeriod+0x1>
    4baa:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4bac:	7353      	lod	A, ep:0x53 <_g_u16CommutTimerPeriod+0x1>
    4bae:	b351      	adc	A, ep:0x51 <_g_u16MicroStepIdx+0x1>
    4bb0:	b252      	adc	A, [S-83]
    4bb2:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4bb4:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4bb6:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    4bb8:	7350      	lod	A, ep:0x50 <_g_u16MicroStepIdx>
    4bba:	7251      	lod	A, [S-82]
    4bbc:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    4bbe:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bc0:	4616      	mov	[S-23], YL
    4bc2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4bc4:	e349      	add	Y, ep:0x49 <_g_DiagResponse+0x5>
    4bc6:	ea4a      	sub	Y, [S-75]
    4bc8:	e94b      	sub	Y, dp:0x4b <_g_DiagResponse+0x7>
    4bca:	1008      	call	0x4bdc <__mlx4_flash_start+0xbdc>
    4bcc:	8350      	add	AL, ep:0x50 <_g_u16MicroStepIdx>
    4bce:	8a51      	sub	AL, [S-82]
    4bd0:	8952      	sub	AL, dp:0x52 <_g_u16CommutTimerPeriod>
    4bd2:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x2>
    4bd4:	ea47      	sub	Y, [S-72]
    4bd6:	e948      	sub	Y, dp:0x48 <_g_DiagResponse+0x4>
    4bd8:	0001      	jmp	0x4bdc <__mlx4_flash_start+0xbdc>
    4bda:	25f6      	or	X, dp:0xf6 <_g_u16CalibTravel>
    4bdc:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x2>
    4bde:	bf8c      	xor	A, ep:0x8c <_g_NvramUser+0x32>
    4be0:	e784      	or	Y, ep:0x84 <_g_NvramUser+0x2a>
    4be2:	1103      	call	0x4dea <__mlx4_flash_start+0xdea>
    4be4:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    4be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4be8:	2495      	or	X, #-107
    4bea:	2494      	or	X, #-108
    4bec:	b73e      	and	A, ep:0x3e <__data_dp_end+0x2>
    4bee:	b252      	adc	A, [S-83]
    4bf0:	e680      	or	Y, io:0x0 <__dp__>
    4bf2:	b153      	adc	A, dp:0x53 <_g_u16CommutTimerPeriod+0x1>
    4bf4:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x26>
    4bf6:	1101      	call	0x4dfa <__mlx4_flash_start+0xdfa>
    4bf8:	260e      	or	X, [S-15]
    4bfa:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4bfc:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bfe:	7153      	lod	A, dp:0x53 <_g_u16CommutTimerPeriod+0x1>
    4c00:	4616      	mov	[S-23], YL
    4c02:	7252      	lod	A, [S-83]
    4c04:	b251      	adc	A, [S-82]
    4c06:	4616      	mov	[S-23], YL
    4c08:	7251      	lod	A, [S-82]
    4c0a:	b250      	adc	A, [S-81]
    4c0c:	4616      	mov	[S-23], YL
    4c0e:	7250      	lod	A, [S-81]
    4c10:	b26a      	adc	A, [S-107]
    4c12:	4616      	mov	[S-23], YL
    4c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    4c16:	726a      	lod	A, [S-107]
    4c18:	61fb      	lod	AL, dp:0xfb <_g_u16ActuatorTgtPos+0x1>
    4c1a:	25f7      	or	X, dp:0xf7 <_g_u16CalibTravel+0x1>
    4c1c:	b250      	adc	A, [S-81]
    4c1e:	b151      	adc	A, dp:0x51 <_g_u16MicroStepIdx+0x1>
    4c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    4c22:	ed8c      	cmp	Y, dp:0x8c <_g_NvramUser+0x32>
    4c24:	1001      	call	0x4c28 <__mlx4_flash_start+0xc28>
    4c26:	261a      	or	X, [S-27]
    4c28:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4c2a:	4616      	mov	[S-23], YL
    4c2c:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x18>
    4c2e:	61fb      	lod	AL, dp:0xfb <_g_u16ActuatorTgtPos+0x1>
    4c30:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x18>
    4c32:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4c34:	7258      	lod	A, [S-89]
    4c36:	7159      	lod	A, dp:0x59 <_g_u16MotorCurrentLPFx64+0x1>
    4c38:	b53e      	and	A, dp:0x3e <__data_dp_end+0x2>
    4c3a:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x2>
    4c3c:	623a      	lod	AL, [S-59]
    4c3e:	484f      	macu	D, AL, [X]
    4c40:	380d      	subc	X, #13
    4c42:	3806      	subc	X, #6
    4c44:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x2>
    4c46:	0108      	jmp	0x4e58 <__mlx4_flash_start+0xe58>
    4c48:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4c4a:	b34f      	adc	A, ep:0x4f <_g_u16CorrectionRatio+0x1>
    4c4c:	b24e      	adc	A, [S-79]
    4c4e:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4c50:	4616      	mov	[S-23], YL
    4c52:	734f      	lod	A, ep:0x4f <_g_u16CorrectionRatio+0x1>
    4c54:	724e      	lod	A, [S-79]
    4c56:	2622      	or	X, [S-35]
    4c58:	580e      	inc	S, #15
    4c5a:	0903      	clrb	io:0x00.3
    4c5c:	0809      	clrb	dp:0x01.1
    4c5e:	62e6      	lod	AL, Y
    4c60:	262c      	or	X, [S-45]
    4c62:	623a      	lod	AL, [S-59]
    4c64:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4c66:	715a      	lod	A, dp:0x5a <_g_NvramUser>
    4c68:	6394      	lod	AL, ep:0x94 <_g_NvramUser+0x3a>
    4c6a:	b583      	and	A, dp:0x83 <_g_NvramUser+0x29>
    4c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    4c6e:	2495      	or	X, #-107
    4c70:	b739      	and	A, ep:0x39 <_g_u16StartupDelay+0x1>
    4c72:	b638      	and	A, [S-57]
    4c74:	348a      	and	X, #-118
    4c76:	4c58      	dadjs	D, A
    4c78:	b342      	adc	A, ep:0x42 <__data_dp_end+0x6>
    4c7a:	e780      	or	Y, ep:0x80 <_g_NvramUser+0x26>
    4c7c:	0101      	jmp	0x4e80 <__mlx4_flash_start+0xe80>
    4c7e:	2647      	or	X, [S-72]
    4c80:	b340      	adc	A, ep:0x40 <__data_dp_end+0x4>
    4c82:	b241      	adc	A, [S-66]
    4c84:	e358      	add	Y, ep:0x58 <_g_u16MotorCurrentLPFx64>
    4c86:	ea59      	sub	Y, [S-90]
    4c88:	1002      	call	0x4c8e <__mlx4_flash_start+0xc8e>
    4c8a:	7c04      	lod	X, #4
    4c8c:	2494      	or	X, #-108
    4c8e:	b34e      	adc	A, ep:0x4e <_g_u16CorrectionRatio>
    4c90:	b24f      	adc	A, [S-80]
    4c92:	484f      	macu	D, AL, [X]
    4c94:	834e      	add	AL, ep:0x4e <_g_u16CorrectionRatio>
    4c96:	8a4f      	sub	AL, [S-80]
    4c98:	1001      	call	0x4c9c <__mlx4_flash_start+0xc9c>
    4c9a:	2635      	or	X, [S-54]
    4c9c:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    4c9e:	724f      	lod	A, [S-80]
    4ca0:	b358      	adc	A, ep:0x58 <_g_u16MotorCurrentLPFx64>
    4ca2:	b259      	adc	A, [S-90]
    4ca4:	4610      	mov	[S-17], YL
    4ca6:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4ca8:	8358      	add	AL, ep:0x58 <_g_u16MotorCurrentLPFx64>
    4caa:	8a59      	sub	AL, [S-90]
    4cac:	0004      	jmp	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cae:	e34e      	add	Y, ep:0x4e <_g_u16CorrectionRatio>
    4cb0:	ea4f      	sub	Y, [S-80]
    4cb2:	1001      	call	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cb4:	2635      	or	X, [S-54]
    4cb6:	b358      	adc	A, ep:0x58 <_g_u16MotorCurrentLPFx64>
    4cb8:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    4cba:	b259      	adc	A, [S-90]
    4cbc:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4cbe:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4cc0:	7130      	lod	A, dp:0x30 <_l_u8SynchFieldErrorCounter>
    4cc2:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    4cc4:	7331      	lod	A, ep:0x31 <_g_u8BufferOutID>
    4cc6:	7232      	lod	A, [S-51]
    4cc8:	7133      	lod	A, dp:0x33 <_g_u8SAE_SendErrorState>
    4cca:	e355      	add	Y, ep:0x55 <_g_u16TargetCommutTimerPeriod+0x1>
    4ccc:	ea56      	sub	Y, [S-87]
    4cce:	e957      	sub	Y, dp:0x57 <__data_size+0x1>
    4cd0:	1002      	call	0x4cd6 <__mlx4_flash_start+0xcd6>
    4cd2:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2b>
    4cd4:	2636      	or	X, [S-55]
    4cd6:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x2>
    4cd8:	a588      	or	A, dp:0x88 <_g_NvramUser+0x2e>
    4cda:	1102      	call	0x4ee0 <__mlx4_flash_start+0xee0>
    4cdc:	a584      	or	A, dp:0x84 <_g_NvramUser+0x2a>
    4cde:	1101      	call	0x4ee2 <__mlx4_flash_start+0xee2>
    4ce0:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4ce2:	b359      	adc	A, ep:0x59 <_g_u16MotorCurrentLPFx64+0x1>
    4ce4:	b158      	adc	A, dp:0x58 <_g_u16MotorCurrentLPFx64>
    4ce6:	4592      	mov	dp:0x92 <_g_NvramUser+0x38>, YL
    4ce8:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4cea:	b680      	and	A, io:0x0 <__dp__>
    4cec:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cee:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4cf0:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cf2:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    4cf4:	b359      	adc	A, ep:0x59 <_g_u16MotorCurrentLPFx64+0x1>
    4cf6:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4cf8:	834e      	add	AL, ep:0x4e <_g_u16CorrectionRatio>
    4cfa:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cfc:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    4cfe:	724f      	lod	A, [S-80]
    4d00:	b358      	adc	A, ep:0x58 <_g_u16MotorCurrentLPFx64>
    4d02:	b259      	adc	A, [S-90]
    4d04:	b53e      	and	A, dp:0x3e <__data_dp_end+0x2>
    4d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d08:	0102      	jmp	0x4f0e <__mlx4_flash_start+0xf0e>
    4d0a:	0005      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d0c:	269c      	or	X, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4d0e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d10:	ea05      	sub	Y, [S-6]
    4d12:	0001      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d14:	269c      	or	X, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4d16:	834e      	add	AL, ep:0x4e <_g_u16CorrectionRatio>
    4d18:	8a4f      	sub	AL, [S-80]
    4d1a:	e788      	or	Y, ep:0x88 <_g_NvramUser+0x2e>
    4d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    4d1e:	0003      	jmp	0x4d26 <__mlx4_flash_start+0xd26>
    4d20:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    4d22:	4610      	mov	[S-17], YL
    4d24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d28:	0102      	jmp	0x4f2e <__mlx4_flash_start+0xf2e>
    4d2a:	0004      	jmp	0x4d34 <__mlx4_flash_start+0xd34>
    4d2c:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4d2e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d30:	ea05      	sub	Y, [S-6]
    4d32:	100d      	call	0x4d4e <__mlx4_flash_start+0xd4e>
    4d34:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4d36:	2636      	or	X, [S-55]
    4d38:	c34e      	add	AH, ep:0x4e <_g_u16CorrectionRatio>
    4d3a:	ca4f      	sub	AH, [S-80]
    4d3c:	e783      	or	Y, ep:0x83 <_g_NvramUser+0x29>
    4d3e:	ee86      	cmp	Y, io:0x6 <_LinMess2>
    4d40:	1003      	call	0x4d48 <__mlx4_flash_start+0xd48>
    4d42:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4d44:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    4d46:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d4a:	0102      	jmp	0x4f50 <__mlx4_flash_start+0xf50>
    4d4c:	1004      	call	0x4d56 <__mlx4_flash_start+0xd56>
    4d4e:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4d50:	e304      	add	Y, ep:0x4 <_LinMess>
    4d52:	ea05      	sub	Y, [S-6]
    4d54:	0002      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4d56:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4d58:	2636      	or	X, [S-55]
    4d5a:	4d58      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, YH
    4d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    4d5e:	b73e      	and	A, ep:0x3e <__data_dp_end+0x2>
    4d60:	7306      	lod	A, ep:0x6 <_LinMess2>
    4d62:	4c02 7ccb 	add	D, #2097315019
    4d66:	7d02 
    4d68:	b25e      	adc	A, [S-95]
    4d6a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4d6c:	725e      	lod	A, [S-95]
    4d6e:	344a      	and	X, #74
    4d70:	3906      	subc	X, dp:0x6 <_LinMess2>
    4d72:	b681      	and	A, io:0x1 <__dp__+0x1>
    4d74:	724e      	lod	A, [S-79]
    4d76:	7245      	lod	A, [S-70]
    4d78:	b239      	adc	A, [S-58]
    4d7a:	7271      	lod	A, [S-114]
    4d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    4d7e:	7239      	lod	A, [S-58]
    4d80:	5c00      	dec	S
    4d82:	4d1c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, YH
    4d84:	4962      	mov	dp:0x62 <_g_NvramUser+0x8>, AH
    4d86:	4d2c      	mov	dp:0x2c <_g_e8ErrorCoil>, YH
    4d88:	492e      	mov	dp:0x2e <_g_e8MotorRequest>, AH
    4d8a:	b680      	and	A, io:0x0 <__dp__>
    4d8c:	720d      	lod	A, [S-14]
    4d8e:	3807      	subc	X, #7
    4d90:	380e      	subc	X, #14
    4d92:	3430      	and	X, #48
    4d94:	580e      	inc	S, #15
    4d96:	0803      	clrb	dp:0x00.3
    4d98:	0907      	clrb	io:0x00.7
    4d9a:	62e6      	lod	AL, Y
    4d9c:	26ca      	or	X, [--PC]
    4d9e:	623a      	lod	AL, [S-59]
    4da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4da2:	0101      	jmp	0x4fa6 <__mlx4_flash_start+0xfa6>
    4da4:	26ca      	or	X, [--PC]
    4da6:	26f1      	or	X, [Y+1]
    4da8:	623a      	lod	AL, [S-59]
    4daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    4dac:	1101      	call	0x4fb0 <__mlx4_flash_start+0xfb0>
    4dae:	26f1      	or	X, [Y+1]
    4db0:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    4db2:	1105      	call	0x4fbe <__mlx4_flash_start+0xfbe>
    4db4:	626f      	lod	AL, [S-112]
    4db6:	0001      	jmp	0x4dba <__mlx4_flash_start+0xdba>
    4db8:	26ca      	or	X, [--PC]
    4dba:	b586      	and	A, dp:0x86 <_g_NvramUser+0x2c>
    4dbc:	29d4      	sub	X, dp:0xd4 <_LIN_nad>
    4dbe:	b239      	adc	A, [S-58]
    4dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4dc2:	110e      	call	0x4fe0 <__mlx4_flash_start+0xfe0>
    4dc4:	b680      	and	A, io:0x0 <__dp__>
    4dc6:	e24e      	add	Y, [S-79]
    4dc8:	1108      	call	0x4fda <__mlx4_flash_start+0xfda>
    4dca:	6259      	lod	AL, [S-90]
    4dcc:	6266      	lod	AL, [S-103]
    4dce:	0007      	jmp	0x4dde <__mlx4_flash_start+0xdde>
    4dd0:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2b>
    4dd2:	b271      	adc	A, [S-114]
    4dd4:	7239      	lod	A, [S-58]
    4dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4dd8:	2495      	or	X, #-107
    4dda:	724e      	lod	A, [S-79]
    4ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    4dde:	26ca      	or	X, [--PC]
    4de0:	26ca      	or	X, [--PC]
    4de2:	b33a      	adc	A, ep:0x3a <_l_u8StallCountO>
    4de4:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x28>
    4de6:	733a      	lod	A, ep:0x3a <_l_u8StallCountO>
    4de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    4dea:	7c4c      	lod	X, #76
    4dec:	3805      	subc	X, #5
    4dee:	3808      	subc	X, #8
    4df0:	3906      	subc	X, dp:0x6 <_LinMess2>
    4df2:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4df4:	4940      	mov	dp:0x40 <__data_dp_end+0x4>, AH
    4df6:	4942      	mov	dp:0x42 <__data_dp_end+0x6>, AH
    4df8:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    4dfa:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    4dfc:	b589      	and	A, dp:0x89 <_g_NvramUser+0x2f>
    4dfe:	580a      	inc	S, #11
    4e00:	0904      	clrb	io:0x00.4
    4e02:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x18>
    4e04:	62e6      	lod	AL, Y
    4e06:	b172      	adc	A, dp:0x72 <_g_NvramUser+0x18>
    4e08:	26ff      	or	X, [X+7]
    4e0a:	623a      	lod	AL, [S-59]
    4e0c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4e0e:	4008      	jmp	fp0:0x40
    4e10:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x2>
    4e12:	a58f      	or	A, dp:0x8f <_g_NvramUser+0x35>
    4e14:	0101      	jmp	0x5018 <__mlx4_flash_start+0x1018>
    4e16:	2726      	or	X, ep:0x26 <_g_e8ErrorOverTemperature>
    4e18:	1409      	call	0x462c <__mlx4_flash_start+0x62c>
    4e1a:	3807      	subc	X, #7
    4e1c:	380e      	subc	X, #14
    4e1e:	3430      	and	X, #48
    4e20:	27bd      	or	X, ep:0xbd <__bss_dp_size+0xd>
    4e22:	b239      	adc	A, [S-58]
    4e24:	7238      	lod	A, [S-57]
    4e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    4e28:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4e2a:	24a3      	or	X, #-93
    4e2c:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    4e2e:	b239      	adc	A, [S-58]
    4e30:	7238      	lod	A, [S-57]
    4e32:	4040      	jmp	fp2:0x00
    4e34:	624a      	lod	AL, [S-75]
    4e36:	1504      	call	0x4840 <__mlx4_flash_start+0x840>
    4e38:	b23b      	adc	A, [S-60]
    4e3a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4e3c:	723b      	lod	A, [S-60]
    4e3e:	24a3      	or	X, #-93
    4e40:	b23b      	adc	A, [S-60]
    4e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4e44:	723b      	lod	A, [S-60]
    4e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    4e48:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4e4a:	24a3      	or	X, #-93
    4e4c:	4060      	jmp	fp3:0x00
    4e4e:	624a      	lod	AL, [S-75]
    4e50:	e589      	or	Y, dp:0x89 <_g_NvramUser+0x2f>
    4e52:	1109      	call	0x5066 <__mlx4_flash_start+0x1066>
    4e54:	b339      	adc	A, ep:0x39 <_g_u16StartupDelay+0x1>
    4e56:	e78f      	or	Y, ep:0x8f <_g_NvramUser+0x35>
    4e58:	010a      	jmp	0x506e <__mlx4_flash_start+0x106e>
    4e5a:	1409      	call	0x466e <__mlx4_flash_start+0x66e>
    4e5c:	b686      	and	A, io:0x6 <_LinMess2>
    4e5e:	7338      	lod	A, ep:0x38 <_g_u16StartupDelay>
    4e60:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4e62:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4e64:	24a3      	or	X, #-93
    4e66:	4060      	jmp	fp3:0x00
    4e68:	622e      	lod	AL, [S-47]
    4e6a:	0501      	jmp	0x486e <__mlx4_flash_start+0x86e>
    4e6c:	2739      	or	X, ep:0x39 <_g_u16StartupDelay+0x1>
    4e6e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4e70:	26ff      	or	X, [X+7]
    4e72:	e583      	or	Y, dp:0x83 <_g_NvramUser+0x29>
    4e74:	1001      	call	0x4e78 <__mlx4_flash_start+0xe78>
    4e76:	274c      	or	X, ep:0x4c <_l_u8LinInFrameMsgID>
    4e78:	b791      	and	A, ep:0x91 <_g_NvramUser+0x37>
    4e7a:	d78f      	and	AH, ep:0x8f <_g_NvramUser+0x35>
    4e7c:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4e7e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x2d>
    4e80:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    4e82:	4060      	jmp	fp3:0x00
    4e84:	4d62      	mov	dp:0x62 <_g_NvramUser+0x8>, YH
    4e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    4e88:	b63d      	and	A, [S-62]
    4e8a:	721e      	lod	A, [S-31]
    4e8c:	4962      	mov	dp:0x62 <_g_NvramUser+0x8>, AH
    4e8e:	4d2e      	mov	dp:0x2e <_g_e8MotorRequest>, YH
    4e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    4e92:	b63d      	and	A, [S-62]
    4e94:	721f      	lod	A, [S-32]
    4e96:	492e      	mov	dp:0x2e <_g_e8MotorRequest>, AH
    4e98:	7492      	lod	PC, #-110
    4e9a:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4e9c:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    4e9e:	1101      	call	0x50a2 <__mlx4_flash_start+0x10a2>
    4ea0:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4ea2:	d245      	adc	AH, [S-70]
    4ea4:	7245      	lod	A, [S-70]
    4ea6:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    4ea8:	6c01      	lod	YH, #1
    4eaa:	2768      	or	X, ep:0x68 <_g_NvramUser+0xe>
    4eac:	277b      	or	X, ep:0x7b <_g_NvramUser+0x21>
    4eae:	278a      	or	X, ep:0x8a <_g_NvramUser+0x30>
    4eb0:	26ff      	or	X, [X+7]
    4eb2:	26ff      	or	X, [X+7]
    4eb4:	26ff      	or	X, [X+7]
    4eb6:	26ff      	or	X, [X+7]
    4eb8:	275e      	or	X, ep:0x5e <_g_NvramUser+0x4>
    4eba:	26ff      	or	X, [X+7]
    4ebc:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    4ebe:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    4ec0:	0106      	jmp	0x50ce <__mlx4_flash_start+0x10ce>
    4ec2:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    4ec4:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    4ec6:	b271      	adc	A, [S-114]
    4ec8:	7238      	lod	A, [S-57]
    4eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    4ecc:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4ece:	26ff      	or	X, [X+7]
    4ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    4ed4:	bf82      	xor	A, ep:0x82 <_g_NvramUser+0x28>
    4ed6:	d345      	adc	AH, ep:0x45 <_g_DiagResponse+0x1>
    4ed8:	b209      	adc	A, [S-10]
    4eda:	720f      	lod	A, [S-16]
    4edc:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4ede:	d792      	and	AH, ep:0x92 <_g_NvramUser+0x38>
    4ee0:	1101      	call	0x50e4 <__mlx4_flash_start+0x10e4>
    4ee2:	26ff      	or	X, [X+7]
    4ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    4ee6:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    4ee8:	b638      	and	A, [S-57]
    4eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    4eec:	1103      	call	0x50f4 <__mlx4_flash_start+0x10f4>
    4eee:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    4ef0:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2a>
    4ef2:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    4ef4:	24a3      	or	X, #-93
    4ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    4ef8:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4efa:	0102      	jmp	0x5100 <__mlx4_flash_start+0x1100>
    4efc:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4efe:	26ff      	or	X, [X+7]
    4f00:	b360      	adc	A, ep:0x60 <_g_NvramUser+0x6>
    4f02:	b161      	adc	A, dp:0x61 <_g_NvramUser+0x7>
    4f04:	f580      	and	Y, dp:0x80 <_g_NvramUser+0x26>
    4f06:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f08:	7260      	lod	A, [S-97]
    4f0a:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    4f0c:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f0e:	7261      	lod	A, [S-98]
    4f10:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    4f12:	26ff      	or	X, [X+7]
    4f14:	b209      	adc	A, [S-10]
    4f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4f18:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4f1a:	1102      	call	0x5120 <__mlx4_flash_start+0x1120>
    4f1c:	f781      	and	Y, ep:0x81 <_g_NvramUser+0x27>
    4f1e:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    4f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4f22:	4610      	mov	[S-17], YL
    4f24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f26:	4610      	mov	[S-17], YL
    4f28:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f2a:	720d      	lod	A, [S-14]
    4f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    4f30:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4f32:	0104      	jmp	0x513c <__mlx4_flash_start+0x113c>
    4f34:	b31f      	adc	A, ep:0x1f <_g_u8StallTypeComm>
    4f36:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4f38:	1105      	call	0x5144 <__mlx4_flash_start+0x1144>
    4f3a:	8788      	or	AL, ep:0x88 <_g_NvramUser+0x2e>
    4f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f3e:	b680      	and	A, io:0x0 <__dp__>
    4f40:	720d      	lod	A, [S-14]
    4f42:	27b5      	or	X, ep:0xb5 <__bss_dp_size+0x5>
    4f44:	3bea      	subc	X, ep:0xea <_ml_driver_mode+0x12>
    4f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    4f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f4a:	4050      	jmp	fp2:0x80
    4f4c:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    4f4e:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    4f50:	f588      	and	Y, dp:0x88 <_g_NvramUser+0x2e>
    4f52:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    4f56:	0105      	jmp	0x5162 <__mlx4_flash_start+0x1162>
    4f58:	b20d      	adc	A, [S-14]
    4f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4f5c:	720d      	lod	A, [S-14]
    4f5e:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4f60:	26ff      	or	X, [X+7]
    4f62:	720d      	lod	A, [S-14]
    4f64:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    4f66:	b7a7      	and	A, ep:0xa7 <_g_NvramUser+0x4d>
    4f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f6c:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    4f6e:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    4f70:	3beb      	subc	X, ep:0xeb <_ml_driver_mode+0x13>
    4f72:	7360      	lod	A, ep:0x60 <_g_NvramUser+0x6>
    4f74:	7161      	lod	A, dp:0x61 <_g_NvramUser+0x7>
    4f76:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    4f78:	26ff      	or	X, [X+7]
    4f7a:	1501      	call	0x497e <__mlx4_flash_start+0x97e>
    4f7c:	2800      	sub	X, #0
    4f7e:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x2>
    4f80:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    4f82:	1109      	call	0x5196 <__mlx4_flash_start+0x1196>
    4f84:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2a>
    4f86:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x2>
    4f88:	4804      	mulu	D, A, [Y++]
    4f8a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x2>
    4f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    4f8e:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4f90:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    4f92:	0101      	jmp	0x5196 <__mlx4_flash_start+0x1196>
    4f94:	24a3      	or	X, #-93
    4f96:	5cc2      	neg	A
    4f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f9a:	a588      	or	A, dp:0x88 <_g_NvramUser+0x2e>
    4f9c:	0103      	jmp	0x51a4 <__mlx4_flash_start+0x11a4>
    4f9e:	7ca8      	lod	X, #-88
    4fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    4fa2:	24a3      	or	X, #-93
    4fa4:	b261      	adc	A, [S-98]
    4fa6:	4600      	mov	[S-1], YL
    4fa8:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4faa:	0104      	jmp	0x51b4 <__mlx4_flash_start+0x11b4>
    4fac:	0001      	jmp	0x4fb0 <__mlx4_flash_start+0xfb0>
    4fae:	24a3      	or	X, #-93
    4fb0:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    4fb2:	27e7      	or	X, ep:0xe7 <_ml_driver_mode+0xf>
    4fb4:	5c00      	dec	S
    4fb6:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x5>
    4fb8:	a783      	or	A, ep:0x83 <_g_NvramUser+0x29>
    4fba:	1103      	call	0x51c2 <__mlx4_flash_start+0x11c2>
    4fbc:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4fbe:	bf83      	xor	A, ep:0x83 <_g_NvramUser+0x29>
    4fc0:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    4fc2:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    4fc4:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    4fc6:	1102      	call	0x51cc <__mlx4_flash_start+0x11cc>
    4fc8:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2a>
    4fca:	62bc      	lod	AL, io:0x3c <__data_dp_end>
    4fcc:	b781      	and	A, ep:0x81 <_g_NvramUser+0x27>
    4fce:	b260      	adc	A, [S-97]
    4fd0:	725b      	lod	A, [S-92]
    4fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4fd4:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fd6:	724c      	lod	A, [S-77]
    4fd8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fda:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4fdc:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fde:	b556      	and	A, dp:0x56 <__data_size>
    4fe0:	7137      	lod	A, dp:0x37 <_g_u8MotorStopDelay>
    4fe2:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fe4:	b556      	and	A, dp:0x56 <__data_size>
    4fe6:	7136      	lod	A, dp:0x36 <_l_u8VTIdx>
    4fe8:	b25b      	adc	A, [S-92]
    4fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    4fec:	4788      	mov	ep:0x88 <_g_NvramUser+0x2e>, YL
    4fee:	f693      	and	Y, io:0x13 <__dp_noinit_size+0x3>
    4ff0:	725b      	lod	A, [S-92]
    4ff2:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4ff4:	0002      	jmp	0x4ffa <__mlx4_flash_start+0xffa>
    4ff6:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    4ff8:	27fe      	or	X, ep:0xfe <_g_u16EXVStatusCurrentPositon>
    4ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    4ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4ffe:	281f      	sub	X, #31
    5000:	b239      	adc	A, [S-58]
    5002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    5004:	0101      	jmp	0x5208 <__mlx4_flash_start+0x1208>
    5006:	2814      	sub	X, #20
    5008:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    500a:	a782      	or	A, ep:0x82 <_g_NvramUser+0x28>
    500c:	0103      	jmp	0x5214 <__mlx4_flash_start+0x1214>
    500e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    5010:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    5012:	24a3      	or	X, #-93
    5014:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    5016:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    5018:	0107      	jmp	0x5228 <__mlx4_flash_start+0x1228>
    501a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    501c:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x26>
    501e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    5020:	ed80      	cmp	Y, dp:0x80 <_g_NvramUser+0x26>
    5022:	1102      	call	0x5228 <__mlx4_flash_start+0x1228>
    5024:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x28>
    5026:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    5028:	e24c      	add	Y, [S-77]
    502a:	0109      	jmp	0x523e <__mlx4_flash_start+0x123e>
    502c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    502e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x2d>
    5030:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    5032:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    5034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    5036:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0xe>
    5038:	8681      	or	AL, io:0x1 <__dp__+0x1>
    503a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    503c:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0xe>
    503e:	b139      	adc	A, dp:0x39 <_g_u16StartupDelay+0x1>
    5040:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    5042:	7139      	lod	A, dp:0x39 <_g_u16StartupDelay+0x1>
    5044:	1106      	call	0x5252 <__mlx4_flash_start+0x1252>
    5046:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    5048:	4930      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AH
    504a:	b35b      	adc	A, ep:0x5b <_g_NvramUser+0x1>
    504c:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    504e:	1107      	call	0x525e <__mlx4_flash_start+0x125e>
    5050:	2849      	sub	X, #73
    5052:	b208      	adc	A, [S-9]
    5054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    5056:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    5058:	e14c      	add	Y, dp:0x4c <_l_u8LinInFrameMsgID>
    505a:	0105      	jmp	0x5266 <__mlx4_flash_start+0x1266>
    505c:	6233      	lod	AL, [S-52]
    505e:	7cce      	lod	X, #-50
    5060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    5062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5064:	26ca      	or	X, [--PC]
    5066:	820a      	add	AL, [S-11]
    5068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    506a:	8681      	or	AL, io:0x1 <__dp__+0x1>
    506c:	8f80      	cmp	AL, ep:0x80 <_g_NvramUser+0x26>
    506e:	0103      	jmp	0x5276 <__mlx4_flash_start+0x1276>
    5070:	b684      	and	A, io:0x4 <_LinMess>
    5072:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    5074:	24a3      	or	X, #-93
    5076:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    5078:	a782      	or	A, ep:0x82 <_g_NvramUser+0x28>
    507a:	0105      	jmp	0x5286 <__mlx4_flash_start+0x1286>
    507c:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    507e:	bf8d      	xor	A, ep:0x8d <_g_NvramUser+0x33>
    5080:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    5082:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    5084:	29d4      	sub	X, dp:0xd4 <_LIN_nad>
    5086:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x4>
    5088:	f782      	and	Y, ep:0x82 <_g_NvramUser+0x28>
    508a:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x4>
    508c:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    508e:	62bc      	lod	AL, io:0x3c <__data_dp_end>
    5090:	24a3      	or	X, #-93
    5092:	b58f      	and	A, dp:0x8f <_g_NvramUser+0x35>
    5094:	7139      	lod	A, dp:0x39 <_g_u16StartupDelay+0x1>
    5096:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    5098:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    509a:	4940      	mov	dp:0x40 <__data_dp_end+0x4>, AH
    509c:	4942      	mov	dp:0x42 <__data_dp_end+0x6>, AH
    509e:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    50a0:	b738      	and	A, ep:0x38 <_g_u16StartupDelay>
    50a2:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    50a4:	110b      	call	0x52bc <__mlx4_flash_start+0x12bc>
    50a6:	b239      	adc	A, [S-58]
    50a8:	7238      	lod	A, [S-57]
    50aa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    50ac:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    50ae:	b23b      	adc	A, [S-60]
    50b0:	f684      	and	Y, io:0x4 <_LinMess>
    50b2:	723b      	lod	A, [S-60]
    50b4:	b25e      	adc	A, [S-95]
    50b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    50b8:	725e      	lod	A, [S-95]
    50ba:	24a1      	or	X, #-95
    50bc:	3805      	subc	X, #5
    50be:	3808      	subc	X, #8
    50c0:	346b      	and	X, #107
    50c2:	34b0      	and	X, #-80
    50c4:	4930      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AH
    50c6:	b34c      	adc	A, ep:0x4c <_l_u8LinInFrameMsgID>
    50c8:	c781      	or	AH, ep:0x81 <_g_NvramUser+0x27>
    50ca:	4796      	mov	ep:0x96 <_g_NvramUser+0x3c>, YL
    50cc:	b65b      	and	A, [S-92]
    50ce:	7236      	lod	A, [S-55]
    50d0:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    50d2:	b65b      	and	A, [S-92]
    50d4:	7237      	lod	A, [S-56]
    50d6:	b364      	adc	A, ep:0x64 <_g_NvramUser+0xa>
    50d8:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2a>
    50da:	0101      	jmp	0x52de <__mlx4_flash_start+0x12de>
    50dc:	b581      	and	A, dp:0x81 <_g_NvramUser+0x27>
    50de:	858a      	or	AL, dp:0x8a <_g_NvramUser+0x30>
    50e0:	715d      	lod	A, dp:0x5d <_g_NvramUser+0x3>
    50e2:	b164      	adc	A, dp:0x64 <_g_NvramUser+0xa>
    50e4:	bd83      	xor	A, dp:0x83 <_g_NvramUser+0x29>
    50e6:	8582      	or	AL, dp:0x82 <_g_NvramUser+0x28>
    50e8:	714d      	lod	A, dp:0x4d <_l_u8LinInFrameMsgID+0x1>
    50ea:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    50ec:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    50ee:	5c00      	dec	S
    50f0:	0101      	jmp	0x52f4 <__mlx4_flash_start+0x12f4>
    50f2:	5c02      	dec	S, #3
    50f4:	580e      	inc	S, #15
    50f6:	0809      	clrb	dp:0x01.1
    50f8:	090c      	clrb	io:0x01.4
    50fa:	62e6      	lod	AL, Y
    50fc:	b16f      	adc	A, dp:0x6f <_g_NvramUser+0x15>
    50fe:	a588      	or	A, dp:0x88 <_g_NvramUser+0x2e>
    5100:	1103      	call	0x5308 <__mlx4_flash_start+0x1308>
    5102:	a584      	or	A, dp:0x84 <_g_NvramUser+0x2a>
    5104:	0105      	jmp	0x5310 <__mlx4_flash_start+0x1310>
    5106:	24a3      	or	X, #-93
    5108:	2892      	sub	X, #-110
    510a:	623a      	lod	AL, [S-59]
    510c:	a688      	or	A, io:0x8 <__bist_stat_size>
    510e:	0106      	jmp	0x531c <__mlx4_flash_start+0x131c>
    5110:	287a      	sub	X, #122
    5112:	623a      	lod	AL, [S-59]
    5114:	a788      	or	A, ep:0x88 <_g_NvramUser+0x2e>
    5116:	1102      	call	0x531c <__mlx4_flash_start+0x131c>
    5118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    511a:	1101      	call	0x531e <__mlx4_flash_start+0x131e>
    511c:	2853      	sub	X, #83
    511e:	a781      	or	A, ep:0x81 <_g_NvramUser+0x27>
    5120:	1107      	call	0x5330 <__mlx4_flash_start+0x1330>
    5122:	287a      	sub	X, #122
    5124:	b14d      	adc	A, dp:0x4d <_l_u8LinInFrameMsgID+0x1>
    5126:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x26>
    5128:	1101      	call	0x532c <__mlx4_flash_start+0x132c>
    512a:	28a6      	sub	X, #-90
    512c:	5cc2      	neg	A
    512e:	287a      	sub	X, #122
    5130:	6241      	lod	AL, [S-66]
    5132:	0001      	jmp	0x5136 <__mlx4_flash_start+0x1136>
    5134:	2711      	or	X, ep:0x11 <__dp_noinit_size+0x1>
    5136:	b14d      	adc	A, dp:0x4d <_l_u8LinInFrameMsgID+0x1>
    5138:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    513a:	1101      	call	0x533e <__mlx4_flash_start+0x133e>
    513c:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x2>
    513e:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    5140:	8d80      	cmp	AL, dp:0x80 <_g_NvramUser+0x26>
    5142:	714d      	lod	A, dp:0x4d <_l_u8LinInFrameMsgID+0x1>
    5144:	e580      	or	Y, dp:0x80 <_g_NvramUser+0x26>
    5146:	1101      	call	0x534a <__mlx4_flash_start+0x134a>
    5148:	0501      	jmp	0x4b4c <__mlx4_flash_start+0xb4c>
    514a:	287a      	sub	X, #122
    514c:	b36f      	adc	A, ep:0x6f <_g_NvramUser+0x15>
    514e:	bf87      	xor	A, ep:0x87 <_g_NvramUser+0x2d>
    5150:	736f      	lod	A, ep:0x6f <_g_NvramUser+0x15>
    5152:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    5154:	3468      	and	X, #104
    5156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5158:	b203      	adc	A, [S-4]
    515a:	4610      	mov	[S-17], YL
    515c:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    515e:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    5160:	724f      	lod	A, [S-80]
    5162:	4c4f      	dadju	D, [X]
    5164:	6217      	lod	AL, [S-24]
    5166:	6233      	lod	AL, [S-52]
    5168:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    516a:	7170      	lod	A, dp:0x70 <_g_NvramUser+0x16>
    516c:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    516e:	484f      	macu	D, AL, [X]
    5170:	380a      	subc	X, #10
    5172:	3420      	and	X, #32
    5174:	3965      	subc	X, dp:0x65 <_g_NvramUser+0xb>
    5176:	3501      	and	X, dp:0x1 <__dp__+0x1>
    5178:	37a4      	and	X, ep:0xa4 <_g_NvramUser+0x4a>
    517a:	346b      	and	X, #107
    517c:	5806      	inc	S, #7
    517e:	090e      	clrb	io:0x01.6
    5180:	623a      	lod	AL, [S-59]
    5182:	484f      	macu	D, AL, [X]
    5184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5186:	b203      	adc	A, [S-4]
    5188:	4610      	mov	[S-17], YL
    518a:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    518c:	834e      	add	AL, ep:0x4e <_g_u16CorrectionRatio>
    518e:	8a4f      	sub	AL, [S-80]
    5190:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    5192:	724f      	lod	A, [S-80]
    5194:	4c4f      	dadju	D, [X]
    5196:	3409      	and	X, #9
    5198:	3808      	subc	X, #8
    519a:	28eb      	sub	X, #-21
    519c:	623a      	lod	AL, [S-59]
    519e:	a688      	or	A, io:0x8 <__bist_stat_size>
    51a0:	1101      	call	0x53a4 <__mlx4_flash_start+0x13a4>
    51a2:	28fb      	sub	X, #-5
    51a4:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    51a6:	b582      	and	A, dp:0x82 <_g_NvramUser+0x28>
    51a8:	b682      	and	A, io:0x2 <_LinCmnd>
    51aa:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    51ac:	b681      	and	A, io:0x1 <__dp__+0x1>
    51ae:	7201      	lod	A, [S-2]
    51b0:	2487      	or	X, #-121
    51b2:	6217      	lod	AL, [S-24]
    51b4:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    51b6:	0007      	jmp	0x51c6 <__mlx4_flash_start+0x11c6>
    51b8:	1107      	call	0x53c8 <__mlx4_flash_start+0x13c8>
    51ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    51bc:	d78f      	and	AH, ep:0x8f <_g_NvramUser+0x35>
    51be:	7234      	lod	A, [S-53]
    51c0:	7335      	lod	A, ep:0x35 <_g_u8NAD+0x1>
    51c2:	6228      	lod	AL, [S-41]
    51c4:	28e5      	sub	X, #-27
    51c6:	2906      	sub	X, dp:0x6 <_LinMess2>
    51c8:	6233      	lod	AL, [S-52]
    51ca:	4040      	jmp	fp2:0x00
    51cc:	3501      	and	X, dp:0x1 <__dp__+0x1>
    51ce:	580a      	inc	S, #11
    51d0:	0902      	clrb	io:0x00.2
    51d2:	62e6      	lod	AL, Y
    51d4:	28e7      	sub	X, #-25
    51d6:	623a      	lod	AL, [S-59]
    51d8:	a684      	or	A, io:0x4 <_LinMess>
    51da:	110d      	call	0x53f6 <__mlx4_flash_start+0x13f6>
    51dc:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x16>
    51de:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e0:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e2:	624a      	lod	AL, [S-75]
    51e4:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x2>
    51e6:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    51e8:	e15d      	add	Y, dp:0x5d <_g_NvramUser+0x3>
    51ea:	0109      	jmp	0x53fe <__mlx4_flash_start+0x13fe>
    51ec:	622e      	lod	AL, [S-47]
    51ee:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x16>
    51f0:	4784      	mov	ep:0x84 <_g_NvramUser+0x2a>, YL
    51f2:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x16>
    51f4:	28e6      	sub	X, #-26
    51f6:	4040      	jmp	fp2:0x00
    51f8:	624a      	lod	AL, [S-75]
    51fa:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    51fc:	2853      	sub	X, #83
    51fe:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x16>
    5200:	4040      	jmp	fp2:0x00
    5202:	4784      	mov	ep:0x84 <_g_NvramUser+0x2a>, YL
    5204:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x16>
    5206:	7ccf      	lod	X, #-49
    5208:	7d34      	lod	X, dp:0x34 <_g_u8NAD>
    520a:	28d9      	sub	X, #-39
    520c:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    520e:	580a      	inc	S, #11
    5210:	0902      	clrb	io:0x00.2
    5212:	62e6      	lod	AL, Y
    5214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    5216:	623a      	lod	AL, [S-59]
    5218:	a684      	or	A, io:0x4 <_LinMess>
    521a:	0101      	jmp	0x541e <__mlx4_flash_start+0x141e>
    521c:	28fb      	sub	X, #-5
    521e:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x5>
    5220:	a583      	or	A, dp:0x83 <_g_NvramUser+0x29>
    5222:	1103      	call	0x542a <__mlx4_flash_start+0x142a>
    5224:	b100      	adc	A, dp:0x0 <__dp__>
    5226:	a581      	or	A, dp:0x81 <_g_NvramUser+0x27>
    5228:	0102      	jmp	0x542e <__mlx4_flash_start+0x142e>
    522a:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2b>
    522c:	62bc      	lod	AL, io:0x3c <__data_dp_end>
    522e:	24a3      	or	X, #-93
    5230:	3807      	subc	X, #7
    5232:	3809      	subc	X, #9
    5234:	3468      	and	X, #104
    5236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5238:	b638      	and	A, [S-57]
    523a:	a688      	or	A, io:0x8 <__bist_stat_size>
    523c:	0101      	jmp	0x5440 <__mlx4_flash_start+0x1440>
    523e:	2494      	or	X, #-108
    5240:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    5244:	7201      	lod	A, [S-2]
    5246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    5248:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    524a:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    524c:	580e      	inc	S, #15
    524e:	0803      	clrb	dp:0x00.3
    5250:	0906      	clrb	io:0x00.6
    5252:	62e6      	lod	AL, Y
    5254:	2926      	sub	X, dp:0x26 <_g_e8ErrorOverTemperature>
    5256:	623a      	lod	AL, [S-59]
    5258:	a688      	or	A, io:0x8 <__bist_stat_size>
    525a:	010a      	jmp	0x5470 <__mlx4_flash_start+0x1470>
    525c:	248c      	or	X, #-116
    525e:	626f      	lod	AL, [S-112]
    5260:	1007      	call	0x5270 <__mlx4_flash_start+0x1270>
    5262:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    5264:	b684      	and	A, io:0x4 <_LinMess>
    5266:	62ca      	lod	AL, [--PC]
    5268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    526a:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    526c:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x16>
    526e:	2a05      	sub	X, [S-6]
    5270:	2926      	sub	X, dp:0x26 <_g_e8ErrorOverTemperature>
    5272:	5c00      	dec	S
    5274:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    5276:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    5278:	4954      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, AH
    527a:	4956      	mov	dp:0x56 <__data_size>, AH
    527c:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    527e:	a78d      	or	A, ep:0x8d <_g_NvramUser+0x33>
    5280:	1103      	call	0x5488 <__mlx4_flash_start+0x1488>
    5282:	4940      	mov	dp:0x40 <__data_dp_end+0x4>, AH
    5284:	4942      	mov	dp:0x42 <__data_dp_end+0x6>, AH
    5286:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    5288:	b78e      	and	A, ep:0x8e <_g_NvramUser+0x34>
    528a:	b763      	and	A, ep:0x63 <_g_NvramUser+0x9>
    528c:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x2>
    528e:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    5290:	735a      	lod	A, ep:0x5a <_g_NvramUser>
    5292:	736a      	lod	A, ep:0x6a <_g_NvramUser+0x10>
    5294:	736b      	lod	A, ep:0x6b <_g_NvramUser+0x11>
    5296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    5298:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    529a:	734f      	lod	A, ep:0x4f <_g_u16CorrectionRatio+0x1>
    529c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    529e:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    52a0:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    52a2:	4c4e      	dadju	D, [X++]
    52a4:	34ef      	and	X, #-17
    52a6:	3985      	subc	X, dp:0x85 <_g_NvramUser+0x2b>
    52a8:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    52aa:	4c4f      	dadju	D, [X]
    52ac:	484f      	macu	D, AL, [X]
    52ae:	3806      	subc	X, #6
    52b0:	380a      	subc	X, #10
    52b2:	3428      	and	X, #40
    52b4:	3beb      	subc	X, ep:0xeb <_ml_driver_mode+0x13>
    52b6:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    52b8:	736d      	lod	A, ep:0x6d <_g_NvramUser+0x13>
    52ba:	b588      	and	A, dp:0x88 <_g_NvramUser+0x2e>
    52bc:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    52be:	726e      	lod	A, [S-111]
    52c0:	b23b      	adc	A, [S-60]
    52c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    52c4:	1103      	call	0x54cc <__mlx4_flash_start+0x14cc>
    52c6:	4930      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AH
    52c8:	b78c      	and	A, ep:0x8c <_g_NvramUser+0x32>
    52ca:	735b      	lod	A, ep:0x5b <_g_NvramUser+0x1>
    52cc:	2282      	add	X, io:0x2 <_LinCmnd>
    52ce:	622b      	lod	AL, [S-44]
    52d0:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    52d2:	3f88      	xor	X, ep:0x88 <_g_NvramUser+0x2e>
    52d4:	b680      	and	A, io:0x0 <__dp__>
    52d6:	7271      	lod	A, [S-114]
    52d8:	7c54      	lod	X, #84
    52da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    52dc:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x2>
    52de:	4c04      	add	D, [Y++]
    52e0:	3805      	subc	X, #5
    52e2:	3808      	subc	X, #8
    52e4:	3449      	and	X, #73
    52e6:	3906      	subc	X, dp:0x6 <_LinMess2>
    52e8:	3512      	and	X, dp:0x12 <__dp_noinit_size+0x2>
    52ea:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    52ec:	623a      	lod	AL, [S-59]
    52ee:	b58c      	and	A, dp:0x8c <_g_NvramUser+0x32>
    52f0:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x3>
    52f2:	580a      	inc	S, #11
    52f4:	0902      	clrb	io:0x00.2
    52f6:	62e6      	lod	AL, Y
    52f8:	2979      	sub	X, dp:0x79 <_g_NvramUser+0x1f>
    52fa:	623a      	lod	AL, [S-59]
    52fc:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    52fe:	0102      	jmp	0x5504 <__mlx4_flash_end+0x14>
    5300:	3502      	and	X, dp:0x2 <_LinCmnd>
    5302:	2979      	sub	X, dp:0x79 <_g_NvramUser+0x1f>
    5304:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    5306:	b271      	adc	A, [S-114]
    5308:	8681      	or	AL, io:0x1 <__dp__+0x1>
    530a:	7271      	lod	A, [S-114]
    530c:	a681      	or	A, io:0x1 <__dp__+0x1>
    530e:	1105      	call	0x551a <__mlx4_flash_end+0x2a>
    5310:	e686      	or	Y, io:0x6 <_LinMess2>
    5312:	0101      	jmp	0x5516 <__mlx4_flash_end+0x26>
    5314:	296c      	sub	X, dp:0x6c <_g_NvramUser+0x12>
    5316:	b584      	and	A, dp:0x84 <_g_NvramUser+0x2a>
    5318:	29d4      	sub	X, dp:0xd4 <_LIN_nad>
    531a:	3809      	subc	X, #9
    531c:	5806      	inc	S, #7
    531e:	0902      	clrb	io:0x00.2
    5320:	623a      	lod	AL, [S-59]
    5322:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    5324:	623a      	lod	AL, [S-59]
    5326:	a688      	or	A, io:0x8 <__bist_stat_size>
    5328:	0101      	jmp	0x552c <__mlx4_flash_end+0x3c>
    532a:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    532c:	b580      	and	A, dp:0x80 <_g_NvramUser+0x26>
    532e:	7143      	lod	A, dp:0x43 <__data_dp_end+0x7>
    5330:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    5332:	b304      	adc	A, ep:0x4 <_LinMess>
    5334:	b205      	adc	A, [S-6]
    5336:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    5338:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    533a:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    533c:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    533e:	7241      	lod	A, [S-66]
    5340:	7142      	lod	A, dp:0x42 <__data_dp_end+0x6>
    5342:	4792      	mov	ep:0x92 <_g_NvramUser+0x38>, YL
    5344:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    5346:	4596      	mov	dp:0x96 <_g_NvramUser+0x3c>, YL
    5348:	8340      	add	AL, ep:0x40 <__data_dp_end+0x4>
    534a:	8a41      	sub	AL, [S-66]
    534c:	8942      	sub	AL, dp:0x42 <__data_dp_end+0x6>
    534e:	7340      	lod	A, ep:0x40 <__data_dp_end+0x4>
    5350:	7241      	lod	A, [S-66]
    5352:	7142      	lod	A, dp:0x42 <__data_dp_end+0x6>
    5354:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    5356:	b788      	and	A, ep:0x88 <_g_NvramUser+0x2e>
    5358:	b682      	and	A, io:0x2 <_LinCmnd>
    535a:	62ca      	lod	AL, [--PC]
    535c:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    535e:	f784      	and	Y, ep:0x84 <_g_NvramUser+0x2a>
    5360:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    5362:	24a3      	or	X, #-93
    5364:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    5366:	b271      	adc	A, [S-114]
    5368:	e685      	or	Y, io:0x5 <_LinMess+0x1>
    536a:	0103      	jmp	0x5572 <_INDXtbl+0x32>
    536c:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2a>
    536e:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2b>
    5370:	29bb      	sub	X, dp:0xbb <__bss_dp_size+0xb>
    5372:	b786      	and	A, ep:0x86 <_g_NvramUser+0x2c>
    5374:	b587      	and	A, dp:0x87 <_g_NvramUser+0x2d>
    5376:	b763      	and	A, ep:0x63 <_g_NvramUser+0x9>
    5378:	b561      	and	A, dp:0x61 <_g_NvramUser+0x7>
    537a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    537c:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    537e:	b682      	and	A, io:0x2 <_LinCmnd>
    5380:	75bc      	lod	PC, dp:0xbc <__bss_dp_size+0xc>
    5382:	3b33      	subc	X, ep:0x33 <_g_u8SAE_SendErrorState>
    5384:	580f      	inc	S, #16
    5386:	080b      	clrb	dp:0x01.3
    5388:	0902      	clrb	io:0x00.2
    538a:	62e6      	lod	AL, Y
    538c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    538e:	623a      	lod	AL, [S-59]
    5390:	a688      	or	A, io:0x8 <__bist_stat_size>
    5392:	0105      	jmp	0x559e <_INDXtbl+0x5e>
    5394:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    5396:	bf8f      	xor	A, ep:0x8f <_g_NvramUser+0x35>
    5398:	0101      	jmp	0x559c <_INDXtbl+0x5c>
    539a:	2982      	sub	X, dp:0x82 <_g_NvramUser+0x28>
    539c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    539e:	623a      	lod	AL, [S-59]
    53a0:	b785      	and	A, ep:0x85 <_g_NvramUser+0x2b>
    53a2:	b682      	and	A, io:0x2 <_LinCmnd>
    53a4:	62ca      	lod	AL, [--PC]
    53a6:	24a3      	or	X, #-93
    53a8:	7172      	lod	A, dp:0x72 <_g_NvramUser+0x18>
    53aa:	b738      	and	A, ep:0x38 <_g_u16StartupDelay>
    53ac:	7370      	lod	A, ep:0x70 <_g_NvramUser+0x16>
    53ae:	b787      	and	A, ep:0x87 <_g_NvramUser+0x2d>
    53b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    53b2:	734f      	lod	A, ep:0x4f <_g_u16CorrectionRatio+0x1>
    53b4:	b786      	and	A, ep:0x86 <_g_NvramUser+0x2c>
    53b6:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    53b8:	734e      	lod	A, ep:0x4e <_g_u16CorrectionRatio>
    53ba:	4c4e      	dadju	D, [X++]
    53bc:	4c4f      	dadju	D, [X]
    53be:	b784      	and	A, ep:0x84 <_g_NvramUser+0x2a>
    53c0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x5>
    53c2:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x2>
    53c4:	3469      	and	X, #105
    53c6:	3807      	subc	X, #7
    53c8:	380a      	subc	X, #10
    53ca:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    53cc:	b585      	and	A, dp:0x85 <_g_NvramUser+0x2b>
    53ce:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x3>
    53d0:	8581      	or	AL, dp:0x81 <_g_NvramUser+0x27>
    53d2:	580e      	inc	S, #15
    53d4:	0803      	clrb	dp:0x00.3
    53d6:	0906      	clrb	io:0x00.6
    53d8:	62e6      	lod	AL, Y
    53da:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x11>
    53dc:	623a      	lod	AL, [S-59]
    53de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    53e0:	110c      	call	0x55fa <_start+0x12>
    53e2:	2a3c      	sub	X, [S-61]
    53e4:	627c      	lod	AL, [S-125]
    53e6:	0101      	jmp	0x55ea <_start+0x2>
    53e8:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x11>
    53ea:	623a      	lod	AL, [S-59]
    53ec:	c581      	or	AH, dp:0x81 <_g_NvramUser+0x27>
    53ee:	0107      	jmp	0x55fe <_start+0x16>
    53f0:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2a>
    53f2:	1104      	call	0x55fc <_start+0x14>
    53f4:	a681      	or	A, io:0x1 <__dp__+0x1>
    53f6:	1102      	call	0x55fc <_start+0x14>
    53f8:	29ef      	sub	X, dp:0xef <_g_u8MotorHoldingCurrEna>
    53fa:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x11>
    53fc:	29ef      	sub	X, dp:0xef <_g_u8MotorHoldingCurrEna>
    53fe:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5400:	e584      	or	Y, dp:0x84 <_g_NvramUser+0x2a>
    5402:	0103      	jmp	0x560a <__ram_section_init>
    5404:	b372      	adc	A, ep:0x72 <_g_NvramUser+0x18>
    5406:	b684      	and	A, io:0x4 <_LinMess>
    5408:	62ca      	lod	AL, [--PC]
    540a:	b365      	adc	A, ep:0x65 <_g_NvramUser+0xb>
    540c:	a784      	or	A, ep:0x84 <_g_NvramUser+0x2a>
    540e:	1101      	call	0x5612 <__ram_section_init+0x8>
    5410:	2a1b      	sub	X, [S-28]
    5412:	3448      	and	X, #72
    5414:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    5416:	3804      	subc	X, #4
    5418:	3e40      	xor	X, [S-65]
    541a:	3f8c      	xor	X, ep:0x8c <_g_NvramUser+0x32>
    541c:	b723      	and	A, ep:0x23 <_g_i16ChipTemperature+0x1>
    541e:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2a>
    5420:	0105      	jmp	0x562c <__ram_section_init+0x22>
    5422:	623a      	lod	AL, [S-59]
    5424:	bf88      	xor	A, ep:0x88 <_g_NvramUser+0x2e>
    5426:	1101      	call	0x562a <__ram_section_init+0x20>
    5428:	2a0e      	sub	X, [S-15]
    542a:	2a3a      	sub	X, [S-59]
    542c:	3e98      	xor	X, io:0x18 <__data_dp_start>
    542e:	580b      	inc	S, #12
    5430:	090d      	clrb	io:0x01.5
    5432:	62e6      	lod	AL, Y
    5434:	2a17      	sub	X, [S-24]
    5436:	3468      	and	X, #104
    5438:	3790      	and	X, ep:0x90 <_g_NvramUser+0x36>
    543a:	3806      	subc	X, #6
    543c:	380a      	subc	X, #10
    543e:	b370      	adc	A, ep:0x70 <_g_NvramUser+0x16>
    5440:	bf88      	xor	A, ep:0x88 <_g_NvramUser+0x2e>
    5442:	010d      	jmp	0x565e <_STACK_IT+0x12>
    5444:	b638      	and	A, [S-57]
    5446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5448:	110a      	call	0x565e <_STACK_IT+0x12>
    544a:	2a3c      	sub	X, [S-61]
    544c:	627c      	lod	AL, [S-125]
    544e:	0101      	jmp	0x5652 <_STACK_IT+0x6>
    5450:	2a17      	sub	X, [S-24]
    5452:	b723      	and	A, ep:0x23 <_g_i16ChipTemperature+0x1>
    5454:	bf84      	xor	A, ep:0x84 <_g_NvramUser+0x2a>
    5456:	110e      	call	0x5674 <_STACK_IT+0x28>
    5458:	623a      	lod	AL, [S-59]
    545a:	7c05      	lod	X, #5
    545c:	2a17      	sub	X, [S-24]
    545e:	580e      	inc	S, #15
    5460:	0805      	clrb	dp:0x00.5
    5462:	0902      	clrb	io:0x00.2
    5464:	62e6      	lod	AL, Y
    5466:	2a2f      	sub	X, [S-48]
    5468:	627c      	lod	AL, [S-125]
    546a:	2a2f      	sub	X, [S-48]
    546c:	623a      	lod	AL, [S-59]
    546e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5470:	0103      	jmp	0x5678 <_STACK_IT+0x2c>
    5472:	2a2f      	sub	X, [S-48]
    5474:	622b      	lod	AL, [S-44]
    5476:	2a72      	sub	X, [S-115]
    5478:	4d3e      	mov	dp:0x3e <__data_dp_end+0x2>, YH
    547a:	4930      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AH
    547c:	3449      	and	X, #73
    547e:	3809      	subc	X, #9
    5480:	3805      	subc	X, #5
    5482:	37a0      	and	X, ep:0xa0 <_g_NvramUser+0x46>
    5484:	3986      	subc	X, dp:0x86 <_g_NvramUser+0x2c>
    5486:	580e      	inc	S, #15
    5488:	0803      	clrb	dp:0x00.3
    548a:	0903      	clrb	io:0x00.3
    548c:	62e6      	lod	AL, Y
    548e:	2a43      	sub	X, [S-68]
    5490:	2a60      	sub	X, [S-97]
    5492:	627c      	lod	AL, [S-125]
    5494:	0101      	jmp	0x5698 <__fatal+0xa>
    5496:	2a43      	sub	X, [S-68]
    5498:	623a      	lod	AL, [S-59]
    549a:	b330      	adc	A, ep:0x30 <_l_u8SynchFieldErrorCounter>
    549c:	b231      	adc	A, [S-50]
    549e:	8781      	or	AL, ep:0x81 <_g_NvramUser+0x27>
    54a0:	8e80      	cmp	AL, io:0x0 <__dp__>
    54a2:	7330      	lod	A, ep:0x30 <_l_u8SynchFieldErrorCounter>
    54a4:	7231      	lod	A, [S-50]
    54a6:	b588      	and	A, dp:0x88 <_g_NvramUser+0x2e>
    54a8:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x3>
    54aa:	b589      	and	A, dp:0x89 <_g_NvramUser+0x2f>
    54ac:	ee5d      	cmp	Y, [S-94]
    54ae:	1102      	call	0x56b4 <__fatal+0x26>
    54b0:	b782      	and	A, ep:0x82 <_g_NvramUser+0x28>
    54b2:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    54b4:	b58a      	and	A, dp:0x8a <_g_NvramUser+0x30>
    54b6:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x3>
    54b8:	b58b      	and	A, dp:0x8b <_g_NvramUser+0x31>
    54ba:	ee5d      	cmp	Y, [S-94]
    54bc:	0001      	jmp	0x54c0 <__mlx4_flash_start+0x14c0>
    54be:	2918      	sub	X, dp:0x18 <__data_dp_start>
    54c0:	623a      	lod	AL, [S-59]
    54c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    54c4:	1101      	call	0x56c8 <__fatal+0x3a>
    54c6:	2a43      	sub	X, [S-68]
    54c8:	b201      	adc	A, [S-2]
    54ca:	b33b      	adc	A, ep:0x3b <_l_u8StallCountA>
    54cc:	a782      	or	A, ep:0x82 <_g_NvramUser+0x28>
    54ce:	1105      	call	0x56da <__fatal+0x4c>
    54d0:	7c05      	lod	X, #5
    54d2:	e684      	or	Y, io:0x4 <_LinMess>
    54d4:	0101      	jmp	0x56d8 <__fatal+0x4a>
    54d6:	29e2      	sub	X, dp:0xe2 <_ml_driver_mode+0xa>
    54d8:	2a1b      	sub	X, [S-28]
    54da:	e684      	or	Y, io:0x4 <_LinMess>
    54dc:	0103      	jmp	0x56e4 <__fatal+0x56>
    54de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    54e0:	62b5      	lod	AL, io:0x35 <_g_u8NAD+0x1>
    54e2:	24a3      	or	X, #-93
    54e4:	b783      	and	A, ep:0x83 <_g_NvramUser+0x29>
    54e6:	b682      	and	A, io:0x2 <_LinCmnd>
    54e8:	62ca      	lod	AL, [--PC]
    54ea:	b780      	and	A, ep:0x80 <_g_NvramUser+0x26>
    54ec:	733b      	lod	A, ep:0x3b <_l_u8StallCountA>
    54ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00005540 <_INDXtbl>:
    5540:	c0c0      	add	AH, #-64
    5542:	c0c0      	add	AH, #-64
    5544:	c0c0      	add	AH, #-64
    5546:	c0c0      	add	AH, #-64
    5548:	c0c0      	add	AH, #-64
    554a:	c0c0      	add	AH, #-64
    554c:	c0c0      	add	AH, #-64
    554e:	c0c0      	add	AH, #-64
    5550:	c0c0      	add	AH, #-64
    5552:	c0c0      	add	AH, #-64
    5554:	c0c0      	add	AH, #-64
    5556:	c0c0      	add	AH, #-64
    5558:	c0c0      	add	AH, #-64
    555a:	c0c0      	add	AH, #-64
    555c:	c0c0      	add	AH, #-64
    555e:	c0c0      	add	AH, #-64
    5560:	c0c0      	add	AH, #-64
    5562:	c0c0      	add	AH, #-64
    5564:	c0c0      	add	AH, #-64
    5566:	c0c0      	add	AH, #-64
    5568:	c0c0      	add	AH, #-64
    556a:	c0c0      	add	AH, #-64
    556c:	c0c0      	add	AH, #-64
    556e:	c0c0      	add	AH, #-64
    5570:	c0c0      	add	AH, #-64
    5572:	c0c0      	add	AH, #-64
    5574:	c0c0      	add	AH, #-64
    5576:	c0c0      	add	AH, #-64
    5578:	c0c0      	add	AH, #-64
    557a:	c0c0      	add	AH, #-64
    557c:	1110      	call	0x579e <__prestart+0x78>
    557e:	c0c0      	add	AH, #-64
    5580:	2b0b      	sub	X, ep:0xb <__bist_stat_size+0x3>
    5582:	a0a0      	add	A, #-96
    5584:	a0a0      	add	A, #-96
    5586:	a0a0      	add	A, #-96
    5588:	a0a0      	add	A, #-96
    558a:	a0a0      	add	A, #-96
    558c:	a0a0      	add	A, #-96
    558e:	a0a0      	add	A, #-96
    5590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    5592:	a0a0      	add	A, #-96
    5594:	a0a0      	add	A, #-96
    5596:	a0a0      	add	A, #-96
    5598:	a0a0      	add	A, #-96
    559a:	a0a0      	add	A, #-96
    559c:	a0a0      	add	A, #-96
    559e:	a0a0      	add	A, #-96
    55a0:	a0a0      	add	A, #-96
    55a2:	a0a0      	add	A, #-96
    55a4:	a0a0      	add	A, #-96
    55a6:	a0a0      	add	A, #-96
    55a8:	a0a0      	add	A, #-96
    55aa:	a0a0      	add	A, #-96
    55ac:	a0a0      	add	A, #-96
    55ae:	a0a0      	add	A, #-96
    55b0:	a0a0      	add	A, #-96
    55b2:	a0a0      	add	A, #-96
    55b4:	a0a0      	add	A, #-96
    55b6:	a0a0      	add	A, #-96
    55b8:	a0a0      	add	A, #-96
    55ba:	a0a0      	add	A, #-96
    55bc:	a0a0      	add	A, #-96
    55be:	a0a0      	add	A, #-96

000055c0 <_AUTOADDtbl>:
    55c0:	2610      	or	X, [S-17]
    55c2:	1626      	call	0x5210 <__mlx4_flash_start+0x1210>
    55c4:	0000      	nop
    55c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 5726 	jmpf	0x5726 <__prestart>
    bf6e:	a55a      	or	A, dp:0x5a <_g_NvramUser>
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da 564c 	jmpf	0x564c <_STACK_IT>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	6402      	lod	YL, #2
    bf7c:	76da 568e 	jmpf	0x568e <__fatal>
    bf80:	54f8      	mov	UPr, #8
    bf82:	6403      	lod	YL, #3
    bf84:	76da 568e 	jmpf	0x568e <__fatal>
    bf88:	54f8      	mov	UPr, #8
    bf8a:	6404      	lod	YL, #4
    bf8c:	76da 568e 	jmpf	0x568e <__fatal>
    bf90:	54f0      	mov	UPr, #0
    bf92:	6405      	lod	YL, #5
    bf94:	76da 568e 	jmpf	0x568e <__fatal>
    bf98:	54f0      	mov	UPr, #0
    bf9a:	6406      	lod	YL, #6
    bf9c:	76da 568e 	jmpf	0x568e <__fatal>
    bfa0:	54f0      	mov	UPr, #0
    bfa2:	6407      	lod	YL, #7
    bfa4:	76da 568e 	jmpf	0x568e <__fatal>
    bfa8:	54f0      	mov	UPr, #0
    bfaa:	6408      	lod	YL, #8
    bfac:	76da 568e 	jmpf	0x568e <__fatal>
    bfb0:	54d4      	psup	#4
    bfb2:	76da 5dc0 	jmpf	0x5dc0 <_linit>
    bfb6:	0000      	nop
    bfb8:	54d5      	psup	#5
    bfba:	76da a348 	jmpf	0xa348 <_TIMER_IT>
    bfbe:	0000      	nop
    bfc0:	54d4      	psup	#4
    bfc2:	76da 8868 	jmpf	0x8868 <_ADC_IT>
    bfc6:	0000      	nop
    bfc8:	54f0      	mov	UPr, #0
    bfca:	640c      	lod	YL, #12
    bfcc:	76da 568e 	jmpf	0x568e <__fatal>
    bfd0:	54d3      	psup	#3
    bfd2:	76da 96f4 	jmpf	0x96f4 <_EXT0_IT>
    bfd6:	0000      	nop
    bfd8:	54f0      	mov	UPr, #0
    bfda:	640e      	lod	YL, #14
    bfdc:	76da 568e 	jmpf	0x568e <__fatal>
    bfe0:	54f0      	mov	UPr, #0
    bfe2:	640f      	lod	YL, #15
    bfe4:	76da 568e 	jmpf	0x568e <__fatal>
    bfe8:	54f0      	mov	UPr, #0
    bfea:	6410      	lod	YL, #16
    bfec:	76da 568e 	jmpf	0x568e <__fatal>
    bff0:	54d2      	psup	#2
    bff2:	76da 8bcc 	jmpf	0x8bcc <_EXT4_IT>
    bff6:	0000      	nop
    bff8:	54f0      	mov	UPr, #0
    bffa:	6412      	lod	YL, #18
    bffc:	76da 568e 	jmpf	0x568e <__fatal>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000055e8 <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    55e8:	7000      	lod	A, #0
    55ea:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    55ec:	70ff      	lod	A, #-1
    55ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    55f2:	72da 033e 	lod	A, #830
    55f6:	52ef      	mov	S, A

    _low_level_init();
    55f8:	82db 693a 	callf	0x693a <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    55fc:	1006      	call	0x560a <__ram_section_init>
    _premain();
    55fe:	82db 6a8c 	callf	0x6a8c <__premain>
    (void)main();
    5602:	82db 6fe8 	callf	0x6fe8 <_main>
    _fatal();
    5606:	1043      	call	0x568e <__fatal>
    5608:	5401      	ret

0000560a <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    560a:	7ada 003c 	lod	Y, #60
    560e:	eeda 00ec 	cmp	Y, #236
    5612:	1c03      	jnc	0x561a <__ram_section_init+0x10>
        *w++ = 0;
    5614:	7000      	lod	A, #0
    5616:	52d6      	mov	[Y++], A
    5618:	07fa      	jmp	0x560e <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    561a:	7ada 0152 	lod	Y, #338
    561e:	eeda 0336 	cmp	Y, #822
    5622:	1c03      	jnc	0x562a <__ram_section_init+0x20>
        *w++ = 0;
    5624:	7000      	lod	A, #0
    5626:	52d6      	mov	[Y++], A
    5628:	07fa      	jmp	0x561e <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    562a:	7eda a5a6 	lod	X, #42406

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    562e:	7ada 0018 	lod	Y, #24
    5632:	eeda 003c 	cmp	Y, #60
    5636:	1c02      	jnc	0x563c <__ram_section_init+0x32>
        *w++ = *r++;
    5638:	54ce      	movsw	[Y++], [X++]
    563a:	07fb      	jmp	0x5632 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    563c:	7ada 00fc 	lod	Y, #252
    5640:	eeda 0152 	cmp	Y, #338
    5644:	1c02      	jnc	0x564a <__ram_section_init+0x40>
        *w++ = *r++;
    5646:	54ce      	movsw	[Y++], [X++]
    5648:	07fb      	jmp	0x5640 <__ram_section_init+0x36>
    564a:	5401      	ret

0000564c <_STACK_IT>:
 */
__MLX_TEXT__ void STACK_IT(void)
{
//	SET_STACK( &stack);
	/* Chip header is valid and chip successfully initialised; LIN Command Reset use AWD to reset chip */
	if ( (bistHeader == C_CHIP_HEADER) && ((bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET) || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)) )
    564c:	72d8 0336 	lod	A, 0x336 <__bss_end>
    5650:	aeda b598 	cmp	A, #46488
    5654:	1d19      	jne	0x5688 <_STACK_IT+0x3c>
    5656:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    565a:	aeda 3072 	cmp	A, #12402
    565e:	1905      	je	0x566a <_STACK_IT+0x1e>
    5660:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5664:	aeda 3212 	cmp	A, #12818
    5668:	1d0f      	jne	0x5688 <_STACK_IT+0x3c>
	{
		/* INLINE MLX16_RESET (Don't use stack) */
		do
		{
			if ( (PLL_CTRL & PLL_EN) != 0 )								/* Only delay in case of PLL is active */
    566a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    566e:	b401      	and	A, #1
    5670:	1903      	je	0x5678 <_STACK_IT+0x2c>
			{
				DELAY_US( 250);											/* Should be called with period > 200us, otherwise bit AWD_WRITE_FAIL will be set and further acknowledgment will fail during next 200 us */
    5672:	7eda 06d6 	lod	X, #1750
    5676:	1bff      	djnz	X, 0x5676 <_STACK_IT+0x2a>
			}
			AWD_CTRL = (AWD_ATT | AWD_WRITE_FAIL | (3u << 8) | 1);		/* Set 1:1 pre-scaler and minimal period; AWD timeout will be 100 us */
    5678:	72da 6301 	lod	A, #25345
    567c:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
		} while ( AWD_CTRL & (AWD_ATT | AWD_WRITE_FAIL) );
    567e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    5680:	b6da 6000 	and	A, #24576
    5684:	1d72      	jne	0x566a <_STACK_IT+0x1e>
		for ( ; ; ) {
    5686:	07ff      	jmp	0x5686 <_STACK_IT+0x3a>
			/* wait for reset */
		}
	}
	__asm__( "mov yl, #01");
    5688:	6401      	lod	YL, #1
	__asm__( "jmp __fatal");
    568a:	0001      	jmp	0x568e <__fatal>
    568c:	5401      	ret

0000568e <__fatal>:
 * 0x079C: Address of failure (from stack)
 */
__MLX_TEXT__ void _fatal (void)
{
	/* YL = Error-reason; Don't use stack (MMP151125-1) */
	__asm__("lod X, 0x2026");													/* X = [FL_CTRL0] */
    568e:	7ed8 2026 	lod	X, 0x2026 <__ep__+0x1026>
	__asm__("and X, #0x07");													/* X[2:0] = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) */
    5692:	3407      	and	X, #7
	__asm__("lod A, 0x2040");													/* A = [PLL_STAT] */
    5694:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
	__asm__("and A, #0x03");													/* A[1:0] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) */
    5698:	b403      	and	A, #3
	__asm__("asl A, #2");
    569a:	44a2      	asl	A, #2
	__asm__("asl A, #2");														/* A[5:4] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569c:	44a2      	asl	A, #2
	__asm__("or  A, X");														/* A(L) = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569e:	a6ee      	or	A, X
	__asm__("lod YH, AL");														/* YH = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    56a0:	6ee0      	lod	YH, AL
	__asm__("mov _bistError, Y");
    56a2:	5ad8 033a 	mov	0x33a <_bistError>, Y
	__asm__("lod A, [S-2]");													/* Save address of failed instruction */
    56a6:	7201      	lod	A, [S-2]
	__asm__("mov _bistErrorInfo, A");											/* Failure address */
    56a8:	52d8 033c 	mov	0x33c <_bistErrorInfo>, A

#if _SUPPORT_CRASH_RECOVERY
	/* Crash recovery */
	if ( (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) && ((uint8)(bistError & 0xFF) < 0x05) )	/* MMP151125-1 */
    56ac:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    56b0:	aeda 1a45 	cmp	A, #6725
    56b4:	1d26      	jne	0x5702 <__fatal+0x74>
    56b6:	72d8 033a 	lod	A, 0x33a <_bistError>
    56ba:	8c04      	cmp	AL, #4
    56bc:	1e22      	jug	0x5702 <__fatal+0x74>
	{
		/* Crash recovery is enabled, and type of IRQ is between 0x01 and 0x04 */
		bistResetInfo = C_CHIP_STATE_FATAL_CRASH_RECOVERY;						/* Start recovery (on-going) */
    56be:	72da 1872 	lod	A, #6258
    56c2:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
		SET_STACK( &stack);														/* Re-initialise stack */
    56c6:	72da 033e 	lod	A, #830
    56ca:	52ef      	mov	S, A
		ENTER_SYSTEM_MODE();													/* Protected mode, highest priority (0) (MMP141023-1) */
    56cc:	4407      	mov	R, #0
    56ce:	500c      	call	fp0:0x60
    56d0:	54f0      	mov	UPr, #0
		XI0_PEND = CLR_T1_INT4;
    56d2:	7040      	lod	A, #64
    56d4:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI2_PEND = 0xFFFF;														/* Clear all XI2_PEND flags */
    56d8:	70ff      	lod	A, #-1
    56da:	52d8 2038 	mov	0x2038 <__ep__+0x1038>, A
		XI4_PEND = (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV);
    56de:	72da e100 	lod	A, #57600
    56e2:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		g_u8Mlx4ErrorState = (uint8) C_MLX4_STATE_IMMEDIATE_RST;				/* Reset MLX4 always */
    56e6:	6080      	lod	AL, #-128
    56e8:	42d8 010e 	mov	0x10e <_g_u8Mlx4ErrorState>, AL
		PEND = CLR_TIMER_IT;													/* Core-Timer */
    56ec:	7020      	lod	A, #32
    56ee:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		SET_PRIORITY( 7);														/* Protected mode, low priority (7) */
    56f2:	54f7      	mov	UPr, #7
		(void) FlashBackgroundTest( 0);
    56f4:	7000      	lod	A, #0
    56f6:	82db 6d3a 	callf	0x6d3a <_FlashBackgroundTest>
				NVRAM_SavePage( NVRAM1_PAGE2 | NVRAM_PAGE_WR_SKIP_WAIT);
			}
		}
#endif /* (_DEBUG_FATAL != FALSE) */

		(void) main();
    56fa:	82db 6fe8 	callf	0x6fe8 <_main>

		/* Should never come here, as main should not be left */
		__asm__( "mov YL, #0x19");												/* C_MLX16_MAIN_FATAL */
    56fe:	6419      	lod	YL, #25
		/* lint -e{974} */ _fatal();
    5700:	17c6      	call	0x568e <__fatal>
	}
#endif /* _SUPPORT_CRASH_RECOVERY */

	SET_STACK( &stack);															/* Re-initialise stack (MMP141023-1) */
    5702:	72da 033e 	lod	A, #830
    5706:	52ef      	mov	S, A
	ENTER_SYSTEM_MODE();														/* Protected mode, highest priority (0) (MMP141023-1) */
    5708:	4407      	mov	R, #0
    570a:	500c      	call	fp0:0x60
    570c:	54f0      	mov	UPr, #0
	FL_CTRL0 &= ~(FL_DBE | FL_SBE);												/* Clear DBE and SBE errors (MMP141023-1) */
    570e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5712:	b4f9      	and	A, #-7
    5714:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
		}
	}
#endif /* (_DEBUG_FATAL != FALSE) */

	/* Disable motor driver first, before waiting for watchdog */
	DRVCFG_DIS_UVWT();															/* Tri-state (disconnect) the phase U, V, W and T (MMP130919-1) */
    5718:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    571c:	b6da fe00 	and	A, #65024
    5720:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	for (;;) {
    5724:	07ff      	jmp	0x5724 <__fatal+0x96>

00005726 <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    5726:	5801      	inc	S, #2
    5728:	7000      	lod	A, #0
    572a:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    572c:	70ff      	lod	A, #-1
    572e:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    5732:	72da 033e 	lod	A, #830
    5736:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    5738:	1130      	call	0x599a <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    573a:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    573e:	b401      	and	A, #1
    5740:	1d27      	jne	0x5790 <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5742:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5746:	5cf2      	usex	A
    5748:	4422      	asl	A
    574a:	7ada 10e8 	lod	Y, #4328
    574e:	eae2      	sub	Y, A
    5750:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5754:	5cf2      	usex	A
    5756:	7ee2      	lod	X, A
    5758:	7014      	lod	A, #20
    575a:	aaee      	sub	A, X
    575c:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    575e:	7ee2      	lod	X, A
    5760:	7000      	lod	A, #0
    5762:	08a7      	clrb	ML.7
    5764:	b2d6      	adc	A, [Y++]
    5766:	1bfe      	djnz	X, 0x5764 <__prestart+0x3e>
    5768:	92e4      	adc	AL, AH
    576a:	9000      	adc	AL, #0
    576c:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    576e:	aeda 00ff 	cmp	A, #255
    5772:	1d0e      	jne	0x5790 <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    5774:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    5778:	b4f8      	and	A, #-8
    577a:	aeda 04b8 	cmp	A, #1208
    577e:	1d08      	jne	0x5790 <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    5780:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    5784:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    5788:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    578a:	eeda 201a 	cmp	Y, #8218
    578e:	1a7c      	jule	0x5788 <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    5790:	72d8 0336 	lod	A, 0x336 <__bss_end>
    5794:	aeda b598 	cmp	A, #46488
    5798:	1901      	je	0x579c <__prestart+0x76>
    579a:	0037      	jmp	0x580a <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    579c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    579e:	ac00      	cmp	A, #0
    57a0:	1a84      	jsl	0x57aa <__prestart+0x84>
    57a2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    57a6:	8c00      	cmp	AL, #0
    57a8:	1e98      	jsge	0x57da <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    57aa:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57ae:	aeda 3072 	cmp	A, #12402
    57b2:	1d01      	jne	0x57b6 <__prestart+0x90>
    57b4:	0031      	jmp	0x5818 <__prestart+0xf2>
    57b6:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57ba:	aeda 3212 	cmp	A, #12818
    57be:	192c      	je	0x5818 <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    57c0:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57c4:	1905      	je	0x57d0 <__prestart+0xaa>
    57c6:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57ca:	aeda 1a45 	cmp	A, #6725
    57ce:	1d03      	jne	0x57d6 <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    57d0:	72da 5c92 	lod	A, #23698
    57d4:	000d      	jmp	0x57f0 <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    57d6:	7c00      	lod	X, #0
    57d8:	0015      	jmp	0x5804 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    57da:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57de:	aeda 3072 	cmp	A, #12402
    57e2:	1909      	je	0x57f6 <__prestart+0xd0>
    57e4:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57e8:	aeda 3212 	cmp	A, #12818
    57ec:	1904      	je	0x57f6 <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    57ee:	7000      	lod	A, #0
    57f0:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
    57f4:	0011      	jmp	0x5818 <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    57f6:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    57fa:	aeda 1a45 	cmp	A, #6725
    57fe:	1d0c      	jne	0x5818 <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    5800:	7eda 56d2 	lod	X, #22226
    5804:	5ed8 0338 	mov	0x338 <_bistResetInfo>, X
    5808:	0007      	jmp	0x5818 <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    580a:	7000      	lod	A, #0
    580c:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    5810:	7eda b598 	lod	X, #46488
    5814:	5ed8 0336 	mov	0x336 <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    5818:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    581c:	aeda 3072 	cmp	A, #12402
    5820:	1919      	je	0x5854 <__prestart+0x12e>
    5822:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5826:	aeda 3212 	cmp	A, #12818
    582a:	1914      	je	0x5854 <__prestart+0x12e>
    582c:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5830:	aeda 5c92 	cmp	A, #23698
    5834:	190f      	je	0x5854 <__prestart+0x12e>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5836:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    583a:	7c20      	lod	X, #32
    583c:	7000      	lod	A, #0
    583e:	08a7      	clrb	ML.7
    5840:	b2d6      	adc	A, [Y++]
    5842:	1bfe      	djnz	X, 0x5840 <__prestart+0x11a>
    5844:	92e4      	adc	AL, AH
    5846:	9000      	adc	AL, #0
    5848:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    584a:	aeda 00ff 	cmp	A, #255
    584e:	1902      	je	0x5854 <__prestart+0x12e>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    5850:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    5852:	071d      	jmp	0x568e <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    5854:	6030      	lod	AL, #48
    5856:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    585a:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    585e:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    5862:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    5866:	a6da 8000 	or	A, #32768
    586a:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    586e:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    5872:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    5876:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    587a:	b6da 00ff 	and	A, #255
    587e:	a6da c000 	or	A, #49152
    5882:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    5886:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    588a:	94cf      	and	AL, #-49
    588c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    5890:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    5894:	b4f9      	and	A, #-7
    5896:	a402      	or	A, #2
    5898:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    589c:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    58a0:	b401      	and	A, #1
    58a2:	1914      	je	0x58cc <__prestart+0x1a6>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    58a4:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    58a8:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    58ac:	a6e6      	or	A, Y
    58ae:	190e      	je	0x58cc <__prestart+0x1a6>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    58b0:	7eda 55c8 	lod	X, #21960

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    58b4:	7ada 0740 	lod	Y, #1856
    58b8:	eeda 075e 	cmp	Y, #1886
    58bc:	1c05      	jnc	0x58c8 <__prestart+0x1a2>
        *w++ = *r++;
    58be:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c0:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c2:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c4:	54ce      	movsw	[Y++], [X++]
    58c6:	07f8      	jmp	0x58b8 <__prestart+0x192>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    58c8:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    58cc:	72da 6fd1 	lod	A, #28625
    58d0:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58d4:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    58d6:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    58da:	b401      	and	A, #1
    58dc:	1d03      	jne	0x58e4 <__prestart+0x1be>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58de:	e001      	add	Y, #1
    58e0:	ec63      	cmp	Y, #99
    58e2:	1a79      	jule	0x58d6 <__prestart+0x1b0>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    58e4:	ec64      	cmp	Y, #100
    58e6:	1d01      	jne	0x58ea <__prestart+0x1c4>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    58e8:	07ff      	jmp	0x58e8 <__prestart+0x1c2>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    58ea:	6024      	lod	AL, #36
    58ec:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    58f0:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    58f4:	aeda 3072 	cmp	A, #12402
    58f8:	190e      	je	0x5916 <__prestart+0x1f0>
    58fa:	82db 6646 	callf	0x6646 <_LDR_GetState>
    58fe:	8c00      	cmp	AL, #0
    5900:	1d0a      	jne	0x5916 <__prestart+0x1f0>
    5902:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5906:	aeda 3212 	cmp	A, #12818
    590a:	1905      	je	0x5916 <__prestart+0x1f0>
    590c:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5910:	aeda 5c92 	cmp	A, #23698
    5914:	1d02      	jne	0x591a <__prestart+0x1f4>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    5916:	0668      	jmp	0x55e8 <_start>
    5918:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    591a:	76da 68ea 	jmpf	0x68ea <_RAM_Test>
    591e:	5403      	ret	#4

00005920 <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    5920:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    5922:	4407      	mov	R, #0
    5924:	500c      	call	fp0:0x60
    5926:	54f0      	mov	UPr, #0
    5928:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    592a:	b430      	and	A, #48
    592c:	ac10      	cmp	A, #16
    592e:	1914      	je	0x5958 <_MLX16_RESET+0x38>
    5930:	1e03      	jug	0x5938 <_MLX16_RESET+0x18>
    5932:	ac00      	cmp	A, #0
    5934:	190c      	je	0x594e <_MLX16_RESET+0x2e>
    5936:	002f      	jmp	0x5996 <_MLX16_RESET+0x76>
    5938:	ac20      	cmp	A, #32
    593a:	1903      	je	0x5942 <_MLX16_RESET+0x22>
    593c:	ac30      	cmp	A, #48
    593e:	1904      	je	0x5948 <_MLX16_RESET+0x28>
    5940:	002a      	jmp	0x5996 <_MLX16_RESET+0x76>
    5942:	6000      	lod	AL, #0
    5944:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5946:	07fd      	jmp	0x5942 <_MLX16_RESET+0x22>
    5948:	6000      	lod	AL, #0
    594a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    594c:	07ff      	jmp	0x594c <_MLX16_RESET+0x2c>
    594e:	6001      	lod	AL, #1
    5950:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5952:	6010      	lod	AL, #16
    5954:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    5956:	07ff      	jmp	0x5956 <_MLX16_RESET+0x36>
    5958:	6282      	lod	AL, io:0x2 <_LinCmnd>
    595a:	66e0      	lod	YL, AL
    595c:	5cf6      	usex	Y
    595e:	44a6      	asl	Y, #2
    5960:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5962:	b403      	and	A, #3
    5964:	4422      	asl	A
    5966:	ac00      	cmp	A, #0
    5968:	1b03      	jsle	0x5970 <_MLX16_RESET+0x50>
    596a:	42e9      	mov	Cx, AL
    596c:	4426      	asl	Y
    596e:	1ffe      	djnz	Cx, 0x596c <_MLX16_RESET+0x4c>
    5970:	ec7d      	cmp	Y, #125
    5972:	1c01      	jnc	0x5976 <_MLX16_RESET+0x56>
    5974:	07ff      	jmp	0x5974 <_MLX16_RESET+0x54>
    5976:	7eda 06d6 	lod	X, #1750
    597a:	1bff      	djnz	X, 0x597a <_MLX16_RESET+0x5a>
    597c:	72da 6301 	lod	A, #25345
    5980:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
    5982:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    5984:	b6da 6000 	and	A, #24576
    5988:	1d76      	jne	0x5976 <_MLX16_RESET+0x56>
    598a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    598e:	b4fe      	and	A, #-2
    5990:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    5994:	07ff      	jmp	0x5994 <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    5996:	5ae3      	mov	M, Y
    5998:	5401      	ret

0000599a <_NVRAM_LoadAll>:
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
        WD_T = 0;                       /* .. acknowledge the watchdog */
    599a:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    599e:	b401      	and	A, #1
    59a0:	1908      	je	0x59b2 <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59a2:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59a4:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59a6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59a8:	b430      	and	A, #48
    59aa:	1977      	je	0x599a <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59ac:	6000      	lod	AL, #0
    59ae:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59b0:	07f4      	jmp	0x599a <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    59b2:	72da 8000 	lod	A, #32768
    59b6:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    59ba:	72da 8001 	lod	A, #32769
    59be:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59c2:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59c6:	b401      	and	A, #1
    59c8:	1908      	je	0x59da <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59ca:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59cc:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59ce:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59d0:	b430      	and	A, #48
    59d2:	1977      	je	0x59c2 <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59d4:	6000      	lod	AL, #0
    59d6:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59d8:	07f4      	jmp	0x59c2 <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    59da:	7000      	lod	A, #0
    59dc:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    59e0:	7001      	lod	A, #1
    59e2:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59e6:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59ea:	b401      	and	A, #1
    59ec:	1908      	je	0x59fe <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59ee:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59f0:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59f2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59f4:	b430      	and	A, #48
    59f6:	1977      	je	0x59e6 <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59f8:	6000      	lod	AL, #0
    59fa:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59fc:	07f4      	jmp	0x59e6 <_NVRAM_LoadAll+0x4c>
    59fe:	5401      	ret

00005a00 <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    5a00:	7ee2      	lod	X, A
    5a02:	b6da 7fff 	and	A, #32767
    5a06:	ac01      	cmp	A, #1
    5a08:	1906      	je	0x5a16 <_NVRAM_SavePage+0x16>
    5a0a:	1803      	jc	0x5a12 <_NVRAM_SavePage+0x12>
    5a0c:	ac02      	cmp	A, #2
    5a0e:	1905      	je	0x5a1a <_NVRAM_SavePage+0x1a>
    5a10:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    5a12:	7810      	lod	Y, #16
            break;
    5a14:	0004      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    5a16:	7818      	lod	Y, #24
            break;
    5a18:	0002      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    5a1a:	7ada 8400 	lod	Y, #33792
    5a1e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a22:	b401      	and	A, #1
    5a24:	1908      	je	0x5a36 <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a26:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5a28:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a2a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a2c:	b430      	and	A, #48
    5a2e:	1977      	je	0x5a1e <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a30:	6000      	lod	AL, #0
    5a32:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a34:	07f4      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    5a36:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    5a3a:	e403      	or	Y, #3
    5a3c:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    5a40:	2c00      	cmp	X, #0
    5a42:	1a8c      	jsl	0x5a5c <_NVRAM_SavePage+0x5c>
    5a44:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a48:	b401      	and	A, #1
    5a4a:	1908      	je	0x5a5c <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a4c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5a4e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a50:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a52:	b430      	and	A, #48
    5a54:	1977      	je	0x5a44 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a56:	6000      	lod	AL, #0
    5a58:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a5a:	07f4      	jmp	0x5a44 <_NVRAM_SavePage+0x44>
    5a5c:	5401      	ret

00005a5e <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    5a5e:	7ae2      	lod	Y, A
    5a60:	6203      	lod	AL, [S-4]
    5a62:	5cf2      	usex	A
    5a64:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    5a66:	72e6      	lod	A, Y
    5a68:	b401      	and	A, #1
    5a6a:	1908      	je	0x5a7c <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    5a6c:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a6e:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    5a70:	b6da 00ff 	and	A, #255
    5a74:	36da 00ff 	and	X, #255
    5a78:	7eec      	swap	X
    5a7a:	0003      	jmp	0x5a82 <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a7c:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    5a7e:	b6da ff00 	and	A, #65280
    5a82:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    5a84:	52f0      	mov	[Y], A
    5a86:	5401      	ret

00005a88 <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    5a88:	7000      	lod	A, #0
    5a8a:	17ba      	call	0x5a00 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    5a8c:	7001      	lod	A, #1
    5a8e:	17b8      	call	0x5a00 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    5a90:	7002      	lod	A, #2
    5a92:	17b6      	call	0x5a00 <_NVRAM_SavePage>
    5a94:	5401      	ret

00005a96 <_ml_ReleaseBuffer>:
    5a96:	602f      	lod	AL, #47
    5a98:	0033      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005a9a <_ml_ReleaseBufferProg>:
    5a9a:	9401      	and	AL, #1
    5a9c:	44a0      	asl	AL, #2
    5a9e:	44a0      	asl	AL, #2
    5aa0:	840f      	or	AL, #15
    5aa2:	002e      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005aa4 <_ml_DataReady>:
    5aa4:	6ae0      	lod	AH, AL
    5aa6:	6015      	lod	AL, #21
    5aa8:	7eda 0008 	lod	X, #8
    5aac:	7ada 00cc 	lod	Y, #204
    5ab0:	54c6      	movsw	[X++], [Y++]
    5ab2:	54c6      	movsw	[X++], [Y++]
    5ab4:	54c6      	movsw	[X++], [Y++]
    5ab6:	54c6      	movsw	[X++], [Y++]
    5ab8:	0023      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005aba <_ml_AssignFrameToMessageID>:
    5aba:	6a03      	lod	AH, [S-4]
    5abc:	d43f      	and	AH, #63
    5abe:	0004      	jmp	0x5ac8 <_ml_EnableMessage+0x4>

00005ac0 <_ml_DisableMessage>:
    5ac0:	6802      	lod	AH, #2
    5ac2:	0001      	jmp	0x5ac6 <_ml_EnableMessage+0x2>

00005ac4 <_ml_EnableMessage>:
    5ac4:	6803      	lod	AH, #3
    5ac6:	44d4      	rr	AH, #2
    5ac8:	44a0      	asl	AL, #2
    5aca:	44a0      	asl	AL, #2
    5acc:	8406      	or	AL, #6
    5ace:	0018      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ad0 <_ml_AutoAddressingConfig>:
    5ad0:	44a0      	asl	AL, #2
    5ad2:	44a0      	asl	AL, #2
    5ad4:	840d      	or	AL, #13
    5ad6:	0014      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ad8 <_ml_SetSlewRate>:
    5ad8:	44a2      	asl	A, #2
    5ada:	44a2      	asl	A, #2
    5adc:	a407      	or	A, #7
    5ade:	0010      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ae0 <_ml_SetOptions>:
    5ae0:	6a03      	lod	AH, [S-4]
    5ae2:	44a4      	asl	AH, #2
    5ae4:	86e4      	or	AL, AH
    5ae6:	44a0      	asl	AL, #2
    5ae8:	44a0      	asl	AL, #2
    5aea:	840b      	or	AL, #11
    5aec:	c607      	or	AH, [S-8]
    5aee:	44a4      	asl	AH, #2
    5af0:	c605      	or	AH, [S-6]
    5af2:	dc01      	xor	AH, #1
    5af4:	0005      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005af6 <_ml_DiscardFrame>:
    5af6:	6005      	lod	AL, #5
    5af8:	0003      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005afa <_ml_ContFrame>:
    5afa:	6ae0      	lod	AH, AL
    5afc:	6025      	lod	AL, #37
    5afe:	0000      	nop
    5b00:	54e2      	mov	Cx, #2
    5b02:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    5b06:	7ae2      	lod	Y, A
    5b08:	6041      	lod	AL, #65
    5b0a:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5b0e:	7eda 03e8 	lod	X, #1000
    5b12:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5b16:	9402      	and	AL, #2
    5b18:	1d03      	jne	0x5b20 <_ml_ContFrame+0x26>
    5b1a:	1bfb      	djnz	X, 0x5b12 <_ml_ContFrame+0x18>
    5b1c:	7002      	lod	A, #2
    5b1e:	5401      	ret
    5b20:	7ee6      	lod	X, Y
    5b22:	340f      	and	X, #15
    5b24:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b28:	6800      	lod	AH, #0
    5b2a:	aeee      	cmp	A, X
    5b2c:	1d02      	jne	0x5b32 <_ml_ContFrame+0x38>
    5b2e:	7000      	lod	A, #0
    5b30:	5401      	ret
    5b32:	72e6      	lod	A, Y
    5b34:	1fe6      	djnz	Cx, 0x5b02 <_ml_ContFrame+0x8>
    5b36:	7001      	lod	A, #1
    5b38:	5401      	ret

00005b3a <_ml_LinModuleVersion>:
    5b3a:	602a      	lod	AL, #42
    5b3c:	17e1      	call	0x5b00 <_ml_ContFrame+0x6>
    5b3e:	ac00      	cmp	A, #0
    5b40:	1d11      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b42:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b46:	940f      	and	AL, #15
    5b48:	8c0a      	cmp	AL, #10
    5b4a:	1d0c      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b4c:	66e4      	lod	YL, AH
    5b4e:	601a      	lod	AL, #26
    5b50:	17d7      	call	0x5b00 <_ml_ContFrame+0x6>
    5b52:	ac00      	cmp	A, #0
    5b54:	1d07      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b56:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b5a:	940f      	and	AL, #15
    5b5c:	8c0a      	cmp	AL, #10
    5b5e:	1d02      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b60:	62e8      	lod	AL, YL
    5b62:	5401      	ret
    5b64:	7000      	lod	A, #0
    5b66:	5401      	ret

00005b68 <_ml_GetState>:
    5b68:	44a2      	asl	A, #2
    5b6a:	44a2      	asl	A, #2
    5b6c:	a40c      	or	A, #12
    5b6e:	17c8      	call	0x5b00 <_ml_ContFrame+0x6>
    5b70:	ac00      	cmp	A, #0
    5b72:	1d0b      	jne	0x5b8a <_ml_GetState+0x22>
    5b74:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b78:	8c0c      	cmp	AL, #12
    5b7a:	1d07      	jne	0x5b8a <_ml_GetState+0x22>
    5b7c:	62e4      	lod	AL, AH
    5b7e:	44f4      	asr	AH, #2
    5b80:	44f4      	asr	AH, #2
    5b82:	4ad8 3003 	mov	0x330 <_LinStatus>, AH
    5b86:	b40f      	and	A, #15
    5b88:	5401      	ret
    5b8a:	70ff      	lod	A, #-1
    5b8c:	5401      	ret

00005b8e <_ml_SetBaudRate>:
    5b8e:	44a0      	asl	AL, #2
    5b90:	44a0      	asl	AL, #2
    5b92:	8402      	or	AL, #2
    5b94:	7a03      	lod	Y, [S-4]
    5b96:	6ae8      	lod	AH, YL
    5b98:	07b3      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005b9a <_ml_SetAutoBaudRateMode>:
    5b9a:	6ae0      	lod	AH, AL
    5b9c:	6002      	lod	AL, #2
    5b9e:	84e0      	or	AL, #-32
    5ba0:	07af      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ba2 <_ml_Connect>:
    5ba2:	6002      	lod	AL, #2
    5ba4:	0008      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005ba6 <_ml_Disconnect>:
    5ba6:	6001      	lod	AL, #1
    5ba8:	0006      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005baa <_ml_SwitchToFast>:
    5baa:	600f      	lod	AL, #15
    5bac:	0004      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005bae <_ml_WakeUp>:
    5bae:	6008      	lod	AL, #8
    5bb0:	0002      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005bb2 <_ml_GotoSleep>:
    5bb2:	6004      	lod	AL, #4
    5bb4:	0000      	nop
    5bb6:	44a0      	asl	AL, #2
    5bb8:	44a0      	asl	AL, #2
    5bba:	8401      	or	AL, #1
    5bbc:	07a1      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005bbe <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    5bbe:	60aa      	lod	AL, #-86
    5bc0:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    5bc4:	7104      	lod	A, dp:0x4 <_LinMess>
    5bc6:	51d6      	mov	dp:0xd6 <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    5bc8:	7810      	lod	Y, #16
    5bca:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bce:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    5bd0:	ac03      	cmp	A, #3
    5bd2:	1d09      	jne	0x5be6 <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    5bd4:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    5bd6:	51cc      	mov	dp:0xcc <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    5bd8:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    5bda:	59ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    5bdc:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    5bde:	51d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    5be0:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    5be2:	59d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    5be4:	1758      	call	0x5a96 <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    5be6:	6042      	lod	AL, #66
    5be8:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5bec:	5401      	ret

00005bee <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    5bee:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bf0:	79d6      	lod	Y, dp:0xd6 <_LinMessage>
    5bf2:	72e6      	lod	A, Y
    5bf4:	b40f      	and	A, #15
    5bf6:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    5bf8:	ac07      	cmp	A, #7
    5bfa:	1d07      	jne	0x5c0a <_ml_ProccessLinEvent+0x1c>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    5bfc:	44b6      	lsr	Y, #2
    5bfe:	44b6      	lsr	Y, #2
    5c00:	72e6      	lod	A, Y
    5c02:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    5c04:	82db 7c36 	callf	0x7c36 <_mlu_AutoAddressingStep>
    5c08:	00c7      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    5c0a:	72e6      	lod	A, Y
    5c0c:	6000      	lod	AL, #0
    5c0e:	72e4      	swap	A
    5c10:	b43f      	and	A, #63
    5c12:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    5c14:	62d8 00d8 	lod	AL, 0xd8 <_ml_driver_mode>
    5c18:	8c55      	cmp	AL, #85
    5c1a:	1d01      	jne	0x5c1e <_ml_ProccessLinEvent+0x30>
    5c1c:	009d      	jmp	0x5d58 <_ml_ProccessLinEvent+0x16a>
        if (LDR_GetState() == 0) {
    5c1e:	82db 6646 	callf	0x6646 <_LDR_GetState>
    5c22:	8c00      	cmp	AL, #0
    5c24:	1901      	je	0x5c28 <_ml_ProccessLinEvent+0x3a>
    5c26:	006a      	jmp	0x5cfc <_ml_ProccessLinEvent+0x10e>
#endif
            switch(LinCommand) {
    5c28:	7203      	lod	A, [S-4]
    5c2a:	a0ff      	add	A, #-1
    5c2c:	ac04      	cmp	A, #4
    5c2e:	1a01      	jule	0x5c32 <_ml_ProccessLinEvent+0x44>
    5c30:	00b3      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5c32:	4422      	asl	A
    5c34:	7ae2      	lod	Y, A
    5c36:	e2da 6be0 	add	Y, #27616
    5c3a:	72f0      	lod	A, [Y]
    5c3c:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    5c3e:	79d6      	lod	Y, dp:0xd6 <_LinMessage>
    5c40:	72e6      	lod	A, Y
    5c42:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    5c46:	ac40      	cmp	A, #64
    5c48:	1901      	je	0x5c4c <_ml_ProccessLinEvent+0x5e>
    5c4a:	00a6      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    5c4c:	44c6      	rl	Y, #2
    5c4e:	44c6      	rl	Y, #2
    5c50:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    5c52:	72e6      	lod	A, Y
    5c54:	82db 7bb4 	callf	0x7bb4 <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    5c58:	009f      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    5c5a:	79d6      	lod	Y, dp:0xd6 <_LinMessage>
    5c5c:	72e6      	lod	A, Y
    5c5e:	44b2      	lsr	A, #2
    5c60:	44b2      	lsr	A, #2
    5c62:	b40f      	and	A, #15
    5c64:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    5c66:	ac05      	cmp	A, #5
    5c68:	1d0e      	jne	0x5c86 <_ml_ProccessLinEvent+0x98>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    5c6a:	6400      	lod	YL, #0
    5c6c:	7ae8      	swap	Y
    5c6e:	72e6      	lod	A, Y
    5c70:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    5c72:	44b6      	lsr	Y, #2
    5c74:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    5c76:	80ff      	add	AL, #-1
    5c78:	8c08      	cmp	AL, #8
    5c7a:	1a17      	jule	0x5caa <_ml_ProccessLinEvent+0xbc>
    5c7c:	62e8      	lod	AL, YL
    5c7e:	8c0f      	cmp	AL, #15
    5c80:	1914      	je	0x5caa <_ml_ProccessLinEvent+0xbc>
                            Error = ml_erStopBitTX;
    5c82:	7c10      	lod	X, #16
    5c84:	0012      	jmp	0x5caa <_ml_ProccessLinEvent+0xbc>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    5c86:	ac0c      	cmp	A, #12
    5c88:	1d05      	jne	0x5c94 <_ml_ProccessLinEvent+0xa6>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    5c8a:	44c6      	rl	Y, #2
    5c8c:	44c6      	rl	Y, #2
    5c8e:	f40f      	and	Y, #15
                        if(nbytes == 0)
    5c90:	1d0c      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    5c92:	0082      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    5c94:	ac02      	cmp	A, #2
    5c96:	1d09      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    5c98:	6400      	lod	YL, #0
    5c9a:	7ae8      	swap	Y
    5c9c:	72e6      	lod	A, Y
    5c9e:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    5ca0:	8c02      	cmp	AL, #2
    5ca2:	1d03      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    5ca4:	1780      	call	0x5ba6 <_ml_Disconnect>
                            (void)ml_Connect();
    5ca6:	177d      	call	0x5ba2 <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    5ca8:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    5caa:	72ee      	lod	A, X
    5cac:	82db 7b9e 	callf	0x7b9e <_mlu_ErrorDetected>
                    break;
    5cb0:	0073      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5cb2:	7104      	lod	A, dp:0x4 <_LinMess>
    5cb4:	52d8 014e 	mov	0x14e <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cb8:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cba:	42d8 0150 	mov	0x150 <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    5cbe:	6201      	lod	AL, [S-2]
    5cc0:	8c10      	cmp	AL, #16
    5cc2:	1902      	je	0x5cc8 <_ml_ProccessLinEvent+0xda>
                        mlu_MessageReceived(LinID); /* notify application */
    5cc4:	7201      	lod	A, [S-2]
    5cc6:	000a      	jmp	0x5cdc <_ml_ProccessLinEvent+0xee>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    5cc8:	54ca 0000 	pushw	#0
    5ccc:	72da 00cc 	lod	A, #204
    5cd0:	10ce      	call	0x5e6e <_ldr_isReadByIdMessage>
    5cd2:	5c01      	dec	S, #2
    5cd4:	8c00      	cmp	AL, #0
    5cd6:	1901      	je	0x5cda <_ml_ProccessLinEvent+0xec>
    5cd8:	0034      	jmp	0x5d42 <_ml_ProccessLinEvent+0x154>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    5cda:	7010      	lod	A, #16
    5cdc:	82db 7bcc 	callf	0x7bcc <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    5ce0:	005b      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5ce2:	7104      	lod	A, dp:0x4 <_LinMess>
    5ce4:	52d8 014e 	mov	0x14e <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5ce8:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cea:	42d8 0150 	mov	0x150 <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    5cee:	7201      	lod	A, [S-2]
    5cf0:	82db 7b3a 	callf	0x7b3a <_mlu_DataRequest>
                    break;
    5cf4:	0051      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    5cf6:	82db 7b90 	callf	0x7b90 <_mlu_DataTransmitted>
                    break;
    5cfa:	004e      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    5cfc:	7203      	lod	A, [S-4]
    5cfe:	ac03      	cmp	A, #3
    5d00:	190d      	je	0x5d1c <_ml_ProccessLinEvent+0x12e>
    5d02:	1e03      	jug	0x5d0a <_ml_ProccessLinEvent+0x11c>
    5d04:	ac02      	cmp	A, #2
    5d06:	1905      	je	0x5d12 <_ml_ProccessLinEvent+0x124>
    5d08:	0047      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d0a:	7203      	lod	A, [S-4]
    5d0c:	ac04      	cmp	A, #4
    5d0e:	191d      	je	0x5d4a <_ml_ProccessLinEvent+0x15c>
    5d10:	0043      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d12:	61d6      	lod	AL, dp:0xd6 <_LinMessage>
    5d14:	44b2      	lsr	A, #2
    5d16:	44b2      	lsr	A, #2
    5d18:	b40f      	and	A, #15
    5d1a:	002f      	jmp	0x5d7a <_ml_ProccessLinEvent+0x18c>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d1c:	7104      	lod	A, dp:0x4 <_LinMess>
    5d1e:	52d8 014e 	mov	0x14e <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d22:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d24:	42d8 0150 	mov	0x150 <_LINBaud>, AL

                    if (LinID == D_DIA) {
    5d28:	6201      	lod	AL, [S-2]
    5d2a:	8c10      	cmp	AL, #16
    5d2c:	1901      	je	0x5d30 <_ml_ProccessLinEvent+0x142>
    5d2e:	0034      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    5d30:	54ca 0001 	pushw	#1
    5d34:	72da 00cc 	lod	A, #204
    5d38:	109a      	call	0x5e6e <_ldr_isReadByIdMessage>
    5d3a:	5c01      	dec	S, #2
    5d3c:	8c00      	cmp	AL, #0
    5d3e:	1d01      	jne	0x5d42 <_ml_ProccessLinEvent+0x154>
    5d40:	002b      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    5d42:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x3>
    5d44:	5cf2      	usex	A
    5d46:	1207      	call	0x6156 <_ml_ldr_ReadByIdMessage>
    5d48:	0027      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d4a:	7104      	lod	A, dp:0x4 <_LinMess>
    5d4c:	52d8 014e 	mov	0x14e <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d50:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d52:	42d8 0150 	mov	0x150 <_LINBaud>, AL
    5d56:	001d      	jmp	0x5d92 <_ml_ProccessLinEvent+0x1a4>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    5d58:	7203      	lod	A, [S-4]
    5d5a:	ac03      	cmp	A, #3
    5d5c:	1910      	je	0x5d7e <_ml_ProccessLinEvent+0x190>
    5d5e:	1e03      	jug	0x5d66 <_ml_ProccessLinEvent+0x178>
    5d60:	ac02      	cmp	A, #2
    5d62:	1907      	je	0x5d72 <_ml_ProccessLinEvent+0x184>
    5d64:	0019      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d66:	7203      	lod	A, [S-4]
    5d68:	ac04      	cmp	A, #4
    5d6a:	1913      	je	0x5d92 <_ml_ProccessLinEvent+0x1a4>
    5d6c:	ac05      	cmp	A, #5
    5d6e:	1913      	je	0x5d96 <_ml_ProccessLinEvent+0x1a8>
    5d70:	0013      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d72:	44b6      	lsr	Y, #2
    5d74:	44b6      	lsr	Y, #2
    5d76:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    5d78:	72e6      	lod	A, Y
    5d7a:	1155      	call	0x6026 <_ml_ldr_ErrorDetected>
                 break;
    5d7c:	000d      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    5d7e:	6201      	lod	AL, [S-2]
    5d80:	8c10      	cmp	AL, #16
    5d82:	1d0a      	jne	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d84:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer>
    5d86:	8dd4      	cmp	AL, dp:0xd4 <_LIN_nad>
    5d88:	1902      	je	0x5d8e <_ml_ProccessLinEvent+0x1a0>
    5d8a:	8c7f      	cmp	AL, #127
    5d8c:	1d05      	jne	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    5d8e:	1231      	call	0x61f2 <_ml_DiagReceived>
    5d90:	0003      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    5d92:	16b1      	call	0x5af6 <_ml_DiscardFrame>
                 break;
    5d94:	0001      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    5d96:	11fb      	call	0x618e <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    5d98:	60ab      	lod	AL, #-85
    5d9a:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    5d9e:	5405      	ret	#6

00005da0 <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    5da0:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5da4:	7ada 0010 	lod	Y, #16
    5da8:	7eda 72ef 	lod	X, #29423
    5dac:	5ef0      	mov	[Y], X
    5dae:	7eda e861 	lod	X, #59489
    5db2:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    5db4:	41d4      	mov	dp:0xd4 <_LIN_nad>, AL
    return ML_SUCCESS;
}
    5db6:	7000      	lod	A, #0
    5db8:	5401      	ret

00005dba <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    5dba:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5dbc:	5cf2      	usex	A
}
    5dbe:	5401      	ret

00005dc0 <_linit>:
 * This function is called whenever an EVENT interrupt from the LIN task (Mlx4)
 * occurs
 */
void __interrupt__ ml_LinInterruptHandler(void);
__MLX_TEXT__  void ml_LinInterruptHandler(void)
{
    5dc0:	52df      	push	A
    5dc2:	5edf      	push	X
    5dc4:	5adf      	push	Y
    5dc6:	4c83      	push	D
    ml_GetLinEventData();
    5dc8:	16fa      	call	0x5bbe <_ml_GetLinEventData>
    ml_ProccessLinEvent();
    5dca:	1711      	call	0x5bee <_ml_ProccessLinEvent>
    5dcc:	4cc3      	pop	D
    5dce:	7acf      	pop	Y
    5dd0:	7ecf      	pop	X
    5dd2:	72cf      	pop	A
    5dd4:	4407      	mov	R, #0
    5dd6:	72cb      	pop	M
    5dd8:	5401      	ret

00005dda <_ml_GetBaudRate>:
 *
 *  With this max presc 8 the limit for PLL is:
 *  PLL_max = 2^(pres+1) * div * baud = 2^9 * 100 * 1000 = 51.2 MHz
 */
__MLX_TEXT__ ml_uint16 ml_GetBaudRate (void)
{
    5dda:	5803      	inc	S, #4
#if (FPLL < 50000)

    uint8_t presc = (uint8_t)((LINPresc & 0x00F0) >> 4);  /* Prescaller |XXXX|XXXX|PRES|XXXX| */
    5ddc:	66d8 014e 	lod	YL, 0x14e <_LINPresc>
    5de0:	f6da 00f0 	and	Y, #240
    5de4:	44b6      	lsr	Y, #2
    5de6:	44b6      	lsr	Y, #2
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    5de8:	4cc2 9f80 	mov	D, #14000000
    5dec:	00d5 
    5dee:	62d8 0150 	lod	AL, 0x150 <_LINBaud>
    5df2:	5cf2      	usex	A
    5df4:	ec00      	cmp	Y, #0
    5df6:	1b03      	jsle	0x5dfe <_ml_GetBaudRate+0x24>
    5df8:	46e9      	mov	Cx, YL
    5dfa:	4422      	asl	A
    5dfc:	1ffe      	djnz	Cx, 0x5dfa <_ml_GetBaudRate+0x20>
    5dfe:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    5e00:	4c80      	mov	YA, D
    5e02:	7e03      	lod	X, [S-4]
    5e04:	4c63      	divu	YA, X
    5e06:	4c63      	divu	YA, X
    5e08:	5203      	mov	[S-4], A

#else
    #warning "Function can't work with FPLL > 50MHz (overflow in 2nd argument of divU16_U32byU16)"
    return 0U;
#endif
}
    5e0a:	5405      	ret	#6

00005e0c <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    5e0c:	82db 6646 	callf	0x6646 <_LDR_GetState>
    5e10:	8c00      	cmp	AL, #0
    5e12:	1d0a      	jne	0x5e28 <_ml_InitLinModule+0x1c>
    5e14:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    5e18:	aeda 3212 	cmp	A, #12818
    5e1c:	1905      	je	0x5e28 <_ml_InitLinModule+0x1c>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    5e1e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    5e22:	a410      	or	A, #16
    5e24:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5e28:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5e2a:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5e2c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5e2e:	b430      	and	A, #48
    5e30:	1902      	je	0x5e36 <_ml_InitLinModule+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5e32:	6000      	lod	AL, #0
    5e34:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    5e36:	6084      	lod	AL, #-124
    5e38:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    5e3c:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5e40:	b404      	and	A, #4
    5e42:	197c      	je	0x5e3c <_ml_InitLinModule+0x30>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    5e44:	60ab      	lod	AL, #-85
    5e46:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    5e4a:	6000      	lod	AL, #0
    5e4c:	42d8 00d8 	mov	0xd8 <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    5e50:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    5e54:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    5e58:	4cb2 72ef 	cmp	YA, #-396266769
    5e5c:	e861 
    5e5e:	1d03      	jne	0x5e66 <_ml_InitLinModule+0x5a>
    {
        LIN_nad = stFixedRamNAD.nad;
    5e60:	62d8 0014 	lod	AL, 0x14 <__dp_noinit_size+0x4>
    5e64:	0001      	jmp	0x5e68 <_ml_InitLinModule+0x5c>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    5e66:	6001      	lod	AL, #1
    5e68:	41d4      	mov	dp:0xd4 <_LIN_nad>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    5e6a:	7000      	lod	A, #0
    5e6c:	5401      	ret

00005e6e <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    5e6e:	5801      	inc	S, #2
    5e70:	7ae2      	lod	Y, A
    5e72:	6205      	lod	AL, [S-6]
    5e74:	5cf2      	usex	A
    5e76:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    5e78:	7ef0      	lod	X, [Y]
    5e7a:	2eda 067f 	cmp	X, #1663
    5e7e:	1907      	je	0x5e8e <_ldr_isReadByIdMessage+0x20>
    5e80:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5e82:	b6da 06ff 	and	A, #1791
    5e86:	a6da 0600 	or	A, #1536
    5e8a:	2ee2      	cmp	X, A
    5e8c:	1d15      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5e8e:	72f2      	lod	A, [Y+2]
    5e90:	8cb2      	cmp	AL, #-78
    5e92:	1d12      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5e94:	7ef4      	lod	X, [Y+4]
    5e96:	2c13      	cmp	X, #19
    5e98:	1d04      	jne	0x5ea2 <_ldr_isReadByIdMessage+0x34>
    5e9a:	72f6      	lod	A, [Y+6]
    5e9c:	aeda cafe 	cmp	A, #51966
    5ea0:	1909      	je	0x5eb4 <_ldr_isReadByIdMessage+0x46>
    5ea2:	6201      	lod	AL, [S-2]
    5ea4:	8c01      	cmp	AL, #1
    5ea6:	1d08      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5ea8:	2eda 7fff 	cmp	X, #32767
    5eac:	1d05      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5eae:	72f6      	lod	A, [Y+6]
    5eb0:	acff      	cmp	A, #-1
    5eb2:	1d02      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    5eb4:	7001      	lod	A, #1
    5eb6:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    5eb8:	7000      	lod	A, #0
    }
}
    5eba:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    5ebc:	5801      	inc	S, #2
    5ebe:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    5ec0:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5ec2:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    5ec4:	6003      	lod	AL, #3
    5ec6:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    5ec8:	607f      	lod	AL, #127
    5eca:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    5ecc:	13bc      	call	0x6646 <_LDR_GetState>
    5ece:	8480      	or	AL, #-128
    5ed0:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    5ed2:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x1>
    5ed4:	8601      	or	AL, [S-2]
    5ed6:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    5ed8:	60ff      	lod	AL, #-1
    5eda:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    5edc:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL
    LinFrameDataBuffer[7] = 0xFF;
    5ede:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    5ee0:	6000      	lod	AL, #0
    5ee2:	41d9      	mov	dp:0xd9 <_ml_driver_mode+0x1>, AL
    5ee4:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    5ee6:	5801      	inc	S, #2
    5ee8:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    5eea:	aeda 00f0 	cmp	A, #240
    5eee:	1d02      	jne	0x5ef4 <_ldr_isReadByIdMessage+0x86>
    5ef0:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x1>
    5ef2:	1904      	je	0x5efc <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    5ef4:	72e6      	lod	A, Y
    5ef6:	17e2      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    5ef8:	7000      	lod	A, #0
    5efa:	000e      	jmp	0x5f18 <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    5efc:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5efe:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    5f00:	6002      	lod	AL, #2
    5f02:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    5f04:	60f4      	lod	AL, #-12
    5f06:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    5f08:	139e      	call	0x6646 <_LDR_GetState>
    5f0a:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    5f0c:	60ff      	lod	AL, #-1
    5f0e:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    5f10:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    5f12:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL
        LinFrameDataBuffer[7] = 0xFF;
    5f14:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL
        blReturn = ML_TRUE;
    5f16:	7001      	lod	A, #1
    5f18:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    5f1a:	7000      	lod	A, #0
    5f1c:	15c3      	call	0x5aa4 <_ml_DataReady>

    return ( blReturn );
}
    5f1e:	7201      	lod	A, [S-2]
    5f20:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    5f22:	5807      	inc	S, #8
    5f24:	660b      	lod	YL, [S-12]
    5f26:	5cf6      	usex	Y
    5f28:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    5f2a:	79e0      	lod	Y, dp:0xe0 <_ml_driver_mode+0x8>
    5f2c:	e1e8      	add	Y, dp:0xe8 <_ml_driver_mode+0x10>
    5f2e:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    5f30:	7ae2      	lod	Y, A
    5f32:	e2da 00cc 	add	Y, #204


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    5f36:	71e8      	lod	A, dp:0xe8 <_ml_driver_mode+0x10>
    5f38:	5205      	mov	[S-6], A
    5f3a:	72e6      	lod	A, Y
    5f3c:	a001      	add	A, #1
    5f3e:	5203      	mov	[S-4], A
    5f40:	20ff      	add	X, #-1
    5f42:	5e01      	mov	[S-2], X
    5f44:	7e05      	lod	X, [S-6]
    5f46:	2de4      	cmp	X, dp:0xe4 <_ml_driver_mode+0xc>
    5f48:	1c04      	jnc	0x5f52 <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    5f4a:	7e07      	lod	X, [S-8]
    5f4c:	62de      	lod	AL, [X++]
    5f4e:	5e07      	mov	[S-8], X
    5f50:	0001      	jmp	0x5f54 <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    5f52:	60ff      	lod	AL, #-1
    5f54:	42f0      	mov	[Y], AL
    5f56:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    5f58:	7205      	lod	A, [S-6]
    5f5a:	a001      	add	A, #1
    5f5c:	51e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    5f5e:	7e01      	lod	X, [S-2]
    5f60:	1d6a      	jne	0x5f36 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    5f62:	ade4      	cmp	A, dp:0xe4 <_ml_driver_mode+0xc>
    5f64:	1802      	jc	0x5f6a <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    5f66:	7000      	lod	A, #0
    5f68:	15c8      	call	0x5afa <_ml_ContFrame>
    5f6a:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    5f6c:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    5f6e:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x1>
    5f70:	1904      	je	0x5f7a <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5f72:	72da 00f0 	lod	A, #240
    5f76:	17a2      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    5f78:	0039      	jmp	0x5fec <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    5f7a:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xc>
    5f7c:	7ae2      	lod	Y, A
    5f7e:	e002      	add	Y, #2
    5f80:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    5f82:	ac04      	cmp	A, #4
    5f84:	1a17      	jule	0x5fb4 <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    5f86:	7001      	lod	A, #1
    5f88:	15b8      	call	0x5afa <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    5f8a:	6000      	lod	AL, #0
    5f8c:	41ea      	mov	dp:0xea <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    5f8e:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5f90:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    5f92:	7201      	lod	A, [S-2]
    5f94:	b6da 0f00 	and	A, #3840
    5f98:	6000      	lod	AL, #0
    5f9a:	72e4      	swap	A
    5f9c:	8410      	or	AL, #16
    5f9e:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    5fa0:	6601      	lod	YL, [S-2]
    5fa2:	45ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    5fa4:	60f4      	lod	AL, #-12
    5fa6:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    5fa8:	134e      	call	0x6646 <_LDR_GetState>
    5faa:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    5fac:	54ca 0003 	pushw	#3
    5fb0:	7005      	lod	A, #5
    5fb2:	001a      	jmp	0x5fe8 <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    5fb4:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    5fb6:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    5fb8:	6201      	lod	AL, [S-2]
    5fba:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    5fbc:	60f4      	lod	AL, #-12
    5fbe:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    5fc0:	1342      	call	0x6646 <_LDR_GetState>
    5fc2:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    5fc4:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    5fc6:	aeda bf66 	cmp	A, #48998
    5fca:	1d0b      	jne	0x5fe2 <_ldr_isReadByIdMessage+0x174>
    5fcc:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xc>
    5fce:	ac02      	cmp	A, #2
    5fd0:	1d08      	jne	0x5fe2 <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    5fd2:	1339      	call	0x6646 <_LDR_GetState>
    5fd4:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    5fd6:	6400      	lod	YL, #0
    5fd8:	45d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    5fda:	60ff      	lod	AL, #-1
    5fdc:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    5fde:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL
    5fe0:	0005      	jmp	0x5fec <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    5fe2:	54ca 0004 	pushw	#4
    5fe6:	7004      	lod	A, #4
    5fe8:	179c      	call	0x5f22 <_ldr_isReadByIdMessage+0xb4>
    5fea:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    5fec:	7000      	lod	A, #0
    5fee:	155a      	call	0x5aa4 <_ml_DataReady>
    5ff0:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    5ff2:	5801      	inc	S, #2
    5ff4:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    5ff6:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x1>
    5ff8:	1904      	je	0x6002 <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5ffa:	72da 00f0 	lod	A, #240
    5ffe:	175e      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    6000:	000f      	jmp	0x6020 <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    6002:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    6004:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    6006:	6006      	lod	AL, #6
    6008:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    600a:	60f4      	lod	AL, #-12
    600c:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    600e:	131b      	call	0x6646 <_LDR_GetState>
    6010:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    6012:	79e4      	lod	Y, dp:0xe4 <_ml_driver_mode+0xc>
    6014:	4dd0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    6016:	45d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    6018:	7201      	lod	A, [S-2]
    601a:	49d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    601c:	6201      	lod	AL, [S-2]
    601e:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    6020:	7000      	lod	A, #0
    6022:	1540      	call	0x5aa4 <_ml_DataReady>
    6024:	5403      	ret	#4

00006026 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    6026:	ac0a      	cmp	A, #10
    6028:	1901      	je	0x602c <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    602a:	41d9      	mov	dp:0xd9 <_ml_driver_mode+0x1>, AL
    602c:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    602e:	5807      	inc	S, #8
    6030:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    6032:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x1>
    6034:	1904      	je	0x603e <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    6036:	72da 00f0 	lod	A, #240
    603a:	1740      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    603c:	0040      	jmp	0x60be <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    603e:	15b3      	call	0x5ba6 <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    6040:	79e0      	lod	Y, dp:0xe0 <_ml_driver_mode+0x8>
    6042:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    6044:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    6046:	7000      	lod	A, #0
    6048:	5201      	mov	[S-2], A
    604a:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xc>
    604c:	5203      	mov	[S-4], A
    604e:	7000      	lod	A, #0
    6050:	ae03      	cmp	A, [S-4]
    6052:	1c26      	jnc	0x60a0 <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    6054:	7ae8      	swap	Y
        crc ^= *data;
    6056:	7e05      	lod	X, [S-6]
    6058:	62de      	lod	AL, [X++]
    605a:	5e05      	mov	[S-6], X
    605c:	5cf2      	usex	A
    605e:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    6060:	62e8      	lod	AL, YL
    6062:	44b0      	lsr	AL, #2
    6064:	44b0      	lsr	AL, #2
    6066:	5cf2      	usex	A
    6068:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    606a:	72e6      	lod	A, Y
    606c:	b40f      	and	A, #15
    606e:	44d2      	rr	A, #2
    6070:	44d2      	rr	A, #2
    6072:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    6074:	72e6      	lod	A, Y
    6076:	b6da 00ff 	and	A, #255
    607a:	44a2      	asl	A, #2
    607c:	44a2      	asl	A, #2
    607e:	4422      	asl	A
    6080:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    6082:	7201      	lod	A, [S-2]
    6084:	b6da 0fff 	and	A, #4095
    6088:	1d07      	jne	0x6098 <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    608a:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    608c:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    608e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6090:	b430      	and	A, #48
    6092:	1902      	je	0x6098 <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6094:	6000      	lod	AL, #0
    6096:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    6098:	7201      	lod	A, [S-2]
    609a:	a001      	add	A, #1
    609c:	5201      	mov	[S-2], A
    609e:	07d8      	jmp	0x6050 <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    60a0:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    60a2:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    60a4:	6006      	lod	AL, #6
    60a6:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    60a8:	60f4      	lod	AL, #-12
    60aa:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    60ac:	60ff      	lod	AL, #-1
    60ae:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    60b0:	4dd0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    60b2:	45d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    60b4:	7207      	lod	A, [S-8]
    60b6:	49d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    60b8:	6607      	lod	YL, [S-8]
    60ba:	45d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    60bc:	1572      	call	0x5ba2 <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    60be:	7000      	lod	A, #0
    60c0:	14f1      	call	0x5aa4 <_ml_DataReady>
    60c2:	5409      	ret	#10

000060c4 <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    60c4:	5801      	inc	S, #2
    60c6:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    60c8:	12be      	call	0x6646 <_LDR_GetState>
    60ca:	8c00      	cmp	AL, #0
    60cc:	1d09      	jne	0x60e0 <_ml_ldr_SwitchToProgMode+0x1c>
    60ce:	82db 7b06 	callf	0x7b06 <_mlu_ApplicationStop>
    60d2:	8c00      	cmp	AL, #0
    60d4:	1905      	je	0x60e0 <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    60d6:	6000      	lod	AL, #0
    60d8:	41d8      	mov	dp:0xd8 <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    60da:	7000      	lod	A, #0
    60dc:	14de      	call	0x5a9a <_ml_ReleaseBufferProg>
    60de:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    60e0:	7000      	lod	A, #0
    60e2:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    60e6:	12af      	call	0x6646 <_LDR_GetState>
    60e8:	8c00      	cmp	AL, #0
    60ea:	1d0b      	jne	0x6102 <_ml_ldr_SwitchToProgMode+0x3e>
    60ec:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    60f0:	aeda 3212 	cmp	A, #12818
    60f4:	1906      	je	0x6102 <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    60f6:	14c8      	call	0x5a88 <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    60f8:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    60fc:	a410      	or	A, #16
    60fe:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    6102:	6055      	lod	AL, #85
    6104:	41d8      	mov	dp:0xd8 <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    6106:	6000      	lod	AL, #0
    6108:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    610a:	12a8      	call	0x665c <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    610c:	7001      	lod	A, #1
    610e:	14c5      	call	0x5a9a <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    6110:	6201      	lod	AL, [S-2]
    6112:	8c01      	cmp	AL, #1
    6114:	1d0c      	jne	0x612e <_ml_ldr_SwitchToProgMode+0x6a>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    6116:	72da 3212 	lod	A, #12818
    611a:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    611e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6122:	94fe      	and	AL, #-2
    6124:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    6128:	82db 5920 	callf	0x5920 <_MLX16_RESET>
            for (;;) {
    612c:	07ff      	jmp	0x612c <_ml_ldr_SwitchToProgMode+0x68>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    612e:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    6130:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    6132:	6006      	lod	AL, #6
    6134:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6136:	60f2      	lod	AL, #-14
    6138:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    613a:	4cea 0004 	movu	YA, #4
    613e:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    6140:	4cea 0401 	movu	YA, #1025
    6144:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    6146:	6000      	lod	AL, #0
    6148:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    614a:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    614c:	127c      	call	0x6646 <_LDR_GetState>
    614e:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6150:	7000      	lod	A, #0
    6152:	14a8      	call	0x5aa4 <_ml_DataReady>
    6154:	5403      	ret	#4

00006156 <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    6156:	8c33      	cmp	AL, #51
    6158:	1d03      	jne	0x6160 <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    615a:	7001      	lod	A, #1
    615c:	17b3      	call	0x60c4 <_ml_ldr_SwitchToProgMode>
    615e:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    6160:	ac00      	cmp	A, #0
    6162:	1d14      	jne	0x618c <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    6164:	7001      	lod	A, #1
    6166:	1499      	call	0x5a9a <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    6168:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    616a:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    616c:	6006      	lod	AL, #6
    616e:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6170:	60f2      	lod	AL, #-14
    6172:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    6174:	6013      	lod	AL, #19
    6176:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    6178:	6000      	lod	AL, #0
    617a:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    617c:	60fe      	lod	AL, #-2
    617e:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    6180:	60ca      	lod	AL, #-54
    6182:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    6184:	6001      	lod	AL, #1
    6186:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6188:	7000      	lod	A, #0
    618a:	148c      	call	0x5aa4 <_ml_DataReady>
    618c:	5401      	ret

0000618e <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    618e:	61eb      	lod	AL, dp:0xeb <_ml_driver_mode+0x13>
    6190:	8c03      	cmp	AL, #3
    6192:	1d15      	jne	0x61be <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    6194:	7000      	lod	A, #0
    6196:	14b1      	call	0x5afa <_ml_ContFrame>
            (void)ml_Disconnect();
    6198:	1506      	call	0x5ba6 <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    619a:	61dc      	lod	AL, dp:0xdc <_ml_driver_mode+0x4>
    619c:	5cf2      	usex	A
    619e:	1377      	call	0x688e <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    61a0:	54ca 0000 	pushw	#0
    61a4:	54ca 0001 	pushw	#1
    61a8:	54ca 0000 	pushw	#0
    61ac:	7001      	lod	A, #1
    61ae:	1498      	call	0x5ae0 <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    61b0:	7001      	lod	A, #1
    61b2:	1492      	call	0x5ad8 <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    61b4:	14fa      	call	0x5baa <_ml_SwitchToFast>
            pendingAction = 0;
    61b6:	6000      	lod	AL, #0
    61b8:	41eb      	mov	dp:0xeb <_ml_driver_mode+0x13>, AL
            break;
    61ba:	5c05      	dec	S, #6
    61bc:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    61be:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    61c0:	8c06      	cmp	AL, #6
    61c2:	1902      	je	0x61c8 <_ml_DiagRequest+0x3a>
    61c4:	8c08      	cmp	AL, #8
    61c6:	1d14      	jne	0x61f0 <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    61c8:	71e8      	lod	A, dp:0xe8 <_ml_driver_mode+0x10>
    61ca:	ade4      	cmp	A, dp:0xe4 <_ml_driver_mode+0xc>
    61cc:	1c11      	jnc	0x61f0 <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    61ce:	61ea      	lod	AL, dp:0xea <_ml_driver_mode+0x12>
    61d0:	8001      	add	AL, #1
    61d2:	66e0      	lod	YL, AL
    61d4:	41ea      	mov	dp:0xea <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    61d6:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    61d8:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    61da:	62e8      	lod	AL, YL
    61dc:	940f      	and	AL, #15
    61de:	8420      	or	AL, #32
    61e0:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    61e2:	54ca 0006 	pushw	#6
    61e6:	7002      	lod	A, #2
    61e8:	169c      	call	0x5f22 <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    61ea:	7000      	lod	A, #0
    61ec:	145b      	call	0x5aa4 <_ml_DataReady>
    61ee:	5c01      	dec	S, #2
    61f0:	5401      	ret

000061f2 <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    61f2:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    61f4:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x1>
    61f6:	5cf2      	usex	A
    61f8:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    61fa:	b6da 00f0 	and	A, #240
    61fe:	ac20      	cmp	A, #32
    6200:	1901      	je	0x6204 <_ml_DiagReceived+0x12>
    6202:	0073      	jmp	0x62ea <_ml_DiagReceived+0xf8>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    6204:	7a0b      	lod	Y, [S-12]
    6206:	f40f      	and	Y, #15
    6208:	61ea      	lod	AL, dp:0xea <_ml_driver_mode+0x12>
    620a:	4209      	mov	[S-10], AL
    620c:	b40f      	and	A, #15
    620e:	eee2      	cmp	Y, A
    6210:	1901      	je	0x6214 <_ml_DiagReceived+0x22>
    6212:	0067      	jmp	0x62e2 <_ml_DiagReceived+0xf0>
                ddFrameCounter += 1;
    6214:	6209      	lod	AL, [S-10]
    6216:	8001      	add	AL, #1
    6218:	41ea      	mov	dp:0xea <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    621a:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    621c:	8c85      	cmp	AL, #-123
    621e:	1901      	je	0x6222 <_ml_DiagReceived+0x30>
    6220:	003d      	jmp	0x629c <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6222:	7800      	lod	Y, #0
    6224:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    6226:	79e8      	lod	Y, dp:0xe8 <_ml_driver_mode+0x10>
    6228:	ede4      	cmp	Y, dp:0xe4 <_ml_driver_mode+0xc>
    622a:	1c0a      	jnc	0x6240 <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    622c:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xa>
    622e:	a2e6      	add	A, Y
    6230:	7a0d      	lod	Y, [S-14]
    6232:	e2da 00ce 	add	Y, #206
    6236:	66f0      	lod	YL, [Y]
    6238:	5cf6      	usex	Y
    623a:	5adf      	push	Y
    623c:	1246      	call	0x66ca <_Flash_PageBufferFill>
    623e:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6240:	71e8      	lod	A, dp:0xe8 <_ml_driver_mode+0x10>
    6242:	a001      	add	A, #1
    6244:	51e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6246:	7a0d      	lod	Y, [S-14]
    6248:	e001      	add	Y, #1
    624a:	5a0d      	mov	[S-14], Y
    624c:	ec05      	cmp	Y, #5
    624e:	1a6b      	jule	0x6226 <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6250:	ade4      	cmp	A, dp:0xe4 <_ml_driver_mode+0xc>
    6252:	1c01      	jnc	0x6256 <_ml_DiagReceived+0x64>
    6254:	01f7      	jmp	0x6644 <_ml_DiagReceived+0x452>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    6256:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    6258:	1308      	call	0x686a <_Flash_PageWriteFiltered>
    625a:	51de      	mov	dp:0xde <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    625c:	ac00      	cmp	A, #0
    625e:	1901      	je	0x6262 <_ml_DiagReceived+0x70>
    6260:	0042      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    6262:	71e8      	lod	A, dp:0xe8 <_ml_driver_mode+0x10>
    6264:	79e6      	lod	Y, dp:0xe6 <_ml_driver_mode+0xe>
    6266:	aee6      	cmp	A, Y
    6268:	1c15      	jnc	0x6294 <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    626a:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    626c:	7ee2      	lod	X, A
    626e:	22da 0080 	add	X, #128
    6272:	5de0      	mov	dp:0xe0 <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    6274:	7000      	lod	A, #0
    6276:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    6278:	51e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    627a:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    627c:	eeda 0080 	cmp	Y, #128
    6280:	1a03      	jule	0x6288 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    6282:	72da 0080 	lod	A, #128
    6286:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    6288:	72e6      	lod	A, Y
    628a:	a9e4      	sub	A, dp:0xe4 <_ml_driver_mode+0xc>
    628c:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    628e:	72ee      	lod	A, X
    6290:	120d      	call	0x66ac <_Flash_PageRead>
    6292:	0029      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    6294:	7800      	lod	Y, #0
    6296:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    6298:	59e6      	mov	dp:0xe6 <_ml_driver_mode+0xe>, Y
    629a:	0025      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    629c:	8c47      	cmp	AL, #71
    629e:	1d23      	jne	0x62e6 <_ml_DiagReceived+0xf4>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62a0:	7000      	lod	A, #0
    62a2:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    62a4:	79e8      	lod	Y, dp:0xe8 <_ml_driver_mode+0x10>
    62a6:	ede4      	cmp	Y, dp:0xe4 <_ml_driver_mode+0xc>
    62a8:	1c0b      	jnc	0x62c0 <_ml_DiagReceived+0xce>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    62aa:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    62ac:	a2e6      	add	A, Y
    62ae:	7a0d      	lod	Y, [S-14]
    62b0:	e2da 00ce 	add	Y, #206
    62b4:	66f0      	lod	YL, [Y]
    62b6:	5cf6      	usex	Y
    62b8:	5adf      	push	Y
    62ba:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
    62be:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    62c0:	71e8      	lod	A, dp:0xe8 <_ml_driver_mode+0x10>
    62c2:	a001      	add	A, #1
    62c4:	51e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62c6:	7a0d      	lod	Y, [S-14]
    62c8:	e001      	add	Y, #1
    62ca:	5a0d      	mov	[S-14], Y
    62cc:	ec05      	cmp	Y, #5
    62ce:	1a6a      	jule	0x62a4 <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    62d0:	ade4      	cmp	A, dp:0xe4 <_ml_driver_mode+0xc>
    62d2:	1c01      	jnc	0x62d6 <_ml_DiagReceived+0xe4>
    62d4:	01b7      	jmp	0x6644 <_ml_DiagReceived+0x452>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    62d6:	82db 5a88 	callf	0x5a88 <_NVRAM_SaveAll>
                        ddDataSize = 0;
    62da:	7000      	lod	A, #0
    62dc:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    62de:	140d      	call	0x5afa <_ml_ContFrame>
    62e0:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    62e2:	6400      	lod	YL, #0
    62e4:	45da      	mov	dp:0xda <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    62e6:	7000      	lod	A, #0
    62e8:	07fa      	jmp	0x62de <_ml_DiagReceived+0xec>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    62ea:	ac10      	cmp	A, #16
    62ec:	1901      	je	0x62f0 <_ml_DiagReceived+0xfe>
    62ee:	0041      	jmp	0x6372 <_ml_DiagReceived+0x180>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    62f0:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    62f2:	8cb4      	cmp	AL, #-76
    62f4:	1901      	je	0x62f8 <_ml_DiagReceived+0x106>
    62f6:	01a0      	jmp	0x6638 <_ml_DiagReceived+0x446>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    62f8:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    62fa:	8cd3      	cmp	AL, #-45
    62fc:	1901      	je	0x6300 <_ml_DiagReceived+0x10e>
    62fe:	019c      	jmp	0x6638 <_ml_DiagReceived+0x446>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    6300:	6001      	lod	AL, #1
    6302:	41ea      	mov	dp:0xea <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    6304:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    6306:	8c85      	cmp	AL, #-123
    6308:	1d14      	jne	0x6332 <_ml_DiagReceived+0x140>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    630a:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x5>
    630c:	5cf2      	usex	A
    630e:	52df      	push	A
    6310:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xa>
    6312:	11db      	call	0x66ca <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    6314:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xa>
    6316:	a001      	add	A, #1
    6318:	65d2      	lod	YL, dp:0xd2 <_LinFrameDataBuffer+0x6>
    631a:	5cf6      	usex	Y
    631c:	5adf      	push	Y
    631e:	11d5      	call	0x66ca <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    6320:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xa>
    6322:	a002      	add	A, #2
    6324:	65d3      	lod	YL, dp:0xd3 <_LinFrameDataBuffer+0x7>
    6326:	5cf6      	usex	Y
    6328:	5adf      	push	Y
    632a:	11cf      	call	0x66ca <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    632c:	7003      	lod	A, #3
    632e:	51e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, A
    6330:	0018      	jmp	0x6362 <_ml_DiagReceived+0x170>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    6332:	8c47      	cmp	AL, #71
    6334:	1d1b      	jne	0x636c <_ml_DiagReceived+0x17a>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    6336:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x5>
    6338:	5cf2      	usex	A
    633a:	52df      	push	A
    633c:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    633e:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    6342:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    6344:	a001      	add	A, #1
    6346:	65d2      	lod	YL, dp:0xd2 <_LinFrameDataBuffer+0x6>
    6348:	5cf6      	usex	Y
    634a:	5adf      	push	Y
    634c:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    6350:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    6352:	a002      	add	A, #2
    6354:	65d3      	lod	YL, dp:0xd3 <_LinFrameDataBuffer+0x7>
    6356:	5cf6      	usex	Y
    6358:	5adf      	push	Y
    635a:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    635e:	7803      	lod	Y, #3
    6360:	59e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    6362:	7001      	lod	A, #1
    6364:	82db 5afa 	callf	0x5afa <_ml_ContFrame>
    6368:	5c05      	dec	S, #6
    636a:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    636c:	7020      	lod	A, #32
    636e:	15bb      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
    6370:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    6372:	620b      	lod	AL, [S-12]
    6374:	94f0      	and	AL, #-16
    6376:	1901      	je	0x637a <_ml_DiagReceived+0x188>
    6378:	0162      	jmp	0x663e <_ml_DiagReceived+0x44c>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    637a:	7000      	lod	A, #0
    637c:	82db 5afa 	callf	0x5afa <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    6380:	720b      	lod	A, [S-12]
    6382:	b40f      	and	A, #15
    6384:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    6386:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    6388:	8cb4      	cmp	AL, #-76
    638a:	190d      	je	0x63a6 <_ml_DiagReceived+0x1b4>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    638c:	54ca 0001 	pushw	#1
    6390:	72da 00cc 	lod	A, #204
    6394:	156c      	call	0x5e6e <_ldr_isReadByIdMessage>
    6396:	5c01      	dec	S, #2
    6398:	8c00      	cmp	AL, #0
    639a:	1d01      	jne	0x639e <_ml_DiagReceived+0x1ac>
    639c:	014d      	jmp	0x6638 <_ml_DiagReceived+0x446>
                ml_ldr_ReadByIdMessage(Data[0]);
    639e:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x3>
    63a0:	5cf2      	usex	A
    63a2:	16d9      	call	0x6156 <_ml_ldr_ReadByIdMessage>
    63a4:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    63a6:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x3>
    63a8:	4207      	mov	[S-8], AL
    63aa:	8cd3      	cmp	AL, #-45
    63ac:	190a      	je	0x63c2 <_ml_DiagReceived+0x1d0>
    63ae:	8c80      	cmp	AL, #-128
    63b0:	1908      	je	0x63c2 <_ml_DiagReceived+0x1d0>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    63b2:	69d0      	lod	AH, dp:0xd0 <_LinFrameDataBuffer+0x4>
    63b4:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x5>
    63b6:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    63b8:	69d2      	lod	AH, dp:0xd2 <_LinFrameDataBuffer+0x6>
    63ba:	61d3      	lod	AL, dp:0xd3 <_LinFrameDataBuffer+0x7>
    63bc:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    63be:	7800      	lod	Y, #0
    63c0:	59e8      	mov	dp:0xe8 <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    63c2:	6607      	lod	YL, [S-8]
    63c4:	5cf6      	usex	Y
    63c6:	72e6      	lod	A, Y
    63c8:	b420      	and	A, #32
    63ca:	1929      	je	0x641e <_ml_DiagReceived+0x22c>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    63cc:	72e6      	lod	A, Y
    63ce:	b430      	and	A, #48
    63d0:	ac20      	cmp	A, #32
    63d2:	1d18      	jne	0x6404 <_ml_DiagReceived+0x212>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    63d4:	6085      	lod	AL, #-123
    63d6:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    63d8:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    63da:	7ae2      	lod	Y, A
    63dc:	f47f      	and	Y, #127
    63de:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    63e0:	b480      	and	A, #-128
    63e2:	5205      	mov	[S-6], A
    63e4:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    63e6:	7de4      	lod	X, dp:0xe4 <_ml_driver_mode+0xc>
    63e8:	5de6      	mov	dp:0xe6 <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    63ea:	72da 0080 	lod	A, #128
    63ee:	aae6      	sub	A, Y
    63f0:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    63f2:	aeee      	cmp	A, X
    63f4:	1a01      	jule	0x63f8 <_ml_DiagReceived+0x206>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    63f6:	5de4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    63f8:	7205      	lod	A, [S-6]
    63fa:	1148      	call	0x668c <_Flash_GetWriteTime>
    63fc:	15fa      	call	0x5ff2 <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    63fe:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    6400:	1155      	call	0x66ac <_Flash_PageRead>
    6402:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    6404:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    6406:	8cd6      	cmp	AL, #-42
    6408:	1901      	je	0x640c <_ml_DiagReceived+0x21a>
    640a:	0087      	jmp	0x651a <_ml_DiagReceived+0x328>
    640c:	61db      	lod	AL, dp:0xdb <_ml_driver_mode+0x3>
    640e:	1901      	je	0x6412 <_ml_DiagReceived+0x220>
    6410:	0084      	jmp	0x651a <_ml_DiagReceived+0x328>
    6412:	61dc      	lod	AL, dp:0xdc <_ml_driver_mode+0x4>
    6414:	8c01      	cmp	AL, #1
    6416:	1901      	je	0x641a <_ml_DiagReceived+0x228>
    6418:	0080      	jmp	0x651a <_ml_DiagReceived+0x328>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    641a:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xc>
    641c:	0106      	jmp	0x662a <_ml_DiagReceived+0x438>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    641e:	eeda 0080 	cmp	Y, #128
    6422:	1d01      	jne	0x6426 <_ml_DiagReceived+0x234>
    6424:	002d      	jmp	0x6480 <_ml_DiagReceived+0x28e>
    6426:	1f0c      	jsg	0x6440 <_ml_DiagReceived+0x24e>
    6428:	ec08      	cmp	Y, #8
    642a:	1d01      	jne	0x642e <_ml_DiagReceived+0x23c>
    642c:	0065      	jmp	0x64f8 <_ml_DiagReceived+0x306>
    642e:	1f04      	jsg	0x6438 <_ml_DiagReceived+0x246>
    6430:	ec03      	cmp	Y, #3
    6432:	1d01      	jne	0x6436 <_ml_DiagReceived+0x244>
    6434:	0039      	jmp	0x64a8 <_ml_DiagReceived+0x2b6>
    6436:	0100      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6438:	ec47      	cmp	Y, #71
    643a:	1d01      	jne	0x643e <_ml_DiagReceived+0x24c>
    643c:	0059      	jmp	0x64f0 <_ml_DiagReceived+0x2fe>
    643e:	00fc      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6440:	eeda 00c1 	cmp	Y, #193
    6444:	190f      	je	0x6464 <_ml_DiagReceived+0x272>
    6446:	1f05      	jsg	0x6452 <_ml_DiagReceived+0x260>
    6448:	eeda 0092 	cmp	Y, #146
    644c:	1d01      	jne	0x6450 <_ml_DiagReceived+0x25e>
    644e:	0059      	jmp	0x6502 <_ml_DiagReceived+0x310>
    6450:	00f3      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6452:	eeda 00d3 	cmp	Y, #211
    6456:	1d01      	jne	0x645a <_ml_DiagReceived+0x268>
    6458:	0063      	jmp	0x6520 <_ml_DiagReceived+0x32e>
    645a:	eeda 00d6 	cmp	Y, #214
    645e:	1d01      	jne	0x6462 <_ml_DiagReceived+0x270>
    6460:	00c6      	jmp	0x65ee <_ml_DiagReceived+0x3fc>
    6462:	00ea      	jmp	0x6638 <_ml_DiagReceived+0x446>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    6464:	10f0      	call	0x6646 <_LDR_GetState>
    6466:	66e0      	lod	YL, AL
    6468:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    646a:	8ee8      	cmp	AL, YL
    646c:	1d01      	jne	0x6470 <_ml_DiagReceived+0x27e>
    646e:	00ea      	jmp	0x6644 <_ml_DiagReceived+0x452>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    6470:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6474:	94fe      	and	AL, #-2
    6476:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    647a:	82db 5920 	callf	0x5920 <_MLX16_RESET>
                            }
                            break;
    647e:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    6480:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    6482:	8c85      	cmp	AL, #-123
    6484:	1d09      	jne	0x6498 <_ml_DiagReceived+0x2a6>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    6486:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x6>
    6488:	1d05      	jne	0x6494 <_ml_DiagReceived+0x2a2>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    648a:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xc>
    648c:	1901      	je	0x6490 <_ml_DiagReceived+0x29e>
    648e:	076e      	jmp	0x636c <_ml_DiagReceived+0x17a>
                                        ddCurrentOp = 0;            /* operation done */
    6490:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
    6492:	0007      	jmp	0x64a2 <_ml_DiagReceived+0x2b0>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    6494:	7050      	lod	A, #80
    6496:	076b      	jmp	0x636e <_ml_DiagReceived+0x17c>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6498:	8c47      	cmp	AL, #71
    649a:	1901      	je	0x649e <_ml_DiagReceived+0x2ac>
    649c:	00b6      	jmp	0x660a <_ml_DiagReceived+0x418>
                                ddCurrentOp = 0;                /* operation done */
    649e:	6400      	lod	YL, #0
    64a0:	45da      	mov	dp:0xda <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    64a2:	7000      	lod	A, #0
    64a4:	15a6      	call	0x5ff2 <_ldr_isReadByIdMessage+0x184>
    64a6:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    64a8:	620b      	lod	AL, [S-12]
    64aa:	8c03      	cmp	AL, #3
    64ac:	1d08      	jne	0x64be <_ml_DiagReceived+0x2cc>
                                peCurrentValue = Data[1];
    64ae:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    64b0:	41dc      	mov	dp:0xdc <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    64b2:	8c64      	cmp	AL, #100
    64b4:	1e04      	jug	0x64be <_ml_DiagReceived+0x2cc>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    64b6:	8c12      	cmp	AL, #18
    64b8:	1e04      	jug	0x64c2 <_ml_DiagReceived+0x2d0>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    64ba:	6013      	lod	AL, #19
    64bc:	0001      	jmp	0x64c0 <_ml_DiagReceived+0x2ce>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    64be:	6064      	lod	AL, #100
    64c0:	41dc      	mov	dp:0xdc <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    64c2:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    64c4:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    64c6:	6403      	lod	YL, #3
    64c8:	45cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    64ca:	60f4      	lod	AL, #-12
    64cc:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    64ce:	10bb      	call	0x6646 <_LDR_GetState>
    64d0:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    64d2:	61dc      	lod	AL, dp:0xdc <_ml_driver_mode+0x4>
    64d4:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    64d6:	60ff      	lod	AL, #-1
    64d8:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    64da:	41d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    64dc:	41d3      	mov	dp:0xd3 <_LinFrameDataBuffer+0x7>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    64de:	7000      	lod	A, #0
    64e0:	82db 5aa4 	callf	0x5aa4 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    64e4:	7001      	lod	A, #1
    64e6:	82db 5afa 	callf	0x5afa <_ml_ContFrame>
                            pendingAction = ddFastProt;
    64ea:	6003      	lod	AL, #3
    64ec:	41eb      	mov	dp:0xeb <_ml_driver_mode+0x13>, AL
                            break;
    64ee:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    64f0:	45da      	mov	dp:0xda <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64f2:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
    64f6:	07d5      	jmp	0x64a2 <_ml_DiagReceived+0x2b0>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    64f8:	45da      	mov	dp:0xda <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64fa:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    64fe:	1536      	call	0x5f6c <_ldr_isReadByIdMessage+0xfe>
                            break;
    6500:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    6502:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    6504:	6000      	lod	AL, #0
    6506:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    6508:	ac08      	cmp	A, #8
    650a:	1902      	je	0x6510 <_ml_DiagReceived+0x31e>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    650c:	7010      	lod	A, #16
    650e:	072f      	jmp	0x636e <_ml_DiagReceived+0x17c>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    6510:	7801      	lod	Y, #1
    6512:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    6514:	72da 6bec 	lod	A, #27628
    6518:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    651a:	6006      	lod	AL, #6
    651c:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
    651e:	07ef      	jmp	0x64fe <_ml_DiagReceived+0x30c>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    6520:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x2>
    6522:	8c85      	cmp	AL, #-123
    6524:	1901      	je	0x6528 <_ml_DiagReceived+0x336>
    6526:	0042      	jmp	0x65ac <_ml_DiagReceived+0x3ba>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    6528:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    652a:	a1e2      	add	A, dp:0xe2 <_ml_driver_mode+0xa>
    652c:	aeda bf66 	cmp	A, #48998
    6530:	1d24      	jne	0x657a <_ml_DiagReceived+0x388>
    6532:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0xe>
    6534:	ac02      	cmp	A, #2
    6536:	1d21      	jne	0x657a <_ml_DiagReceived+0x388>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    6538:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    653a:	5cf2      	usex	A

                                    switch (new_state) {
    653c:	1903      	je	0x6544 <_ml_DiagReceived+0x352>
    653e:	ac01      	cmp	A, #1
    6540:	190d      	je	0x655c <_ml_DiagReceived+0x36a>
    6542:	0051      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    6544:	72da be84 	lod	A, #48772
    6548:	10b1      	call	0x66ac <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    654a:	72da be84 	lod	A, #48772
    654e:	b47f      	and	A, #127
    6550:	54ca 0001 	pushw	#1
    6554:	10ba      	call	0x66ca <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    6556:	72da be84 	lod	A, #48772
    655a:	000b      	jmp	0x6572 <_ml_DiagReceived+0x380>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    655c:	72da be80 	lod	A, #48768
    6560:	10a5      	call	0x66ac <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    6562:	72da be80 	lod	A, #48768
    6566:	b47f      	and	A, #127
    6568:	54ca 0001 	pushw	#1
    656c:	10ae      	call	0x66ca <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    656e:	72da be80 	lod	A, #48768
    6572:	10c3      	call	0x66fa <_Flash_PageWrite>
    6574:	51de      	mov	dp:0xde <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    6576:	5c01      	dec	S, #2
    6578:	0036      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    657a:	7800      	lod	Y, #0
    657c:	5a0d      	mov	[S-14], Y
    657e:	20fe      	add	X, #-2
    6580:	5e03      	mov	[S-4], X
    6582:	eeee      	cmp	Y, X
    6584:	1c0f      	jnc	0x65a4 <_ml_DiagReceived+0x3b2>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    6586:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xa>
    6588:	a20d      	add	A, [S-14]
    658a:	7a0d      	lod	Y, [S-14]
    658c:	e2da 00d0 	add	Y, #208
    6590:	66f0      	lod	YL, [Y]
    6592:	5cf6      	usex	Y
    6594:	5adf      	push	Y
    6596:	1099      	call	0x66ca <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6598:	5c01      	dec	S, #2
    659a:	720d      	lod	A, [S-14]
    659c:	a001      	add	A, #1
    659e:	520d      	mov	[S-14], A
    65a0:	ae03      	cmp	A, [S-4]
    65a2:	1871      	jc	0x6586 <_ml_DiagReceived+0x394>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    65a4:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    65a6:	1161      	call	0x686a <_Flash_PageWriteFiltered>
    65a8:	51de      	mov	dp:0xde <_ml_driver_mode+0x6>, A
    65aa:	001d      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    65ac:	8c47      	cmp	AL, #71
    65ae:	1d19      	jne	0x65e2 <_ml_DiagReceived+0x3f0>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    65b0:	7800      	lod	Y, #0
    65b2:	5a0d      	mov	[S-14], Y
    65b4:	20fe      	add	X, #-2
    65b6:	5e01      	mov	[S-2], X
    65b8:	eeee      	cmp	Y, X
    65ba:	1c10      	jnc	0x65dc <_ml_DiagReceived+0x3ea>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    65bc:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0x8>
    65be:	a20d      	add	A, [S-14]
    65c0:	7a0d      	lod	Y, [S-14]
    65c2:	e2da 00d0 	add	Y, #208
    65c6:	66f0      	lod	YL, [Y]
    65c8:	5cf6      	usex	Y
    65ca:	5adf      	push	Y
    65cc:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    65d0:	5c01      	dec	S, #2
    65d2:	720d      	lod	A, [S-14]
    65d4:	a001      	add	A, #1
    65d6:	520d      	mov	[S-14], A
    65d8:	ae01      	cmp	A, [S-2]
    65da:	1870      	jc	0x65bc <_ml_DiagReceived+0x3ca>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    65dc:	82db 5a88 	callf	0x5a88 <_NVRAM_SaveAll>
    65e0:	0002      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    65e2:	7020      	lod	A, #32
    65e4:	1480      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    65e6:	7800      	lod	Y, #0
    65e8:	59e6      	mov	dp:0xe6 <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    65ea:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    65ec:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    65ee:	60d6      	lod	AL, #-42
    65f0:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    65f2:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x4>
    65f4:	41db      	mov	dp:0xdb <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    65f6:	1d0c      	jne	0x6610 <_ml_DiagReceived+0x41e>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65f8:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x5>
    65fa:	41dc      	mov	dp:0xdc <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65fc:	5cf2      	usex	A
    65fe:	1903      	je	0x6606 <_ml_DiagReceived+0x414>
    6600:	ac01      	cmp	A, #1
    6602:	1903      	je	0x660a <_ml_DiagReceived+0x418>
    6604:	0017      	jmp	0x6634 <_ml_DiagReceived+0x442>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    6606:	6000      	lod	AL, #0
    6608:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    660a:	72da 00f0 	lod	A, #240
    660e:	06af      	jmp	0x636e <_ml_DiagReceived+0x17c>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    6610:	8c01      	cmp	AL, #1
    6612:	1d10      	jne	0x6634 <_ml_DiagReceived+0x442>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    6614:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x5>
    6616:	41dc      	mov	dp:0xdc <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    6618:	1d0a      	jne	0x662e <_ml_DiagReceived+0x43c>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    661a:	61d2      	lod	AL, dp:0xd2 <_LinFrameDataBuffer+0x6>
    661c:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    661e:	1101      	call	0x6822 <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    6620:	7ada 4000 	lod	Y, #16384
    6624:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    6626:	7800      	lod	Y, #0
    6628:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    662a:	1501      	call	0x602e <_ml_ldr_ErrorDetected+0x8>
                                    break;
    662c:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    662e:	6000      	lod	AL, #0
    6630:	41da      	mov	dp:0xda <_ml_driver_mode+0x2>, AL
    6632:	0002      	jmp	0x6638 <_ml_DiagReceived+0x446>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    6634:	6400      	lod	YL, #0
    6636:	45da      	mov	dp:0xda <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    6638:	72da 00d0 	lod	A, #208
    663c:	0698      	jmp	0x636e <_ml_DiagReceived+0x17c>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    663e:	72da 00b0 	lod	A, #176
    6642:	1451      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
    6644:	540f      	ret	#16

00006646 <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    6646:	7ada be80 	lod	Y, #48768
    664a:	62f0      	lod	AL, [Y]
    664c:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    6650:	66e0      	lod	YL, AL
    6652:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    6656:	a2e6      	add	A, Y
    6658:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    665a:	5401      	ret

0000665c <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    665c:	17f4      	call	0x6646 <_LDR_GetState>
    665e:	8c03      	cmp	AL, #3
    6660:	1d03      	jne	0x6668 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    6662:	72da 8000 	lod	A, #32768
    6666:	0001      	jmp	0x666a <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    6668:	7000      	lod	A, #0
    666a:	52d8 0334 	mov	0x334 <_page_buffer+0x2>, A
    666e:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    6670:	a2da c000 	add	A, #49152
    6674:	72e4      	swap	A
    6676:	b6da 00ff 	and	A, #255
    667a:	44b2      	lsr	A, #2
    667c:	4432      	lsr	A
}
    667e:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    6680:	44e2      	sfb	A
    6682:	b6d8 0334 	and	A, 0x334 <_page_buffer+0x2>
    6686:	1901      	je	0x668a <_Flash_InitDriver+0x2e>
    6688:	7001      	lod	A, #1
}
    668a:	5401      	ret

0000668c <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    668c:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    668e:	17f0      	call	0x6670 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    6690:	17f7      	call	0x6680 <_Flash_InitDriver+0x24>
    6692:	8c00      	cmp	AL, #0
    6694:	1d09      	jne	0x66a8 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6696:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    669a:	8c01      	cmp	AL, #1
    669c:	1a02      	jule	0x66a2 <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    669e:	7030      	lod	A, #48
    66a0:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    66a2:	72da 02a6 	lod	A, #678
    66a6:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    66a8:	7006      	lod	A, #6
    }

    return wr_time;
}
    66aa:	5401      	ret

000066ac <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    66ac:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    66ae:	b480      	and	A, #-128
    66b0:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    66b2:	7ed8 0332 	lod	X, 0x332 <_page_buffer>
    66b6:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    66b8:	7a03      	lod	Y, [S-4]
    66ba:	54c6      	movsw	[X++], [Y++]
    66bc:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66be:	7201      	lod	A, [S-2]
    66c0:	a2da 0080 	add	A, #128
    66c4:	2ee2      	cmp	X, A
    66c6:	1878      	jc	0x66b8 <_Flash_PageRead+0xc>
    66c8:	5405      	ret	#6

000066ca <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    66ca:	b47f      	and	A, #127
    66cc:	7ae2      	lod	Y, A
    66ce:	e2d8 0332 	add	Y, 0x332 <_page_buffer>
    66d2:	6203      	lod	AL, [S-4]
    66d4:	42f0      	mov	[Y], AL
    66d6:	5401      	ret

000066d8 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    66d8:	b480      	and	A, #-128
    66da:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    66dc:	7ad8 0332 	lod	Y, 0x332 <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    66e0:	72d6      	lod	A, [Y++]
    66e2:	aede      	cmp	A, [X++]
    66e4:	1902      	je	0x66ea <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    66e6:	7001      	lod	A, #1
    66e8:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66ea:	72d8 0332 	lod	A, 0x332 <_page_buffer>
    66ee:	a2da 0080 	add	A, #128
    66f2:	eee2      	cmp	Y, A
    66f4:	1875      	jc	0x66e0 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    66f6:	7000      	lod	A, #0
}
    66f8:	5401      	ret

000066fa <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    66fa:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    66fc:	b480      	and	A, #-128
    66fe:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    6700:	17a2      	call	0x6646 <_LDR_GetState>
    6702:	8c01      	cmp	AL, #1
    6704:	1d0b      	jne	0x671c <_Flash_PageWrite+0x22>
    6706:	72da bf66 	lod	A, #48998
    670a:	b480      	and	A, #-128
    670c:	7a09      	lod	Y, [S-10]
    670e:	eee2      	cmp	Y, A
    6710:	1d05      	jne	0x671c <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    6712:	7ad8 0332 	lod	Y, 0x332 <_page_buffer>
    6716:	e076      	add	Y, #118
    6718:	61d4      	lod	AL, dp:0xd4 <_LIN_nad>
    671a:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    671c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    671e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6720:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6722:	b430      	and	A, #48
    6724:	1902      	je	0x672a <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6726:	6000      	lod	AL, #0
    6728:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    672a:	11fc      	call	0x6b24 <_mlx_isPowerOk>
    672c:	8c00      	cmp	AL, #0
    672e:	1d02      	jne	0x6734 <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    6730:	7001      	lod	A, #1
    6732:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    6734:	7a09      	lod	Y, [S-10]
    6736:	eeda be80 	cmp	Y, #48768
    673a:	1d01      	jne	0x673e <_Flash_PageWrite+0x44>
    673c:	0045      	jmp	0x67c8 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    673e:	72e6      	lod	A, Y
    6740:	1797      	call	0x6670 <_Flash_InitDriver+0x14>
    6742:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    6744:	179d      	call	0x6680 <_Flash_InitDriver+0x24>
    6746:	8c00      	cmp	AL, #0
    6748:	1901      	je	0x674c <_Flash_PageWrite+0x52>
    674a:	003e      	jmp	0x67c8 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    674c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    674e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6750:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6752:	b430      	and	A, #48
    6754:	1902      	je	0x675a <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6756:	6000      	lod	AL, #0
    6758:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    675a:	7207      	lod	A, [S-8]
    675c:	487a 0800 	muls	Y, A, #2048
    6760:	e2da 4000 	add	Y, #16384
    6764:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6766:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    676a:	8c01      	cmp	AL, #1
    676c:	1a03      	jule	0x6774 <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    676e:	7801      	lod	Y, #1
    6770:	5a03      	mov	[S-4], Y
    6772:	0002      	jmp	0x6778 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    6774:	7010      	lod	A, #16
    6776:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    6778:	7800      	lod	Y, #0
    677a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    677e:	7a05      	lod	Y, [S-6]
    6780:	7000      	lod	A, #0
    6782:	52d6      	mov	[Y++], A
        *dst++ = 0;
    6784:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6786:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    6788:	72da 00c8 	lod	A, #200
    678c:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    6790:	62d8 00d8 	lod	AL, 0xd8 <_ml_driver_mode>
    6794:	8c55      	cmp	AL, #85
    6796:	1903      	je	0x679e <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    6798:	7000      	lod	A, #0
    679a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    679e:	7000      	lod	A, #0
    67a0:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    67a2:	72ee      	lod	A, X
    67a4:	80ff      	add	AL, #-1
    67a6:	5cf2      	usex	A
    67a8:	7ee2      	lod	X, A
    67aa:	1d6e      	jne	0x6788 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    67ac:	7a05      	lod	Y, [S-6]
    67ae:	e2da 0080 	add	Y, #128
    67b2:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    67b4:	7203      	lod	A, [S-4]
    67b6:	a0ff      	add	A, #-1
    67b8:	5203      	mov	[S-4], A
    67ba:	1d5e      	jne	0x6778 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    67bc:	7207      	lod	A, [S-8]
    67be:	44e2      	sfb	A
    67c0:	a6d8 0334 	or	A, 0x334 <_page_buffer+0x2>
    67c4:	52d8 0334 	mov	0x334 <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67c8:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    67ca:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67cc:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67ce:	b430      	and	A, #48
    67d0:	1902      	je	0x67d6 <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67d2:	6400      	lod	YL, #0
    67d4:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    67d6:	7000      	lod	A, #0
    67d8:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    67dc:	7ad8 0332 	lod	Y, 0x332 <_page_buffer>
    dst = (uint16_t *)addr;
    67e0:	7e09      	lod	X, [S-10]
    67e2:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    67e4:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    67e6:	7201      	lod	A, [S-2]
    67e8:	a2da 0080 	add	A, #128
    67ec:	eee2      	cmp	Y, A
    67ee:	187a      	jc	0x67e4 <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    67f0:	7818      	lod	Y, #24
    67f2:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    67f6:	62d8 00d8 	lod	AL, 0xd8 <_ml_driver_mode>
    67fa:	8c55      	cmp	AL, #85
    67fc:	1903      	je	0x6804 <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    67fe:	7000      	lod	A, #0
    6800:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    6804:	7a09      	lod	Y, [S-10]
    6806:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    6808:	7000      	lod	A, #0
    680a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    680e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6810:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6812:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6814:	b430      	and	A, #48
    6816:	1902      	je	0x681c <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6818:	6400      	lod	YL, #0
    681a:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    681c:	7209      	lod	A, [S-10]
    681e:	175c      	call	0x66d8 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    6820:	540b      	ret	#12

00006822 <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    6822:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    6824:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    6828:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    682a:	7ae8      	swap	Y
    682c:	f6da 00ff 	and	Y, #255
    6830:	4436      	lsr	Y
    6832:	7ee6      	lod	X, Y
    6834:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    6836:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    6838:	ac3f      	cmp	A, #63
    683a:	1b02      	jsle	0x6840 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    683c:	703f      	lod	A, #63
    683e:	0003      	jmp	0x6846 <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    6840:	ac00      	cmp	A, #0
    6842:	1e81      	jsge	0x6846 <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    6844:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    6846:	7ae2      	lod	Y, A
    6848:	f43f      	and	Y, #63
    684a:	f6da 00ff 	and	Y, #255
    684e:	7ae8      	swap	Y
    6850:	4426      	asl	Y
    6852:	7201      	lod	A, [S-2]
    6854:	b6da 81ff 	and	A, #33279
    6858:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    685a:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    685e:	4432      	lsr	A
    6860:	b6da 3f00 	and	A, #16128
    6864:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    6866:	72ee      	lod	A, X
    6868:	5403      	ret	#4

0000686a <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    686a:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    686c:	b480      	and	A, #-128
    686e:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    6870:	aeda be80 	cmp	A, #48768
    6874:	1907      	je	0x6884 <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    6876:	7201      	lod	A, [S-2]
    6878:	aeda bf00 	cmp	A, #48896
    687c:	1d05      	jne	0x6888 <_Flash_PageWriteFiltered+0x1e>
    687e:	16e3      	call	0x6646 <_LDR_GetState>
    6880:	8c03      	cmp	AL, #3
    6882:	1d02      	jne	0x6888 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    6884:	7000      	lod	A, #0
    6886:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    6888:	7201      	lod	A, [S-2]
    688a:	1737      	call	0x66fa <_Flash_PageWrite>
}
    688c:	5403      	ret	#4

0000688e <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    688e:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6890:	4cc2 45c0 	mov	D, #280000
    6894:	0004 
    6896:	4872 0006 	muls	A, A, #6
    689a:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    689c:	4c80      	mov	YA, D
    689e:	7e03      	lod	X, [S-4]
    68a0:	4c63      	divu	YA, X
    68a2:	4c63      	divu	YA, X
    68a4:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    68a6:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    68a8:	7000      	lod	A, #0
    68aa:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    68ac:	eeda 027a 	cmp	Y, #634
    68b0:	1e04      	jug	0x68ba <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    68b2:	80ff      	add	AL, #-1
    68b4:	b40f      	and	A, #15
    68b6:	5205      	mov	[S-6], A
            break;
    68b8:	0005      	jmp	0x68c4 <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    68ba:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    68bc:	8001      	add	AL, #1
    68be:	5cf2      	usex	A
    68c0:	8c02      	cmp	AL, #2
    68c2:	1a74      	jule	0x68ac <_ml_SetFastBaudRate+0x1e>
    68c4:	72e6      	lod	A, Y
    68c6:	a005      	add	A, #5
    68c8:	4cf2      	usex	YA
    68ca:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    68cc:	4c63      	divu	YA, X
    68ce:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    68d0:	8080      	add	AL, #-128
    68d2:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    68d4:	52df      	push	A
    68d6:	7207      	lod	A, [S-8]
    68d8:	82db 5b8e 	callf	0x5b8e <_ml_SetBaudRate>
    68dc:	5c01      	dec	S, #2
    68de:	5407      	ret	#8
    68e0:	b66d      	and	A, [S-110]
    68e2:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x3>
    68e4:	dbb6      	subc	AH, ep:0xb6 <__bss_dp_size+0x6>
    68e6:	b66d      	and	A, [S-110]
    68e8:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x3>

000068ea <_RAM_Test>:
    68ea:	7ada 68e0 	lod	Y, #26848
    68ee:	4cc0      	mov	D, YA
    68f0:	7c00      	lod	X, #0
    68f2:	54c6      	movsw	[X++], [Y++]
    68f4:	54c6      	movsw	[X++], [Y++]
    68f6:	54c6      	movsw	[X++], [Y++]
    68f8:	7800      	lod	Y, #0
    68fa:	54c6      	movsw	[X++], [Y++]
    68fc:	2eda 07fe 	cmp	X, #2046
    6900:	1a7c      	jule	0x68fa <_RAM_Test+0x10>
    6902:	4c80      	mov	YA, D
    6904:	7c00      	lod	X, #0
    6906:	72de      	lod	A, [X++]
    6908:	aed6      	cmp	A, [Y++]
    690a:	1d0a      	jne	0x6920 <_RAM_Test+0x36>
    690c:	72de      	lod	A, [X++]
    690e:	aed6      	cmp	A, [Y++]
    6910:	1d07      	jne	0x6920 <_RAM_Test+0x36>
    6912:	72de      	lod	A, [X++]
    6914:	aed6      	cmp	A, [Y++]
    6916:	1d04      	jne	0x6920 <_RAM_Test+0x36>
    6918:	7800      	lod	Y, #0
    691a:	72de      	lod	A, [X++]
    691c:	aed6      	cmp	A, [Y++]
    691e:	1903      	je	0x6926 <_RAM_Test+0x3c>
    6920:	64f3      	lod	YL, #-13
    6922:	76da 568e 	jmpf	0x568e <__fatal>
    6926:	2eda 07fe 	cmp	X, #2046
    692a:	1a77      	jule	0x691a <_RAM_Test+0x30>
    692c:	4c80      	mov	YA, D
    692e:	e002      	add	Y, #2
    6930:	eeda 68e6 	cmp	Y, #26854
    6934:	1d5c      	jne	0x68ee <_RAM_Test+0x4>
    6936:	76da 55e8 	jmpf	0x55e8 <_start>

0000693a <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    693a:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    693c:	72d8 0336 	lod	A, 0x336 <__bss_end>
    6940:	aeda b598 	cmp	A, #46488
    6944:	1907      	je	0x6954 <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    6946:	72da b598 	lod	A, #46488
    694a:	52d8 0336 	mov	0x336 <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    694e:	7800      	lod	Y, #0
    6950:	5ad8 0338 	mov	0x338 <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if (   (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    6954:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6958:	aeda 3072 	cmp	A, #12402
    695c:	1d01      	jne	0x6960 <__low_level_init+0x26>
    695e:	0071      	jmp	0x6a42 <__low_level_init+0x108>
    6960:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6964:	aeda 3212 	cmp	A, #12818
    6968:	1d01      	jne	0x696c <__low_level_init+0x32>
    696a:	006b      	jmp	0x6a42 <__low_level_init+0x108>
    696c:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6970:	aeda 5c92 	cmp	A, #23698
    6974:	1d01      	jne	0x6978 <__low_level_init+0x3e>
    6976:	0065      	jmp	0x6a42 <__low_level_init+0x108>
    6978:	7c0f      	lod	X, #15
    697a:	7ada 11c0 	lod	Y, #4544
    697e:	7000      	lod	A, #0
    6980:	08a7      	clrb	ML.7
    6982:	b2d6      	adc	A, [Y++]
    6984:	1bfe      	djnz	X, 0x6982 <__low_level_init+0x48>
    6986:	92e4      	adc	AL, AH
    6988:	9000      	adc	AL, #0
    698a:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    698c:	aeda 00ff 	cmp	A, #255
    6990:	1903      	je	0x6998 <__low_level_init+0x5e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    6992:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    6994:	76da 568e 	jmpf	0x568e <__fatal>
    6998:	7c0c      	lod	X, #12
    699a:	7ada 11de 	lod	Y, #4574
    699e:	7000      	lod	A, #0
    69a0:	08a7      	clrb	ML.7
    69a2:	b2d6      	adc	A, [Y++]
    69a4:	1bfe      	djnz	X, 0x69a2 <__low_level_init+0x68>
    69a6:	92e4      	adc	AL, AH
    69a8:	9000      	adc	AL, #0
    69aa:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    69ac:	aeda 00ff 	cmp	A, #255
    69b0:	1903      	je	0x69b8 <__low_level_init+0x7e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    69b2:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    69b4:	76da 568e 	jmpf	0x568e <__fatal>
    69b8:	7c05      	lod	X, #5
    69ba:	7ada 11f6 	lod	Y, #4598
    69be:	7000      	lod	A, #0
    69c0:	08a7      	clrb	ML.7
    69c2:	b2d6      	adc	A, [Y++]
    69c4:	1bfe      	djnz	X, 0x69c2 <__low_level_init+0x88>
    69c6:	92e4      	adc	AL, AH
    69c8:	9000      	adc	AL, #0
    69ca:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    69cc:	aeda 00ff 	cmp	A, #255
    69d0:	1903      	je	0x69d8 <__low_level_init+0x9e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    69d2:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    69d4:	76da 568e 	jmpf	0x568e <__fatal>
    69d8:	7ada 10fc 	lod	Y, #4348
    69dc:	7c02      	lod	X, #2
    69de:	7000      	lod	A, #0
    69e0:	08a7      	clrb	ML.7
    69e2:	b2d6      	adc	A, [Y++]
    69e4:	1bfe      	djnz	X, 0x69e2 <__low_level_init+0xa8>
    69e6:	92e4      	adc	AL, AH
    69e8:	9000      	adc	AL, #0
    69ea:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    69ec:	aeda 00ff 	cmp	A, #255
    69f0:	1d07      	jne	0x6a00 <__low_level_init+0xc6>
    69f2:	7eda 11f8 	lod	X, #4600
    69f6:	7ada 10fe 	lod	Y, #4350
    69fa:	72f0      	lod	A, [Y]
    69fc:	aef8      	cmp	A, [X]
    69fe:	1921      	je	0x6a42 <__low_level_init+0x108>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    6a00:	7000      	lod	A, #0
    6a02:	7eda 10fc 	lod	X, #4348
    6a06:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    6a08:	7eda 10fe 	lod	X, #4350
    6a0c:	7ada 11f8 	lod	Y, #4600
    6a10:	7af0      	lod	Y, [Y]
    6a12:	5af8      	mov	[X], Y
    6a14:	7ada 10fc 	lod	Y, #4348
    6a18:	7c02      	lod	X, #2
    6a1a:	7000      	lod	A, #0
    6a1c:	08a7      	clrb	ML.7
    6a1e:	b2d6      	adc	A, [Y++]
    6a20:	1bfe      	djnz	X, 0x6a1e <__low_level_init+0xe4>
    6a22:	92e4      	adc	AL, AH
    6a24:	9000      	adc	AL, #0
    6a26:	5cf2      	usex	A
    6a28:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    6a2a:	72da 00ff 	lod	A, #255
    6a2e:	aa05      	sub	A, [S-6]
    6a30:	7ada 10fc 	lod	Y, #4348
    6a34:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    6a36:	7001      	lod	A, #1
    6a38:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    6a3c:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    6a3e:	76da 568e 	jmpf	0x568e <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    6a42:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a46:	8408      	or	AL, #8
    6a48:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    6a4c:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    6a50:	b6da ff7f 	and	A, #65407
    6a54:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    6a58:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a5c:	94f7      	and	AL, #-9
    6a5e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    6a62:	7c04      	lod	X, #4
    6a64:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    6a68:	72da 7c50 	lod	A, #31824
    6a6c:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    6a70:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a74:	94fe      	and	AL, #-2
    6a76:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    6a7a:	0000      	nop
    NOP();
    6a7c:	0000      	nop
    NOP();
    6a7e:	0000      	nop
    MLX4_START();
    6a80:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a84:	8401      	or	AL, #1
    6a86:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    6a8a:	540f      	ret	#16

00006a8c <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    6a8c:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    6a8e:	72ef      	lod	A, S
    6a90:	a080      	add	A, #-128
    6a92:	52d8 0332 	mov	0x332 <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    6a96:	15d7      	call	0x6646 <_LDR_GetState>
    6a98:	8c00      	cmp	AL, #0
    6a9a:	1d06      	jne	0x6aa8 <__premain+0x1c>
    6a9c:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6aa0:	aeda 3212 	cmp	A, #12818
    6aa4:	1901      	je	0x6aa8 <__premain+0x1c>
    6aa6:	003b      	jmp	0x6b1e <__premain+0x92>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
	    if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    6aa8:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    6aac:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    6ab0:	4cb2 72ef 	cmp	YA, #-396266769
    6ab4:	e861 
    6ab6:	1913      	je	0x6ade <__premain+0x52>
		{
			uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76);					/* Get NAD from Flash at STACK_IT Segment */
    6ab8:	7ada bf76 	lod	Y, #49014
    6abc:	72f0      	lod	A, [Y]
    6abe:	5cf2      	usex	A
			if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    6ac0:	8c00      	cmp	AL, #0
    6ac2:	1a82      	jsl	0x6ac8 <__premain+0x3c>
    6ac4:	ac00      	cmp	A, #0
    6ac6:	1d01      	jne	0x6aca <__premain+0x3e>
			{
				u8NAD = 0x7F;													/* Invalid NAD; Use default NAD */
    6ac8:	707f      	lod	A, #127
			}
			stFixedRamNAD.nad = u8NAD;
    6aca:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
			stFixedRamNAD.key = _mlx_NAD_Security_Key;
    6ace:	72da 72ef 	lod	A, #29423
    6ad2:	52d8 0010 	mov	0x10 <__dp_noinit_size>, A
    6ad6:	72da e861 	lod	A, #59489
    6ada:	52d8 0012 	mov	0x12 <__dp_noinit_size+0x2>, A
		}
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    6ade:	54f7      	mov	UPr, #7

        ml_LinInit();
    6ae0:	106e      	call	0x6bbe <_ml_LinInit>
        (void)ml_Connect();
    6ae2:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    6ae6:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6aea:	aeda 3212 	cmp	A, #12818
    6aee:	1d07      	jne	0x6afe <__premain+0x72>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    6af0:	7000      	lod	A, #0
    6af2:	82db 60c4 	callf	0x60c4 <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    6af6:	72da 5c92 	lod	A, #23698
    6afa:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6afe:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6b00:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b02:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b04:	b430      	and	A, #48
    6b06:	1902      	je	0x6b0c <__premain+0x80>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b08:	6000      	lod	AL, #0
    6b0a:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    6b0c:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b10:	b410      	and	A, #16
    6b12:	1975      	je	0x6afe <__premain+0x72>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    6b14:	82db 5bbe 	callf	0x5bbe <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    6b18:	82db 5bee 	callf	0x5bee <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    6b1c:	07f0      	jmp	0x6afe <__premain+0x72>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    6b1e:	54f7      	mov	UPr, #7
    6b20:	5c7f      	dec	S, #128
    6b22:	5401      	ret

00006b24 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    6b24:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    6b26:	7003      	lod	A, #3
    6b28:	5205      	mov	[S-6], A
    6b2a:	70ff      	lod	A, #-1
    6b2c:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    6b2e:	7000      	lod	A, #0
    6b30:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    6b32:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b34:	b401      	and	A, #1
    6b36:	1917      	je	0x6b66 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b38:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6b3a:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b3c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b3e:	b430      	and	A, #48
    6b40:	1902      	je	0x6b46 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b42:	6000      	lod	AL, #0
    6b44:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    6b46:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b48:	b4fb      	and	A, #-5
    6b4a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b4c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b4e:	b401      	and	A, #1
    6b50:	190a      	je	0x6b66 <_mlx_isPowerOk+0x42>
    6b52:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    6b54:	7eda 15e0 	lod	X, #5600
    6b58:	1bff      	djnz	X, 0x6b58 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b5a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b5c:	b401      	and	A, #1
    6b5e:	1903      	je	0x6b66 <_mlx_isPowerOk+0x42>
    6b60:	e0ff      	add	Y, #-1
    6b62:	ecff      	cmp	Y, #-1
    6b64:	1d77      	jne	0x6b54 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    6b66:	7000      	lod	A, #0
    6b68:	5290      	mov	io:0x10 <__dp_noinit_size>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    6b6a:	72ef      	lod	A, S
    6b6c:	a0fe      	add	A, #-2
    6b6e:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
    6b70:	72ef      	lod	A, S
    6b72:	a0fa      	add	A, #-6
    6b74:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
    6b76:	72da 0080 	lod	A, #128
    6b7a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    6b7c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b7e:	a401      	or	A, #1
    6b80:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    DELAY(500);                     /* some delay for sample and hold */
    6b82:	7eda 01f4 	lod	X, #500
    6b86:	1bff      	djnz	X, 0x6b86 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    6b88:	7040      	lod	A, #64
    6b8a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    6b8e:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b90:	a6da 0100 	or	A, #256
    6b94:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    6b96:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b9a:	b440      	and	A, #64
    6b9c:	1d08      	jne	0x6bae <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b9e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6ba0:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6ba2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6ba4:	b430      	and	A, #48
    6ba6:	1977      	je	0x6b96 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6ba8:	6000      	lod	AL, #0
    6baa:	4282      	mov	io:0x2 <_LinCmnd>, AL
    6bac:	07f4      	jmp	0x6b96 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    6bae:	7201      	lod	A, [S-2]
    6bb0:	aeda 0158 	cmp	A, #344
    6bb4:	1e02      	jug	0x6bba <_mlx_isPowerOk+0x96>
        return false;
    6bb6:	7000      	lod	A, #0
    6bb8:	5407      	ret	#8
    }
    else {
        return true;
    6bba:	7001      	lod	A, #1
    }
}
    6bbc:	5407      	ret	#8

00006bbe <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    6bbe:	82db 5e0c 	callf	0x5e0c <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6bc2:	54ca 0000 	pushw	#0
    6bc6:	54ca 0001 	pushw	#1
    6bca:	54ca 0000 	pushw	#0
    6bce:	7001      	lod	A, #1
    6bd0:	82db 5ae0 	callf	0x5ae0 <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    6bd4:	7000      	lod	A, #0
    6bd6:	82db 5ad8 	callf	0x5ad8 <_ml_SetSlewRate>
    6bda:	5c05      	dec	S, #6
    6bdc:	5401      	ret
    6bde:	0000      	nop
    6be0:	5c3e      	dec	S, #63
    6be2:	5c5a      	dec	S, #91
    6be4:	5cb2      	ssg	A
    6be6:	5ce2      	ssex	A
    6be8:	5cf6      	usex	Y
    6bea:	0000      	nop
    6bec:	0001      	jmp	0x6bf0 <_muldivI16_I16byI16byI16+0x2>

00006bee <_muldivI16_I16byI16byI16>:
    6bee:	7a03      	lod	Y, [S-4]
    6bf0:	4831      	muls	YA, A, Y
    6bf2:	7e05      	lod	X, [S-6]
    6bf4:	4c73      	divs	YA, X
    6bf6:	4c73      	divs	YA, X
    6bf8:	4c7b      	dadjs	YA, X
    6bfa:	5401      	ret

00006bfc <_muldivU16_U16byU16byU16>:
    6bfc:	7a03      	lod	Y, [S-4]
    6bfe:	4821      	mulu	YA, A, Y
    6c00:	7e05      	lod	X, [S-6]
    6c02:	4c63      	divu	YA, X
    6c04:	4c63      	divu	YA, X
    6c06:	5401      	ret

00006c08 <_divI32_I32byI16>:
    6c08:	7e03      	lod	X, [S-4]
    6c0a:	1d87      	jnn	0x6c1a <_divI32_I32byU16+0x2>
    6c0c:	5cce      	neg	X
    6c0e:	5e03      	mov	[S-4], X
    6c10:	e000      	add	Y, #0
    6c12:	1d86      	jnn	0x6c20 <_divI32_I32byU16+0x8>
    6c14:	4cf0      	neg	YA
    6c16:	0011      	jmp	0x6c3a <_divU32_U32byU16>

00006c18 <_divI32_I32byU16>:
    6c18:	7e03      	lod	X, [S-4]
    6c1a:	e000      	add	Y, #0
    6c1c:	1d8e      	jnn	0x6c3a <_divU32_U32byU16>
    6c1e:	4cf0      	neg	YA
    6c20:	4ca3      	push	YA
    6c22:	72e6      	lod	A, Y
    6c24:	7800      	lod	Y, #0
    6c26:	7e07      	lod	X, [S-8]
    6c28:	4c63      	divu	YA, X
    6c2a:	4c63      	divu	YA, X
    6c2c:	5201      	mov	[S-2], A
    6c2e:	7203      	lod	A, [S-4]
    6c30:	4c63      	divu	YA, X
    6c32:	4c63      	divu	YA, X
    6c34:	7a01      	lod	Y, [S-2]
    6c36:	4cf0      	neg	YA
    6c38:	5405      	ret	#6

00006c3a <_divU32_U32byU16>:
    6c3a:	4ca3      	push	YA
    6c3c:	72e6      	lod	A, Y
    6c3e:	7800      	lod	Y, #0
    6c40:	7e07      	lod	X, [S-8]
    6c42:	4c63      	divu	YA, X
    6c44:	4c63      	divu	YA, X
    6c46:	5201      	mov	[S-2], A
    6c48:	7203      	lod	A, [S-4]
    6c4a:	4c63      	divu	YA, X
    6c4c:	4c63      	divu	YA, X
    6c4e:	7a01      	lod	Y, [S-2]
    6c50:	5405      	ret	#6

00006c52 <_mulI32_I16byU16>:
    6c52:	a000      	add	A, #0
    6c54:	1d85      	jnn	0x6c60 <_mulU32_U16byU16>
    6c56:	5cc2      	neg	A
    6c58:	7a03      	lod	Y, [S-4]
    6c5a:	4821      	mulu	YA, A, Y
    6c5c:	4cf0      	neg	YA
    6c5e:	5401      	ret

00006c60 <_mulU32_U16byU16>:
    6c60:	7a03      	lod	Y, [S-4]
    6c62:	4821      	mulu	YA, A, Y
    6c64:	5401      	ret

00006c66 <___mulsi3>:
    6c66:	5edf      	push	X
    6c68:	7eef      	lod	X, S
    6c6a:	2808      	sub	X, #8
    6c6c:	1002      	call	0x6c72 <___mulsi3_1>
    6c6e:	7ecf      	pop	X
    6c70:	5401      	ret

00006c72 <___mulsi3_1>:
    6c72:	4c83      	push	D
    6c74:	4cf3      	swap	YA
    6c76:	4806      	mulu	D, A, [X++]
    6c78:	4cf3      	swap	YA
    6c7a:	4847      	macu	D, A, [X]
    6c7c:	2802      	sub	X, #2
    6c7e:	48cf      	asl	D, #16
    6c80:	4847      	macu	D, A, [X]
    6c82:	4c80      	mov	YA, D
    6c84:	4cc3      	pop	D
    6c86:	5401      	ret

00006c88 <___mulsi3_D>:
    6c88:	5edf      	push	X
    6c8a:	7eef      	lod	X, S
    6c8c:	2002      	add	X, #2
    6c8e:	17f1      	call	0x6c72 <___mulsi3_1>
    6c90:	7ecf      	pop	X
    6c92:	5401      	ret

00006c94 <___udivsi3>:
    6c94:	7c00      	lod	X, #0
    6c96:	0002      	jmp	0x6c9c <___udivmodsi4>

00006c98 <___umodsi3>:
    6c98:	7c01      	lod	X, #1
    6c9a:	0000      	nop

00006c9c <___udivmodsi4>:
    6c9c:	5edf      	push	X
    6c9e:	2c00      	cmp	X, #0
    6ca0:	1d06      	jne	0x6cae <___udivmodsi4+0x12>
    6ca2:	7e05      	lod	X, [S-6]
    6ca4:	1d05      	jne	0x6cb0 <___udivmodsi4+0x14>
    6ca6:	7e07      	lod	X, [S-8]
    6ca8:	5e01      	mov	[S-2], X
    6caa:	1024      	call	0x6cf4 <__divU32_U32byU16>
    6cac:	5403      	ret	#4
    6cae:	7e05      	lod	X, [S-6]
    6cb0:	2607      	or	X, [S-8]
    6cb2:	1d03      	jne	0x6cba <___udivmodsi4+0x1e>
    6cb4:	4cfa ffff 	movs	YA, #65535
    6cb8:	5403      	ret	#4
    6cba:	4cc0      	mov	D, YA
    6cbc:	7eef      	lod	X, S
    6cbe:	2808      	sub	X, #8
    6cc0:	4cea 0000 	movu	YA, #0
    6cc4:	54e0      	mov	Cx, #0
    6cc6:	48c0      	asl	D, #1
    6cc8:	4402      	rlc	A
    6cca:	4406      	rlc	Y
    6ccc:	1802      	jc	0x6cd2 <___udivmodsi4+0x36>
    6cce:	4cb7      	cmp	YA, [X]
    6cd0:	1803      	jc	0x6cd8 <___udivmodsi4+0x3c>
    6cd2:	4c37      	sub	YA, [X]
    6cd4:	4c0a 0001 	addu	D, #1
    6cd8:	48c0      	asl	D, #1
    6cda:	4402      	rlc	A
    6cdc:	4406      	rlc	Y
    6cde:	1802      	jc	0x6ce4 <___udivmodsi4+0x48>
    6ce0:	4cb7      	cmp	YA, [X]
    6ce2:	1803      	jc	0x6cea <___udivmodsi4+0x4e>
    6ce4:	4c37      	sub	YA, [X]
    6ce6:	4c0a 0001 	addu	D, #1
    6cea:	1fed      	djnz	Cx, 0x6cc6 <___udivmodsi4+0x2a>
    6cec:	7ecf      	pop	X
    6cee:	1d01      	jne	0x6cf2 <___udivmodsi4+0x56>
    6cf0:	4c80      	mov	YA, D
    6cf2:	5401      	ret

00006cf4 <__divU32_U32byU16>:
    6cf4:	5edf      	push	X
    6cf6:	4ca3      	push	YA
    6cf8:	72e6      	lod	A, Y
    6cfa:	7800      	lod	Y, #0
    6cfc:	7e09      	lod	X, [S-10]
    6cfe:	4c63      	divu	YA, X
    6d00:	4c63      	divu	YA, X
    6d02:	5201      	mov	[S-2], A
    6d04:	7203      	lod	A, [S-4]
    6d06:	4c63      	divu	YA, X
    6d08:	4c63      	divu	YA, X
    6d0a:	7a01      	lod	Y, [S-2]
    6d0c:	7e05      	lod	X, [S-6]
    6d0e:	5407      	ret	#8

00006d10 <_RamBackgroundTest>:
{
	/* Use compare instead of CRC-check !! */
	uint16 *pu16Page;
#if (LINPROT == LIN2J_VALVE_GM)
	(void) u16Page;
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    6d10:	7ada 101e 	lod	Y, #4126
    6d14:	66f0      	lod	YL, [Y]
    6d16:	f6da 0080 	and	Y, #128
    6d1a:	7ee6      	lod	X, Y
    6d1c:	7ada 111e 	lod	Y, #4382
    6d20:	62f0      	lod	AL, [Y]
    6d22:	b6da 0080 	and	A, #128
    6d26:	2ee2      	cmp	X, A
    6d28:	1903      	je	0x6d30 <_RamBackgroundTest+0x20>
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;
    6d2a:	72da 1100 	lod	A, #4352
    6d2e:	0002      	jmp	0x6d34 <_RamBackgroundTest+0x24>
	else
		pu16Page = (uint16 *) C_ADDR_USERPAGE1;
    6d30:	72da 1000 	lod	A, #4096
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;									/* Compare NVRAM User-page #2 against RAM */
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */

	return ( NVRAM_PageVerify( pu16Page) );
    6d34:	82db 9a22 	callf	0x9a22 <_NVRAM_PageVerify>

} /* End of RamBackgroundTest() */
    6d38:	5401      	ret

00006d3a <_FlashBackgroundTest>:
#define C_FLASH_CRC_FAILED			0
#define C_FLASH_CRC_OK				1
#define C_FLASH_CRC_CALCULATING		2

uint16 FlashBackgroundTest( uint16 u16Size)
{
    6d3a:	5807      	inc	S, #8
    6d3c:	7ee2      	lod	X, A
	uint16 u16Result = C_FLASH_CRC_CALCULATING;
    6d3e:	4cd3      	swap	D
    6d40:	48cf      	asl	D, #16
    6d42:	4c0a 0002 	addu	D, #2
	static uint16 *pu16Segment = (uint16 *) FLASH_START_ADDR;
	static uint16 u16FlashCRC = 0;

	if ( u16Size == 0U )
    6d46:	ac00      	cmp	A, #0
    6d48:	1d06      	jne	0x6d56 <_FlashBackgroundTest+0x1c>
	{
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6d4a:	72da 4000 	lod	A, #16384
    6d4e:	52d8 0118 	mov	0x118 <_g_i16SupplyVoltage+0x2>, A
		return ( u16Result );
    6d52:	7002      	lod	A, #2
    6d54:	5409      	ret	#10
	}
	if ( pu16Segment == (uint16 *) FLASH_START_ADDR )
    6d56:	7ad8 0118 	lod	Y, 0x118 <_g_i16SupplyVoltage+0x2>
    6d5a:	eeda 4000 	cmp	Y, #16384
    6d5e:	1d03      	jne	0x6d66 <_FlashBackgroundTest+0x2c>
	{
		u16FlashCRC = 0xFFFF;													/* Initialise the CRC preset with 0xFFFF */
    6d60:	70ff      	lod	A, #-1
    6d62:	52d8 011a 	mov	0x11a <_g_i16SupplyVoltage+0x4>, A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
    6d66:	72e6      	lod	A, Y
    6d68:	a2ee      	add	A, X
    6d6a:	aeda c000 	cmp	A, #49152
    6d6e:	1a04      	jule	0x6d78 <_FlashBackgroundTest+0x3e>
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
    6d70:	72da c000 	lod	A, #49152
    6d74:	7ee2      	lod	X, A
    6d76:	2ae6      	sub	X, Y
	}
	for ( ; u16Size > 0; u16Size-- )
    6d78:	2c00      	cmp	X, #0
    6d7a:	192b      	je	0x6dd2 <_FlashBackgroundTest+0x98>
    6d7c:	5a03      	mov	[S-4], Y
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
    6d7e:	7a03      	lod	Y, [S-4]
    6d80:	eeda bf4e 	cmp	Y, #48974
    6d84:	1920      	je	0x6dc6 <_FlashBackgroundTest+0x8c>
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
    6d86:	72f0      	lod	A, [Y]
    6d88:	5205      	mov	[S-6], A
			for ( u8Count = 16; u8Count > 0; u8Count-- )
    6d8a:	7810      	lod	Y, #16
    6d8c:	5a07      	mov	[S-8], Y
    6d8e:	7ad8 011a 	lod	Y, 0x11a <_g_i16SupplyVoltage+0x4>
			{
				uint16 u16XorFlag = !!(u16FlashCRC & 0x8000);
    6d92:	72e6      	lod	A, Y
    6d94:	b6da 8000 	and	A, #32768
    6d98:	5201      	mov	[S-2], A
    6d9a:	1902      	je	0x6da0 <_FlashBackgroundTest+0x66>
    6d9c:	7001      	lod	A, #1
    6d9e:	5201      	mov	[S-2], A
				u16FlashCRC = (u16FlashCRC << 1);
    6da0:	4426      	asl	Y
				if ( u16Data & 0x8000 )
    6da2:	7205      	lod	A, [S-6]
    6da4:	ac00      	cmp	A, #0
    6da6:	1e81      	jsge	0x6daa <_FlashBackgroundTest+0x70>
				{
					u16FlashCRC++;
    6da8:	e001      	add	Y, #1
				}
				if ( u16XorFlag )
    6daa:	7201      	lod	A, [S-2]
    6dac:	1902      	je	0x6db2 <_FlashBackgroundTest+0x78>
				{
					u16FlashCRC ^= POLY;
    6dae:	feda 1021 	xor	Y, #4129
				}
				u16Data <<= 1;
    6db2:	7205      	lod	A, [S-6]
    6db4:	4422      	asl	A
    6db6:	5205      	mov	[S-6], A
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
			for ( u8Count = 16; u8Count > 0; u8Count-- )
    6db8:	6207      	lod	AL, [S-8]
    6dba:	80ff      	add	AL, #-1
    6dbc:	5cf2      	usex	A
    6dbe:	5207      	mov	[S-8], A
    6dc0:	1d68      	jne	0x6d92 <_FlashBackgroundTest+0x58>
    6dc2:	5ad8 011a 	mov	0x11a <_g_i16SupplyVoltage+0x4>, Y
					u16FlashCRC ^= POLY;
				}
				u16Data <<= 1;
			}
		}
		pu16Segment++;
    6dc6:	7203      	lod	A, [S-4]
    6dc8:	a002      	add	A, #2
    6dca:	5203      	mov	[S-4], A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
	}
	for ( ; u16Size > 0; u16Size-- )
    6dcc:	1bd8      	djnz	X, 0x6d7e <_FlashBackgroundTest+0x44>
    6dce:	52d8 0118 	mov	0x118 <_g_i16SupplyVoltage+0x2>, A
			}
		}
		pu16Segment++;
	}

	if ( (uint16) pu16Segment >= FLASH_END_ADDR )
    6dd2:	72d8 0118 	lod	A, 0x118 <_g_i16SupplyVoltage+0x2>
    6dd6:	aeda bfff 	cmp	A, #49151
    6dda:	1a14      	jule	0x6e04 <_FlashBackgroundTest+0xca>
	{
		/* CRC fully calculated, check values */
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6ddc:	7ada 4000 	lod	Y, #16384
    6de0:	5ad8 0118 	mov	0x118 <_g_i16SupplyVoltage+0x2>, Y
		if ( *(uint16 *) FLASH_CRC_ADDR != 0 )									/* Flash/ROM Checksum programmed? */
    6de4:	7ada bf4e 	lod	Y, #48974
    6de8:	72f0      	lod	A, [Y]
    6dea:	190c      	je	0x6e04 <_FlashBackgroundTest+0xca>
		{
			if ( *(uint16 *) FLASH_CRC_ADDR != u16FlashCRC )
    6dec:	aed8 011a 	cmp	A, 0x11a <_g_i16SupplyVoltage+0x4>
    6df0:	1905      	je	0x6dfc <_FlashBackgroundTest+0xc2>
			{
				u16Result = C_FLASH_CRC_FAILED;
    6df2:	4cd3      	swap	D
    6df4:	48cf      	asl	D, #16
    6df6:	4c0a 0000 	addu	D, #0
    6dfa:	0004      	jmp	0x6e04 <_FlashBackgroundTest+0xca>
			}
			else
			{
				u16Result = C_FLASH_CRC_OK;
    6dfc:	4cd3      	swap	D
    6dfe:	48cf      	asl	D, #16
    6e00:	4c0a 0001 	addu	D, #1
			}
		}
	}

	return ( u16Result );
    6e04:	4c88      	mov	A, DL

} /* End of FlashBackgroundTest() */
    6e06:	5409      	ret	#10

00006e08 <_noinit_section_init>:
 * noinit_section_init
 * MMP151118-2 *
 * ****************************************************************************	*/
void noinit_section_init(void)
{
	g_e8MotorCtrlMode = (uint8) C_MOTOR_CTRL_STOP;
    6e08:	6000      	lod	AL, #0
    6e0a:	41ec      	mov	dp:0xec <__bss_dp_end>, AL
	//g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;								/* Control-flag Stall-detector enabled [WD] */;
	g_u8MotorHoldingCurrEna = FALSE;
    6e0c:	41ef      	mov	dp:0xef <_g_u8MotorHoldingCurrEna>, AL
	g_u16ActualPosition = 32767U;
    6e0e:	72da 7fff 	lod	A, #32767
    6e12:	51f0      	mov	dp:0xf0 <_g_u16ActualPosition>, A
	g_u16TargetPosition = 65535U;
    6e14:	70ff      	lod	A, #-1
    6e16:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
	g_u8MotorCtrlSpeed = (uint8) C_DEFAULT_MOTOR_SPEED;
    6e18:	6003      	lod	AL, #3
    6e1a:	41f4      	mov	dp:0xf4 <_g_u8MotorCtrlSpeed>, AL
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    6e1c:	6000      	lod	AL, #0
    6e1e:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
	g_u16CalibTravel = C_EXV_DEF_TRAVEL;									/* Number of steps between two end-stops */
    6e20:	658e      	lod	YL, dp:0x8e <_g_NvramUser+0x34>
    6e22:	44b6      	lsr	Y, #2
    6e24:	44b6      	lsr	Y, #2
    6e26:	4436      	lsr	Y
    6e28:	f403      	and	Y, #3
    6e2a:	716c      	lod	A, dp:0x6c <_g_NvramUser+0x12>
    6e2c:	ec00      	cmp	Y, #0
    6e2e:	1b03      	jsle	0x6e36 <_noinit_section_init+0x2e>
    6e30:	46e9      	mov	Cx, YL
    6e32:	4422      	asl	A
    6e34:	1ffe      	djnz	Cx, 0x6e32 <_noinit_section_init+0x2a>
    6e36:	51f6      	mov	dp:0xf6 <_g_u16CalibTravel>, A

	/* MotorDriver.c variables */
	g_u16ActuatorActPos = 0;
    6e38:	7000      	lod	A, #0
    6e3a:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = 0;
    6e3c:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
    6e3e:	5401      	ret

00006e40 <_RteExv2Lin>:
} /* End of noinit_section_init() */

void RteExv2Lin(void)
{
    6e40:	580b      	inc	S, #12

//	g_e8CalibrationStep = (uint8)C_CALIB_DONE;

//	g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;

	if (g_e8CalibrationStep == (uint8)C_CALIB_NONE)
    6e42:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    6e44:	1903      	je	0x6e4c <_RteExv2Lin+0xc>
	{
		g_e8EXVStatusInitStat = C_STATUS_NOT_INIT;
	}
	else if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6e46:	8c0a      	cmp	AL, #10
    6e48:	1904      	je	0x6e52 <_RteExv2Lin+0x12>
		g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;

	}
	else
	{
		g_e8EXVStatusInitStat = C_STATUS_INIT_BUSY;
    6e4a:	6001      	lod	AL, #1
    6e4c:	42d8 00fd 	mov	0xfd <_g_e8EXVStatusInitStat>, AL
	}

	if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6e50:	0009      	jmp	0x6e64 <_RteExv2Lin+0x24>
	{
		g_e8EXVStatusInitStat = C_STATUS_NOT_INIT;
	}
	else if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
	{
		g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;
    6e52:	6002      	lod	AL, #2
    6e54:	42d8 00fd 	mov	0xfd <_g_e8EXVStatusInitStat>, AL
		g_e8EXVStatusInitStat = C_STATUS_INIT_BUSY;
	}

	if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
	{
		if(g_u8StallOcc == TRUE)
    6e58:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    6e5a:	8c01      	cmp	AL, #1
    6e5c:	1d03      	jne	0x6e64 <_RteExv2Lin+0x24>
		{
			g_e8EXVErrorBlock = TRUE;
    6e5e:	4118      	mov	dp:0x18 <__data_dp_start>, AL
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban,
    6e60:	6002      	lod	AL, #2
    6e62:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
		}
	}

	//TODO need to add the indetermint, ban debug
	if(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_OVER)
    6e64:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    6e66:	8c02      	cmp	AL, #2
    6e68:	1d02      	jne	0x6e6e <_RteExv2Lin+0x2e>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_VOLTAGE;
    6e6a:	6001      	lod	AL, #1
    6e6c:	0020      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_UNDER)
    6e6e:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    6e70:	8c01      	cmp	AL, #1
    6e72:	1d02      	jne	0x6e78 <_RteExv2Lin+0x38>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_UNDER_VLOTAGE;
    6e74:	6002      	lod	AL, #2
    6e76:	001b      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if((g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_A) || (g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_B))
    6e78:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e7a:	8cea      	cmp	AL, #-22
    6e7c:	1903      	je	0x6e84 <_RteExv2Lin+0x44>
    6e7e:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e80:	8ceb      	cmp	AL, #-21
    6e82:	1d02      	jne	0x6e88 <_RteExv2Lin+0x48>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_COIL_SHORT;
    6e84:	6003      	lod	AL, #3
    6e86:	0013      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_C)
    6e88:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e8a:	8cec      	cmp	AL, #-20
    6e8c:	1d02      	jne	0x6e92 <_RteExv2Lin+0x52>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_COIL_OPEN;
    6e8e:	6004      	lod	AL, #4
    6e90:	000e      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorOverTemperature == (uint8)C_ERR_OTEMP_YES)
    6e92:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    6e94:	8c01      	cmp	AL, #1
    6e96:	1d02      	jne	0x6e9c <_RteExv2Lin+0x5c>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_TEMP_SHUTDOWN;
    6e98:	6005      	lod	AL, #5
    6e9a:	0009      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if(g_e8EXVErrorBlock == TRUE)
    6e9c:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    6e9e:	8c01      	cmp	AL, #1
    6ea0:	1d02      	jne	0x6ea6 <_RteExv2Lin+0x66>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_UNEXPECT_STALL;
    6ea2:	6006      	lod	AL, #6
    6ea4:	0004      	jmp	0x6eae <_RteExv2Lin+0x6e>
	}
	else if(g_e8WarningOverTemperature == C_WARNING_OTEMP_YES)
    6ea6:	611a      	lod	AL, dp:0x1a <_g_e8WarningOverTemperature>
    6ea8:	8c01      	cmp	AL, #1
    6eaa:	1d04      	jne	0x6eb4 <_RteExv2Lin+0x74>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_TEMP_WARNING;
    6eac:	600a      	lod	AL, #10
    6eae:	42d8 0101 	mov	0x101 <_g_e8EXVStatusFaultState>, AL
    6eb2:	0003      	jmp	0x6eba <_RteExv2Lin+0x7a>
	}
	else
	{
		g_e8EXVStatusFaultState = C_STATUS_NO_FAULT;
    6eb4:	6400      	lod	YL, #0
    6eb6:	46d8 0101 	mov	0x101 <_g_e8EXVStatusFaultState>, YL
	}

	//if(((g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM) && (g_e8EXVStatusFaultState != C_STATUS_NO_FAULT)) || ((g_e8CalibrationStep > C_CALIB_NONE) && (g_e8CalibrationStep < C_CALIB_DONE) && ((g_e8ErrorVoltage != C_ERR_VOLTAGE_IN_RANGE) || (g_e8ErrorOverTemperature == (uint8)C_ERR_OTEMP_YES))))//coil open/short/over temp/stall,ov/uv, changed to un-initialized
	if((g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM) && (g_e8EXVStatusFaultState != C_STATUS_NO_FAULT))//coil open/short/stall, changed to un-initialized
    6eba:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    6ebc:	8c02      	cmp	AL, #2
    6ebe:	1d0d      	jne	0x6eda <_RteExv2Lin+0x9a>
    6ec0:	62d8 0101 	lod	AL, 0x101 <_g_e8EXVStatusFaultState>
    6ec4:	190a      	je	0x6eda <_RteExv2Lin+0x9a>
	{
		g_e8CalibrationStep = C_CALIB_NONE;
    6ec6:	6000      	lod	AL, #0
    6ec8:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
		g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    6eca:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    6ecc:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
		g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    6ece:	42d8 0106 	mov	0x106 <_g_e8CalibPostMotorRequest>, AL
		g_u16TargetPosition = g_u16ActualPosition;
    6ed2:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    6ed4:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
		g_u16ActuatorActPos = g_u16ActualPosition;
    6ed6:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
		g_u16ActuatorTgtPos = g_u16TargetPosition;
    6ed8:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
	}

	if((g_e8EXVStatusInitStat == (uint8)C_STATUS_INIT_BUSY) || (g_e8EXVStatusInitStat == (uint8)C_STATUS_INIT_DONE))
    6eda:	62d8 00fd 	lod	AL, 0xfd <_g_e8EXVStatusInitStat>
    6ede:	420b      	mov	[S-12], AL
    6ee0:	80ff      	add	AL, #-1
    6ee2:	8c01      	cmp	AL, #1
    6ee4:	1a01      	jule	0x6ee8 <_RteExv2Lin+0xa8>
    6ee6:	003c      	jmp	0x6f60 <_RteExv2Lin+0x120>
	{
		if(g_u16ActualPosition <= C_EXV_ZERO_POS)
    6ee8:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    6eea:	44b2      	lsr	A, #2
    6eec:	44b2      	lsr	A, #2
    6eee:	4432      	lsr	A
    6ef0:	b403      	and	A, #3
    6ef2:	5207      	mov	[S-8], A
    6ef4:	7c64      	lod	X, #100
    6ef6:	ac00      	cmp	A, #0
    6ef8:	1b03      	jsle	0x6f00 <_RteExv2Lin+0xc0>
    6efa:	42e9      	mov	Cx, AL
    6efc:	442e      	asl	X
    6efe:	1ffe      	djnz	Cx, 0x6efc <_RteExv2Lin+0xbc>
    6f00:	79f0      	lod	Y, dp:0xf0 <_g_u16ActualPosition>
    6f02:	5a01      	mov	[S-2], Y
    6f04:	eeee      	cmp	Y, X
    6f06:	1e02      	jug	0x6f0c <_RteExv2Lin+0xcc>
		{
			g_u16EXVStatusCurrentPositon = 0;
    6f08:	7000      	lod	A, #0
    6f0a:	0010      	jmp	0x6f2c <_RteExv2Lin+0xec>
		}
		else if(g_u16ActualPosition >= C_EXV_POSITION_STD + C_EXV_ZERO_POS)
    6f0c:	7ada 0120 	lod	Y, #288
    6f10:	7207      	lod	A, [S-8]
    6f12:	ac00      	cmp	A, #0
    6f14:	1b03      	jsle	0x6f1c <_RteExv2Lin+0xdc>
    6f16:	42e9      	mov	Cx, AL
    6f18:	4426      	asl	Y
    6f1a:	1ffe      	djnz	Cx, 0x6f18 <_RteExv2Lin+0xd8>
    6f1c:	5a09      	mov	[S-10], Y
    6f1e:	72e6      	lod	A, Y
    6f20:	a2ee      	add	A, X
    6f22:	7a01      	lod	Y, [S-2]
    6f24:	eee2      	cmp	Y, A
    6f26:	1805      	jc	0x6f32 <_RteExv2Lin+0xf2>
		{
			g_u16EXVStatusCurrentPositon = 0x3FF;
    6f28:	72da 03ff 	lod	A, #1023
    6f2c:	52d8 00fe 	mov	0xfe <_g_u16EXVStatusCurrentPositon>, A
    6f30:	540d      	ret	#14
		}
		else
		{
			g_u16EXVStatusCurrentPositon = ((uint32)(g_u16ActualPosition - C_EXV_ZERO_POS)*1023+C_EXV_POSITION_STD/2)/C_EXV_POSITION_STD;
    6f32:	7201      	lod	A, [S-2]
    6f34:	aaee      	sub	A, X
    6f36:	4802 03ff 	mulu	D, A, #1023
    6f3a:	7aef      	lod	Y, S
    6f3c:	e0fa      	add	Y, #-6
    6f3e:	4c85      	mov	[Y], D
    6f40:	7209      	lod	A, [S-10]
    6f42:	4432      	lsr	A
    6f44:	4cc8      	movu	D, A
    6f46:	4c80      	mov	YA, D
    6f48:	a205      	add	A, [S-6]
    6f4a:	f203      	adc	Y, [S-4]
    6f4c:	5205      	mov	[S-6], A
    6f4e:	5a03      	mov	[S-4], Y
    6f50:	7a09      	lod	Y, [S-10]
    6f52:	4cc9      	movu	D, Y
    6f54:	4c83      	push	D
    6f56:	7209      	lod	A, [S-10]
    6f58:	7a07      	lod	Y, [S-8]
    6f5a:	169c      	call	0x6c94 <___udivsi3>
    6f5c:	5c03      	dec	S, #4
    6f5e:	07e6      	jmp	0x6f2c <_RteExv2Lin+0xec>
		}
	}
	else if(g_e8EXVStatusInitStat == (uint8)C_STATUS_NOT_INIT)
    6f60:	620b      	lod	AL, [S-12]
    6f62:	1d03      	jne	0x6f6a <_RteExv2Lin+0x12a>
	{
		g_u16EXVStatusCurrentPositon = 0;
    6f64:	7800      	lod	Y, #0
    6f66:	5ad8 00fe 	mov	0xfe <_g_u16EXVStatusCurrentPositon>, Y
    6f6a:	540d      	ret	#14

00006f6c <_UpdateMotorSpeed>:
}

//In default MLX, update speed during motor start or receive motor speed change command(will not excute other command)
//In updated MLX by Ban, update speed during motor start and receive motor speed change command(doesn't impact other command)
void UpdateMotorSpeed(void)
{
    6f6c:	5809      	inc	S, #10
	uint8 u8MotorSpeedIdx;
	if(g_u8TorqueBoostRequest == 0)//normal torque
    6f6e:	62d8 010a 	lod	AL, 0x10a <_g_u8TorqueBoostRequest>
    6f72:	4209      	mov	[S-10], AL
    6f74:	1d0c      	jne	0x6f8e <_UpdateMotorSpeed+0x22>
	{
		g_u8MotorCtrlSpeed = (uint8) C_DEFAULT_MOTOR_SPEED;//speed 1
    6f76:	6003      	lod	AL, #3
    6f78:	41f4      	mov	dp:0xf4 <_g_u8MotorCtrlSpeed>, AL
		u8MotorSpeedIdx = (g_u8MotorCtrlSpeed & 0x07);
    6f7a:	7003      	lod	A, #3
		g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    6f7c:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
		g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[u8MotorSpeedIdx];
    6f7e:	7ad8 028a 	lod	Y, 0x28a <_g_au16MotorSpeedRPS+0x6>
    6f82:	5ad8 026c 	mov	0x26c <_g_u16MotorSpeedRPS>, Y
		g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[u8MotorSpeedIdx];
    6f86:	7ed8 027a 	lod	X, 0x27a <_g_au16MotorSpeedCommutTimerPeriod+0x6>
    6f8a:	5d54      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, X
    6f8c:	540b      	ret	#12
	}
	else//boost torque, reduce the speed
	{
		g_u8MotorCtrlSpeed = (uint8) C_MOTOR_SPEED_MID_LOW;//Speed 0
    6f8e:	6002      	lod	AL, #2
    6f90:	41f4      	mov	dp:0xf4 <_g_u8MotorCtrlSpeed>, AL
		u8MotorSpeedIdx = (g_u8MotorCtrlSpeed & 0x07);
    6f92:	7002      	lod	A, #2
		g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    6f94:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6f96:	7192      	lod	A, dp:0x92 <_g_NvramUser+0x38>
    6f98:	a990      	sub	A, dp:0x90 <_g_NvramUser+0x36>
    6f9a:	5203      	mov	[S-4], A
    6f9c:	6609      	lod	YL, [S-10]
    6f9e:	5cf6      	usex	Y
    6fa0:	5a01      	mov	[S-2], Y
    6fa2:	7c64      	lod	X, #100
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    6fa4:	7201      	lod	A, [S-2]
    6fa6:	7a03      	lod	Y, [S-4]
    6fa8:	4821      	mulu	YA, A, Y
    6faa:	4c63      	divu	YA, X
    6fac:	4c63      	divu	YA, X
    6fae:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6fb0:	7192      	lod	A, dp:0x92 <_g_NvramUser+0x38>
    6fb2:	aaee      	sub	A, X
    6fb4:	5207      	mov	[S-8], A
		uint16 u16RPM = NVRAM_SPEED1 - muldivU16_U16byU16byU16((NVRAM_SPEED1 - NVRAM_SPEED0),g_u8TorqueBoostRequest,100);
		uint32 u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60), g_u16MotorMicroStepsPerMechRotation);
    6fb6:	7ad8 0270 	lod	Y, 0x270 <_g_u16MotorMicroStepsPerMechRotation>
    6fba:	5adf      	push	Y
    6fbc:	4ce2 2c40 	mov	YA, #105000000
    6fc0:	0642 
    6fc2:	163b      	call	0x6c3a <_divU32_U32byU16>
    6fc4:	4cc0      	mov	D, YA
    6fc6:	5c01      	dec	S, #2
    6fc8:	7207      	lod	A, [S-8]
    6fca:	a01e      	add	A, #30
    6fcc:	4cf2      	usex	YA
    6fce:	7c3c      	lod	X, #60
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6fd0:	4c63      	divu	YA, X
    6fd2:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6fd4:	52d8 026c 	mov	0x26c <_g_u16MotorSpeedRPS>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6fd8:	4c80      	mov	YA, D
    6fda:	7e07      	lod	X, [S-8]
    6fdc:	4c63      	divu	YA, X
    6fde:	4c63      	divu	YA, X
    6fe0:	5201      	mov	[S-2], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6fe2:	a0ff      	add	A, #-1
    6fe4:	5154      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, A
    6fe6:	540b      	ret	#12

00006fe8 <_main>:
 *	S. (Optional) Determine actuator position
 *	T. (Watch-dog Reset) Start actuator (if needed)
 *	U. Main application loop
 * ****************************************************************************	*/
int16 main( void)
{
    6fe8:	581f      	inc	S, #32
	/* *************************************************** */
	/* *** A. Initialise background schedule (Task-ID) *** */
	/* *************************************************** */
	uint8 u8BackgroundSchedulerTaskID = 0;
    6fea:	7000      	lod	A, #0
    6fec:	521f      	mov	[S-32], A

#if _SUPPORT_CRASH_RECOVERY
	/* **************************************************************** */
	/* *** B. (Optional) Check crash-recovery (fatal-error handler) *** */
	/* **************************************************************** */
	if ( bistResetInfo == C_CHIP_STATE_FATAL_CRASH_RECOVERY )
    6fee:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    6ff2:	aeda 1872 	cmp	A, #6258
    6ff6:	1d0d      	jne	0x7012 <_main+0x2a>
	{
#if LIN_COMM
		g_u8LinInFrameBufState = C_LIN_IN_FREE;
    6ff8:	6400      	lod	YL, #0
    6ffa:	46d8 011e 	mov	0x11e <_g_u8LinInFrameBufState>, YL
#endif /* LIN_COMM */
		if ( (g_e8StallDetectorEna != (uint8) C_STALLDET_NONE) && ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0)) /*lint !e845 */
    6ffe:	61ee      	lod	AL, dp:0xee <_g_e8StallDetectorEna>
    7000:	1d01      	jne	0x7004 <_main+0x1c>
    7002:	00ca      	jmp	0x7198 <_main+0x1b0>
    7004:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7006:	b401      	and	A, #1
    7008:	1d01      	jne	0x700c <_main+0x24>
    700a:	00c6      	jmp	0x7198 <_main+0x1b0>
		{
			/* Actuator is active; clear motor-raw-current moving-average buffer */
			MotorDriverCurrentMeasureInit();
    700c:	82db 913e 	callf	0x913e <_MotorDriverCurrentMeasureInit>
    7010:	00c3      	jmp	0x7198 <_main+0x1b0>
#if WATCHDOG == DISABLED
		WD_CTRL = 0;															/* Disable digital Watch-dog */
		AWD_CTRL = 0x8000;														/* Disable analogue Watch-dog */
#endif /* WATCHDOG == DISABLED */
#if WATCHDOG == ENABLED
		WD_T = WatchDog_PeriodOf100ms;											/* Initialise the (Digital) watch-dog comparator to 100ms */
    7012:	60c3      	lod	AL, #-61
    7014:	4282      	mov	io:0x2 <_LinCmnd>, AL
		WD_CTRL = WatchDog_ModeTimer;											/* Define the mode and start the watchdog */
    7016:	6012      	lod	AL, #18
    7018:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
 *
 *****************************************************************************
 */
__MLX_TEXT__  static INLINE void awdg_init (uint8 prescaler, uint8 timer)
{
    AWD_CTRL = ((uint16)(prescaler & 3) << 8) | timer;
    701a:	72da 019c 	lod	A, #412
    701e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
		awdg_init( AWDG_DIV_16, C_AWD_PERIOD_250MS);
		/* Maximum Watch-dog period */
#endif /* WATCHDOG == ENABLED */
#if MCU_ASSP_MODE
		ANA_OUTL |= ASSP;														/* ASSP-mode */
    7020:	72d8 28d4 	lod	A, 0x28d4 <__io__+0xd4>
    7024:	a401      	or	A, #1
    7026:	52d8 28d4 	mov	0x28d4 <__io__+0xd4>, A

#if _SUPPORT_TESTMODE_OFF
		/* ******************************************** */
		/* *** D. (Optional) Chip test-mode disable *** */
		/* ******************************************** */
		CONTROL |= OUTA_WE;														/* Grant access to ANA_OUTx registers */
    702a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    702e:	8408      	or	AL, #8
    7030:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
		ANA_OUTA |= TEST_MODE_DIS;												/* Disable test-mode */
    7034:	72d8 201c 	lod	A, 0x201c <__ep__+0x101c>
    7038:	a6da 0080 	or	A, #128
    703c:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
		CONTROL &= ~OUTA_WE;
    7040:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7044:	94f7      	and	AL, #-9
    7046:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
#endif /* MCU_ASSP_MODE */
#endif /* _DEBUG_SPI */
#endif /* _DEBUG */

		/* Application mode */
		SET_PRIORITY(0);
    704a:	54f0      	mov	UPr, #0
		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    704c:	6002      	lod	AL, #2
    704e:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
		/* ******************************* */
		/* *** E. Load user NVRAM page *** */
		/* ******************************* */
		NVRAM_LoadUserPage();													/* Load User NVRAM storage parameters */
    7050:	82db 9b46 	callf	0x9b46 <_NVRAM_LoadUserPage>

#if USE_MULTI_PURPOSE_BUFFER
		g_MPBuf.u8Type = (uint8) C_MP_BUF_NONE;
    7054:	6400      	lod	YL, #0
    7056:	46d8 0154 	mov	0x154 <_g_MPBuf>, YL
		g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;
    705a:	46d8 0155 	mov	0x155 <_g_MPBuf+0x1>, YL
#endif /* USE_MULTI_PURPOSE_BUFFER */

		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )						/* MMP151118 - Begin */
    705e:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7062:	aeda 5c92 	cmp	A, #23698
    7066:	1901      	je	0x706a <_main+0x82>
		{
			noinit_section_init();
    7068:	16cf      	call	0x6e08 <_noinit_section_init>
		}																		/* MMP151118 - End */
		g_e8StallDetectorEna = C_STALLDET_NONE;
    706a:	6000      	lod	AL, #0
    706c:	41ee      	mov	dp:0xee <_g_e8StallDetectorEna>, AL
		if ( g_NvramUser.StallDetectorEna )
    706e:	616a      	lod	AL, dp:0x6a <_g_NvramUser+0x10>
    7070:	421d      	mov	[S-30], AL
    7072:	44b0      	lsr	AL, #2
    7074:	4430      	lsr	AL
    7076:	b401      	and	A, #1
    7078:	1902      	je	0x707e <_main+0x96>
		{
#if _SUPPORT_STALLDET_H
			g_e8StallDetectorEna |= C_STALLDET_H;								/* Control-flag Stall-detector "H" and "A" enabled */
#else  /* _SUPPORT_STALLDET_H */
			g_e8StallDetectorEna |= C_STALLDET_A;								/* Control-flag Stall-detector "A" enabled */
    707a:	6001      	lod	AL, #1
    707c:	41ee      	mov	dp:0xee <_g_e8StallDetectorEna>, AL
#endif /* _SUPPORT_STALLDET_H */
		}
		if ( NVRAM_STALL_O )
    707e:	61c9      	lod	AL, dp:0xc9 <__bss_dp_size+0x19>
    7080:	44b2      	lsr	A, #2
    7082:	44b2      	lsr	A, #2
    7084:	44b2      	lsr	A, #2
    7086:	b401      	and	A, #1
    7088:	1903      	je	0x7090 <_main+0xa8>
		{
			g_e8StallDetectorEna |= C_STALLDET_O;								/* Control-flag Stall-detector "O" enabled */
    708a:	61ee      	lod	AL, dp:0xee <_g_e8StallDetectorEna>
    708c:	8402      	or	AL, #2
    708e:	41ee      	mov	dp:0xee <_g_e8StallDetectorEna>, AL
		}

		//g_e8StallDetectorEna = C_STALLDET_NONE;//Ban for GM CV, stall O is enabled and not programmable. TODO
		g_u8MotorHoldingCurrEna = g_NvramUser.MotorHoldingCurrentEna;			/* Control-flag motor Holding-current enabled */
    7090:	621d      	lod	AL, [S-30]
    7092:	44b0      	lsr	AL, #2
    7094:	44b0      	lsr	AL, #2
    7096:	b401      	and	A, #1
    7098:	41ef      	mov	dp:0xef <_g_u8MotorHoldingCurrEna>, AL

		/* ********************************************** */
		/* *** F. Initialise Error-logging management *** */
		/* ********************************************** */
		ErrorLogInit();
    709a:	82db 8c3e 	callf	0x8c3e <_ErrorLogInit>

		/* Log Watch-dog reset */
		if ( bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET )						/* LIN-command chip reset use WD; No need to log */
    709e:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    70a2:	aeda 3072 	cmp	A, #12402
    70a6:	1918      	je	0x70d8 <_main+0xf0>
		{
			if ( (CONTROL & WD_BOOT) || (AWD_CTRL & AWD_RST) )
    70a8:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    70ac:	8c00      	cmp	AL, #0
    70ae:	1a83      	jsl	0x70b6 <_main+0xce>
    70b0:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    70b2:	ac00      	cmp	A, #0
    70b4:	1e91      	jsge	0x70d8 <_main+0xf0>
			{
				if ( CONTROL & WD_BOOT )
    70b6:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    70ba:	8c00      	cmp	AL, #0
    70bc:	1e89      	jsge	0x70d0 <_main+0xe8>
				{
					if ( AWD_CTRL & AWD_RST )
    70be:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    70c0:	ac00      	cmp	A, #0
    70c2:	1e83      	jsge	0x70ca <_main+0xe2>
					{
						SetLastError( (uint8) C_ERR_WD_AWD_RST);				/* Both Analogue & Digital Watch-dog reset */
    70c4:	72da 00f3 	lod	A, #243
    70c8:	0005      	jmp	0x70d4 <_main+0xec>
					}
					else
					{
						SetLastError( (uint8) C_ERR_WD_RST);					/* Digital Watch-dog reset */
    70ca:	72da 00f1 	lod	A, #241
    70ce:	0002      	jmp	0x70d4 <_main+0xec>
					}
				}
				else
				{
					SetLastError( (uint8) C_ERR_AWD_RST);						/* Analogue Watch-dog reset */
    70d0:	72da 00f2 	lod	A, #242
    70d4:	82db 8c66 	callf	0x8c66 <_SetLastError>
		}

		/* ******************************************* */
		/* *** G. Initialise chip (H/W) Diagnostic *** */
		/* ******************************************* */
		DiagnosticsInit();														/* Initialise Diagnostic */
    70d8:	82db 8b5e 	callf	0x8b5e <_DiagnosticsInit>

		/* ************************* */
		/* *** H. Initialise ADC *** */
		/* ************************* */
		ADC_Init();																/* Initialise ADC */
    70dc:	82db 87dc 	callf	0x87dc <_ADC_Init>

		/* ********************************** */
		/* *** I. Initialise Motor-driver *** */
		/* ********************************** */
		MotorDriverInit();														/* Initialise Motor-Driver */
    70e0:	82db 8d22 	callf	0x8d22 <_MotorDriverInit>

		/* *************************************** */
		/* *** J. Initialise rewind management *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0) )
    70e4:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    70e8:	aeda 5c92 	cmp	A, #23698
    70ec:	1907      	je	0x70fc <_main+0x114>
    70ee:	61a5      	lod	AL, dp:0xa5 <_g_NvramUser+0x4b>
    70f0:	8c00      	cmp	AL, #0
    70f2:	1e84      	jsge	0x70fc <_main+0x114>
    70f4:	61c2      	lod	AL, dp:0xc2 <__bss_dp_size+0x12>
    70f6:	1902      	je	0x70fc <_main+0x114>
#else  /* _SUPPORT_WD_RST_RECOVERY */
			if ( (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
			{
				g_u8RewindFlags = (uint8) (C_REWIND_STALL_DETECT | C_REWIND_DIRECTION_AUTO);/* After POR: Enable Rewind and set auto-direction */
    70f8:	6006      	lod	AL, #6
    70fa:	4124      	mov	dp:0x24 <__data_dp_size>, AL
			}

		SET_PRIORITY(7);
    70fc:	54f7      	mov	UPr, #7

		/* ********************************* */
		/* *** K. Motor-driver self-test *** */
		/* ********************************* */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
    70fe:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7102:	aeda 5c92 	cmp	A, #23698
    7106:	190a      	je	0x711c <_main+0x134>
    7108:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    710c:	aeda 3072 	cmp	A, #12402
    7110:	1905      	je	0x711c <_main+0x134>
#else  /* _SUPPORT_WD_RST_RECOVERY */
			if ( ((CONTROL & WD_BOOT) == 0) && ((AWD_CTRL & AWD_RST) == 0) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
			{
#if (_SUPPORT_MOTOR_SELFTEST != FALSE)
				g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_SELFTEST;
    7112:	6004      	lod	AL, #4
    7114:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
				MotorDriverSelfTest();												/* Self-test Motor-Driver */
    7116:	82db 8f54 	callf	0x8f54 <_MotorDriverSelfTest>
    711a:	0007      	jmp	0x712a <_main+0x142>
#endif /* (_SUPPORT_MOTOR_SELFTEST != FALSE) */
			}
#if _SUPPORT_WD_RST_RECOVERY
			else if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )				/* MMP130626-11 */
    711c:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7120:	aeda 5c92 	cmp	A, #23698
    7124:	1d02      	jne	0x712a <_main+0x142>
			{
				g_u8ChipResetOcc = FALSE;											/* Clear chip-reset flag before LIN initialisation */
    7126:	6400      	lod	YL, #0
    7128:	4529      	mov	dp:0x29 <_g_u8ChipResetOcc>, YL
			}
#endif /* _SUPPORT_WD_RST_RECOVERY */

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    712a:	6002      	lod	AL, #2
    712c:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL

		/* ********************************* */
		/* *** L. Initialise PID-Control *** */
		/* ********************************* */
		PID_Init();																/* PID Control initialisation */
    712e:	82db 9f16 	callf	0x9f16 <_PID_Init>

		/* *************************************** */
		/* *** M. Initialise (Task) Core Timer *** */
		/* *************************************** */
		Timer_Init();															/* Initialise (Core) Timer */
    7132:	82db a288 	callf	0xa288 <_Timer_Init>

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    7136:	6000      	lod	AL, #0
    7138:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
#if LIN_COMM
		/* *************************************** */
		/* *** O. Initialise LIN-communication *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    713a:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    713e:	aeda 5c92 	cmp	A, #23698
    7142:	1d02      	jne	0x7148 <_main+0x160>
		{
			/* Do not change actual and target position */
			LIN_Init( TRUE);													/* Initialise LIN communication interface */
    7144:	7001      	lod	A, #1
    7146:	0001      	jmp	0x714a <_main+0x162>
		}
		else
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			LIN_Init( FALSE);													/* Initialise LIN communication interface */
    7148:	7000      	lod	A, #0
    714a:	82db 7ac4 	callf	0x7ac4 <_LIN_Init>
		}

		/* Check chip-state for LIN-command RESET, to setup diagnostic-response */
		if ( bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET )
    714e:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7152:	aeda 3072 	cmp	A, #12402
    7156:	1d05      	jne	0x7162 <_main+0x17a>
		{
#if (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
#endif /* (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE) */
#if ((LINPROT & LINXX) == LIN2J)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
    7158:	82db 8744 	callf	0x8744 <_RfrDiagReset>
#endif /* ((LINPROT & LINXX) == LIN2J) */
			bistResetInfo = C_CHIP_STATE_COLD_START;
    715c:	7800      	lod	Y, #0
    715e:	5ad8 0338 	mov	0x338 <_bistResetInfo>, Y
		}
#endif /* LIN_COMM */

#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    7162:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7166:	aeda 5c92 	cmp	A, #23698
    716a:	1904      	je	0x7174 <_main+0x18c>
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			g_u16ActuatorActPos = g_u16ActualPosition;							/* Initialise the Actuator positions too */
    716c:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    716e:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
			g_u16ActuatorTgtPos = g_u16TargetPosition;
    7170:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    7172:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
		}

		/* **************************************************************** */
		/* *** Q. Perform an initial supply and temperature measurement *** */
		/* **************************************************************** */
		MeasureVsupplyAndTemperature();
    7174:	82db 89c6 	callf	0x89c6 <_MeasureVsupplyAndTemperature>
		GetChipTemperature( TRUE);												/* MMP131020-1 */;
    7178:	7001      	lod	A, #1
    717a:	82db 88ee 	callf	0x88ee <_GetChipTemperature>

		/* ********************************************** */
		/* *** R. Stop any motor activity immediately *** */
		/* ********************************************** */
		MotorDriverStop( (uint16) C_STOP_IMMEDIATE);							/* Start-up: Energyce coils if needed */
    717e:	7001      	lod	A, #1
    7180:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>

#if _SUPPORT_WD_RST_RECOVERY
		/* ****************************************************** */
		/* *** T. (Watch-dog Reset) Start actuator (if needed) *** */
		/* ****************************************************** */
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    7184:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    7188:	aeda 5c92 	cmp	A, #23698
    718c:	1d05      	jne	0x7198 <_main+0x1b0>
		{
			if ( g_u16ActuatorActPos != g_u16ActuatorTgtPos )
    718e:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    7190:	adfa      	cmp	A, dp:0xfa <_g_u16ActuatorTgtPos>
    7192:	1902      	je	0x7198 <_main+0x1b0>
			{
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7194:	6003      	lod	AL, #3
    7196:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		}
#endif /* _SUPPORT_WD_RST_RECOVERY */
	}

#if _SUPPORT_CRASH_RECOVERY
	bistResetInfo = C_CHIP_STATE_FATAL_RECOVER_ENA;							/* Enable Fatal crash recovery */
    7198:	7ada 1a45 	lod	Y, #6725
    719c:	5ad8 0338 	mov	0x338 <_bistResetInfo>, Y
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    71a0:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    71a2:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    71a4:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    71a6:	b430      	and	A, #48
    71a8:	1902      	je	0x71ae <_main+0x1c6>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    71aa:	6000      	lod	AL, #0
    71ac:	4282      	mov	io:0x2 <_LinCmnd>, AL

		/* ********************************* */
		/* *** c. LIN(-IN) communication *** */
		/* ********************************* */
#if LIN_COMM
		if ( g_u8LinInFrameBufState != C_LIN_IN_FREE )
    71ae:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
    71b2:	1902      	je	0x71b8 <_main+0x1d0>
		{
			/* LIN message buffer filled */
			HandleLinInMsg();
    71b4:	82db 7bfa 	callf	0x7bfa <_HandleLinInMsg>

		/* ******************************* */
		/* *** d. Motor Driver current *** */
		/* ******************************* */
		/* Calculate Current (1000LSB/A) [mA] */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) || (g_u8MotorHoldingCurrState != FALSE) )
    71b8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    71ba:	b401      	and	A, #1
    71bc:	1d03      	jne	0x71c4 <_main+0x1dc>
    71be:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    71c2:	191a      	je	0x71f8 <_main+0x210>
    71c4:	82db 89aa 	callf	0x89aa <_GetMotorDriverCurrent>
    71c8:	794e      	lod	Y, dp:0x4e <_g_u16CorrectionRatio>
    71ca:	7eda 5760 	lod	X, #22368
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    71ce:	4821      	mulu	YA, A, Y
    71d0:	4c63      	divu	YA, X
    71d2:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    71d4:	52d8 0112 	mov	0x112 <_g_i16Current>, A
		{
			/* Average current = unfiltered_current * Motor_PWM_DutyCycle */
			g_i16Current = (int16) muldivU16_U16byU16byU16( (uint16) GetMotorDriverCurrent(), g_u16CorrectionRatio, (PWM_REG_PERIOD << (4 + PWM_PRESCALER_N)));

			if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    71d8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    71da:	b401      	and	A, #1
    71dc:	1d17      	jne	0x720c <_main+0x224>
			{
				/* Motor holding mode: Update motor-current LPF for PID-control */
				g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 16) >> 4)) + (g_i16Current << 2);
    71de:	7158      	lod	A, dp:0x58 <_g_u16MotorCurrentLPFx64>
    71e0:	7ae2      	lod	Y, A
    71e2:	e010      	add	Y, #16
    71e4:	44b6      	lsr	Y, #2
    71e6:	44b6      	lsr	Y, #2
    71e8:	aae6      	sub	A, Y
    71ea:	7ad8 0112 	lod	Y, 0x112 <_g_i16Current>
    71ee:	44a6      	asl	Y, #2
    71f0:	a2e6      	add	A, Y
    71f2:	5158      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, A
#if (C_MOVAVG_SSZ < 6)
				g_u16MotorCurrentMovAvgxN = ((g_u16MotorCurrentLPFx64 + 2) >> (6 - C_MOVAVG_SSZ));	/* -=#=- Just for debug feedback */
#endif /* (C_MOVAVG_SSZ < 6 ) */
#if (C_MOVAVG_SSZ == 6 )
				g_u16MotorCurrentMovAvgxN = g_u16MotorCurrentLPFx64;			/* -=#=- Just for debug feedback */
    71f4:	5156      	mov	dp:0x56 <__data_size>, A
    71f6:	000a      	jmp	0x720c <_main+0x224>
#endif /* (C_MOVAVG_SSZ == 6 ) */
			}
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    71f8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    71fa:	b401      	and	A, #1
    71fc:	1d07      	jne	0x720c <_main+0x224>
#else  /* LIN_COMM */
			if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
#endif /* LIN_COMM */
			{
				g_i16Current = 0;
    71fe:	7800      	lod	Y, #0
    7200:	5ad8 0112 	mov	0x112 <_g_i16Current>, Y
				g_u16MotorCurrentLPFx64 = 0;
    7204:	5958      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, Y
				g_u16MotorCurrentMovAvgxN = 0;
    7206:	5956      	mov	dp:0x56 <__data_size>, Y
				MeasureVsupplyAndTemperature();										/* Perform Vbat/Temperature measurement incase motor is stopped */
    7208:	82db 89c6 	callf	0x89c6 <_MeasureVsupplyAndTemperature>

		/* ************************************************************** */
		/* *** e. Chip and Motor Driver voltage (degraded-mode check) *** */
		/* ************************************************************** */
		/* Calculate Voltage (100LSB/V) [10mV] */
		GetVsupply();
    720c:	82db 886e 	callf	0x886e <_GetVsupply>
		GetVsupplyMotor();
    7210:	82db 88aa 	callf	0x88aa <_GetVsupplyMotor>
		if ( g_i16MotorVoltage < (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS) )//under voltage is 9-0.5=8.5V accroding to FMEA, set in NVRAM
    7214:	61ac      	lod	AL, dp:0xac <_g_NvramUser+0x52>
    7216:	5cf2      	usex	A
    7218:	4872 0019 	muls	A, A, #25
    721c:	4472      	asr	A
    721e:	521b      	mov	[S-28], A
    7220:	7ae2      	lod	Y, A
    7222:	e0ce      	add	Y, #-50
    7224:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7226:	aee6      	cmp	A, Y
    7228:	1e94      	jsge	0x7252 <_main+0x26a>
		{
			/* First time application under-voltage error */					/* MMP150128-1 - Begin */
			if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_UV) == 0x00 )
    722a:	66d8 0109 	lod	YL, 0x109 <_l_e8ErrorDebounceFilter>
    722e:	72e6      	lod	A, Y
    7230:	b404      	and	A, #4
    7232:	1d03      	jne	0x723a <_main+0x252>
			{
				/* Need twice a under-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_UV;
    7234:	62e8      	lod	AL, YL
    7236:	8404      	or	AL, #4
    7238:	003c      	jmp	0x72b2 <_main+0x2ca>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_UNDER )
    723a:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    723c:	8c01      	cmp	AL, #1
    723e:	1d01      	jne	0x7242 <_main+0x25a>
    7240:	003a      	jmp	0x72b6 <_main+0x2ce>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_UNDER;				/* 9.5.3.4 */
    7242:	6001      	lod	AL, #1
    7244:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    7246:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7248:	42d8 010b 	mov	0x10b <_g_e8ErrorVoltageComm>, AL
					SetLastError( (uint8) C_ERR_APPL_UNDER_VOLT);
    724c:	72da 00a2 	lod	A, #162
    7250:	001d      	jmp	0x728c <_main+0x2a4>
#if (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44)
				u16DegradeDelay = 0xFFFF;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		else if ( g_i16MotorVoltage > (NVRAM_APPL_OVOLT + C_VOLTAGE_HYS) )//Over voltage is 19+0.5=19.5V, according to FMEA, set in NVRAM
    7252:	61ad      	lod	AL, dp:0xad <_g_NvramUser+0x53>
    7254:	5cf2      	usex	A
    7256:	4872 0019 	muls	A, A, #25
    725a:	7ee2      	lod	X, A
    725c:	447e      	asr	X
    725e:	7aee      	lod	Y, X
    7260:	e032      	add	Y, #50
    7262:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7264:	aee6      	cmp	A, Y
    7266:	1b15      	jsle	0x7292 <_main+0x2aa>
		{
			/* First time application over-voltage error */
			if ( (l_e8ErrorDebounceFilter & C_DEBFLT_ERR_OV) == 0x00 )
    7268:	66d8 0109 	lod	YL, 0x109 <_l_e8ErrorDebounceFilter>
    726c:	72e6      	lod	A, Y
    726e:	b408      	and	A, #8
    7270:	1d03      	jne	0x7278 <_main+0x290>
			{
				/* Need twice a over-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OV;
    7272:	62e8      	lod	AL, YL
    7274:	8408      	or	AL, #8
    7276:	001d      	jmp	0x72b2 <_main+0x2ca>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_OVER )
    7278:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    727a:	8c02      	cmp	AL, #2
    727c:	191c      	je	0x72b6 <_main+0x2ce>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_OVER;				/* 9.5.3.4 */
    727e:	6002      	lod	AL, #2
    7280:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    7282:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7284:	42d8 010b 	mov	0x10b <_g_e8ErrorVoltageComm>, AL
					SetLastError( (uint8) C_ERR_APPL_OVER_VOLT);
    7288:	72da 00a3 	lod	A, #163
    728c:	82db 8c66 	callf	0x8c66 <_SetLastError>
    7290:	0012      	jmp	0x72b6 <_main+0x2ce>
				u16DegradeDelay = 0xFFFF;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		//else if ( (g_i16MotorVoltage >= (NVRAM_APPL_UVOLT + C_VOLTAGE_HYS)) && (g_i16SupplyVoltage <= (NVRAM_APPL_OVOLT - C_VOLTAGE_HYS)) )
		else if ( (g_i16MotorVoltage >= (NVRAM_APPL_UVOLT - 10)) && (g_i16SupplyVoltage <= (NVRAM_APPL_OVOLT + 10)) )//Accroding to FMEA, set the voltage to 8.9V & 19.1V
    7292:	7a1b      	lod	Y, [S-28]
    7294:	e0f6      	add	Y, #-10
    7296:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7298:	aee6      	cmp	A, Y
    729a:	1a8d      	jsl	0x72b6 <_main+0x2ce>
    729c:	7aee      	lod	Y, X
    729e:	e00a      	add	Y, #10
    72a0:	72d8 0116 	lod	A, 0x116 <_g_i16SupplyVoltage>
    72a4:	aee6      	cmp	A, Y
    72a6:	1f07      	jsg	0x72b6 <_main+0x2ce>
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;			/* Signal voltage-in range */
				}
			}
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
#else  /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
    72a8:	6000      	lod	AL, #0
    72aa:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
    72ac:	62d8 0109 	lod	AL, 0x109 <_l_e8ErrorDebounceFilter>
    72b0:	94f3      	and	AL, #-13
    72b2:	42d8 0109 	mov	0x109 <_l_e8ErrorDebounceFilter>, AL
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */		/* MMP150128-1 - End */
		}

#if _SUPPORT_LIN_UV
		if ( NVRAM_LIN_UV != 0 )												/* MMP131216-1 - Begin */
    72b6:	61c7      	lod	AL, dp:0xc7 <__bss_dp_size+0x17>
    72b8:	b407      	and	A, #7
    72ba:	191b      	je	0x72f2 <_main+0x30a>
		{
			if ( g_i16MotorVoltage >= (int16) (600 + (NVRAM_LIN_UV * 50)) )
    72bc:	4872 0032 	muls	A, A, #50
    72c0:	a2da 0258 	add	A, #600
    72c4:	7920      	lod	Y, dp:0x20 <_g_i16MotorVoltage>
    72c6:	eee2      	cmp	Y, A
    72c8:	1a82      	jsl	0x72ce <_main+0x2e6>
			{
				g_u16LinUVTimeCounter = 0;										/* Stop LIN UV time-counter */
    72ca:	7800      	lod	Y, #0
    72cc:	0010      	jmp	0x72ee <_main+0x306>
			}
			else if ( g_u16LinUVTimeCounter > PI_TICKS_PER_SECOND )
    72ce:	72d8 014c 	lod	A, 0x14c <_g_u16LinUVTimeCounter>
    72d2:	aeda 07d0 	cmp	A, #2000
    72d6:	1a08      	jule	0x72e8 <_main+0x300>
			{
				/* Restart MLX4 Bus-timeout */
				(void) ml_Disconnect();
    72d8:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
				(void) ml_Connect();
    72dc:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
				g_u16LinUVTimeCounter = 1;										/* Re-start LIN UV time-counter */
    72e0:	7001      	lod	A, #1
    72e2:	52d8 014c 	mov	0x14c <_g_u16LinUVTimeCounter>, A
    72e6:	0005      	jmp	0x72f2 <_main+0x30a>
			}
			else if ( g_u16LinUVTimeCounter == 0 )
    72e8:	ac00      	cmp	A, #0
    72ea:	1d03      	jne	0x72f2 <_main+0x30a>
			{
				g_u16LinUVTimeCounter = 1;										/* Start LIN UV time-counter */
    72ec:	7801      	lod	Y, #1
    72ee:	5ad8 014c 	mov	0x14c <_g_u16LinUVTimeCounter>, Y

		/* ************************************************************* */
		/* *** f. Chip and ambient temperature (degraded-mode check) *** */
		/* ************************************************************* */
		/* Calculate Chip internal temperature (1LSB/C) [C] */
		GetChipTemperature( FALSE)												/* MMP131020-1 */;
    72f2:	7000      	lod	A, #0
    72f4:	82db 88ee 	callf	0x88ee <_GetChipTemperature>
#endif /* (_SUPPORT_DIAG_OVT != FALSE) */
#else  /* _SUPPORT_AMBIENT_TEMP */
		//if ( ((g_i16ChipTemperature > (int16) (NVRAM_APPL_OTEMP + C_TEMPERATURE_HYS)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) ||
		//	 (g_i16ChipTemperature > C_CHIP_OVERTEMP_LEVEL) )
		//Ban, the over temperate is set to 150 degree, also go to degrade mode
		if ( ((g_i16ChipTemperature > (int16) (NVRAM_APPL_OTEMP + 10)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) || (g_i16ChipTemperature > (int16) C_CHIP_OVERTEMP_LEVEL) )
    72f8:	61ab      	lod	AL, dp:0xab <_g_NvramUser+0x51>
    72fa:	5cf2      	usex	A
    72fc:	7ee2      	lod	X, A
    72fe:	7ae2      	lod	Y, A
    7300:	e0ce      	add	Y, #-50
    7302:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    7304:	aee6      	cmp	A, Y
    7306:	1b03      	jsle	0x730e <_main+0x326>
    7308:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    730a:	b401      	and	A, #1
    730c:	1904      	je	0x7316 <_main+0x32e>
    730e:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    7310:	aeda 0096 	cmp	A, #150
    7314:	1b1b      	jsle	0x734c <_main+0x364>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT) == 0x00 )
    7316:	66d8 0109 	lod	YL, 0x109 <_l_e8ErrorDebounceFilter>
    731a:	72e6      	lod	A, Y
    731c:	b402      	and	A, #2
    731e:	1d05      	jne	0x732a <_main+0x342>
			{
				/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVT;
    7320:	62e8      	lod	AL, YL
    7322:	8402      	or	AL, #2
    7324:	42d8 0109 	mov	0x109 <_l_e8ErrorDebounceFilter>, AL
    7328:	0020      	jmp	0x736a <_main+0x382>
			}
			else if ( g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_YES )
    732a:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    732c:	8c01      	cmp	AL, #1
    732e:	191d      	je	0x736a <_main+0x382>
			{
				g_u8OverTemperatureCount++;
    7330:	62d8 010d 	lod	AL, 0x10d <_g_u8OverTemperatureCount>
    7334:	8001      	add	AL, #1
    7336:	42d8 010d 	mov	0x10d <_g_u8OverTemperatureCount>, AL
				if ( g_u8OverTemperatureCount >= (uint8) C_OVERTEMP_TO_PERMDEFECT_THRSHLD )
    733a:	8c03      	cmp	AL, #3
    733c:	1a16      	jule	0x736a <_main+0x382>
				{
					g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    733e:	6001      	lod	AL, #1
    7340:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
					SetLastError( (uint8) C_ERR_APPL_OVER_TEMP);
    7342:	72da 00a1 	lod	A, #161
    7346:	82db 8c66 	callf	0x8c66 <_SetLastError>
    734a:	000f      	jmp	0x736a <_main+0x382>
		}
#if _SUPPORT_AMBIENT_TEMP
		else if ( g_i16AmbjTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
			//else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
			else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP) )//Over temp pass criteria is 140 degree
    734c:	7aee      	lod	Y, X
    734e:	e0c4      	add	Y, #-60
    7350:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    7352:	aee6      	cmp	A, Y
    7354:	1e8a      	jsge	0x736a <_main+0x382>
#endif /* _SUPPORT_AMBIENT_TEMP */
			{
				g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_NO;
    7356:	6000      	lod	AL, #0
    7358:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
				l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVT;
    735a:	62d8 0109 	lod	AL, 0x109 <_l_e8ErrorDebounceFilter>
    735e:	94fd      	and	AL, #-3
    7360:	42d8 0109 	mov	0x109 <_l_e8ErrorDebounceFilter>, AL
				g_u8OverTemperatureCount = 0;
    7364:	6400      	lod	YL, #0
    7366:	46d8 010d 	mov	0x10d <_g_u8OverTemperatureCount>, YL
			}

		if (g_i16ChipTemperature > (int16) (C_CHIP_WARNING_OVERTEMP_LEVEL + C_TEMPERATURE_HYS))//over temperature waning process
    736a:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    736c:	aeda 0094 	cmp	A, #148
    7370:	1b05      	jsle	0x737c <_main+0x394>
		{
			if ( g_e8WarningOverTemperature != (uint8) C_WARNING_OTEMP_YES )
    7372:	611a      	lod	AL, dp:0x1a <_g_e8WarningOverTemperature>
    7374:	8c01      	cmp	AL, #1
    7376:	1908      	je	0x7388 <_main+0x3a0>
			{
				g_e8WarningOverTemperature = (uint8) C_WARNING_OTEMP_YES;
    7378:	6001      	lod	AL, #1
    737a:	0005      	jmp	0x7386 <_main+0x39e>
			}
		}
		else if(g_i16ChipTemperature < (int16) (C_CHIP_WARNING_OVERTEMP_LEVEL - C_TEMPERATURE_HYS))
    737c:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    737e:	aeda 008d 	cmp	A, #141
    7382:	1f02      	jsg	0x7388 <_main+0x3a0>
		{
			g_e8WarningOverTemperature = (uint8) C_WARNING_OTEMP_NO;
    7384:	6000      	lod	AL, #0
    7386:	411a      	mov	dp:0x1a <_g_e8WarningOverTemperature>, AL

		/* ****************************** */
		/* *** g. Degraded-mode check *** */
		/* ****************************** */
		/* Degraded check */
		if ( ((g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE) || (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_YES)) && ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) == 0))
    7388:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    738a:	1d03      	jne	0x7392 <_main+0x3aa>
    738c:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    738e:	8c01      	cmp	AL, #1
    7390:	1d1d      	jne	0x73cc <_main+0x3e4>
    7392:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7394:	8c00      	cmp	AL, #0
    7396:	1a9a      	jsl	0x73cc <_main+0x3e4>
		{
			/* Not in degradation state; Stop motor, remember last "request" and enter degradation state */
			if ( g_e8MotorRequest != (uint8) C_MOTOR_REQUEST_NONE )				/* MMP150313-3 - Begin */
    7398:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    739a:	1904      	je	0x73a4 <_main+0x3bc>
			{
				g_e8DegradedMotorRequest = g_e8MotorRequest;
    739c:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    739e:	6400      	lod	YL, #0
    73a0:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
    73a2:	0008      	jmp	0x73b4 <_main+0x3cc>
				MotorDriverStop( (uint16) C_STOP_RAMPDOWN);						/* Degraded-mode (Running) */
			}
			else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0 )	/* MMP150313-3 - End */
    73a4:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    73a6:	b401      	and	A, #1
    73a8:	1907      	je	0x73b8 <_main+0x3d0>
			{
				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )
    73aa:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    73ac:	8c01      	cmp	AL, #1
    73ae:	1d0b      	jne	0x73c6 <_main+0x3de>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;	/* Set before Diagnostics UV/OV kicks-in */
    73b0:	6003      	lod	AL, #3
    73b2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Degraded-mode (Running) */
    73b4:	7000      	lod	A, #0
    73b6:	0005      	jmp	0x73c2 <_main+0x3da>
				else
				{
					/* "Stopping" */
				}
			}
			else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    73b8:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    73ba:	1d05      	jne	0x73c6 <_main+0x3de>
			{
				/* Actuator is stopped, but maybe still powered (holding-mode);
				 * Request to stop without ramp-down */
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;		/* In case non-degraded mode, (optionally) turn on holding-mode */
    73bc:	6001      	lod	AL, #1
    73be:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Degraded-mode (MMP150313-2) */
    73c0:	7002      	lod	A, #2
    73c2:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
			}
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    73c6:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    73c8:	8480      	or	AL, #-128
    73ca:	0017      	jmp	0x73fa <_main+0x412>
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) && 
    73cc:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    73ce:	8c00      	cmp	AL, #0
    73d0:	1e95      	jsge	0x73fc <_main+0x414>
    73d2:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    73d4:	1d13      	jne	0x73fc <_main+0x414>
    73d6:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    73d8:	1d11      	jne	0x73fc <_main+0x414>
				(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_NO))
		{
			/* No longer degraded mode */
			if ( g_e8DegradedMotorRequest != (uint8) C_MOTOR_REQUEST_NONE ) 
    73da:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    73dc:	190c      	je	0x73f6 <_main+0x40e>
			{
				g_e8MotorRequest = (uint8) g_e8DegradedMotorRequest;
    73de:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    73e0:	6000      	lod	AL, #0
    73e2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				if(g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS)//go back to continue calibration
    73e4:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    73e6:	8c03      	cmp	AL, #3
    73e8:	1d02      	jne	0x73ee <_main+0x406>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_HI_ENDPOS;
    73ea:	6002      	lod	AL, #2
    73ec:	0003      	jmp	0x73f4 <_main+0x40c>
				}
				else if(g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS)
    73ee:	8c06      	cmp	AL, #6
    73f0:	1d02      	jne	0x73f6 <_main+0x40e>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_LO_ENDPOS;
    73f2:	6005      	lod	AL, #5
    73f4:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				}
			}
			g_e8MotorStatusMode &= (uint8) ~C_MOTOR_STATUS_DEGRADED;
    73f6:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    73f8:	947f      	and	AL, #127
    73fa:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
		/* ************************************************* */
		/* *** i. Handling Motor Request (Emergency Run) *** */
		/* ************************************************* */
#if (_SUPPORT_BUSTIMEOUT)
		/* Bus-timeout occurred */
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_EMRUN )
    73fc:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    73fe:	8c07      	cmp	AL, #7
    7400:	1d29      	jne	0x7454 <_main+0x46c>
		{
			//TODO, where to clear the emergency run flag, emergency run only occurred in initialized stage
			/* Actuator move's towards Emergency Run position */
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7402:	6400      	lod	YL, #0
    7404:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL


#if (((LINPROT & LINXX) == LIN2X) || ((LINPROT & LINXX) == LIN2J))
			if(g_e8CalibrationStep == (uint8) C_CALIB_DONE)
    7406:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7408:	8c0a      	cmp	AL, #10
    740a:	1d24      	jne	0x7454 <_main+0x46c>
			{
				if ( g_NvramUser.EmergencyRunEndStopHi == 0 )
    740c:	616a      	lod	AL, dp:0x6a <_g_NvramUser+0x10>
    740e:	44b2      	lsr	A, #2
    7410:	b401      	and	A, #1
    7412:	1d0c      	jne	0x742c <_main+0x444>
				{
					/* Move to Low EndStop */
					g_u16TargetPosition = C_EXV_ZERO_POS;
    7414:	658e      	lod	YL, dp:0x8e <_g_NvramUser+0x34>
    7416:	44b6      	lsr	Y, #2
    7418:	44b6      	lsr	Y, #2
    741a:	4436      	lsr	Y
    741c:	f403      	and	Y, #3
    741e:	7064      	lod	A, #100
    7420:	ec00      	cmp	Y, #0
    7422:	1b03      	jsle	0x742a <_main+0x442>
    7424:	46e9      	mov	Cx, YL
    7426:	4422      	asl	A
    7428:	1ffe      	djnz	Cx, 0x7426 <_main+0x43e>
    742a:	0001      	jmp	0x742e <_main+0x446>
				}
				else
				{
					/* Move to High EndStop */
					g_u16TargetPosition = g_u16CalibTravel;
    742c:	71f6      	lod	A, dp:0xf6 <_g_u16CalibTravel>
    742e:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
				}
				if ( g_u16TargetPosition != g_u16ActualPosition)
    7430:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    7432:	adf0      	cmp	A, dp:0xf0 <_g_u16ActualPosition>
    7434:	190f      	je	0x7454 <_main+0x46c>
				{
					/* Only move actuator when not already at position */
					g_u8EmergencyRunOcc = TRUE;
    7436:	6001      	lod	AL, #1
    7438:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
					//g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;
					g_u8StallOcc = FALSE;
    743a:	6400      	lod	YL, #0
    743c:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
					g_u8StallTypeComm &= ~M_STALL_MODE;								/* MMP130916-1 */
    743e:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7440:	9487      	and	AL, #-121
    7442:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

					if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7444:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7446:	8c00      	cmp	AL, #0
    7448:	1e83      	jsge	0x7450 <_main+0x468>
					{
						g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    744a:	6003      	lod	AL, #3
    744c:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
    744e:	0002      	jmp	0x7454 <_main+0x46c>
					}
					else
					{
						g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7450:	6003      	lod	AL, #3
    7452:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
#endif /* (_SUPPORT_BUSTIMEOUT_SLEEP != FALSE) */								/* MMP130815-1 - End */
#endif /* (((LINPROT & LINXX) == LIN2X) || ((LINPROT & LINXX) == LIN2J)) */
		}
#endif /* (_SUPPORT_BUSTIMEOUT) */
		//Ban, Go to sleep after emergency run
		if((g_u8EmergencyRunOcc == TRUE) && (g_u16ActualPosition == g_u16CalibTravel))
    7454:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    7456:	8c01      	cmp	AL, #1
    7458:	1d05      	jne	0x7464 <_main+0x47c>
    745a:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    745c:	adf6      	cmp	A, dp:0xf6 <_g_u16CalibTravel>
    745e:	1d02      	jne	0x7464 <_main+0x47c>
		{
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    7460:	6006      	lod	AL, #6
    7462:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		/* ********************************************************************************************* */

//		g_e8MotorRequest = C_MOTOR_REQUEST_START;
//		g_e8CalibrationStep = C_CALIB_DONE;

		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_STOP )
    7464:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    7466:	4219      	mov	[S-26], AL
    7468:	8c01      	cmp	AL, #1
    746a:	1d0a      	jne	0x7480 <_main+0x498>
		{
			/* Stop Actuator */
			g_u8RewindFlags &= (uint8) ~(C_REWIND_ACTIVE | C_REWIND_REWIND);
    746c:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    746e:	94d7      	and	AL, #-41
    7470:	4124      	mov	dp:0x24 <__data_dp_size>, AL
			MotorDriverStop( (uint16) C_STOP_RAMPDOWN);							/* LIN-cmd request */
    7472:	7000      	lod	A, #0
    7474:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7478:	6400      	lod	YL, #0
    747a:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;			/* MMP150313-1 */
    747c:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
    747e:	01b4      	jmp	0x77e8 <_main+0x800>
			//g_e8CalibrationStep = (uint8) C_CALIB_NONE;
			//g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_INIT) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_INIT) )	/* MMP150313-1 */
    7480:	6219      	lod	AL, [S-26]
    7482:	8c02      	cmp	AL, #2
    7484:	1904      	je	0x748e <_main+0x4a6>
    7486:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    7488:	4218      	mov	[S-25], AL
    748a:	8c02      	cmp	AL, #2
    748c:	1d08      	jne	0x749e <_main+0x4b6>
		{
			/* Actuator initialisation: Set new actual position */
			g_u16ActuatorActPos = g_u16ActualPosition;
    748e:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    7490:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7492:	6400      	lod	YL, #0
    7494:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;			/* MMP150313-1 */
    7496:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
			g_e8CalibrationStep = (uint8) C_CALIB_DONE;
    7498:	600a      	lod	AL, #10
    749a:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    749c:	01a5      	jmp	0x77e8 <_main+0x800>
		}
#endif /* LIN_COMM */
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_START) && (g_u8MotorStartDelay == 0))
    749e:	6219      	lod	AL, [S-26]
    74a0:	8c03      	cmp	AL, #3
    74a2:	1901      	je	0x74a6 <_main+0x4be>
    74a4:	004c      	jmp	0x753e <_main+0x556>
    74a6:	62d8 010c 	lod	AL, 0x10c <_g_u8MotorStartDelay>
    74aa:	1901      	je	0x74ae <_main+0x4c6>
    74ac:	0158      	jmp	0x775e <_main+0x776>
		{
			//g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;//make sure just run once
			if((g_u8EmergencyRunOcc == FALSE) && (g_e8EXVMoveEnableRequestFlag == (uint8) C_EXV_MOVE_ENABLE))
    74ae:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    74b0:	1d29      	jne	0x7504 <_main+0x51c>
    74b2:	611c      	lod	AL, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    74b4:	8c01      	cmp	AL, #1
    74b6:	1d26      	jne	0x7504 <_main+0x51c>
					g_u16TargetPosition = C_EXV_ZERO_POS + C_EXV_RANGE_MAX;
				}
				else
#endif
				{
					g_u16TargetPosition = (((uint32)g_u16EXVTargetPositionTemp)*C_EXV_POSITION_STD+512)/1023 + C_EXV_ZERO_POS;//update the target position
    74b8:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    74ba:	44b2      	lsr	A, #2
    74bc:	44b2      	lsr	A, #2
    74be:	4432      	lsr	A
    74c0:	b403      	and	A, #3
    74c2:	5217      	mov	[S-24], A
    74c4:	72da 0120 	lod	A, #288
    74c8:	7a17      	lod	Y, [S-24]
    74ca:	ec00      	cmp	Y, #0
    74cc:	1b03      	jsle	0x74d4 <_main+0x4ec>
    74ce:	46e9      	mov	Cx, YL
    74d0:	4422      	asl	A
    74d2:	1ffe      	djnz	Cx, 0x74d0 <_main+0x4e8>
    74d4:	7ad8 0102 	lod	Y, 0x102 <_g_u16EXVTargetPositionTemp>
    74d8:	4821      	mulu	YA, A, Y
    74da:	4c22 0200 	add	YA, #512
    74de:	0000 
    74e0:	54ca 03ff 	pushw	#1023
    74e4:	54ca 0000 	pushw	#0
    74e8:	82db 6c94 	callf	0x6c94 <___udivsi3>
    74ec:	5c03      	dec	S, #4
    74ee:	5215      	mov	[S-22], A
    74f0:	5a13      	mov	[S-20], Y
    74f2:	7064      	lod	A, #100
    74f4:	7a17      	lod	Y, [S-24]
    74f6:	ec00      	cmp	Y, #0
    74f8:	1b03      	jsle	0x7500 <_main+0x518>
    74fa:	46e9      	mov	Cx, YL
    74fc:	4422      	asl	A
    74fe:	1ffe      	djnz	Cx, 0x74fc <_main+0x514>
    7500:	a215      	add	A, [S-22]
    7502:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
				}
			}
			/* Start Actuator */
			if (( g_u16ActualPosition != g_u16TargetPosition ) && (g_e8CalibrationStep == C_CALIB_DONE))
    7504:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    7506:	adf2      	cmp	A, dp:0xf2 <_g_u16TargetPosition>
    7508:	1917      	je	0x7538 <_main+0x550>
    750a:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    750c:	8c0a      	cmp	AL, #10
    750e:	1d14      	jne	0x7538 <_main+0x550>
			{
				uint8 u8NewMotorDirectionCCW;
#if LIN_COMM
				UpdateMotorSpeed();//TODO, when accelerate or Decelerate, may changed the speed
    7510:	152d      	call	0x6f6c <_UpdateMotorSpeed>
				g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_2;
				g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[C_MOTOR_SPEED_2];		/* Use Speed #2 as default */
				g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[C_MOTOR_SPEED_2];
#endif /* LIN_COMM */

				u8NewMotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? TRUE : FALSE;
    7512:	7800      	lod	Y, #0
    7514:	7df2      	lod	X, dp:0xf2 <_g_u16TargetPosition>
    7516:	2df0      	cmp	X, dp:0xf0 <_g_u16ActualPosition>
    7518:	1c01      	jnc	0x751c <_main+0x534>
    751a:	7801      	lod	Y, #1
						g_u8RewindFlags = 0;									/* Clear previous detected stall flags */
					}															/* MMP140331-1 - End */
				}
#endif

				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP )
    751c:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    751e:	1d04      	jne	0x7528 <_main+0x540>
				{
					g_e8MotorDirectionCCW = u8NewMotorDirectionCCW;
    7520:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
					MotorDriverStart();
    7522:	82db 9376 	callf	0x9376 <_MotorDriverStart>
    7526:	0008      	jmp	0x7538 <_main+0x550>
				}
				else if ( u8NewMotorDirectionCCW != g_e8MotorDirectionCCW )
    7528:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    752a:	8ee8      	cmp	AL, YL
    752c:	1904      	je	0x7536 <_main+0x54e>
				{
					/* Changing direction; Stop motor first before starting in opposite direction */
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Change of direction */
    752e:	7000      	lod	A, #0
    7530:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
					continue;
    7534:	0635      	jmp	0x71a0 <_main+0x1b8>
				}
				else
				{
					g_u16ActuatorTgtPos = g_u16TargetPosition;					/* Motor already started; Update target-position only */
    7536:	5dfa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, X
				}
			}
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7538:	6000      	lod	AL, #0
    753a:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    753c:	0155      	jmp	0x77e8 <_main+0x800>
		}
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_CALIBRATION) && (g_e8EXVMoveEnableRequestFlag == (uint8) C_EXV_MOVE_ENABLE) )
    753e:	6219      	lod	AL, [S-26]
    7540:	8c05      	cmp	AL, #5
    7542:	1901      	je	0x7546 <_main+0x55e>
    7544:	0109      	jmp	0x7758 <_main+0x770>
    7546:	611c      	lod	AL, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    7548:	8c01      	cmp	AL, #1
    754a:	1901      	je	0x754e <_main+0x566>
    754c:	0108      	jmp	0x775e <_main+0x776>
		{
			//TODO, ban, how about emergency run?
			//g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;//make sure just run once
			if ( g_e8CalibrationStep == (uint8) C_CALIB_START )//not initialized, case 00
    754e:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7550:	4211      	mov	[S-18], AL
    7552:	8c01      	cmp	AL, #1
    7554:	1901      	je	0x7558 <_main+0x570>
    7556:	003d      	jmp	0x75d2 <_main+0x5ea>
			{
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_NO;
    7558:	6400      	lod	YL, #0
    755a:	452d      	mov	dp:0x2d <_g_e8ErrorElectric>, YL
				g_e8ErrorCoil = 0;//Clean coil status because this is not updated until error happened, need to debug(ban debug)
    755c:	452c      	mov	dp:0x2c <_g_e8ErrorCoil>, YL
				g_u8StallOcc = FALSE;
    755e:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
				g_e8EXVErrorBlock = FALSE;
    7560:	4518      	mov	dp:0x18 <__data_dp_start>, YL
				g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_NO;
    7562:	4526      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, YL

				g_e8CalibrationStep = (uint8) C_CALIB_SETUP_HI_ENDPOS;
    7564:	6002      	lod	AL, #2
    7566:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				if(g_u16EXVTargetPositionTemp == (uint16)C_EXV_FULLY_OPEN_LIN)//Move to Full open, 100% first
    7568:	72d8 0102 	lod	A, 0x102 <_g_u16EXVTargetPositionTemp>
    756c:	aeda 03ff 	cmp	A, #1023
    7570:	1d27      	jne	0x75c0 <_main+0x5d8>
				{
					g_u16ActualPosition = (uint16)C_EXV_ZERO_POS;
    7572:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    7574:	44b2      	lsr	A, #2
    7576:	44b2      	lsr	A, #2
    7578:	4432      	lsr	A
    757a:	7ee2      	lod	X, A
    757c:	3403      	and	X, #3
    757e:	7864      	lod	Y, #100
    7580:	2c00      	cmp	X, #0
    7582:	1b04      	jsle	0x758c <_main+0x5a4>
    7584:	5edf      	push	X
    7586:	4426      	asl	Y
    7588:	1bfe      	djnz	X, 0x7586 <_main+0x59e>
    758a:	7ecf      	pop	X
    758c:	5a0f      	mov	[S-16], Y
    758e:	59f0      	mov	dp:0xf0 <_g_u16ActualPosition>, Y
					g_u16TargetPosition = (uint16)C_EXV_RANGE_MAX + C_EXV_ZERO_POS;
    7590:	616e      	lod	AL, dp:0x6e <_g_NvramUser+0x14>
    7592:	66e0      	lod	YL, AL
    7594:	5cf6      	usex	Y
    7596:	e16c      	add	Y, dp:0x6c <_g_NvramUser+0x12>
    7598:	616f      	lod	AL, dp:0x6f <_g_NvramUser+0x15>
    759a:	5cf2      	usex	A
    759c:	a2e6      	add	A, Y
    759e:	2c00      	cmp	X, #0
    75a0:	1b04      	jsle	0x75aa <_main+0x5c2>
    75a2:	5edf      	push	X
    75a4:	4422      	asl	A
    75a6:	1bfe      	djnz	X, 0x75a4 <_main+0x5bc>
    75a8:	7ecf      	pop	X
    75aa:	7818      	lod	Y, #24
    75ac:	2c00      	cmp	X, #0
    75ae:	1b02      	jsle	0x75b4 <_main+0x5cc>
    75b0:	4426      	asl	Y
    75b2:	1bfe      	djnz	X, 0x75b0 <_main+0x5c8>
    75b4:	a2e6      	add	A, Y
    75b6:	a20f      	add	A, [S-16]
    75b8:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
					l_e8GmcvInitDirection = (uint8)C_GMCV_INIT_DIR_OPEN_FIRST;
    75ba:	6211      	lod	AL, [S-18]
    75bc:	42d8 00fc 	mov	0xfc <__dp_noinit_end>, AL
				}

				if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_STOP ) //stop the motor if it is running
    75c0:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    75c2:	1907      	je	0x75d2 <_main+0x5ea>
				{
					MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    75c4:	7001      	lod	A, #1
    75c6:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
					g_u16CalibPauseCounter = C_PI_TICKS_STABILISE_CALIB;
    75ca:	7ada 00c8 	lod	Y, #200
    75ce:	5ad8 0104 	mov	0x104 <_g_u16CalibPauseCounter>, Y
				}
			}

			if ( (g_e8CalibrationStep == (uint8) C_CALIB_SETUP_HI_ENDPOS) && (g_u16CalibPauseCounter == 0) )//moving to full open
    75d2:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    75d4:	8c02      	cmp	AL, #2
    75d6:	1d0f      	jne	0x75f6 <_main+0x60e>
    75d8:	72d8 0104 	lod	A, 0x104 <_g_u16CalibPauseCounter>
    75dc:	1901      	je	0x75e0 <_main+0x5f8>
    75de:	0099      	jmp	0x7712 <_main+0x72a>
			{
				UpdateMotorSpeed();
    75e0:	14c5      	call	0x6f6c <_UpdateMotorSpeed>
				g_e8MotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? (uint8) C_MOTOR_DIR_CLOSING : (uint8) C_MOTOR_DIR_OPENING;
    75e2:	6400      	lod	YL, #0
    75e4:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    75e6:	adf0      	cmp	A, dp:0xf0 <_g_u16ActualPosition>
    75e8:	1c01      	jnc	0x75ec <_main+0x604>
    75ea:	6401      	lod	YL, #1
    75ec:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
				MotorDriverStart();
    75ee:	82db 9376 	callf	0x9376 <_MotorDriverStart>
				g_e8CalibrationStep = (uint8) C_CALIB_CHECK_HI_ENDPOS;		/* Check for FIRST End-stop */
    75f2:	6003      	lod	AL, #3
    75f4:	008d      	jmp	0x7710 <_main+0x728>
			}
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS )//At the full open
    75f6:	8c03      	cmp	AL, #3
    75f8:	1d12      	jne	0x761e <_main+0x636>
			{
				if ( g_u8StallOcc || (g_u16TargetPosition == g_u16ActualPosition))//Ban
    75fa:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    75fc:	1d04      	jne	0x7606 <_main+0x61e>
    75fe:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    7600:	adf0      	cmp	A, dp:0xf0 <_g_u16ActualPosition>
    7602:	1901      	je	0x7606 <_main+0x61e>
    7604:	0086      	jmp	0x7712 <_main+0x72a>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_LO_ENDPOS;
    7606:	6005      	lod	AL, #5
    7608:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
					g_u16CalibPauseCounter = C_PI_TICKS_STABILISE_CALIB;
    760a:	72da 00c8 	lod	A, #200
    760e:	52d8 0104 	mov	0x104 <_g_u16CalibPauseCounter>, A
					g_u8StallOcc = FALSE;
    7612:	6400      	lod	YL, #0
    7614:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
					g_u8StallTypeComm &= ~M_STALL_MODE;
    7616:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7618:	9487      	and	AL, #-121
    761a:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
    761c:	007a      	jmp	0x7712 <_main+0x72a>
				}
			}
			else if ( (g_e8CalibrationStep == (uint8) C_CALIB_SETUP_LO_ENDPOS) && (g_u16CalibPauseCounter == 0) )
    761e:	8c05      	cmp	AL, #5
    7620:	1901      	je	0x7624 <_main+0x63c>
    7622:	0035      	jmp	0x768e <_main+0x6a6>
    7624:	72d8 0104 	lod	A, 0x104 <_g_u16CalibPauseCounter>
    7628:	1901      	je	0x762c <_main+0x644>
    762a:	0073      	jmp	0x7712 <_main+0x72a>
			{
				UpdateMotorSpeed();
    762c:	149f      	call	0x6f6c <_UpdateMotorSpeed>
				g_u16ActualPosition = C_EXV_RANGE_MAX + C_EXV_ZERO_POS;
    762e:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    7630:	44b2      	lsr	A, #2
    7632:	44b2      	lsr	A, #2
    7634:	4432      	lsr	A
    7636:	7ee2      	lod	X, A
    7638:	3403      	and	X, #3
    763a:	616e      	lod	AL, dp:0x6e <_g_NvramUser+0x14>
    763c:	5cf2      	usex	A
    763e:	a16c      	add	A, dp:0x6c <_g_NvramUser+0x12>
    7640:	656f      	lod	YL, dp:0x6f <_g_NvramUser+0x15>
    7642:	5cf6      	usex	Y
    7644:	e2e2      	add	Y, A
    7646:	2c00      	cmp	X, #0
    7648:	1b04      	jsle	0x7652 <_main+0x66a>
    764a:	5edf      	push	X
    764c:	4426      	asl	Y
    764e:	1bfe      	djnz	X, 0x764c <_main+0x664>
    7650:	7ecf      	pop	X
    7652:	7018      	lod	A, #24
    7654:	2c00      	cmp	X, #0
    7656:	1b04      	jsle	0x7660 <_main+0x678>
    7658:	5edf      	push	X
    765a:	4422      	asl	A
    765c:	1bfe      	djnz	X, 0x765a <_main+0x672>
    765e:	7ecf      	pop	X
    7660:	e2e2      	add	Y, A
    7662:	7064      	lod	A, #100
    7664:	2c00      	cmp	X, #0
    7666:	1b02      	jsle	0x766c <_main+0x684>
    7668:	4422      	asl	A
    766a:	1bfe      	djnz	X, 0x7668 <_main+0x680>
    766c:	5201      	mov	[S-2], A
    766e:	e2e2      	add	Y, A
    7670:	59f0      	mov	dp:0xf0 <_g_u16ActualPosition>, Y
				g_u16TargetPosition = C_EXV_ZERO_POS;
    7672:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
				g_e8MotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? C_MOTOR_DIR_CLOSING : C_MOTOR_DIR_OPENING;
    7674:	6000      	lod	AL, #0
    7676:	420d      	mov	[S-14], AL
    7678:	7201      	lod	A, [S-2]
    767a:	aee6      	cmp	A, Y
    767c:	1c02      	jnc	0x7682 <_main+0x69a>
    767e:	6001      	lod	AL, #1
    7680:	420d      	mov	[S-14], AL
    7682:	660d      	lod	YL, [S-14]
    7684:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
				MotorDriverStart();
    7686:	82db 9376 	callf	0x9376 <_MotorDriverStart>
				g_e8CalibrationStep = (uint8) C_CALIB_CHECK_LO_ENDPOS;		/* Check for SECOND End-stop */
    768a:	6006      	lod	AL, #6
    768c:	0041      	jmp	0x7710 <_main+0x728>
			}
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS )//////////////////////////////
    768e:	8c06      	cmp	AL, #6
    7690:	1901      	je	0x7694 <_main+0x6ac>
    7692:	003f      	jmp	0x7712 <_main+0x72a>
			{
				if ( g_u8StallOcc ||  (g_u16TargetPosition == g_u16ActualPosition))
    7694:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    7696:	1d04      	jne	0x76a0 <_main+0x6b8>
    7698:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    769a:	adf0      	cmp	A, dp:0xf0 <_g_u16ActualPosition>
    769c:	1901      	je	0x76a0 <_main+0x6b8>
    769e:	0039      	jmp	0x7712 <_main+0x72a>
				{
					g_u16CalibTravel = (C_EXV_RANGE_MAX + C_EXV_ZERO_POS) - g_u16ActualPosition;
    76a0:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    76a2:	44b2      	lsr	A, #2
    76a4:	44b2      	lsr	A, #2
    76a6:	4432      	lsr	A
    76a8:	7ee2      	lod	X, A
    76aa:	3403      	and	X, #3
    76ac:	616e      	lod	AL, dp:0x6e <_g_NvramUser+0x14>
    76ae:	5cf2      	usex	A
    76b0:	a16c      	add	A, dp:0x6c <_g_NvramUser+0x12>
    76b2:	656f      	lod	YL, dp:0x6f <_g_NvramUser+0x15>
    76b4:	5cf6      	usex	Y
    76b6:	e2e2      	add	Y, A
    76b8:	2c00      	cmp	X, #0
    76ba:	1b04      	jsle	0x76c4 <_main+0x6dc>
    76bc:	5edf      	push	X
    76be:	4426      	asl	Y
    76c0:	1bfe      	djnz	X, 0x76be <_main+0x6d6>
    76c2:	7ecf      	pop	X
    76c4:	7018      	lod	A, #24
    76c6:	2c00      	cmp	X, #0
    76c8:	1b04      	jsle	0x76d2 <_main+0x6ea>
    76ca:	5edf      	push	X
    76cc:	4422      	asl	A
    76ce:	1bfe      	djnz	X, 0x76cc <_main+0x6e4>
    76d0:	7ecf      	pop	X
    76d2:	e2e2      	add	Y, A
    76d4:	5a0b      	mov	[S-12], Y
    76d6:	7064      	lod	A, #100
    76d8:	2c00      	cmp	X, #0
    76da:	1b04      	jsle	0x76e4 <_main+0x6fc>
    76dc:	5edf      	push	X
    76de:	4422      	asl	A
    76e0:	1bfe      	djnz	X, 0x76de <_main+0x6f6>
    76e2:	7ecf      	pop	X
    76e4:	a2e6      	add	A, Y
    76e6:	7ae2      	lod	Y, A
    76e8:	e9f0      	sub	Y, dp:0xf0 <_g_u16ActualPosition>
    76ea:	59f6      	mov	dp:0xf6 <_g_u16CalibTravel>, Y
					if((g_u16CalibTravel < C_EXV_POSITION_STD) || (g_u16CalibTravel >= C_EXV_RANGE_MAX))//unexpect stall, under range or over range, TODO
    76ec:	72da 0120 	lod	A, #288
    76f0:	2c00      	cmp	X, #0
    76f2:	1b02      	jsle	0x76f8 <_main+0x710>
    76f4:	4422      	asl	A
    76f6:	1bfe      	djnz	X, 0x76f4 <_main+0x70c>
    76f8:	eee2      	cmp	Y, A
    76fa:	1802      	jc	0x7700 <_main+0x718>
    76fc:	ee0b      	cmp	Y, [S-12]
    76fe:	1807      	jc	0x770e <_main+0x726>
					{
						g_e8CalibrationStep = C_CALIB_NONE;
    7700:	6400      	lod	YL, #0
    7702:	451d      	mov	dp:0x1d <_g_e8CalibrationStep>, YL
						g_e8EXVErrorBlock = TRUE;
    7704:	6001      	lod	AL, #1
    7706:	4118      	mov	dp:0x18 <__data_dp_start>, AL
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban, stop the motor in case of unexpect stall
    7708:	6002      	lod	AL, #2
    770a:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
    770c:	0002      	jmp	0x7712 <_main+0x72a>
					}
					else
					{
						g_e8CalibrationStep = (uint8) C_CALIB_END;
    770e:	6009      	lod	AL, #9
    7710:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
					}
				}
			}
			if(g_e8CalibrationStep == (uint8) C_CALIB_END)
    7712:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7714:	8c09      	cmp	AL, #9
    7716:	1901      	je	0x771a <_main+0x732>
    7718:	0067      	jmp	0x77e8 <_main+0x800>
			{
				g_u8StallOcc = FALSE;
    771a:	6000      	lod	AL, #0
    771c:	4128      	mov	dp:0x28 <_g_u8StallOcc>, AL
				g_u8StallTypeComm &= ~M_STALL_MODE;
    771e:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7720:	9487      	and	AL, #-121
    7722:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

				g_u16ActualPosition = C_EXV_ZERO_POS;
    7724:	658e      	lod	YL, dp:0x8e <_g_NvramUser+0x34>
    7726:	44b6      	lsr	Y, #2
    7728:	44b6      	lsr	Y, #2
    772a:	4436      	lsr	Y
    772c:	f403      	and	Y, #3
    772e:	7064      	lod	A, #100
    7730:	ec00      	cmp	Y, #0
    7732:	1b03      	jsle	0x773a <_main+0x752>
    7734:	46e9      	mov	Cx, YL
    7736:	4422      	asl	A
    7738:	1ffe      	djnz	Cx, 0x7736 <_main+0x74e>
    773a:	51f0      	mov	dp:0xf0 <_g_u16ActualPosition>, A
				g_u16TargetPosition = C_EXV_ZERO_POS;
    773c:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A

				g_u16ActuatorActPos = g_u16ActualPosition;
    773e:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
				g_u16ActuatorTgtPos = g_u16TargetPosition;
    7740:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A

				g_e8CalibrationStep = C_CALIB_DONE;
    7742:	600a      	lod	AL, #10
    7744:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				g_u8MotorStartDelay = 255;	//C_PI_TICKS_STABILISE_CALIB;
    7746:	60ff      	lod	AL, #-1
    7748:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
				g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    774c:	6400      	lod	YL, #0
    774e:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7750:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
				//TODO, the post motor request, related to emergency run
				g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7752:	46d8 0106 	mov	0x106 <_g_e8CalibPostMotorRequest>, YL
    7756:	0048      	jmp	0x77e8 <_main+0x800>
			}
		}
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) )	/* MMP150313-1 */
    7758:	6219      	lod	AL, [S-26]
    775a:	8c06      	cmp	AL, #6
    775c:	1904      	je	0x7766 <_main+0x77e>
    775e:	6218      	lod	AL, [S-25]
    7760:	8c06      	cmp	AL, #6
    7762:	1901      	je	0x7766 <_main+0x77e>
    7764:	0037      	jmp	0x77d4 <_main+0x7ec>
		{
			/* Actuator enters (Deep-)SLEEP mode (lowest power mode; Only LIN/PWM msg can wake-up) */
			if ( ((g_e8MotorStatusMode & ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) && /* MMP130730-1 */
    7766:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7768:	b47f      	and	A, #127
    776a:	1d2e      	jne	0x77c8 <_main+0x7e0>
    776c:	6137      	lod	AL, dp:0x37 <_g_u8MotorStopDelay>
    776e:	1d2c      	jne	0x77c8 <_main+0x7e0>
    7770:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    7774:	b401      	and	A, #1
    7776:	1d28      	jne	0x77c8 <_main+0x7e0>
					(g_u8MotorStopDelay == 0) &&
					((NV_CTRL & NV_BUSY) == 0) ) /* MMP140812-3 */
			{
				if ( g_u8MotorHoldingCurrEna &&									/* Holding mode enabled */
    7778:	61ef      	lod	AL, dp:0xef <_g_u8MotorHoldingCurrEna>
    777a:	1908      	je	0x778c <_main+0x7a4>
    777c:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    777e:	8c02      	cmp	AL, #2
    7780:	1905      	je	0x778c <_main+0x7a4>
    7782:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7784:	1d03      	jne	0x778c <_main+0x7a4>
						(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) )
				{
					MotorDriverStop( (uint16) C_STOP_SLEEP);					/* Disable holding current */
    7786:	7003      	lod	A, #3
    7788:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>

#if (LINPROT == LIN2J_VALVE_GM)
				/* Before the actuator enters in Sleep, it saves in EEPROM the CPOS,
				 * the Status and the NAD only if the value of cells is different as the RAM value.
				 */
				LIN_SAE_J2602_Store();											/* MMP160613-2 */
    778c:	12c8      	call	0x7d1e <_LIN_SAE_J2602_Store>
				 * Wake up is done by resetting the chip. The source of the wake up can be found in ANA_INB.
				 * Note: In case between MLX4_HALT and MLX16_HALT a LIN-bus event happens, the chip will not
				 * enter SLEEP but HALT-mode. To allow a LIN-wakeup, the Analogue Watchdog is set to minimum
				 * period of 100us to allow a chip reset.
				 */
				IO_WU = 0;														/* Disable IO3 wake up */
    778e:	7800      	lod	Y, #0
    7790:	5ad8 28c8 	mov	0x28c8 <__io__+0xc8>, Y
				ANA_OUTG = ANA_OUTG & 0xFF9E;									/* Clear Internal WU delay and DIS_GTSM */
    7794:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    7798:	b49e      	and	A, #-98
    779a:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
				MASK = 0;
    779e:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y
				ADC_Stop();														/* MMP140812-4 - End */
    77a2:	82db 87a4 	callf	0x87a4 <_ADC_Stop>
				/* Go into sleep/halt */
				AWD_CTRL = (3u << 8) | 1;										/* Set 1:1 prescaler and minimal period; AWD timeout will be 100 us (MMP140813-2) */
    77a6:	72da 0301 	lod	A, #769
    77aa:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
				MLX4_RESET();
    77ac:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77b0:	94fe      	and	AL, #-2
    77b2:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				MLX16_HALT();													/* See MELEXIS doc */
    77b6:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77ba:	8402      	or	AL, #2
    77bc:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    77c0:	0000      	nop
				/* Chip should reset upon LIN bus changes */
				/* We should never make it to here, as a backup we add a chip reset */
				MLX16_RESET();
    77c2:	82db 5920 	callf	0x5920 <_MLX16_RESET>
    77c6:	0010      	jmp	0x77e8 <_main+0x800>
			}
			else if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_STOP )
    77c8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    77ca:	190e      	je	0x77e8 <_main+0x800>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);	
    77cc:	7001      	lod	A, #1
    77ce:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
    77d2:	000a      	jmp	0x77e8 <_main+0x800>
			}
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SPEED_CHANGE) && (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) )
    77d4:	6219      	lod	AL, [S-26]
    77d6:	8c08      	cmp	AL, #8
    77d8:	1d07      	jne	0x77e8 <_main+0x800>
    77da:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    77dc:	8c01      	cmp	AL, #1
    77de:	1d04      	jne	0x77e8 <_main+0x800>
		{
			UpdateMotorSpeed();
    77e0:	82db 6f6c 	callf	0x6f6c <_UpdateMotorSpeed>
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    77e4:	6400      	lod	YL, #0
    77e6:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
		}
#endif /* _SUPPORT_SPEED_AUTO */

		/* Update status actual-position (only incase not the initial position have been changed) */
		//if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) && ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0) )				/* MMP130626-4 */
		if ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0)//Ban, fix the move to 0 bug, because it stopped,but g_u16ActuatorActPos = 0,g_u16ActualPosition is not zero
    77e8:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    77ea:	b408      	and	A, #8
    77ec:	1d02      	jne	0x77f2 <_main+0x80a>
		{
			g_u16ActualPosition = g_u16ActuatorActPos;
    77ee:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    77f0:	51f0      	mov	dp:0xf0 <_g_u16ActualPosition>, A
//--------------------------------------------------------------------------------------------------------------------

		/* ********************************************************** */
		/* *** l. Threshold control (Stepper: Current-threshold) *** */
		/* ********************************************************** */
		ThresholdControl();													
    77f2:	82db a148 	callf	0xa148 <_ThresholdControl>
//------------------------------------------------------------------------------------------------------------------

		/* ************************************************* */
		/* *** m. PID control (Stepper: current-control) *** */
		/* ************************************************* */
		PID_Control();															/* PID-control (Current) */
    77f6:	82db a00e 	callf	0xa00e <_PID_Control>
		{
			uint16 u16Mlx4CounterThreshold = C_MLX4_STATE_TIMEOUT;				/* MMP130905-4 - Begin */
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4)
			{
				/* MLX4 LIN-Bus activity check when not in LIN-AA mode (only __MLX_PLTF_VERSION_MAJOR__ == 4) */
				if ( (ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0) )
    77fa:	7009      	lod	A, #9
    77fc:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    7800:	acff      	cmp	A, #-1
    7802:	190e      	je	0x7820 <_main+0x838>
    7804:	62d8 0330 	lod	AL, 0x330 <_LinStatus>
    7808:	b401      	and	A, #1
    780a:	190a      	je	0x7820 <_main+0x838>
				{
					/* MLX4 has detected a SYNC field */
					g_u16Mlx4StateCheckCounter = 0;
    780c:	7000      	lod	A, #0
    780e:	52d8 0110 	mov	0x110 <_g_u16Mlx4StateCheckCounter>, A
					g_u8ErrorCommBusTimeout = FALSE;
    7812:	6400      	lod	YL, #0
    7814:	46d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, YL
					(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    7818:	7008      	lod	A, #8
    781a:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    781e:	0005      	jmp	0x782a <_main+0x842>
				}
				else
				{
					g_u16Mlx4StateCheckCounter++;								/* State check counter */
    7820:	72d8 0110 	lod	A, 0x110 <_g_u16Mlx4StateCheckCounter>
    7824:	a001      	add	A, #1
    7826:	52d8 0110 	mov	0x110 <_g_u16Mlx4StateCheckCounter>, A
				}
			}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4) */

			if ( (g_u16Mlx4StateCheckCounter >= u16Mlx4CounterThreshold) || ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0) ) /* MMP130905-4 - End */
    782a:	72d8 0110 	lod	A, 0x110 <_g_u16Mlx4StateCheckCounter>
    782e:	aeda 03e8 	cmp	A, #1000
    7832:	1c05      	jnc	0x783e <_main+0x856>
    7834:	62d8 010e 	lod	AL, 0x10e <_g_u8Mlx4ErrorState>
    7838:	8c00      	cmp	AL, #0
    783a:	1a81      	jsl	0x783e <_main+0x856>
    783c:	0037      	jmp	0x78ac <_main+0x8c4>
			{
				/* Didn't receive MLX4 LIN command and/or data-request in the last period, or need immediate reset */
				g_u16Mlx4StateCheckCounter = 0;										/* MLX4 State check counter reset; MLX4 still active */
    783e:	7000      	lod	A, #0
    7840:	52d8 0110 	mov	0x110 <_g_u16Mlx4StateCheckCounter>, A
				if ( ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0) ||
    7844:	62d8 010e 	lod	AL, 0x10e <_g_u8Mlx4ErrorState>
    7848:	8c00      	cmp	AL, #0
    784a:	1a8b      	jsl	0x7862 <_main+0x87a>
    784c:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    784e:	b440      	and	A, #64
    7850:	1d2a      	jne	0x78a6 <_main+0x8be>
    7852:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    7854:	8c06      	cmp	AL, #6
    7856:	1927      	je	0x78a6 <_main+0x8be>
    7858:	7009      	lod	A, #9
    785a:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    785e:	acff      	cmp	A, #-1
    7860:	1d22      	jne	0x78a6 <_main+0x8be>
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 4) */
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
					&& (ml_GetState() == ml_stINVALID) ) )					/* MMP130811-1 */
#endif /*((__MLX_PLTF_VERSION_MAJOR__ == 3) */
		{
			g_u8Mlx4ErrorState++;
    7862:	62d8 010e 	lod	AL, 0x10e <_g_u8Mlx4ErrorState>
    7866:	8001      	add	AL, #1
    7868:	42d8 010e 	mov	0x10e <_g_u8Mlx4ErrorState>, AL
			if ( g_u8Mlx4ErrorState >= (uint8) C_MLX4_STATE_ERROR_THRSHLD )
    786c:	8c03      	cmp	AL, #3
    786e:	1a1e      	jule	0x78ac <_main+0x8c4>
			{
				/* Signal Error; Reset MLX4 */
				MLX4_RESET();
    7870:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7874:	94fe      	and	AL, #-2
    7876:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				NOP();
    787a:	0000      	nop
				NOP();
    787c:	0000      	nop
				NOP();
    787e:	0000      	nop
				MLX4_START();
    7880:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7884:	8401      	or	AL, #1
    7886:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				if ( (g_u8Mlx4ErrorState & C_MLX4_STATE_NOT_LOGGED) == 0 )	/* MMP131126-1 */
    788a:	62d8 010e 	lod	AL, 0x10e <_g_u8Mlx4ErrorState>
    788e:	b440      	and	A, #64
    7890:	1d04      	jne	0x789a <_main+0x8b2>
				{
					SetLastError( (uint8) C_ERR_MLX4_RESTART);
    7892:	72da 00fa 	lod	A, #250
    7896:	82db 8c66 	callf	0x8c66 <_SetLastError>
				}
				LIN_Init( TRUE);										/* Re-initialise LIN interface w/o changing position */
    789a:	7001      	lod	A, #1
    789c:	1113      	call	0x7ac4 <_LIN_Init>
				g_u8Mlx4ErrorState = 0;
    789e:	6400      	lod	YL, #0
    78a0:	46d8 010e 	mov	0x10e <_g_u8Mlx4ErrorState>, YL
    78a4:	0003      	jmp	0x78ac <_main+0x8c4>
			}
		}
		else
		{
			g_u8Mlx4ErrorState = 0;
    78a6:	6000      	lod	AL, #0
    78a8:	42d8 010e 	mov	0x10e <_g_u8Mlx4ErrorState>, AL
//--------------------------------------------------------------------------------------------------------------------------------

		/* ********************************** */
		/* *** o. Background System check *** */
		/* ********************************** */
		if ( (u8BackgroundSchedulerTaskID == 0) || (u8BackgroundSchedulerTaskID == 128) )
    78ac:	7a1f      	lod	Y, [S-32]
    78ae:	1903      	je	0x78b6 <_main+0x8ce>
    78b0:	621f      	lod	AL, [S-32]
    78b2:	8c80      	cmp	AL, #-128
    78b4:	1d13      	jne	0x78dc <_main+0x8f4>
		{
#if (LINPROT == LIN2J_VALVE_GM)
			if ( RamBackgroundTest( 0) == FALSE )								/* Check RAM against NVRAM User-page */
    78b6:	7000      	lod	A, #0
    78b8:	82db 6d10 	callf	0x6d10 <_RamBackgroundTest>
    78bc:	ac00      	cmp	A, #0
    78be:	1d0a      	jne	0x78d4 <_main+0x8ec>
				if ( RamBackgroundTest( u8BackgroundSchedulerTaskID ? 1 : 0) == FALSE )	/* Check RAM against NVRAM User-page #1/#2 */
#endif /* (LINPROT == LIN2J_VALVE_GM) */
				{
					/* MMP150925-1: RAM g_NvramUser structure not same as NVRAM Page #1.1.
					 * Either System RAM is corrupted or the NVRAM. Allow one time NVRAM reload */
					if ( l_u8RamPreError == FALSE )
    78c0:	62d8 0108 	lod	AL, 0x108 <_l_u8RamPreError>
    78c4:	1d04      	jne	0x78ce <_main+0x8e6>
					{
						NVRAM_LoadAll();
    78c6:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
						l_u8RamPreError = TRUE;
    78ca:	6001      	lod	AL, #1
    78cc:	0004      	jmp	0x78d6 <_main+0x8ee>
					}
					else
					{
						SetLastError( (uint8) C_ERR_RAM_BG);						/* Log RAM failure */
    78ce:	72da 00f8 	lod	A, #248
    78d2:	000f      	jmp	0x78f2 <_main+0x90a>
#endif /* (LINPROT == LIN2J_VALVE_GM) */
					}
				}
				else
				{
					l_u8RamPreError = FALSE;										/* Error is gone (caused by wrong NVRAM shadow-RAM) */
    78d4:	6000      	lod	AL, #0
    78d6:	42d8 0108 	mov	0x108 <_l_u8RamPreError>, AL
    78da:	0018      	jmp	0x790c <_main+0x924>
				}
		}
		else if ( (FL_CTRL0 & FL_DETECT) != 0 )									/* MMP150603-2 */
    78dc:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    78e0:	b401      	and	A, #1
    78e2:	1914      	je	0x790c <_main+0x924>
		{
			if ( FlashBackgroundTest( C_FLASH_SEGMENT_SZ) == C_FLASH_CRC_FAILED )	/* Check Flash/ROM Memory Checksum (max. 250us) */
    78e4:	7004      	lod	A, #4
    78e6:	82db 6d3a 	callf	0x6d3a <_FlashBackgroundTest>
    78ea:	ac00      	cmp	A, #0
    78ec:	1d0f      	jne	0x790c <_main+0x924>
			{
				SetLastError( (uint8) C_ERR_FLASH_BG);
    78ee:	72da 00f9 	lod	A, #249
    78f2:	82db 8c66 	callf	0x8c66 <_SetLastError>
#if (LINPROT == LIN2J_VALVE_GM)
				MLX4_RESET();													/* Reset the Mlx4   */
    78f6:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    78fa:	94fe      	and	AL, #-2
    78fc:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    7900:	7ada 3072 	lod	Y, #12402
    7904:	5ad8 0338 	mov	0x338 <_bistResetInfo>, Y
				MLX16_RESET();													/* Reset the Mlx16  */
    7908:	82db 5920 	callf	0x5920 <_MLX16_RESET>
#endif /* (LINPROT == LIN2J_VALVE_GM) */
			}
		}
		u8BackgroundSchedulerTaskID++; 
    790c:	621f      	lod	AL, [S-32]
    790e:	8001      	add	AL, #1
    7910:	5cf2      	usex	A
    7912:	521f      	mov	[S-32], A
#if _SUPPORT_MLX16_HALT
		/* ************************************* */
		/* *** r. Power-saving (non-running) *** */
		/* ************************************* */
		/* In case MLX4 is inactive, don't enter HALT mode, because the chip enters SLEEP mode which will stop the Core-timer as well */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0) && (g_u8MotorStopDelay == 0) && ((CONTROL & M4_RB) != 0) && (g_u8LinInFrameBufState == C_LIN_IN_FREE) )
    7914:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7916:	b401      	and	A, #1
    7918:	1901      	je	0x791c <_main+0x934>
    791a:	0062      	jmp	0x79e0 <_main+0x9f8>
    791c:	6137      	lod	AL, dp:0x37 <_g_u8MotorStopDelay>
    791e:	1901      	je	0x7922 <_main+0x93a>
    7920:	005f      	jmp	0x79e0 <_main+0x9f8>
    7922:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7926:	b401      	and	A, #1
    7928:	1d01      	jne	0x792c <_main+0x944>
    792a:	005a      	jmp	0x79e0 <_main+0x9f8>
    792c:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
    7930:	1901      	je	0x7934 <_main+0x94c>
    7932:	0056      	jmp	0x79e0 <_main+0x9f8>
		{
			uint16 u16XI0_Mask = XI0_MASK;
    7934:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    7938:	5209      	mov	[S-10], A
			uint16 u16IsrMask = MASK;
    793a:	7ad8 2006 	lod	Y, 0x2006 <__ep__+0x1006>
    793e:	5a07      	mov	[S-8], Y
			uint16 u16Timer1Ctrl = TMR1_CTRL;
    7940:	72aa      	lod	A, io:0x2a <_g_e8MotorDirectionCCW>
    7942:	5205      	mov	[S-6], A

			ADC_PowerOff();														/* Stop ADC, including turning off reference voltage (Approx: 0.6mA) */
    7944:	82db 884c 	callf	0x884c <_ADC_PowerOff>
			DRVCFG |= DIS_SHOA;													/* Disable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    7948:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    794c:	a6da 0400 	or	A, #1024
    7950:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			/* Setup wake-up timer event */
			TMR1_CTRL = (2 * TMRx_DIV0) | (0 * TMRx_MODE0) | TMRx_T_EBLK;		/* Timer mode 0, Divider 256 */
    7954:	7ada 8001 	lod	Y, #32769
    7958:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
			TMR1_REGB = C_SLEEP_PERIOD;											/* Set sleep-period */
    795a:	72da 155c 	lod	A, #5468
    795e:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
			XI0_PEND = CLR_T1_INT4;												/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    7960:	7840      	lod	Y, #64
    7962:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
			XI0_MASK = EN_T1_INT4;												/* Disable Timer1 all 2nd level interrupts, except INT4 (CMP) */
    7966:	5ad8 202a 	mov	0x202a <__ep__+0x102a>, Y
			PEND = CLR_EXT0_IT;
    796a:	72da 0100 	lod	A, #256
    796e:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
			MASK = EN_EXT4_IT | EN_EXT0_IT | EN_M4_SHE_IT;						/* Enable Diagnostics, Timer1 and MLX4 IRQ's only */
    7972:	7ada 1110 	lod	Y, #4368
    7976:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y
			TMR1_CTRL = (2 * TMRx_DIV0) | (0 * TMRx_MODE0) | TMRx_T_EBLK | TMRx_START;	/* Start timer */
    797a:	72da 8003 	lod	A, #32771
    797e:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
			 * the LinInFrameBufState check and before the actual entering of
			 * the HALT-state. The LIN message is not lost, but delayed by the
			 * HALT time-out period. Below code blocks the IRQ's (post-pone)
			 * until the MLX16 enters HALT-state.
			 */
			__asm__("psup #0");													/* Block IRQ's */
    7980:	54d0      	psup	#0
			__asm__("lod AL, _g_u8LinInFrameBufState");							/* Check for LIN message received */
    7982:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
			__asm__("jne _HALT_10");											/* Skip HALT in case LIN message received */
    7986:	1d0b      	jne	0x799e <_main+0x9b6>
			__asm__("lod X, #_au16HaltZero");									/* X pointer to flash memory with 0x0000 (MMP150224-2) */
    7988:	7eda a3e4 	lod	X, #41956
			__asm__("lod AL, 0x2000");											/* Get MLX16 Control-state */
    798c:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
			__asm__("or  AL, #0x02");											/* Set HALT-state */
    7990:	8402      	or	AL, #2
			__asm__("mov R, #0");												/* Restore IRQ-state */
    7992:	4407      	mov	R, #0
			__asm__("pop M");
    7994:	72cb      	pop	M
			__asm__("mov 0x2000, AL");											/* Enter HALT-state */
    7996:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			__asm__("mov A,[X]");												/* MMP150224-2 */
    799a:	72f8      	lod	A, [X]
			__asm__("jmp _HALT_20");											/* Leave HALT-state */
    799c:	0002      	jmp	0x79a2 <_main+0x9ba>
			__asm__("_HALT_10:");
			__asm__("mov R, #0");
    799e:	4407      	mov	R, #0
			__asm__("pop M");
    79a0:	72cb      	pop	M
			__asm__("_HALT_20:");

			DRVCFG &= ~DIS_SHOA;												/* Enable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    79a2:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    79a6:	b6da fbff 	and	A, #64511
    79aa:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			{
				uint16 u16TimerCnt = TMR1_CNT;									/* Take a copy of the Timer-count value */
    79ae:	7ab0      	lod	Y, io:0x30 <_l_u8SynchFieldErrorCounter>
    79b0:	5a03      	mov	[S-4], Y
				TMR1_CTRL = u16Timer1Ctrl & ~TMRx_START;						/* Stop Timer */
    79b2:	7205      	lod	A, [S-6]
    79b4:	b4fd      	and	A, #-3
    79b6:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
				XI0_PEND = u16XI0_Mask;											/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    79b8:	7209      	lod	A, [S-10]
    79ba:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
				XI0_MASK = u16XI0_Mask;											/* Restore Timer1 interrupt mask */
    79be:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
				PEND = CLR_EXT0_IT;
    79c2:	7ada 0100 	lod	Y, #256
    79c6:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y
				MASK = u16IsrMask;												/* Restore 1st level interrupt mask */
    79ca:	7207      	lod	A, [S-8]
    79cc:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

				if ( g_u8MotorHoldingCurrState != FALSE )
    79d0:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    79d4:	1902      	je	0x79da <_main+0x9f2>
							l_u16AdcHoldMode = (l_u16AdcHoldMode + 1);
						}
					}
					ADC_Start( l_u16AdcHoldMode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					ADC_Start();
    79d6:	82db 881c 	callf	0x881c <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				Timer_SleepCompensation( u16TimerCnt);							/* Compensate Timer counters for sleep-period */
    79da:	7203      	lod	A, [S-4]
    79dc:	82db a2aa 	callf	0xa2aa <_Timer_SleepCompensation>

#if _SUPPORT_IOREG_CHECK
		/* ************************************ */
		/* *** s. Critical peripheral check *** */
		/* ************************************ */
		if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_APPL_STOP) == 0x00 )	/* If application is NOT stopped ... */
    79e0:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    79e2:	b440      	and	A, #64
    79e4:	1901      	je	0x79e8 <_main+0xa00>
    79e6:	006a      	jmp	0x7abc <_main+0xad4>
		{
			/* Check: Motor commutation timer disabled */
			if ( (TMR1_CTRL & TMRx_T_EBLK) == 0 )
    79e8:	72aa      	lod	A, io:0x2a <_g_e8MotorDirectionCCW>
    79ea:	b401      	and	A, #1
    79ec:	1d0e      	jne	0x7a0a <_main+0xa22>
			{
				/* Communication timer is disabled; Motor is stopped too */
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    79ee:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    79f0:	b401      	and	A, #1
    79f2:	1904      	je	0x79fc <_main+0xa14>
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;					/* Start timer mode 0 */
    79f4:	7ada 4003 	lod	Y, #16387
    79f8:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
    79fa:	0003      	jmp	0x7a02 <_main+0xa1a>
				}
				else
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0;								/* Timer mode 0 */
    79fc:	72da 4001 	lod	A, #16385
    7a00:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
				}
				SetLastError( (uint8) C_ERR_IOREG);
    7a02:	72da 00fc 	lod	A, #252
    7a06:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
			/* Check: Administrative timer disabled */
			if ( (TIMER & TMR_EN) == 0 )							
    7a0a:	7286      	lod	A, io:0x6 <_LinMess2>
    7a0c:	ac00      	cmp	A, #0
    7a0e:	1a87      	jsl	0x7a1e <_main+0xa36>
			{
				TIMER = TMR_EN | CT_PERIODIC_RATE;
    7a10:	7ada 81f4 	lod	Y, #33268
    7a14:	5a86      	mov	io:0x6 <_LinMess2>, Y
				SetLastError( (uint8) C_ERR_IOREG);
    7a16:	72da 00fc 	lod	A, #252
    7a1a:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
			/* Check: IRQ-Mask (Respectively: Diagnostics, Timer1, CoreTimer and LIN-Communication */
			if ( (MASK & (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT)) != (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT) )
    7a1e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7a22:	b6da 1130 	and	A, #4400
    7a26:	aeda 1130 	cmp	A, #4400
    7a2a:	190e      	je	0x7a48 <_main+0xa60>
			{
				PEND = (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7a2c:	72da 1130 	lod	A, #4400
    7a30:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
				MASK |= (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7a34:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7a38:	a6da 1130 	or	A, #4400
    7a3c:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a40:	72da 00fc 	lod	A, #252
    7a44:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
			/* Check: IRQ-priority (Respectively: Diagnostics, Timer1, CoreTimer) */
			if ( (PRIO & ((3u << 14) | (3u << 6) | (3u << 0))) != (/*((3-3) << 14) |*/ ((4-3) << 6) | ((6-3) << 0)) )
    7a48:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7a4c:	b6da c0c3 	and	A, #49347
    7a50:	ac43      	cmp	A, #67
    7a52:	190b      	je	0x7a6a <_main+0xa82>
			{
				PRIO = (PRIO & ~((3u << 14) | (3u << 6) | (3u << 0))) | (/*((3-3) << 14) |*/ ((4-3) << 6) | ((6-3) << 0));
    7a54:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7a58:	b6da 3f3c 	and	A, #16188
    7a5c:	a443      	or	A, #67
    7a5e:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a62:	72da 00fc 	lod	A, #252
    7a66:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
			/* Check: 2nd level IRQ Timer1 */
			if ( (XI0_MASK & EN_T1_INT4) == 0 )
    7a6a:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    7a6e:	b440      	and	A, #64
    7a70:	1d09      	jne	0x7a84 <_main+0xa9c>
			{
				XI0_PEND = EN_T1_INT4;
    7a72:	7840      	lod	Y, #64
    7a74:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
				XI0_MASK = EN_T1_INT4;
    7a78:	5ad8 202a 	mov	0x202a <__ep__+0x102a>, Y
				SetLastError( (uint8) C_ERR_IOREG);
    7a7c:	72da 00fc 	lod	A, #252
    7a80:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
			/* Check: 2nd level IRQ Diagnostics */
			if ( (XI4_MASK & (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV)) != C_DIAG_MASK )
    7a84:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    7a88:	b6da e100 	and	A, #57600
    7a8c:	aeda e100 	cmp	A, #57600
    7a90:	190a      	je	0x7aa6 <_main+0xabe>
			{
				XI4_PEND = C_DIAG_MASK;											/* MMP150409-1 */
    7a92:	72da e100 	lod	A, #57600
    7a96:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
				XI4_MASK = C_DIAG_MASK;											/* MMP150409-1 */
    7a9a:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a9e:	72da 00fc 	lod	A, #252
    7aa2:	82db 8c66 	callf	0x8c66 <_SetLastError>
			{
				ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
				SetLastError( (uint8) C_ERR_IOREG);
			}
#endif /* 0 */
			if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) && ((DRVCFG & (DRV_CFG_T|DRV_CFG_W|DRV_CFG_V|DRV_CFG_U)) == 0) )
    7aa6:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7aa8:	b401      	and	A, #1
    7aaa:	1908      	je	0x7abc <_main+0xad4>
    7aac:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7ab0:	8c00      	cmp	AL, #0
    7ab2:	1d04      	jne	0x7abc <_main+0xad4>
			{
				/* Driver have been disabled */
				SetLastError( (uint8) C_ERR_IOREG);
    7ab4:	72da 00fc 	lod	A, #252
    7ab8:	82db 8c66 	callf	0x8c66 <_SetLastError>
			}
		}
#endif /* _SUPPORT_IOREG_CHECK */

		//DiagnosticCheck();//Ban
		RteExv2Lin();
    7abc:	82db 6e40 	callf	0x6e40 <_RteExv2Lin>
#endif /* _SUPPORT_DIG_LIN */

	/* ******************************** */
	/* *** U. Main application loop *** */
	/* ******************************** */
	for(;;)
    7ac0:	76da 71a0 	jmpf	0x71a0 <_main+0x1b8>

00007ac4 <_LIN_Init>:
 *
 * Initialise LIN communication interface.
 * Default start-up, at 9600 Baud
 * ****************************************************************************	*/
void LIN_Init( uint16 u16WarmStart)
{
    7ac4:	5801      	inc	S, #2
    7ac6:	5201      	mov	[S-2], A
	/* Initialise LIN Communication */
	LIN_XCFG &= ~DISTERM;														/* Enable LIN pull-up resistor (MMP150811-2) */
    7ac8:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7aca:	b4fb      	and	A, #-5
    7acc:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A
	(void) ml_InitLinModule();													/* Initialise the LIN module */
    7ace:	82db 5e0c 	callf	0x5e0c <_ml_InitLinModule>
#if (_SUPPORT_AUTO_BAUDRATE != FALSE)
	/* Auto baudrate only on first LIN frame */
	(void) ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);						/* MMP141215-1 */
#else  /* (_SUPPORT_AUTO_BAUDRATE != FALSE) */
	/* Fixed baudrate */
	(void) ml_SetBaudRate( (ml_uint8) LIN_BR_PRESCALER, (ml_uint8)LIN_BR_DIV);	/* Program the baudrate : default startup : 9600baud @ 20.0 Mhz	*/
    7ad2:	54ca 00a8 	pushw	#168
    7ad6:	7003      	lod	A, #3
    7ad8:	82db 5b8e 	callf	0x5b8e <_ml_SetBaudRate>
						  ML_ENABLED,											/* StateChangeSignal */
						  1,													/* Light-sleep mode with timeout */
						  ML_SLEWHIGH);											/* SlewRate: ML_SLEWHIGH=20kbps / ML_SLEWLOW=10kbps */
#endif /* ((LIN_BR < 10000) && (_SUPPORT_AUTO_BAUDRATE == FALSE)) */
#elif (__MLX_PLTF_VERSION_MAJOR__ == 4)
	(void) ml_SetOptions( 1U,													/* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    7adc:	54ca 0000 	pushw	#0
    7ae0:	54ca 0001 	pushw	#1
    7ae4:	54ca 0000 	pushw	#0
    7ae8:	7001      	lod	A, #1
    7aea:	82db 5ae0 	callf	0x5ae0 <_ml_SetOptions>
						  0U,													/* TXStopBitLength = 1 Bit */
						  ML_ENABLED,											/* StateChangeSignal */
						  ML_LIGHTSLEEP);										/* SleepMode: light-sleep mode */

#if ((LIN_BR < 12000) && (_SUPPORT_AUTO_BAUDRATE == FALSE))
	(void) ml_SetSlewRate( ML_SLEWLOW);
    7aee:	7002      	lod	A, #2
    7af0:	82db 5ad8 	callf	0x5ad8 <_ml_SetSlewRate>
#if ((LINPROT & LINXX) == LIN2X)
	LIN_2x_Init( u16WarmStart);
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)
	LIN_SAE_J2602_Init( u16WarmStart);
    7af4:	7209      	lod	A, [S-10]
    7af6:	10d1      	call	0x7c9a <_LIN_SAE_J2602_Init>
#endif /* ((LINPROT & LINXX) == LIN2J) */

	(void) ml_Connect();
    7af8:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
	g_u8ErrorCommBusTimeout = FALSE;
    7afc:	6000      	lod	AL, #0
    7afe:	42d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, AL
    7b02:	5c07      	dec	S, #8
    7b04:	5403      	ret	#4

00007b06 <_mlu_ApplicationStop>:
 *  LIN API event: mlu_ApplicationStop
 * ****************************************************************************	*/
ml_Status mlu_ApplicationStop(void)
{
	/* Stop motor (e.g. disconnect drivers) */
	MotorDriverStop( (uint16) C_STOP_IMMEDIATE);								/* Application stop */
    7b06:	7001      	lod	A, #1
    7b08:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
	SetLastError( (uint8) C_ERR_APPL_STOP);
    7b0c:	72da 00a8 	lod	A, #168
    7b10:	82db 8c66 	callf	0x8c66 <_SetLastError>

	/* Disable all IRQ's, except LIN */
	XI0_MASK = 0;
    7b14:	7000      	lod	A, #0
    7b16:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	XI1_MASK = 0;
    7b1a:	52d8 202c 	mov	0x202c <__ep__+0x102c>, A
	XI2_MASK = 0;
    7b1e:	52d8 202e 	mov	0x202e <__ep__+0x102e>, A
	XI3_MASK = 0;
    7b22:	52d8 2030 	mov	0x2030 <__ep__+0x1030>, A
	XI4_MASK = 0;
    7b26:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	MASK = EN_M4_SHE_IT;														/* Disable all interrupts, except LIN M4_SHE_IT */
    7b2a:	7010      	lod	A, #16
    7b2c:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_APPL_STOP;					/* Don't perform periodic MLX4 Status checks */
    7b30:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7b32:	8440      	or	AL, #64
    7b34:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL

	return ( ML_SUCCESS );														/* Return that the application has stopped */
} /* End of mlu_ApplicationStop */
    7b36:	7000      	lod	A, #0
    7b38:	5401      	ret

00007b3a <_mlu_DataRequest>:

/* ****************************************************************************	*
 *  LIN API event: Data Request (slave TX)
 * ****************************************************************************	*/
void mlu_DataRequest( ml_MessageID MessageID) 
{
    7b3a:	7ae2      	lod	Y, A
	g_u8ErrorCommBusTimeout = FALSE;											/* Data requested; No longer Bus time-out */
    7b3c:	6000      	lod	AL, #0
    7b3e:	42d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, AL
	g_u8EmergencyRunOcc = FALSE;//clear emergency run flag,Ban
    7b42:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
	(void) ml_ReleaseBuffer();													/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)												/* LIN 2.x_J2602 */
	if ( MessageID == (uint8) mlxRFR_DIAG )
    7b44:	62e8      	lod	AL, YL
    7b46:	8c11      	cmp	AL, #17
    7b48:	1d16      	jne	0x7b76 <_mlu_DataRequest+0x3c>
	{
		/* Diagnostic */
		if ( g_u8BufferOutID == (uint8) QR_RFR_DIAG )
    7b4a:	6131      	lod	AL, dp:0x31 <_g_u8BufferOutID>
    7b4c:	8c07      	cmp	AL, #7
    7b4e:	1d10      	jne	0x7b70 <_mlu_DataRequest+0x36>
		{
			RFR_DIAG *pDiag = &g_DiagResponse;
			uint16 *src = (uint16 *) pDiag;
			uint16 *dst = (uint16 *) LinFrameDataBuffer;
			dst[0] = src[0];
    7b50:	7144      	lod	A, dp:0x44 <_g_DiagResponse>
    7b52:	51cc      	mov	dp:0xcc <_LinFrameDataBuffer>, A
			dst[1] = src[1];
    7b54:	7146      	lod	A, dp:0x46 <_g_DiagResponse+0x2>
    7b56:	51ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, A
			dst[2] = src[2];
    7b58:	7148      	lod	A, dp:0x48 <_g_DiagResponse+0x4>
    7b5a:	51d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x4>, A
			dst[3] = src[3];
    7b5c:	714a      	lod	A, dp:0x4a <_g_DiagResponse+0x6>
    7b5e:	51d2      	mov	dp:0xd2 <_LinFrameDataBuffer+0x6>, A

			(void) ml_DataReady( ML_END_OF_TX_DISABLED);
    7b60:	7000      	lod	A, #0
    7b62:	82db 5aa4 	callf	0x5aa4 <_ml_DataReady>
			l_u8SynchFieldErrorCounter = 0;										/* Reset sync field errors */
    7b66:	6000      	lod	AL, #0
    7b68:	4130      	mov	dp:0x30 <_l_u8SynchFieldErrorCounter>, AL
			g_u8BufferOutID = (uint8) QR_INVALID;								/* Invalidate LIN output buffer */
    7b6a:	60ff      	lod	AL, #-1
    7b6c:	4131      	mov	dp:0x31 <_g_u8BufferOutID>, AL
    7b6e:	5401      	ret
		}
		else
		{
			(void) ml_DiscardFrame();											/* Output buffer response doesn't match requested response */
    7b70:	82db 5af6 	callf	0x5af6 <_ml_DiscardFrame>
    7b74:	5401      	ret
		}
	}
#if (LINPROT == LIN2J_VALVE_GM)
	else if ( (g_u8NAD >= (uint8) C_MIN_J2602_NAD) && (g_u8NAD <= (uint8) C_MAX_J2602_NAD) )
    7b76:	62d8 0034 	lod	AL, 0x34 <_g_u8NAD>
    7b7a:	80a0      	add	AL, #-96
    7b7c:	8c0d      	cmp	AL, #13
    7b7e:	1e07      	jug	0x7b8e <_mlu_DataRequest+0x54>
	{
		if ( MessageID == (uint8) mlxACT_STATUS )
    7b80:	62e8      	lod	AL, YL
    7b82:	8c01      	cmp	AL, #1
    7b84:	1d04      	jne	0x7b8e <_mlu_DataRequest+0x54>
		{
			/* Status AGS */
			HandleActRfrSta();
    7b86:	1182      	call	0x7e8c <_HandleActRfrSta>
			(void) ml_DataReady( ML_END_OF_TX_ENABLED);
    7b88:	7001      	lod	A, #1
    7b8a:	82db 5aa4 	callf	0x5aa4 <_ml_DataReady>
    7b8e:	5401      	ret

00007b90 <_mlu_DataTransmitted>:
	if ( g_u8SAE_SendErrorState )
	{
		g_u8SAE_ErrorFlags &= ~(uint8)(1 << g_u8SAE_SendErrorState);			/* Clear error-flags which have been transmitted */
	}
#else  /* (LINPROT != LIN2J_VALVE_GM) */
	if ( g_u8SAE_SendErrorState )
    7b90:	62d8 0033 	lod	AL, 0x33 <_g_u8SAE_SendErrorState>
    7b94:	1903      	je	0x7b9c <_mlu_DataTransmitted+0xc>
	{
		g_u8ErrorCommunication = FALSE;
    7b96:	6000      	lod	AL, #0
    7b98:	42d8 011d 	mov	0x11d <_g_u8ErrorCommunication>, AL
    7b9c:	5401      	ret

00007b9e <_mlu_ErrorDetected>:

/* ****************************************************************************	*
 *  LIN API event: mlu_ErrorDetected
 * ****************************************************************************	*/
void mlu_ErrorDetected( ml_LinError Error)
{
    7b9e:	5801      	inc	S, #2
    7ba0:	5201      	mov	[S-2], A
	SetLastError( (uint8) C_ERR_LIN_COMM | ((uint8)Error & 0x1F));
    7ba2:	a6da 0080 	or	A, #128
    7ba6:	b6da 009f 	and	A, #159
    7baa:	82db 8c66 	callf	0x8c66 <_SetLastError>
	LIN2x_ErrorHandling( Error);
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
	(void) ml_ReleaseBuffer(); 													/* Release the buffer in case there was a reception overflow */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
#elif (LINPROT == LIN2J_VALVE_GM)
	LIN2J_ErrorHandling( Error);
    7bae:	7201      	lod	A, [S-2]
    7bb0:	1205      	call	0x7fbc <_LIN2J_ErrorHandling>
    7bb2:	5403      	ret	#4

00007bb4 <_mlu_LinSleepMode>:
{
	/*
	 * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
	 * and does not report it via mlu_MessageReceived event.
	 */
	if ( (Reason == ml_reasonMaster) || (Reason == ml_reasonCommand) )			/* MMP130918-1 */
    7bb4:	7ae2      	lod	Y, A
    7bb6:	a0ff      	add	A, #-1
    7bb8:	ac01      	cmp	A, #1
    7bba:	1e02      	jug	0x7bc0 <_mlu_LinSleepMode+0xc>
	{
		{
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    7bbc:	6006      	lod	AL, #6
    7bbe:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		}
	}

	if ( (Reason == ml_reasonTimeOut) || (Reason == ml_reasonTimeOutDominant) )
    7bc0:	72e6      	lod	A, Y
    7bc2:	a0fa      	add	A, #-6
    7bc4:	ac01      	cmp	A, #1
    7bc6:	1e01      	jug	0x7bca <_mlu_LinSleepMode+0x16>
		/*
		 * LIN bus was inactive for 4 seconds without receiving an explicit
		 * "Go-to-Sleep frame". This can be considered as a failure of the Master or
		 * PHY layer. Slave can enter limp-home mode.
		 */
		HandleBusTimeout();
    7bc8:	11e1      	call	0x7f8c <_HandleBusTimeout>
    7bca:	5401      	ret

00007bcc <_mlu_MessageReceived>:

/* ****************************************************************************	*
 *  LIN API event: MessageReceived (slave RX)
 * ****************************************************************************	*/
void mlu_MessageReceived( ml_MessageID byMessageID)
{
    7bcc:	7ae2      	lod	Y, A
	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_FULL )
    7bce:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
    7bd2:	8c01      	cmp	AL, #1
    7bd4:	1911      	je	0x7bf8 <_mlu_MessageReceived+0x2c>
	{
		/* Buffer is either empty or message is postpone (overwrite allowed) */
		l_u8LinInFrameMsgID = byMessageID;
    7bd6:	454c      	mov	dp:0x4c <_l_u8LinInFrameMsgID>, YL

		/* LIN In-frame buffer to a Copy LIN In-frame buffer */
		{
			uint16 *pu16Source = (uint16 *) LinFrameDataBuffer;
			uint16 *pu16Target = (uint16 *) &g_LinCmdFrameBuffer;
			*pu16Target = *pu16Source;
    7bd8:	71cc      	lod	A, dp:0xcc <_LinFrameDataBuffer>
    7bda:	513c      	mov	dp:0x3c <__data_dp_end>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7bdc:	71ce      	lod	A, dp:0xce <_LinFrameDataBuffer+0x2>
    7bde:	513e      	mov	dp:0x3e <__data_dp_end+0x2>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7be0:	71d0      	lod	A, dp:0xd0 <_LinFrameDataBuffer+0x4>
    7be2:	5140      	mov	dp:0x40 <__data_dp_end+0x4>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7be4:	71d2      	lod	A, dp:0xd2 <_LinFrameDataBuffer+0x6>
    7be6:	5142      	mov	dp:0x42 <__data_dp_end+0x6>, A
		}
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
		(void) ml_ReleaseBuffer();												/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7be8:	6001      	lod	AL, #1
    7bea:	42d8 011e 	mov	0x11e <_g_u8LinInFrameBufState>, AL
		g_u8ErrorCommBusTimeout = FALSE;										/* Frame received; No longer Bus time-out */
    7bee:	6000      	lod	AL, #0
    7bf0:	42d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, AL
		g_u8EmergencyRunOcc = FALSE;//clear emergency run flag,Ban
    7bf4:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
		LinFrame[0] = 0x00;														/* Clear NAD address */
    7bf6:	4108      	mov	dp:0x8 <__bist_stat_size>, AL
    7bf8:	5401      	ret

00007bfa <_HandleLinInMsg>:
	}
} /* End of mlu_MessageReceived() */

void HandleLinInMsg( void)
{
    7bfa:	5801      	inc	S, #2
	if ( g_u8LinInFrameBufState == (uint8) C_LIN_IN_POSTPONE )
    7bfc:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
    7c00:	8c02      	cmp	AL, #2
    7c02:	1d03      	jne	0x7c0a <_HandleLinInMsg+0x10>
	{
		/* Last message postponed; Try again (without overwritten by LIN message ISR */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7c04:	6001      	lod	AL, #1
    7c06:	42d8 011e 	mov	0x11e <_g_u8LinInFrameBufState>, AL
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
#endif /* (LINPROT == LIN2X_ACT44) */
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if ((LINPROT & LINXX) == LIN2J)												/* LIN 2.x_J2602 */
	if ( l_u8LinInFrameMsgID == (uint8) mlxDFR_DIAG )
    7c0a:	614c      	lod	AL, dp:0x4c <_l_u8LinInFrameMsgID>
    7c0c:	4201      	mov	[S-2], AL
    7c0e:	8c10      	cmp	AL, #16
    7c10:	1d02      	jne	0x7c16 <_HandleLinInMsg+0x1c>
	{
		/* Diagnostic frame */
		HandleDfrDiag();
    7c12:	1246      	call	0x80a0 <_HandleDfrDiag>
    7c14:	0008      	jmp	0x7c26 <_HandleLinInMsg+0x2c>
	}
#if (LINPROT == LIN2J_VALVE_GM)
	else if ( (g_u8NAD >= (uint8) C_MIN_J2602_NAD) && (g_u8NAD <= (uint8) C_MAX_J2602_NAD) && (l_u8LinInFrameMsgID == (uint8) mlxACT_CTRL) )
    7c16:	62d8 0034 	lod	AL, 0x34 <_g_u8NAD>
    7c1a:	80a0      	add	AL, #-96
    7c1c:	8c0d      	cmp	AL, #13
    7c1e:	1e03      	jug	0x7c26 <_HandleLinInMsg+0x2c>
    7c20:	6201      	lod	AL, [S-2]
    7c22:	1d01      	jne	0x7c26 <_HandleLinInMsg+0x2c>
	{
		/* Control */
		HandleActCfrCtrl();
    7c24:	10c3      	call	0x7dac <_HandleActCfrCtrl>
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */
#endif /* ((LINPROT & LINXX) == LIN2J) */

	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_POSTPONE )
    7c26:	62d8 011e 	lod	AL, 0x11e <_g_u8LinInFrameBufState>
    7c2a:	8c02      	cmp	AL, #2
    7c2c:	1903      	je	0x7c34 <_HandleLinInMsg+0x3a>
	{
		/* LIN Message is handled; Release LIN message buffer */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FREE;
    7c2e:	6000      	lod	AL, #0
    7c30:	42d8 011e 	mov	0x11e <_g_u8LinInFrameBufState>, AL
    7c34:	5403      	ret	#4

00007c36 <_mlu_AutoAddressingStep>:
/* ****************************************************************************	*
 *  LIN API event: mlu_AutoAddressingStep
 * ****************************************************************************	*/
void mlu_AutoAddressingStep( ml_uint8 StepNumber)
{
	(void) StepNumber; 
    7c36:	5401      	ret

00007c38 <_CalcProtectionBits>:
/* ****************************************************************************	*
 * CalcProtectionBits
 *
 * ****************************************************************************	*/
uint8 CalcProtectionBits( uint8 byFrameID)
{
    7c38:	7ee2      	lod	X, A
	byFrameID |= ((byFrameID & 0x01) ^ ((byFrameID & 0x02) >> 1) ^ ((byFrameID & 0x04) >> 2) ^ ((byFrameID & 0x10) >> 4)) ? 0x40 : 0x00;
    7c3a:	7ae2      	lod	Y, A
    7c3c:	f401      	and	Y, #1
    7c3e:	b402      	and	A, #2
    7c40:	4472      	asr	A
    7c42:	fee2      	xor	Y, A
    7c44:	72ee      	lod	A, X
    7c46:	b404      	and	A, #4
    7c48:	44f2      	asr	A, #2
    7c4a:	fee2      	xor	Y, A
    7c4c:	72ee      	lod	A, X
    7c4e:	b410      	and	A, #16
    7c50:	44f2      	asr	A, #2
    7c52:	44f2      	asr	A, #2
    7c54:	eee2      	cmp	Y, A
    7c56:	1903      	je	0x7c5e <_CalcProtectionBits+0x26>
    7c58:	72ee      	lod	A, X
    7c5a:	a440      	or	A, #64
    7c5c:	0002      	jmp	0x7c62 <_CalcProtectionBits+0x2a>
    7c5e:	72ee      	lod	A, X
    7c60:	5cf2      	usex	A
    7c62:	7ee2      	lod	X, A
	byFrameID |= (((byFrameID & 0x02) >> 1) ^ ((byFrameID & 0x08) >> 3) ^ ((byFrameID & 0x10) >> 4) ^ ((byFrameID & 0x20) >> 5)) ? 0x00 : 0x80;
    7c64:	7ae2      	lod	Y, A
    7c66:	f402      	and	Y, #2
    7c68:	4476      	asr	Y
    7c6a:	b408      	and	A, #8
    7c6c:	44f2      	asr	A, #2
    7c6e:	4472      	asr	A
    7c70:	fee2      	xor	Y, A
    7c72:	72ee      	lod	A, X
    7c74:	b410      	and	A, #16
    7c76:	44f2      	asr	A, #2
    7c78:	44f2      	asr	A, #2
    7c7a:	fee2      	xor	Y, A
    7c7c:	72ee      	lod	A, X
    7c7e:	b420      	and	A, #32
    7c80:	44f2      	asr	A, #2
    7c82:	44f2      	asr	A, #2
    7c84:	4472      	asr	A
    7c86:	eee2      	cmp	Y, A
    7c88:	1903      	je	0x7c90 <_CalcProtectionBits+0x58>
    7c8a:	72ee      	lod	A, X
    7c8c:	5cf2      	usex	A
    7c8e:	5401      	ret
    7c90:	26da 0080 	or	X, #128
    7c94:	72ee      	lod	A, X
    7c96:	5cf2      	usex	A
	return ( byFrameID );
} /* End of CalcProtectionBits() */
    7c98:	5401      	ret

00007c9a <_LIN_SAE_J2602_Init>:
{
	(void) u16WarmStart;

#if (LINPROT == LIN2J_VALVE_GM)
	/* Check wake-up from SLEEP (MMP160613-2) */
	if ( ANA_INB & WAKEUP_LIN )
    7c9a:	729e      	lod	A, io:0x1e <__ramfunc_size>
    7c9c:	b6da 0100 	and	A, #256
    7ca0:	655c      	lod	YL, dp:0x5c <_g_NvramUser+0x2>
    7ca2:	ac00      	cmp	A, #0
    7ca4:	1914      	je	0x7cce <_LIN_SAE_J2602_Init+0x34>
	{
		g_u8NAD = g_NvramUser.NAD;
    7ca6:	4534      	mov	dp:0x34 <_g_u8NAD>, YL
		l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
    7ca8:	616a      	lod	AL, dp:0x6a <_g_NvramUser+0x10>
    7caa:	b401      	and	A, #1
    7cac:	4132      	mov	dp:0x32 <_l_u8ActDirection>, AL
		g_u16ActualPosition = g_u16TargetPosition = g_NvramUser.CPOS;
    7cae:	7176      	lod	A, dp:0x76 <_g_NvramUser+0x1c>
    7cb0:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
    7cb2:	51f0      	mov	dp:0xf0 <_g_u16ActualPosition>, A
		{
			uint8 u8AppStatus = g_NvramUser.AppStatus;
    7cb4:	6178      	lod	AL, dp:0x78 <_g_NvramUser+0x1e>
    7cb6:	5cf2      	usex	A
			if ( u8AppStatus & 0x03 )
    7cb8:	7ae2      	lod	Y, A
    7cba:	f403      	and	Y, #3
    7cbc:	1901      	je	0x7cc0 <_LIN_SAE_J2602_Init+0x26>
				g_e8ErrorElectric = (uint8) (u8AppStatus & 0x03U);
    7cbe:	452d      	mov	dp:0x2d <_g_e8ErrorElectric>, YL
			if ( u8AppStatus & 0x08 )
    7cc0:	b408      	and	A, #8
    7cc2:	1902      	je	0x7cc8 <_LIN_SAE_J2602_Init+0x2e>
				g_u8EmergencyRunOcc = TRUE;
    7cc4:	6001      	lod	AL, #1
    7cc6:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
		}
		g_u8ChipResetOcc = FALSE;
    7cc8:	6000      	lod	AL, #0
    7cca:	4129      	mov	dp:0x29 <_g_u8ChipResetOcc>, AL
    7ccc:	0009      	jmp	0x7ce0 <_LIN_SAE_J2602_Init+0x46>
	}
	else if ( (g_NvramUser.NAD >= C_MIN_J2602_NAD) && (g_NvramUser.NAD <= C_MAX_J2602_NAD) && ((g_NvramUser.NAD & (C_STEP_J2602_NAD - 1)) == 0) )
    7cce:	5cf6      	usex	Y
    7cd0:	72e6      	lod	A, Y
    7cd2:	a0a0      	add	A, #-96
    7cd4:	ac0d      	cmp	A, #13
    7cd6:	1e04      	jug	0x7ce0 <_LIN_SAE_J2602_Init+0x46>
	{
		g_u8NAD = g_NvramUser.NAD;
    7cd8:	4534      	mov	dp:0x34 <_g_u8NAD>, YL
		l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
    7cda:	616a      	lod	AL, dp:0x6a <_g_NvramUser+0x10>
    7cdc:	b401      	and	A, #1
    7cde:	4132      	mov	dp:0x32 <_l_u8ActDirection>, AL
/*		g_u8SAE_ErrorFlags = (1 << C_SAE_RESET_ERROR);	MMP160613-1 */
	}

	if ( (g_u8NAD & 0x0F) != 0x0F )
    7ce0:	6534      	lod	YL, dp:0x34 <_g_u8NAD>
    7ce2:	72e6      	lod	A, Y
    7ce4:	b40f      	and	A, #15
    7ce6:	ac0f      	cmp	A, #15
    7ce8:	1915      	je	0x7d14 <_LIN_SAE_J2602_Init+0x7a>
	{
		uint8 byFrameID = ((g_u8NAD & 0x0F) << 2) + 0x00;
    7cea:	72e6      	lod	A, Y
    7cec:	44a2      	asl	A, #2
    7cee:	b43c      	and	A, #60
		byFrameID = CalcProtectionBits( byFrameID);
    7cf0:	17a3      	call	0x7c38 <_CalcProtectionBits>
    7cf2:	5cf2      	usex	A
		(void) ml_AssignFrameToMessageID( mlxACT_CTRL, byFrameID);
    7cf4:	52df      	push	A
    7cf6:	7000      	lod	A, #0
    7cf8:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
		byFrameID = ((g_u8NAD & 0x0F) << 2) + 0x01;
    7cfc:	6134      	lod	AL, dp:0x34 <_g_u8NAD>
    7cfe:	b40f      	and	A, #15
    7d00:	44a2      	asl	A, #2
    7d02:	8001      	add	AL, #1
    7d04:	5cf2      	usex	A
		byFrameID = CalcProtectionBits( byFrameID);
    7d06:	1798      	call	0x7c38 <_CalcProtectionBits>
    7d08:	5cf2      	usex	A
		(void) ml_AssignFrameToMessageID( mlxACT_STATUS, byFrameID);
    7d0a:	52df      	push	A
    7d0c:	7001      	lod	A, #1
    7d0e:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
    7d12:	5c03      	dec	S, #4
		SetLastError( (uint8) C_ERR_INV_NAD);
	}
	l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
#endif /* (LINPROT == LIN2J_HVAC_GM) */

	(void) ml_SetLoaderNAD( g_u8NAD);											/* Setup NAD at power-up */
    7d14:	6134      	lod	AL, dp:0x34 <_g_u8NAD>
    7d16:	5cf2      	usex	A
    7d18:	82db 5da0 	callf	0x5da0 <_ml_SetLoaderNAD>
    7d1c:	5401      	ret

00007d1e <_LIN_SAE_J2602_Store>:
 * Before the actuator enters in Sleep, it saves in EEPROM the CPOS,
 * the Status, and the NAD only if the value of cells is different as the RAM value.
 * MMP160613-2
 * ****************************************************************************	*/
void LIN_SAE_J2602_Store( void)
{
    7d1e:	5805      	inc	S, #6
	uint16 u16Store = FALSE;
    7d20:	7c00      	lod	X, #0
	if ( g_u16ActualPosition != g_NvramUser.CPOS )
    7d22:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    7d24:	ad76      	cmp	A, dp:0x76 <_g_NvramUser+0x1c>
    7d26:	1902      	je	0x7d2c <_LIN_SAE_J2602_Store+0xe>
	{
		g_NvramUser.CPOS = g_u16ActualPosition;
    7d28:	5176      	mov	dp:0x76 <_g_NvramUser+0x1c>, A
		u16Store = TRUE;
    7d2a:	7c01      	lod	X, #1
	}
	{
		uint8 u8AppStatus = 0x00U;
    7d2c:	7800      	lod	Y, #0

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )
    7d2e:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    7d30:	1903      	je	0x7d38 <_LIN_SAE_J2602_Store+0x1a>
			u8AppStatus |= (g_e8ErrorElectric & 0x03);
    7d32:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    7d34:	7ae2      	lod	Y, A
    7d36:	f403      	and	Y, #3
		if ( g_u8EmergencyRunOcc != FALSE )
    7d38:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    7d3a:	1901      	je	0x7d3e <_LIN_SAE_J2602_Store+0x20>
			u8AppStatus |= 0x08U;
    7d3c:	e408      	or	Y, #8
		if ( u8AppStatus != g_NvramUser.AppStatus )
    7d3e:	6178      	lod	AL, dp:0x78 <_g_NvramUser+0x1e>
    7d40:	5cf2      	usex	A
    7d42:	eee2      	cmp	Y, A
    7d44:	1902      	je	0x7d4a <_LIN_SAE_J2602_Store+0x2c>
		{
			g_NvramUser.AppStatus = u8AppStatus;
    7d46:	4578      	mov	dp:0x78 <_g_NvramUser+0x1e>, YL
			u16Store = TRUE;
    7d48:	7c01      	lod	X, #1
		}
	}
	if ( g_u8NAD != g_NvramUser.NAD )
    7d4a:	6534      	lod	YL, dp:0x34 <_g_u8NAD>
    7d4c:	615c      	lod	AL, dp:0x5c <_g_NvramUser+0x2>
    7d4e:	8ee8      	cmp	AL, YL
    7d50:	1902      	je	0x7d56 <_LIN_SAE_J2602_Store+0x38>
	{
		g_NvramUser.NAD = g_u8NAD;
    7d52:	455c      	mov	dp:0x5c <_g_NvramUser+0x2>, YL
    7d54:	0002      	jmp	0x7d5a <_LIN_SAE_J2602_Store+0x3c>
		u16Store = TRUE;
	}
	if ( u16Store != FALSE )
    7d56:	2c00      	cmp	X, #0
    7d58:	1928      	je	0x7daa <_LIN_SAE_J2602_Store+0x8c>
		 * 						  0		  0		Write C_NVRAM_USER_PAGE_1
		 * 						  0		  1		Write C_NVRAM_USER_PAGE_2
		 * 						  1		  0		Write C_NVRAM_USER_PAGE_2
		 * 						  1		  1		Write C_NVRAM_USER_PAGE_1
		 */
		if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    7d5a:	7ada 101e 	lod	Y, #4126
    7d5e:	66f0      	lod	YL, [Y]
    7d60:	f6da 0080 	and	Y, #128
    7d64:	7ee6      	lod	X, Y
    7d66:	7ada 111e 	lod	Y, #4382
    7d6a:	62f0      	lod	AL, [Y]
    7d6c:	4201      	mov	[S-2], AL
    7d6e:	66e0      	lod	YL, AL
    7d70:	f6da 0080 	and	Y, #128
    7d74:	6178      	lod	AL, dp:0x78 <_g_NvramUser+0x1e>
    7d76:	4204      	mov	[S-5], AL
    7d78:	6201      	lod	AL, [S-2]
    7d7a:	9480      	and	AL, #-128
    7d7c:	4203      	mov	[S-4], AL
    7d7e:	2ee6      	cmp	X, Y
    7d80:	1908      	je	0x7d92 <_LIN_SAE_J2602_Store+0x74>
		{
			g_NvramUser.AppStatus = (g_NvramUser.AppStatus & 0x7F) | (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80);
    7d82:	6204      	lod	AL, [S-5]
    7d84:	947f      	and	AL, #127
    7d86:	8603      	or	AL, [S-4]
    7d88:	4178      	mov	dp:0x78 <_g_NvramUser+0x1e>, AL
			(void) NVRAM_Store( C_NVRAM_USER_PAGE_1);
    7d8a:	7001      	lod	A, #1
    7d8c:	82db 9a3c 	callf	0x9a3c <_NVRAM_Store>
    7d90:	5407      	ret	#8
		}
		else
		{
			g_NvramUser.AppStatus = (g_NvramUser.AppStatus & 0x7F) | ((((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) ^ 0x80);
    7d92:	6204      	lod	AL, [S-5]
    7d94:	947f      	and	AL, #127
    7d96:	4201      	mov	[S-2], AL
    7d98:	6203      	lod	AL, [S-4]
    7d9a:	9c80      	xor	AL, #-128
    7d9c:	4205      	mov	[S-6], AL
    7d9e:	6201      	lod	AL, [S-2]
    7da0:	8605      	or	AL, [S-6]
    7da2:	4178      	mov	dp:0x78 <_g_NvramUser+0x1e>, AL
			(void) NVRAM_Store( C_NVRAM_USER_PAGE_2);
    7da4:	7002      	lod	A, #2
    7da6:	82db 9a3c 	callf	0x9a3c <_NVRAM_Store>
    7daa:	5407      	ret	#8

00007dac <_HandleActCfrCtrl>:
 *	Byte 2	|		Reserved		|		TorqueLevel				| MovEn |
 *			+-----------------------+-------------------------------+-------+
 *
 * ****************************************************************************	*/
void HandleActCfrCtrl( void)
{
    7dac:	580b      	inc	S, #12
	ACT_CFR_CTRL *pCfrCtrl = &g_LinCmdFrameBuffer.cfrCtrl;

		g_u16EXVTargetPositionTemp = (((uint16)pCfrCtrl->byPositionMSB & 0x03) << 8) | pCfrCtrl->byPositionLSB;
    7dae:	653d      	lod	YL, dp:0x3d <__data_dp_end+0x1>
    7db0:	f403      	and	Y, #3
    7db2:	6c00      	lod	YH, #0
    7db4:	7ae8      	swap	Y
    7db6:	613c      	lod	AL, dp:0x3c <__data_dp_end>
    7db8:	5cf2      	usex	A
    7dba:	e6e2      	or	Y, A
    7dbc:	5ad8 0102 	mov	0x102 <_g_u16EXVTargetPositionTemp>, Y
		if((g_e8MotorStatusMode & ((uint8) C_MOTOR_STATUS_DEGRADED)) == 0) //not degrade mode, otherwise, just update the target position
    7dc0:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7dc2:	8c00      	cmp	AL, #0
    7dc4:	1aa5      	jsl	0x7e10 <_HandleActCfrCtrl+0x64>
		{
			if(pCfrCtrl->byMovEn == C_CTRL_MOVE_ENA){
    7dc6:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x2>
    7dc8:	420b      	mov	[S-12], AL
    7dca:	9401      	and	AL, #1
    7dcc:	191c      	je	0x7e06 <_HandleActCfrCtrl+0x5a>
				g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_ENABLE;
    7dce:	6001      	lod	AL, #1
    7dd0:	411c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, AL
				if(((g_e8CalibrationStep == (uint8) C_CALIB_NONE) || (g_e8CalibrationStep == (uint8) C_CALIB_DONE)) && (g_u16EXVTargetPositionTemp == 0x3FF))
    7dd2:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7dd4:	1902      	je	0x7dda <_HandleActCfrCtrl+0x2e>
    7dd6:	8c0a      	cmp	AL, #10
    7dd8:	1d08      	jne	0x7dea <_HandleActCfrCtrl+0x3e>
    7dda:	eeda 03ff 	cmp	Y, #1023
    7dde:	1d05      	jne	0x7dea <_HandleActCfrCtrl+0x3e>
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_CALIBRATION;
    7de0:	6005      	lod	AL, #5
    7de2:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
					g_e8CalibrationStep = (uint8) C_CALIB_START;
    7de4:	6001      	lod	AL, #1
    7de6:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    7de8:	0006      	jmp	0x7df6 <_HandleActCfrCtrl+0x4a>
				}
				else if(g_e8CalibrationStep == (uint8) C_CALIB_DONE)
    7dea:	8c0a      	cmp	AL, #10
    7dec:	1d02      	jne	0x7df2 <_HandleActCfrCtrl+0x46>
				{
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7dee:	6003      	lod	AL, #3
    7df0:	0001      	jmp	0x7df4 <_HandleActCfrCtrl+0x48>
				}
				else
				{
					//TODO,Ban,what to do if during initalization?
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_CALIBRATION;
    7df2:	6005      	lod	AL, #5
    7df4:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
				}
				if(pCfrCtrl->byStallEnable == C_CTRL_STALL_ENABLE)
    7df6:	620b      	lod	AL, [S-12]
    7df8:	9408      	and	AL, #8
    7dfa:	1902      	je	0x7e00 <_HandleActCfrCtrl+0x54>
				{
					g_e8StallDetectorEna = C_STALLDET_H;
    7dfc:	6004      	lod	AL, #4
    7dfe:	0001      	jmp	0x7e02 <_HandleActCfrCtrl+0x56>
				}
				else
				{
					g_e8StallDetectorEna = C_STALLDET_NONE;
    7e00:	6000      	lod	AL, #0
    7e02:	41ee      	mov	dp:0xee <_g_e8StallDetectorEna>, AL
    7e04:	002a      	jmp	0x7e5a <_HandleActCfrCtrl+0xae>
				}
			}else{
				g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;
    7e06:	6000      	lod	AL, #0
    7e08:	411c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, AL
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    7e0a:	6001      	lod	AL, #1
    7e0c:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    7e0e:	0025      	jmp	0x7e5a <_HandleActCfrCtrl+0xae>
			}
		}
		else
		{
			g_u16TargetPosition = (((uint32)g_u16EXVTargetPositionTemp)*g_u16CalibTravel+128)/255 + C_EXV_ZERO_POS;//update the target position in degrade mode,
    7e10:	71f6      	lod	A, dp:0xf6 <_g_u16CalibTravel>
    7e12:	4801      	mulu	D, A, Y
    7e14:	72ef      	lod	A, S
    7e16:	a0fc      	add	A, #-4
    7e18:	4cf3      	swap	YA
    7e1a:	4c85      	mov	[Y], D
    7e1c:	7203      	lod	A, [S-4]
    7e1e:	a2da 0080 	add	A, #128
    7e22:	5203      	mov	[S-4], A
    7e24:	7201      	lod	A, [S-2]
    7e26:	b000      	adc	A, #0
    7e28:	5201      	mov	[S-2], A
    7e2a:	54ca 00ff 	pushw	#255
    7e2e:	54ca 0000 	pushw	#0
    7e32:	7207      	lod	A, [S-8]
    7e34:	7a05      	lod	Y, [S-6]
    7e36:	82db 6c94 	callf	0x6c94 <___udivsi3>
    7e3a:	5c03      	dec	S, #4
    7e3c:	5209      	mov	[S-10], A
    7e3e:	5a07      	mov	[S-8], Y
    7e40:	658e      	lod	YL, dp:0x8e <_g_NvramUser+0x34>
    7e42:	44b6      	lsr	Y, #2
    7e44:	44b6      	lsr	Y, #2
    7e46:	4436      	lsr	Y
    7e48:	f403      	and	Y, #3
    7e4a:	7064      	lod	A, #100
    7e4c:	ec00      	cmp	Y, #0
    7e4e:	1b03      	jsle	0x7e56 <_HandleActCfrCtrl+0xaa>
    7e50:	46e9      	mov	Cx, YL
    7e52:	4422      	asl	A
    7e54:	1ffe      	djnz	Cx, 0x7e52 <_HandleActCfrCtrl+0xa6>
    7e56:	a209      	add	A, [S-10]
    7e58:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
		}
		if ( (pCfrCtrl->byTorqueLevel >= C_CTRL_TORQUE_NOMINAL) && (pCfrCtrl->byTorqueLevel <= C_CTRL_TORQUE_BOOST_40PCT) )
    7e5a:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x2>
    7e5c:	4205      	mov	[S-6], AL
    7e5e:	9406      	and	AL, #6
    7e60:	190d      	je	0x7e7c <_HandleActCfrCtrl+0xd0>
    7e62:	6205      	lod	AL, [S-6]
    7e64:	4430      	lsr	AL
    7e66:	9403      	and	AL, #3
    7e68:	4204      	mov	[S-5], AL
    7e6a:	8c03      	cmp	AL, #3
    7e6c:	1e07      	jug	0x7e7c <_HandleActCfrCtrl+0xd0>
		{
			g_u8TorqueBoostRequest = (pCfrCtrl->byTorqueLevel - C_CTRL_TORQUE_NOMINAL) * 10U;
    7e6e:	640a      	lod	YL, #10
    7e70:	4829      	mulu	Y, AL, YL
    7e72:	62e8      	lod	AL, YL
    7e74:	80f6      	add	AL, #-10
    7e76:	42d8 010a 	mov	0x10a <_g_u8TorqueBoostRequest>, AL
    7e7a:	0005      	jmp	0x7e86 <_HandleActCfrCtrl+0xda>
		}
		else//undefined torque, just stop the motor
		{
			g_u8TorqueBoostRequest = C_CTRL_TORQUE_NO;
    7e7c:	6000      	lod	AL, #0
    7e7e:	42d8 010a 	mov	0x10a <_g_u8TorqueBoostRequest>, AL
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    7e82:	6001      	lod	AL, #1
    7e84:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		}

		g_u8ChipResetOcc = FALSE;											/* Clear 'reset'-flag only after CFR_INI (4.2.6.3) */
    7e86:	6000      	lod	AL, #0
    7e88:	4129      	mov	dp:0x29 <_g_u8ChipResetOcc>, AL
    7e8a:	540d      	ret	#14

00007e8c <_HandleActRfrSta>:
 *	Byte 4	|			Reserved			|	ArcState	|	InitState	|
 *			+-------------------------------+---------------+---------------+
 *
 * ****************************************************************************	*/
void HandleActRfrSta( void)
{
    7e8c:	5817      	inc	S, #24
	ACT_RFR_STA *pRfrSta = (ACT_RFR_STA *)LinFrameDataBuffer;

	/*	if ( g_u8SAE_ErrorFlags != 0 )		(MMP160613-1) */
	if ( g_u8ErrorCommunication != FALSE )
    7e8e:	62d8 011d 	lod	AL, 0x11d <_g_u8ErrorCommunication>
    7e92:	4207      	mov	[S-8], AL
    7e94:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer>
    7e96:	4212      	mov	[S-19], AL
    7e98:	62d8 0101 	lod	AL, 0x101 <_g_e8EXVStatusFaultState>
    7e9c:	4211      	mov	[S-18], AL
    7e9e:	6207      	lod	AL, [S-8]
    7ea0:	1903      	je	0x7ea8 <_HandleActRfrSta+0x1c>
	{
		pRfrSta->byLinErr = C_STATUS_LIN_ERR;
    7ea2:	6212      	lod	AL, [S-19]
    7ea4:	8401      	or	AL, #1
    7ea6:	0002      	jmp	0x7eac <_HandleActRfrSta+0x20>
	}
	else
	{
		pRfrSta->byLinErr = C_STATUS_LIN_OK;
    7ea8:	6212      	lod	AL, [S-19]
    7eaa:	94fe      	and	AL, #-2
    7eac:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
	}
	g_u8SAE_SendErrorState = g_u8ErrorCommunication;
    7eae:	62d8 011d 	lod	AL, 0x11d <_g_u8ErrorCommunication>
    7eb2:	4133      	mov	dp:0x33 <_g_u8SAE_SendErrorState>, AL

	pRfrSta->byFaultState = g_e8EXVStatusFaultState;
    7eb4:	6211      	lod	AL, [S-18]
    7eb6:	940f      	and	AL, #15
    7eb8:	4420      	asl	AL
    7eba:	4217      	mov	[S-24], AL
    7ebc:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer>
    7ebe:	94e1      	and	AL, #-31
    7ec0:	66e0      	lod	YL, AL
    7ec2:	6217      	lod	AL, [S-24]
    7ec4:	86e8      	or	AL, YL
    7ec6:	66e0      	lod	YL, AL
    7ec8:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL

	if ( (g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0 )
    7eca:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7ecc:	b401      	and	A, #1
    7ece:	1d03      	jne	0x7ed6 <_HandleActRfrSta+0x4a>
	{
		pRfrSta->byMoveState = C_STATUS_MOVE_IDLE;
    7ed0:	62e8      	lod	AL, YL
    7ed2:	94df      	and	AL, #-33
    7ed4:	0002      	jmp	0x7eda <_HandleActRfrSta+0x4e>
	}
	else
	{
		pRfrSta->byMoveState = C_STATUS_MOVE_ACTIVE;
    7ed6:	62e8      	lod	AL, YL
    7ed8:	8420      	or	AL, #32
    7eda:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
	}

	if ( (g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0 )
    7edc:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7ede:	7ae2      	lod	Y, A
    7ee0:	f401      	and	Y, #1
    7ee2:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer>
    7ee4:	4212      	mov	[S-19], AL
    7ee6:	72d8 00fe 	lod	A, 0xfe <_g_u16EXVStatusCurrentPositon>
    7eea:	520f      	mov	[S-16], A
    7eec:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x3>
    7eee:	420d      	mov	[S-14], AL
    7ef0:	62d8 00fd 	lod	AL, 0xfd <_g_e8EXVStatusInitStat>
    7ef4:	420c      	mov	[S-13], AL
    7ef6:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x1>
    7ef8:	420b      	mov	[S-12], AL
    7efa:	62d8 011f 	lod	AL, 0x11f <_l_u8StaCounter>
    7efe:	420a      	mov	[S-11], AL
    7f00:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    7f02:	4209      	mov	[S-10], AL
    7f04:	ec00      	cmp	Y, #0
    7f06:	1d03      	jne	0x7f0e <_HandleActRfrSta+0x82>
	{
		pRfrSta->byTorqueLevel = (uint8)C_CTRL_TORQUE_NO;
    7f08:	6212      	lod	AL, [S-19]
    7f0a:	943f      	and	AL, #63
    7f0c:	0012      	jmp	0x7f32 <_HandleActRfrSta+0xa6>
    7f0e:	66d8 010a 	lod	YL, 0x10a <_g_u8TorqueBoostRequest>
    7f12:	5cf6      	usex	Y
    7f14:	5a05      	mov	[S-6], Y
    7f16:	7205      	lod	A, [S-6]
    7f18:	7800      	lod	Y, #0
    7f1a:	5205      	mov	[S-6], A
    7f1c:	5a03      	mov	[S-4], Y
    7f1e:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    7f20:	4c63      	divu	YA, X
    7f22:	4c63      	divu	YA, X
    7f24:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    7f26:	44d0      	rr	AL, #2
    7f28:	94c0      	and	AL, #-64
    7f2a:	4216      	mov	[S-23], AL
    7f2c:	6212      	lod	AL, [S-19]
    7f2e:	943f      	and	AL, #63
    7f30:	8616      	or	AL, [S-23]
    7f32:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer>, AL
	{
		pRfrSta->byTorqueLevel = (uint8) divU16_U32byU16( (uint32) g_u8TorqueBoostRequest, 10U);
	}

	//Byte 2
	pRfrSta->byActPositionLSB = g_u16EXVStatusCurrentPositon&0xFF;
    7f34:	620f      	lod	AL, [S-16]
    7f36:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x2>, AL
	pRfrSta->byActPositionMSB = (g_u16EXVStatusCurrentPositon>>8)&0x3;
    7f38:	7a0f      	lod	Y, [S-16]
    7f3a:	6400      	lod	YL, #0
    7f3c:	7ae8      	swap	Y
    7f3e:	5a0f      	mov	[S-16], Y
    7f40:	620f      	lod	AL, [S-16]
    7f42:	9403      	and	AL, #3
    7f44:	4215      	mov	[S-22], AL
    7f46:	620d      	lod	AL, [S-14]
    7f48:	94fc      	and	AL, #-4
    7f4a:	8615      	or	AL, [S-22]
    7f4c:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x3>, AL

	//Byte 3
	pRfrSta->byInitState = g_e8EXVStatusInitStat;
    7f4e:	620c      	lod	AL, [S-13]
    7f50:	9403      	and	AL, #3
    7f52:	4214      	mov	[S-21], AL
    7f54:	620b      	lod	AL, [S-12]
    7f56:	94f0      	and	AL, #-16
    7f58:	4213      	mov	[S-20], AL

	pRfrSta->byArcState = l_u8StaCounter;
    7f5a:	620a      	lod	AL, [S-11]
    7f5c:	9403      	and	AL, #3
    7f5e:	44a0      	asl	AL, #2
    7f60:	4205      	mov	[S-6], AL
    7f62:	6213      	lod	AL, [S-20]
    7f64:	8614      	or	AL, [S-21]
    7f66:	66e0      	lod	YL, AL
    7f68:	6205      	lod	AL, [S-6]
    7f6a:	86e8      	or	AL, YL
    7f6c:	66e0      	lod	YL, AL
    7f6e:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
	l_u8StaCounter++;
    7f70:	620a      	lod	AL, [S-11]
    7f72:	8001      	add	AL, #1
    7f74:	42d8 011f 	mov	0x11f <_l_u8StaCounter>, AL

	if(g_e8EXVErrorBlock == TRUE)
    7f78:	6209      	lod	AL, [S-10]
    7f7a:	8c01      	cmp	AL, #1
    7f7c:	1d03      	jne	0x7f84 <_HandleActRfrSta+0xf8>
	{
		pRfrSta->byStallDetectStatus = TRUE;
    7f7e:	62e8      	lod	AL, YL
    7f80:	8410      	or	AL, #16
    7f82:	0002      	jmp	0x7f88 <_HandleActRfrSta+0xfc>
	}
	else
	{
		pRfrSta->byStallDetectStatus = FALSE;
    7f84:	62e8      	lod	AL, YL
    7f86:	94ef      	and	AL, #-17
    7f88:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x1>, AL
    7f8a:	5419      	ret	#26

00007f8c <_HandleBusTimeout>:
 *  Bus-timeout
 * ****************************************************************************	*/
void HandleBusTimeout( void)
{
#if _SUPPORT_BUSTIMEOUT
	if ( g_u8ErrorCommBusTimeout == FALSE )
    7f8c:	62d8 011c 	lod	AL, 0x11c <_g_u8ErrorCommBusTimeout>
    7f90:	1d14      	jne	0x7fba <_HandleBusTimeout+0x2e>
	{
		/* Emergency run is enabled */
		g_u8ErrorCommBusTimeout = TRUE;
    7f92:	6001      	lod	AL, #1
    7f94:	42d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, AL
		SetLastError( (uint8) C_ERR_LIN_BUS_TIMEOUT);
    7f98:	72da 00bf 	lod	A, #191
    7f9c:	82db 8c66 	callf	0x8c66 <_SetLastError>

		if ( g_NvramUser.EmergencyRunEna != FALSE )
    7fa0:	616a      	lod	AL, dp:0x6a <_g_NvramUser+0x10>
    7fa2:	4432      	lsr	A
    7fa4:	b401      	and	A, #1
    7fa6:	1909      	je	0x7fba <_HandleBusTimeout+0x2e>
		{
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7fa8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    7faa:	8c00      	cmp	AL, #0
    7fac:	1e84      	jsge	0x7fb6 <_HandleBusTimeout+0x2a>
			{
				/* Module is in degraded-mode; Postpone emergency-run till after degraded-mode have been obsoleted */
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    7fae:	6007      	lod	AL, #7
    7fb0:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
				g_e8DegradedMotorRequest = g_e8MotorRequest;
    7fb2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
    7fb4:	5401      	ret
			}
			else
			{
				/* Perform emergency-run immediately */
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    7fb6:	6007      	lod	AL, #7
    7fb8:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    7fba:	5401      	ret

00007fbc <_LIN2J_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2J_ErrorHandling( ml_LinError Error)
{
    7fbc:	5805      	inc	S, #6
    7fbe:	7ee2      	lod	X, A
	uint8 u8FrameID = (uint8) (LinProtectedID & 0x3F);							/* Get Frame-ID without parity bits */
    7fc0:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    7fc2:	7ae2      	lod	Y, A
    7fc4:	f43f      	and	Y, #63
    7fc6:	5a05      	mov	[S-6], Y
	if ( (u8FrameID == (uint8) ML_MRF_ID) && ((Error == ml_erDataFraming) || (Error == ml_erCheckSum)) )
    7fc8:	6205      	lod	AL, [S-6]
    7fca:	8c3c      	cmp	AL, #60
    7fcc:	1d06      	jne	0x7fda <_LIN2J_ErrorHandling+0x1e>
    7fce:	2c06      	cmp	X, #6
    7fd0:	1902      	je	0x7fd6 <_LIN2J_ErrorHandling+0x1a>
    7fd2:	2c04      	cmp	X, #4
    7fd4:	1d02      	jne	0x7fda <_LIN2J_ErrorHandling+0x1e>
	{
		/*
		 * Abort Diagnostic communication with corrupted Diagnostic request
		 * Checked by LIN2.1 CT test case 13.2.2
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    7fd6:	60ff      	lod	AL, #-1
    7fd8:	4131      	mov	dp:0x31 <_g_u8BufferOutID>, AL
	}

	/* ---- ml_erLinModuleReset -------------------------------------------- */
	if ( Error == ml_erLinModuleReset )
    7fda:	2c02      	cmp	X, #2
    7fdc:	1d01      	jne	0x7fe0 <_LIN2J_ErrorHandling+0x24>
    7fde:	002a      	jmp	0x8034 <_LIN2J_ErrorHandling+0x78>
	{
		/* Non-recoverable failure has occurred in the LIN Module */
		/* switch to System Mode and reinitialise LIN module */
	}
	/* ---- ml_erIdParity -------------------------------------------------- */
	else if ( Error == ml_erIdParity )
    7fe0:	2c03      	cmp	X, #3
    7fe2:	1928      	je	0x8034 <_LIN2J_ErrorHandling+0x78>
	{
		/* Do NOT set response_error bit, because error occurred in a header */
	}
	else if ( u8FrameID == (((g_u8NAD & 0x0F) << 2) + 0x01) )
    7fe4:	6134      	lod	AL, dp:0x34 <_g_u8NAD>
    7fe6:	4203      	mov	[S-4], AL
    7fe8:	66e0      	lod	YL, AL
    7fea:	f40f      	and	Y, #15
    7fec:	44a6      	asl	Y, #2
    7fee:	72e6      	lod	A, Y
    7ff0:	a001      	add	A, #1
    7ff2:	5201      	mov	[S-2], A
    7ff4:	7205      	lod	A, [S-6]
    7ff6:	ae01      	cmp	A, [S-2]
    7ff8:	1d06      	jne	0x8006 <_LIN2J_ErrorHandling+0x4a>
	{
		/* Status Frame */
		if ( Error == ml_erIdFraming )
    7ffa:	2c07      	cmp	X, #7
    7ffc:	1d1b      	jne	0x8034 <_LIN2J_ErrorHandling+0x78>
		{
			g_u8ErrorCommunication = TRUE;
    7ffe:	6001      	lod	AL, #1
    8000:	42d8 011d 	mov	0x11d <_g_u8ErrorCommunication>, AL
    8004:	5407      	ret	#8
		}
	}
	else if ( (u8FrameID == (((g_u8NAD & 0x0F) << 2) + 0x00)) ||			/* 1.3.4.2 */
    8006:	7205      	lod	A, [S-6]
    8008:	aee6      	cmp	A, Y
    800a:	190b      	je	0x8022 <_LIN2J_ErrorHandling+0x66>
    800c:	8c3c      	cmp	AL, #60
    800e:	1d03      	jne	0x8016 <_LIN2J_ErrorHandling+0x5a>
    8010:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
    8012:	8e03      	cmp	AL, [S-4]
    8014:	1906      	je	0x8022 <_LIN2J_ErrorHandling+0x66>
    8016:	6205      	lod	AL, [S-6]
    8018:	8c3d      	cmp	AL, #61
    801a:	1d0c      	jne	0x8034 <_LIN2J_ErrorHandling+0x78>
    801c:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
    801e:	8e03      	cmp	AL, [S-4]
    8020:	1d09      	jne	0x8034 <_LIN2J_ErrorHandling+0x78>
			  ((u8FrameID == ML_MRF_ID) && (LinFrame[0] == g_u8NAD)) ||		/* 1.3.4.3 */
			  ((u8FrameID == ML_SRF_ID) && (LinFrame[0] == g_u8NAD)) )		/* 1.3.4.3 */
	{
		/* Control frame or Diagnostics frame */
		if ( (Error == ml_erCheckSum) || (Error == ml_erDataFraming) || (Error == ml_erIdFraming) )
    8022:	2c04      	cmp	X, #4
    8024:	1904      	je	0x802e <_LIN2J_ErrorHandling+0x72>
    8026:	2c06      	cmp	X, #6
    8028:	1902      	je	0x802e <_LIN2J_ErrorHandling+0x72>
    802a:	2c07      	cmp	X, #7
    802c:	1d03      	jne	0x8034 <_LIN2J_ErrorHandling+0x78>
		{
			g_u8ErrorCommunication = TRUE;
    802e:	6001      	lod	AL, #1
    8030:	42d8 011d 	mov	0x11d <_g_u8ErrorCommunication>, AL
    8034:	5407      	ret	#8

00008036 <_SetupDiagResponse>:

/* ****************************************************************************	*
 * SetupDiagResponse
 * ****************************************************************************	*/
void SetupDiagResponse( uint8 u8NAD, uint8 u8SID, uint8 u8ResponseCode)
{
    8036:	5801      	inc	S, #2
    8038:	6605      	lod	YL, [S-6]
    803a:	5cf6      	usex	Y
    803c:	5a01      	mov	[S-2], Y
    803e:	6607      	lod	YL, [S-8]
    8040:	5cf6      	usex	Y
	g_DiagResponse.byNAD = u8NAD;
    8042:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
	if ( u8ResponseCode == (uint8) C_ERRCODE_POSITIVE_RESPONSE )
    8044:	1d09      	jne	0x8058 <_SetupDiagResponse+0x22>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x01|  SID | Reserved | Reserved | Reserved | Reserved | Reserved |
		 *	|  NAD  |     | |0x40|   0xFF   |   0xFF   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_REASSIGN_NAD;
    8046:	6001      	lod	AL, #1
    8048:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (u8SID | C_RSID_OK);
    804a:	6201      	lod	AL, [S-2]
    804c:	8440      	or	AL, #64
    804e:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    8050:	60ff      	lod	AL, #-1
    8052:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    8054:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
    8056:	0007      	jmp	0x8066 <_SetupDiagResponse+0x30>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x03| 0x7F | Requested| Response | Reserved | Reserved | Reserved |
		 *	|  NAD  |     |      |    SID   |   Code   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_NOK;
    8058:	6003      	lod	AL, #3
    805a:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_RSID_NOK;
    805c:	607f      	lod	AL, #127
    805e:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = u8SID;
    8060:	6201      	lod	AL, [S-2]
    8062:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = u8ResponseCode;
    8064:	4548      	mov	dp:0x48 <_g_DiagResponse+0x4>, YL
	}

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    8066:	6007      	lod	AL, #7
    8068:	4131      	mov	dp:0x31 <_g_u8BufferOutID>, AL
    806a:	5403      	ret	#4

0000806c <_CheckSupplier>:
/* ****************************************************************************	*
 * CheckSupplier
 * ****************************************************************************	*/
uint16 CheckSupplier( uint16 const u16SupplierID)
{
	uint16 u16Result = FALSE;
    806c:	7800      	lod	Y, #0
	if ( (u16SupplierID == (uint16) C_WILDCARD_SUPPLIER_ID)
    806e:	aeda 7fff 	cmp	A, #32767
    8072:	1903      	je	0x807a <_CheckSupplier+0xe>
    8074:	aeda 0124 	cmp	A, #292
    8078:	1d01      	jne	0x807c <_CheckSupplier+0x10>
		|| (u16SupplierID == (uint16)C_SUPPLIER_ID) )
	{
		u16Result = TRUE;
    807a:	7801      	lod	Y, #1
	}
	return ( u16Result );
} /* End of CheckSupplier() */
    807c:	72e6      	lod	A, Y
    807e:	5401      	ret

00008080 <_ValidSupplierFunctionID>:
 * Pre:		Pointer to address of supplier and function ID
 * Post:	FALSE: Incorrect supplier and/or function ID
 *			TRUE: Correct supplier and function ID
 * ****************************************************************************	*/
uint16 ValidSupplierFunctionID( uint16 const u16SupplierID, uint16 const u16FunctionID )
{
    8080:	7a03      	lod	Y, [S-4]
	uint16 u16Result = FALSE;
    8082:	7c00      	lod	X, #0
	if ( ((u16SupplierID == C_SUPPLIER_ID)
    8084:	aeda 0124 	cmp	A, #292
    8088:	1903      	je	0x8090 <_ValidSupplierFunctionID+0x10>
    808a:	aeda 7fff 	cmp	A, #32767
    808e:	1d06      	jne	0x809c <_ValidSupplierFunctionID+0x1c>
    8090:	eeda 00b0 	cmp	Y, #176
    8094:	1902      	je	0x809a <_ValidSupplierFunctionID+0x1a>
    8096:	ecff      	cmp	Y, #-1
    8098:	1d01      	jne	0x809c <_ValidSupplierFunctionID+0x1c>
		|| (u16SupplierID == C_WILDCARD_SUPPLIER_ID)) &&
		((u16FunctionID == C_FUNCTION_ID)
		|| (u16FunctionID == C_WILDCARD_FUNCTION_ID)) )
	{
		u16Result = TRUE;
    809a:	7c01      	lod	X, #1
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */
    809c:	72ee      	lod	A, X
    809e:	5401      	ret

000080a0 <_HandleDfrDiag>:

/* ****************************************************************************	*
 * Diagnostic
 * ****************************************************************************	*/
void HandleDfrDiag( void)
{
    80a0:	581b      	inc	S, #28
	}
	else if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == (uint8) C_BROADCAST_NAD) )
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
	/* Targeted or Broadcast */
	if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == C_BROADCAST_J2602_NAD) )
    80a2:	613c      	lod	AL, dp:0x3c <__data_dp_end>
    80a4:	4203      	mov	[S-4], AL
    80a6:	62d8 0034 	lod	AL, 0x34 <_g_u8NAD>
    80aa:	421b      	mov	[S-28], AL
    80ac:	6203      	lod	AL, [S-4]
    80ae:	8e1b      	cmp	AL, [S-28]
    80b0:	1903      	je	0x80b8 <_HandleDfrDiag+0x18>
    80b2:	8c7f      	cmp	AL, #127
    80b4:	1901      	je	0x80b8 <_HandleDfrDiag+0x18>
    80b6:	0345      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		uint16 u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8) | ((uint16)pDiag->bySID);
    80b8:	6d3d      	lod	YH, dp:0x3d <__data_dp_end+0x1>
    80ba:	6400      	lod	YL, #0
    80bc:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x2>
    80be:	4217      	mov	[S-24], AL
    80c0:	5cf2      	usex	A
    80c2:	5219      	mov	[S-26], A
    80c4:	e6e2      	or	Y, A

		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    80c6:	60ff      	lod	AL, #-1
    80c8:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    80ca:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    80cc:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    80ce:	414a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    80d0:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_COND_SEQ);	/* Status = Negative feedback */
			SetLastError( (uint8) C_ERR_LIN2X_WRITE);
		}
		else if ( (u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD) && (pDiag->byNAD != (uint8) C_DEFAULT_NAD) )
#else  /* ((LINPROT & LINXX) == LIN2X) */
		if ( u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD )
    80d2:	eeda 06b0 	cmp	Y, #1712
    80d6:	1901      	je	0x80da <_HandleDfrDiag+0x3a>
    80d8:	0038      	jmp	0x814a <_HandleDfrDiag+0xaa>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB0 | Supplier | Supplier | Function | Function |  New NAD |
			 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8)) )
    80da:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    80dc:	5cf2      	usex	A
    80de:	7ee2      	lod	X, A
    80e0:	6942      	lod	AH, dp:0x42 <__data_dp_end+0x6>
    80e2:	6000      	lod	AL, #0
    80e4:	26e2      	or	X, A
    80e6:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x4>
    80e8:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
    80ea:	5edf      	push	X
    80ec:	17c9      	call	0x8080 <_ValidSupplierFunctionID>
    80ee:	5c01      	dec	S, #2
    80f0:	ac00      	cmp	A, #0
    80f2:	1d01      	jne	0x80f6 <_HandleDfrDiag+0x56>
    80f4:	0326      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
			{
				uint8 byInitialNAD = g_NvramUser.NAD;
    80f6:	615c      	lod	AL, dp:0x5c <_g_NvramUser+0x2>
    80f8:	5cf2      	usex	A
    80fa:	5215      	mov	[S-22], A
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);		/* Status = Negative feedback */
				}
				else
#endif /* ((LINPROT & LINXX) == LIN2J) */
				{
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);				/* Status = Pending */
    80fc:	54ca 0078 	pushw	#120
    8100:	7a1b      	lod	Y, [S-28]
    8102:	5adf      	push	Y
    8104:	7219      	lod	A, [S-26]
    8106:	1797      	call	0x8036 <_SetupDiagResponse>
					g_NvramUser.NAD = pDiag->byD5;
    8108:	6143      	lod	AL, dp:0x43 <__data_dp_end+0x7>
    810a:	415c      	mov	dp:0x5c <_g_NvramUser+0x2>, AL
					g_u8NAD = g_NvramUser.NAD;
    810c:	42d8 0034 	mov	0x34 <_g_u8NAD>, AL
					/* Store NVRAM */
					if ( (NVRAM_Store( (uint16) C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.NAD == pDiag->byD5) )
    8110:	7003      	lod	A, #3
    8112:	82db 9a3c 	callf	0x9a3c <_NVRAM_Store>
    8116:	5c03      	dec	S, #4
    8118:	ac00      	cmp	A, #0
    811a:	1d0a      	jne	0x8130 <_HandleDfrDiag+0x90>
    811c:	6143      	lod	AL, dp:0x43 <__data_dp_end+0x7>
    811e:	8d5c      	cmp	AL, dp:0x5c <_g_NvramUser+0x2>
    8120:	1d07      	jne	0x8130 <_HandleDfrDiag+0x90>
					{
						/* NAD changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    8122:	54ca 0000 	pushw	#0
    8126:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x2>
    8128:	5cf2      	usex	A
    812a:	52df      	push	A
    812c:	7219      	lod	A, [S-26]
    812e:	0284      	jmp	0x8638 <_HandleDfrDiag+0x598>
					}
					else
					{
						/* NAD couldn't be changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);		/* Status = Negative feedback */
    8130:	54ca 0012 	pushw	#18
    8134:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x2>
    8136:	5cf2      	usex	A
    8138:	52df      	push	A
    813a:	7219      	lod	A, [S-26]
    813c:	177c      	call	0x8036 <_SetupDiagResponse>
						SetLastError( (uint8) C_ERR_LIN2X_B0);
    813e:	72da 00b0 	lod	A, #176
    8142:	82db 8c66 	callf	0x8c66 <_SetLastError>
    8146:	5c03      	dec	S, #4
    8148:	541d      	ret	#30
					SetLastError( (uint8) C_ERR_LIN2X_B1);
				}
			}
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else if ( u16DiagPCI_SID == C_PCI_SID_READ_BY_ID )
    814a:	eeda 06b2 	cmp	Y, #1714
    814e:	1901      	je	0x8152 <_HandleDfrDiag+0xb2>
    8150:	0043      	jmp	0x81d8 <_HandleDfrDiag+0x138>
			 * (0x40-0xFF: Reserved)
			 * (M) = Mandatory
			 * (O) = Optional
			 * (U) = User defined
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD2) | ((uint16)(pDiag->byD3) << 8), (pDiag->byD4) | ((uint16)(pDiag->byD5) << 8)) )
    8152:	6142      	lod	AL, dp:0x42 <__data_dp_end+0x6>
    8154:	5cf2      	usex	A
    8156:	7ee2      	lod	X, A
    8158:	6943      	lod	AH, dp:0x43 <__data_dp_end+0x7>
    815a:	6000      	lod	AL, #0
    815c:	26e2      	or	X, A
    815e:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x5>
    8160:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x4>
    8162:	5edf      	push	X
    8164:	178d      	call	0x8080 <_ValidSupplierFunctionID>
    8166:	5c01      	dec	S, #2
    8168:	ac00      	cmp	A, #0
    816a:	1d01      	jne	0x816e <_HandleDfrDiag+0xce>
    816c:	02ea      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
			{
				if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    816e:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
    8170:	1d0d      	jne	0x818c <_HandleDfrDiag+0xec>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xF2 | Supplier | Supplier | Function | Function |  Variant |
					 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    8172:	621b      	lod	AL, [S-28]
    8174:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
    8176:	6006      	lod	AL, #6
    8178:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    817a:	60f2      	lod	AL, #-14
    817c:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
    817e:	60b0      	lod	AL, #-80
    8180:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8182:	72da 0124 	lod	A, #292
    8186:	7ada 00b0 	lod	Y, #176
    818a:	000a      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
					StoreD1to4( C_SUPPLIER_ID, C_FUNCTION_ID);					/* Supplier & Function-ID */
				}
				else if ( pDiag->byD1 == C_SERIAL_NR_ID )
    818c:	8c01      	cmp	AL, #1
    818e:	1d0f      	jne	0x81ae <_HandleDfrDiag+0x10e>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x05| 0xF2 | SerialNr | SerialNr | SerialNr | SerialNr | Reserved |
					 *	|     |     |      |   (LSB)  |		     |          |   (MSB)  |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    8190:	661b      	lod	YL, [S-28]
    8192:	4544      	mov	dp:0x44 <_g_DiagResponse>, YL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
    8194:	6005      	lod	AL, #5
    8196:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    8198:	60f2      	lod	AL, #-14
    819a:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    819c:	7166      	lod	A, dp:0x66 <_g_NvramUser+0xc>
    819e:	7968      	lod	Y, dp:0x68 <_g_NvramUser+0xe>
	__asm__ __volatile__
    81a0:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
    81a2:	4948      	mov	dp:0x48 <_g_DiagResponse+0x4>, AH
    81a4:	4549      	mov	dp:0x49 <_g_DiagResponse+0x5>, YL
    81a6:	4d4a      	mov	dp:0x4a <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    81a8:	6007      	lod	AL, #7
    81aa:	4131      	mov	dp:0x31 <_g_u8BufferOutID>, AL
    81ac:	541d      	ret	#30
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
					StoreD1to4( g_NvramUser.SerialNumberLSW, g_NvramUser.SerialNumberMSW);	/* Serial-number */
				}
#if (LINPROT == LIN2J_VALVE_GM)
				else if ( pDiag->byD1 == (uint8) C_SVN_ID )
    81ae:	8c30      	cmp	AL, #48
    81b0:	1d09      	jne	0x81c4 <_HandleDfrDiag+0x124>
				{
					g_DiagResponse.byNAD = g_u8NAD;
    81b2:	621b      	lod	AL, [S-28]
    81b4:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
    81b6:	6005      	lod	AL, #5
    81b8:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    81ba:	60f2      	lod	AL, #-14
    81bc:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    81be:	7001      	lod	A, #1
    81c0:	78ff      	lod	Y, #-1
    81c2:	07ee      	jmp	0x81a0 <_HandleDfrDiag+0x100>
				}
#endif /* ((LINPROT & LINXX) == LIN2X) */
				else
				{
					/* Identifier not supported */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    81c4:	621b      	lod	AL, [S-28]
    81c6:	5cf2      	usex	A
    81c8:	54ca 0012 	pushw	#18
    81cc:	7a1b      	lod	Y, [S-28]
    81ce:	5adf      	push	Y
    81d0:	1732      	call	0x8036 <_SetupDiagResponse>
					SetLastError( (uint8) C_ERR_LIN2X_B2);
    81d2:	72da 00b2 	lod	A, #178
    81d6:	07b5      	jmp	0x8142 <_HandleDfrDiag+0xa2>
				SetLastError( (uint8) C_ERR_LIN2X_CB);
			}
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
		else if ( u16DiagPCI_SID == C_SID_PCI_RESET )	/* Targeted or Broadcast reset */
    81d8:	eeda 01b5 	cmp	Y, #437
    81dc:	1d0a      	jne	0x81f2 <_HandleDfrDiag+0x152>
		{
			/* Reset Target */
			MLX4_RESET();														/* Reset the Mlx4   */
    81de:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    81e2:	94fe      	and	AL, #-2
    81e4:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    81e8:	72da 3072 	lod	A, #12402
    81ec:	52d8 0338 	mov	0x338 <_bistResetInfo>, A
    81f0:	01ac      	jmp	0x854a <_HandleDfrDiag+0x4aa>
			MLX16_RESET();														/* Reset the Mlx16  */
			/* This reset restart the chip as POR, and doesn't come back (no answer) */
		}
#endif /* ((LINPROT & LINXX) == LIN2J) */
#if _SUPPORT_MLX_DEBUG_MODE
		else if ( pDiag->bySID == C_SID_MLX_DEBUG )
    81f2:	6217      	lod	AL, [S-24]
    81f4:	8cdb      	cmp	AL, #-37
    81f6:	1901      	je	0x81fa <_HandleDfrDiag+0x15a>
    81f8:	0221      	jmp	0x863c <_HandleDfrDiag+0x59c>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| Debug| Supplier | Supplier | Param #1 | Param #2 | Function |
			 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |    ID    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			uint16 u16SupplierID = (((uint16) pDiag->byD2) << 8) | ((uint16) pDiag->byD1);
    81fa:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x4>
    81fc:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
			if ( u16SupplierID == C_SUPPLIER_ID )
    81fe:	aeda 0124 	cmp	A, #292
    8202:	1901      	je	0x8206 <_HandleDfrDiag+0x166>
    8204:	0213      	jmp	0x862c <_HandleDfrDiag+0x58c>
			{
				/* MMP131024-1: Reply diagnostics response with NAD, length and RSID.*/
				g_DiagResponse.byNAD = g_u8NAD;
    8206:	661b      	lod	YL, [S-28]
    8208:	4544      	mov	dp:0x44 <_g_DiagResponse>, YL
				g_DiagResponse.byPCI = 0x06;
    820a:	6006      	lod	AL, #6
    820c:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
    820e:	6217      	lod	AL, [S-24]
    8210:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
				 * 0xF8: NVRAM Clear function
				 * 0xFC: Clear Fatal-handler error logging
				 * 0xFD: Get I/O-register value (16-bits)
				 * 0xFE: Get Fatal-error: error-code, info and address
				 */
				if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT )				/* MMP140519-2 - Begin */
    8212:	6143      	lod	AL, dp:0x43 <__data_dp_end+0x7>
    8214:	4213      	mov	[S-20], AL
    8216:	1d07      	jne	0x8226 <_HandleDfrDiag+0x186>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  |MLX DBG[i]|MLX DBG[i]| Reserved | Reserved |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0F);
    8218:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    821a:	b40f      	and	A, #15
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    821c:	4422      	asl	A
    821e:	7ae2      	lod	Y, A
    8220:	e2da a3e8 	add	Y, #41960
    8224:	010b      	jmp	0x843c <_HandleDfrDiag+0x39c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0F);
					StoreD1to2( tMlxDbgSupport[u16Index]);
				}																/* MMP140519-2 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_STALLDET )
    8226:	6213      	lod	AL, [S-20]
    8228:	8c5d      	cmp	AL, #93
    822a:	1d32      	jne	0x8290 <_HandleDfrDiag+0x1f0>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    822c:	7ad8 031e 	lod	Y, 0x31e <_l_u16MotorCurrentStallThrshldxN>
    8230:	44b6      	lsr	Y, #2
    8232:	44b6      	lsr	Y, #2
    8234:	44b6      	lsr	Y, #2
    8236:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    823a:	b6da 00ff 	and	A, #255
    823e:	a2da 0100 	add	A, #256
    uint32 result;

    __asm__ __volatile__ (
    8242:	4801      	mulu	D, A, Y
    8244:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8246:	4c22 0040 	add	YA, #64
    824a:	0000 
    824c:	48a6      	lsr	YA, #7
					 *	| NAD | 0x06| 0xDB |Stallcurrent|Stallcurrent|Motorcurrent|Motorcurrent|StallFlags|
					 *	|     |     |      |Thrshld(LSB)|Thrshld(LSB)|MovAvg (LSB)|MovAvg (MSB)|          |
					 *	+-----+-----+------+------------+------------+------------+------------+----------+
					 */
					uint16 u16Value = (uint16) ((mulU32_U16byU16( (l_u16MotorCurrentStallThrshldxN >> C_MOVAVG_SSZ), EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Stall motor-current threshold [mA] */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
    824e:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
					g_DiagResponse.byD2 = (uint8) (u16Value >> 8);
    8250:	4948      	mov	dp:0x48 <_g_DiagResponse+0x4>, AH
    8252:	7956      	lod	Y, dp:0x56 <__data_size>
    8254:	44b6      	lsr	Y, #2
    8256:	44b6      	lsr	Y, #2
    8258:	44b6      	lsr	Y, #2
    825a:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    825e:	b6da 00ff 	and	A, #255
    8262:	a2da 0100 	add	A, #256
    uint32 result;

    __asm__ __volatile__ (
    8266:	4801      	mulu	D, A, Y
    8268:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    826a:	4c22 0040 	add	YA, #64
    826e:	0000 
    8270:	48a6      	lsr	YA, #7
					u16Value = (uint16) ((mulU32_U16byU16( (g_u16MotorCurrentMovAvgxN >> C_MOVAVG_SSZ), EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Moving average-motor current [mA] */
					g_DiagResponse.byD3 = (uint8) (u16Value & 0xFF);
    8272:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
					g_DiagResponse.byD4 = (uint8) (u16Value >> 8);
    8274:	494a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AH
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountO & 0x07);	/* Stall detection & count */
					}
					else
#endif /* _SUPPORT_STALLDET_O */												/* MMP140330-1 */
					{
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountA & 0x07);	/* Stall detection & count */
    8276:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    8278:	9478      	and	AL, #120
    827a:	4211      	mov	[S-18], AL
    827c:	613b      	lod	AL, dp:0x3b <_l_u8StallCountA>
    827e:	9407      	and	AL, #7
    8280:	8611      	or	AL, [S-18]
    8282:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
					}
					if ( g_e8StallDetectorEna != C_STALLDET_NONE )				/* MMP130916-1 */
    8284:	61ee      	lod	AL, dp:0xee <_g_e8StallDetectorEna>
    8286:	1d01      	jne	0x828a <_HandleDfrDiag+0x1ea>
    8288:	078f      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					{
						g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;
    828a:	6000      	lod	AL, #0
    828c:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
    828e:	078c      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_INFO != FALSE)
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LINAA_1 )
    8290:	6213      	lod	AL, [S-20]
    8292:	8ca1      	cmp	AL, #-95
    8294:	1d26      	jne	0x82e2 <_HandleDfrDiag+0x242>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   Step   |  Ishunt1 |  Ishunt2 |  Ishunt3 | AA-Flags |
					 *	|     |     |      |CycleCount|          |          |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					PSNPD_DATA pSNPD_Data = LIN_AA_DATA + l_u8SNPD_CycleCountComm;
    8296:	62d8 0122 	lod	AL, 0x122 <_l_u8SNPD_CycleCountComm>
    829a:	4210      	mov	[S-17], AL
    829c:	5cf2      	usex	A
    829e:	4872 0010 	muls	A, A, #16
    82a2:	7ae2      	lod	Y, A
    82a4:	e2da 0156 	add	Y, #342
					g_DiagResponse.byD1 = (uint8) ((pSNPD_Data->byStepAndFlags << 1) & 0xF0) | (l_u8SNPD_CycleCountComm & 0x0F); /* MMP130818-1 */
    82a8:	62f0      	lod	AL, [Y]
    82aa:	420f      	mov	[S-16], AL
    82ac:	4420      	asl	AL
    82ae:	94f0      	and	AL, #-16
    82b0:	420e      	mov	[S-15], AL
    82b2:	6210      	lod	AL, [S-17]
    82b4:	940f      	and	AL, #15
    82b6:	860e      	or	AL, [S-15]
    82b8:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
					g_DiagResponse.byD2 = pSNPD_Data->byIshunt1;
    82ba:	62f1      	lod	AL, [Y+1]
    82bc:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
					g_DiagResponse.byD3 = pSNPD_Data->byIshunt2;
    82be:	62f2      	lod	AL, [Y+2]
    82c0:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
					g_DiagResponse.byD4 = pSNPD_Data->byIshunt3;
    82c2:	62f3      	lod	AL, [Y+3]
    82c4:	414a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AL
					g_DiagResponse.byD5 = (pSNPD_Data->byStepAndFlags & 0x87);	/* MMP130818-1 */
    82c6:	620f      	lod	AL, [S-16]
    82c8:	9487      	and	AL, #-121
    82ca:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
					l_u8SNPD_CycleCountComm++;
    82cc:	6210      	lod	AL, [S-17]
    82ce:	8001      	add	AL, #1
    82d0:	42d8 0122 	mov	0x122 <_l_u8SNPD_CycleCountComm>, AL
					if ( l_u8SNPD_CycleCountComm >= LIN_AA_INFO_SZ )								/* Don't increase index incase last AA-structure index */
    82d4:	8c0f      	cmp	AL, #15
    82d6:	1e01      	jug	0x82da <_HandleDfrDiag+0x23a>
    82d8:	0767      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					{
						l_u8SNPD_CycleCountComm = 0;
    82da:	6400      	lod	YL, #0
    82dc:	46d8 0122 	mov	0x122 <_l_u8SNPD_CycleCountComm>, YL
    82e0:	0763      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;											/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_SCREENTEST != FALSE)
				else if ( (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_LINAA_2) && (pDiag->byD5 <= (uint8) C_DBG_SUBFUNC_LINAA_4) )
    82e2:	6213      	lod	AL, [S-20]
    82e4:	805e      	add	AL, #94
    82e6:	8c02      	cmp	AL, #2
    82e8:	1e19      	jug	0x831c <_HandleDfrDiag+0x27c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |CycleCount|CommonMode|CommonMode|DifferMode|DifferMode|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					PSNPD_DATA pSNPD_Data = LIN_AA_DATA + l_u8SNPD_CycleCountComm;
    82ea:	66d8 0122 	lod	YL, 0x122 <_l_u8SNPD_CycleCountComm>
    82ee:	62e8      	lod	AL, YL
    82f0:	5cf2      	usex	A
    82f2:	4872 0010 	muls	A, A, #16
    82f6:	7ee2      	lod	X, A
    82f8:	22da 0156 	add	X, #342
					uint16 *pu16CMDM;
					g_DiagResponse.byD1 = l_u8SNPD_CycleCountComm;
    82fc:	4547      	mov	dp:0x47 <_g_DiagResponse+0x3>, YL
					if ( (pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LINAA_2))
    82fe:	6213      	lod	AL, [S-20]
    8300:	8ca2      	cmp	AL, #-94
    8302:	1d03      	jne	0x830a <_HandleDfrDiag+0x26a>
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_1);
    8304:	7aee      	lod	Y, X
    8306:	e004      	add	Y, #4
    8308:	01f6      	jmp	0x86f6 <_HandleDfrDiag+0x656>
					else if (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_LINAA_3)
    830a:	6213      	lod	AL, [S-20]
    830c:	8ca2      	cmp	AL, #-94
    830e:	1a03      	jule	0x8316 <_HandleDfrDiag+0x276>
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_2);
    8310:	7aee      	lod	Y, X
    8312:	e008      	add	Y, #8
    8314:	01f0      	jmp	0x86f6 <_HandleDfrDiag+0x656>
					else
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_3);
    8316:	7aee      	lod	Y, X
    8318:	e00c      	add	Y, #12
    831a:	01ed      	jmp	0x86f6 <_HandleDfrDiag+0x656>
					StoreD2to5( pu16CMDM[0], pu16CMDM[1]); /*lint !e415 */
				}
#endif /* (LIN_AA_SCREENTEST != FALSE) */
#endif /* (LIN_AA_INFO != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APPLSTATE )
    831c:	6213      	lod	AL, [S-20]
    831e:	8ca5      	cmp	AL, #-91
    8320:	1d25      	jne	0x836c <_HandleDfrDiag+0x2cc>
					 *	bit 5: Emergency Run occurred
					 *	bit 4: Over-temperature
					 *  bit 3:2: Voltage (In-range, UV and OV)
					 *  bit 1:0: Electric Error (Ok, Error, Permanent)
					 */
					g_DiagResponse.byD1 = g_e8MotorStatusMode;
    8322:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8324:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
					{
						uint16 u16CopyPosition = g_u16ActualPosition;
    8326:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
						g_DiagResponse.byD2 = (uint8) (u16CopyPosition & 0xFF);
    8328:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
						g_DiagResponse.byD3 = (uint8) (u16CopyPosition >> 8);
    832a:	4949      	mov	dp:0x49 <_g_DiagResponse+0x5>, AH
					}
					g_DiagResponse.byD4 = (g_e8MotorRequest & 0x0F);
    832c:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    832e:	940f      	and	AL, #15
    8330:	414a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AL
					{
						uint8 u8D5 = ((g_e8ErrorVoltage & 0x03) << 2) | (g_e8ErrorElectric & 0x03);
    8332:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    8334:	b403      	and	A, #3
    8336:	44a2      	asl	A, #2
    8338:	652d      	lod	YL, dp:0x2d <_g_e8ErrorElectric>
    833a:	f403      	and	Y, #3
    833c:	e6e2      	or	Y, A
						if ( g_e8ErrorOverTemperature != FALSE )
    833e:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    8340:	1901      	je	0x8344 <_HandleDfrDiag+0x2a4>
							u8D5 |= 0x10;
    8342:	e410      	or	Y, #16
						if ( g_u8EmergencyRunOcc != FALSE )
    8344:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    8346:	1904      	je	0x8350 <_HandleDfrDiag+0x2b0>
							u8D5 |= 0x20;
    8348:	62e8      	lod	AL, YL
    834a:	8420      	or	AL, #32
    834c:	66e0      	lod	YL, AL
    834e:	5cf6      	usex	Y
						if ( g_u8StallOcc != FALSE )
    8350:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    8352:	1904      	je	0x835c <_HandleDfrDiag+0x2bc>
							u8D5 |= 0x40;
    8354:	62e8      	lod	AL, YL
    8356:	8440      	or	AL, #64
    8358:	66e0      	lod	YL, AL
    835a:	5cf6      	usex	Y
						if (g_u8ChipResetOcc != FALSE)
    835c:	6129      	lod	AL, dp:0x29 <_g_u8ChipResetOcc>
    835e:	1904      	je	0x8368 <_HandleDfrDiag+0x2c8>
							u8D5 |= 0x80;
    8360:	62e8      	lod	AL, YL
    8362:	8480      	or	AL, #-128
    8364:	66e0      	lod	YL, AL
    8366:	5cf6      	usex	Y
						g_DiagResponse.byD5 = u8D5;
    8368:	454b      	mov	dp:0x4b <_g_DiagResponse+0x7>, YL
    836a:	071e      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;											/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_INFO && LIN_AA_SCREENTEST)
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LIN_BAUDRATE )	/* MMP130810-1 - Begin */
    836c:	6213      	lod	AL, [S-20]
    836e:	8ca6      	cmp	AL, #-90
    8370:	1d07      	jne	0x8380 <_HandleDfrDiag+0x2e0>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |  MCU_PLL |NomLINBaud|NomLINBaud|ActLINBaud|ActLINBaud|
					 *	|     |     |      |   _MULT  |rate (LSB)|rate (MSB)|rate (LSB)|rate (MSB)|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD1 = (uint8) MCU_PLL_MULT;					/* MMP131022-1 */
    8372:	6070      	lod	AL, #112
    8374:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8376:	82db 5dda 	callf	0x5dda <_ml_GetBaudRate>
    837a:	7ae2      	lod	Y, A
	__asm__ __volatile__
    837c:	70ff      	lod	A, #-1
    837e:	01bd      	jmp	0x86fa <_HandleDfrDiag+0x65a>
					g_DiagResponse.byD5 = (uint8) (u16Baudrate >> 8);
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
				}																/* MMP130810-1 - End */
#endif /* (LIN_AA_INFO && LIN_AA_SCREENTEST) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_RESTART_AUTO_BAUDRATE )	/* MMP130828-1 - Begin */
    8380:	6213      	lod	AL, [S-20]
    8382:	8ca7      	cmp	AL, #-89
    8384:	1d07      	jne	0x8394 <_HandleDfrDiag+0x2f4>
					 */
#if ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1))
					__asm__("clrb dp:_LinBusStatus.1");							/* LinBusStatus &= ~ML_LIN_BAUDRATE_DETECTED; */
#endif /* ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1)) */
#if (__MLX_PLTF_VERSION_MAJOR__ == 4)
					(void)ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);		/* MMP141215-1 */
    8386:	7000      	lod	A, #0
    8388:	82db 5b9a 	callf	0x5b9a <_ml_SetAutoBaudRateMode>
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 4) */
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK
					g_u8Mlx4ErrorState = C_MLX4_STATE_IMMEDIATE_RST;			/* Reset MLX4 too */
    838c:	6080      	lod	AL, #-128
    838e:	42d8 010e 	mov	0x10e <_g_u8Mlx4ErrorState>, AL
    8392:	541d      	ret	#30
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK */
				}																/* MMP130828-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_ADC_RAW )
    8394:	6213      	lod	AL, [S-20]
    8396:	8cac      	cmp	AL, #-84
    8398:	1d06      	jne	0x83a6 <_HandleDfrDiag+0x306>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    839a:	12eb      	call	0x8972 <_GetRawTemperature>
    839c:	520d      	mov	[S-14], A
    839e:	1282      	call	0x88a4 <_GetRawChipSupply>
    83a0:	7ae2      	lod	Y, A
	__asm__ __volatile__
    83a2:	720d      	lod	A, [S-14]
    83a4:	06fd      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					 *	|     |     |      |   (LSB)   |   (MSB)   |  (LSB)  |  (MSB)  |          |
					 *	+-----+-----+------+-----------+-----------+---------+---------+----------+
					 */
					StoreD1to4( GetRawTemperature(), GetRawChipSupply());
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_AMBJENV )
    83a6:	6213      	lod	AL, [S-20]
    83a8:	8cae      	cmp	AL, #-82
    83aa:	1d03      	jne	0x83b2 <_HandleDfrDiag+0x312>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    83ac:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    83ae:	78ff      	lod	Y, #-1
    83b0:	01a4      	jmp	0x86fa <_HandleDfrDiag+0x65a>
					StoreD2to5( (uint16) g_i16MotorVoltage, (uint16) g_i16PhaseVoltage);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					StoreD2to5( (uint16) g_i16MotorVoltage, 0xFFFF);
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX16_CLK )		/* MMP140527-1 - Begin */
    83b2:	6213      	lod	AL, [S-20]
    83b4:	8cc0      	cmp	AL, #-64
    83b6:	1d30      	jne	0x8418 <_HandleDfrDiag+0x378>
    83b8:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    83bc:	5ce2      	ssex	A
    83be:	a2da 0800 	add	A, #2048
    83c2:	5201      	mov	[S-2], A
    83c4:	7ada 03e8 	lod	Y, #1000
    83c8:	7eda 0800 	lod	X, #2048
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    83cc:	4821      	mulu	YA, A, Y
    83ce:	4c63      	divu	YA, X
    83d0:	4c63      	divu	YA, X
    83d2:	520b      	mov	[S-12], A
					 *	| NAD | 0x06| 0xDB |MLX16Clock|MLX16Clock| Reserved | Reserved | Reserved |
					 *	|     |     |      |[kHz](LSB)|[kHz](MSB)|   0xFF   |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16RC_Clock = muldivU16_U16byU16byU16( (2048 + EE_OCLOCK), 1000, 2048);
					int16 i16ADC_Temp = (int16) (GetRawTemperature() - EE_OTEMP);
    83d4:	12ce      	call	0x8972 <_GetRawTemperature>
    83d6:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    83da:	aae6      	sub	A, Y
    83dc:	7ae2      	lod	Y, A
					int16 i16Coef;
					if ( i16ADC_Temp <= 0 )
    83de:	ac00      	cmp	A, #0
    83e0:	1f05      	jsg	0x83ec <_HandleDfrDiag+0x34c>
					{
						/* ((dTemp * Gp) * 1000)/131072 --> ((dTemp * Gp) * 125)/16384 */
						i16Coef = EE_GPCLOCK;
    83e2:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    83e6:	62e4      	lod	AL, AH
    83e8:	5ce2      	ssex	A
    83ea:	0003      	jmp	0x83f2 <_HandleDfrDiag+0x352>
					}
					else
					{
						/* ((dTemp * Gn) * 1000)/131072 --> ((dTemp * Gn) * 125)/16384 */
						i16Coef = EE_GNCLOCK;
    83ec:	72d8 11c6 	lod	A, 0x11c6 <__ep__+0x1c6>
    83f0:	5ce2      	ssex	A
					}
					i16Coef = (125 * i16Coef);
    83f2:	4872 007d 	muls	A, A, #125
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    83f6:	7eda 4000 	lod	X, #16384
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    83fa:	4831      	muls	YA, A, Y
    83fc:	4c73      	divs	YA, X
    83fe:	4c73      	divs	YA, X
    8400:	4c7b      	dadjs	YA, X
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    8402:	7a0b      	lod	Y, [S-12]
    8404:	e2e2      	add	Y, A
    8406:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    840a:	6000      	lod	AL, #0
    840c:	72e4      	swap	A
    840e:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    8410:	4801      	mulu	D, A, Y
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8412:	4881      	lsr	D, #2
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
	__asm__ __volatile__
    8414:	4c88      	mov	A, DL
    8416:	0013      	jmp	0x843e <_HandleDfrDiag+0x39e>
					}
					i16Coef = (125 * i16Coef);
					u16RC_Clock += muldivI16_I16byI16byI16( i16ADC_Temp, i16Coef, 16384);
					StoreD1to2( (uint16) (mulU32_U16byU16( u16RC_Clock, ((PLL_CTRL >> 8) + 1)) >> 2));
				}																/* MMP140527-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPID )
    8418:	6213      	lod	AL, [S-20]
    841a:	8cc1      	cmp	AL, #-63
    841c:	1d08      	jne	0x842e <_HandleDfrDiag+0x38e>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x02);
    841e:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    8420:	b402      	and	A, #2
					g_DiagResponse.byD1 = (uint8) u16Index;
    8422:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLX_CHIPID) + u16Index;			/* NVRAM 16-bit pointer */
    8424:	4422      	asl	A
    8426:	7ae2      	lod	Y, A
    8428:	e2da 1188 	add	Y, #4488
    842c:	0164      	jmp	0x86f6 <_HandleDfrDiag+0x656>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_HWSWID )
    842e:	6213      	lod	AL, [S-20]
    8430:	8cc2      	cmp	AL, #-62
    8432:	1d08      	jne	0x8444 <_HandleDfrDiag+0x3a4>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | HW/SW ID | HW/SW ID | CPU-Clock| Reserved | Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |          |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
    8434:	6070      	lod	AL, #112
    8436:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    8438:	7ada 1182 	lod	Y, #4482
    843c:	72f0      	lod	A, [Y]
	__asm__ __volatile__
    843e:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
    8440:	4948      	mov	dp:0x48 <_g_DiagResponse+0x4>, AH
    8442:	06b2      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
					StoreD1to2( *((uint16 *) C_ADDR_MLX_HWSWID));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT_OPTIONS )	/* MMP140904-1 - Begin */
    8444:	6213      	lod	AL, [S-20]
    8446:	8cc6      	cmp	AL, #-58
    8448:	1d0a      	jne	0x845e <_HandleDfrDiag+0x3be>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | SUPPORT  | SUPPORT  |  SUPPORT |  SUPPORT | Reserved |
					 *	|     |     |      |   (LSB)  |          |          |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD1 = (uint8) (C_DIAG_RES
    844a:	6084      	lod	AL, #-124
    844c:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
#endif /* _SUPPORT_MLX16_HALT */
#if _SUPPORT_CHIP_TEMP_PROFILE
													& ~(1U << 7)				/* bit 7: Chip temperature profile check (dT/dt) support */
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */
																);
					g_DiagResponse.byD2 = (uint8) (C_DIAG_RES
    844e:	60f9      	lod	AL, #-7
    8450:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
#endif /* _SUPPORT_LINNETWORK_LOADER */
#if _SUPPORT_BUSTIMEOUT_SLEEP
													& ~(1U << 3)				/* bit 3: Bus-time-out to sleep support */
#endif /* _SUPPORT_BUSTIMEOUT_SLEEP */
																);
					g_DiagResponse.byD3 = (uint8) (C_DIAG_RES
    8452:	60cd      	lod	AL, #-51
    8454:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
#endif /* _SUPPORT_PHASE_SHORT_DET */
#if _SUPPORT_STALLDET_O
													& ~(1U << 7)				/* bit 7: Current-oscillation stall-detection support */
#endif /* _SUPPORT_STALLDET_O */
																);
					g_DiagResponse.byD4 = (uint8) (C_DIAG_RES
    8456:	60f6      	lod	AL, #-10
    8458:	414a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AL
#endif /* _SUPPORT_DIAG_OC */
#if _SUPPORT_DOUBLE_USTEP
													& ~(1U << 3)				/* bit 3: Double uStep support */
#endif /* _SUPPORT_DOUBLE_USTEP */
																);
					g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    845a:	60ff      	lod	AL, #-1
    845c:	0101      	jmp	0x8660 <_HandleDfrDiag+0x5c0>
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
				}																/* MMP140904-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX4_VERSION )	/* MMP140523-1 - Begin */
    845e:	6213      	lod	AL, [S-20]
    8460:	8cc7      	cmp	AL, #-57
    8462:	1d07      	jne	0x8472 <_HandleDfrDiag+0x3d2>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8464:	7ada 4018 	lod	Y, #16408
    8468:	72f0      	lod	A, [Y]
    846a:	7ada 401a 	lod	Y, #16410
    846e:	7af0      	lod	Y, [Y]
    8470:	0697      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( *((uint16 *) 0x4018), *((uint16 *) 0x401A));
				}																/* MMP140523-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_PLTF_VERSION )	/* MMP140519-1 - Begin */
    8472:	6213      	lod	AL, [S-20]
    8474:	8cc8      	cmp	AL, #-56
    8476:	1d04      	jne	0x8480 <_HandleDfrDiag+0x3e0>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8478:	72da 0104 	lod	A, #260
    847c:	7800      	lod	Y, #0
    847e:	0690      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( (__MLX_PLTF_VERSION_MAJOR__ | (__MLX_PLTF_VERSION_MINOR__ << 8)),
								(__MLX_PLTF_VERSION_REVISION__ | (__MLX_PLTF_VERSION_CUSTOMER_BUILD__ << 8)));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APP_VERSION )
    8480:	6213      	lod	AL, [S-20]
    8482:	8cc9      	cmp	AL, #-55
    8484:	1d15      	jne	0x84b0 <_HandleDfrDiag+0x410>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Appl ver | Appl ver | Appl ver | Appl ver | Appl ver |
					 *	|     |     |      |  (Major) |  (Minor) | (Rev LSB)| (Rev MSB)|   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					if ( pDiag->byD3 == 0 )									/* MMP140618-2 */
    8486:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    8488:	1d04      	jne	0x8492 <_HandleDfrDiag+0x3f2>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    848a:	7001      	lod	A, #1
    848c:	7ada e008 	lod	Y, #57352
    8490:	0687      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					 */
					if ( pDiag->byD3 == 0 )									/* MMP140618-2 */
					{
						StoreD1to4( (__APP_VERSION_MAJOR__ | (__APP_VERSION_MINOR__ << 8)), __APP_VERSION_REVISION__);
					}
					else if ( pDiag->byD3 == 1 )								/* MMP140618-2 - Begin */
    8492:	8c01      	cmp	AL, #1
    8494:	1d05      	jne	0x84a0 <_HandleDfrDiag+0x400>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8496:	72d8 bf50 	lod	A, 0xbf50 <_product_id>
    849a:	7ad8 bf52 	lod	Y, 0xbf52 <_product_id+0x2>
    849e:	0680      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					}
					else if ( pDiag->byD3 == 1 )								/* MMP140618-2 - Begin */
					{
						StoreD1to4( *((uint16 *) &product_id[0]), *((uint16 *) &product_id[2]));
					}
					else if ( pDiag->byD3 == 2 )
    84a0:	8c02      	cmp	AL, #2
    84a2:	1901      	je	0x84a6 <_HandleDfrDiag+0x406>
    84a4:	014e      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    84a6:	72d8 bf54 	lod	A, 0xbf54 <_product_id+0x4>
    84aa:	7ad8 bf56 	lod	Y, 0xbf56 <_product_id+0x6>
    84ae:	0678      	jmp	0x81a0 <_HandleDfrDiag+0x100>
					else if ( pDiag->byD3 == 2 )
					{
						StoreD1to4( *((uint16 *) &product_id[4]), *((uint16 *) &product_id[6]));
					}
				}																/* MMP140519-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPAGE )
    84b0:	6213      	lod	AL, [S-20]
    84b2:	8cca      	cmp	AL, #-54
    84b4:	1d08      	jne	0x84c6 <_HandleDfrDiag+0x426>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x3E);
    84b6:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    84b8:	b43e      	and	A, #62
					g_DiagResponse.byD1 = (uint8) u16Index;
    84ba:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLXF_PAGE) + u16Index;			/* NVRAM 16-bit pointer */
    84bc:	4422      	asl	A
    84be:	7ae2      	lod	Y, A
    84c0:	e2da 1180 	add	Y, #4480
    84c4:	0118      	jmp	0x86f6 <_HandleDfrDiag+0x656>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPID )
    84c6:	6213      	lod	AL, [S-20]
    84c8:	8ccb      	cmp	AL, #-53
    84ca:	1d04      	jne	0x84d4 <_HandleDfrDiag+0x434>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    84cc:	72d8 0320 	lod	A, 0x320 <_g_u16PidCtrlRatio>
    84d0:	79ca      	lod	Y, dp:0xca <_g_u16PID_I>
    84d2:	0113      	jmp	0x86fa <_HandleDfrDiag+0x65a>
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD2to5( g_u16PidCtrlRatio, g_u16PID_I);
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_NVRAM_ERRORCODES )
    84d4:	6213      	lod	AL, [S-20]
    84d6:	8ccc      	cmp	AL, #-52
    84d8:	1d13      	jne	0x8500 <_HandleDfrDiag+0x460>
					 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   Index  | ErrorCode| ErrorCode| ErrorCode| ErrorCode|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x1C);
    84da:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    84dc:	b41c      	and	A, #28
					if ( u16Index < (2 * (C_MAX_ERRORS_PER_PAGE - 1)) )
    84de:	ac15      	cmp	A, #21
    84e0:	1a01      	jule	0x84e4 <_HandleDfrDiag+0x444>
    84e2:	012f      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
					{
						uint16 *pu16ErrorCode;
						g_DiagResponse.byD1 = (uint8) (u16Index & 0xFF);
    84e4:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
						u16Index = u16Index >> 1;
    84e6:	4432      	lsr	A
						if ( u16Index < (C_MAX_ERRORS_PER_PAGE/2) )
    84e8:	ac05      	cmp	A, #5
    84ea:	1e05      	jug	0x84f6 <_HandleDfrDiag+0x456>
						{
							pu16ErrorCode = (uint16 *) &(((PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER)))->ErrorLog[u16Index]);
    84ec:	4422      	asl	A
    84ee:	7ae2      	lod	Y, A
    84f0:	e2da 1074 	add	Y, #4212
    84f4:	0100      	jmp	0x86f6 <_HandleDfrDiag+0x656>
						}
						else
						{
							u16Index -= (C_MAX_ERRORS_PER_PAGE/2);
							pu16ErrorCode = (uint16 *) &(((PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER)))->ErrorLog[u16Index]);
    84f6:	4422      	asl	A
    84f8:	7ae2      	lod	Y, A
    84fa:	e2da 1168 	add	Y, #4456
    84fe:	00fb      	jmp	0x86f6 <_HandleDfrDiag+0x656>
						}
						StoreD2to5( *pu16ErrorCode, *(pu16ErrorCode+1)); /*lint !e661 */
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CLR_NVRAM_ERRORCODES )
    8500:	6213      	lod	AL, [S-20]
    8502:	8ccd      	cmp	AL, #-51
    8504:	1d03      	jne	0x850c <_HandleDfrDiag+0x46c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| Debug| Supplier | Supplier | Reserved | Reserved |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |   0xCD   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					NVRAM_ClearErrorLog();
    8506:	82db 9e80 	callf	0x9e80 <_NVRAM_ClearErrorLog>
    850a:	541d      	ret	#30
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPENV )
    850c:	6213      	lod	AL, [S-20]
    850e:	8cce      	cmp	AL, #-50
    8510:	1d08      	jne	0x8522 <_HandleDfrDiag+0x482>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Chip-Temp|  Current |  Current |  Voltage |  Voltage |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
    8512:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    8514:	a03c      	add	A, #60
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
    8516:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8518:	72d8 0112 	lod	A, 0x112 <_g_i16Current>
    851c:	7ad8 0116 	lod	Y, 0x116 <_g_i16SupplyVoltage>
    8520:	00ec      	jmp	0x86fa <_HandleDfrDiag+0x65a>
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
					StoreD2to5( (uint16) g_i16Current, (uint16) g_i16SupplyVoltage); /* Motor driver current [mA] & Supply voltage [10mV] */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FUNC )
    8522:	6213      	lod	AL, [S-20]
    8524:	8ccf      	cmp	AL, #-49
    8526:	1d14      	jne	0x8550 <_HandleDfrDiag+0x4b0>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | Function | Function |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xCF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint16 u16FunctionID = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8528:	6942      	lod	AH, dp:0x42 <__data_dp_end+0x6>
    852a:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>

					if ( u16FunctionID == C_DBG_DBGFUNC_RESET )
    852c:	aeda 4a74 	cmp	A, #19060
    8530:	1901      	je	0x8534 <_HandleDfrDiag+0x494>
    8532:	0107      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
					{
						/* Function ID = Chip reset */
						(void) mlu_ApplicationStop();
    8534:	82db 7b06 	callf	0x7b06 <_mlu_ApplicationStop>
						MLX4_RESET();											/* Reset the Mlx4   */
    8538:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    853c:	94fe      	and	AL, #-2
    853e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
						bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    8542:	7ada 3072 	lod	Y, #12402
    8546:	5ad8 0338 	mov	0x338 <_bistResetInfo>, Y
						MLX16_RESET();											/* Reset the Mlx16  */
    854a:	82db 5920 	callf	0x5920 <_MLX16_RESET>
    854e:	541d      	ret	#30
					{
						MLX16_RESET();											/* Reset the Mlx16  */
					}
#endif /* _SUPPORT_LINCMD_WD_RST */
				}
				else if ( (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_SET_ANAOUTA) && (pDiag->byD5 <= (uint8) C_DBG_SUBFUNC_SET_ANAOUTH) )
    8550:	6213      	lod	AL, [S-20]
    8552:	8030      	add	AL, #48
    8554:	8c07      	cmp	AL, #7
    8556:	1e15      	jug	0x8582 <_HandleDfrDiag+0x4e2>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| Debug| Supplier | Supplier |   Value  |   Value  |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |   (LSB)  |   (MSB)  | 0xD0-0xD7|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 *pu16IoReg = (uint16*) au16AnaOutRegs[pDiag->byD5 & 0x07];
    8558:	6213      	lod	AL, [S-20]
    855a:	b407      	and	A, #7
    855c:	4422      	asl	A
    855e:	7ae2      	lod	Y, A
    8560:	e2da a408 	add	Y, #41992
    8564:	7ef0      	lod	X, [Y]
					CONTROL |= (OUTA_WE | OUTB_WE | OUTC_WE);					/* Grant access to ANA_OUTx registers */
    8566:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    856a:	8438      	or	AL, #56
    856c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
					*pu16IoReg = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8570:	6942      	lod	AH, dp:0x42 <__data_dp_end+0x6>
    8572:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    8574:	52f8      	mov	[X], A
					CONTROL &= ~(OUTA_WE | OUTB_WE | OUTC_WE);
    8576:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    857a:	94c7      	and	AL, #-57
    857c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    8580:	541d      	ret	#30
						uint16 *pu16MotorCurrRaw = (uint16*) &l_au8MotorCurrRaw[u16Index];
						StoreD1to4( pu16MotorCurrRaw[0], pu16MotorCurrRaw[1]);
					}
				}
#endif /* _DEBUG_MOTOR_CURRENT_FLT */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FILLNVRAM )		/* MMP140407-1 - Begin */
    8582:	6213      	lod	AL, [S-20]
    8584:	8cf8      	cmp	AL, #-8
    8586:	1901      	je	0x858a <_HandleDfrDiag+0x4ea>
    8588:	0035      	jmp	0x85f4 <_HandleDfrDiag+0x554>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | NVRAM ID |  Pattern |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |   0xF8   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint8 u8NvramID = pDiag->byD3;
    858a:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    858c:	5cf2      	usex	A
    858e:	5209      	mov	[S-10], A
					uint16 u16Pattern = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD4);
    8590:	6142      	lod	AL, dp:0x42 <__data_dp_end+0x6>
    8592:	5cf2      	usex	A
    8594:	7ae2      	lod	Y, A
    8596:	6c00      	lod	YH, #0
    8598:	7ae8      	swap	Y
    859a:	a6e6      	or	A, Y
    859c:	5207      	mov	[S-8], A
					if ( u8NvramID & 0x01 )
    859e:	7209      	lod	A, [S-10]
    85a0:	b401      	and	A, #1
    85a2:	1909      	je	0x85b6 <_HandleDfrDiag+0x516>
					{
						/* Fill NVRAM #1, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE1_ADDRESS);
    85a4:	7ada 1000 	lod	Y, #4096
    85a8:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    85aa:	7207      	lod	A, [S-8]
    85ac:	52d6      	mov	[Y++], A
    85ae:	1bfd      	djnz	X, 0x85aa <_HandleDfrDiag+0x50a>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE1);
    85b0:	7000      	lod	A, #0
    85b2:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x02 )
    85b6:	7209      	lod	A, [S-10]
    85b8:	b402      	and	A, #2
    85ba:	1909      	je	0x85ce <_HandleDfrDiag+0x52e>
					{
						/* Fill NVRAM #1, 2 (Don't overwrite the NVRAM1 trim value) */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE2_ADDRESS);
    85bc:	7ada 1080 	lod	Y, #4224
    85c0:	7c3e      	lod	X, #62
						do
						{
							*pu16NvramData++ = u16Pattern;
    85c2:	7207      	lod	A, [S-8]
    85c4:	52d6      	mov	[Y++], A
    85c6:	1bfd      	djnz	X, 0x85c2 <_HandleDfrDiag+0x522>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE2_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE2);
    85c8:	7001      	lod	A, #1
    85ca:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x04 )
    85ce:	7209      	lod	A, [S-10]
    85d0:	b404      	and	A, #4
    85d2:	1909      	je	0x85e6 <_HandleDfrDiag+0x546>
					{
						/* Fill NVRAM #2, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM2_PAGE1_ADDRESS);
    85d4:	7ada 1100 	lod	Y, #4352
    85d8:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    85da:	7207      	lod	A, [S-8]
    85dc:	52d6      	mov	[Y++], A
    85de:	1bfd      	djnz	X, 0x85da <_HandleDfrDiag+0x53a>
						} while (pu16NvramData < (uint16 *) END_NVRAM2_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM2_PAGE1);
    85e0:	7002      	lod	A, #2
    85e2:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x80 )
    85e6:	6209      	lod	AL, [S-10]
    85e8:	8c00      	cmp	AL, #0
    85ea:	1a81      	jsl	0x85ee <_HandleDfrDiag+0x54e>
    85ec:	00aa      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
					{
						NVRAM_LoadUserPage();
    85ee:	82db 9b46 	callf	0x9b46 <_NVRAM_LoadUserPage>
    85f2:	541d      	ret	#30
						pu16NvramData++;
					} while ( (uint16) pu16NvramData < (C_ADDR_FATALPAGE + 0x7C));
					NVRAM_StorePatch();
				}
#endif /* (_DEBUG_FATAL != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_GET_IO_REG )
    85f4:	6213      	lod	AL, [S-20]
    85f6:	8cfd      	cmp	AL, #-3
    85f8:	1901      	je	0x85fc <_HandleDfrDiag+0x55c>
    85fa:	00a3      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |  I/O-reg |  I/O-reg | I/O-value| I/O-value| Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |  (0xFF)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16IoAddress = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    85fc:	6d42      	lod	YH, dp:0x42 <__data_dp_end+0x6>
    85fe:	6400      	lod	YL, #0
    8600:	7ee6      	lod	X, Y
    8602:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x5>
    8604:	5cf2      	usex	A
    8606:	26e2      	or	X, A
					if ( ((u16IoAddress >= 0x2000) && (u16IoAddress <= 0x2056)) ||	/* System I/O */
    8608:	72ee      	lod	A, X
    860a:	a2da e000 	add	A, #57344
    860e:	ac56      	cmp	A, #86
    8610:	1a0a      	jule	0x8626 <_HandleDfrDiag+0x586>
    8612:	2eda 07fe 	cmp	X, #2046
    8616:	1a07      	jule	0x8626 <_HandleDfrDiag+0x586>
    8618:	72ee      	lod	A, X
    861a:	a2da d800 	add	A, #55296
    861e:	aeda 00da 	cmp	A, #218
    8622:	1a01      	jule	0x8626 <_HandleDfrDiag+0x586>
    8624:	008e      	jmp	0x8742 <_HandleDfrDiag+0x6a2>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8626:	7af8      	lod	Y, [X]
	__asm__ __volatile__
    8628:	72ee      	lod	A, X
    862a:	05ba      	jmp	0x81a0 <_HandleDfrDiag+0x100>
				}
#endif /* (_DEBUG_FATAL != FALSE) */
			}
			else
			{
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    862c:	621b      	lod	AL, [S-28]
    862e:	5cf2      	usex	A
    8630:	54ca 0012 	pushw	#18
    8634:	54ca 00db 	pushw	#219
    8638:	14fe      	call	0x8036 <_SetupDiagResponse>
    863a:	0585      	jmp	0x8146 <_HandleDfrDiag+0xa6>
			}
		}
#endif /* _SUPPORT_MLX_DEBUG_MODE */
		else if ( pDiag->bySID == (uint8) C_SID_MLX_ERROR_CODES )
    863c:	6217      	lod	AL, [S-24]
    863e:	8cec      	cmp	AL, #-20
    8640:	1d11      	jne	0x8664 <_HandleDfrDiag+0x5c4>
			 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xEC | Error[0] | Error[1] | Error[2] | Error[3] | Error[4] |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    8642:	661b      	lod	YL, [S-28]
    8644:	4544      	mov	dp:0x44 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = 0x06;
    8646:	6006      	lod	AL, #6
    8648:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_SID_MLX_ERROR_CODES;
    864a:	6217      	lod	AL, [S-24]
    864c:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = GetLastError();													/* Oldest Error-code */
    864e:	133a      	call	0x8cc4 <_GetLastError>
    8650:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
			g_DiagResponse.byD2 = GetLastError();
    8652:	1338      	call	0x8cc4 <_GetLastError>
    8654:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
			g_DiagResponse.byD3 = GetLastError();
    8656:	1336      	call	0x8cc4 <_GetLastError>
    8658:	4149      	mov	dp:0x49 <_g_DiagResponse+0x5>, AL
			g_DiagResponse.byD4 = GetLastError();
    865a:	1334      	call	0x8cc4 <_GetLastError>
    865c:	414a      	mov	dp:0x4a <_g_DiagResponse+0x6>, AL
			g_DiagResponse.byD5 = GetLastError();
    865e:	1332      	call	0x8cc4 <_GetLastError>
    8660:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
    8662:	05a2      	jmp	0x81a8 <_HandleDfrDiag+0x108>

			g_u8BufferOutID = (uint8) QR_RFR_DIAG;													/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( (pDiag->bySID == (uint8) C_SID_MLX_EE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0) )	/* MMP150603-2 */
    8664:	6217      	lod	AL, [S-24]
    8666:	8ced      	cmp	AL, #-19
    8668:	1d26      	jne	0x86b6 <_HandleDfrDiag+0x616>
    866a:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    866e:	b401      	and	A, #1
    8670:	1d22      	jne	0x86b6 <_HandleDfrDiag+0x616>
			/* EEPROM/NVRAM Patch support
			 * D1.bit 7 = 0 : Read Patch area
			 *			  1 : Write Patch area
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3D.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3F);
    8672:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
    8674:	4201      	mov	[S-2], AL
    8676:	66e0      	lod	YL, AL
    8678:	f43f      	and	Y, #63
    867a:	72e6      	lod	A, Y
    867c:	4422      	asl	A
    867e:	5205      	mov	[S-6], A
			if ( pDiag->byD1 & 0x80 )
    8680:	6201      	lod	AL, [S-2]
    8682:	8c00      	cmp	AL, #0
    8684:	1e8d      	jsge	0x86a0 <_HandleDfrDiag+0x600>
				 *	| NAD | 0x06| 0xED |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
			     * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    8686:	7e05      	lod	X, [S-6]
    8688:	22da 1080 	add	X, #4224
				*pu16NvramData = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    868c:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x5>
    868e:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x4>
    8690:	52f8      	mov	[X], A
				pu16NvramData++;
    8692:	7e05      	lod	X, [S-6]
    8694:	22da 1082 	add	X, #4226
				*pu16NvramData = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8698:	6943      	lod	AH, dp:0x43 <__data_dp_end+0x7>
    869a:	6142      	lod	AL, dp:0x42 <__data_dp_end+0x6>
    869c:	52f8      	mov	[X], A
    869e:	541d      	ret	#30
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xED |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    86a0:	621b      	lod	AL, [S-28]
    86a2:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06;
    86a4:	6006      	lod	AL, #6
    86a6:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_PATCH;
    86a8:	6217      	lod	AL, [S-24]
    86aa:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    86ac:	4547      	mov	dp:0x47 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    86ae:	7a05      	lod	Y, [S-6]
    86b0:	e2da 1080 	add	Y, #4224
    86b4:	0020      	jmp	0x86f6 <_HandleDfrDiag+0x656>
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_USERPG1 )
    86b6:	6217      	lod	AL, [S-24]
    86b8:	8cee      	cmp	AL, #-18
    86ba:	1d24      	jne	0x8704 <_HandleDfrDiag+0x664>
			/* EEPROM/NVRAM User-page #1 support
			 * D1.bit 7 = 0 : Read User-page #1
			 *			  1 : Write User-page #1
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3F.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3F);
    86bc:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
    86be:	4201      	mov	[S-2], AL
    86c0:	66e0      	lod	YL, AL
    86c2:	f43f      	and	Y, #63
    86c4:	72e6      	lod	A, Y
    86c6:	4422      	asl	A
    86c8:	7ee2      	lod	X, A
			if ( pDiag->byD1 & 0x80 )
    86ca:	6201      	lod	AL, [S-2]
    86cc:	8c00      	cmp	AL, #0
    86ce:	1e89      	jsge	0x86e2 <_HandleDfrDiag+0x642>
				 *	| NAD | 0x06| 0xEE |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
			     * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    86d0:	22da 005a 	add	X, #90
				pu16NvramData[0] = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    86d4:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x5>
    86d6:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x4>
    86d8:	52f8      	mov	[X], A
				pu16NvramData[1] = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    86da:	6943      	lod	AH, dp:0x43 <__data_dp_end+0x7>
    86dc:	6142      	lod	AL, dp:0x42 <__data_dp_end+0x6>
    86de:	52fa      	mov	[X+2], A
    86e0:	541d      	ret	#30
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xEE |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    86e2:	621b      	lod	AL, [S-28]
    86e4:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06;
    86e6:	6006      	lod	AL, #6
    86e8:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_USERPG1;
    86ea:	6217      	lod	AL, [S-24]
    86ec:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    86ee:	4547      	mov	dp:0x47 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    86f0:	7aee      	lod	Y, X
    86f2:	e2da 005a 	add	Y, #90
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    86f6:	72f0      	lod	A, [Y]
    86f8:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    86fa:	4148      	mov	dp:0x48 <_g_DiagResponse+0x4>, AL
    86fc:	4949      	mov	dp:0x49 <_g_DiagResponse+0x5>, AH
    86fe:	454a      	mov	dp:0x4a <_g_DiagResponse+0x6>, YL
    8700:	4d4b      	mov	dp:0x4b <_g_DiagResponse+0x7>, YH
    8702:	0552      	jmp	0x81a8 <_HandleDfrDiag+0x108>
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_STORE )
    8704:	6217      	lod	AL, [S-24]
    8706:	8cef      	cmp	AL, #-17
    8708:	1d1c      	jne	0x8742 <_HandleDfrDiag+0x6a2>
		{
			if ( pDiag->byD1 == (uint8) C_EE_STORE_USERPG1 )
    870a:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x3>
    870c:	8cee      	cmp	AL, #-18
    870e:	1d11      	jne	0x8732 <_HandleDfrDiag+0x692>
				 *	| NAD | 0x06| 0xEF |   0xEE   | Pages &  |          |          |          |
				 *	|     |     |      |          | ResetFlg |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				(void) NVRAM_Store( pDiag->byD2);
    8710:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x4>
    8712:	5cf2      	usex	A
    8714:	82db 9a3c 	callf	0x9a3c <_NVRAM_Store>
				if ( (pDiag->byD2 != 0xFF) && ((pDiag->byD2 & C_NVRAM_USER_PAGE_RESET) != 0) )
    8718:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x4>
    871a:	8cff      	cmp	AL, #-1
    871c:	1912      	je	0x8742 <_HandleDfrDiag+0x6a2>
    871e:	b420      	and	A, #32
    8720:	1910      	je	0x8742 <_HandleDfrDiag+0x6a2>
				{
					(void) mlu_ApplicationStop();
    8722:	82db 7b06 	callf	0x7b06 <_mlu_ApplicationStop>
					MLX4_RESET();												/* Reset the Mlx4   */
    8726:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    872a:	94fe      	and	AL, #-2
    872c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    8730:	070c      	jmp	0x854a <_HandleDfrDiag+0x4aa>
					MLX16_RESET();												/* Reset the Mlx16  */
				}
			}
			else if ( (pDiag->byD1 == (uint8) C_EE_STORE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0) )	/* MMP150603-2 */
    8732:	8ced      	cmp	AL, #-19
    8734:	1d06      	jne	0x8742 <_HandleDfrDiag+0x6a2>
    8736:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    873a:	b401      	and	A, #1
    873c:	1d02      	jne	0x8742 <_HandleDfrDiag+0x6a2>
				 *	| NAD | 0x06| 0xEF |   0xED   |          |          |          |          |
				 *	|     |     |      |          |          |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				NVRAM_StorePatch();
    873e:	82db 9ed6 	callf	0x9ed6 <_NVRAM_StorePatch>
    8742:	541d      	ret	#30

00008744 <_RfrDiagReset>:
#if ((LINPROT & LINXX) == LIN2X)
	if ( g_u8NAD != (uint8) C_BROADCAST_NAD )
#endif /* ((LINPROT & LINXX) == LIN2X) */
#if ((LINPROT & LINXX) == LIN2J)
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	if ( pDiag->byNAD != C_BROADCAST_J2602_NAD )
    8744:	613c      	lod	AL, dp:0x3c <__data_dp_end>
    8746:	8c7f      	cmp	AL, #127
    8748:	1913      	je	0x8770 <_RfrDiagReset+0x2c>
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		/* Positive Response */
		g_DiagResponse.byNAD = g_u8NAD;
    874a:	62d8 0034 	lod	AL, 0x34 <_g_u8NAD>
    874e:	4144      	mov	dp:0x44 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    8750:	6006      	lod	AL, #6
    8752:	4145      	mov	dp:0x45 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
    8754:	60db      	lod	AL, #-37
    8756:	4146      	mov	dp:0x46 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD5 = (uint8) g_NvramUser.Variant;
    8758:	615d      	lod	AL, dp:0x5d <_g_NvramUser+0x3>
    875a:	414b      	mov	dp:0x4b <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    875c:	72da 0124 	lod	A, #292
    8760:	7ada 00b0 	lod	Y, #176
	__asm__ __volatile__
    8764:	4147      	mov	dp:0x47 <_g_DiagResponse+0x3>, AL
    8766:	4948      	mov	dp:0x48 <_g_DiagResponse+0x4>, AH
    8768:	4549      	mov	dp:0x49 <_g_DiagResponse+0x5>, YL
    876a:	4d4a      	mov	dp:0x4a <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    876c:	6007      	lod	AL, #7
    876e:	4131      	mov	dp:0x31 <_g_u8BufferOutID>, AL
    8770:	5401      	ret

00008772 <_ADC_StartSoftTrig>:
 *
 * Start ADC measurement using Software trigger.
 * ****************************************************************************	*/
void ADC_StartSoftTrig( void)													/* MMP140709-1 - Begin */
{
	PEND = CLR_ADC_IT;
    8772:	7040      	lod	A, #64
    8774:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    8778:	7001      	lod	A, #1
    877a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff )
    877c:	62d8 012c 	lod	AL, 0x12c <_l_u8AdcPowerOff>
    8780:	1904      	je	0x878a <_ADC_StartSoftTrig+0x18>
    8782:	7eda 008b 	lod	X, #139

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
	{
		NOP();
    8786:	0000      	nop
    8788:	1bfe      	djnz	X, 0x8786 <_ADC_StartSoftTrig+0x14>
	{
		NopDelay( DELAY_50us); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    878a:	6000      	lod	AL, #0
    878c:	42d8 012c 	mov	0x12c <_l_u8AdcPowerOff>, AL
    8790:	7c06      	lod	X, #6
    8792:	0000      	nop
    8794:	1bfe      	djnz	X, 0x8792 <_ADC_StartSoftTrig+0x20>
	NopDelay( ADC_SETTING); /*lint !e522 */
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    8796:	72da 0101 	lod	A, #257
    879a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;							/* Wait for ADC result */
    879c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    879e:	b401      	and	A, #1
    87a0:	1d7d      	jne	0x879c <_ADC_StartSoftTrig+0x2a>
    87a2:	5401      	ret

000087a4 <_ADC_Stop>:
 *
 * Stop ADC (with waiting for pending ADC conversions to be finished)
 * ****************************************************************************	*/
void ADC_Stop(void)
{	
	if ( ADC_CTRL & ADC_START )													/* In case ADC is active, wait to finish it */
    87a4:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    87a6:	b401      	and	A, #1
    87a8:	190f      	je	0x87c8 <_ADC_Stop+0x24>
		while ( (ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0) )
		{
			NopDelay( ADC_DELAY); /*lint !e522 */
		}
#endif
		ADC_CTRL &= ~(ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);					/* Stop looping and HW-triggers */
    87aa:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    87ac:	b6da ff79 	and	A, #65401
    87b0:	5290      	mov	io:0x10 <__dp_noinit_size>, A
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    87b2:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    87b4:	b401      	and	A, #1
    87b6:	1908      	je	0x87c8 <_ADC_Stop+0x24>
		while ( ADC_CTRL & ADC_START )											/* As long as the ADC is active ... */
		{
			ADC_CTRL |= ADC_SOFT_TRIG;											/* ... Set S/W trigger */
    87b8:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    87ba:	a6da 0100 	or	A, #256
    87be:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    87c0:	7c12      	lod	X, #18
	{
		NOP();
    87c2:	0000      	nop
    87c4:	1bfe      	djnz	X, 0x87c2 <_ADC_Stop+0x1e>
    87c6:	07f5      	jmp	0x87b2 <_ADC_Stop+0xe>
			NopDelay( DELAY_7us); /*lint !e522 */
		}
	}
	ADC_CTRL = 0;																/* Clear the ADC control register */
    87c8:	7000      	lod	A, #0
    87ca:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	BEGIN_CRITICAL_SECTION();
    87cc:	54d0      	psup	#0
	MASK &= ~EN_ADC_IT;															/* Disable ADC Interrupt */
    87ce:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    87d2:	b4bf      	and	A, #-65
    87d4:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	END_CRITICAL_SECTION();
    87d8:	72cb      	pop	M
    87da:	5401      	ret

000087dc <_ADC_Init>:
 *
 * Measure Zero-current offset
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Init( void)
{
    87dc:	5801      	inc	S, #2
	uint16 volatile u16ZCO;
	ADC_Stop();																	/* clear the ADC control register */
    87de:	17e2      	call	0x87a4 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURROFF;
    87e0:	72da a464 	lod	A, #42084
    87e4:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16ZCO;
    87e6:	72ef      	lod	A, S
    87e8:	a0fe      	add	A, #-2
    87ea:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    87ec:	17c2      	call	0x8772 <_ADC_StartSoftTrig>
	l_u16CurrentZeroOffset = /* lint -e{530} */ u16ZCO;
    87ee:	7201      	lod	A, [S-2]
    87f0:	52d8 012e 	mov	0x12e <_l_u16CurrentZeroOffset>, A
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    87f4:	72da 0101 	lod	A, #257
    87f8:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;							/* Wait for ADC result */
    87fa:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    87fc:	b401      	and	A, #1
    87fe:	1d7d      	jne	0x87fa <_ADC_Init+0x1e>
	l_u16CurrentZeroOffset = (l_u16CurrentZeroOffset + u16ZCO) >> 1;
    8800:	72d8 012e 	lod	A, 0x12e <_l_u16CurrentZeroOffset>
    8804:	7a01      	lod	Y, [S-2]
    8806:	a2e6      	add	A, Y
    8808:	4432      	lsr	A
    880a:	52d8 012e 	mov	0x12e <_l_u16CurrentZeroOffset>, A
		u16Delta = EE_OMCURR - l_u16CurrentZeroOffset;
	if ( u16Delta > 6 )															/* Need to define this value: 6 LSB's is approx. 5mA */
		l_u16CurrentZeroOffset = EE_OMCURR;										/* Take calibrated current offset, insetad of measured offset */
#endif /* SUPPORT_CALIBRATED_ZERO_CURRENT */

	PRIO = (PRIO & ~(3 << 2)) | ((5 - 3) << 2);									/* ADC IRQ Priority: 5 (3..6) (MMP150106-1) */
    880e:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8812:	b4f3      	and	A, #-13
    8814:	a408      	or	A, #8
    8816:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
    881a:	5403      	ret	#4

0000881c <_ADC_Start>:
void ADC_Start( uint16 u16Mode)
#else  /* _SUPPORT_PHASE_SHORT_DET */
void ADC_Start( void)
#endif /* _SUPPORT_PHASE_SHORT_DET */
{
	ADC_Stop();																	/* clear the ADC control register */
    881c:	17c3      	call	0x87a4 <_ADC_Stop>
#if _SUPPORT_PHASE_SHORT_DET
	ADC_SetupShortDetection( u16Mode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_SBASE = (uint16) SBASE_INIT_4PH;
    881e:	72da a448 	lod	A, #42056
    8822:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
#endif /* _SUPPORT_PHASE_SHORT_DET */
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4;
    8824:	72da 0258 	lod	A, #600
    8828:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_CTRL  = (ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);						/* Loop cycle of conversion is done */
    882a:	72da 0086 	lod	A, #134
    882e:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_CTRL |= ADC_START;														/* Start ADC */
    8830:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8832:	a401      	or	A, #1
    8834:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff )														/* MMP140618-1: Add delay */
    8836:	62d8 012c 	lod	AL, 0x12c <_l_u8AdcPowerOff>
    883a:	1904      	je	0x8844 <_ADC_Start+0x28>
    883c:	7eda 008b 	lod	X, #139
    8840:	0000      	nop
    8842:	1bfe      	djnz	X, 0x8840 <_ADC_Start+0x24>
	{
		NopDelay( DELAY_mPWM); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    8844:	6000      	lod	AL, #0
    8846:	42d8 012c 	mov	0x12c <_l_u8AdcPowerOff>, AL
    884a:	5401      	ret

0000884c <_ADC_PowerOff>:
 *
 * Power-off ADC, by disabling reference voltage
 * ****************************************************************************	*/
void ADC_PowerOff( void)
{
	ADC_Stop();																	/* Stop ADC conversion, and disable ADC-IRQ */
    884c:	17ab      	call	0x87a4 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_VREF_OFF;
    884e:	72da a468 	lod	A, #42088
    8852:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	PEND = CLR_ADC_IT;
    8854:	7040      	lod	A, #64
    8856:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    885a:	7001      	lod	A, #1
    885c:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_Stop();
    885e:	17a2      	call	0x87a4 <_ADC_Stop>
	l_u8AdcPowerOff = TRUE;
    8860:	6001      	lod	AL, #1
    8862:	42d8 012c 	mov	0x12c <_l_u8AdcPowerOff>, AL
    8866:	5401      	ret

00008868 <_ADC_IT>:
 * ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead (is approx: 9.5% at 24kHz PWM)
 * (push/pop + check for LIN-AA + Check BEMF ZC)
 * ****************************************************************************	*/
__interrupt__ void ADC_IT(void) 
{
    8868:	4407      	mov	R, #0
    886a:	72cb      	pop	M
    886c:	5401      	ret

0000886e <_GetVsupply>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    886e:	7ad8 025a 	lod	Y, 0x25a <_g_AdcMotorRunStepper4+0x2>
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8872:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8876:	5ce2      	ssex	A
    8878:	eae2      	sub	Y, A
    887a:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    887e:	6000      	lod	AL, #0
    8880:	72e4      	swap	A
    int32 result;

    __asm__ __volatile__ (
    8882:	4811      	muls	D, A, Y
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8884:	4c80      	mov	YA, D
    8886:	4c22 0020 	add	YA, #32
    888a:	0000 
    888c:	4cb2 0000 	cmp	YA, #0
    8890:	0000 
    8892:	1e84      	jsge	0x889c <_GetVsupply+0x2e>
    8894:	4c80      	mov	YA, D
    8896:	4c22 005f 	add	YA, #95
    889a:	0000 
    889c:	48b5      	asr	YA, #6
    889e:	52d8 0116 	mov	0x116 <_g_i16SupplyVoltage>, A
    88a2:	5401      	ret

000088a4 <_GetRawChipSupply>:
} /* End of GetVsupply() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawChipSupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    88a4:	72d8 025a 	lod	A, 0x25a <_g_AdcMotorRunStepper4+0x2>
	return ( u16FilteredSupplyVoltage );
} /* End of GetRawChipSupply() */
    88a8:	5401      	ret

000088aa <_GetVsupplyMotor>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupplyMotor( void)
{
	uint16 u16FilteredDriverVoltage = g_AdcMotorRunStepper4.FilteredDriverVoltage;
    88aa:	72d8 025e 	lod	A, 0x25e <_g_AdcMotorRunStepper4+0x6>
#if _SUPPORT_VSMFILTERED
	g_i16MotorVoltage = (int16) ((mulI32_I16byU16( (int16)(u16FilteredDriverVoltage - EE_OVOLTAGE), EE_GVOLTAGE) + (C_GVOLTAGE_DIV/2)) / C_GVOLTAGE_DIV);
    88ae:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    88b2:	5ce6      	ssex	Y
    88b4:	aae6      	sub	A, Y
    88b6:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    88ba:	6400      	lod	YL, #0
    88bc:	7ae8      	swap	Y
    88be:	5adf      	push	Y
    88c0:	82db 6c52 	callf	0x6c52 <_mulI32_I16byU16>
    88c4:	4cc0      	mov	D, YA
    88c6:	4c22 0020 	add	YA, #32
    88ca:	0000 
    88cc:	4cb2 0000 	cmp	YA, #0
    88d0:	0000 
    88d2:	1e84      	jsge	0x88dc <_GetVsupplyMotor+0x32>
    88d4:	4c80      	mov	YA, D
    88d6:	4c22 005f 	add	YA, #95
    88da:	0000 
    88dc:	48b5      	asr	YA, #6
    88de:	5120      	mov	dp:0x20 <_g_i16MotorVoltage>, A
    88e0:	5c01      	dec	S, #2
    88e2:	5401      	ret

000088e4 <_ResetChipTemperature>:
 *
 * Reset Chip temperature
 * ****************************************************************************	*/
void ResetChipTemperature( void)
{
	g_AdcMotorRunStepper4.IntTemperatureSensor = 0;
    88e4:	7ada 0258 	lod	Y, #600
    88e8:	7000      	lod	A, #0
    88ea:	52f0      	mov	[Y], A
    88ec:	5401      	ret

000088ee <_GetChipTemperature>:
 * GetChipTemperature()
 *
 * Get Chip temperature [C]
 * ****************************************************************************	*/
void GetChipTemperature( uint16 u16Init)										/* MMP131020-1 */
{
    88ee:	580b      	inc	S, #12
    88f0:	520b      	mov	[S-12], A
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    88f2:	7ad8 0258 	lod	Y, 0x258 <_g_AdcMotorRunStepper4>
	int16 i16ChipTemperature, i16ChipTempDelta;

#if _SUPPORT_TWO_LINE_TEMP_INTERPOLATION
	if ( u16ChipTemperatureSensor < EE_OTEMP )
    88f6:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    88fa:	eee2      	cmp	Y, A
    88fc:	1c11      	jnc	0x8920 <_GetChipTemperature+0x32>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    88fe:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8902:	aae6      	sub	A, Y
    8904:	5203      	mov	[S-4], A
    8906:	785a      	lod	Y, #90
    8908:	7ed8 11ba 	lod	X, 0x11ba <__ep__+0x1ba>
    890c:	72d8 11bc 	lod	A, 0x11bc <__ep__+0x1bc>
    8910:	2ae2      	sub	X, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8912:	7203      	lod	A, [S-4]
    8914:	4821      	mulu	YA, A, Y
    8916:	4c63      	divu	YA, X
    8918:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    891a:	7ae2      	lod	Y, A
    891c:	e023      	add	Y, #35
    891e:	0012      	jmp	0x8944 <_GetChipTemperature+0x56>
    8920:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8924:	eae2      	sub	Y, A
    8926:	5a01      	mov	[S-2], Y
    8928:	7ed8 11b8 	lod	X, 0x11b8 <__ep__+0x1b8>
    892c:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    8930:	2ae6      	sub	X, Y
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8932:	704b      	lod	A, #75
    8934:	7a01      	lod	Y, [S-2]
    8936:	4821      	mulu	YA, A, Y
    8938:	4c63      	divu	YA, X
    893a:	4c63      	divu	YA, X
    893c:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    893e:	7023      	lod	A, #35
    8940:	7ae2      	lod	Y, A
    8942:	eaee      	sub	Y, X
	}
#else  /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */
	i16ChipTemperature = (mulI32_I16byI16( (EE_OTEMP - u16ChipTemperatureSensor), EE_GTEMP) / C_GTEMP_DIV) + EE_MIDTEMP;
#endif /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */

	if ( u16Init == FALSE )														/* MMP131020-1 */
    8944:	7e0b      	lod	X, [S-12]
    8946:	1d13      	jne	0x896e <_GetChipTemperature+0x80>
	{
		i16ChipTempDelta = i16ChipTemperature - g_i16ChipTemperature;			/* Delta-temp = new-temp - previous-temp */
    8948:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    894a:	7ee6      	lod	X, Y
    894c:	2ae2      	sub	X, A
    894e:	72ee      	lod	A, X
		if ( i16ChipTempDelta < 0 )
		{
			i16ChipTempDelta = -i16ChipTempDelta;								/* Absolute temperature change */
    8950:	ac00      	cmp	A, #0
    8952:	1e81      	jsge	0x8956 <_GetChipTemperature+0x68>
    8954:	5cc2      	neg	A
		}
		if ( (uint16) i16ChipTempDelta > C_TEMPERATURE_JUMP )					/* Temperature change small, then accept new temperature */
    8956:	ac0a      	cmp	A, #10
    8958:	1a0a      	jule	0x896e <_GetChipTemperature+0x80>
		{
			if ( i16ChipTemperature > g_i16ChipTemperature )					/* To great temperature change; Check temperature change "direction" */
    895a:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    895c:	eee2      	cmp	Y, A
    895e:	1b04      	jsle	0x8968 <_GetChipTemperature+0x7a>
			{
				i16ChipTemperature = g_i16ChipTemperature + 1;					/* Increase by one degree */
    8960:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    8962:	7ae2      	lod	Y, A
    8964:	e001      	add	Y, #1
    8966:	0003      	jmp	0x896e <_GetChipTemperature+0x80>
			}
			else
			{
				i16ChipTemperature = g_i16ChipTemperature - 1;					/* Decrease by one degree */
    8968:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    896a:	7ae2      	lod	Y, A
    896c:	e0ff      	add	Y, #-1
			}
		}
	}																			/* MMP131020-1 */
	g_i16ChipTemperature = i16ChipTemperature;
    896e:	5922      	mov	dp:0x22 <_g_i16ChipTemperature>, Y
    8970:	540d      	ret	#14

00008972 <_GetRawTemperature>:
} /* End of GetChipTemperature() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawTemperature( void)
{
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    8972:	7ada 0258 	lod	Y, #600
    8976:	72f0      	lod	A, [Y]
	return ( u16ChipTemperatureSensor );
} /* End of GetRawTemperature() */
    8978:	5401      	ret

0000897a <_GetRawMotorDriverCurrent>:
 * GetRawMotorDriverCurrent()
 *
 * Get (raw) Motor Driver Current [ADC-LSB]
 * ****************************************************************************	*/
uint16 GetRawMotorDriverCurrent( void)
{
    897a:	5801      	inc	S, #2
	uint16 u16Current = 0;
    897c:	7000      	lod	A, #0
    897e:	5201      	mov	[S-2], A
#if ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL))
	g_u16CurrentMotorCoilA = g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    8980:	7ad8 0260 	lod	Y, 0x260 <_g_AdcMotorRunStepper4+0x8>
    8984:	5ad8 012a 	mov	0x12a <_g_u16CurrentMotorCoilA>, Y
	if ( g_u16CurrentMotorCoilA > l_u16CurrentZeroOffset )
    8988:	7ed8 012e 	lod	X, 0x12e <_l_u16CurrentZeroOffset>
    898c:	eeee      	cmp	Y, X
    898e:	1a02      	jule	0x8994 <_GetRawMotorDriverCurrent+0x1a>
	{
		u16Current = g_u16CurrentMotorCoilA - (int16) l_u16CurrentZeroOffset;
    8990:	eaee      	sub	Y, X
    8992:	5a01      	mov	[S-2], Y
	}
	g_u16CurrentMotorCoilB = g_AdcMotorRunStepper4.UnfilteredDriverCurrent2;
    8994:	72d8 025c 	lod	A, 0x25c <_g_AdcMotorRunStepper4+0x4>
    8998:	52d8 0128 	mov	0x128 <_g_u16CurrentMotorCoilB>, A
	if ( g_u16CurrentMotorCoilB > l_u16CurrentZeroOffset )
    899c:	aeee      	cmp	A, X
    899e:	1a03      	jule	0x89a6 <_GetRawMotorDriverCurrent+0x2c>
	{
		u16Current = u16Current + (g_u16CurrentMotorCoilB - l_u16CurrentZeroOffset);
    89a0:	aaee      	sub	A, X
    89a2:	a201      	add	A, [S-2]
    89a4:	5201      	mov	[S-2], A
	{
		u16Current = u16Current - (int16) l_u16CurrentZeroOffset;
	}
#endif /* ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)) */
	return ( u16Current );
} /* End of GetRawMotorDriverCurrent() */
    89a6:	7201      	lod	A, [S-2]
    89a8:	5403      	ret	#4

000089aa <_GetMotorDriverCurrent>:
 *
 * Get Motor Driver Current [mA]
 * ****************************************************************************	*/
int16 GetMotorDriverCurrent( void)
{
	uint16 u16Current = GetRawMotorDriverCurrent();
    89aa:	17e7      	call	0x897a <_GetRawMotorDriverCurrent>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    89ac:	7ad8 11d0 	lod	Y, 0x11d0 <__ep__+0x1d0>
    89b0:	f6da 00ff 	and	Y, #255
    89b4:	e2da 0100 	add	Y, #256
    uint32 result;

    __asm__ __volatile__ (
    89b8:	4801      	mulu	D, A, Y
    89ba:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    89bc:	4c22 0040 	add	YA, #64
    89c0:	0000 
    89c2:	48a6      	lsr	YA, #7
	u16Current = (uint16) ((mulU32_U16byU16( u16Current, EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV);	/* MMP131117-1 */
	return ( (int16) u16Current);
} /* End of GetMotorDriverCurrent() */
    89c4:	5401      	ret

000089c6 <_MeasureVsupplyAndTemperature>:
 *
 * Measure Vbat and Temperature (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureVsupplyAndTemperature( void)
{	
	ADC_Stop();
    89c6:	16ee      	call	0x87a4 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_MOTORVOLT;										/* switch ADC input source to Voltage */
    89c8:	72da a458 	lod	A, #42072
    89cc:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredDriverVoltage;
    89ce:	72da 025e 	lod	A, #606
    89d2:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    89d4:	16ce      	call	0x8772 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_SUPPLYVOLT;										/* switch ADC input source to Voltage */
    89d6:	72da a45c 	lod	A, #42076
    89da:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    89dc:	72da 025a 	lod	A, #602
    89e0:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    89e2:	16c7      	call	0x8772 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_TEMP;											/* switch ADC input source to Temperature */
    89e4:	72da a460 	lod	A, #42080
    89e8:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.IntTemperatureSensor;
    89ea:	72da 0258 	lod	A, #600
    89ee:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    89f0:	16c0      	call	0x8772 <_ADC_StartSoftTrig>
    89f2:	5401      	ret

000089f4 <_MeasureMotorCurrent>:
 *
 * Measure Motor-current (filtered) (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureMotorCurrent( void)
{
	ADC_Stop();
    89f4:	16d7      	call	0x87a4 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURRENT;											/* switch ADC input source to Motor-driver current */
    89f6:	72da a454 	lod	A, #42068
    89fa:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    89fc:	72da 0260 	lod	A, #608
    8a00:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    8a02:	16b7      	call	0x8772 <_ADC_StartSoftTrig>
    8a04:	5401      	ret

00008a06 <_MeasurePhaseVoltage>:
 * MeasurePhaseVoltage()
 *
 * Measure Phase voltage (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasurePhaseVoltage( uint16 u16AdcSbase)									/* MMP130919-1 - Begin */
{
    8a06:	5803      	inc	S, #4
    8a08:	5201      	mov	[S-2], A
	uint16 u16PhaseVoltage;
	ADC_Stop();
    8a0a:	16cc      	call	0x87a4 <_ADC_Stop>
	ADC_SBASE = (uint16) u16AdcSbase;											/* switch ADC input source to Motor-driver current */
    8a0c:	7201      	lod	A, [S-2]
    8a0e:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16PhaseVoltage;
    8a10:	72ef      	lod	A, S
    8a12:	a0fc      	add	A, #-4
    8a14:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    8a16:	16ad      	call	0x8772 <_ADC_StartSoftTrig>
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    8a18:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8a1c:	5ce2      	ssex	A
    8a1e:	7a03      	lod	Y, [S-4]
    8a20:	eae2      	sub	Y, A
    8a22:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8a26:	6000      	lod	AL, #0
    8a28:	72e4      	swap	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a2a:	4831      	muls	YA, A, Y
    8a2c:	48b5      	asr	YA, #6
    8a2e:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    8a30:	52d8 0114 	mov	0x114 <_g_i16PhaseVoltage>, A
    8a34:	5405      	ret	#6

00008a36 <_HandleDiagnosticEvent>:
 * HandleDiagnosticEvent()
 *
 * Handle Diagnostic Events
 * ****************************************************************************	*/
void HandleDiagnosticEvent( uint16 u16Event)
{
    8a36:	5803      	inc	S, #4
    8a38:	5203      	mov	[S-4], A
	if ( u16Event & (XI4_OC_DRV | XI4_OVT) )
    8a3a:	b6da 8100 	and	A, #33024
    8a3e:	1d01      	jne	0x8a42 <_HandleDiagnosticEvent+0xc>
    8a40:	0045      	jmp	0x8acc <_HandleDiagnosticEvent+0x96>
	{
		/* In case over-current or over-temperature, switch off motor */
#if _SUPPORT_DIAG_OC
		if ( u16Event & XI4_OC_DRV )
    8a42:	7203      	lod	A, [S-4]
    8a44:	b6da 0100 	and	A, #256
    8a48:	191c      	je	0x8a82 <_HandleDiagnosticEvent+0x4c>
			/* Chip over-current */
			/* The over-current may occur then chips has entered test-mode. The test-mode freezes the
			 * complete digital part of the chip, including the Motor PWM and driver. This may result
			 * in a phase H and a phase L, having a DC-current flow!!
			 */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    8a4a:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8a4c:	8c01      	cmp	AL, #1
    8a4e:	1903      	je	0x8a56 <_HandleDiagnosticEvent+0x20>
    8a50:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    8a54:	190c      	je	0x8a6e <_HandleDiagnosticEvent+0x38>
    8a56:	7eda 008b 	lod	X, #139
    8a5a:	0000      	nop
    8a5c:	1bfe      	djnz	X, 0x8a5a <_HandleDiagnosticEvent+0x24>
			{
				/* Average between two driver-current measurements */
				NopDelay( DELAY_mPWM); /*lint !e522 */							/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
				g_i16Current = GetMotorDriverCurrent();
    8a5e:	17a5      	call	0x89aa <_GetMotorDriverCurrent>
    8a60:	52d8 0112 	mov	0x112 <_g_i16Current>, A
				if ( g_i16Current > 1400 )
    8a64:	72d8 0112 	lod	A, 0x112 <_g_i16Current>
    8a68:	aeda 0578 	cmp	A, #1400
    8a6c:	1b0a      	jsle	0x8a82 <_HandleDiagnosticEvent+0x4c>
				}
			}
			else
			{
				//g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_YES;
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban, stop the motor in case of coil short
    8a6e:	6002      	lod	AL, #2
    8a70:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Over-current */
    8a72:	7002      	lod	A, #2
    8a74:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
				//g_u16TargetPosition = g_u16ActualPosition;						/* 9.5.3.3 */
				SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    8a78:	72da 00d0 	lod	A, #208
    8a7c:	10f4      	call	0x8c66 <_SetLastError>
				g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;
    8a7e:	60eb      	lod	AL, #-21
    8a80:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			}
		}
#endif /* _SUPPORT_DIAG_OC */
		if ( u16Event & XI4_OVT )
    8a82:	7203      	lod	A, [S-4]
    8a84:	ac00      	cmp	A, #0
    8a86:	1ea2      	jsge	0x8acc <_HandleDiagnosticEvent+0x96>
		{
			/* Chip over-temperature */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    8a88:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8a8a:	8c01      	cmp	AL, #1
    8a8c:	1903      	je	0x8a94 <_HandleDiagnosticEvent+0x5e>
    8a8e:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    8a92:	1906      	je	0x8aa0 <_HandleDiagnosticEvent+0x6a>
			{
				ResetChipTemperature();
    8a94:	1727      	call	0x88e4 <_ResetChipTemperature>
    8a96:	7eda 008b 	lod	X, #139
    8a9a:	0000      	nop
    8a9c:	1bfe      	djnz	X, 0x8a9a <_HandleDiagnosticEvent+0x64>
    8a9e:	0001      	jmp	0x8aa2 <_HandleDiagnosticEvent+0x6c>
				NopDelay( DELAY_mPWM); /*lint !e522 */
				GetChipTemperature( FALSE);										/* MMP131020-1 */
			}
			else
			{
				MeasureVsupplyAndTemperature();
    8aa0:	1792      	call	0x89c6 <_MeasureVsupplyAndTemperature>
				GetChipTemperature( FALSE);										/* MMP131020-1 */
    8aa2:	7000      	lod	A, #0
    8aa4:	1724      	call	0x88ee <_GetChipTemperature>
			}
			if ( (g_i16ChipTemperature > (int16) C_CHIP_OVERTEMP_LEVEL) && (g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_YES))
    8aa6:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    8aa8:	aeda 0096 	cmp	A, #150
    8aac:	1b0f      	jsle	0x8acc <_HandleDiagnosticEvent+0x96>
    8aae:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    8ab0:	8c01      	cmp	AL, #1
    8ab2:	190c      	je	0x8acc <_HandleDiagnosticEvent+0x96>
			{
				g_u8OverTemperatureCount++;
    8ab4:	62d8 010d 	lod	AL, 0x10d <_g_u8OverTemperatureCount>
    8ab8:	8001      	add	AL, #1
    8aba:	42d8 010d 	mov	0x10d <_g_u8OverTemperatureCount>, AL
				if ( g_u8OverTemperatureCount >= (uint8) C_OVERTEMP_TO_PERMDEFECT_THRSHLD )
    8abe:	8c03      	cmp	AL, #3
    8ac0:	1a05      	jule	0x8acc <_HandleDiagnosticEvent+0x96>
				{
					g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    8ac2:	6001      	lod	AL, #1
    8ac4:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
					SetLastError( (uint8) C_ERR_DIAG_OVER_TEMP);
    8ac6:	72da 00d1 	lod	A, #209
    8aca:	10cd      	call	0x8c66 <_SetLastError>
					//g_u8OverTemperatureCount = 0;
				}
			}
		}
	}
	if ( u16Event & (XI4_UV | XI4_OV) )
    8acc:	7203      	lod	A, [S-4]
    8ace:	b6da 6000 	and	A, #24576
    8ad2:	1d01      	jne	0x8ad6 <_HandleDiagnosticEvent+0xa0>
    8ad4:	0043      	jmp	0x8b5c <_HandleDiagnosticEvent+0x126>
	{
		/* Chip under- or over-voltage */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    8ad6:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8ad8:	8c01      	cmp	AL, #1
    8ada:	1903      	je	0x8ae2 <_HandleDiagnosticEvent+0xac>
    8adc:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    8ae0:	1905      	je	0x8aec <_HandleDiagnosticEvent+0xb6>
    8ae2:	7eda 008b 	lod	X, #139
    8ae6:	0000      	nop
    8ae8:	1bfe      	djnz	X, 0x8ae6 <_HandleDiagnosticEvent+0xb0>
    8aea:	0001      	jmp	0x8aee <_HandleDiagnosticEvent+0xb8>
			NopDelay( DELAY_mPWM); /*lint !e522 */								/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
			GetVsupply();
		}
		else
		{
			MeasureVsupplyAndTemperature();
    8aec:	176c      	call	0x89c6 <_MeasureVsupplyAndTemperature>
			GetVsupply();
    8aee:	16bf      	call	0x886e <_GetVsupply>
		}
		{
			uint8 e8DiagVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
			if ( g_i16SupplyVoltage < (int16)((6 + NVRAM_BROWNOUT_LEVEL) * 100) )
    8af0:	618a      	lod	AL, dp:0x8a <_g_NvramUser+0x30>
    8af2:	44b2      	lsr	A, #2
    8af4:	44b2      	lsr	A, #2
    8af6:	44b2      	lsr	A, #2
    8af8:	b403      	and	A, #3
    8afa:	4872 0064 	muls	A, A, #100
    8afe:	a2da 0258 	add	A, #600
    8b02:	7ad8 0116 	lod	Y, 0x116 <_g_i16SupplyVoltage>
    8b06:	eee2      	cmp	Y, A
    8b08:	1e85      	jsge	0x8b14 <_HandleDiagnosticEvent+0xde>
			{
				/* Chip under-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_UNDER;
    8b0a:	7001      	lod	A, #1
    8b0c:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_UNDER_VOLT);
    8b0e:	72da 00d2 	lod	A, #210
    8b12:	0009      	jmp	0x8b26 <_HandleDiagnosticEvent+0xf0>
			}
			else if ( g_i16SupplyVoltage > 2800 )
    8b14:	72d8 0116 	lod	A, 0x116 <_g_i16SupplyVoltage>
    8b18:	aeda 0af0 	cmp	A, #2800
    8b1c:	1b1f      	jsle	0x8b5c <_HandleDiagnosticEvent+0x126>
			{
				/* Chip over-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_OVER;
    8b1e:	7002      	lod	A, #2
    8b20:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_OVER_VOLT);
    8b22:	72da 00d3 	lod	A, #211
    8b26:	109f      	call	0x8c66 <_SetLastError>
			}
			if ( e8DiagVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE)
			{
				g_e8ErrorVoltage = e8DiagVoltage;								/* 9.5.3.4 */
    8b28:	6201      	lod	AL, [S-2]
    8b2a:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
				g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    8b2c:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    8b2e:	42d8 010b 	mov	0x10b <_g_e8ErrorVoltageComm>, AL
				if ( g_e8MotorRequest != C_MOTOR_REQUEST_NONE )					/* MMP150313-3 - Begin */
    8b32:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    8b34:	1904      	je	0x8b3e <_HandleDiagnosticEvent+0x108>
				{
					g_e8DegradedMotorRequest = g_e8MotorRequest;
    8b36:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    8b38:	6000      	lod	AL, #0
    8b3a:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    8b3c:	0009      	jmp	0x8b50 <_HandleDiagnosticEvent+0x11a>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )	/* MMP150313-3 - End */
    8b3e:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8b40:	8c01      	cmp	AL, #1
    8b42:	1d02      	jne	0x8b48 <_HandleDiagnosticEvent+0x112>
				{
					/* Enter degraded-mode; Stop motor and resume when voltage decreases below upper-application threshold or raise above lower-application threshold */
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    8b44:	6003      	lod	AL, #3
    8b46:	0003      	jmp	0x8b4e <_HandleDiagnosticEvent+0x118>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    8b48:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    8b4a:	1d05      	jne	0x8b56 <_HandleDiagnosticEvent+0x120>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    8b4c:	6001      	lod	AL, #1
    8b4e:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Degraded-mode */
    8b50:	7002      	lod	A, #2
    8b52:	82db 94b6 	callf	0x94b6 <_MotorDriverStop>
				}
				g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    8b56:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    8b58:	8480      	or	AL, #-128
    8b5a:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
    8b5c:	5405      	ret	#6

00008b5e <_DiagnosticsInit>:
 * Don't automatically shut-off motor-driver on over- or under-voltage, or over-temperature.
 * Diagnostic ISR priority: 3 
 * ****************************************************************************	*/
void DiagnosticsInit( void)
{
	DRVCFG = (DRVCFG | (DIS_OC | DIS_OT | DIS_OV | DIS_UV));					/* Disable over-current, over-temperature, over-voltage, under-voltage */
    8b5e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8b62:	a6da f000 	or	A, #61440
    8b66:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	ANA_OUTI &= ~SEL_UV_VS;														/* Enable UV & OV debounce circuitry */
    8b6a:	72d8 28d0 	lod	A, 0x28d0 <__io__+0xd0>
    8b6e:	b6da efff 	and	A, #61439
    8b72:	52d8 28d0 	mov	0x28d0 <__io__+0xd0>, A
	ANA_OUTG = (ANA_OUTG & 0xFCFF) | (NVRAM_BROWNOUT_LEVEL << 8);				/* Brown-out UV-level = 6V + n * 1V; */
    8b76:	7ad8 28cc 	lod	Y, 0x28cc <__io__+0xcc>
    8b7a:	f6da fcff 	and	Y, #64767
    8b7e:	618a      	lod	AL, dp:0x8a <_g_NvramUser+0x30>
    8b80:	44a2      	asl	A, #2
    8b82:	b6da 0300 	and	A, #768
    8b86:	e6e2      	or	Y, A
    8b88:	5ad8 28cc 	mov	0x28cc <__io__+0xcc>, Y
	{
		/* IO[0] is low; Set IRQ-event on rising-edge */
		IO_CFG &= ~FRB_IO5;
	}
#else  /* (_SUPPORT_HALL_SENSOR) */
	XI4_PEND = C_DIAG_MASK;
    8b8c:	72da e100 	lod	A, #57600
    8b90:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	XI4_MASK |= C_DIAG_MASK;
    8b94:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    8b98:	a6da e100 	or	A, #57600
    8b9c:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
#endif /* (_SUPPORT_HALL_SENSOR) */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */						/* EXT4_IT Priority: 3 (3..6) */
	PRIO = (PRIO & ~(3U << 14));												/* EXT4_IT Priority: 3 (3..6) */
    8ba0:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8ba4:	b6da 3fff 	and	A, #16383
    8ba8:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT4_IT;
    8bac:	72da 1000 	lod	A, #4096
    8bb0:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    8bb4:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    8bb8:	a6da 1000 	or	A, #4096
    8bbc:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* MMP141212-1: Check for OVT and OV. Perform Diagnostics handling if required */
	{
#if (_SUPPORT_DIAG_OVT == FALSE)
		uint16 u16DiagnosticEvent = (ANA_INA & XI4_OV);
#else  /* (_SUPPORT_DIAG_OVT == FALSE) */
		uint16 u16DiagnosticEvent = (ANA_INA & (XI4_OVT | XI4_OV));
    8bc0:	729c      	lod	A, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    8bc2:	b6da a000 	and	A, #40960
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */
		if ( u16DiagnosticEvent != 0 )
    8bc6:	1901      	je	0x8bca <_DiagnosticsInit+0x6c>
		{
			HandleDiagnosticEvent( u16DiagnosticEvent);
    8bc8:	1736      	call	0x8a36 <_HandleDiagnosticEvent>
    8bca:	5401      	ret

00008bcc <_EXT4_IT>:
 * EXT4_IT()
 *
 * Diagnostic & IO Interrupt Service Routine.
 * ****************************************************************************	*/
__interrupt__ void EXT4_IT(void)
{
    8bcc:	52df      	push	A
    8bce:	5edf      	push	X
    8bd0:	5adf      	push	Y
    8bd2:	4c83      	push	D
    8bd4:	5801      	inc	S, #2
	uint16 u16Pending = (XI4_PEND & XI4_MASK);									/* Copy interrupt requests which are not masked   */
    8bd6:	7ad8 203c 	lod	Y, 0x203c <__ep__+0x103c>
    8bda:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    8bde:	f6e2      	and	Y, A
    8be0:	5a01      	mov	[S-2], Y
	do
	{
		XI4_PEND = u16Pending;													/* Clear requests which are going to be processed */
    8be2:	7201      	lod	A, [S-2]
    8be4:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	} while (XI4_PEND & u16Pending);
    8be8:	72d8 203c 	lod	A, 0x203c <__ep__+0x103c>
    8bec:	b601      	and	A, [S-2]
    8bee:	1d79      	jne	0x8be2 <_EXT4_IT+0x16>

	/* Multiple diagnostics events is most likely caused by Rinnen/ESD-pulse */
	if ( ((u16Pending & XI4_UV) != 0) && ((u16Pending & (XI4_OC_DRV | XI4_OVT | XI4_OV)) != 0) )
    8bf0:	7201      	lod	A, [S-2]
    8bf2:	b6da 4000 	and	A, #16384
    8bf6:	1904      	je	0x8c00 <_EXT4_IT+0x34>
    8bf8:	7201      	lod	A, [S-2]
    8bfa:	b6da a100 	and	A, #41216
    8bfe:	1d17      	jne	0x8c2e <_EXT4_IT+0x62>
	{
		/* Under-voltage together with any other diagnostic event is strange */
	}
	else
	{
		HandleDiagnosticEvent( u16Pending);
    8c00:	7201      	lod	A, [S-2]
    8c02:	1719      	call	0x8a36 <_HandleDiagnosticEvent>

		if ( (u16Pending & XI4_IO5) != 0 )
    8c04:	7201      	lod	A, [S-2]
    8c06:	b420      	and	A, #32
    8c08:	1912      	je	0x8c2e <_EXT4_IT+0x62>
		{
			g_u8HallSwitchState = IO_IN & XI4_IO5;
    8c0a:	72d8 28ca 	lod	A, 0x28ca <__io__+0xca>
    8c0e:	9420      	and	AL, #32
    8c10:	42d8 0132 	mov	0x132 <_g_u8HallSwitchState>, AL
			if ( g_u8HallSwitchState )
    8c14:	1904      	je	0x8c1e <_EXT4_IT+0x52>
			{
				/* IO[0] is high; Set IRQ-event on falling-edge */
				IO_CFG |= FRB_IO5;
    8c16:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    8c1a:	a420      	or	A, #32
    8c1c:	0003      	jmp	0x8c24 <_EXT4_IT+0x58>
			}
			else
			{
				/* IO[0] is low; Set IRQ-event on rising-edge */
				IO_CFG &= ~FRB_IO5;
    8c1e:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    8c22:	b4df      	and	A, #-33
    8c24:	52d8 28be 	mov	0x28be <__io__+0xbe>, A
			}
			//g_u16HallMicroStepIdx = g_u16MicroStepIdx;
			g_u16HallMicroStepIdx = g_u16ActuatorActPos;//Ban
    8c28:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    8c2a:	52d8 0130 	mov	0x130 <_g_u16HallMicroStepIdx>, A
    8c2e:	5c01      	dec	S, #2
    8c30:	4cc3      	pop	D
    8c32:	7acf      	pop	Y
    8c34:	7ecf      	pop	X
    8c36:	72cf      	pop	A
    8c38:	4407      	mov	R, #0
    8c3a:	72cb      	pop	M
    8c3c:	5401      	ret

00008c3e <_ErrorLogInit>:
 *
 *	Comments:	Clear Error-FiFo-buffer, in case watchdog reset occurred, 
 *				otherwise leave untouched.
 * ****************************************************************************	*/
void ErrorLogInit( void)
{
    8c3e:	5803      	inc	S, #4
	if ( (AWD_CTRL & AWD_RST) != 0 )
    8c40:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    8c42:	ac00      	cmp	A, #0
    8c44:	1e8f      	jsge	0x8c64 <_ErrorLogInit+0x26>
	{
		uint16 i;
		for ( i = 0; i < C_ERR_LOG_SZ; i++ )
    8c46:	7000      	lod	A, #0
    8c48:	780a      	lod	Y, #10
    8c4a:	5a01      	mov	[S-2], Y
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
    8c4c:	7ee2      	lod	X, A
    8c4e:	22da 0262 	add	X, #610
    8c52:	6400      	lod	YL, #0
    8c54:	46f8      	mov	[X], YL
void ErrorLogInit( void)
{
	if ( (AWD_CTRL & AWD_RST) != 0 )
	{
		uint16 i;
		for ( i = 0; i < C_ERR_LOG_SZ; i++ )
    8c56:	a001      	add	A, #1
    8c58:	7e01      	lod	X, [S-2]
    8c5a:	20ff      	add	X, #-1
    8c5c:	5e01      	mov	[S-2], X
    8c5e:	1d76      	jne	0x8c4c <_ErrorLogInit+0xe>
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
		}
		l_u8ErrorLogIdx = 0;
    8c60:	46d8 0133 	mov	0x133 <_l_u8ErrorLogIdx>, YL
    8c64:	5405      	ret	#6

00008c66 <_SetLastError>:
 *
 *	Comments:	Save error-code in Error-FiFo-buffer, unless last error is the 
 *				same as error posted.
 * ****************************************************************************	*/
void SetLastError( uint8 u8ErrorCode)
{
    8c66:	5801      	inc	S, #2
    8c68:	7ee2      	lod	X, A
	if ( (l_u8ErrorLogIdx == 0) || (l_au8FiFoErrorLog[l_u8ErrorLogIdx - 1] != u8ErrorCode) )
    8c6a:	62d8 0133 	lod	AL, 0x133 <_l_u8ErrorLogIdx>
    8c6e:	4201      	mov	[S-2], AL
    8c70:	1908      	je	0x8c82 <_SetLastError+0x1c>
    8c72:	5cf2      	usex	A
    8c74:	7ae2      	lod	Y, A
    8c76:	e2da 0261 	add	Y, #609
    8c7a:	62f0      	lod	AL, [Y]
    8c7c:	7aee      	lod	Y, X
    8c7e:	8ee8      	cmp	AL, YL
    8c80:	1920      	je	0x8cc2 <_SetLastError+0x5c>
	{
		/* Don't log the same error over and over again */
		l_au8FiFoErrorLog[l_u8ErrorLogIdx] = u8ErrorCode;
    8c82:	6201      	lod	AL, [S-2]
    8c84:	5cf2      	usex	A
    8c86:	7ae2      	lod	Y, A
    8c88:	e2da 0262 	add	Y, #610
    8c8c:	72ee      	lod	A, X
    8c8e:	42f0      	mov	[Y], AL
		if ( l_u8ErrorLogIdx < (C_ERR_LOG_SZ - 1) )
    8c90:	6201      	lod	AL, [S-2]
    8c92:	8c08      	cmp	AL, #8
    8c94:	1e03      	jug	0x8c9c <_SetLastError+0x36>
		{
			l_u8ErrorLogIdx++;
    8c96:	8001      	add	AL, #1
    8c98:	42d8 0133 	mov	0x133 <_l_u8ErrorLogIdx>, AL
		}

		/* Log serious error-codes also in NVRAM */
		/* Serious errors are:
		  	  Unsupported IRQ's   or C_ERR_INV_MLXPAGE_CRC1..4, CAL_GN or Over-temperature                   or 'Fatal'-errors */
		if ( (u8ErrorCode < 0x20) || ((u8ErrorCode & 0xC8) == 0xC8) || (u8ErrorCode == (uint8) C_ERR_DIAG_OVER_TEMP) || ((u8ErrorCode & 0xF0) == 0xF0) ) /*lint !e845 */
    8c9c:	72ee      	lod	A, X
    8c9e:	8c1f      	cmp	AL, #31
    8ca0:	1a0d      	jule	0x8cbc <_SetLastError+0x56>
    8ca2:	b6da 00c8 	and	A, #200
    8ca6:	aeda 00c8 	cmp	A, #200
    8caa:	1908      	je	0x8cbc <_SetLastError+0x56>
    8cac:	72ee      	lod	A, X
    8cae:	8cd1      	cmp	AL, #-47
    8cb0:	1905      	je	0x8cbc <_SetLastError+0x56>
    8cb2:	b6da 00f0 	and	A, #240
    8cb6:	aeda 00f0 	cmp	A, #240
    8cba:	1d03      	jne	0x8cc2 <_SetLastError+0x5c>
		{
			(void) NVRAM_LogError( u8ErrorCode);
    8cbc:	72ee      	lod	A, X
    8cbe:	82db 9cba 	callf	0x9cba <_NVRAM_LogError>
    8cc2:	5403      	ret	#4

00008cc4 <_GetLastError>:
		}
	}
} /* End of SetLastError() */

uint8 GetLastError( void)
{
    8cc4:	5809      	inc	S, #10
	uint8 u8Reply = l_au8FiFoErrorLog[0];
    8cc6:	62d8 0262 	lod	AL, 0x262 <_l_au8FiFoErrorLog>
    8cca:	5cf2      	usex	A
    8ccc:	5209      	mov	[S-10], A
	if ( l_u8ErrorLogIdx != 0 )
    8cce:	62d8 0133 	lod	AL, 0x133 <_l_u8ErrorLogIdx>
    8cd2:	4207      	mov	[S-8], AL
    8cd4:	1924      	je	0x8d1e <_GetLastError+0x5a>
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8cd6:	72e3      	lod	A, M
    8cd8:	5203      	mov	[S-4], A
	{
		uint16 i;
		ATOMIC_CODE
    8cda:	4407      	mov	R, #0
    8cdc:	500c      	call	fp0:0x60
    8cde:	54f0      	mov	UPr, #0
    8ce0:	7001      	lod	A, #1
    8ce2:	5205      	mov	[S-6], A
    8ce4:	6207      	lod	AL, [S-8]
    8ce6:	5cf2      	usex	A
    8ce8:	5201      	mov	[S-2], A
    8cea:	7001      	lod	A, #1
    8cec:	ae01      	cmp	A, [S-2]
    8cee:	1c0b      	jnc	0x8d06 <_GetLastError+0x42>
    8cf0:	7a05      	lod	Y, [S-6]
    8cf2:	e2da 0262 	add	Y, #610
    8cf6:	7ee6      	lod	X, Y
    8cf8:	20ff      	add	X, #-1
    8cfa:	62f0      	lod	AL, [Y]
    8cfc:	42f8      	mov	[X], AL
    8cfe:	7205      	lod	A, [S-6]
    8d00:	a001      	add	A, #1
    8d02:	5205      	mov	[S-6], A
    8d04:	07f3      	jmp	0x8cec <_GetLastError+0x28>
    8d06:	6207      	lod	AL, [S-8]
    8d08:	80ff      	add	AL, #-1
    8d0a:	42d8 0133 	mov	0x133 <_l_u8ErrorLogIdx>, AL
    8d0e:	5cf2      	usex	A
    8d10:	7ae2      	lod	Y, A
    8d12:	e2da 0262 	add	Y, #610
    8d16:	6000      	lod	AL, #0
    8d18:	42f0      	mov	[Y], AL
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8d1a:	7203      	lod	A, [S-4]
    8d1c:	52e3      	mov	M, A
			l_u8ErrorLogIdx--;
			l_au8FiFoErrorLog[l_u8ErrorLogIdx] = C_ERR_NONE;
		);
	}
	return ( u8Reply );
} /* End of GetLastError() */
    8d1e:	7209      	lod	A, [S-10]
    8d20:	540b      	ret	#12

00008d22 <_MotorDriverInit>:
 * MotorDriverInit()
 *
 * Initialise Motor Driver
 * ****************************************************************************	*/
void MotorDriverInit( void)
{
    8d22:	5835      	inc	S, #54
#if _SUPPORT_DOUBLE_USTEP
	uint16 u16MotorMicroStepsPerFullStep = (1 << (NVRAM_MICRO_STEPS + 1));		/* Number of micro-steps per full-step (2, 4, 8 or 16) */
    8d24:	618e      	lod	AL, dp:0x8e <_g_NvramUser+0x34>
    8d26:	4233      	mov	[S-52], AL
    8d28:	44b0      	lsr	AL, #2
    8d2a:	44b0      	lsr	AL, #2
    8d2c:	4430      	lsr	AL
    8d2e:	b403      	and	A, #3
    8d30:	a001      	add	A, #1
    8d32:	44e2      	sfb	A
    8d34:	5235      	mov	[S-54], A
    8d36:	6233      	lod	AL, [S-52]
    8d38:	4440      	rl	AL
    8d3a:	9401      	and	AL, #1
    8d3c:	5cf2      	usex	A
    8d3e:	7ae2      	lod	Y, A
    8d40:	e002      	add	Y, #2
    8d42:	4426      	asl	Y
    uint32 result;

    __asm__ __volatile__ (
    8d44:	7235      	lod	A, [S-54]
    8d46:	4801      	mulu	D, A, Y
    8d48:	72ef      	lod	A, S
    8d4a:	a0ce      	add	A, #-50
    8d4c:	4cf3      	swap	YA
    8d4e:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8d50:	7a31      	lod	Y, [S-50]
    8d52:	5ad8 026e 	mov	0x26e <_g_u16MotorMicroStepsPerElecRotation>, Y
    8d56:	618d      	lod	AL, dp:0x8d <_g_NvramUser+0x33>
    8d58:	44b2      	lsr	A, #2
    8d5a:	44b2      	lsr	A, #2
    8d5c:	b40f      	and	A, #15
    8d5e:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    8d60:	4801      	mulu	D, A, Y
    8d62:	7aef      	lod	Y, S
    8d64:	e0d2      	add	Y, #-46
    8d66:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8d68:	7e2d      	lod	X, [S-46]
    8d6a:	5ed8 0270 	mov	0x270 <_g_u16MotorMicroStepsPerMechRotation>, X
	uint16 u16MotorMicroStepsPerFullStep = (1 << NVRAM_MICRO_STEPS);			/* Number of micro-steps per full-step (1, 2, 4 or 8) */
#endif /* _SUPPORT_DOUBLE_USTEP */
	g_u16MotorMicroStepsPerElecRotation = (uint16) mulU32_U16byU16( u16MotorMicroStepsPerFullStep, (NVRAM_MOTOR_PHASES + 2) << 1);
	g_u16MotorMicroStepsPerMechRotation = (uint16) mulU32_U16byU16( NVRAM_POLE_PAIRS, g_u16MotorMicroStepsPerElecRotation);
	{
		uint16 u16ConstAccelaration = NVRAM_ACCELERATION_CONST;
    8d6e:	71a2      	lod	A, dp:0xa2 <_g_NvramUser+0x48>
		if ( u16ConstAccelaration != 0 )
    8d70:	1d01      	jne	0x8d74 <_MotorDriverInit+0x52>
    8d72:	0085      	jmp	0x8e7e <_MotorDriverInit+0x15c>
		{
			l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60), g_u16MotorMicroStepsPerMechRotation);
    8d74:	722d      	lod	A, [S-46]
    8d76:	52df      	push	A
    8d78:	4ce2 2c40 	mov	YA, #105000000
    8d7c:	0642 
    8d7e:	82db 6c3a 	callf	0x6c3a <_divU32_U32byU16>
    8d82:	4cc0      	mov	D, YA
    8d84:	52d8 0318 	mov	0x318 <_l_u32Temp>, A
    8d88:	5ad8 031a 	mov	0x31a <_l_u32Temp+0x2>, Y
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8d8c:	5c01      	dec	S, #2
    8d8e:	79a0      	lod	Y, dp:0xa0 <_g_NvramUser+0x46>
    8d90:	5a29      	mov	[S-42], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8d92:	4c80      	mov	YA, D
    8d94:	7e29      	lod	X, [S-42]
    8d96:	4c63      	divu	YA, X
    8d98:	4c63      	divu	YA, X
    8d9a:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8d9c:	a0ff      	add	A, #-1
    8d9e:	52d8 0282 	mov	0x282 <_g_au16MotorSpeedCommutTimerPeriod+0xe>, A
    8da2:	52d8 0274 	mov	0x274 <_g_au16MotorSpeedCommutTimerPeriod>, A
    8da6:	79c4      	lod	Y, dp:0xc4 <__bss_dp_size+0x14>
    8da8:	5a25      	mov	[S-38], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8daa:	4c80      	mov	YA, D
    8dac:	7e25      	lod	X, [S-38]
    8dae:	4c63      	divu	YA, X
    8db0:	4c63      	divu	YA, X
    8db2:	5223      	mov	[S-36], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8db4:	a0ff      	add	A, #-1
    8db6:	52d8 0280 	mov	0x280 <_g_au16MotorSpeedCommutTimerPeriod+0xc>, A
    8dba:	52d8 0276 	mov	0x276 <_g_au16MotorSpeedCommutTimerPeriod+0x2>, A
    8dbe:	7990      	lod	Y, dp:0x90 <_g_NvramUser+0x36>
    8dc0:	5a1f      	mov	[S-32], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8dc2:	4c80      	mov	YA, D
    8dc4:	7e1f      	lod	X, [S-32]
    8dc6:	4c63      	divu	YA, X
    8dc8:	4c63      	divu	YA, X
    8dca:	521d      	mov	[S-30], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8dcc:	a0ff      	add	A, #-1
    8dce:	5152      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, A
    8dd0:	52d8 0278 	mov	0x278 <_g_au16MotorSpeedCommutTimerPeriod+0x4>, A
    8dd4:	7992      	lod	Y, dp:0x92 <_g_NvramUser+0x38>
    8dd6:	5a19      	mov	[S-26], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8dd8:	4c80      	mov	YA, D
    8dda:	7e19      	lod	X, [S-26]
    8ddc:	4c63      	divu	YA, X
    8dde:	4c63      	divu	YA, X
    8de0:	5217      	mov	[S-24], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8de2:	a0ff      	add	A, #-1
    8de4:	52d8 027a 	mov	0x27a <_g_au16MotorSpeedCommutTimerPeriod+0x6>, A
    8de8:	7994      	lod	Y, dp:0x94 <_g_NvramUser+0x3a>
    8dea:	5a13      	mov	[S-20], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8dec:	4c80      	mov	YA, D
    8dee:	7e13      	lod	X, [S-20]
    8df0:	4c63      	divu	YA, X
    8df2:	4c63      	divu	YA, X
    8df4:	5211      	mov	[S-18], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8df6:	a0ff      	add	A, #-1
    8df8:	52d8 027c 	mov	0x27c <_g_au16MotorSpeedCommutTimerPeriod+0x8>, A
    8dfc:	7996      	lod	Y, dp:0x96 <_g_NvramUser+0x3c>
    8dfe:	5a0d      	mov	[S-14], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e00:	4c80      	mov	YA, D
    8e02:	7e0d      	lod	X, [S-14]
    8e04:	4c63      	divu	YA, X
    8e06:	4c63      	divu	YA, X
    8e08:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e0a:	a0ff      	add	A, #-1
    8e0c:	52d8 027e 	mov	0x27e <_g_au16MotorSpeedCommutTimerPeriod+0xa>, A
			g_au16MotorSpeedCommutTimerPeriod[3] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED1) - 1;
			g_au16MotorSpeedCommutTimerPeriod[4] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED2) - 1;
			g_au16MotorSpeedCommutTimerPeriod[5] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED3) - 1;
			g_au16MotorSpeedCommutTimerPeriod[6] = g_au16MotorSpeedCommutTimerPeriod[1];
			g_au16MotorSpeedCommutTimerPeriod[7] = g_au16MotorSpeedCommutTimerPeriod[0];
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[2];	/* Target commutation timer period (target speed) */
    8e10:	7952      	lod	Y, dp:0x52 <_g_u16CommutTimerPeriod>
    8e12:	5954      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, Y
    8e14:	7229      	lod	A, [S-42]
    8e16:	a01e      	add	A, #30
    8e18:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e1a:	4c80      	mov	YA, D
    8e1c:	7c3c      	lod	X, #60
    8e1e:	4c63      	divu	YA, X
    8e20:	4c63      	divu	YA, X
    8e22:	520b      	mov	[S-12], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e24:	52d8 0284 	mov	0x284 <_g_au16MotorSpeedRPS>, A
    8e28:	7225      	lod	A, [S-38]
    8e2a:	a01e      	add	A, #30
    8e2c:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e2e:	4c80      	mov	YA, D
    8e30:	4c63      	divu	YA, X
    8e32:	4c63      	divu	YA, X
    8e34:	5209      	mov	[S-10], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e36:	52d8 0286 	mov	0x286 <_g_au16MotorSpeedRPS+0x2>, A
    8e3a:	721f      	lod	A, [S-32]
    8e3c:	a01e      	add	A, #30
    8e3e:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e40:	4c63      	divu	YA, X
    8e42:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e44:	52d8 0288 	mov	0x288 <_g_au16MotorSpeedRPS+0x4>, A
    8e48:	7219      	lod	A, [S-26]
    8e4a:	a01e      	add	A, #30
    8e4c:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e4e:	4c63      	divu	YA, X
    8e50:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e52:	52d8 028a 	mov	0x28a <_g_au16MotorSpeedRPS+0x6>, A
    8e56:	7213      	lod	A, [S-20]
    8e58:	a01e      	add	A, #30
    8e5a:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e5c:	4c63      	divu	YA, X
    8e5e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e60:	52d8 028c 	mov	0x28c <_g_au16MotorSpeedRPS+0x8>, A
    8e64:	720d      	lod	A, [S-14]
    8e66:	a01e      	add	A, #30
    8e68:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e6a:	4c63      	divu	YA, X
    8e6c:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e6e:	52d8 028e 	mov	0x28e <_g_au16MotorSpeedRPS+0xa>, A
			g_au16MotorSpeedRPS[1] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED_TORQUE_BOOST + 30U), 60);
			g_au16MotorSpeedRPS[2] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED0 + 30U), 60);
			g_au16MotorSpeedRPS[3] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED1 + 30U), 60);
			g_au16MotorSpeedRPS[4] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED2 + 30U), 60);
			g_au16MotorSpeedRPS[5] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60);
			g_au16MotorSpeedRPS[6] = g_au16MotorSpeedRPS[1];
    8e72:	7a09      	lod	Y, [S-10]
    8e74:	5ad8 0290 	mov	0x290 <_g_au16MotorSpeedRPS+0xc>, Y
			g_au16MotorSpeedRPS[7] = g_au16MotorSpeedRPS[0];
    8e78:	7e0b      	lod	X, [S-12]
    8e7a:	5ed8 0292 	mov	0x292 <_g_au16MotorSpeedRPS+0xe>, X
		}
	}

	g_u16CorrectionRatio = NVRAM_MIN_CORR_RATIO;
    8e7e:	61be      	lod	AL, dp:0xbe <__bss_dp_size+0xe>
    8e80:	5cf2      	usex	A
    8e82:	4832 0576 	muls	YA, A, #1398
    8e86:	48a3      	lsr	YA, #4
    8e88:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
	/* BLDC motor Commutation/Stepper timer */
	g_u16MicroStepIdx = 0;
    8e8a:	7000      	lod	A, #0
    8e8c:	5150      	mov	dp:0x50 <_g_u16MicroStepIdx>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0;												/* Timer mode 0 */
    8e8e:	7ada 4001 	lod	Y, #16385
    8e92:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
	TMR1_REGB = g_u16CommutTimerPeriod;											/* Will be overwritten by MotorDriverStart() */
    8e94:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    8e96:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    8e98:	7c40      	lod	X, #64
    8e9a:	5ed8 2034 	mov	0x2034 <__ep__+0x1034>, X
	XI0_MASK |= EN_T1_INT4;														/* Enable Timer1, CompareB (T1_INT4) */
    8e9e:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    8ea2:	a440      	or	A, #64
    8ea4:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	PRIO = (PRIO & ~(3 << 6)) | ((4 - 3) << 6);									/* Set Timer1 priority to 4 (3..6) */
    8ea8:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8eac:	b6da ff3f 	and	A, #65343
    8eb0:	a440      	or	A, #64
    8eb2:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT0_IT;
    8eb6:	72da 0100 	lod	A, #256
    8eba:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT0_IT;
    8ebe:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    8ec2:	a6da 0100 	or	A, #256
    8ec6:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8eca:	61c2      	lod	AL, dp:0xc2 <__bss_dp_size+0x12>
    8ecc:	5cf2      	usex	A
    uint32 result;

    __asm__ __volatile__ (
    8ece:	7a35      	lod	Y, [S-54]
    8ed0:	4801      	mulu	D, A, Y
    8ed2:	7aef      	lod	Y, S
    8ed4:	e0fa      	add	Y, #-6
    8ed6:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8ed8:	7e05      	lod	X, [S-6]
    8eda:	5ed8 0272 	mov	0x272 <_g_u16MotorRewindSteps>, X

	g_u16MotorRewindSteps = (uint16) mulU32_U16byU16( NVRAM_REWIND_STEPS, u16MotorMicroStepsPerFullStep);

	/* Setup Motor PWM */	
	PWM1_CTRL = 0;																/* Disable master */
    8ede:	6000      	lod	AL, #0
    8ee0:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = 0;																/* Disable Slave 1 */
    8ee4:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = 0;																/* Disable Slave 2 */
    8ee8:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = 0;																/* Disable Slave 3 */
    8eec:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = 0;																/* Disable Slave 4 */
    8ef0:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
	PWM1_PSCL = PWM_PRESCALER;													/* Initialise the master pre-scaler ratio (Fck/8) */
    8ef4:	42d8 284b 	mov	0x284b <__io__+0x4b>, AL
	PWM1_PER = PWM_REG_PERIOD;
    8ef8:	7ada 0576 	lod	Y, #1398
    8efc:	5ad8 284c 	mov	0x284c <__io__+0x4c>, Y
	PWM2_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8f00:	5ad8 2856 	mov	0x2856 <__io__+0x56>, Y
	PWM3_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8f04:	5ad8 2860 	mov	0x2860 <__io__+0x60>, Y
	PWM4_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8f08:	5ad8 286a 	mov	0x286a <__io__+0x6a>, Y
	PWM5_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    8f0c:	5ad8 2874 	mov	0x2874 <__io__+0x74>, Y
	PWM5_CMP = (((83L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 83% of period */
#else  /* _SUPPORT_PHASE_SHORT_DET */
	/* (Single PWM)	17%			33%			50%			75%			100%		(7.0us/ADC-conversion)
	 * MF_STEPPER:	Temperature	Vs-filt		Imotor1		Vsm-unfilt	Imotor2
	 */
	PWM1_CMP = (((17L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 17% of period */
    8f10:	7eda 00ee 	lod	X, #238
    8f14:	5ed8 2852 	mov	0x2852 <__io__+0x52>, X
	PWM2_CMP = (((33L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 33% of period */
    8f18:	72da 01cd 	lod	A, #461
    8f1c:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
	PWM3_CMP = (((50L * PWM_REG_PERIOD) + 50)/100);		/*  10.5us */			/* 50% of period */
    8f20:	7ada 02bb 	lod	Y, #699
    8f24:	5ad8 2866 	mov	0x2866 <__io__+0x66>, Y
	PWM4_CMP = (((75L * PWM_REG_PERIOD) + 50)/100);		/*  10.5us */			/* 75% of period */
    8f28:	7eda 0419 	lod	X, #1049
    8f2c:	5ed8 2870 	mov	0x2870 <__io__+0x70>, X
	PWM3_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 2 control register - CMPI enabled */
	PWM4_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 3 control register - CMPI enabled */
	PWM5_CTRL = (MODE | EXT | EBLK);											/* Initialise the slave 4 control register - CMPI disabled */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	/* In-depended mode */
	PWM1_CTRL = (EBLK | ECI | EPI);												/* Initialise the master control register - CMPI and PWMI enabled */
    8f30:	6019      	lod	AL, #25
    8f32:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 1 control register - CMPI enabled */
    8f36:	6013      	lod	AL, #19
    8f38:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 2 control register - CMPI enabled */
    8f3c:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 3 control register - CMPI enabled */
    8f40:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 4 control register - CMPI enabled */
    8f44:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	PWM1_CTRL |= EBLK;															/* Start PWM in application mode */
    8f48:	62d8 284a 	lod	AL, 0x284a <__io__+0x4a>
    8f4c:	8401      	or	AL, #1
    8f4e:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
    8f52:	5437      	ret	#56

00008f54 <_MotorDriverSelfTest>:
 * 3. Test Open connection with motor-phase
 * 4. Test BEMF Voltage levels
 * ****************************************************************************	*/
#define FET_SETTING (((10*PLL_freq)/(1000000*CYCLES_PER_INSTR*2)) + 1)			/* 10us: 10us*PLL-freq/(10000000us/s * #cycles/instruction) * instructions */
void MotorDriverSelfTest( void)
{
    8f54:	5823      	inc	S, #36
	uint16 u16SelfTestIdx;
	uint16 u16VdsThreshold;														/* MMP130919-1/MMP140403-1 */
	T_ADC_SELFTEST_4PH adcMotorSelfTest4Ph;
	uint16 u16Pwm2Storage = PWM2_CMP;											/* MMP150219-2: Save PWM2 ADC trigger CMP time */
    8f56:	72d8 285c 	lod	A, 0x285c <__io__+0x5c>
    8f5a:	5209      	mov	[S-10], A
	PWM2_CMP = (((50L * PWM_REG_PERIOD) + 50)/100);								/* MMP150219-2: Set PWM2 ADC trigger CMP time at 50% or period */
    8f5c:	7eda 02bb 	lod	X, #699
    8f60:	5ed8 285c 	mov	0x285c <__io__+0x5c>, X

	g_e8ErrorCoil = 0;//init
    8f64:	6000      	lod	AL, #0
    8f66:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL

	MeasureVsupplyAndTemperature();												/* MMP130919-1 - Begin */
    8f68:	152e      	call	0x89c6 <_MeasureVsupplyAndTemperature>
	GetVsupplyMotor();
    8f6a:	149f      	call	0x88aa <_GetVsupplyMotor>
	if ( NVRAM_VDS_THRESHOLD != 0 )
    8f6c:	61c9      	lod	AL, dp:0xc9 <__bss_dp_size+0x19>
    8f6e:	b43f      	and	A, #63
    8f70:	4872 0019 	muls	A, A, #25
    8f74:	4432      	lsr	A
    8f76:	1910      	je	0x8f98 <_MotorDriverSelfTest+0x44>
    8f78:	0011      	jmp	0x8f9c <_MotorDriverSelfTest+0x48>
		DRVCFG_GND_UVWT();

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
		{
			/* Over-current trigger; Phase makes short with other phase */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8f7a:	6002      	lod	AL, #2
    8f7c:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_B);
    8f7e:	72da 00eb 	lod	A, #235
    8f82:	1671      	call	0x8c66 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;//Ban, phase shot with other phase
    8f84:	60eb      	lod	AL, #-21
    8f86:	0006      	jmp	0x8f94 <_MotorDriverSelfTest+0x40>
#endif // _SUPPORT_COIL_RESISTANCE_CHECK
		extern uint16 l_u16CurrentZeroOffset;
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
		{
			/* No current (less than 10 LSB's); Coil Open */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    8f88:	6002      	lod	AL, #2
    8f8a:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_C);
    8f8c:	72da 00ec 	lod	A, #236
    8f90:	166a      	call	0x8c66 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;
    8f92:	60ec      	lod	AL, #-20
    8f94:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			break;
    8f96:	00b7      	jmp	0x9106 <_MotorDriverSelfTest+0x1b2>
	{
		u16VdsThreshold = NVRAM_VDS_THRESHOLD;
	}
	else
	{
		u16VdsThreshold = 200U;
    8f98:	72da 00c8 	lod	A, #200
    8f9c:	520b      	mov	[S-12], A
	}																			/* MMP130919-1 - End */

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    8f9e:	7000      	lod	A, #0
    8fa0:	520d      	mov	[S-14], A
    8fa2:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    8fa4:	1901      	je	0x8fa8 <_MotorDriverSelfTest+0x54>
    8fa6:	003e      	jmp	0x9024 <_MotorDriverSelfTest+0xd0>
	{
		int16 i16DriverCurrent = 0;												/* MMP140403-1 */
    8fa8:	7000      	lod	A, #0
    8faa:	5207      	mov	[S-8], A

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestA[u16SelfTestIdx]);		/* MMP130904-1 */
    8fac:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8fb0:	b6da fe00 	and	A, #65024
    8fb4:	7a0d      	lod	Y, [S-14]
    8fb6:	e2da a526 	add	Y, #42278
    8fba:	66f0      	lod	YL, [Y]
    8fbc:	5cf6      	usex	Y
    8fbe:	a6e6      	or	A, Y
    8fc0:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		MeasurePhaseVoltage( (uint16)c_au16DrvAdcSelfTestA[u16SelfTestIdx>>1]);	/* MMP140403-1/MMP130919-1 - Begin */
    8fc4:	720d      	lod	A, [S-14]
    8fc6:	4432      	lsr	A
    8fc8:	44a2      	asl	A, #2
    8fca:	a2da a516 	add	A, #42262
    8fce:	151b      	call	0x8a06 <_MeasurePhaseVoltage>
		if ( (u16SelfTestIdx & 1) == 0 )
    8fd0:	720d      	lod	A, [S-14]
    8fd2:	b401      	and	A, #1
    8fd4:	5205      	mov	[S-6], A
    8fd6:	1d03      	jne	0x8fde <_MotorDriverSelfTest+0x8a>
		{
			/* Even-index (0,2,4,6) are phase to ground: Check current too (< 20 mA) */
			MeasureMotorCurrent();
    8fd8:	150d      	call	0x89f4 <_MeasureMotorCurrent>
			i16DriverCurrent = GetMotorDriverCurrent();
    8fda:	14e7      	call	0x89aa <_GetMotorDriverCurrent>
    8fdc:	5207      	mov	[S-8], A
		}
		/* Even-index (0,2,4,6) are phase to ground: Vphase < Vds; Odd-index (1,3,5,7) are phase to supply: Vphase > (Vsup - Vds) */
		if ( (g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO) ||
    8fde:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    8fe0:	1d10      	jne	0x9002 <_MotorDriverSelfTest+0xae>
    8fe2:	7205      	lod	A, [S-6]
    8fe4:	1d08      	jne	0x8ff6 <_MotorDriverSelfTest+0xa2>
    8fe6:	72d8 0114 	lod	A, 0x114 <_g_i16PhaseVoltage>
    8fea:	ae0b      	cmp	A, [S-12]
    8fec:	1f0a      	jsg	0x9002 <_MotorDriverSelfTest+0xae>
    8fee:	7e07      	lod	X, [S-8]
    8ff0:	2c14      	cmp	X, #20
    8ff2:	1f07      	jsg	0x9002 <_MotorDriverSelfTest+0xae>
    8ff4:	000e      	jmp	0x9012 <_MotorDriverSelfTest+0xbe>
    8ff6:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    8ff8:	aa0b      	sub	A, [S-12]
    8ffa:	7ad8 0114 	lod	Y, 0x114 <_g_i16PhaseVoltage>
    8ffe:	eee2      	cmp	Y, A
    9000:	1e88      	jsge	0x9012 <_MotorDriverSelfTest+0xbe>
			(((u16SelfTestIdx & 1) == 0) && ((g_i16PhaseVoltage > (int16)u16VdsThreshold) || (i16DriverCurrent > 20))) ||
			(((u16SelfTestIdx & 1) != 0) && (g_i16PhaseVoltage < (int16)(g_i16MotorVoltage - u16VdsThreshold))) )
		{																		/* MMP130919-1 - End */
			/* Over-current trigger; Phase makes short with supply or Ground */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    9002:	6002      	lod	AL, #2
    9004:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( (uint8) C_ERR_SELFTEST_A);
    9006:	72da 00ea 	lod	A, #234
    900a:	162d      	call	0x8c66 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_A;//Ban, FET short with ground or supply
    900c:	60ea      	lod	AL, #-22
    900e:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			break;
    9010:	0009      	jmp	0x9024 <_MotorDriverSelfTest+0xd0>
	{
		u16VdsThreshold = 200U;
	}																			/* MMP130919-1 - End */

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    9012:	720d      	lod	A, [S-14]
    9014:	a001      	add	A, #1
    9016:	520d      	mov	[S-14], A
    9018:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    901a:	1d04      	jne	0x9024 <_MotorDriverSelfTest+0xd0>
    901c:	720d      	lod	A, [S-14]
    901e:	ac07      	cmp	A, #7
    9020:	1e01      	jug	0x9024 <_MotorDriverSelfTest+0xd0>
    9022:	07c2      	jmp	0x8fa8 <_MotorDriverSelfTest+0x54>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9024:	7840      	lod	Y, #64
    9026:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    902a:	6000      	lod	AL, #0
    902c:	72e4      	swap	A
    902e:	5201      	mov	[S-2], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9030:	720b      	lod	A, [S-12]
    9032:	7e01      	lod	X, [S-2]
    9034:	4821      	mulu	YA, A, Y
    9036:	4c63      	divu	YA, X
    9038:	4c63      	divu	YA, X
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    903a:	7000      	lod	A, #0
    903c:	520d      	mov	[S-14], A
    903e:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9040:	1901      	je	0x9044 <_MotorDriverSelfTest+0xf0>
    9042:	0061      	jmp	0x9106 <_MotorDriverSelfTest+0x1b2>
		uint16 u16VphH;
		uint16 u16VphL;
		uint16 u16Vds;
		uint16 u16MotorCoilCurrent;
		register uint16 u16DC;
		if ( u16SelfTestIdx & 0x02 )
    9044:	720d      	lod	A, [S-14]
    9046:	b402      	and	A, #2
    9048:	5203      	mov	[S-4], A
    904a:	1903      	je	0x9052 <_MotorDriverSelfTest+0xfe>
		{
			/* Phase LOW + phase -PWM */
			u16DC = (PWM_REG_PERIOD >> 3);
    904c:	7ada 00ae 	lod	Y, #174
    9050:	0002      	jmp	0x9056 <_MotorDriverSelfTest+0x102>
		}
		else
		{
			/* Phase HIGH + phase PWM */
			u16DC = PWM_REG_PERIOD - (PWM_REG_PERIOD >> 3);						/* Approx. 12.5% */
    9052:	7ada 04c8 	lod	Y, #1224
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
		u16DC = u16DC/2;
    9056:	4436      	lsr	Y
		PWM2_LT = u16DC;														/* Copy the results into the PWM register for phase U */
    9058:	5ad8 2858 	mov	0x2858 <__io__+0x58>, Y
		PWM2_HT = PWM_REG_PERIOD - u16DC;
    905c:	72da 0576 	lod	A, #1398
    9060:	aae6      	sub	A, Y
    9062:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
    9066:	5ad8 2862 	mov	0x2862 <__io__+0x62>, Y
		PWM3_HT = PWM_REG_PERIOD - u16DC;
    906a:	52d8 2864 	mov	0x2864 <__io__+0x64>, A
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
    906e:	5ad8 286c 	mov	0x286c <__io__+0x6c>, Y
		PWM4_HT = PWM_REG_PERIOD - u16DC;
    9072:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
    9076:	5ad8 2876 	mov	0x2876 <__io__+0x76>, Y
		PWM5_HT = PWM_REG_PERIOD - u16DC;
    907a:	52d8 2878 	mov	0x2878 <__io__+0x78>, A
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
    907e:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestB4[u16SelfTestIdx]);
    9082:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9086:	b6da fe00 	and	A, #65024
    908a:	7a0d      	lod	Y, [S-14]
    908c:	e2da a50c 	add	Y, #42252
    9090:	66f0      	lod	YL, [Y]
    9092:	5cf6      	usex	Y
    9094:	a6e6      	or	A, Y
    9096:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		ADC_Stop();																/* clear the ADC control register */
    909a:	82db 87a4 	callf	0x87a4 <_ADC_Stop>
		if ( u16SelfTestIdx & 2 )
    909e:	7203      	lod	A, [S-4]
    90a0:	1904      	je	0x90aa <_MotorDriverSelfTest+0x156>
		{
			ADC_SBASE = (uint16) tAdcSelfTest4B;								/* Phase = Low */
    90a2:	7eda a418 	lod	X, #42008
    90a6:	5e92      	mov	io:0x12 <__dp_noinit_size+0x2>, X
    90a8:	0003      	jmp	0x90b0 <_MotorDriverSelfTest+0x15c>
		}
		else
		{
			ADC_SBASE = (uint16) tAdcSelfTest4A;								/* Phase = High */
    90aa:	72da a430 	lod	A, #42032
    90ae:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
		}
		ADC_DBASE = (uint16) &adcMotorSelfTest4Ph;
    90b0:	7eef      	lod	X, S
    90b2:	20dc      	add	X, #-36
    90b4:	5e94      	mov	io:0x14 <__dp_noinit_size+0x4>, X
		ADC_CTRL |= (ADC_TRIG_SRC | ADC_SYNC_SOC);								/* Single cycle of conversion is done */
    90b6:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    90b8:	a6da 0082 	or	A, #130
    90bc:	5290      	mov	io:0x10 <__dp_noinit_size>, A
		ADC_CTRL |= ADC_START;													/* Start ADC */
    90be:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    90c0:	a401      	or	A, #1
    90c2:	5290      	mov	io:0x10 <__dp_noinit_size>, A

		/* This takes about 4 Motor PWM-periods per self-test */
		while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;						/* Wait for ADC result (Time-out?) */
    90c4:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    90c6:	b401      	and	A, #1
    90c8:	1d7d      	jne	0x90c4 <_MotorDriverSelfTest+0x170>

		DRVCFG_GND_UVWT();
    90ca:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    90ce:	b6da fe00 	and	A, #65024
    90d2:	a6da 00aa 	or	A, #170
    90d6:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
    90da:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    90dc:	1901      	je	0x90e0 <_MotorDriverSelfTest+0x18c>
    90de:	074d      	jmp	0x8f7a <_MotorDriverSelfTest+0x26>
			SetLastError( C_ERR_SELFTEST_B);
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;//Ban, phase shot with other phase
			break;
		}

		if ( u16SelfTestIdx & 2 )
    90e0:	7203      	lod	A, [S-4]
    90e2:	1902      	je	0x90e8 <_MotorDriverSelfTest+0x194>
		{
			/* Use tAdcSelfTest4B */
			u16Vsm = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;				/* Current becomes voltage */
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
    90e4:	7211      	lod	A, [S-18]
    90e6:	0001      	jmp	0x90ea <_MotorDriverSelfTest+0x196>
		}
		else
		{
			/* Use tAdcSelfTest4A */
			u16Vsm = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;
    90e8:	720f      	lod	A, [S-16]
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_E;//Ban, phase resistance is too small
			break;
		}
#endif // _SUPPORT_COIL_RESISTANCE_CHECK
		extern uint16 l_u16CurrentZeroOffset;
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
    90ea:	aad8 012e 	sub	A, 0x12e <_l_u16CurrentZeroOffset>
    90ee:	ac09      	cmp	A, #9
    90f0:	1f01      	jsg	0x90f4 <_MotorDriverSelfTest+0x1a0>
    90f2:	074a      	jmp	0x8f88 <_MotorDriverSelfTest+0x34>
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    90f4:	720d      	lod	A, [S-14]
    90f6:	a001      	add	A, #1
    90f8:	520d      	mov	[S-14], A
    90fa:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    90fc:	1d04      	jne	0x9106 <_MotorDriverSelfTest+0x1b2>
    90fe:	720d      	lod	A, [S-14]
    9100:	ac09      	cmp	A, #9
    9102:	1e01      	jug	0x9106 <_MotorDriverSelfTest+0x1b2>
    9104:	079f      	jmp	0x9044 <_MotorDriverSelfTest+0xf0>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;
			break;
		}
	}	

	DRVCFG_DIS_UVWT();
    9106:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    910a:	b6da fe00 	and	A, #65024
    910e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase U */
    9112:	7eda 02bb 	lod	X, #699
    9116:	5ed8 2858 	mov	0x2858 <__io__+0x58>, X
	PWM3_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase V */
    911a:	5ed8 2862 	mov	0x2862 <__io__+0x62>, X
	PWM4_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase W */
    911e:	5ed8 286c 	mov	0x286c <__io__+0x6c>, X
	PWM5_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase T */
    9122:	5ed8 2876 	mov	0x2876 <__io__+0x76>, X
	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    9126:	5ed8 284e 	mov	0x284e <__io__+0x4e>, X
	DRVCFG_DIS();																/* MMP140903-1 */
    912a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    912e:	a6da 0100 	or	A, #256
    9132:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_CMP = u16Pwm2Storage;													/* MMP150219-2: Restore PWM2 ADC trigger CMP time */
    9136:	7209      	lod	A, [S-10]
    9138:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
    913c:	5425      	ret	#38

0000913e <_MotorDriverCurrentMeasureInit>:
 * Performance: <10us
 * ****************************************************************************	*/
void MotorDriverCurrentMeasureInit( void)
{
	uint16 u16Count;															/* MMP140331-2 - Begin */
	l_u16StartupDelayInit = 64 * NVRAM_ACCELERATION_POINTS;						/* Calculate the startup-delay, based on acceleration steps */
    913e:	61a4      	lod	AL, dp:0xa4 <_g_NvramUser+0x4a>
    9140:	b43f      	and	A, #63
    9142:	487a 0040 	muls	Y, A, #64
    9146:	5ad8 013a 	mov	0x13a <_l_u16StartupDelayInit>, Y
	if ( l_u16StartupDelayInit < (2*C_MOVAVG_SZ) )
    914a:	ec7f      	cmp	Y, #127
    914c:	1e03      	jug	0x9154 <_MotorDriverCurrentMeasureInit+0x16>
	{
		l_u16StartupDelayInit = (2*C_MOVAVG_SZ);								/* Minimum of twice the moving-average filter size */
    914e:	72da 0080 	lod	A, #128
    9152:	0007      	jmp	0x9162 <_MotorDriverCurrentMeasureInit+0x24>
	}
	else if ( l_u16StartupDelayInit > NVRAM_STALL_DETECTOR_DELAY )
    9154:	61c6      	lod	AL, dp:0xc6 <__bss_dp_size+0x16>
    9156:	44a2      	asl	A, #2
    9158:	4422      	asl	A
    915a:	b6da 07f8 	and	A, #2040
    915e:	eee2      	cmp	Y, A
    9160:	1a02      	jule	0x9166 <_MotorDriverCurrentMeasureInit+0x28>
	{
		l_u16StartupDelayInit = NVRAM_STALL_DETECTOR_DELAY;						/* Maximum of NVRAM specified */
    9162:	52d8 013a 	mov	0x13a <_l_u16StartupDelayInit>, A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    9166:	72e3      	lod	A, M
	}																			/* MMP140331-2 - End */

	ATOMIC_CODE
    9168:	4407      	mov	R, #0
    916a:	500c      	call	fp0:0x60
    916c:	54f0      	mov	UPr, #0
    916e:	7ad8 013a 	lod	Y, 0x13a <_l_u16StartupDelayInit>
    9172:	5938      	mov	dp:0x38 <_g_u16StartupDelay>, Y
    9174:	7800      	lod	Y, #0
    9176:	5958      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, Y
    9178:	5ad8 0294 	mov	0x294 <_l_u16MotorCurrentRawIdx>, Y
    917c:	5956      	mov	dp:0x56 <__data_size>, Y
    917e:	5ad8 0296 	mov	0x296 <_l_au16MotorCurrentRaw>, Y
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    9182:	52e3      	mov	M, A
		l_u16MotorCurrentRawIdx = 0;											/* Raw current moving average index */
		g_u16MotorCurrentMovAvgxN = 0;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
    9184:	7ada 0298 	lod	Y, #664
    9188:	7c3f      	lod	X, #63
		for ( u16Count = 1; u16Count < C_MOVAVG_SZ; u16Count++ )
		{
			*pStallCurrentRaw = 0;
    918a:	7000      	lod	A, #0
    918c:	52d6      	mov	[Y++], A
    918e:	1bfd      	djnz	X, 0x918a <_MotorDriverCurrentMeasureInit+0x4c>
		g_u16MotorCurrentMovAvgxN = 0;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
		for ( u16Count = 1; u16Count < C_MOVAVG_SZ; u16Count++ )
    9190:	5401      	ret

00009192 <_MotorDriverCurrentMeasure>:
 *
 * Measure a average motor current, based on ADC current's
 * Performance: Approximate: 10us @ 20MHz
 * ****************************************************************************	*/
void MotorDriverCurrentMeasure( void)
{
    9192:	5803      	inc	S, #4
#if (C_MOVAVG_SSZ < 6)
	uint16 u16MotorCurrentAcc;
#endif /* (C_MOVAVG_SSZ < 6 ) */
	uint16 u16MicroStepMotorCurrent = GetRawMotorDriverCurrent();
    9194:	82db 897a 	callf	0x897a <_GetRawMotorDriverCurrent>
    9198:	7ee2      	lod	X, A
	//SpiDebugWriteFirst(g_u16HallMicroStepIdx);
	//SpiDebugWriteNext(u16MicroStepMotorCurrent);
#endif /* _DEBUG_SPI */

	/* Moving average (sum) of motor-driver current */
	uint16 *pu16MotorCurrentElement = &l_au16MotorCurrentRaw[l_u16MotorCurrentRawIdx];
    919a:	72d8 0294 	lod	A, 0x294 <_l_u16MotorCurrentRawIdx>
    919e:	487a 0002 	muls	Y, A, #2
    91a2:	e2da 0296 	add	Y, #662
    91a6:	5a03      	mov	[S-4], Y
	uint16 u16PrevMotorCurrent = *pu16MotorCurrentElement;
    91a8:	7af0      	lod	Y, [Y]
    91aa:	5a01      	mov	[S-2], Y
	l_u16MotorCurrentRawIdx = (l_u16MotorCurrentRawIdx + 1) & (C_MOVAVG_SZ - 1);
    91ac:	a001      	add	A, #1
    91ae:	b43f      	and	A, #63
    91b0:	52d8 0294 	mov	0x294 <_l_u16MotorCurrentRawIdx>, A
	if ( (g_u16StartupDelay != 0) || (u16MicroStepMotorCurrent < (u16PrevMotorCurrent << 1)) )	/* Check for valid motor-driver current (at least smaller than 2x previous current)  */
    91b4:	7138      	lod	A, dp:0x38 <_g_u16StartupDelay>
    91b6:	1d04      	jne	0x91c0 <_MotorDriverCurrentMeasure+0x2e>
    91b8:	72e6      	lod	A, Y
    91ba:	4422      	asl	A
    91bc:	2ee2      	cmp	X, A
    91be:	1c06      	jnc	0x91cc <_MotorDriverCurrentMeasure+0x3a>
	{
		g_u16MotorCurrentMovAvgxN -= u16PrevMotorCurrent;						/* Subtract oldest raw motor-driver current */
    91c0:	7156      	lod	A, dp:0x56 <__data_size>
    91c2:	aa01      	sub	A, [S-2]
		g_u16MotorCurrentMovAvgxN += u16MicroStepMotorCurrent;					/* Add newest raw motor-driver current */
    91c4:	a2ee      	add	A, X
    91c6:	5156      	mov	dp:0x56 <__data_size>, A
		*pu16MotorCurrentElement = u16MicroStepMotorCurrent;					/* Overwrite oldest with newest motor-driver current */
    91c8:	7a03      	lod	Y, [S-4]
    91ca:	5ef0      	mov	[Y], X
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2*C_MOVAVG_SZ))) || (g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || ((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (u16MotorCurrentAcc < g_u16MotorCurrentLPFx64)) )
	{
		g_u16MotorCurrentLPFx64 = u16MotorCurrentAcc;
#endif /* (C_MOVAVG_SSZ < 6 ) */
#if (C_MOVAVG_SSZ == 6 )
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2*C_MOVAVG_SZ))) || (g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || ((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (g_u16MotorCurrentMovAvgxN < g_u16MotorCurrentLPFx64)) )
    91cc:	72d8 013a 	lod	A, 0x13a <_l_u16StartupDelayInit>
    91d0:	a080      	add	A, #-128
    91d2:	ad38      	cmp	A, dp:0x38 <_g_u16StartupDelay>
    91d4:	1809      	jc	0x91e8 <_MotorDriverCurrentMeasure+0x56>
    91d6:	62d8 013f 	lod	AL, 0x13f <_g_u8MotorStartupMode>
    91da:	8c02      	cmp	AL, #2
    91dc:	1905      	je	0x91e8 <_MotorDriverCurrentMeasure+0x56>
    91de:	8c01      	cmp	AL, #1
    91e0:	1d05      	jne	0x91ec <_MotorDriverCurrentMeasure+0x5a>
    91e2:	7156      	lod	A, dp:0x56 <__data_size>
    91e4:	ad58      	cmp	A, dp:0x58 <_g_u16MotorCurrentLPFx64>
    91e6:	1c02      	jnc	0x91ec <_MotorDriverCurrentMeasure+0x5a>
	{
		g_u16MotorCurrentLPFx64 = g_u16MotorCurrentMovAvgxN;
    91e8:	7156      	lod	A, dp:0x56 <__data_size>
    91ea:	000c      	jmp	0x9204 <_MotorDriverCurrentMeasure+0x72>
#if (MOTOR_MICROSTEPS < 3)
		/* LPF_B: IIR of 0.9921875 (127/128) & 0.0078125 (1/128) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63) >> 7)) + ((g_u16MotorCurrentMovAvgxN + (1 << C_MOVAVG_SSZ)) >> (1 + C_MOVAVG_SSZ));
#else  /* (MOTOR_MICROSTEPS < 3) */
		/* LPF_B: IIR of 0.99609375 (255/256) & 0.00390625 (1/256) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63) >> 8)) + ((g_u16MotorCurrentMovAvgxN + (1 << (1 + C_MOVAVG_SSZ))) >> (2 + C_MOVAVG_SSZ));
    91ec:	7158      	lod	A, dp:0x58 <_g_u16MotorCurrentLPFx64>
    91ee:	7ae2      	lod	Y, A
    91f0:	e03f      	add	Y, #63
    91f2:	6400      	lod	YL, #0
    91f4:	7ae8      	swap	Y
    91f6:	aae6      	sub	A, Y
    91f8:	7956      	lod	Y, dp:0x56 <__data_size>
    91fa:	e2da 0080 	add	Y, #128
    91fe:	6400      	lod	YL, #0
    9200:	7ae8      	swap	Y
    9202:	a2e6      	add	A, Y
    9204:	5158      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, A
#endif /* (MOTOR_MICROSTEPS < 3) */
	}

	if ( g_u16StartupDelay > 0 )
    9206:	7138      	lod	A, dp:0x38 <_g_u16StartupDelay>
    9208:	1902      	je	0x920e <_MotorDriverCurrentMeasure+0x7c>
	{
		g_u16StartupDelay--;
    920a:	a0ff      	add	A, #-1
    920c:	5138      	mov	dp:0x38 <_g_u16StartupDelay>, A
    920e:	5405      	ret	#6

00009210 <_MotorDriver_InitialPwmDutyCycle>:
 * MotorDriver_InitialPwmDutyCycle()
 *
 * Calculate Motor PWM (initial) Duty-cycle, based on current threshold level and speed
 * ****************************************************************************	*/
void MotorDriver_InitialPwmDutyCycle( uint16 u16CurrentLevel, uint16 u16MotorSpeed)
{
    9210:	5807      	inc	S, #8
    9212:	7ae2      	lod	Y, A
    9214:	7e0b      	lod	X, [S-12]
    9216:	61a7      	lod	AL, dp:0xa7 <_g_NvramUser+0x4d>
    9218:	4205      	mov	[S-6], AL
    921a:	618b      	lod	AL, dp:0x8b <_g_NvramUser+0x31>
    921c:	4207      	mov	[S-8], AL
	if ( u16MotorSpeed == 0 )														/* MMP140228-1 - Begin */
    921e:	2c00      	cmp	X, #0
    9220:	1d08      	jne	0x9232 <_MotorDriver_InitialPwmDutyCycle+0x22>
	{
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + 2 * C_FETS_RTOT) * u16CurrentLevel);
    9222:	6205      	lod	AL, [S-6]
    9224:	5cf2      	usex	A
    9226:	a002      	add	A, #2
    9228:	4871      	muls	A, A, Y
    922a:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 4;
    922c:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    922e:	44b2      	lsr	A, #2
    9230:	0013      	jmp	0x9258 <_MotorDriver_InitialPwmDutyCycle+0x48>
	}																				/* MMP140228-1 - End */
	else
	{
		/* Ohmic losses: Ur-losses = (0.5 * R[ohm] * I[mA])/10 [10mV] = (R[ohm] * I[mA])/20 [10mV]
		 * FET losses: Ufet-losses = (Rfet * I[mA])/10 [10mV] = (2 * Rfet * I[mA])/20 [10mV]*/
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2 * C_FETS_RTOT)) * u16CurrentLevel);
    9232:	6205      	lod	AL, [S-6]
    9234:	5cf2      	usex	A
    9236:	a002      	add	A, #2
    9238:	4871      	muls	A, A, Y
    923a:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 20;													/* Divided by 20 */
    923c:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    923e:	4822 cccd 	mulu	YA, A, #52429
    9242:	72e6      	lod	A, Y
    9244:	44b2      	lsr	A, #2
    9246:	44b2      	lsr	A, #2
    9248:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio += (NVRAM_MOTOR_CONSTANT * u16MotorSpeed);				/* BEMF = Kmotor[10mV/RPS] * Speed[RPS] */
    924a:	61a6      	lod	AL, dp:0xa6 <_g_NvramUser+0x4c>
    924c:	66e0      	lod	YL, AL
    924e:	5cf6      	usex	Y
    9250:	72e6      	lod	A, Y
    9252:	487b      	muls	Y, A, X
    9254:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    9256:	a2e6      	add	A, Y
    9258:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    925a:	794e      	lod	Y, dp:0x4e <_g_u16CorrectionRatio>
    925c:	44a6      	asl	Y, #2
    925e:	4426      	asl	Y
    9260:	6207      	lod	AL, [S-8]
    9262:	5cf2      	usex	A
    9264:	4872 0019 	muls	A, A, #25
    9268:	4432      	lsr	A
    926a:	5205      	mov	[S-6], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    926c:	72da 0aec 	lod	A, #2796
    9270:	7e05      	lod	X, [S-6]
    9272:	4821      	mulu	YA, A, Y
    9274:	4c63      	divu	YA, X
    9276:	4c63      	divu	YA, X
    9278:	5203      	mov	[S-4], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    927a:	52d8 0320 	mov	0x320 <_g_u16PidCtrlRatio>, A
	}
	g_u16PidCtrlRatio =  muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1 + PWM_PRESCALER_N), NVRAM_VSUP_REF);
	g_u16PID_I = g_u16PidCtrlRatio;
    927e:	51ca      	mov	dp:0xca <_g_u16PID_I>, A
	if ( g_i16MotorVoltage > 0 )
    9280:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    9282:	ac00      	cmp	A, #0
    9284:	1b0b      	jsle	0x929c <_MotorDriver_InitialPwmDutyCycle+0x8c>
    9286:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    9288:	44a2      	asl	A, #2
    928a:	4422      	asl	A
    928c:	7d20      	lod	X, dp:0x20 <_g_i16MotorVoltage>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    928e:	7ada 0aec 	lod	Y, #2796
    9292:	4821      	mulu	YA, A, Y
    9294:	4c63      	divu	YA, X
    9296:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9298:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
    929a:	0002      	jmp	0x92a0 <_MotorDriver_InitialPwmDutyCycle+0x90>
	{
		g_u16CorrectionRatio = muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1 + PWM_PRESCALER_N), (uint16) g_i16MotorVoltage);
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    929c:	7e03      	lod	X, [S-4]
    929e:	5d4e      	mov	dp:0x4e <_g_u16CorrectionRatio>, X
	}
	g_i16PID_D = 0;
    92a0:	7000      	lod	A, #0
    92a2:	52d8 014a 	mov	0x14a <_g_i16PID_D>, A
	g_i16PID_E = 0;
    92a6:	52d8 0148 	mov	0x148 <_g_i16PID_E>, A
	g_u16PID_CtrlCounter = 0;													/* Re-start Current-control PID */
    92aa:	52d8 0146 	mov	0x146 <_g_u16PID_CtrlCounter>, A
    92ae:	5409      	ret	#10

000092b0 <_MotorDriver_4PhaseStepper>:
 * Performance: 13.5us @ 28MHz (BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
 *
 * Based on a 32-step c_ai16MicroStepVector4PH-table!!
 * ****************************************************************************	*/
void MotorDriver_4PhaseStepper( void)
{
    92b0:	5805      	inc	S, #6
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) */

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND)					/* MMP150515-1 */
	/* EMC CE/RE reduction */
	int16 iPwm1, iPwm2;
	int16 *pi16Vector = (int16 *) &c_ai16MicroStepVector4PH[g_u16MicroStepIdx];
    92b2:	7150      	lod	A, dp:0x50 <_g_u16MicroStepIdx>
    92b4:	5203      	mov	[S-4], A
    92b6:	487a 0002 	muls	Y, A, #2
    92ba:	7ee6      	lod	X, Y
    92bc:	22da a46c 	add	X, #42092
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    92c0:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    92c2:	7af8      	lod	Y, [X]
    92c4:	4831      	muls	YA, A, Y
    92c6:	48b3      	asr	YA, #4
    92c8:	5a01      	mov	[S-2], Y
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    92ca:	5a05      	mov	[S-6], Y
	iPwm1 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	iPwm2 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
#elif (PWM_PRESCALER_N == 0)
	iPwm1 = mulI16_I16byI16Shft4( *pi16Vector, (int16) g_u16CorrectionRatio);	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
    92cc:	2020      	add	X, #32
    92ce:	7af8      	lod	Y, [X]
    92d0:	714e      	lod	A, dp:0x4e <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    92d2:	4831      	muls	YA, A, Y
    92d4:	48b3      	asr	YA, #4
#else
	i16PwmU = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	i16PwmV = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* V */
#endif
	if ( g_u16MicroStepIdx & (2*C_MICROSTEP_PER_FULLSTEP) )
    92d6:	7203      	lod	A, [S-4]
    92d8:	b420      	and	A, #32
    92da:	1913      	je	0x9302 <_MotorDriver_4PhaseStepper+0x52>
	{
		/* 3rd and 4th Quadrant (Pwm1) */
		iPwm1 = (PWM_SCALE_OFFSET + iPwm1);
    92dc:	7205      	lod	A, [S-6]
    92de:	a2da 02bb 	add	A, #699
    92e2:	5205      	mov	[S-6], A
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = PWM */
		PWM4_LT = (uint16) iPwm1;
    92e4:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM4_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    92e8:	72da 0576 	lod	A, #1398
    92ec:	aa05      	sub	A, [S-6]
    92ee:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM3_LT = (uint16) iPwm1;
		PWM3_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */

		/* W = LOW */
		PWM2_HT = 0;
    92f2:	7000      	lod	A, #0
    92f4:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM2_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */;
    92f8:	72da 0577 	lod	A, #1399
    92fc:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
    9300:	0012      	jmp	0x9326 <_MotorDriver_4PhaseStepper+0x76>
	}
	else
	{
		/* 1st and 2nd Quadrant (Pwm1)*/
		/* W = PWM */
		iPwm1 = ((int16) PWM_SCALE_OFFSET - iPwm1);
    9302:	72da 02bb 	lod	A, #699
    9306:	aa01      	sub	A, [S-2]
    9308:	5205      	mov	[S-6], A
		PWM2_LT = (uint16) iPwm1;
    930a:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
		PWM2_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    930e:	72da 0576 	lod	A, #1398
    9312:	aa05      	sub	A, [S-6]
    9314:	52d8 285a 	mov	0x285a <__io__+0x5a>, A

#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = LOW */
		PWM4_HT = 0;
    9318:	7000      	lod	A, #0
    931a:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM4_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
    931e:	72da 0577 	lod	A, #1399
    9322:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM3_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}

	{
		uint16 u16Quad = g_u16MicroStepIdx & (3*C_MICROSTEP_PER_FULLSTEP);
    9326:	7150      	lod	A, dp:0x50 <_g_u16MicroStepIdx>
    9328:	b430      	and	A, #48
		if ( (u16Quad == 0) || (u16Quad == (3*C_MICROSTEP_PER_FULLSTEP)) )
    932a:	1902      	je	0x9330 <_MotorDriver_4PhaseStepper+0x80>
    932c:	ac30      	cmp	A, #48
    932e:	1d0f      	jne	0x934e <_MotorDriver_4PhaseStepper+0x9e>
		{
			/* 1st and 4th Quadrant (Pwm2) */
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* T = PWM */
			PWM5_HT = (uint16) iPwm2;
    9330:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    9334:	72da 0576 	lod	A, #1398
    9338:	aae6      	sub	A, Y
    933a:	52d8 2876 	mov	0x2876 <__io__+0x76>, A

			/* V = LOW */
			PWM3_HT = 0;
    933e:	7800      	lod	Y, #0
    9340:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = PWM_REG_PERIOD + 1;										/* MMP150603-1 */
    9344:	72da 0577 	lod	A, #1399
    9348:	52d8 2862 	mov	0x2862 <__io__+0x62>, A
    934c:	000f      	jmp	0x936c <_MotorDriver_4PhaseStepper+0xbc>
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
		}
		else
		{
			/* 3rd Quadrant (Pwm2) */
			iPwm2 = (0 - iPwm2);
    934e:	5cc6      	neg	Y
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* V = PWM */
			PWM3_HT = (uint16) iPwm2;
    9350:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    9354:	72da 0576 	lod	A, #1398
    9358:	aae6      	sub	A, Y
    935a:	52d8 2862 	mov	0x2862 <__io__+0x62>, A

			/* T = LOW */
			PWM5_HT = 0;
    935e:	7800      	lod	Y, #0
    9360:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = PWM_REG_PERIOD + 1;										/* MMP150603-1 */
    9364:	72da 0577 	lod	A, #1399
    9368:	52d8 2876 	mov	0x2876 <__io__+0x76>, A
		PWM4_LT = (uint16) (0 - iPwm);						/* U = PWM */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */

	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    936c:	7ada 02bb 	lod	Y, #699
    9370:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
    9374:	5407      	ret	#8

00009376 <_MotorDriverStart>:
 * MotorDriverStart()
 *
 * Start Motor Driver
 * ****************************************************************************	*/
void MotorDriverStart( void)
{
    9376:	5801      	inc	S, #2
	if ( g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM )						/* Don't start motor in case of permanent electric failure */
    9378:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    937a:	8c02      	cmp	AL, #2
    937c:	1d01      	jne	0x9380 <_MotorDriverStart+0xa>
    937e:	009a      	jmp	0x94b4 <_MotorDriverStart+0x13e>
	}

#if USE_MULTI_PURPOSE_BUFFER
	/* Fill multi-purpose buffer with acceleration-data */
	{
		l_u16SpeedRPM = NVRAM_MIN_SPEED;
    9380:	71a0      	lod	A, dp:0xa0 <_g_NvramUser+0x46>
    9382:	52d8 0316 	mov	0x316 <_l_u16SpeedRPM>, A
		l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    9386:	72d8 0270 	lod	A, 0x270 <_g_u16MotorMicroStepsPerMechRotation>
    938a:	52df      	push	A
    938c:	4ce2 2c40 	mov	YA, #105000000
    9390:	0642 
    9392:	82db 6c3a 	callf	0x6c3a <_divU32_U32byU16>
    9396:	52d8 0318 	mov	0x318 <_l_u32Temp>, A
    939a:	5ad8 031a 	mov	0x31a <_l_u32Temp+0x2>, Y
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    939e:	5c01      	dec	S, #2
    93a0:	7ed8 0316 	lod	X, 0x316 <_l_u16SpeedRPM>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    93a4:	4c63      	divu	YA, X
    93a6:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    93a8:	a0ff      	add	A, #-1
    93aa:	52d8 031c 	mov	0x31c <_l_u16LowSpeedPeriod>, A
		l_u16LowSpeedPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;
	}
#endif /* USE_MULTI_PURPOSE_BUFFER */

	if ( g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT )
    93ae:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    93b0:	b402      	and	A, #2
    93b2:	1d01      	jne	0x93b6 <_MotorDriverStart+0x40>
    93b4:	0031      	jmp	0x9418 <_MotorDriverStart+0xa2>
	{
		if ( (g_u16MotorRewindSteps != 0) &&									/* MMP140331-1 */
    93b6:	7ed8 0272 	lod	X, 0x272 <_g_u16MotorRewindSteps>
    93ba:	1925      	je	0x9406 <_MotorDriverStart+0x90>
    93bc:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    93be:	7ae2      	lod	Y, A
    93c0:	f401      	and	Y, #1
    93c2:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    93c4:	4201      	mov	[S-2], AL
    93c6:	5cf2      	usex	A
    93c8:	eee2      	cmp	Y, A
    93ca:	1903      	je	0x93d2 <_MotorDriverStart+0x5c>
    93cc:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    93ce:	b404      	and	A, #4
    93d0:	191a      	je	0x9406 <_MotorDriverStart+0x90>
			(((g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == g_e8MotorDirectionCCW) || (g_u8RewindFlags & C_REWIND_DIRECTION_AUTO)) )
		{
			/* Start rewind-function, with "rewinding" */
			g_u8RewindFlags = (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND);		/* Start rewind-process (MMP140331-1) */
    93d2:	6028      	lod	AL, #40
    93d4:	4124      	mov	dp:0x24 <__data_dp_size>, AL
			g_u16TargetPositionRewind = g_u16TargetPosition;
    93d6:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    93d8:	52d8 0152 	mov	0x152 <__data_end>, A
    93dc:	79f0      	lod	Y, dp:0xf0 <_g_u16ActualPosition>
			if ( g_e8MotorDirectionCCW )
    93de:	6201      	lod	AL, [S-2]
    93e0:	190a      	je	0x93f6 <_MotorDriverStart+0x80>
			{
				if ( g_u16ActualPosition <= (uint16) (C_MAX_POS - g_u16MotorRewindSteps) )
    93e2:	72da 00ff 	lod	A, #255
    93e6:	aaee      	sub	A, X
    93e8:	eee2      	cmp	Y, A
    93ea:	1e14      	jug	0x9414 <_MotorDriverStart+0x9e>
				{
					g_u16TargetPosition = g_u16ActualPosition + g_u16MotorRewindSteps;
    93ec:	72e6      	lod	A, Y
    93ee:	a2ee      	add	A, X
    93f0:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = FALSE;								/* MMP140331-3 */
    93f2:	6000      	lod	AL, #0
    93f4:	0006      	jmp	0x9402 <_MotorDriverStart+0x8c>
					g_u8RewindFlags = 0;										/* No rewind possible */
				}
			}
			else
			{
				if ( g_u16ActualPosition >= g_u16MotorRewindSteps )
    93f6:	eeee      	cmp	Y, X
    93f8:	180d      	jc	0x9414 <_MotorDriverStart+0x9e>
				{
					g_u16TargetPosition = g_u16ActualPosition - g_u16MotorRewindSteps;
    93fa:	72e6      	lod	A, Y
    93fc:	aaee      	sub	A, X
    93fe:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = TRUE;								/* MMP140331-3 */
    9400:	6001      	lod	AL, #1
    9402:	412a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, AL
    9404:	0009      	jmp	0x9418 <_MotorDriverStart+0xa2>
				{
					g_u8RewindFlags = 0;										/* No rewind possible */
				}
			}
		}
		else if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != g_e8MotorDirectionCCW ) /* MMP140331-1 - Begin */
    9406:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    9408:	7ae2      	lod	Y, A
    940a:	f401      	and	Y, #1
    940c:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    940e:	5cf2      	usex	A
    9410:	eee2      	cmp	Y, A
    9412:	1902      	je	0x9418 <_MotorDriverStart+0xa2>
		{
			g_u8RewindFlags = 0;												/* Clear previous detected stall flags */
    9414:	6000      	lod	AL, #0
    9416:	4124      	mov	dp:0x24 <__data_dp_size>, AL
		}																		/* MMP140331-1 - End */
	}

	g_u16ActuatorActPos = g_u16ActualPosition;
    9418:	71f0      	lod	A, dp:0xf0 <_g_u16ActualPosition>
    941a:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = g_u16TargetPosition;
    941c:	71f2      	lod	A, dp:0xf2 <_g_u16TargetPosition>
    941e:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
	//g_u8StallOcc = FALSE; TODO,Ban
	//g_u8MechError = FALSE;

	/* Clear motor-driver current measurement */
	MotorDriverCurrentMeasureInit();
    9420:	168e      	call	0x913e <_MotorDriverCurrentMeasureInit>
#if _DEBUG_MOTOR_CURRENT_FLT
	l_u16MotorCurrIdx = 0;
#endif /* _DEBUG_MOTOR_CURRENT_FLT */

	g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;								/* Start-up in Acceleration stepper mode */
    9422:	6001      	lod	AL, #1
    9424:	42d8 013f 	mov	0x13f <_g_u8MotorStartupMode>, AL
	/* (MMP140331-2) g_u16StartupDelay = NVRAM_STALL_DETECTOR_DELAY; */
	MotorStallInitA();
    9428:	1288      	call	0x993a <_MotorStallInitA>
#endif /* _SUPPORT_STALLDET_H */

#if _DEBUG_VOLTAGE_COMPENSATION
	u16MotorVoltIdx = 0;
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	l_u16CoilZeroCurrCountA = 0;
    942a:	7000      	lod	A, #0
    942c:	52d8 0138 	mov	0x138 <_l_u16CoilZeroCurrCountA>, A
	l_u16CoilZeroCurrCountB = 0;
    9430:	52d8 0136 	mov	0x136 <_l_u16CoilZeroCurrCountB>, A
	l_u16CoilCurrentStartDelay = C_COIL_CURRENT_START_DELAY;
    9434:	72da 0080 	lod	A, #128
    9438:	52d8 0134 	mov	0x134 <_l_u16CoilCurrentStartDelay>, A

	/* Connect drivers */
	/* Stepper 4-phase/32-steps */

	{
		MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_au16MotorSpeedRPS[1]);	/* MMP140822-1 - Begin */
    943c:	72d8 0286 	lod	A, 0x286 <_g_au16MotorSpeedRPS+0x2>
    9440:	52df      	push	A
    9442:	72d8 0322 	lod	A, 0x322 <_g_u16PidRunningThreshold>
    9446:	16e4      	call	0x9210 <_MotorDriver_InitialPwmDutyCycle>
	}
	MotorDriver_4PhaseStepper();
    9448:	1733      	call	0x92b0 <_MotorDriver_4PhaseStepper>
#if (_SUPPORT_PWM_DC_RAMPUP == FALSE)											/* MMP140903-2 - Begin */
	if ( g_u16MotorSpeedRPS > g_au16MotorSpeedRPS[1] )
    944a:	72d8 026c 	lod	A, 0x26c <_g_u16MotorSpeedRPS>
    944e:	5c01      	dec	S, #2
    9450:	aed8 0286 	cmp	A, 0x286 <_g_au16MotorSpeedRPS+0x2>
    9454:	1a05      	jule	0x9460 <_MotorDriverStart+0xea>
	{
		MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_u16MotorSpeedRPS);
    9456:	52df      	push	A
    9458:	72d8 0322 	lod	A, 0x322 <_g_u16PidRunningThreshold>
    945c:	16d9      	call	0x9210 <_MotorDriver_InitialPwmDutyCycle>
    945e:	5c01      	dec	S, #2
	}																			/* MMP140822-1 - End */
#endif /* (_SUPPORT_PWM_DC_RAMPUP == FALSE) */									/* MMP140903-2 - End */
	DRVCFG_PWM_UVWT();															/* Enable the driver and the PWM phase W, V, U and T */
    9460:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9464:	b6da fe00 	and	A, #65024
    9468:	a455      	or	A, #85
    946a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	g_u8MotorHoldingCurrState = FALSE;
    946e:	6000      	lod	AL, #0
    9470:	42d8 013e 	mov	0x13e <_g_u8MotorHoldingCurrState>, AL

	/* Setup ADC for Motor Current/Voltage measurements */
#if _SUPPORT_PHASE_SHORT_DET
	ADC_Start( 0);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_Start();
    9474:	82db 881c 	callf	0x881c <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */

	l_u8VTIdx = 0;
    9478:	6000      	lod	AL, #0
    947a:	4136      	mov	dp:0x36 <_l_u8VTIdx>, AL
	if ( g_u8MotorStartupMode == (uint8) MSM_STEPPER_A )
    947c:	62d8 013f 	lod	AL, 0x13f <_g_u8MotorStartupMode>
    9480:	8c01      	cmp	AL, #1
    9482:	1d08      	jne	0x9494 <_MotorDriverStart+0x11e>
	{
		if ( g_u16TargetCommutTimerPeriod < l_u16LowSpeedPeriod )
    9484:	7954      	lod	Y, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    9486:	72d8 031c 	lod	A, 0x31c <_l_u16LowSpeedPeriod>
    948a:	eee2      	cmp	Y, A
    948c:	1c02      	jnc	0x9492 <_MotorDriverStart+0x11c>
		{
			/* Target speed too fast for motor to start-up with */
			g_u16CommutTimerPeriod = l_u16LowSpeedPeriod;						/* Initial start-up speed */
    948e:	5152      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, A
    9490:	0001      	jmp	0x9494 <_MotorDriverStart+0x11e>
		}
		else
		{
			/* Target speed is slower than maximum motor start-up speed */
			g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9492:	5952      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, Y
		}
	}
	TMR1_REGB = g_u16CommutTimerPeriod;
    9494:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    9496:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;									/* Start Timer mode 0 */
    9498:	72da 4003 	lod	A, #16387
    949c:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_RUNNING;
    949e:	6001      	lod	AL, #1
    94a0:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
	g_u8MotorStopDelay = 0;
    94a2:	6000      	lod	AL, #0
    94a4:	4137      	mov	dp:0x37 <_g_u8MotorStopDelay>, AL

	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) C_REWIND_ACTIVE )
    94a6:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    94a8:	b428      	and	A, #40
    94aa:	ac08      	cmp	A, #8
    94ac:	1d03      	jne	0x94b4 <_MotorDriverStart+0x13e>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_ACTIVE;							/* Rewind-function is finished */
    94ae:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    94b0:	94f7      	and	AL, #-9
    94b2:	4124      	mov	dp:0x24 <__data_dp_size>, AL
    94b4:	5403      	ret	#4

000094b6 <_MotorDriverStop>:
 *						C_STOP_EMERGENCY : Immediate stop (without ramp-down) + delay
 *
 * Stop Motor Driver
 * ****************************************************************************	*/
void MotorDriverStop( uint16 u16Immediate)
{
    94b6:	5803      	inc	S, #4
    94b8:	5203      	mov	[S-4], A
	if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) != (uint8) C_MOTOR_STATUS_STOP )
    94ba:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    94bc:	b47f      	and	A, #127
    94be:	1d01      	jne	0x94c2 <_MotorDriverStop+0xc>
    94c0:	0045      	jmp	0x954c <_MotorDriverStop+0x96>
	{
		/* Not STOP status */
		if ( (u16Immediate == (uint16) C_STOP_RAMPDOWN) && (l_u8VTIdx > 1) ) /*lint !e845 */	/* MMP150922-1 */
    94c2:	7203      	lod	A, [S-4]
    94c4:	1901      	je	0x94c8 <_MotorDriverStop+0x12>
    94c6:	0034      	jmp	0x9530 <_MotorDriverStop+0x7a>
    94c8:	6136      	lod	AL, dp:0x36 <_l_u8VTIdx>
    94ca:	4201      	mov	[S-2], AL
    94cc:	8c01      	cmp	AL, #1
    94ce:	1e01      	jug	0x94d2 <_MotorDriverStop+0x1c>
    94d0:	003a      	jmp	0x9546 <_MotorDriverStop+0x90>
		{
			TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;							/* Start timer mode 0 */
    94d2:	72da 4003 	lod	A, #16387
    94d6:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A

			/* Request to ramp-down */
			if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOPPING )
    94d8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    94da:	b47f      	and	A, #127
    94dc:	ac09      	cmp	A, #9
    94de:	1d02      	jne	0x94e4 <_MotorDriverStop+0x2e>
			{
				/* Already stopping */
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;					/* Motor status change to STOP soon */
    94e0:	6014      	lod	AL, #20
    94e2:	0023      	jmp	0x952a <_MotorDriverStop+0x74>
				return;
			}

			/* Set TargetPos near CurrentPos, including ramp-down */
			{
				if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    94e4:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    94e6:	79fa      	lod	Y, dp:0xfa <_g_u16ActuatorTgtPos>
    94e8:	aee6      	cmp	A, Y
    94ea:	1a0d      	jule	0x9506 <_MotorDriverStop+0x50>
				{
					uint32 u32DeltaPos = g_u16ActuatorActPos - g_u16ActuatorTgtPos;
    94ec:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    94ee:	aae6      	sub	A, Y
    94f0:	4cc8      	movu	D, A
					if ( u32DeltaPos > l_u8VTIdx )
    94f2:	6201      	lod	AL, [S-2]
    94f4:	5cf2      	usex	A
    94f6:	4cf2      	usex	YA
    94f8:	4c90      	cmp	D, YA
    94fa:	1a12      	jule	0x9520 <_MotorDriverStop+0x6a>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos - l_u8VTIdx;
    94fc:	6601      	lod	YL, [S-2]
    94fe:	5cf6      	usex	Y
    9500:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    9502:	aae6      	sub	A, Y
    9504:	000c      	jmp	0x951e <_MotorDriverStop+0x68>
					}
				}
				else
				{
					uint32 u32DeltaPos = g_u16ActuatorTgtPos - g_u16ActuatorActPos;
    9506:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    9508:	eae2      	sub	Y, A
    950a:	4cc9      	movu	D, Y
					if ( u32DeltaPos > l_u8VTIdx )
    950c:	6201      	lod	AL, [S-2]
    950e:	5cf2      	usex	A
    9510:	4cf2      	usex	YA
    9512:	4c90      	cmp	D, YA
    9514:	1a05      	jule	0x9520 <_MotorDriverStop+0x6a>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos + l_u8VTIdx;
    9516:	6601      	lod	YL, [S-2]
    9518:	5cf6      	usex	Y
    951a:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    951c:	a2e6      	add	A, Y
    951e:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
					}
				}
			}

			g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOPPING);
    9520:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    9522:	9480      	and	AL, #-128
    9524:	8409      	or	AL, #9
    9526:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;						/* Motor status change to STOP when ramp-down is finished */
    9528:	6028      	lod	AL, #40
    952a:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
			return;
    952e:	5405      	ret	#6
		}
		else if ( u16Immediate == (uint16) C_STOP_EMERGENCY )
    9530:	7203      	lod	A, [S-4]
    9532:	ac02      	cmp	A, #2
    9534:	1d08      	jne	0x9546 <_MotorDriverStop+0x90>
		{
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;						/* Wait 10 (up to 20 ms) before continue */
    9536:	6014      	lod	AL, #20
    9538:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
			if ( g_u8MotorStatusSpeed > (uint8) C_MOTOR_SPEED_MID )
    953c:	611e      	lod	AL, dp:0x1e <__ramfunc_size>
    953e:	8c03      	cmp	AL, #3
    9540:	1a05      	jule	0x954c <_MotorDriverStop+0x96>
			{
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;
    9542:	6028      	lod	AL, #40
    9544:	0001      	jmp	0x9548 <_MotorDriverStop+0x92>
			}
		}
		else
		{
			g_u8MotorStartDelay = 0;
    9546:	6000      	lod	AL, #0
    9548:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
		}
	}

	/* Re-stall code */
	if ( (g_u8StallOcc != FALSE) && ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0) )
    954c:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    954e:	1d01      	jne	0x9552 <_MotorDriverStop+0x9c>
    9550:	002d      	jmp	0x95ac <_MotorDriverStop+0xf6>
    9552:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    9554:	b408      	and	A, #8
    9556:	1d2a      	jne	0x95ac <_MotorDriverStop+0xf6>
	{
		/* 'Restore' actual-position in case of re-stall without rewind; MMP140331-4 - Begin */
		if ( (NVRAM_REWIND_STEPS == 0) && ((g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT) != 0) )
    9558:	61c2      	lod	AL, dp:0xc2 <__bss_dp_size+0x12>
    955a:	1d1d      	jne	0x9596 <_MotorDriverStop+0xe0>
    955c:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    955e:	b402      	and	A, #2
    9560:	191a      	je	0x9596 <_MotorDriverStop+0xe0>
		{
			/* Stall detected before (no rewind support) */
			if ( g_e8MotorDirectionCCW )
    9562:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9564:	1908      	je	0x9576 <_MotorDriverStop+0xc0>
			{
				if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != 0 )
    9566:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    9568:	b401      	and	A, #1
    956a:	1915      	je	0x9596 <_MotorDriverStop+0xe0>
				{
					/* Stall in same direction; 'Restore' actual-position */
					g_u16ActuatorActPos += (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET));		/* MMP140428-1 */
    956c:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    956e:	a2d8 013a 	add	A, 0x13a <_l_u16StartupDelayInit>
    9572:	a020      	add	A, #32
    9574:	000f      	jmp	0x9594 <_MotorDriverStop+0xde>
				}
			}
			else
			{
				if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == 0 )
    9576:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    9578:	b401      	and	A, #1
    957a:	1d0d      	jne	0x9596 <_MotorDriverStop+0xe0>
				{
					/* Stall in same direction; 'Restore' actual-position */
					if ( g_u16ActuatorActPos > (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET)) )	/* MMP140428-1 */
    957c:	7ed8 013a 	lod	X, 0x13a <_l_u16StartupDelayInit>
    9580:	7aee      	lod	Y, X
    9582:	e020      	add	Y, #32
    9584:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    9586:	aee6      	cmp	A, Y
    9588:	1a04      	jule	0x9592 <_MotorDriverStop+0xdc>
					{
						g_u16ActuatorActPos -= (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET));	/* MMP140428-1 */
    958a:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    958c:	aaee      	sub	A, X
    958e:	a0e0      	add	A, #-32
    9590:	0001      	jmp	0x9594 <_MotorDriverStop+0xde>
					}
					else
					{
						g_u16ActuatorActPos = 0;
    9592:	7000      	lod	A, #0
    9594:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
				}
			}
		}																		/* MMP140331-4 - End */

		/* Set re-wind active */
		g_u8RewindFlags |= (uint8) C_REWIND_STALL_DETECT;
    9596:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    9598:	8402      	or	AL, #2
    959a:	4124      	mov	dp:0x24 <__data_dp_size>, AL
		if ( g_e8MotorDirectionCCW )
    959c:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    959e:	1903      	je	0x95a6 <_MotorDriverStop+0xf0>
		{
			g_u8RewindFlags |= (uint8) C_REWIND_DIRECTION_CCW;
    95a0:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    95a2:	8401      	or	AL, #1
    95a4:	0002      	jmp	0x95aa <_MotorDriverStop+0xf4>
		}
		else
		{
			g_u8RewindFlags &= (uint8) ~C_REWIND_DIRECTION_CCW;
    95a6:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    95a8:	94fe      	and	AL, #-2
    95aa:	4124      	mov	dp:0x24 <__data_dp_size>, AL
		}
	}

	/* First stop ADC, before stopping motor (trigger-event) */
	ADC_Stop();
    95ac:	82db 87a4 	callf	0x87a4 <_ADC_Stop>
	g_u8MotorStartupMode = (uint8) MSM_STOP;									/* Stop mode */
    95b0:	6000      	lod	AL, #0
    95b2:	42d8 013f 	mov	0x13f <_g_u8MotorStartupMode>, AL
	g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOP);
    95b6:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    95b8:	9480      	and	AL, #-128
    95ba:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
	if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    95bc:	72d8 0338 	lod	A, 0x338 <_bistResetInfo>
    95c0:	aeda 5c92 	cmp	A, #23698
    95c4:	1902      	je	0x95ca <_MotorDriverStop+0x114>
	{
		/* make target-position same as actual position, except in case of WD-reset */
		g_u16ActuatorTgtPos = g_u16ActuatorActPos;							/* Stop: Target = Actual */
    95c6:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    95c8:	51fa      	mov	dp:0xfa <_g_u16ActuatorTgtPos>, A
	}
	g_u16ActualPosition = g_u16ActuatorActPos;
    95ca:	79f8      	lod	Y, dp:0xf8 <_g_u16ActuatorActPos>
    95cc:	59f0      	mov	dp:0xf0 <_g_u16ActualPosition>, Y
	g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_STOP;							/* Stop */
    95ce:	6000      	lod	AL, #0
    95d0:	411e      	mov	dp:0x1e <__ramfunc_size>, AL

#if (LINPROT == LIN2J_VALVE_GM)
	if ( g_e8CalibrationStep == (uint8) C_CALIB_DONE )
    95d2:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    95d4:	8c0a      	cmp	AL, #10
    95d6:	1d16      	jne	0x9604 <_MotorDriverStop+0x14e>
	{
		/* Check for mechanical defect (1 = calculation rounding) */
		if ( (g_u16ActualPosition <= 1) || (g_u16ActualPosition >= ((g_u16CalibTravel + (2*C_PERC_OFFSET)) - 1)) )
    95d8:	ec01      	cmp	Y, #1
    95da:	1a04      	jule	0x95e4 <_MotorDriverStop+0x12e>
    95dc:	71f6      	lod	A, dp:0xf6 <_g_u16CalibTravel>
    95de:	a01f      	add	A, #31
    95e0:	eee2      	cmp	Y, A
    95e2:	1803      	jc	0x95ea <_MotorDriverStop+0x134>
		{
			g_u8MechError = TRUE;
    95e4:	6001      	lod	AL, #1
    95e6:	42d8 0107 	mov	0x107 <_g_u8MechError>, AL
		}

		/* Round actual position */
		if ( g_u16ActualPosition < (C_PERC_OFFSET + C_HALFPERC_OFFSET) )
    95ea:	7df0      	lod	X, dp:0xf0 <_g_u16ActualPosition>
    95ec:	2c10      	cmp	X, #16
    95ee:	1e02      	jug	0x95f4 <_MotorDriverStop+0x13e>
		{
			g_u16ActualPosition = C_PERC_OFFSET;
    95f0:	7010      	lod	A, #16
    95f2:	0007      	jmp	0x9602 <_MotorDriverStop+0x14c>
		}
		else if ( g_u16ActualPosition > ((g_u16CalibTravel + C_PERC_OFFSET) - C_HALFPERC_OFFSET) )
    95f4:	79f6      	lod	Y, dp:0xf6 <_g_u16CalibTravel>
    95f6:	72e6      	lod	A, Y
    95f8:	a00f      	add	A, #15
    95fa:	2ee2      	cmp	X, A
    95fc:	1a03      	jule	0x9604 <_MotorDriverStop+0x14e>
		{
			g_u16ActualPosition = (g_u16CalibTravel + C_PERC_OFFSET);
    95fe:	72e6      	lod	A, Y
    9600:	a010      	add	A, #16
    9602:	51f0      	mov	dp:0xf0 <_g_u16ActualPosition>, A
		}
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */


	if ( (g_u8MotorHoldingCurrEna != FALSE) &&									/* Holding mode enabled */
    9604:	61ef      	lod	AL, dp:0xef <_g_u8MotorHoldingCurrEna>
    9606:	1922      	je	0x964c <_MotorDriverStop+0x196>
    9608:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    960a:	8c02      	cmp	AL, #2
    960c:	191f      	je	0x964c <_MotorDriverStop+0x196>
    960e:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    9610:	1d1d      	jne	0x964c <_MotorDriverStop+0x196>
    9612:	7203      	lod	A, [S-4]
    9614:	ac03      	cmp	A, #3
    9616:	191a      	je	0x964c <_MotorDriverStop+0x196>
		(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && (u16Immediate != (uint16) C_STOP_SLEEP) ) /*lint !e845 */
	{
		/* Keep Motor driver active with a specified amount of current (unless permanent electric error) */
		MotorDriver_InitialPwmDutyCycle( g_u16PidHoldingThreshold, 0);
    9618:	54ca 0000 	pushw	#0
    961c:	72d8 0326 	lod	A, 0x326 <_g_u16PidHoldingThreshold>
    9620:	15f7      	call	0x9210 <_MotorDriver_InitialPwmDutyCycle>
	
		MotorDriver_4PhaseStepper();
    9622:	1646      	call	0x92b0 <_MotorDriver_4PhaseStepper>
		DRVCFG_PWM_UVWT();														/* Enable the driver and the PWM phase W, V and U */
    9624:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9628:	b6da fe00 	and	A, #65024
    962c:	a455      	or	A, #85
    962e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		g_u8MotorHoldingCurrState = TRUE;
    9632:	6001      	lod	AL, #1
    9634:	42d8 013e 	mov	0x13e <_g_u8MotorHoldingCurrState>, AL

		g_u16MotorCurrentLPFx64 = (g_u16PidHoldingThreshold << 6);				/* Low-pass Filtered motor-current (x 64) */
    9638:	72d8 0326 	lod	A, 0x326 <_g_u16PidHoldingThreshold>
    963c:	44a2      	asl	A, #2
    963e:	44a2      	asl	A, #2
    9640:	44a2      	asl	A, #2
    9642:	5158      	mov	dp:0x58 <_g_u16MotorCurrentLPFx64>, A
#if _SUPPORT_PHASE_SHORT_DET
		ADC_Start( 0);															/* Start measuring motor current */
#else  /* _SUPPORT_PHASE_SHORT_DET */
		ADC_Start();
    9644:	82db 881c 	callf	0x881c <_ADC_Start>
    9648:	5c01      	dec	S, #2
    964a:	0025      	jmp	0x9696 <_MotorDriverStop+0x1e0>
#endif /* _SUPPORT_PHASE_SHORT_DET */
	}
	else
	{
		/* Disconnect drivers */
		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM )					/* MMP130919-1 - Begin */
    964c:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    964e:	8c02      	cmp	AL, #2
    9650:	1911      	je	0x9674 <_MotorDriverStop+0x1be>
		{
			if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_YES )				/* MMP150217-1 - Begin */
    9652:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9654:	8c01      	cmp	AL, #1
    9656:	1907      	je	0x9666 <_MotorDriverStop+0x1b0>
			{
				DRVCFG_GND_UVWT();												/* Make Low-side active, for a short time (recycle current) */
    9658:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    965c:	b6da fe00 	and	A, #65024
    9660:	a6da 00aa 	or	A, #170
    9664:	0011      	jmp	0x9688 <_MotorDriverStop+0x1d2>
			}
			else
			{
				DRVCFG_VSUP_UVWT();												/* Make High-side active, for a short time (recycle current) */
    9666:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    966a:	b6da fe00 	and	A, #65024
    966e:	a6da 00ff 	or	A, #255
    9672:	000a      	jmp	0x9688 <_MotorDriverStop+0x1d2>
			}																	/* MMP150217-1 - End */
		}
		else
		{
			/* In case of a permanent error, don't connect drivers anymore */
			DRVCFG_DIS_UVWT();
    9674:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9678:	b6da fe00 	and	A, #65024
    967c:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();														/* MMP140903-1 */
    9680:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9684:	a6da 0100 	or	A, #256
    9688:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}																		/* MMP130919-1 - End */
		g_u8MotorHoldingCurrState = FALSE;
    968c:	6000      	lod	AL, #0
    968e:	42d8 013e 	mov	0x13e <_g_u8MotorHoldingCurrState>, AL

		g_u8MotorStopDelay = 200;												/* 200x 0.5ms = 100ms delay before driver is disconnected */
    9692:	60c8      	lod	AL, #-56
    9694:	4137      	mov	dp:0x37 <_g_u8MotorStopDelay>, AL
	}

	TMR1_CTRL &= ~TMRx_START;													/* Stop "commutation timer" */
    9696:	72aa      	lod	A, io:0x2a <_g_e8MotorDirectionCCW>
    9698:	b4fd      	and	A, #-3
    969a:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially pending) Timer1 second level interrupts (T1_INT4) */
    969c:	7040      	lod	A, #64
    969e:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
	PEND = CLR_EXT0_IT;															/* ... and first level interrupt */
    96a2:	72da 0100 	lod	A, #256
    96a6:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
#if USE_MULTI_PURPOSE_BUFFER
	g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;									/* Motor-stopped: Multi-purpose buffer is free for others */
    96aa:	6000      	lod	AL, #0
    96ac:	42d8 0155 	mov	0x155 <_g_MPBuf+0x1>, AL
#endif /* USE_MULTI_PURPOSE_BUFFER */

	/* Re-stall code */
	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND) )
    96b0:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    96b2:	b428      	and	A, #40
    96b4:	ac28      	cmp	A, #40
    96b6:	1d19      	jne	0x96ea <_MotorDriverStop+0x234>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_REWIND;							/* Rewinding of the Rewind-function is finished */
    96b8:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    96ba:	94df      	and	AL, #-33
    96bc:	4124      	mov	dp:0x24 <__data_dp_size>, AL
		g_u16TargetPosition = g_u16TargetPositionRewind;
    96be:	72d8 0152 	lod	A, 0x152 <__data_end>
    96c2:	51f2      	mov	dp:0xf2 <_g_u16TargetPosition>, A
		g_u8MotorStopDelay = 0;													/* Cancel stop delay */
    96c4:	6000      	lod	AL, #0
    96c6:	4137      	mov	dp:0x37 <_g_u8MotorStopDelay>, AL
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_CALIBRATION )
    96c8:	652e      	lod	YL, dp:0x2e <_g_e8MotorRequest>
    96ca:	62e8      	lod	AL, YL
    96cc:	8c05      	cmp	AL, #5
    96ce:	1d0a      	jne	0x96e4 <_MotorDriverStop+0x22e>
		{
			if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS )
    96d0:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    96d2:	8c03      	cmp	AL, #3
    96d4:	1d03      	jne	0x96dc <_MotorDriverStop+0x226>
				g_e8CalibrationStep = C_CALIB_SETUP_HI_ENDPOS;
    96d6:	6002      	lod	AL, #2
    96d8:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    96da:	5405      	ret	#6
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS )
    96dc:	8c06      	cmp	AL, #6
    96de:	1d09      	jne	0x96f2 <_MotorDriverStop+0x23c>
				g_e8CalibrationStep = C_CALIB_SETUP_LO_ENDPOS;
    96e0:	451d      	mov	dp:0x1d <_g_e8CalibrationStep>, YL
    96e2:	5405      	ret	#6
		}
		else
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    96e4:	6003      	lod	AL, #3
    96e6:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    96e8:	5405      	ret	#6
	}
	else if ( (g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT) == 0 )
    96ea:	6124      	lod	AL, dp:0x24 <__data_dp_size>
    96ec:	b402      	and	A, #2
    96ee:	1d01      	jne	0x96f2 <_MotorDriverStop+0x23c>
	{
		g_u8RewindFlags = 0;													/* Clear all other flags in case no STALL have been detected */
    96f0:	4124      	mov	dp:0x24 <__data_dp_size>, AL
    96f2:	5405      	ret	#6

000096f4 <_EXT0_IT>:
 * The g_u8StallOcc flags can be set in this Commutation_ISR(), but cleared in the MotorDriverStop(),
 * before it is communicated back to the ECU/Master.
 * ****************************************************************************	*/
#define Commutation_ISR	EXT0_IT
__interrupt__ void Commutation_ISR(void)
{
    96f4:	52df      	push	A
    96f6:	5edf      	push	X
    96f8:	5adf      	push	Y
    96fa:	4c83      	push	D
    96fc:	5811      	inc	S, #18
#if (_DEBUG_COMMUT_ISR != FALSE)
	DEBUG_SET_IO_B();
#endif /* (_DEBUG_COMMUT_ISR != FALSE) && (_DEBUG_HALLLATCH_ISR == FALSE) */

	uint16 pending = XI0_PEND & XI0_MASK;										/* Copy interrupt requests which are not masked   */
    96fe:	7ad8 2034 	lod	Y, 0x2034 <__ep__+0x1034>
    9702:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    9706:	f6e2      	and	Y, A
	do
	{
		XI0_PEND = pending;														/* Clear requests which are going to be processed */
    9708:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
	} while (XI0_PEND & pending);
    970c:	72d8 2034 	lod	A, 0x2034 <__ep__+0x1034>
    9710:	b6e6      	and	A, Y
    9712:	1d7a      	jne	0x9708 <_EXT0_IT+0x14>

	if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    9714:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    9716:	b401      	and	A, #1
    9718:	1d01      	jne	0x971c <_EXT0_IT+0x28>
    971a:	0107      	jmp	0x992a <_EXT0_IT+0x236>
	{
		return;		/* Used for CPU wake-up */
	}

	if ( g_e8MotorDirectionCCW )
    971c:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    971e:	1903      	je	0x9726 <_EXT0_IT+0x32>
	{
		g_u16ActuatorActPos--;													/* Closing */
    9720:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    9722:	a0ff      	add	A, #-1
    9724:	0002      	jmp	0x972a <_EXT0_IT+0x36>
	}
	else
	{
		g_u16ActuatorActPos++;													/* Opening */
    9726:	71f8      	lod	A, dp:0xf8 <_g_u16ActuatorActPos>
    9728:	a001      	add	A, #1
    972a:	51f8      	mov	dp:0xf8 <_g_u16ActuatorActPos>, A
	}

	{
		int32 i32DeltaPosition = (int32)g_u16ActuatorActPos - (int32)g_u16ActuatorTgtPos;
    972c:	7df8      	lod	X, dp:0xf8 <_g_u16ActuatorActPos>
    972e:	4ceb      	movu	YA, X
    9730:	a9fa      	sub	A, dp:0xfa <_g_u16ActuatorTgtPos>
    9732:	f800      	subc	Y, #0
    9734:	5211      	mov	[S-18], A
    9736:	5a0f      	mov	[S-16], Y
		if ( i32DeltaPosition == 0 )
    9738:	4cb2 0000 	cmp	YA, #0
    973c:	0000 
    973e:	1d0a      	jne	0x9754 <_EXT0_IT+0x60>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    9740:	7001      	lod	A, #1
    9742:	16b9      	call	0x94b6 <_MotorDriverStop>
			return;
    9744:	5c11      	dec	S, #18
    9746:	4cc3      	pop	D
    9748:	7acf      	pop	Y
    974a:	7ecf      	pop	X
    974c:	72cf      	pop	A
    974e:	4407      	mov	R, #0
    9750:	72cb      	pop	M
    9752:	5401      	ret
		}
		if ( i32DeltaPosition < 0 )
    9754:	7211      	lod	A, [S-18]
    9756:	7a0f      	lod	Y, [S-16]
    9758:	4cb2 0000 	cmp	YA, #0
    975c:	0000 
    975e:	1e83      	jsge	0x9766 <_EXT0_IT+0x72>
		{
			i32DeltaPosition = -i32DeltaPosition;
    9760:	4cf0      	neg	YA
    9762:	5211      	mov	[S-18], A
    9764:	5a0f      	mov	[S-16], Y
		}
		if ( i32DeltaPosition <= (int16) l_u8VTIdx )
    9766:	6536      	lod	YL, dp:0x36 <_l_u8VTIdx>
    9768:	5cf6      	usex	Y
    976a:	5a07      	mov	[S-8], Y
    976c:	7207      	lod	A, [S-8]
    976e:	7800      	lod	Y, #0
    9770:	5207      	mov	[S-8], A
    9772:	5a05      	mov	[S-6], Y
    9774:	72ef      	lod	A, S
    9776:	a0ee      	add	A, #-18
    9778:	4cf3      	swap	YA
    977a:	4cc5      	mov	D, [Y]
    977c:	7207      	lod	A, [S-8]
    977e:	7a05      	lod	Y, [S-6]
    9780:	4c90      	cmp	D, YA
    9782:	1f08      	jsg	0x9794 <_EXT0_IT+0xa0>
		{
			/* Decelerate motor speed (almost at target-position) */
			g_u16StartupDelay = (uint16) i32DeltaPosition;
    9784:	7a11      	lod	Y, [S-18]
    9786:	5938      	mov	dp:0x38 <_g_u16StartupDelay>, Y
			g_u16TargetCommutTimerPeriod = l_u16LowSpeedPeriod;
    9788:	7ed8 031c 	lod	X, 0x31c <_l_u16LowSpeedPeriod>
    978c:	5d54      	mov	dp:0x54 <_g_u16TargetCommutTimerPeriod>, X
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_STOPPING;
    978e:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    9790:	8409      	or	AL, #9
    9792:	41ed      	mov	dp:0xed <_g_e8MotorStatusMode>, AL
		}
	}

	/* Current measurement used for Stall-detector "A" and current control (PID) */
	MotorDriverCurrentMeasure();
    9794:	14fe      	call	0x9192 <_MotorDriverCurrentMeasure>
	/* Coil current check */
	if(l_u16CoilCurrentStartDelay == 0)
    9796:	72d8 0134 	lod	A, 0x134 <_l_u16CoilCurrentStartDelay>
    979a:	1901      	je	0x979e <_EXT0_IT+0xaa>
    979c:	0041      	jmp	0x9820 <_EXT0_IT+0x12c>
	{
		if(g_u16CurrentMotorCoilA < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT))
    979e:	7ad8 012e 	lod	Y, 0x12e <_l_u16CurrentZeroOffset>
    97a2:	72e6      	lod	A, Y
    97a4:	a00a      	add	A, #10
    97a6:	5207      	mov	[S-8], A
    97a8:	7ed8 0138 	lod	X, 0x138 <_l_u16CoilZeroCurrCountA>
    97ac:	72d8 0128 	lod	A, 0x128 <_g_u16CurrentMotorCoilB>
    97b0:	5209      	mov	[S-10], A
    97b2:	7207      	lod	A, [S-8]
    97b4:	aed8 012a 	cmp	A, 0x12a <_g_u16CurrentMotorCoilA>
    97b8:	1a03      	jule	0x97c0 <_EXT0_IT+0xcc>
		{
			l_u16CoilZeroCurrCountA++;
    97ba:	72ee      	lod	A, X
    97bc:	a001      	add	A, #1
    97be:	0004      	jmp	0x97c8 <_EXT0_IT+0xd4>
		}
		else if ( l_u16CoilZeroCurrCountA != 0 )
    97c0:	2c00      	cmp	X, #0
    97c2:	1904      	je	0x97cc <_EXT0_IT+0xd8>
		{
			l_u16CoilZeroCurrCountA--;
    97c4:	72ee      	lod	A, X
    97c6:	a0ff      	add	A, #-1
    97c8:	52d8 0138 	mov	0x138 <_l_u16CoilZeroCurrCountA>, A
		}

		if(g_u16CurrentMotorCoilB < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT))
    97cc:	e00a      	add	Y, #10
    97ce:	5a07      	mov	[S-8], Y
    97d0:	7ed8 0138 	lod	X, 0x138 <_l_u16CoilZeroCurrCountA>
    97d4:	7ad8 0136 	lod	Y, 0x136 <_l_u16CoilZeroCurrCountB>
    97d8:	7209      	lod	A, [S-10]
    97da:	ae07      	cmp	A, [S-8]
    97dc:	1c03      	jnc	0x97e4 <_EXT0_IT+0xf0>
		{
			l_u16CoilZeroCurrCountB++;
    97de:	72e6      	lod	A, Y
    97e0:	a001      	add	A, #1
    97e2:	0004      	jmp	0x97ec <_EXT0_IT+0xf8>
		}
		else if ( l_u16CoilZeroCurrCountB != 0 )
    97e4:	ec00      	cmp	Y, #0
    97e6:	1904      	je	0x97f0 <_EXT0_IT+0xfc>
		{
			l_u16CoilZeroCurrCountB--;
    97e8:	72e6      	lod	A, Y
    97ea:	a0ff      	add	A, #-1
    97ec:	52d8 0136 	mov	0x136 <_l_u16CoilZeroCurrCountB>, A
		}

		if((l_u16CoilZeroCurrCountA >= C_COIL_ZERO_CURRENT_COUNT) || (l_u16CoilZeroCurrCountB >= C_COIL_ZERO_CURRENT_COUNT))
    97f0:	2c1f      	cmp	X, #31
    97f2:	1e04      	jug	0x97fc <_EXT0_IT+0x108>
    97f4:	72d8 0136 	lod	A, 0x136 <_l_u16CoilZeroCurrCountB>
    97f8:	ac1f      	cmp	A, #31
    97fa:	1a15      	jule	0x9826 <_EXT0_IT+0x132>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    97fc:	7001      	lod	A, #1
    97fe:	165b      	call	0x94b6 <_MotorDriverStop>
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    9800:	6002      	lod	AL, #2
    9802:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
    9804:	72da 00e6 	lod	A, #230
    9808:	82db 8c66 	callf	0x8c66 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;//coil open
    980c:	60ec      	lod	AL, #-20
    980e:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			return;
    9810:	5c11      	dec	S, #18
    9812:	4cc3      	pop	D
    9814:	7acf      	pop	Y
    9816:	7ecf      	pop	X
    9818:	72cf      	pop	A
    981a:	4407      	mov	R, #0
    981c:	72cb      	pop	M
    981e:	5401      	ret
		}
	}else if(l_u16CoilCurrentStartDelay > 0){
		l_u16CoilCurrentStartDelay--;
    9820:	a0ff      	add	A, #-1
    9822:	52d8 0134 	mov	0x134 <_l_u16CoilCurrentStartDelay>, A



	/* Update micro-step index */
	{
		uint16 u16MicroStepIdx = g_u16MicroStepIdx;
    9826:	7950      	lod	Y, dp:0x50 <_g_u16MicroStepIdx>
		if ( g_e8MotorDirectionCCW )
    9828:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    982a:	1906      	je	0x9838 <_EXT0_IT+0x144>
		{
			/* Counter Clock-wise (Closing) */
			if ( u16MicroStepIdx == 0 )
    982c:	ec00      	cmp	Y, #0
    982e:	1d02      	jne	0x9834 <_EXT0_IT+0x140>
			{
				u16MicroStepIdx = g_u16MotorMicroStepsPerElecRotation;
    9830:	7ad8 026e 	lod	Y, 0x26e <_g_u16MotorMicroStepsPerElecRotation>
			}
			u16MicroStepIdx--;													/* Decrement the PWM vector pointer */
    9834:	e0ff      	add	Y, #-1
    9836:	0005      	jmp	0x9842 <_EXT0_IT+0x14e>
		}
		else
		{
			/* Clock-wise (Opening) */
			u16MicroStepIdx++;													/* Increment the PWM vectors pointer */
    9838:	e001      	add	Y, #1
			if ( u16MicroStepIdx >= g_u16MotorMicroStepsPerElecRotation )		/* Test the PWM vectors pointer: 48 usteps per electrical period */
    983a:	eed8 026e 	cmp	Y, 0x26e <_g_u16MotorMicroStepsPerElecRotation>
    983e:	1801      	jc	0x9842 <_EXT0_IT+0x14e>
			{
				u16MicroStepIdx = 0;											/* Re-initialise the PWM vectors pointer to 0 */
    9840:	7800      	lod	Y, #0
			}
		}
		g_u16MicroStepIdx = u16MicroStepIdx;
    9842:	5950      	mov	dp:0x50 <_g_u16MicroStepIdx>, Y
	}

	/* Check for speed update required */
	if ( g_u16CommutTimerPeriod == g_u16TargetCommutTimerPeriod )
    9844:	7d52      	lod	X, dp:0x52 <_g_u16CommutTimerPeriod>
    9846:	7154      	lod	A, dp:0x54 <_g_u16TargetCommutTimerPeriod>
    9848:	520d      	mov	[S-14], A
    984a:	2ee2      	cmp	X, A
    984c:	1d04      	jne	0x9856 <_EXT0_IT+0x162>
	{
		g_u8MotorStartupMode = (uint8) MSM_STEPPER_C;
    984e:	6003      	lod	AL, #3
    9850:	42d8 013f 	mov	0x13f <_g_u8MotorStartupMode>, AL
    9854:	005b      	jmp	0x990c <_EXT0_IT+0x218>
	}
	else
	{
		/* Update speed */
		uint16 u16Compensation = l_u16SpeedRPM;							//MMP160606-1
    9856:	72d8 0316 	lod	A, 0x316 <_l_u16SpeedRPM>
    985a:	520b      	mov	[S-12], A
		if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    985c:	2e0d      	cmp	X, [S-14]
    985e:	1c30      	jnc	0x98c0 <_EXT0_IT+0x1cc>
		{
			/* Deceleration per micro-step */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_D;					/* Too fast, decelerate */
    9860:	6002      	lod	AL, #2
    9862:	42d8 013f 	mov	0x13f <_g_u8MotorStartupMode>, AL
    9866:	71a2      	lod	A, dp:0xa2 <_g_NvramUser+0x48>
    9868:	7800      	lod	Y, #0
    986a:	48e0      	asl	YA, #1
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    986c:	7e0b      	lod	X, [S-12]
    986e:	4c63      	divu	YA, X
    9870:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9872:	2ae2      	sub	X, A
    9874:	5e03      	mov	[S-4], X
    9876:	5ed8 0316 	mov	0x316 <_l_u16SpeedRPM>, X
    987a:	72d8 0318 	lod	A, 0x318 <_l_u32Temp>
    987e:	7ad8 031a 	lod	Y, 0x31a <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9882:	4c63      	divu	YA, X
    9884:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9886:	7ae2      	lod	Y, A
    9888:	e0ff      	add	Y, #-1
    988a:	5952      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM - divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;	/* MMP160606-1 */
			l_u8VTIdx--;
    988c:	6136      	lod	AL, dp:0x36 <_l_u8VTIdx>
    988e:	80ff      	add	AL, #-1
    9890:	4136      	mov	dp:0x36 <_l_u8VTIdx>, AL
			if ( g_u16StartupDelay < l_u8VTIdx )
    9892:	5cf2      	usex	A
    9894:	ad38      	cmp	A, dp:0x38 <_g_u16StartupDelay>
    9896:	1a03      	jule	0x989e <_EXT0_IT+0x1aa>
			{
				g_u16StartupDelay = l_u16StartupDelayInit;						/* MMP130627-1/MMP140331-2: Speed reduction, stall detection post-poned */
    9898:	72d8 013a 	lod	A, 0x13a <_l_u16StartupDelayInit>
    989c:	5138      	mov	dp:0x38 <_g_u16StartupDelay>, A
			}
			if ( g_u16CommutTimerPeriod > g_u16TargetCommutTimerPeriod )
    989e:	ee0d      	cmp	Y, [S-14]
    98a0:	1a02      	jule	0x98a6 <_EXT0_IT+0x1b2>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    98a2:	7a0d      	lod	Y, [S-14]
    98a4:	5952      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, Y
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    98a6:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    98a8:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    98aa:	72d8 0320 	lod	A, 0x320 <_g_u16PidCtrlRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    98ae:	7a03      	lod	Y, [S-4]
    98b0:	7e0b      	lod	X, [S-12]
    98b2:	4821      	mulu	YA, A, Y
    98b4:	4c63      	divu	YA, X
    98b6:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    98b8:	52d8 0320 	mov	0x320 <_g_u16PidCtrlRatio>, A
#if (_SUPPORT_PWM_DC_RAMPDOWN != FALSE)											/* MMP140903-2 - Begin */
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
    98bc:	51ca      	mov	dp:0xca <_g_u16PID_I>, A
    98be:	0026      	jmp	0x990c <_EXT0_IT+0x218>
//			/* Reduce the PWM-duty cycle to avoid current increase (wrong stall detection) (254/256) */
//			g_u16PidCtrlRatio = (uint16) (mulU32_U16byU16( g_u16PidCtrlRatio, 254) >> 8);
//			g_u16PID_I = g_u16PidCtrlRatio;
//#endif /* (_SUPPORT_PWM_DC_RAMPDOWN != FALSE) */								/* MMP140903-2 - Begin */
		}
		else if ( (g_u16MicroStepIdx == 0) || ((g_u16MicroStepIdx > NVRAM_ACCELERATION_POINTS) && ((g_u16MicroStepIdx & NVRAM_ACCELERATION_POINTS) == 0)) )
    98c0:	ec00      	cmp	Y, #0
    98c2:	1906      	je	0x98d0 <_EXT0_IT+0x1dc>
    98c4:	61a4      	lod	AL, dp:0xa4 <_g_NvramUser+0x4a>
    98c6:	b43f      	and	A, #63
    98c8:	eee2      	cmp	Y, A
    98ca:	1a20      	jule	0x990c <_EXT0_IT+0x218>
    98cc:	b6e6      	and	A, Y
    98ce:	1d1e      	jne	0x990c <_EXT0_IT+0x218>
		{
			/* Acceleration per acceleration_points ((multiple) full-step) */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;					/* Too slow, accelerate */
    98d0:	6001      	lod	AL, #1
    98d2:	42d8 013f 	mov	0x13f <_g_u8MotorStartupMode>, AL
    98d6:	71a2      	lod	A, dp:0xa2 <_g_NvramUser+0x48>
    98d8:	7800      	lod	Y, #0
    98da:	48e0      	asl	YA, #1
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    98dc:	7e0b      	lod	X, [S-12]
    98de:	4c63      	divu	YA, X
    98e0:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    98e2:	22e2      	add	X, A
    98e4:	5ed8 0316 	mov	0x316 <_l_u16SpeedRPM>, X
    98e8:	72d8 0318 	lod	A, 0x318 <_l_u32Temp>
    98ec:	7ad8 031a 	lod	Y, 0x31a <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    98f0:	4c63      	divu	YA, X
    98f2:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    98f4:	7ae2      	lod	Y, A
    98f6:	e0ff      	add	Y, #-1
    98f8:	5952      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM + divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;	/* MMP160606-1 */
			l_u8VTIdx++;
    98fa:	6136      	lod	AL, dp:0x36 <_l_u8VTIdx>
    98fc:	8001      	add	AL, #1
    98fe:	4136      	mov	dp:0x36 <_l_u8VTIdx>, AL
			if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )	/* MMP150923-1 */
    9900:	ee0d      	cmp	Y, [S-14]
    9902:	1c02      	jnc	0x9908 <_EXT0_IT+0x214>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9904:	720d      	lod	A, [S-14]
    9906:	5152      	mov	dp:0x52 <_g_u16CommutTimerPeriod>, A
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    9908:	7152      	lod	A, dp:0x52 <_g_u16CommutTimerPeriod>
    990a:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
//			TMR1_REGB = g_u16CommutTimerPeriod;
//			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;						/* Too slow, accelerate */
		}
	}

	VoltageCorrection();
    990c:	1358      	call	0x9fbe <_VoltageCorrection>

	MotorDriver_4PhaseStepper();
    990e:	14d0      	call	0x92b0 <_MotorDriver_4PhaseStepper>
	if ( MotorStallCheckA() != (uint16) C_STALL_NOT_FOUND )						/* Stall-detector "A" */
    9910:	1018      	call	0x9942 <_MotorStallCheckA>
    9912:	ac00      	cmp	A, #0
    9914:	190a      	je	0x992a <_EXT0_IT+0x236>
	{
		g_u8StallTypeComm |= (uint8) C_STALL_FOUND_A;
    9916:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    9918:	8440      	or	AL, #64
    991a:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
		if ( g_e8StallDetectorEna & ((uint8) C_STALLDET_A | (uint8) C_STALLDET_CALIB))	/* MMP130916-1 */
    991c:	61ee      	lod	AL, dp:0xee <_g_e8StallDetectorEna>
    991e:	b409      	and	A, #9
    9920:	1904      	je	0x992a <_EXT0_IT+0x236>
		{
			g_u8StallOcc = TRUE;												/* Report stall and ...  */
    9922:	6001      	lod	AL, #1
    9924:	4128      	mov	dp:0x28 <_g_u8StallOcc>, AL
			MotorDriverStop( (uint16) C_STOP_EMERGENCY);						/* ... stop motor (Stall) */
    9926:	7002      	lod	A, #2
    9928:	15c6      	call	0x94b6 <_MotorDriverStop>
    992a:	5c11      	dec	S, #18
    992c:	4cc3      	pop	D
    992e:	7acf      	pop	Y
    9930:	7ecf      	pop	X
    9932:	72cf      	pop	A
    9934:	4407      	mov	R, #0
    9936:	72cb      	pop	M
    9938:	5401      	ret

0000993a <_MotorStallInitA>:
 *
 * Initialise Stall detector "A"
 * ****************************************************************************	*/
void MotorStallInitA( void)
{
	g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;								/* Used for communication */
    993a:	6000      	lod	AL, #0
    993c:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

	l_u8StallCountA = 0;														/* Stall-counter */
    993e:	413b      	mov	dp:0x3b <_l_u8StallCountA>, AL
    9940:	5401      	ret

00009942 <_MotorStallCheckA>:
 * Check if motor is stalled
 * Stall detector "A" is based on fast current increase
 * Performance: 5us @ 20MHz
 * ****************************************************************************	*/
uint16 MotorStallCheckA( void)
{
    9942:	5805      	inc	S, #6
	uint16 u16Result = C_STALL_NOT_FOUND;
    9944:	7000      	lod	A, #0
    9946:	5205      	mov	[S-6], A
	if ( (g_u16StartupDelay == 0) && (g_u16MotorCurrentMovAvgxN > (C_MIN_MOTORCURRENT << 4)) )	/* MMP130916-1 */
    9948:	7138      	lod	A, dp:0x38 <_g_u16StartupDelay>
    994a:	1d2e      	jne	0x99a8 <_MotorStallCheckA+0x66>
    994c:	7156      	lod	A, dp:0x56 <__data_size>
    994e:	5203      	mov	[S-4], A
    9950:	aeda 00a0 	cmp	A, #160
    9954:	1a29      	jule	0x99a8 <_MotorStallCheckA+0x66>
		   blocks, the BEMF drops to zero, and therefore the motor current increases.
		   This increase is monitored by calculating the difference (delta) between
		   a LPF filter (slowly increase) and the actual motor current. If this delta
		   increases above a specified threshold, stall is detected. */
		uint16 u16Threshold;
		if ( NVRAM_STALL_SPEED_DEPENDED )
    9956:	61c9      	lod	AL, dp:0xc9 <__bss_dp_size+0x19>
    9958:	65a5      	lod	YL, dp:0xa5 <_g_NvramUser+0x4b>
    995a:	7d58      	lod	X, dp:0x58 <_g_u16MotorCurrentLPFx64>
    995c:	8c00      	cmp	AL, #0
    995e:	1e8a      	jsge	0x9974 <_MotorStallCheckA+0x32>
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 120) + (g_u8MotorStatusSpeed << 3);	/* Speed depended Threshold */
    9960:	f47f      	and	Y, #127
    9962:	611e      	lod	AL, dp:0x1e <__ramfunc_size>
    9964:	44a2      	asl	A, #2
    9966:	4422      	asl	A
    9968:	b6da 07f8 	and	A, #2040
    996c:	e2e2      	add	Y, A
    996e:	72e6      	lod	A, Y
    9970:	a078      	add	A, #120
    9972:	0004      	jmp	0x997c <_MotorStallCheckA+0x3a>
		}
		else
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 128);					/* Fixed Threshold */
    9974:	72e6      	lod	A, Y
    9976:	b47f      	and	A, #127
    9978:	a2da 0080 	add	A, #128
		}
		l_u16MotorCurrentStallThrshldxN = (uint16)(((uint32)g_u16MotorCurrentLPFx64 * u16Threshold) >> (13 - C_MOVAVG_SSZ));
    997c:	4823      	mulu	YA, A, X
    997e:	48a6      	lsr	YA, #7
    9980:	52d8 031e 	mov	0x31e <_l_u16MotorCurrentStallThrshldxN>, A
		if ( g_u16MotorCurrentMovAvgxN > l_u16MotorCurrentStallThrshldxN )
    9984:	7ae2      	lod	Y, A
    9986:	613b      	lod	AL, dp:0x3b <_l_u8StallCountA>
    9988:	4201      	mov	[S-2], AL
    998a:	7203      	lod	A, [S-4]
    998c:	aee6      	cmp	A, Y
    998e:	1a08      	jule	0x99a0 <_MotorStallCheckA+0x5e>
		{
			l_u8StallCountA++;
    9990:	6201      	lod	AL, [S-2]
    9992:	8001      	add	AL, #1
    9994:	413b      	mov	dp:0x3b <_l_u8StallCountA>, AL
			if ( l_u8StallCountA >= 3 )
    9996:	8c02      	cmp	AL, #2
    9998:	1a07      	jule	0x99a8 <_MotorStallCheckA+0x66>
			{
				/* Real stall */
				u16Result = C_STALL_FOUND;
    999a:	7002      	lod	A, #2
    999c:	5205      	mov	[S-6], A
    999e:	0004      	jmp	0x99a8 <_MotorStallCheckA+0x66>
			}
		}
		else if ( l_u8StallCountA )
    99a0:	6201      	lod	AL, [S-2]
    99a2:	1902      	je	0x99a8 <_MotorStallCheckA+0x66>
		{
			l_u8StallCountA--;
    99a4:	80ff      	add	AL, #-1
    99a6:	413b      	mov	dp:0x3b <_l_u8StallCountA>, AL
		}
	}
	return ( u16Result );
} /* End of MotorStallCheckA() */
    99a8:	7205      	lod	A, [S-6]
    99aa:	5407      	ret	#8

000099ac <_NVRAM_CRC8>:
 *								TRUE: Calculated CRC8
 *
 *	Calculate CRC8 on User-NVRAM
 * ****************************************************************************	*/
uint8 NVRAM_CRC8( uint8 byReplaceCRC)
{
    99ac:	5803      	inc	S, #4
    99ae:	5201      	mov	[S-2], A
	uint16 u16CRC;

	if ( byReplaceCRC != FALSE )
    99b0:	ac00      	cmp	A, #0
    99b2:	1902      	je	0x99b8 <_NVRAM_CRC8+0xc>
	{
		g_NvramUser.CRC8 = 0x00;
    99b4:	6000      	lod	AL, #0
    99b6:	415a      	mov	dp:0x5a <_g_NvramUser>, AL
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    99b8:	7ada 005a 	lod	Y, #90
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    99bc:	7c38      	lod	X, #56
    99be:	7000      	lod	A, #0
    99c0:	08a7      	clrb	ML.7
    99c2:	b2d6      	adc	A, [Y++]
    99c4:	1bfe      	djnz	X, 0x99c2 <_NVRAM_CRC8+0x16>
    99c6:	92e4      	adc	AL, AH
    99c8:	9000      	adc	AL, #0
    99ca:	5cf2      	usex	A
    99cc:	5203      	mov	[S-4], A
	}

	u16CRC = nvram_CalcCRC( (uint16 *) &g_NvramUser, (sizeof(g_NvramUser)/sizeof(uint16)));	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    99ce:	7a01      	lod	Y, [S-2]
    99d0:	1903      	je	0x99d8 <_NVRAM_CRC8+0x2c>
	{
		g_NvramUser.CRC8 = (0xFF - u16CRC);
    99d2:	60ff      	lod	AL, #-1
    99d4:	8a03      	sub	AL, [S-4]
    99d6:	415a      	mov	dp:0x5a <_g_NvramUser>, AL
	}

	return ( (uint8) u16CRC );
    99d8:	6203      	lod	AL, [S-4]
    99da:	5cf2      	usex	A
} /* End of NVRAM_CRC8() */
    99dc:	5405      	ret	#6

000099de <_NVRAM_CountCRC8>:
 *								TRUE: Calculated CRC8.
 *
 *	Calculate CRC8 on Write-cycle counter.
 * ****************************************************************************	*/
uint8 NVRAM_CountCRC8( PNVRAM_ERRORLOG pNVERRLOG, uint8 byReplaceCRC)
{
    99de:	5807      	inc	S, #8
    99e0:	5203      	mov	[S-4], A
    99e2:	620b      	lod	AL, [S-12]
    99e4:	5cf2      	usex	A
    99e6:	5201      	mov	[S-2], A
    99e8:	7c01      	lod	X, #1
    99ea:	7a03      	lod	Y, [S-4]
    99ec:	7000      	lod	A, #0
    99ee:	08a7      	clrb	ML.7
    99f0:	b2d6      	adc	A, [Y++]
    99f2:	1bfe      	djnz	X, 0x99f0 <_NVRAM_CountCRC8+0x12>
    99f4:	92e4      	adc	AL, AH
    99f6:	9000      	adc	AL, #0
    99f8:	5cf2      	usex	A
    99fa:	5207      	mov	[S-8], A
	uint16 u16CRC = nvram_CalcCRC( (uint16 *) &pNVERRLOG->NvramProgramCycleCount, 1);	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    99fc:	7201      	lod	A, [S-2]
    99fe:	190c      	je	0x9a18 <_NVRAM_CountCRC8+0x3a>
	{
		pNVERRLOG->ErrorLogIndex_CRC = (pNVERRLOG->ErrorLogIndex_CRC & 0x00FF) | ((0xFF - u16CRC) << 8);
    9a00:	7a03      	lod	Y, [S-4]
    9a02:	72f2      	lod	A, [Y+2]
    9a04:	b6da 00ff 	and	A, #255
    9a08:	7ee2      	lod	X, A
    9a0a:	72da 00ff 	lod	A, #255
    9a0e:	aa07      	sub	A, [S-8]
    9a10:	6800      	lod	AH, #0
    9a12:	72e4      	swap	A
    9a14:	26e2      	or	X, A
    9a16:	5ef2      	mov	[Y+2], X
	}
	return ( (uint8) ((pNVERRLOG->ErrorLogIndex_CRC >> 8) ^ u16CRC) );
    9a18:	7a03      	lod	Y, [S-4]
    9a1a:	62f3      	lod	AL, [Y+3]
    9a1c:	9e07      	xor	AL, [S-8]
    9a1e:	5cf2      	usex	A
} /* End of NVRAM_CountCRC8() */
    9a20:	5409      	ret	#10

00009a22 <_NVRAM_PageVerify>:
 *	Post:	FALSE: NVRAM shadow-RAM page structure and RAM-structure are not the same
 *			TRUE : NVRAM shadow-RAM page structure and RAM-structure are the same
 *
 * ****************************************************************************	*/
uint16 NVRAM_PageVerify( const uint16 *pMRAM)
{
    9a22:	7ee2      	lod	X, A
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    9a24:	7ada 005a 	lod	Y, #90
	do
	{
		if ( *pMRAM++ != *pURAM++ )
    9a28:	72de      	lod	A, [X++]
    9a2a:	aed6      	cmp	A, [Y++]
    9a2c:	1902      	je	0x9a32 <_NVRAM_PageVerify+0x10>
		{
			/* Error */
			return ( FALSE );
    9a2e:	7000      	lod	A, #0
    9a30:	5401      	ret
		}
	} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    9a32:	eeda 00ca 	cmp	Y, #202
    9a36:	1878      	jc	0x9a28 <_NVRAM_PageVerify+0x6>
	return ( TRUE );
    9a38:	7001      	lod	A, #1
} /* End of NVRAM_PageVerify() */
    9a3a:	5401      	ret

00009a3c <_NVRAM_Store>:
 *
 * C_ADDR_USERPAGE1+0x00:0x7F:	User page #1 (64x 16-bits words)
 * C_ADDR_USERPAGE2+0x00:0x7F:	User page #2 (64x 16-bits words) (Backup)
 * ****************************************************************************	*/
uint16 NVRAM_Store( uint16 u16Page)
{
    9a3c:	5803      	inc	S, #4
    9a3e:	5203      	mov	[S-4], A
	uint16 *pURAM;
	uint16 *pMRAM;
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    9a40:	7000      	lod	A, #0
    9a42:	5201      	mov	[S-2], A

	/* Store NVRAM */
	if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0 )
    9a44:	6203      	lod	AL, [S-4]
    9a46:	8c00      	cmp	AL, #0
    9a48:	1a82      	jsl	0x9a4e <_NVRAM_Store+0x12>
	{
		(void) NVRAM_CRC8( TRUE);												/* Update CRC8 */
    9a4a:	7001      	lod	A, #1
    9a4c:	17af      	call	0x99ac <_NVRAM_CRC8>
	}

	/* Copy NVRAM UserRAM-copy into NVRAM MirrorRAM */
	if ( (u16Page & C_NVRAM_USER_PAGE_1) &&
    9a4e:	7203      	lod	A, [S-4]
    9a50:	b401      	and	A, #1
    9a52:	1d01      	jne	0x9a56 <_NVRAM_Store+0x1a>
    9a54:	0039      	jmp	0x9ac8 <_NVRAM_Store+0x8c>
    9a56:	7203      	lod	A, [S-4]
    9a58:	b440      	and	A, #64
    9a5a:	1d05      	jne	0x9a66 <_NVRAM_Store+0x2a>
    9a5c:	72da 1000 	lod	A, #4096
    9a60:	17e0      	call	0x9a22 <_NVRAM_PageVerify>
    9a62:	ac00      	cmp	A, #0
    9a64:	1d31      	jne	0x9ac8 <_NVRAM_Store+0x8c>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */							/* MMP150219-1 - Begin */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    9a66:	54ca 0000 	pushw	#0
    9a6a:	72da 1070 	lod	A, #4208
    9a6e:	17b7      	call	0x99de <_NVRAM_CountCRC8>
    9a70:	5c01      	dec	S, #2
    9a72:	8cff      	cmp	AL, #-1
    9a74:	1906      	je	0x9a82 <_NVRAM_Store+0x46>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    9a76:	7000      	lod	A, #0
    9a78:	7ada 1070 	lod	Y, #4208
    9a7c:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    9a7e:	7802      	lod	Y, #2
    9a80:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    9a82:	7ada 1070 	lod	Y, #4208
    9a86:	72f0      	lod	A, [Y]
    9a88:	acfd      	cmp	A, #-3
    9a8a:	1e02      	jug	0x9a90 <_NVRAM_Store+0x54>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    9a8c:	a001      	add	A, #1
    9a8e:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);							/* Calculate Cycle-count CRC8 */
    9a90:	54ca 0001 	pushw	#1
    9a94:	72da 1070 	lod	A, #4208
    9a98:	17a2      	call	0x99de <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 1 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    9a9a:	7ada 005a 	lod	Y, #90
				pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    9a9e:	7eda 1000 	lod	X, #4096
				do
    9aa2:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    9aa4:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    9aa6:	eeda 00ca 	cmp	Y, #202
    9aaa:	187c      	jc	0x9aa4 <_NVRAM_Store+0x68>
			}																	/* MMP150219-1 - End */

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM1_PAGE1);
    9aac:	7000      	lod	A, #0
    9aae:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    9ab2:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE1) == FALSE )
    9ab6:	72da 1000 	lod	A, #4096
    9aba:	17b3      	call	0x9a22 <_NVRAM_PageVerify>
    9abc:	ac00      	cmp	A, #0
    9abe:	1d04      	jne	0x9ac8 <_NVRAM_Store+0x8c>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG11);
    9ac0:	72da 00f4 	lod	A, #244
    9ac4:	82db 8c66 	callf	0x8c66 <_SetLastError>
		} while ( FALSE );
	}

#if _SUPPORT_NVRAM_BACKUP
	/* Duplicate NVRAM user page 1 into page 2 */
	if ( (u16Page & C_NVRAM_USER_PAGE_2) &&
    9ac8:	7203      	lod	A, [S-4]
    9aca:	b402      	and	A, #2
    9acc:	1d01      	jne	0x9ad0 <_NVRAM_Store+0x94>
    9ace:	0039      	jmp	0x9b42 <_NVRAM_Store+0x106>
    9ad0:	7203      	lod	A, [S-4]
    9ad2:	b440      	and	A, #64
    9ad4:	1d05      	jne	0x9ae0 <_NVRAM_Store+0xa4>
    9ad6:	72da 1100 	lod	A, #4352
    9ada:	17a3      	call	0x9a22 <_NVRAM_PageVerify>
    9adc:	ac00      	cmp	A, #0
    9ade:	1d31      	jne	0x9b42 <_NVRAM_Store+0x106>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */							/* MMP150219-1 - Begin */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    9ae0:	54ca 0000 	pushw	#0
    9ae4:	72da 1170 	lod	A, #4464
    9ae8:	177a      	call	0x99de <_NVRAM_CountCRC8>
    9aea:	5c01      	dec	S, #2
    9aec:	8cff      	cmp	AL, #-1
    9aee:	1906      	je	0x9afc <_NVRAM_Store+0xc0>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    9af0:	7000      	lod	A, #0
    9af2:	7ada 1170 	lod	Y, #4464
    9af6:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    9af8:	7802      	lod	Y, #2
    9afa:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    9afc:	7ada 1170 	lod	Y, #4464
    9b00:	72f0      	lod	A, [Y]
    9b02:	acfd      	cmp	A, #-3
    9b04:	1e02      	jug	0x9b0a <_NVRAM_Store+0xce>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    9b06:	a001      	add	A, #1
    9b08:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);
    9b0a:	54ca 0001 	pushw	#1
    9b0e:	72da 1170 	lod	A, #4464
    9b12:	1765      	call	0x99de <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 2 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    9b14:	7ada 005a 	lod	Y, #90
				pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    9b18:	7eda 1100 	lod	X, #4352
				do
    9b1c:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    9b1e:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    9b20:	eeda 00ca 	cmp	Y, #202
    9b24:	187c      	jc	0x9b1e <_NVRAM_Store+0xe2>
			}																	/* MMP150219-1 - End */

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1);
    9b26:	7002      	lod	A, #2
    9b28:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    9b2c:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE2) == FALSE )
    9b30:	72da 1100 	lod	A, #4352
    9b34:	1776      	call	0x9a22 <_NVRAM_PageVerify>
    9b36:	ac00      	cmp	A, #0
    9b38:	1d04      	jne	0x9b42 <_NVRAM_Store+0x106>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG21);
    9b3a:	72da 00f6 	lod	A, #246
    9b3e:	82db 8c66 	callf	0x8c66 <_SetLastError>
#endif /* _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE */
		} while ( FALSE );
	}
#endif /* _SUPPORT_NVRAM_BACKUP */
	return ( u16Result );														/* MMP150219-1 */
} /* NVRAM_Store() */
    9b42:	7201      	lod	A, [S-2]
    9b44:	5405      	ret	#6

00009b46 <_NVRAM_LoadUserPage>:
 * void NVRAM_LoadUserPage
 *
 * Load user NVRAM page (NVRAM to User-RAM).
 * ****************************************************************************	*/
void NVRAM_LoadUserPage( void)
{
    9b46:	5807      	inc	S, #8
	uint16 u16ErrorFlag;
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    9b48:	7ada 005a 	lod	Y, #90
    9b4c:	5a05      	mov	[S-6], Y
#if (LINPROT == LIN2J_VALVE_GM)
	uint16 *pMRAM;
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    9b4e:	7ada 101e 	lod	Y, #4126
    9b52:	66f0      	lod	YL, [Y]
    9b54:	f6da 0080 	and	Y, #128
    9b58:	7ee6      	lod	X, Y
    9b5a:	7ada 111e 	lod	Y, #4382
    9b5e:	62f0      	lod	AL, [Y]
    9b60:	b6da 0080 	and	A, #128
    9b64:	2ee2      	cmp	X, A
    9b66:	1904      	je	0x9b70 <_NVRAM_LoadUserPage+0x2a>
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    9b68:	7eda 1100 	lod	X, #4352
    9b6c:	5e03      	mov	[S-4], X
    9b6e:	0003      	jmp	0x9b76 <_NVRAM_LoadUserPage+0x30>
	else
		pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    9b70:	7ada 1000 	lod	Y, #4096
    9b74:	5a03      	mov	[S-4], Y
#else  /* (LINPROT == LIN2J_VALVE_GM) */
	uint16 *pMRAM = (uint16 *) C_ADDR_USERPAGE1;
#endif /* (LINPROT == LIN2J_VALVE_GM) */

	NVRAM_LoadAll();
    9b76:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
	u16ErrorFlag = (VARIOUS_L & EENV_DED);										/* Double-bit error state */
    9b7a:	6280      	lod	AL, io:0x0 <__dp__>
    9b7c:	7ae2      	lod	Y, A
    9b7e:	f6da 0080 	and	Y, #128
    9b82:	5a07      	mov	[S-8], Y
	/* Copy NVRAM MirrorRAM-copy into NVRAM UserRAM (to allow byte/bit access) */
	do
	{
		*pURAM++ = *pMRAM++;
    9b84:	7e05      	lod	X, [S-6]
    9b86:	7a03      	lod	Y, [S-4]
    9b88:	54c6      	movsw	[X++], [Y++]
    9b8a:	5a03      	mov	[S-4], Y
    9b8c:	5e05      	mov	[S-6], X
	} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9b8e:	2eda 00ca 	cmp	X, #202
    9b92:	1878      	jc	0x9b84 <_NVRAM_LoadUserPage+0x3e>
	/* Check Double-bit NVRAM set, User-NVRAM structure-revision and User-NVRAM Checksum */
	if ( ((u16ErrorFlag == FALSE) && (VARIOUS_L & EENV_DED)) || (g_NvramUser.Revision != C_NVRAM_USER_REV) || (NVRAM_CRC8( FALSE) != 0xFF) || (g_NvramUser.ConfigurationID != CONFIGURATION_ID) )
    9b94:	7207      	lod	A, [S-8]
    9b96:	1d03      	jne	0x9b9e <_NVRAM_LoadUserPage+0x58>
    9b98:	6280      	lod	AL, io:0x0 <__dp__>
    9b9a:	8c00      	cmp	AL, #0
    9b9c:	1a8c      	jsl	0x9bb6 <_NVRAM_LoadUserPage+0x70>
    9b9e:	615b      	lod	AL, dp:0x5b <_g_NvramUser+0x1>
    9ba0:	8c01      	cmp	AL, #1
    9ba2:	1d09      	jne	0x9bb6 <_NVRAM_LoadUserPage+0x70>
    9ba4:	7000      	lod	A, #0
    9ba6:	1702      	call	0x99ac <_NVRAM_CRC8>
    9ba8:	8cff      	cmp	AL, #-1
    9baa:	1d05      	jne	0x9bb6 <_NVRAM_LoadUserPage+0x70>
    9bac:	7162      	lod	A, dp:0x62 <_g_NvramUser+0x8>
    9bae:	aeda 5467 	cmp	A, #21607
    9bb2:	1d01      	jne	0x9bb6 <_NVRAM_LoadUserPage+0x70>
    9bb4:	006d      	jmp	0x9c90 <_NVRAM_LoadUserPage+0x14a>
	/* Check Double-Bit Error NVRAM, Wrong revision or Invalid Checksum */
	if ( u16ErrorFlag )
	{
		/* Double-bit error or incorrect revision or Invalid CRC; Copy NVRAM user page 2 into UserRAM */
		/* Note: EENV_DED can't be cleared !! In case of first user-page DBE, a second-page DBE can't be detected */
		u16ErrorFlag = (VARIOUS_L & EENV_DED);
    9bb6:	6280      	lod	AL, io:0x0 <__dp__>
    9bb8:	7ae2      	lod	Y, A
    9bba:	f6da 0080 	and	Y, #128
    9bbe:	5a07      	mov	[S-8], Y

#if (LINPROT == LIN2J_VALVE_GM)
		if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
    9bc0:	7ada 101e 	lod	Y, #4126
    9bc4:	66f0      	lod	YL, [Y]
    9bc6:	f6da 0080 	and	Y, #128
    9bca:	7ee6      	lod	X, Y
    9bcc:	7ada 111e 	lod	Y, #4382
    9bd0:	62f0      	lod	AL, [Y]
    9bd2:	b6da 0080 	and	A, #128
    9bd6:	2ee2      	cmp	X, A
    9bd8:	1904      	je	0x9be2 <_NVRAM_LoadUserPage+0x9c>
			pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    9bda:	7eda 1000 	lod	X, #4096
    9bde:	5e03      	mov	[S-4], X
    9be0:	0003      	jmp	0x9be8 <_NVRAM_LoadUserPage+0xa2>
		else
			pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    9be2:	7ada 1100 	lod	Y, #4352
    9be6:	5a03      	mov	[S-4], Y
#else  /* (LINPROT == LIN2J_VALVE_GM) */
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
#endif /* (LINPROT == LIN2J_VALVE_GM) */
		pURAM = (uint16 *) &g_NvramUser;
    9be8:	7eda 005a 	lod	X, #90
    9bec:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    9bee:	7e05      	lod	X, [S-6]
    9bf0:	7a03      	lod	Y, [S-4]
    9bf2:	54c6      	movsw	[X++], [Y++]
    9bf4:	5a03      	mov	[S-4], Y
    9bf6:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9bf8:	2eda 00ca 	cmp	X, #202
    9bfc:	1878      	jc	0x9bee <_NVRAM_LoadUserPage+0xa8>
		if ( ((u16ErrorFlag != FALSE) || ((VARIOUS_L & EENV_DED) == 0)) && (g_NvramUser.Revision == C_NVRAM_USER_REV) && (NVRAM_CRC8( FALSE) == 0xFF) && (g_NvramUser.ConfigurationID == CONFIGURATION_ID) )
    9bfe:	7207      	lod	A, [S-8]
    9c00:	1d03      	jne	0x9c08 <_NVRAM_LoadUserPage+0xc2>
    9c02:	6280      	lod	AL, io:0x0 <__dp__>
    9c04:	8c00      	cmp	AL, #0
    9c06:	1a92      	jsl	0x9c2c <_NVRAM_LoadUserPage+0xe6>
    9c08:	615b      	lod	AL, dp:0x5b <_g_NvramUser+0x1>
    9c0a:	8c01      	cmp	AL, #1
    9c0c:	1d0f      	jne	0x9c2c <_NVRAM_LoadUserPage+0xe6>
    9c0e:	7000      	lod	A, #0
    9c10:	16cd      	call	0x99ac <_NVRAM_CRC8>
    9c12:	8cff      	cmp	AL, #-1
    9c14:	1d0b      	jne	0x9c2c <_NVRAM_LoadUserPage+0xe6>
    9c16:	7162      	lod	A, dp:0x62 <_g_NvramUser+0x8>
    9c18:	aeda 5467 	cmp	A, #21607
    9c1c:	1d07      	jne	0x9c2c <_NVRAM_LoadUserPage+0xe6>
		{
			/* Second User Page is correct; Rewrite 1st page */
			SetLastError( (uint8) C_ERR_INV_USERPAGE_1);
    9c1e:	72da 00c0 	lod	A, #192
    9c22:	82db 8c66 	callf	0x8c66 <_SetLastError>
			(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_1 | C_NVRAM_USER_PAGE_FORCE));
    9c26:	7041      	lod	A, #65
    9c28:	1709      	call	0x9a3c <_NVRAM_Store>
			u16ErrorFlag = FALSE;
    9c2a:	5409      	ret	#10
#if (MOTOR_PARAMS == MP_NVRAM)
#if (_SUPPORT_CODE_PARAMS == FALSE)
	if ( u16ErrorFlag )
	{
		/* First and/or second page is corrupt; Log error and use default data */
		SetLastError( (uint8) C_ERR_INV_USERPAGE_BOTH);
    9c2c:	72da 00c2 	lod	A, #194
    9c30:	82db 8c66 	callf	0x8c66 <_SetLastError>
#else  /* (_SUPPORT_CODE_PARAMS == FALSE) */
		/* Always use hard-coded NVRAM value to be re-written in RAM-structure */
#endif /* (_SUPPORT_CODE_PARAMS == FALSE) */

		/* UniROM */
		pMRAM = (uint16 *) &defNvramUser;
    9c34:	7ada a52e 	lod	Y, #42286
    9c38:	5a03      	mov	[S-4], Y
		pURAM = (uint16 *) &g_NvramUser;
    9c3a:	7eda 005a 	lod	X, #90
    9c3e:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    9c40:	7e05      	lod	X, [S-6]
    9c42:	7a03      	lod	Y, [S-4]
    9c44:	54c6      	movsw	[X++], [Y++]
    9c46:	5a03      	mov	[S-4], Y
    9c48:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    9c4a:	2eda 00ca 	cmp	X, #202
    9c4e:	1878      	jc	0x9c40 <_NVRAM_LoadUserPage+0xfa>

#if (_SUPPORT_CODE_PARAMS == FALSE)
		{
			PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    9c50:	7ada 1070 	lod	Y, #4208
    9c54:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFF )				/* Check NVRAM User Page #1 Write-cycle counter CRC */
    9c56:	54ca 0000 	pushw	#0
    9c5a:	72da 1070 	lod	A, #4208
    9c5e:	16bf      	call	0x99de <_NVRAM_CountCRC8>
    9c60:	5c01      	dec	S, #2
    9c62:	8cff      	cmp	AL, #-1
    9c64:	1904      	je	0x9c6e <_NVRAM_LoadUserPage+0x128>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0;						/* Clear program cycle-counter */
    9c66:	7000      	lod	A, #0
    9c68:	7e01      	lod	X, [S-2]
    9c6a:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0;							/* Clear Error-log index & CRC */
    9c6c:	52fa      	mov	[X+2], A
			}
			pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
    9c6e:	7ada 1170 	lod	Y, #4464
    9c72:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFF )				/* Check NVRAM User Page #2 Write-cycle counter CRC */
    9c74:	54ca 0000 	pushw	#0
    9c78:	72da 1170 	lod	A, #4464
    9c7c:	16b0      	call	0x99de <_NVRAM_CountCRC8>
    9c7e:	5c01      	dec	S, #2
    9c80:	8cff      	cmp	AL, #-1
    9c82:	1904      	je	0x9c8c <_NVRAM_LoadUserPage+0x146>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0;						/* Clear program cycle-counter */
    9c84:	7000      	lod	A, #0
    9c86:	7e01      	lod	X, [S-2]
    9c88:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0;							/* Clear Error-log index & CRC */
    9c8a:	52fa      	mov	[X+2], A
			}
		}
		(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_ALL | C_NVRAM_USER_PAGE_FORCE));	/* Write (both) user page(s) with default data */
    9c8c:	7043      	lod	A, #67
    9c8e:	16d6      	call	0x9a3c <_NVRAM_Store>
    9c90:	5409      	ret	#10

00009c92 <_PlaceError>:
 *			u8ErrorCode: Error-code
 *	Post:	-
 *	Comments: Write error-code into NVRAM (16-bits words based)
 * ****************************************************************************	*/
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode)
{
    9c92:	5801      	inc	S, #2
    9c94:	7ee2      	lod	X, A
    9c96:	6207      	lod	AL, [S-8]
    9c98:	66e0      	lod	YL, AL
    9c9a:	5cf6      	usex	Y
    9c9c:	72f8      	lod	A, [X]
    9c9e:	5201      	mov	[S-2], A
	if ( u16OddEven )
    9ca0:	7205      	lod	A, [S-6]
    9ca2:	1905      	je	0x9cae <_PlaceError+0x1c>
	{
		/* Odd index: MSB of uint16 */
		*pu16ErrorElement = (uint8)(*pu16ErrorElement) | (((uint16) u8ErrorCode) << 8);
    9ca4:	6201      	lod	AL, [S-2]
    9ca6:	5cf2      	usex	A
    9ca8:	6c00      	lod	YH, #0
    9caa:	7ae8      	swap	Y
    9cac:	0003      	jmp	0x9cb4 <_PlaceError+0x22>
	}
	else
	{
		/* Even index: LSB of uint16 */
		*pu16ErrorElement = (*pu16ErrorElement & 0xFF00) | ((uint16) u8ErrorCode);
    9cae:	7201      	lod	A, [S-2]
    9cb0:	b6da ff00 	and	A, #65280
    9cb4:	a6e6      	or	A, Y
    9cb6:	52f8      	mov	[X], A
    9cb8:	5403      	ret	#4

00009cba <_NVRAM_LogError>:
 *	result is either 0 or 1, indicating which page should be written next-time.
 * Index at user-page #1/#2: 0-11: Empty/over-write index, FF: Full
 * If index user-page #1 is not 0xFF (Full), write error at page #1, otherwise page #2
 * ****************************************************************************	*/
uint16 NVRAM_LogError( uint8 u8ErrorCode)
{
    9cba:	5807      	inc	S, #8
    9cbc:	5207      	mov	[S-8], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    9cbe:	7000      	lod	A, #0
    9cc0:	5205      	mov	[S-6], A
	PNVRAM_ERRORLOG pNVERRLOG_UPG1 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
	PNVRAM_ERRORLOG pNVERRLOG_UPG2 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
	uint16 u16ErrorLogIdx1 = (uint8) (pNVERRLOG_UPG1->ErrorLogIndex_CRC);
    9cc2:	7ada 1070 	lod	Y, #4208
    9cc6:	72f2      	lod	A, [Y+2]
    9cc8:	5cf2      	usex	A
    9cca:	5203      	mov	[S-4], A
	uint16 u16ErrorLogIdx2 = (uint8) (pNVERRLOG_UPG2->ErrorLogIndex_CRC);
    9ccc:	7ada 1170 	lod	Y, #4464
    9cd0:	72f2      	lod	A, [Y+2]
    9cd2:	5cf2      	usex	A
    9cd4:	5201      	mov	[S-2], A
	
	if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x00 )
    9cd6:	7203      	lod	A, [S-4]
    9cd8:	be01      	xor	A, [S-2]
    9cda:	1d03      	jne	0x9ce2 <_NVRAM_LogError+0x28>
	{
		u16ErrorLogIdx1 = 0x00;													/* Second UserPage last time written full; Start from index 0 at User Page #1 */
    9cdc:	7000      	lod	A, #0
    9cde:	5203      	mov	[S-4], A
    9ce0:	0004      	jmp	0x9cea <_NVRAM_LogError+0x30>
	}
	else if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x01 )
    9ce2:	ac01      	cmp	A, #1
    9ce4:	1d02      	jne	0x9cea <_NVRAM_LogError+0x30>
	{
		u16ErrorLogIdx2 = 0x00;
    9ce6:	7800      	lod	Y, #0
    9ce8:	5a01      	mov	[S-2], Y
	}
	
	if ( (u16ErrorLogIdx1 & 0x80) == 0x00 )
    9cea:	6203      	lod	AL, [S-4]
    9cec:	8c00      	cmp	AL, #0
    9cee:	1e81      	jsge	0x9cf2 <_NVRAM_LogError+0x38>
    9cf0:	0046      	jmp	0x9d7e <_NVRAM_LogError+0xc4>
	{
		/* Store error on User-Page #1 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx1 >= C_MAX_ERRORS_PER_PAGE )							/* Check against array overflow */
    9cf2:	7a03      	lod	Y, [S-4]
    9cf4:	ec0b      	cmp	Y, #11
    9cf6:	1a02      	jule	0x9cfc <_NVRAM_LogError+0x42>
		{
			u16ErrorLogIdx1 = 0;
    9cf8:	7000      	lod	A, #0
    9cfa:	5203      	mov	[S-4], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG1, FALSE) == 0x00 )
    9cfc:	54ca 0000 	pushw	#0
    9d00:	72da 1070 	lod	A, #4208
    9d04:	166c      	call	0x99de <_NVRAM_CountCRC8>
    9d06:	5c01      	dec	S, #2
    9d08:	8c00      	cmp	AL, #0
    9d0a:	1d05      	jne	0x9d16 <_NVRAM_LogError+0x5c>
		{
			pNVERRLOG_UPG1->NvramProgramCycleCount++;
    9d0c:	7ada 1070 	lod	Y, #4208
    9d10:	72f0      	lod	A, [Y]
    9d12:	a001      	add	A, #1
    9d14:	0003      	jmp	0x9d1c <_NVRAM_LogError+0x62>
		}
		else
		{
			pNVERRLOG_UPG1->NvramProgramCycleCount = 1U;
    9d16:	7001      	lod	A, #1
    9d18:	7ada 1070 	lod	Y, #4208
    9d1c:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End */
		if ( pNVERRLOG_UPG1->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000) )
    9d1e:	7ada 1070 	lod	Y, #4208
    9d22:	72f0      	lod	A, [Y]
    9d24:	aeda f9ff 	cmp	A, #63999
    9d28:	1a01      	jule	0x9d2c <_NVRAM_LogError+0x72>
    9d2a:	0068      	jmp	0x9dfc <_NVRAM_LogError+0x142>
		{
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG1, TRUE);
    9d2c:	54ca 0001 	pushw	#1
    9d30:	72da 1070 	lod	A, #4208
    9d34:	1654      	call	0x99de <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG1->ErrorLog[u16ErrorLogIdx1 >> 1]), u16ErrorLogIdx1 & 0x01, u8ErrorCode);
    9d36:	7205      	lod	A, [S-6]
    9d38:	b4fe      	and	A, #-2
    9d3a:	a2da 1074 	add	A, #4212
    9d3e:	7a09      	lod	Y, [S-10]
    9d40:	5adf      	push	Y
    9d42:	7a07      	lod	Y, [S-8]
    9d44:	f401      	and	Y, #1
    9d46:	5adf      	push	Y
    9d48:	17a4      	call	0x9c92 <_PlaceError>
			/* Update Error-log Index */
			u16ErrorLogIdx1++;
    9d4a:	7209      	lod	A, [S-10]
    9d4c:	a001      	add	A, #1
    9d4e:	5209      	mov	[S-10], A
			if ( u16ErrorLogIdx1 >= C_MAX_ERRORS_PER_PAGE )
    9d50:	5c05      	dec	S, #6
    9d52:	ac0b      	cmp	A, #11
    9d54:	1a0a      	jule	0x9d6a <_NVRAM_LogError+0xb0>
			{
				/* Array full; Switch to page #2 */
				if ( u16ErrorLogIdx2 & 0x80 )
    9d56:	6201      	lod	AL, [S-2]
    9d58:	8c00      	cmp	AL, #0
    9d5a:	1e84      	jsge	0x9d64 <_NVRAM_LogError+0xaa>
				{
					u16ErrorLogIdx1 = (u16ErrorLogIdx2 ^ 0x01);
    9d5c:	7a01      	lod	Y, [S-2]
    9d5e:	fc01      	xor	Y, #1
    9d60:	5a03      	mov	[S-4], Y
    9d62:	0003      	jmp	0x9d6a <_NVRAM_LogError+0xb0>
				}
				else
				{
					u16ErrorLogIdx1 = 0xFF;
    9d64:	72da 00ff 	lod	A, #255
    9d68:	5203      	mov	[S-4], A
				}
			}
			pNVERRLOG_UPG1->ErrorLogIndex_CRC = ((pNVERRLOG_UPG1->ErrorLogIndex_CRC) & 0xFF00) | u16ErrorLogIdx1;
    9d6a:	7ada 1070 	lod	Y, #4208
    9d6e:	72f2      	lod	A, [Y+2]
    9d70:	b6da ff00 	and	A, #65280
    9d74:	a603      	or	A, [S-4]
    9d76:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM1_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    9d78:	72da 8000 	lod	A, #32768
    9d7c:	003c      	jmp	0x9df6 <_NVRAM_LogError+0x13c>
		}
	}
	else 
	{
		/* Store error on User-Page #2 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx2 >= C_MAX_ERRORS_PER_PAGE )							/* Check against array overflow */
    9d7e:	7a01      	lod	Y, [S-2]
    9d80:	ec0b      	cmp	Y, #11
    9d82:	1a02      	jule	0x9d88 <_NVRAM_LogError+0xce>
		{
			u16ErrorLogIdx2 = 0;
    9d84:	7000      	lod	A, #0
    9d86:	5201      	mov	[S-2], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG2, FALSE) == 0x00 )
    9d88:	54ca 0000 	pushw	#0
    9d8c:	72da 1170 	lod	A, #4464
    9d90:	1626      	call	0x99de <_NVRAM_CountCRC8>
    9d92:	5c01      	dec	S, #2
    9d94:	8c00      	cmp	AL, #0
    9d96:	1d05      	jne	0x9da2 <_NVRAM_LogError+0xe8>
		{
			pNVERRLOG_UPG2->NvramProgramCycleCount++;
    9d98:	7ada 1170 	lod	Y, #4464
    9d9c:	72f0      	lod	A, [Y]
    9d9e:	a001      	add	A, #1
    9da0:	0003      	jmp	0x9da8 <_NVRAM_LogError+0xee>
		}
		else
		{
			pNVERRLOG_UPG2->NvramProgramCycleCount = 1U;
    9da2:	7001      	lod	A, #1
    9da4:	7ada 1170 	lod	Y, #4464
    9da8:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End  */
		if ( pNVERRLOG_UPG2->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000) )
    9daa:	7ada 1170 	lod	Y, #4464
    9dae:	72f0      	lod	A, [Y]
    9db0:	aeda f9ff 	cmp	A, #63999
    9db4:	1e23      	jug	0x9dfc <_NVRAM_LogError+0x142>
		{
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG2, TRUE);
    9db6:	54ca 0001 	pushw	#1
    9dba:	72da 1170 	lod	A, #4464
    9dbe:	160f      	call	0x99de <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG2->ErrorLog[u16ErrorLogIdx2 >> 1]), u16ErrorLogIdx2 & 0x01, u8ErrorCode);
    9dc0:	7203      	lod	A, [S-4]
    9dc2:	b4fe      	and	A, #-2
    9dc4:	a2da 1174 	add	A, #4468
    9dc8:	7a09      	lod	Y, [S-10]
    9dca:	5adf      	push	Y
    9dcc:	7a05      	lod	Y, [S-6]
    9dce:	f401      	and	Y, #1
    9dd0:	5adf      	push	Y
    9dd2:	175f      	call	0x9c92 <_PlaceError>
			/* Update Error-log Index */
			u16ErrorLogIdx2++;
    9dd4:	7207      	lod	A, [S-8]
    9dd6:	a001      	add	A, #1
    9dd8:	5207      	mov	[S-8], A
			if ( u16ErrorLogIdx2 >= C_MAX_ERRORS_PER_PAGE )
    9dda:	5c05      	dec	S, #6
    9ddc:	ac0b      	cmp	A, #11
    9dde:	1a02      	jule	0x9de4 <_NVRAM_LogError+0x12a>
			{
				/* Array full; Switch to page #1  */
				u16ErrorLogIdx2 = u16ErrorLogIdx1;
    9de0:	7a03      	lod	Y, [S-4]
    9de2:	5a01      	mov	[S-2], Y
			}
			pNVERRLOG_UPG2->ErrorLogIndex_CRC = ((pNVERRLOG_UPG2->ErrorLogIndex_CRC) & 0xFF00) | u16ErrorLogIdx2;
    9de4:	7ada 1170 	lod	Y, #4464
    9de8:	72f2      	lod	A, [Y+2]
    9dea:	b6da ff00 	and	A, #65280
    9dee:	a601      	or	A, [S-2]
    9df0:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    9df2:	72da 8002 	lod	A, #32770
    9df6:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
    9dfa:	0002      	jmp	0x9e00 <_NVRAM_LogError+0x146>
		}
		else
		{
			u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
    9dfc:	7001      	lod	A, #1
    9dfe:	5205      	mov	[S-6], A
		}
	}
	return ( u16Result );														/* MMP150219-1 */
} /* End of NVRAM_LogError() */
    9e00:	7205      	lod	A, [S-6]
    9e02:	5409      	ret	#10

00009e04 <_NVRAM_GetLastError>:
 *
 *	Pre:	-
 *	Post:	(uint8) Last logged error-code
 * ****************************************************************************	*/
uint8 NVRAM_GetLastError( void)
{
    9e04:	5803      	inc	S, #4
	uint16 u16ErrorLogIdx1, u16ErrorLogIdx2;
	uint8 u8Result = 0x00;														/* No error's */
    9e06:	7000      	lod	A, #0
    9e08:	5201      	mov	[S-2], A
	PNVRAM_ERRORLOG pNVERRLOG_UPG1 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    9e0a:	7ada 1070 	lod	Y, #4208
	PNVRAM_ERRORLOG pNVERRLOG_UPG2 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
	u16ErrorLogIdx1 = (uint8) (pNVERRLOG_UPG1->ErrorLogIndex_CRC);
    9e0e:	72f2      	lod	A, [Y+2]
    9e10:	5cf2      	usex	A
    9e12:	7ee2      	lod	X, A
	u16ErrorLogIdx2 = (uint8) (pNVERRLOG_UPG2->ErrorLogIndex_CRC);
    9e14:	7ada 1170 	lod	Y, #4464
    9e18:	72f2      	lod	A, [Y+2]
    9e1a:	5cf2      	usex	A
    9e1c:	5203      	mov	[S-4], A

	if ( (u16ErrorLogIdx1 != 0x00) || (u16ErrorLogIdx2 != 0x00) )
    9e1e:	2c00      	cmp	X, #0
    9e20:	1d02      	jne	0x9e26 <_NVRAM_GetLastError+0x22>
    9e22:	ac00      	cmp	A, #0
    9e24:	192b      	je	0x9e7c <_NVRAM_GetLastError+0x78>
	{
		if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x00 )
    9e26:	7203      	lod	A, [S-4]
    9e28:	beee      	xor	A, X
    9e2a:	1d03      	jne	0x9e32 <_NVRAM_GetLastError+0x2e>
		{
			u16ErrorLogIdx2 = C_MAX_ERRORS_PER_PAGE;								/* Second UserPage last time written full */
    9e2c:	700c      	lod	A, #12
    9e2e:	5203      	mov	[S-4], A
    9e30:	0008      	jmp	0x9e42 <_NVRAM_GetLastError+0x3e>
		}
		else if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x01 )
    9e32:	ac01      	cmp	A, #1
    9e34:	1905      	je	0x9e40 <_NVRAM_GetLastError+0x3c>
		{
			u16ErrorLogIdx1 = C_MAX_ERRORS_PER_PAGE;								/* First UserPage last time written full, and Second UserPage is full */
		}
		else if ( (u16ErrorLogIdx1 == 0xFF) && (u16ErrorLogIdx2 == 0) )				/* MMP140218-1 */
    9e36:	2eda 00ff 	cmp	X, #255
    9e3a:	1d03      	jne	0x9e42 <_NVRAM_GetLastError+0x3e>
    9e3c:	7a03      	lod	Y, [S-4]
    9e3e:	1d01      	jne	0x9e42 <_NVRAM_GetLastError+0x3e>
		{
			u16ErrorLogIdx1 = C_MAX_ERRORS_PER_PAGE;								/* First UserPage last time written full, and Second UserPage is empty */
    9e40:	7c0c      	lod	X, #12
		}																			/* MMP140218-1 */

		if ( (u16ErrorLogIdx1 & 0x80) == 0x00 )
    9e42:	72ee      	lod	A, X
    9e44:	8c00      	cmp	AL, #0
    9e46:	1a89      	jsl	0x9e5a <_NVRAM_GetLastError+0x56>
		{
			/* Get last error from User-Page #1 */
			u16ErrorLogIdx1--;
    9e48:	20ff      	add	X, #-1
			{
				uint16 u16ErrorCodes = pNVERRLOG_UPG1->ErrorLog[u16ErrorLogIdx1 >> 1];
    9e4a:	72ee      	lod	A, X
    9e4c:	b4fe      	and	A, #-2
    9e4e:	7ae2      	lod	Y, A
    9e50:	e2da 1074 	add	Y, #4212
    9e54:	7af0      	lod	Y, [Y]
				if ( u16ErrorLogIdx1 & 0x01 )
    9e56:	72ee      	lod	A, X
    9e58:	000a      	jmp	0x9e6e <_NVRAM_GetLastError+0x6a>
			}
		}
		else
		{
			/* Get last error from User-Page #2 */
			u16ErrorLogIdx2--;
    9e5a:	7a03      	lod	Y, [S-4]
    9e5c:	e0ff      	add	Y, #-1
    9e5e:	5a03      	mov	[S-4], Y
			{
				uint16 u16ErrorCodes = pNVERRLOG_UPG2->ErrorLog[u16ErrorLogIdx2 >> 1];
    9e60:	72e6      	lod	A, Y
    9e62:	b4fe      	and	A, #-2
    9e64:	7ae2      	lod	Y, A
    9e66:	e2da 1174 	add	Y, #4468
    9e6a:	7af0      	lod	Y, [Y]
				if ( u16ErrorLogIdx2 & 0x01 )
    9e6c:	7203      	lod	A, [S-4]
    9e6e:	b401      	and	A, #1
    9e70:	1903      	je	0x9e78 <_NVRAM_GetLastError+0x74>
				{
					u8Result = (uint8) (u16ErrorCodes >> 8);
    9e72:	6400      	lod	YL, #0
    9e74:	7ae8      	swap	Y
    9e76:	0001      	jmp	0x9e7a <_NVRAM_GetLastError+0x76>
				}
				else
				{
					u8Result = (uint8) u16ErrorCodes;
    9e78:	5cf6      	usex	Y
    9e7a:	5a01      	mov	[S-2], Y
			}
		}
	}
	return( u8Result );

} /* End of NVRAM_GetLastError() */
    9e7c:	7201      	lod	A, [S-2]
    9e7e:	5405      	ret	#6

00009e80 <_NVRAM_ClearErrorLog>:
 *	Comments: Clear Application Error logging (in both User-NVRAM pages)
 * ****************************************************************************	*/
void NVRAM_ClearErrorLog( void)
{
	uint16 i;
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    9e80:	7ada 1070 	lod	Y, #4208
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00) | 0x00;	/* Set index at 0x00 */
    9e84:	72f2      	lod	A, [Y+2]
    9e86:	b6da ff00 	and	A, #65280
    9e8a:	52f2      	mov	[Y+2], A
    9e8c:	7ada 1074 	lod	Y, #4212
    9e90:	7c06      	lod	X, #6
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE/2); i++ )
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000;
    9e92:	7000      	lod	A, #0
    9e94:	52d6      	mov	[Y++], A
    9e96:	1bfd      	djnz	X, 0x9e92 <_NVRAM_ClearErrorLog+0x12>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    9e98:	54ca 0001 	pushw	#1
    9e9c:	72da 1070 	lod	A, #4208
    9ea0:	159e      	call	0x99de <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM1_PAGE1);
    9ea2:	7000      	lod	A, #0
    9ea4:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

	pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
    9ea8:	7ada 1170 	lod	Y, #4464
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00) | 0x00;	/* Set index at 0x00 */
    9eac:	72f2      	lod	A, [Y+2]
    9eae:	b6da ff00 	and	A, #65280
    9eb2:	52f2      	mov	[Y+2], A
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE/2); i++ )
    9eb4:	5c01      	dec	S, #2
    9eb6:	7ada 1174 	lod	Y, #4468
    9eba:	7c06      	lod	X, #6
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000;
    9ebc:	7000      	lod	A, #0
    9ebe:	52d6      	mov	[Y++], A
    9ec0:	1bfd      	djnz	X, 0x9ebc <_NVRAM_ClearErrorLog+0x3c>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    9ec2:	54ca 0001 	pushw	#1
    9ec6:	72da 1170 	lod	A, #4464
    9eca:	1589      	call	0x99de <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM2_PAGE1);
    9ecc:	7002      	lod	A, #2
    9ece:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
    9ed2:	5c01      	dec	S, #2
    9ed4:	5401      	ret

00009ed6 <_NVRAM_StorePatch>:
 * C_ADDR_PATCHPAGE+0x7A:0x7B:	PATCH3_A
 *
 * ****************************************************************************	*/
void NVRAM_StorePatch( void)
{
	NVRAM_SavePage( NVRAM1_PAGE2);
    9ed6:	7001      	lod	A, #1
    9ed8:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
	NVRAM_LoadUserPage();
    9edc:	1634      	call	0x9b46 <_NVRAM_LoadUserPage>
    9ede:	5401      	ret

00009ee0 <_NVRAM_MlxCalibrationAreaCheck>:
 *	Post:	-
 * Comments: Check Melexis NVRAM-page gain-factors (non-zero)
 * ****************************************************************************	*/
void NVRAM_MlxCalibrationAreaCheck( void)
{
	if ( (EE_GLAA == 0) ||														/* Auto addressing gain calibration */
    9ee0:	72d8 11d6 	lod	A, 0x11d6 <__ep__+0x1d6>
    9ee4:	1913      	je	0x9f0c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9ee6:	72d8 11d8 	lod	A, 0x11d8 <__ep__+0x1d8>
    9eea:	1910      	je	0x9f0c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9eec:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    9ef0:	b6da 00ff 	and	A, #255
    9ef4:	aeda ff00 	cmp	A, #65280
    9ef8:	1909      	je	0x9f0c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9efa:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9efe:	6000      	lod	AL, #0
    9f00:	72e4      	swap	A
    9f02:	1904      	je	0x9f0c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    9f04:	72d8 11ca 	lod	A, 0x11ca <__ep__+0x1ca>
    9f08:	8c00      	cmp	AL, #0
    9f0a:	1d04      	jne	0x9f14 <_NVRAM_MlxCalibrationAreaCheck+0x34>
		 (EE_GDMCMAA == 0) ||													/* Common Mode Rejection factor */
		 (EE_GMCURR == 0) ||													/* CGAINCAL_FLT (Current sensor filter gain) */
		 (EE_GVOLTAGE == 0) ||													/* VGAINCAL (supply sensor filter gain) */
		 (EE_GTEMP == 0) )														/* Temperature Gain */
	{
		SetLastError( (uint8) C_ERR_NVRAM_MLX_CAL_GN);
    9f0c:	72da 00cf 	lod	A, #207
    9f10:	82db 8c66 	callf	0x8c66 <_SetLastError>
    9f14:	5401      	ret

00009f16 <_PID_Init>:

/* ***
 * PID_Init()
 * ***/
void PID_Init( void)
{
    9f16:	5813      	inc	S, #20
	/* MMP141209-1: Convert [mA] to [ADC-lsb] */
	uint16 u16MCurrgain = EE_GMCURR;
    9f18:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    9f1c:	b6da 00ff 	and	A, #255
    9f20:	7ee2      	lod	X, A
    9f22:	22da 0100 	add	X, #256
	g_u16PidHoldingThreshold = NVRAM_HOLDING_CURR_LEVEL;
    9f26:	61a8      	lod	AL, dp:0xa8 <_g_NvramUser+0x4e>
    9f28:	5cf2      	usex	A
    9f2a:	52d8 0326 	mov	0x326 <_g_u16PidHoldingThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9f2e:	7ada 0080 	lod	Y, #128
    9f32:	4821      	mulu	YA, A, Y
    9f34:	4c63      	divu	YA, X
    9f36:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f38:	52d8 032a 	mov	0x32a <_g_u16PidHoldingThresholdADC>, A
	g_u16PidHoldingThresholdADC = muldivU16_U16byU16byU16( g_u16PidHoldingThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1 */
	g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL;
    9f3c:	61a9      	lod	AL, dp:0xa9 <_g_NvramUser+0x4f>
    9f3e:	4422      	asl	A
    9f40:	b6da 01fe 	and	A, #510
    9f44:	52d8 0322 	mov	0x322 <_g_u16PidRunningThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9f48:	7ada 0080 	lod	Y, #128
    9f4c:	4821      	mulu	YA, A, Y
    9f4e:	4c63      	divu	YA, X
    9f50:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f52:	52d8 0324 	mov	0x324 <_g_u16PidRunningThresholdADC>, A
	g_u16PidRunningThresholdADC = muldivU16_U16byU16byU16( g_u16PidRunningThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1/MMP131219-1 */
	g_u16MotorRefVoltage = NVRAM_VSUP_REF;
    9f56:	618b      	lod	AL, dp:0x8b <_g_NvramUser+0x31>
    9f58:	5cf2      	usex	A
    9f5a:	4872 0019 	muls	A, A, #25
    9f5e:	4432      	lsr	A
    9f60:	5205      	mov	[S-6], A
    9f62:	52d8 0142 	mov	0x142 <_g_u16MotorRefVoltage>, A
    9f66:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9f6a:	6000      	lod	AL, #0
    9f6c:	72e4      	swap	A
    9f6e:	5203      	mov	[S-4], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9f70:	7040      	lod	A, #64
    9f72:	7a05      	lod	Y, [S-6]
    9f74:	7e03      	lod	X, [S-4]
    9f76:	4821      	mulu	YA, A, Y
    9f78:	4c63      	divu	YA, X
    9f7a:	4c63      	divu	YA, X
    9f7c:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f7e:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9f82:	5ce2      	ssex	A
    9f84:	a201      	add	A, [S-2]
    9f86:	52d8 0140 	mov	0x140 <_l_u16MotorRefVoltageADC>, A
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GVOLTAGE) + EE_OVOLTAGE;
#else  /* _SUPPORT_VSMFILTERED */
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GADC) + EE_OADC;
#endif /* _SUPPORT_VSMFILTERED */

	l_u16MinCorrectionRatio = NVRAM_MIN_CORR_RATIO;								/* MMP150509-2 */
    9f8a:	61be      	lod	AL, dp:0xbe <__bss_dp_size+0xe>
    9f8c:	5cf2      	usex	A
    9f8e:	4812 0576 	muls	D, A, #1398
    9f92:	7aef      	lod	Y, S
    9f94:	e0f2      	add	Y, #-14
    9f96:	4c85      	mov	[Y], D
    9f98:	720d      	lod	A, [S-14]
    9f9a:	7a0b      	lod	Y, [S-12]
    9f9c:	48a3      	lsr	YA, #4
    9f9e:	52d8 032c 	mov	0x32c <_l_u16MinCorrectionRatio>, A
	l_u16MaxCorrectionRatio = NVRAM_MAX_CORR_RATIO;								/* MMP150509-2 */
    9fa2:	61bf      	lod	AL, dp:0xbf <__bss_dp_size+0xf>
    9fa4:	5cf2      	usex	A
    9fa6:	a001      	add	A, #1
    9fa8:	4812 0576 	muls	D, A, #1398
    9fac:	7aef      	lod	Y, S
    9fae:	e0f6      	add	Y, #-10
    9fb0:	4c85      	mov	[Y], D
    9fb2:	7209      	lod	A, [S-10]
    9fb4:	7a07      	lod	Y, [S-8]
    9fb6:	48a3      	lsr	YA, #4
    9fb8:	52d8 032e 	mov	0x32e <_l_u16MaxCorrectionRatio>, A
    9fbc:	5415      	ret	#22

00009fbe <_VoltageCorrection>:
 *
 *	Compensate Motor PWM Duty Cycle for voltage changes
 * Performance: 7.5us @ 20Mz
 * ***/
void VoltageCorrection( void)
{
    9fbe:	5801      	inc	S, #2

#define ADC_SETTING (uint16)(((2U*PLL_freq)/(1000000U*2*CYCLES_PER_INSTR)) + 1)	/* 2us: 2us*PLL-freq/(10000000us/s * #cycles/instruction) */

static INLINE uint16 GetRawVsupplyMotor( void)
{
extern T_ADC_MOTORRUN_STEPPER4 volatile g_AdcMotorRunStepper4;					/* ADC results Stepper mode */
    9fc0:	7ed8 025e 	lod	X, 0x25e <_g_AdcMotorRunStepper4+0x6>
	uint16 u16MotorVoltageADC = GetRawVsupplyMotor();
#if _DEBUG_VOLTAGE_COMPENSATION
	l_ai16MotorVolt[u16MotorVoltIdx] = g_i16MotorVoltage;
	u16MotorVoltIdx = (u16MotorVoltIdx + 1) & (SZ_MOTOR_VOLT_COMP - 1);
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	if ( (u16MotorVoltageADC > 0) && (l_u16MotorRefVoltageADC > 0) )
    9fc4:	1920      	je	0xa006 <_VoltageCorrection+0x48>
    9fc6:	7ad8 0140 	lod	Y, 0x140 <_l_u16MotorRefVoltageADC>
    9fca:	191d      	je	0xa006 <_VoltageCorrection+0x48>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    9fcc:	72d8 0320 	lod	A, 0x320 <_g_u16PidCtrlRatio>
    uint32 result;

    __asm__ __volatile__ (
    9fd0:	4801      	mulu	D, A, Y
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9fd2:	4c80      	mov	YA, D
    9fd4:	4c63      	divu	YA, X
    9fd6:	4c63      	divu	YA, X
    9fd8:	7ee2      	lod	X, A
	{
		/* Correct Motor PWM duty cycle instantly based on change of supply voltage */
		uint16 u16NewCorrectionRatio = divU16_U32byU16( mulU32_U16byU16( g_u16PidCtrlRatio, l_u16MotorRefVoltageADC), u16MotorVoltageADC);
		if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    9fda:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    9fdc:	b401      	and	A, #1
    9fde:	1909      	je	0x9ff2 <_VoltageCorrection+0x34>
		{
			if ( u16NewCorrectionRatio < l_u16MinCorrectionRatio )
    9fe0:	72d8 032c 	lod	A, 0x32c <_l_u16MinCorrectionRatio>
    9fe4:	2ee2      	cmp	X, A
    9fe6:	180c      	jc	0xa000 <_VoltageCorrection+0x42>
			{
				/* Underflow */
				u16NewCorrectionRatio = l_u16MinCorrectionRatio;
			}
			else if ( u16NewCorrectionRatio > l_u16MaxPidCtrlRatio )
    9fe8:	72d8 0328 	lod	A, 0x328 <_l_u16MaxPidCtrlRatio>
    9fec:	2ee2      	cmp	X, A
    9fee:	1a09      	jule	0xa002 <_VoltageCorrection+0x44>
    9ff0:	0007      	jmp	0xa000 <_VoltageCorrection+0x42>
			{
				/* Overflow */
				u16NewCorrectionRatio = l_u16MaxPidCtrlRatio;
			}
		}
		else if ( u16NewCorrectionRatio < NVRAM_MIN_HOLDCORR_RATIO )
    9ff2:	61bd      	lod	AL, dp:0xbd <__bss_dp_size+0xd>
    9ff4:	5cf2      	usex	A
    9ff6:	4832 0576 	muls	YA, A, #1398
    9ffa:	48a3      	lsr	YA, #4
    9ffc:	2ee2      	cmp	X, A
    9ffe:	1c01      	jnc	0xa002 <_VoltageCorrection+0x44>
		{
			/* Underflow */
			u16NewCorrectionRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a000:	7ee2      	lod	X, A
		}
		g_u16CorrectionRatio = u16NewCorrectionRatio;
    a002:	5d4e      	mov	dp:0x4e <_g_u16CorrectionRatio>, X
    a004:	5403      	ret	#4
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    a006:	72d8 0320 	lod	A, 0x320 <_g_u16PidCtrlRatio>
    a00a:	514e      	mov	dp:0x4e <_g_u16CorrectionRatio>, A
    a00c:	5403      	ret	#4

0000a00e <_PID_Control>:
 *	DC: Motor PWM Duty Cycle; 
 *	Stepper: current-control;
 *	BEMF: speed-control
 * ***/
void PID_Control( void)
{
    a00e:	5801      	inc	S, #2
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) ||
    a010:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a012:	b401      	and	A, #1
    a014:	1d07      	jne	0xa024 <_PID_Control+0x16>
    a016:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a018:	1901      	je	0xa01c <_PID_Control+0xe>
    a01a:	0095      	jmp	0xa146 <_PID_Control+0x138>
    a01c:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    a020:	1d01      	jne	0xa024 <_PID_Control+0x16>
    a022:	0091      	jmp	0xa146 <_PID_Control+0x138>
			 ((g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE)) ) 	/* Stop-mode & holding-current required */
	{
		/* Running-mode and NOT stall-mode "B" */
		if ( (((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) &&
    a024:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a026:	b401      	and	A, #1
    a028:	1906      	je	0xa036 <_PID_Control+0x28>
    a02a:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    a02c:	1904      	je	0xa036 <_PID_Control+0x28>
    a02e:	5cf2      	usex	A
    a030:	aed8 0146 	cmp	A, 0x146 <_g_u16PID_CtrlCounter>
    a034:	1a0f      	jule	0xa054 <_PID_Control+0x46>
    a036:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a038:	1901      	je	0xa03c <_PID_Control+0x2e>
    a03a:	007d      	jmp	0xa136 <_PID_Control+0x128>
    a03c:	61b8      	lod	AL, dp:0xb8 <__bss_dp_size+0x8>
    a03e:	44a2      	asl	A, #2
    a040:	7ae2      	lod	Y, A
    a042:	f6da 03fc 	and	Y, #1020
    a046:	1d01      	jne	0xa04a <_PID_Control+0x3c>
    a048:	0076      	jmp	0xa136 <_PID_Control+0x128>
    a04a:	72d8 0146 	lod	A, 0x146 <_g_u16PID_CtrlCounter>
    a04e:	aee6      	cmp	A, Y
    a050:	1c01      	jnc	0xa054 <_PID_Control+0x46>
    a052:	0071      	jmp	0xa136 <_PID_Control+0x128>
			int16 i16PID_Ipart;
			int16 i16PID_Ppart;
			uint16 u16PidCtrlRatio;

			/* Current Control */
			uint16 u16MotorCurrentLPFFraction = ((g_u16MotorCurrentLPFx64 + 32) >> 6);	/* MMP140911-1 */
    a054:	7158      	lod	A, dp:0x58 <_g_u16MotorCurrentLPFx64>
    a056:	7ae2      	lod	Y, A
    a058:	e020      	add	Y, #32
    a05a:	44b6      	lsr	Y, #2
    a05c:	44b6      	lsr	Y, #2
    a05e:	44b6      	lsr	Y, #2
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a060:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a062:	b401      	and	A, #1
    a064:	1909      	je	0xa078 <_PID_Control+0x6a>
			{
				i16ControlError = (int16) (g_u16PidRunningThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    a066:	72d8 0324 	lod	A, 0x324 <_g_u16PidRunningThresholdADC>
    a06a:	7ee2      	lod	X, A
    a06c:	2ae6      	sub	X, Y
				l_u16MaxPidCtrlRatio = l_u16MaxCorrectionRatio;
    a06e:	72d8 032e 	lod	A, 0x32e <_l_u16MaxCorrectionRatio>
    a072:	52d8 0328 	mov	0x328 <_l_u16MaxPidCtrlRatio>, A
    a076:	0004      	jmp	0xa080 <_PID_Control+0x72>
			}
			else
			{
				i16ControlError = (int16) (g_u16PidHoldingThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    a078:	72d8 032a 	lod	A, 0x32a <_g_u16PidHoldingThresholdADC>
    a07c:	7ee2      	lod	X, A
    a07e:	2ae6      	sub	X, Y
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a080:	7aee      	lod	Y, X
    a082:	ead8 0148 	sub	Y, 0x148 <_g_i16PID_E>
    a086:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    a088:	5cf2      	usex	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a08a:	4831      	muls	YA, A, Y
    a08c:	48b5      	asr	YA, #6
    a08e:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a090:	52d8 014a 	mov	0x14a <_g_i16PID_D>, A
			}

			/* Derivative-part */
			g_i16PID_D = mulI16_I16byI16RndDiv64( (i16ControlError - g_i16PID_E), NVRAM_PID_COEF_D);
			g_i16PID_E = i16ControlError;
    a094:	5ed8 0148 	mov	0x148 <_g_i16PID_E>, X
    a098:	61ba      	lod	AL, dp:0xba <__bss_dp_size+0xa>
    a09a:	66e0      	lod	YL, AL
    a09c:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a09e:	72e6      	lod	A, Y
    a0a0:	4833      	muls	YA, A, X
    a0a2:	48b5      	asr	YA, #6
    a0a4:	b000      	adc	A, #0
    a0a6:	5201      	mov	[S-2], A
			/* Integral-part */
			i16PID_Ipart = mulI16_I16byI16RndDiv64( i16ControlError, NVRAM_PID_COEF_I);
			if ( (i16PID_Ipart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ipart)) )
    a0a8:	ac00      	cmp	A, #0
    a0aa:	1e86      	jsge	0xa0b8 <_PID_Control+0xaa>
    a0ac:	7201      	lod	A, [S-2]
    a0ae:	5cc2      	neg	A
    a0b0:	adca      	cmp	A, dp:0xca <_g_u16PID_I>
    a0b2:	1a02      	jule	0xa0b8 <_PID_Control+0xaa>
			{
				g_u16PID_I = 0;
    a0b4:	7000      	lod	A, #0
    a0b6:	0002      	jmp	0xa0bc <_PID_Control+0xae>
			}
			else
			{
				g_u16PID_I = (uint16) (g_u16PID_I + i16PID_Ipart);
    a0b8:	71ca      	lod	A, dp:0xca <_g_u16PID_I>
    a0ba:	a201      	add	A, [S-2]
    a0bc:	51ca      	mov	dp:0xca <_g_u16PID_I>, A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a0be:	61b9      	lod	AL, dp:0xb9 <__bss_dp_size+0x9>
    a0c0:	66e0      	lod	YL, AL
    a0c2:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a0c4:	72e6      	lod	A, Y
    a0c6:	4833      	muls	YA, A, X
    a0c8:	48b5      	asr	YA, #6
    a0ca:	b000      	adc	A, #0
    a0cc:	7ee2      	lod	X, A
			}
			/* Proportional-part */
			i16PID_Ppart = mulI16_I16byI16RndDiv64( i16ControlError, (int16) NVRAM_PID_COEF_P);
			if ( (i16PID_Ppart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ppart)) )
    a0ce:	ac00      	cmp	A, #0
    a0d0:	1e92      	jsge	0xa0f6 <_PID_Control+0xe8>
    a0d2:	5cc2      	neg	A
    a0d4:	adca      	cmp	A, dp:0xca <_g_u16PID_I>
    a0d6:	1a0f      	jule	0xa0f6 <_PID_Control+0xe8>
			{
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a0d8:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a0da:	b401      	and	A, #1
    a0dc:	1903      	je	0xa0e4 <_PID_Control+0xd6>
				{
					u16PidCtrlRatio = l_u16MinCorrectionRatio;
    a0de:	7ed8 032c 	lod	X, 0x32c <_l_u16MinCorrectionRatio>
    a0e2:	0006      	jmp	0xa0f0 <_PID_Control+0xe2>
				}
				else
				{
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a0e4:	61bd      	lod	AL, dp:0xbd <__bss_dp_size+0xd>
    a0e6:	5cf2      	usex	A
    a0e8:	4832 0576 	muls	YA, A, #1398
    a0ec:	48a3      	lsr	YA, #4
    a0ee:	7ee2      	lod	X, A
				}
				g_u16PID_I = 0;
    a0f0:	7000      	lod	A, #0
    a0f2:	51ca      	mov	dp:0xca <_g_u16PID_I>, A
    a0f4:	001b      	jmp	0xa12c <_PID_Control+0x11e>
			}
			else
			{
				u16PidCtrlRatio = (uint16) (g_u16PID_I + i16PID_Ppart + g_i16PID_D);
    a0f6:	71ca      	lod	A, dp:0xca <_g_u16PID_I>
    a0f8:	a2ee      	add	A, X
    a0fa:	7ee2      	lod	X, A
    a0fc:	22d8 014a 	add	X, 0x14a <_g_i16PID_D>
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a100:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a102:	b401      	and	A, #1
    a104:	190b      	je	0xa11c <_PID_Control+0x10e>
				{
					if ( u16PidCtrlRatio < l_u16MinCorrectionRatio )
    a106:	72d8 032c 	lod	A, 0x32c <_l_u16MinCorrectionRatio>
    a10a:	2ee2      	cmp	X, A
    a10c:	180e      	jc	0xa12a <_PID_Control+0x11c>
					{
						/* Underflow */
						u16PidCtrlRatio = l_u16MinCorrectionRatio;
					}
					else if ( u16PidCtrlRatio >= l_u16MaxPidCtrlRatio )
    a10e:	72d8 0328 	lod	A, 0x328 <_l_u16MaxPidCtrlRatio>
    a112:	2ee2      	cmp	X, A
    a114:	180b      	jc	0xa12c <_PID_Control+0x11e>
					{
						/* Overflow */
						u16PidCtrlRatio = l_u16MaxPidCtrlRatio;
    a116:	7ee2      	lod	X, A
						g_u16PID_I = u16PidCtrlRatio;								/* MMP140617-1 */
    a118:	51ca      	mov	dp:0xca <_g_u16PID_I>, A
    a11a:	0008      	jmp	0xa12c <_PID_Control+0x11e>
					}
				}
				else if ( u16PidCtrlRatio < NVRAM_MIN_HOLDCORR_RATIO )
    a11c:	61bd      	lod	AL, dp:0xbd <__bss_dp_size+0xd>
    a11e:	5cf2      	usex	A
    a120:	4832 0576 	muls	YA, A, #1398
    a124:	48a3      	lsr	YA, #4
    a126:	2ee2      	cmp	X, A
    a128:	1c01      	jnc	0xa12c <_PID_Control+0x11e>
				{
					/* Underflow */
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a12a:	7ee2      	lod	X, A
				}
			}
			g_u16PidCtrlRatio = u16PidCtrlRatio;
    a12c:	5ed8 0320 	mov	0x320 <_g_u16PidCtrlRatio>, X
			g_u16PID_CtrlCounter = 0;
    a130:	7000      	lod	A, #0
    a132:	52d8 0146 	mov	0x146 <_g_u16PID_CtrlCounter>, A
		}
		VoltageCorrection();
    a136:	1743      	call	0x9fbe <_VoltageCorrection>

		/* Update motor-driver PWM duty-cycle in case of holding-mode with coil-current */

		/* Stop-mode & holding-current required */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE) )
    a138:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a13a:	1d05      	jne	0xa146 <_PID_Control+0x138>
    a13c:	62d8 013e 	lod	AL, 0x13e <_g_u8MotorHoldingCurrState>
    a140:	1902      	je	0xa146 <_PID_Control+0x138>
		{
			MotorDriver_4PhaseStepper();
    a142:	82db 92b0 	callf	0x92b0 <_MotorDriver_4PhaseStepper>
    a146:	5403      	ret	#4

0000a148 <_ThresholdControl>:
 *	DC-Motor: Motor Power
 *	Stepper: Current Threshold Control
 *	BEMF: Nothing
 * ***/
void ThresholdControl( void)
{
    a148:	583b      	inc	S, #60
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0) && (g_u16PID_ThrshldCtrlCounter >= NVRAM_PID_THRSHLDCTRL_PER) )
    a14a:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a14c:	66e0      	lod	YL, AL
    a14e:	f401      	and	Y, #1
    a150:	1901      	je	0xa154 <_ThresholdControl+0xc>
    a152:	0099      	jmp	0xa286 <_ThresholdControl+0x13e>
    a154:	69bc      	lod	AH, dp:0xbc <__bss_dp_size+0xc>
    a156:	6000      	lod	AL, #0
    a158:	4472      	asr	A
    a15a:	aed8 0144 	cmp	A, 0x144 <_g_u16PID_ThrshldCtrlCounter>
    a15e:	1a01      	jule	0xa162 <_ThresholdControl+0x1a>
    a160:	0092      	jmp	0xa286 <_ThresholdControl+0x13e>
	{
		uint16 u16CurrThrshldRatio;
		int16 i16TemperatureBgn = NVRAM_CURRTHRSHLD_TEMP_1;
    a162:	65ae      	lod	YL, dp:0xae <_g_NvramUser+0x54>
    a164:	5cf6      	usex	Y
    a166:	7ee6      	lod	X, Y
    a168:	e0c4      	add	Y, #-60
    a16a:	5a35      	mov	[S-54], Y
		uint16 u16CurrThrshldRatioBgn = NVRAM_CURRTHRSHLD_RATIO_1;
    a16c:	61af      	lod	AL, dp:0xaf <_g_NvramUser+0x55>
    a16e:	5cf2      	usex	A
    a170:	5233      	mov	[S-52], A

		g_u16PID_ThrshldCtrlCounter = 0;
    a172:	7800      	lod	Y, #0
    a174:	5ad8 0144 	mov	0x144 <_g_u16PID_ThrshldCtrlCounter>, Y

#if _SUPPORT_AMBIENT_TEMP
		if ( g_i16AmbjTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( g_i16ChipTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
    a178:	20c2      	add	X, #-62
    a17a:	5e31      	mov	[S-50], X
    a17c:	7d22      	lod	X, dp:0x22 <_g_i16ChipTemperature>
    a17e:	61b6      	lod	AL, dp:0xb6 <__bss_dp_size+0x6>
    a180:	4207      	mov	[S-8], AL
    a182:	7ad8 0326 	lod	Y, 0x326 <_g_u16PidHoldingThreshold>
    a186:	5a05      	mov	[S-6], Y
    a188:	72d8 0322 	lod	A, 0x322 <_g_u16PidRunningThreshold>
    a18c:	5203      	mov	[S-4], A
    a18e:	2e31      	cmp	X, [S-50]
    a190:	1e86      	jsge	0xa19e <_ThresholdControl+0x56>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( NVRAM_CURRTHRSHLD_ZONE_1 != 0 )
    a192:	6607      	lod	YL, [S-8]
    a194:	f401      	and	Y, #1
    a196:	1d01      	jne	0xa19a <_ThresholdControl+0x52>
    a198:	005f      	jmp	0xa258 <_ThresholdControl+0x110>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;					/* Same as point _1 */
    a19a:	7233      	lod	A, [S-52]
    a19c:	005b      	jmp	0xa254 <_ThresholdControl+0x10c>
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
			}
		}
		else
		{
			uint8 u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_2;				/* Get current threshold compensation-type */
    a19e:	6207      	lod	AL, [S-8]
    a1a0:	4430      	lsr	AL
    a1a2:	66e0      	lod	YL, AL
    a1a4:	f403      	and	Y, #3
    a1a6:	5a2d      	mov	[S-46], Y
			uint16 u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_2;			/* Get zone end point (_2) */
    a1a8:	65b1      	lod	YL, dp:0xb1 <__bss_dp_size+0x1>
    a1aa:	5cf6      	usex	Y
    a1ac:	5a29      	mov	[S-42], Y
			int16 i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_2;						
    a1ae:	65b0      	lod	YL, dp:0xb0 <__bss_dp_size>
    a1b0:	5cf6      	usex	Y
    a1b2:	7ee6      	lod	X, Y
    a1b4:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
			if ( g_i16AmbjTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
			if ( g_i16ChipTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
    a1b6:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    a1b8:	aeee      	cmp	A, X
    a1ba:	1b2f      	jsle	0xa21a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
			{
				i16TemperatureBgn = i16TemperatureEnd;							/* Next zone; begin point (_2) */
    a1bc:	5e35      	mov	[S-54], X
				u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    a1be:	7a29      	lod	Y, [S-42]
    a1c0:	5a33      	mov	[S-52], Y
				u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_3;
    a1c2:	6207      	lod	AL, [S-8]
    a1c4:	44b0      	lsr	AL, #2
    a1c6:	4430      	lsr	AL
    a1c8:	66e0      	lod	YL, AL
    a1ca:	f403      	and	Y, #3
    a1cc:	5a2d      	mov	[S-46], Y
				u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_3;				/* Get zone end point (_3) */
    a1ce:	65b3      	lod	YL, dp:0xb3 <__bss_dp_size+0x3>
    a1d0:	5cf6      	usex	Y
    a1d2:	5a29      	mov	[S-42], Y
				i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_3;
    a1d4:	65b2      	lod	YL, dp:0xb2 <__bss_dp_size+0x2>
    a1d6:	5cf6      	usex	Y
    a1d8:	7ee6      	lod	X, Y
    a1da:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
				if ( g_i16AmbjTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
				if ( g_i16ChipTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
    a1dc:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    a1de:	aeee      	cmp	A, X
    a1e0:	1b1c      	jsle	0xa21a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
				{
					i16TemperatureBgn = i16TemperatureEnd;						/* Next zone; begin point (_3) */
    a1e2:	5e35      	mov	[S-54], X
					u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    a1e4:	7a29      	lod	Y, [S-42]
    a1e6:	5a33      	mov	[S-52], Y
					u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_4;
    a1e8:	6207      	lod	AL, [S-8]
    a1ea:	44b0      	lsr	AL, #2
    a1ec:	44b0      	lsr	AL, #2
    a1ee:	4430      	lsr	AL
    a1f0:	66e0      	lod	YL, AL
    a1f2:	f403      	and	Y, #3
    a1f4:	5a2d      	mov	[S-46], Y
					u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_4;			/* Get zone end point (_3) */
    a1f6:	65b5      	lod	YL, dp:0xb5 <__bss_dp_size+0x5>
    a1f8:	5cf6      	usex	Y
    a1fa:	5a29      	mov	[S-42], Y
					i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_4;
    a1fc:	65b4      	lod	YL, dp:0xb4 <__bss_dp_size+0x4>
    a1fe:	5cf6      	usex	Y
    a200:	7ee6      	lod	X, Y
    a202:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
					if ( g_i16AmbjTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
					if ( g_i16ChipTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
    a204:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    a206:	aeee      	cmp	A, X
    a208:	1b08      	jsle	0xa21a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
					{
						u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_5;
    a20a:	6207      	lod	AL, [S-8]
    a20c:	4440      	rl	AL
    a20e:	9401      	and	AL, #1
    a210:	66e0      	lod	YL, AL
    a212:	5cf6      	usex	Y
    a214:	62e8      	lod	AL, YL
    a216:	5cf2      	usex	A
    a218:	522d      	mov	[S-46], A
					}
				}
			}
			if ( u8CurrThrshldCtrlType == 1 )
    a21a:	622d      	lod	AL, [S-46]
    a21c:	8c01      	cmp	AL, #1
    a21e:	1d02      	jne	0xa224 <_ThresholdControl+0xdc>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;
    a220:	7a33      	lod	Y, [S-52]
    a222:	001b      	jmp	0xa25a <_ThresholdControl+0x112>
			}
			else if ( u8CurrThrshldCtrlType == 2 )
    a224:	622d      	lod	AL, [S-46]
    a226:	8c02      	cmp	AL, #2
    a228:	1d02      	jne	0xa22e <_ThresholdControl+0xe6>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioEnd;
    a22a:	7a29      	lod	Y, [S-42]
    a22c:	0016      	jmp	0xa25a <_ThresholdControl+0x112>
			}
			else if ( u8CurrThrshldCtrlType == 3 )
    a22e:	622d      	lod	AL, [S-46]
    a230:	8c03      	cmp	AL, #3
    a232:	1d12      	jne	0xa258 <_ThresholdControl+0x110>
			{
				i16TemperatureEnd = i16TemperatureEnd - i16TemperatureBgn;
    a234:	2a35      	sub	X, [S-54]
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    a236:	7a29      	lod	Y, [S-42]
    a238:	ea33      	sub	Y, [S-52]
    a23a:	5a13      	mov	[S-20], Y
    a23c:	7122      	lod	A, dp:0x22 <_g_i16ChipTemperature>
    a23e:	aa35      	sub	A, [S-54]
    a240:	5211      	mov	[S-18], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a242:	7213      	lod	A, [S-20]
    a244:	7a11      	lod	Y, [S-18]
    a246:	4831      	muls	YA, A, Y
    a248:	4c73      	divs	YA, X
    a24a:	4c73      	divs	YA, X
    a24c:	4c7b      	dadjs	YA, X
    a24e:	7ee2      	lod	X, A
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    a250:	7233      	lod	A, [S-52]
    a252:	a2ee      	add	A, X
    a254:	5201      	mov	[S-2], A
    a256:	0002      	jmp	0xa25c <_ThresholdControl+0x114>
				u16CurrThrshldRatio = (uint16) (muldivI16_I16byI16byI16( ((int16) u16CurrThrshldRatioEnd - (int16) u16CurrThrshldRatioBgn), (g_i16ChipTemperature - i16TemperatureBgn), i16TemperatureEnd) + u16CurrThrshldRatioBgn);
#endif /* _SUPPORT_AMBIENT_TEMP */
			}
			else
			{
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
    a258:	7800      	lod	Y, #0
    a25a:	5a01      	mov	[S-2], Y
			}
		}
		{
			uint16 u16MCurrgain = EE_GMCURR;
    a25c:	7ed8 11d0 	lod	X, 0x11d0 <__ep__+0x1d0>
    a260:	36da 00ff 	and	X, #255
    a264:	22da 0100 	add	X, #256
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a268:	7205      	lod	A, [S-6]
    a26a:	7a01      	lod	Y, [S-2]
    a26c:	4821      	mulu	YA, A, Y
    a26e:	4c63      	divu	YA, X
    a270:	4c63      	divu	YA, X
    a272:	520d      	mov	[S-14], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a274:	52d8 032a 	mov	0x32a <_g_u16PidHoldingThresholdADC>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a278:	7203      	lod	A, [S-4]
    a27a:	7a01      	lod	Y, [S-2]
    a27c:	4821      	mulu	YA, A, Y
    a27e:	4c63      	divu	YA, X
    a280:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a282:	52d8 0324 	mov	0x324 <_g_u16PidRunningThresholdADC>, A
    a286:	543d      	ret	#62

0000a288 <_Timer_Init>:
 *
 * Initialise the core timer (Mulan2-timer), at a periodic rate of 500us
 * ****************************************************************************	*/
void Timer_Init( void)
{
	TIMER = TMR_EN | CT_PERIODIC_RATE;											/* 500us timer */
    a288:	72da 81f4 	lod	A, #33268
    a28c:	5286      	mov	io:0x6 <_LinMess2>, A
	PRIO = (PRIO & ~(3 << 0)) | ((6 - 3) << 0);									/* Set CoreTimer priority to 6 (3..6) */
    a28e:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    a292:	a403      	or	A, #3
    a294:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_TIMER_IT;
    a298:	7020      	lod	A, #32
    a29a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_TIMER_IT;														/* Enable Timer interrupt */
    a29e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    a2a2:	a420      	or	A, #32
    a2a4:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    a2a8:	5401      	ret

0000a2aa <_Timer_SleepCompensation>:
 * Timer_SleepCompensation()
 *
 * Compensate the various timer-counters for the sleep-period
 * ****************************************************************************	*/
void Timer_SleepCompensation( uint16 u16SleepPeriod)
{
    a2aa:	5805      	inc	S, #6
    a2ac:	5201      	mov	[S-2], A
    a2ae:	7ada 0100 	lod	Y, #256
    a2b2:	7eda 36b0 	lod	X, #14000
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a2b6:	4821      	mulu	YA, A, Y
    a2b8:	4c63      	divu	YA, X
    a2ba:	4c63      	divu	YA, X
    a2bc:	5205      	mov	[S-6], A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    a2be:	72e3      	lod	A, M
    a2c0:	5203      	mov	[S-4], A
	u16SleepPeriod = muldivU16_U16byU16byU16( u16SleepPeriod, 256U, (uint16)(CT_PERIODIC_RATE*(PLL_freq/1000000U)));
	ATOMIC_CODE
    a2c2:	4407      	mov	R, #0
    a2c4:	500c      	call	fp0:0x60
    a2c6:	54f0      	mov	UPr, #0
    a2c8:	7009      	lod	A, #9
    a2ca:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    a2ce:	acff      	cmp	A, #-1
    a2d0:	190d      	je	0xa2ec <_Timer_SleepCompensation+0x42>
    a2d2:	62d8 0330 	lod	AL, 0x330 <_LinStatus>
    a2d6:	b401      	and	A, #1
    a2d8:	1909      	je	0xa2ec <_Timer_SleepCompensation+0x42>
    a2da:	7000      	lod	A, #0
    a2dc:	52d8 0110 	mov	0x110 <_g_u16Mlx4StateCheckCounter>, A
    a2e0:	42d8 011c 	mov	0x11c <_g_u8ErrorCommBusTimeout>, AL
    a2e4:	7008      	lod	A, #8
    a2e6:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    a2ea:	0005      	jmp	0xa2f6 <_Timer_SleepCompensation+0x4c>
    a2ec:	72d8 0110 	lod	A, 0x110 <_g_u16Mlx4StateCheckCounter>
    a2f0:	a205      	add	A, [S-6]
    a2f2:	52d8 0110 	mov	0x110 <_g_u16Mlx4StateCheckCounter>, A
    a2f6:	72d8 0146 	lod	A, 0x146 <_g_u16PID_CtrlCounter>
    a2fa:	a205      	add	A, [S-6]
    a2fc:	52d8 0146 	mov	0x146 <_g_u16PID_CtrlCounter>, A
    a300:	72d8 0144 	lod	A, 0x144 <_g_u16PID_ThrshldCtrlCounter>
    a304:	a205      	add	A, [S-6]
    a306:	52d8 0144 	mov	0x144 <_g_u16PID_ThrshldCtrlCounter>, A
    a30a:	66d8 010c 	lod	YL, 0x10c <_g_u8MotorStartDelay>
    a30e:	62e8      	lod	AL, YL
    a310:	5cf2      	usex	A
    a312:	ae05      	cmp	A, [S-6]
    a314:	1a03      	jule	0xa31c <_Timer_SleepCompensation+0x72>
    a316:	62e8      	lod	AL, YL
    a318:	8a05      	sub	AL, [S-6]
    a31a:	0001      	jmp	0xa31e <_Timer_SleepCompensation+0x74>
    a31c:	6000      	lod	AL, #0
    a31e:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
    a322:	72d8 014c 	lod	A, 0x14c <_g_u16LinUVTimeCounter>
    a326:	1903      	je	0xa32e <_Timer_SleepCompensation+0x84>
    a328:	a205      	add	A, [S-6]
    a32a:	52d8 014c 	mov	0x14c <_g_u16LinUVTimeCounter>, A
    a32e:	72d8 0104 	lod	A, 0x104 <_g_u16CalibPauseCounter>
    a332:	1907      	je	0xa342 <_Timer_SleepCompensation+0x98>
    a334:	ae05      	cmp	A, [S-6]
    a336:	1a02      	jule	0xa33c <_Timer_SleepCompensation+0x92>
    a338:	aa05      	sub	A, [S-6]
    a33a:	0001      	jmp	0xa33e <_Timer_SleepCompensation+0x94>
    a33c:	7000      	lod	A, #0
    a33e:	52d8 0104 	mov	0x104 <_g_u16CalibPauseCounter>, A
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    a342:	7203      	lod	A, [S-4]
    a344:	52e3      	mov	M, A
    a346:	5407      	ret	#8

0000a348 <_TIMER_IT>:
 * TIMER_IT()
 *
 * Periodic Timer ISR
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
    a348:	52df      	push	A
	{
		g_u16Mlx4StateCheckCounter++;										/* State check counter */
	}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 3) */

	if ( g_u8MotorStopDelay != 0 )
    a34a:	6137      	lod	AL, dp:0x37 <_g_u8MotorStopDelay>
    a34c:	1912      	je	0xa372 <_TIMER_IT+0x2a>
	{
		if ( (--g_u8MotorStopDelay == 0) && ((g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) )
    a34e:	80ff      	add	AL, #-1
    a350:	4137      	mov	dp:0x37 <_g_u8MotorStopDelay>, AL
    a352:	1d0f      	jne	0xa372 <_TIMER_IT+0x2a>
    a354:	61ed      	lod	AL, dp:0xed <_g_e8MotorStatusMode>
    a356:	b47f      	and	A, #127
    a358:	1d0c      	jne	0xa372 <_TIMER_IT+0x2a>
		{
			DRVCFG_DIS_UVWT();
    a35a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    a35e:	b6da fe00 	and	A, #65024
    a362:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();														/* MMP140903-1 */
    a366:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    a36a:	a6da 0100 	or	A, #256
    a36e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}
	}

	if ( g_u8MotorStartDelay != 0 )
    a372:	62d8 010c 	lod	AL, 0x10c <_g_u8MotorStartDelay>
    a376:	1903      	je	0xa37e <_TIMER_IT+0x36>
	{
		g_u8MotorStartDelay--;
    a378:	80ff      	add	AL, #-1
    a37a:	42d8 010c 	mov	0x10c <_g_u8MotorStartDelay>, AL
	}

	g_u16PID_CtrlCounter++;														/* PID Current/Speed control */
    a37e:	72d8 0146 	lod	A, 0x146 <_g_u16PID_CtrlCounter>
    a382:	a001      	add	A, #1
    a384:	52d8 0146 	mov	0x146 <_g_u16PID_CtrlCounter>, A
	g_u16PID_ThrshldCtrlCounter++;												/* PID Threshold control */
    a388:	72d8 0144 	lod	A, 0x144 <_g_u16PID_ThrshldCtrlCounter>
    a38c:	a001      	add	A, #1
    a38e:	52d8 0144 	mov	0x144 <_g_u16PID_ThrshldCtrlCounter>, A
#if _SUPPORT_CHIP_TEMP_PROFILE
	g_u16TemperatureStabilityCounter++;
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */

#if _SUPPORT_LIN_UV
	if ( g_u16LinUVTimeCounter != 0 )											/* MMP131216-1 - Begin */
    a392:	72d8 014c 	lod	A, 0x14c <_g_u16LinUVTimeCounter>
    a396:	1903      	je	0xa39e <_TIMER_IT+0x56>
	{
		g_u16LinUVTimeCounter++;
    a398:	a001      	add	A, #1
    a39a:	52d8 014c 	mov	0x14c <_g_u16LinUVTimeCounter>, A
	{
		u16DegradeDelay--;
	}
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */		/* MMP150128-1 - End */

	if ( g_u16CalibPauseCounter != 0 )
    a39e:	72d8 0104 	lod	A, 0x104 <_g_u16CalibPauseCounter>
    a3a2:	1903      	je	0xa3aa <_TIMER_IT+0x62>
		g_u16CalibPauseCounter--;
    a3a4:	a0ff      	add	A, #-1
    a3a6:	52d8 0104 	mov	0x104 <_g_u16CalibPauseCounter>, A
    a3aa:	72cf      	pop	A
    a3ac:	4407      	mov	R, #0
    a3ae:	72cb      	pop	M
    a3b0:	5401      	ret

0000a3b2 <_SpiDebugInit>:
 *
 *	Comments:	Initialise SPI Interface.
 * ****************************************************************************	*/
void SpiDebugInit( void)
{
	SPI1_PCR  = SPI_CKEN;													/* Set the bit SPI_CKEN to 1 */
    a3b2:	6001      	lod	AL, #1
    a3b4:	42d8 289a 	mov	0x289a <__io__+0x9a>, AL
	SPI1_BRR  = ((PLL_freq / DEBUG_SPI_BAUDRATE) + 1);						/* 100, 200, 400, 800 or 1000 kBaud */
    a3b8:	701d      	lod	A, #29
    a3ba:	52d8 289c 	mov	0x289c <__io__+0x9c>, A
	SPI1_CTRL = (SPI_FRSSOEN << 8) | (SPI_MSTRONLY << 8) | SPI_RFIE | SPI_TFIE | /* SPI_BYTEMOD | */ SPI_MSTR | SPI_EN | SPI_CKEN;	/* Mode 00 */
    a3be:	72da 0ad3 	lod	A, #2771
    a3c2:	52d8 289a 	mov	0x289a <__io__+0x9a>, A
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
static INLINE void SpiDebugWriteFirst( uint16 u16Data)
{
	SPI1_PSCR |= SPI_FRSSOEN;													/* Toggle Slave-Select */
    a3c6:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    a3ca:	8408      	or	AL, #8
    a3cc:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_PSCR &= ~SPI_FRSSOEN;
    a3d0:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    a3d4:	94f7      	and	AL, #-9
    a3d6:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_DR = u16Data;															/* Send SPI-Data */
    a3da:	72da a55a 	lod	A, #42330
    a3de:	52d8 289e 	mov	0x289e <__io__+0x9e>, A
    a3e2:	5401      	ret

0000a3e4 <_au16HaltZero>:
    a3e4:	0000 0000                                   ....

0000a3e8 <_tMlxDbgSupport>:
    a3e8:	fffe 0007 0000 0000 0000 0000 0000 0000     ................
    a3f8:	0000 0000 d0ff 0000 ff87 c0ff 0001 7d07     ...............}

0000a408 <_au16AnaOutRegs>:
    a408:	201c 201e 2020 204a 204c 204e 28cc 28ce     . .   J L N .(.(

0000a418 <_tAdcSelfTest4B>:
    a418:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    a428:	1903 0d53 0003 ffff                         ..S.....

0000a430 <_tAdcSelfTest4A>:
    a430:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    a440:	1903 0053 0d03 ffff                         ..S.....

0000a448 <_SBASE_INIT_4PH>:
    a448:	0143 0053 0d63 0473 0d03 ffff               C.S.c.s.....

0000a454 <_SBASE_CURRENT>:
    a454:	0d03 ffff                                   ....

0000a458 <_SBASE_MOTORVOLT>:
    a458:	0403 ffff                                   ....

0000a45c <_SBASE_SUPPLYVOLT>:
    a45c:	0003 ffff                                   ....

0000a460 <_SBASE_TEMP>:
    a460:	0103 ffff                                   ....

0000a464 <_SBASE_CURROFF>:
    a464:	0d03 ffff                                   ....

0000a468 <_SBASE_VREF_OFF>:
    a468:	0100 ffff                                   ....

0000a46c <_c_ai16MicroStepVector4PH>:
    a46c:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    a47c:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..
    a48c:	7ffe 7ec3 7c4f 78a8 73d8 6deb 66ee 5ef4     ...~O|.x.s.m.f.^
    a49c:	560f 4c56 41e1 36ca 2b2c 1f23 12cd 0649     .VVL.A.6,+#...I.
    a4ac:	f9b7 ed33 e0dd d4d4 c936 be1f b3aa a9f1     ..3.....6.......
    a4bc:	a10c 9912 9215 8c28 8758 83b1 813d 8002     ......(.X...=...
    a4cc:	8002 813d 83b1 8758 8c28 9215 9912 a10c     ..=...X.(.......
    a4dc:	a9f1 b3aa be1f c936 d4d4 e0dd ed33 f9b7     ......6.....3...
    a4ec:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    a4fc:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..

0000a50c <_c_au8DrvCfgSelfTestB4>:
    a50c:	c431 8421 4c13 4812 b5f5                    1.!..L.H..

0000a516 <_c_au16DrvAdcSelfTestA>:
    a516:	0b03 ffff 0a03 ffff 0903 ffff 1903 ffff     ................

0000a526 <_c_au8DrvCfgSelfTestA>:
    a526:	3020 0c08 0302 c080                          0......

0000a52e <_defNvramUser>:
    a52e:	0100 b06c 8881 0000 5467 0000 ffff 2dc0     ..l.....gT.....-
    a53e:	321e 0138 0a0a 00b0 0124 ffff 0000 3000     .28.....$......0
    a54e:	0000 0000 0000 0000 0000 0000 0000 0000     ................
    a55e:	6c40 b001 0060 004b 004b 004b 004b 0000     @l..`.K.K.K.K...
    a56e:	0000 0000 0000 004b 05dc 1201 1791 963c     ......K.......<.
    a57e:	a514 9040 821a 8044 8062 8f7a 0aef 3219     ..@...D.b.z....2
    a58e:	1e1e 1a10 fa1a 0000 0000 004b 0210 5840     ..........K...@X
    a59e:	0600 00b2 7fff ffff                         ........
