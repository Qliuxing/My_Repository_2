mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


MLX81315A_S03_VALVE.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00004000  00004000  00000274  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00005540  00005540  00001764  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000098  0000bf68  0000bf68  0000700a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00006f68  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  00007008  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  00007002  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .protection_key 00000008  0000bf46  0000bf46  00006fe8  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .flash_crc    00000002  0000bf4e  0000bf4e  00006ff0  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .product_no   00000008  0000bf50  0000bf50  00006ff2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .app_version  00000004  0000bf58  0000bf58  00006ffa  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .pltf_version 00000004  0000bf5c  0000bf5c  00006ffe  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .ramfunc      0000001e  00000740  000055c8  000017ec  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         000056d8  000055e8  000055e8  0000180c  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 13 .shared_ram   00000010  00000000  00000000  000070a2  2**0
                  CONTENTS, READONLY
 14 .ram_lin_fixed 00000006  00000010  00000010  00000274  2**1
                  ALLOC
 15 .dp.data      00000022  00000018  0000acc0  00006ee4  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 16 .dp           000000b0  0000003a  0000ace2  00006f06  2**1
                  ALLOC
 17 .dp.noinit    00000010  000000ea  0000ace2  00006f06  2**1
                  ALLOC
 18 .data         00000062  000000fa  0000ace2  00006f06  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 19 .bss          00000214  0000015c  0000ad44  00006f68  2**1
                  ALLOC
 20 .bist_stat    00000008  00000370  0000ad44  00006f68  2**1
                  ALLOC
 21 .debug_abbrev 000029fb  00000000  00000000  000070b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_info   0000e4cb  00000000  00000000  00009aad  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   0000849b  00000000  00000000  00017f78  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  00001530  00000000  00000000  00020414  2**1
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_pubnames 00001cef  00000000  00000000  00021944  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_aranges 00000480  00000000  00000000  00023633  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_str    000039b0  00000000  00000000  00023ab3  2**0
                  CONTENTS, READONLY, DEBUGGING
 28 .comment      00000011  00000000  00000000  00027463  2**0
                  CONTENTS, READONLY
 29 .debug_ranges 0000000c  00000000  00000000  00027474  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .mlx4_flash:

00004000 <__mlx4_flash_start>:
    4000:	a55a      	or	A, dp:0x5a <_g_NvramUser+0x2>
    4002:	5aa5      	mov	io:0x25 <_g_e8DegradedMotorRequest>, Y
    4004:	0000      	nop
    4006:	0000      	nop
    4008:	2442      	or	X, #66
    400a:	2442      	or	X, #66
    400c:	243f      	or	X, #63
    400e:	243f      	or	X, #63
    4010:	0000      	nop
    4012:	0000      	nop
    4014:	0000      	nop
    4016:	0000      	nop
    4018:	4100      	mov	dp:0x0 <__dp__>, AL
    401a:	2000      	add	X, #0
    401c:	0000      	nop
    401e:	0000      	nop
    4020:	01e0      	jmp	0x43e2 <__mlx4_flash_start+0x3e2>
    4022:	0003      	jmp	0x402a <__mlx4_flash_start+0x2a>
    4024:	0005      	jmp	0x4030 <__mlx4_flash_start+0x30>
    4026:	0000      	nop
    4028:	4233      	mov	[S-52], AL
    402a:	5f50      	mov	ep:0x50 <_g_u16CommutTimerPeriod>, X
    402c:	7c6d      	lod	X, #109
    402e:	998a      	subc	AL, dp:0x8a <__data_size+0x28>
    4030:	140e      	call	0x384e <__io__+0x104e>
    4032:	201a      	add	X, #26
    4034:	2c26      	cmp	X, #38
    4036:	3832      	subc	X, #50
    4038:	0208      	jmp	0x444a <__mlx4_flash_start+0x44a>
    403a:	af52      	cmp	A, ep:0x52 <_g_u16TargetCommutTimerPeriod>
    403c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    403e:	ff35      	xor	Y, ep:0x35 <_g_u8MotorStopDelay>
    4040:	e0e0      	add	Y, #-32
    4042:	dba6      	subc	AH, ep:0xa6 <__data_size+0x44>
    4044:	0000      	nop
    4046:	0200      	jmp	0x4448 <__mlx4_flash_start+0x448>
    4048:	7da0      	lod	X, dp:0xa0 <__data_size+0x3e>
    404a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    404c:	39e4      	subc	X, dp:0xe4 <_ml_driver_mode+0xe>
    404e:	934e      	adc	AL, ep:0x4e <_g_u16MicroStepIdx>
    4050:	d3e0      	adc	AH, ep:0xe0 <_ml_driver_mode+0xa>
    4052:	a497      	or	A, #-105
    4054:	2c1f      	cmp	X, #31
    4056:	5b68      	mov	ep:0x68 <__data_size+0x6>, Y
    4058:	a81f      	sub	A, #31
    405a:	b47f      	and	A, #127
    405c:	00b2      	jmp	0x41c2 <__mlx4_flash_start+0x1c2>
    405e:	7c50      	lod	X, #80
    4060:	b787      	and	A, ep:0x87 <__data_size+0x25>
    4062:	773a      	lod	PC, ep:0x3a <__data_dp_end>
    4064:	b78e      	and	A, ep:0x8e <__data_size+0x2c>
    4066:	773b      	lod	PC, ep:0x3b <__data_dp_end+0x1>
    4068:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    406a:	34e9      	and	X, #-23
    406c:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    406e:	b76f      	and	A, ep:0x6f <__data_size+0xd>
    4070:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x5>
    4072:	4c02 b203 	add	D, #-1291603453
    4076:	b303 
    4078:	8684      	or	AL, io:0x4 <_LinMess>
    407a:	7203      	lod	A, [S-4]
    407c:	4c03      	add	D, ??
    407e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    4080:	380e      	subc	X, #14
    4082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    4084:	320a      	adc	X, [S-11]
    4086:	340a      	and	X, #10
    4088:	3eac      	xor	X, io:0x2c <_g_e8ErrorCoil>
    408a:	3b16      	subc	X, ep:0x16 <__dp_noinit_size+0x6>
    408c:	3730      	and	X, ep:0x30 <_g_u8BufferOutID>
    408e:	6193      	lod	AL, dp:0x93 <__data_size+0x31>
    4090:	b680      	and	A, io:0x0 <__dp__>
    4092:	7273      	lod	A, [S-116]
    4094:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4098:	7239      	lod	A, [S-58]
    409a:	726f      	lod	A, [S-112]
    409c:	b582      	and	A, dp:0x82 <__data_size+0x20>
    409e:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    40a0:	b588      	and	A, dp:0x88 <__data_size+0x26>
    40a2:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    40a4:	0000      	nop
    40a6:	0000      	nop
    40a8:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    40aa:	320a      	adc	X, [S-11]
    40ac:	580a      	inc	S, #11
    40ae:	0901      	clrb	io:0x00.1
    40b0:	2080      	add	X, #-128
    40b2:	623a      	lod	AL, [S-59]
    40b4:	7270      	lod	A, [S-113]
    40b6:	b637      	and	A, [S-56]
    40b8:	b373      	adc	A, ep:0x73 <__data_size+0x11>
    40ba:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    40bc:	e783      	or	Y, ep:0x83 <__data_size+0x21>
    40be:	1101      	call	0x42c2 <__mlx4_flash_start+0x2c2>
    40c0:	20b7      	add	X, #-73
    40c2:	6c03      	lod	YH, #3
    40c4:	206e      	add	X, #110
    40c6:	2066      	add	X, #102
    40c8:	2073      	add	X, #115
    40ca:	2050      	add	X, #80
    40cc:	e680      	or	Y, io:0x0 <__dp__>
    40ce:	1102      	call	0x42d4 <__mlx4_flash_start+0x2d4>
    40d0:	b782      	and	A, ep:0x82 <__data_size+0x20>
    40d2:	207a      	add	X, #122
    40d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    40d6:	110b      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40d8:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    40da:	207a      	add	X, #122
    40dc:	b270      	adc	A, [S-113]
    40de:	a688      	or	A, io:0x8 <__bist_stat_size>
    40e0:	1106      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40e2:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    40e4:	207a      	add	X, #122
    40e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    40e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    40ea:	1101      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40ec:	207c      	add	X, #124
    40ee:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    40f0:	7373      	lod	A, ep:0x73 <__data_size+0x11>
    40f2:	2050      	add	X, #80
    40f4:	7373      	lod	A, ep:0x73 <__data_size+0x11>
    40f6:	2056      	add	X, #86
    40f8:	b783      	and	A, ep:0x83 <__data_size+0x21>
    40fa:	7373      	lod	A, ep:0x73 <__data_size+0x11>
    40fc:	3cc3      	xor	X, #-61
    40fe:	2050      	add	X, #80
    4100:	b384      	adc	A, ep:0x84 <__data_size+0x22>
    4102:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    4104:	7380      	lod	A, ep:0x80 <__data_size+0x1e>
    4106:	7334      	lod	A, ep:0x34 <_l_u8VTIdx>
    4108:	7235      	lod	A, [S-54]
    410a:	7ca7      	lod	X, #-89
    410c:	7d34      	lod	X, dp:0x34 <_l_u8VTIdx>
    410e:	6c03      	lod	YH, #3
    4110:	20b1      	add	X, #-79
    4112:	20ad      	add	X, #-83
    4114:	20b3      	add	X, #-77
    4116:	20b3      	add	X, #-77
    4118:	20b3      	add	X, #-77
    411a:	20a1      	add	X, #-95
    411c:	20b3      	add	X, #-77
    411e:	20b3      	add	X, #-77
    4120:	20b3      	add	X, #-77
    4122:	20b3      	add	X, #-77
    4124:	20b3      	add	X, #-77
    4126:	20b3      	add	X, #-77
    4128:	20b3      	add	X, #-77
    412a:	20b3      	add	X, #-77
    412c:	20b3      	add	X, #-77
    412e:	2098      	add	X, #-104
    4130:	a682      	or	A, io:0x2 <_LinCmnd>
    4132:	1106      	call	0x4340 <__mlx4_flash_start+0x340>
    4134:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x7>
    4136:	bf8e      	xor	A, ep:0x8e <__data_size+0x2c>
    4138:	a681      	or	A, io:0x1 <__dp__+0x1>
    413a:	0101      	jmp	0x433e <__mlx4_flash_start+0x33e>
    413c:	f781      	and	Y, ep:0x81 <__data_size+0x1f>
    413e:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    4140:	20b1      	add	X, #-79
    4142:	e682      	or	Y, io:0x2 <_LinCmnd>
    4144:	110d      	call	0x4360 <__mlx4_flash_start+0x360>
    4146:	b286      	adc	A, io:0x6 <_LinMess2>
    4148:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x7>
    414a:	f782      	and	Y, ep:0x82 <__data_size+0x20>
    414c:	e681      	or	Y, io:0x1 <__dp__+0x1>
    414e:	0103      	jmp	0x4356 <__mlx4_flash_start+0x356>
    4150:	bf8d      	xor	A, ep:0x8d <__data_size+0x2b>
    4152:	b680      	and	A, io:0x0 <__dp__>
    4154:	7273      	lod	A, [S-116]
    4156:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    4158:	20b1      	add	X, #-79
    415a:	e681      	or	Y, io:0x1 <__dp__+0x1>
    415c:	1101      	call	0x4360 <__mlx4_flash_start+0x360>
    415e:	245d      	or	X, #93
    4160:	20b3      	add	X, #-77
    4162:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4164:	20b4      	add	X, #-76
    4166:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4168:	7381      	lod	A, ep:0x81 <__data_size+0x1f>
    416a:	5404      	ret	#5
    416c:	2056      	add	X, #86
    416e:	a681      	or	A, io:0x1 <__dp__+0x1>
    4170:	1104      	call	0x437a <__mlx4_flash_start+0x37a>
    4172:	b270      	adc	A, [S-113]
    4174:	a688      	or	A, io:0x8 <__bist_stat_size>
    4176:	1105      	call	0x4382 <__mlx4_flash_start+0x382>
    4178:	2048      	add	X, #72
    417a:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    417c:	622e      	lod	AL, [S-47]
    417e:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4180:	0101      	jmp	0x4384 <__mlx4_flash_start+0x384>
    4182:	2056      	add	X, #86
    4184:	b139      	adc	A, dp:0x39 <_l_u8StallCountA>
    4186:	e14c      	add	Y, dp:0x4c <_g_u16CorrectionRatio>
    4188:	1101      	call	0x438c <__mlx4_flash_start+0x38c>
    418a:	20e4      	add	X, #-28
    418c:	4592      	mov	dp:0x92 <__data_size+0x30>, YL
    418e:	76e5      	jmp	MH
    4190:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4192:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0xf>
    4194:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4196:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4198:	7139      	lod	A, dp:0x39 <_l_u8StallCountA>
    419a:	6198      	lod	AL, dp:0x98 <__data_size+0x36>
    419c:	e581      	or	Y, dp:0x81 <__data_size+0x1f>
    419e:	110b      	call	0x43b6 <__mlx4_flash_start+0x3b6>
    41a0:	7cd5      	lod	X, #-43
    41a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    41a4:	b208      	adc	A, [S-9]
    41a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    41a8:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    41aa:	a783      	or	A, ep:0x83 <__data_size+0x21>
    41ac:	1105      	call	0x43b8 <__mlx4_flash_start+0x3b8>
    41ae:	bf8c      	xor	A, ep:0x8c <__data_size+0x2a>
    41b0:	f373      	adc	Y, ep:0x73 <__data_size+0x11>
    41b2:	7373      	lod	A, ep:0x73 <__data_size+0x11>
    41b4:	724c      	lod	A, [S-77]
    41b6:	2050      	add	X, #80
    41b8:	7271      	lod	A, [S-114]
    41ba:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    41bc:	e781      	or	Y, ep:0x81 <__data_size+0x1f>
    41be:	0102      	jmp	0x43c4 <__mlx4_flash_start+0x3c4>
    41c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    41c2:	20da      	add	X, #-38
    41c4:	b686      	and	A, io:0x6 <_LinMess2>
    41c6:	20da      	add	X, #-38
    41c8:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    41ca:	300a      	adc	X, #10
    41cc:	6198      	lod	AL, dp:0x98 <__data_size+0x36>
    41ce:	ef80      	cmp	Y, ep:0x80 <__data_size+0x1e>
    41d0:	0103      	jmp	0x43d8 <__mlx4_flash_start+0x3d8>
    41d2:	b684      	and	A, io:0x4 <_LinMess>
    41d4:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    41d6:	2030      	add	X, #48
    41d8:	b24e      	adc	A, [S-79]
    41da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    41dc:	724e      	lod	A, [S-79]
    41de:	6c02      	lod	YH, #2
    41e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    41e2:	20f4      	add	X, #-12
    41e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    41e6:	2100      	add	X, dp:0x0 <__dp__>
    41e8:	b78b      	and	A, ep:0x8b <__data_size+0x29>
    41ea:	b584      	and	A, dp:0x84 <__data_size+0x22>
    41ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    41ee:	61ae      	lod	AL, dp:0xae <__data_size+0x4c>
    41f0:	b787      	and	A, ep:0x87 <__data_size+0x25>
    41f2:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    41f4:	b783      	and	A, ep:0x83 <__data_size+0x21>
    41f6:	b582      	and	A, dp:0x82 <__data_size+0x20>
    41f8:	b681      	and	A, io:0x1 <__dp__+0x1>
    41fa:	61ae      	lod	AL, dp:0xae <__data_size+0x4c>
    41fc:	b783      	and	A, ep:0x83 <__data_size+0x21>
    41fe:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4200:	b682      	and	A, io:0x2 <_LinCmnd>
    4202:	724e      	lod	A, [S-79]
    4204:	b78d      	and	A, ep:0x8d <__data_size+0x2b>
    4206:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4208:	b681      	and	A, io:0x1 <__dp__+0x1>
    420a:	61ae      	lod	AL, dp:0xae <__data_size+0x4c>
    420c:	b783      	and	A, ep:0x83 <__data_size+0x21>
    420e:	2110      	add	X, dp:0x10 <__dp_noinit_size>
    4210:	b24c      	adc	A, [S-77]
    4212:	7271      	lod	A, [S-114]
    4214:	b78b      	and	A, ep:0x8b <__data_size+0x29>
    4216:	b584      	and	A, dp:0x84 <__data_size+0x22>
    4218:	b681      	and	A, io:0x1 <__dp__+0x1>
    421a:	61ae      	lod	AL, dp:0xae <__data_size+0x4c>
    421c:	b785      	and	A, ep:0x85 <__data_size+0x23>
    421e:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    4220:	b24e      	adc	A, [S-79]
    4222:	b171      	adc	A, dp:0x71 <__data_size+0xf>
    4224:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4226:	b584      	and	A, dp:0x84 <__data_size+0x22>
    4228:	b56d      	and	A, dp:0x6d <__data_size+0xb>
    422a:	b685      	and	A, io:0x5 <_LinMess+0x1>
    422c:	b66e      	and	A, [S-111]
    422e:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    4230:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4232:	b680      	and	A, io:0x0 <__dp__>
    4234:	738b      	lod	A, ep:0x8b <__data_size+0x29>
    4236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    4238:	b783      	and	A, ep:0x83 <__data_size+0x21>
    423a:	7388      	lod	A, ep:0x88 <__data_size+0x26>
    423c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    423e:	5408      	ret	#9
    4240:	b273      	adc	A, [S-116]
    4242:	a688      	or	A, io:0x8 <__bist_stat_size>
    4244:	1109      	call	0x4458 <__mlx4_flash_start+0x458>
    4246:	b24e      	adc	A, [S-79]
    4248:	e681      	or	Y, io:0x1 <__dp__+0x1>
    424a:	0103      	jmp	0x4452 <__mlx4_flash_start+0x452>
    424c:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x7>
    424e:	a582      	or	A, dp:0x82 <__data_size+0x20>
    4250:	0102      	jmp	0x4456 <__mlx4_flash_start+0x456>
    4252:	b680      	and	A, io:0x0 <__dp__>
    4254:	204a      	add	X, #74
    4256:	2048      	add	X, #72
    4258:	3806      	subc	X, #6
    425a:	380e      	subc	X, #14
    425c:	580c      	inc	S, #13
    425e:	0807      	clrb	dp:0x00.7
    4260:	62e6      	lod	AL, Y
    4262:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4264:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4266:	1108      	call	0x4478 <__mlx4_flash_start+0x478>
    4268:	a784      	or	A, ep:0x84 <__data_size+0x22>
    426a:	1105      	call	0x4476 <__mlx4_flash_start+0x476>
    426c:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    426e:	623a      	lod	AL, [S-59]
    4270:	a784      	or	A, ep:0x84 <__data_size+0x22>
    4272:	1101      	call	0x4476 <__mlx4_flash_start+0x476>
    4274:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    4276:	2030      	add	X, #48
    4278:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    427a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    427c:	b582      	and	A, dp:0x82 <__data_size+0x20>
    427e:	6223      	lod	AL, [S-36]
    4280:	6198      	lod	AL, dp:0x98 <__data_size+0x36>
    4282:	b208      	adc	A, [S-9]
    4284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    4286:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    4288:	6c03      	lod	YH, #3
    428a:	2155      	add	X, dp:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    428c:	214a      	add	X, dp:0x4a <_l_u8LinInFrameMsgID>
    428e:	b688      	and	A, io:0x8 <__bist_stat_size>
    4290:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4292:	215a      	add	X, dp:0x5a <_g_NvramUser+0x2>
    4294:	b586      	and	A, dp:0x86 <__data_size+0x24>
    4296:	61a8      	lod	AL, dp:0xa8 <__data_size+0x46>
    4298:	b584      	and	A, dp:0x84 <__data_size+0x22>
    429a:	b6e5      	and	A, MH
    429c:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    429e:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xf>
    42a0:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    42a2:	76e5      	jmp	MH
    42a4:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    42a6:	77e5      	lod	PC, ep:0xe5 <_ml_driver_mode+0xf>
    42a8:	b686      	and	A, io:0x6 <_LinMess2>
    42aa:	b584      	and	A, dp:0x84 <__data_size+0x22>
    42ac:	61a8      	lod	AL, dp:0xa8 <__data_size+0x46>
    42ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    42b0:	b582      	and	A, dp:0x82 <__data_size+0x20>
    42b2:	3e10      	xor	X, [S-17]
    42b4:	724c      	lod	A, [S-77]
    42b6:	7139      	lod	A, dp:0x39 <_l_u8StallCountA>
    42b8:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    42ba:	34c0      	and	X, #-64
    42bc:	623a      	lod	AL, [S-59]
    42be:	38b7      	subc	X, #-73
    42c0:	357b      	and	X, dp:0x7b <__data_size+0x19>
    42c2:	3663      	and	X, [S-100]
    42c4:	7cd3      	lod	X, #-45
    42c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    42c8:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    42ca:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    42cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    42ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    42d0:	b208      	adc	A, [S-9]
    42d2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    42d4:	4616      	mov	[S-23], YL
    42d6:	3561      	and	X, dp:0x61 <_g_NvramUser+0x9>
    42d8:	7208      	lod	A, [S-9]
    42da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    42dc:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    42de:	0103      	jmp	0x44e6 <__mlx4_flash_start+0x4e6>
    42e0:	b272      	adc	A, [S-115]
    42e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    42e4:	010a      	jmp	0x44fa <__mlx4_flash_start+0x4fa>
    42e6:	4500      	mov	dp:0x0 <__dp__>, YL
    42e8:	4584      	mov	dp:0x84 <__data_size+0x22>, YL
    42ea:	8582      	or	AL, dp:0x82 <__data_size+0x20>
    42ec:	5802      	inc	S, #3
    42ee:	b739      	and	A, ep:0x39 <_l_u8StallCountA>
    42f0:	b638      	and	A, [S-57]
    42f2:	7272      	lod	A, [S-115]
    42f4:	b737      	and	A, ep:0x37 <_g_u16StartupDelay+0x1>
    42f6:	0004      	jmp	0x4300 <__mlx4_flash_start+0x300>
    42f8:	2167      	add	X, dp:0x67 <__data_size+0x5>
    42fa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    42fc:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    42fe:	2047      	add	X, #71
    4300:	6217      	lod	AL, [S-24]
    4302:	0007      	jmp	0x4312 <__mlx4_flash_start+0x312>
    4304:	1102      	call	0x450a <__mlx4_flash_start+0x50a>
    4306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    4308:	7209      	lod	A, [S-10]
    430a:	b208      	adc	A, [S-9]
    430c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    430e:	6198      	lod	AL, dp:0x98 <__data_size+0x36>
    4310:	2165      	add	X, dp:0x65 <__data_size+0x3>
    4312:	b16f      	adc	A, dp:0x6f <__data_size+0xd>
    4314:	bd83      	xor	A, dp:0x83 <__data_size+0x21>
    4316:	716f      	lod	A, dp:0x6f <__data_size+0xd>
    4318:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x7>
    431a:	a582      	or	A, dp:0x82 <__data_size+0x20>
    431c:	1101      	call	0x4520 <__mlx4_flash_start+0x520>
    431e:	2030      	add	X, #48
    4320:	b785      	and	A, ep:0x85 <__data_size+0x23>
    4322:	62d2      	lod	AL, [A++]
    4324:	212e      	add	X, dp:0x2e <_g_e8MotorRequest>
    4326:	38b7      	subc	X, #-73
    4328:	3e18      	xor	X, [S-25]
    432a:	357b      	and	X, dp:0x7b <__data_size+0x19>
    432c:	367b      	and	X, [S-124]
    432e:	6800      	lod	AH, #0
    4330:	7370      	lod	A, ep:0x70 <__data_size+0xe>
    4332:	b792      	and	A, ep:0x92 <__data_size+0x30>
    4334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4336:	b20a      	adc	A, [S-11]
    4338:	d667      	and	AH, [S-104]
    433a:	720b      	lod	A, [S-12]
    433c:	b76b      	and	A, ep:0x6b <__data_size+0x9>
    433e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    4340:	b370      	adc	A, ep:0x70 <__data_size+0xe>
    4342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4344:	b20a      	adc	A, [S-11]
    4346:	d667      	and	AH, [S-104]
    4348:	720b      	lod	A, [S-12]
    434a:	b76b      	and	A, ep:0x6b <__data_size+0x9>
    434c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    434e:	6800      	lod	AH, #0
    4350:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xf>
    4352:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4354:	e78f      	or	Y, ep:0x8f <__data_size+0x2d>
    4356:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xf>
    4358:	ef87      	cmp	Y, ep:0x87 <__data_size+0x25>
    435a:	6800      	lod	AH, #0
    435c:	7270      	lod	A, [S-113]
    435e:	b6e7      	and	A, R
    4360:	8791      	or	AL, ep:0x91 <__data_size+0x2f>
    4362:	76e7      	jmp	R
    4364:	c791      	or	AH, ep:0x91 <__data_size+0x2f>
    4366:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    4368:	e370      	add	Y, ep:0x70 <__data_size+0xe>
    436a:	0109      	jmp	0x457e <__mlx4_flash_start+0x57e>
    436c:	21af      	add	X, dp:0xaf <__data_size+0x4d>
    436e:	b587      	and	A, dp:0x87 <__data_size+0x25>
    4370:	b66d      	and	A, [S-110]
    4372:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4374:	b56d      	and	A, dp:0x6d <__data_size+0xb>
    4376:	76e7      	jmp	R
    4378:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    437a:	75e7      	lod	PC, dp:0xe7 <_ml_driver_mode+0x11>
    437c:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    437e:	6800      	lod	AH, #0
    4380:	b140      	adc	A, dp:0x40 <__data_dp_end+0x6>
    4382:	814e      	add	AL, dp:0x4e <_g_u16MicroStepIdx>
    4384:	7140      	lod	A, dp:0x40 <__data_dp_end+0x6>
    4386:	b141      	adc	A, dp:0x41 <__data_dp_end+0x7>
    4388:	894f      	sub	AL, dp:0x4f <_g_u16MicroStepIdx+0x1>
    438a:	7141      	lod	A, dp:0x41 <__data_dp_end+0x7>
    438c:	b142      	adc	A, dp:0x42 <_g_DiagResponse>
    438e:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    4390:	7142      	lod	A, dp:0x42 <_g_DiagResponse>
    4392:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x1>
    4394:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    4396:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x1>
    4398:	b144      	adc	A, dp:0x44 <_g_DiagResponse+0x2>
    439a:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    439c:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    439e:	6800      	lod	AH, #0
    43a0:	b154      	adc	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    43a2:	814e      	add	AL, dp:0x4e <_g_u16MicroStepIdx>
    43a4:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    43a6:	b155      	adc	A, dp:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    43a8:	894f      	sub	AL, dp:0x4f <_g_u16MicroStepIdx+0x1>
    43aa:	7155      	lod	A, dp:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    43ac:	b156      	adc	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    43ae:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    43b0:	7156      	lod	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    43b2:	b157      	adc	A, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    43b4:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    43b6:	7157      	lod	A, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    43b8:	6800      	lod	AH, #0
    43ba:	b34e      	adc	A, ep:0x4e <_g_u16MicroStepIdx>
    43bc:	b24f      	adc	A, [S-80]
    43be:	b15a      	adc	A, dp:0x5a <_g_NvramUser+0x2>
    43c0:	e349      	add	Y, ep:0x49 <_g_DiagResponse+0x7>
    43c2:	ea4a      	sub	Y, [S-75]
    43c4:	e94b      	sub	Y, dp:0x4b <_l_u8LinInFrameMsgID+0x1>
    43c6:	1003      	call	0x43ce <__mlx4_flash_start+0x3ce>
    43c8:	7349      	lod	A, ep:0x49 <_g_DiagResponse+0x7>
    43ca:	724a      	lod	A, [S-75]
    43cc:	714b      	lod	A, dp:0x4b <_l_u8LinInFrameMsgID+0x1>
    43ce:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x4>
    43d0:	ea47      	sub	Y, [S-72]
    43d2:	e948      	sub	Y, dp:0x48 <_g_DiagResponse+0x6>
    43d4:	0003      	jmp	0x43dc <__mlx4_flash_start+0x3dc>
    43d6:	7346      	lod	A, ep:0x46 <_g_DiagResponse+0x4>
    43d8:	7247      	lod	A, [S-72]
    43da:	7148      	lod	A, dp:0x48 <_g_DiagResponse+0x6>
    43dc:	e684      	or	Y, io:0x4 <_LinMess>
    43de:	ed80      	cmp	Y, dp:0x80 <__data_size+0x1e>
    43e0:	0009      	jmp	0x43f4 <__mlx4_flash_start+0x3f4>
    43e2:	8350      	add	AL, ep:0x50 <_g_u16CommutTimerPeriod>
    43e4:	8a51      	sub	AL, [S-82]
    43e6:	8952      	sub	AL, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    43e8:	7350      	lod	A, ep:0x50 <_g_u16CommutTimerPeriod>
    43ea:	7251      	lod	A, [S-82]
    43ec:	7152      	lod	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    43ee:	b353      	adc	A, ep:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    43f0:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    43f2:	7353      	lod	A, ep:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    43f4:	6800      	lod	AH, #0
    43f6:	b157      	adc	A, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    43f8:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    43fa:	7157      	lod	A, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    43fc:	b156      	adc	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    43fe:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4400:	7156      	lod	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    4402:	b155      	adc	A, dp:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    4404:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4406:	7155      	lod	A, dp:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    4408:	b154      	adc	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    440a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    440c:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    440e:	b144      	adc	A, dp:0x44 <_g_DiagResponse+0x2>
    4410:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4412:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    4414:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x1>
    4416:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4418:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x1>
    441a:	b142      	adc	A, dp:0x42 <_g_DiagResponse>
    441c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    441e:	7142      	lod	A, dp:0x42 <_g_DiagResponse>
    4420:	b141      	adc	A, dp:0x41 <__data_dp_end+0x7>
    4422:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4424:	7141      	lod	A, dp:0x41 <__data_dp_end+0x7>
    4426:	b140      	adc	A, dp:0x40 <__data_dp_end+0x6>
    4428:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    442a:	7140      	lod	A, dp:0x40 <__data_dp_end+0x6>
    442c:	6800      	lod	AH, #0
    442e:	b139      	adc	A, dp:0x39 <_l_u8StallCountA>
    4430:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4432:	7139      	lod	A, dp:0x39 <_l_u8StallCountA>
    4434:	e14c      	add	Y, dp:0x4c <_g_u16CorrectionRatio>
    4436:	0006      	jmp	0x4444 <__mlx4_flash_start+0x444>
    4438:	0102      	jmp	0x463e <__mlx4_flash_start+0x63e>
    443a:	4050      	jmp	fp2:0x80
    443c:	222a      	add	X, [S-43]
    443e:	b20a      	adc	A, [S-11]
    4440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    4442:	2226      	add	X, [S-39]
    4444:	4592      	mov	dp:0x92 <__data_size+0x30>, YL
    4446:	b6e5      	and	A, MH
    4448:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    444a:	b7e5      	and	A, ep:0xe5 <_ml_driver_mode+0xf>
    444c:	7234      	lod	A, [S-53]
    444e:	7335      	lod	A, ep:0x35 <_g_u8MotorStopDelay>
    4450:	7208      	lod	A, [S-9]
    4452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    4454:	6800      	lod	AH, #0
    4456:	3e60      	xor	X, [S-97]
    4458:	3e90      	xor	X, io:0x10 <__dp_noinit_size>
    445a:	6800      	lod	AH, #0
    445c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    445e:	b208      	adc	A, [S-9]
    4460:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4462:	4616      	mov	[S-23], YL
    4464:	2228      	add	X, [S-41]
    4466:	820a      	add	AL, [S-11]
    4468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    446a:	8e80      	cmp	AL, io:0x0 <__dp__>
    446c:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    446e:	720a      	lod	A, [S-11]
    4470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    4472:	6800      	lod	AH, #0
    4474:	b739      	and	A, ep:0x39 <_l_u8StallCountA>
    4476:	b638      	and	A, [S-57]
    4478:	6800      	lod	AH, #0
    447a:	b53e      	and	A, dp:0x3e <__data_dp_end+0x4>
    447c:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    447e:	753e      	lod	PC, dp:0x3e <__data_dp_end+0x4>
    4480:	6800      	lod	AH, #0
    4482:	b330      	adc	A, ep:0x30 <_g_u8BufferOutID>
    4484:	b231      	adc	A, [S-50]
    4486:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4488:	8e80      	cmp	AL, io:0x0 <__dp__>
    448a:	7330      	lod	A, ep:0x30 <_g_u8BufferOutID>
    448c:	7231      	lod	A, [S-50]
    448e:	e336      	add	Y, ep:0x36 <_g_u16StartupDelay>
    4490:	ea37      	sub	Y, [S-56]
    4492:	6800      	lod	AH, #0
    4494:	0009      	jmp	0x44a8 <__mlx4_flash_start+0x4a8>
    4496:	b340      	adc	A, ep:0x40 <__data_dp_end+0x6>
    4498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    449a:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    449c:	b341      	adc	A, ep:0x41 <__data_dp_end+0x7>
    449e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    44a0:	7341      	lod	A, ep:0x41 <__data_dp_end+0x7>
    44a2:	b342      	adc	A, ep:0x42 <_g_DiagResponse>
    44a4:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    44a6:	2257      	add	X, [S-88]
    44a8:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    44aa:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    44ac:	7341      	lod	A, ep:0x41 <__data_dp_end+0x7>
    44ae:	7342      	lod	A, ep:0x42 <_g_DiagResponse>
    44b0:	6800      	lod	AH, #0
    44b2:	b354      	adc	A, ep:0x54 <_g_u16MotorCurrentMovAvgxN>
    44b4:	b255      	adc	A, [S-86]
    44b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    44b8:	8a03      	sub	AL, [S-4]
    44ba:	7354      	lod	A, ep:0x54 <_g_u16MotorCurrentMovAvgxN>
    44bc:	7255      	lod	A, [S-86]
    44be:	b356      	adc	A, ep:0x56 <_g_u16MotorCurrentLPFx64>
    44c0:	b257      	adc	A, [S-88]
    44c2:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    44c4:	8e80      	cmp	AL, io:0x0 <__dp__>
    44c6:	7356      	lod	A, ep:0x56 <_g_u16MotorCurrentLPFx64>
    44c8:	7257      	lod	A, [S-88]
    44ca:	6800      	lod	AH, #0
    44cc:	b354      	adc	A, ep:0x54 <_g_u16MotorCurrentMovAvgxN>
    44ce:	b255      	adc	A, [S-86]
    44d0:	e330      	add	Y, ep:0x30 <_g_u8BufferOutID>
    44d2:	ea31      	sub	Y, [S-50]
    44d4:	b356      	adc	A, ep:0x56 <_g_u16MotorCurrentLPFx64>
    44d6:	b257      	adc	A, [S-88]
    44d8:	eb32      	sub	Y, ep:0x32 <_l_u8ActDirection>
    44da:	ea33      	sub	Y, [S-52]
    44dc:	6800      	lod	AH, #0
    44de:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    44e0:	bf8f      	xor	A, ep:0x8f <__data_size+0x2d>
    44e2:	4040      	jmp	fp2:0x00
    44e4:	0108      	jmp	0x46f6 <__mlx4_flash_start+0x6f6>
    44e6:	3cc3      	xor	X, #-61
    44e8:	b782      	and	A, ep:0x82 <__data_size+0x20>
    44ea:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    44ec:	833c      	add	AL, ep:0x3c <__data_dp_end+0x2>
    44ee:	733c      	lod	A, ep:0x3c <__data_dp_end+0x2>
    44f0:	b33d      	adc	A, ep:0x3d <__data_dp_end+0x3>
    44f2:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    44f4:	733d      	lod	A, ep:0x3d <__data_dp_end+0x3>
    44f6:	6800      	lod	AH, #0
    44f8:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    44fa:	a78f      	or	A, ep:0x8f <__data_size+0x2d>
    44fc:	0101      	jmp	0x4700 <__mlx4_flash_start+0x700>
    44fe:	3cc3      	xor	X, #-61
    4500:	6800      	lod	AH, #0
    4502:	2939      	sub	X, dp:0x39 <_l_u8StallCountA>
    4504:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4506:	493c      	mov	dp:0x3c <__data_dp_end+0x2>, AH
    4508:	b681      	and	A, io:0x1 <__dp__+0x1>
    450a:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x6>
    450c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    450e:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4510:	b680      	and	A, io:0x0 <__dp__>
    4512:	b75e      	and	A, ep:0x5e <_g_NvramUser+0x6>
    4514:	b682      	and	A, io:0x2 <_LinCmnd>
    4516:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4518:	3b33      	subc	X, ep:0x33 <_g_u8NAD>
    451a:	6800      	lod	AH, #0
    451c:	3b12      	subc	X, ep:0x12 <__dp_noinit_size+0x2>
    451e:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    4520:	b787      	and	A, ep:0x87 <__data_size+0x25>
    4522:	b682      	and	A, io:0x2 <_LinCmnd>
    4524:	bfbc      	xor	A, ep:0xbc <__bss_dp_size+0xc>
    4526:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    4528:	6800      	lod	AH, #0
    452a:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    452c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    452e:	1106      	call	0x473c <__mlx4_flash_start+0x73c>
    4530:	e781      	or	Y, ep:0x81 <__data_size+0x1f>
    4532:	1108      	call	0x4744 <__mlx4_flash_start+0x744>
    4534:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4536:	7381      	lod	A, ep:0x81 <__data_size+0x1f>
    4538:	5404      	ret	#5
    453a:	202f      	add	X, #47
    453c:	e78e      	or	Y, ep:0x8e <__data_size+0x2c>
    453e:	0102      	jmp	0x4744 <__mlx4_flash_start+0x744>
    4540:	a752      	or	A, ep:0x52 <_g_u16TargetCommutTimerPeriod>
    4542:	1104      	call	0x474c <__mlx4_flash_start+0x74c>
    4544:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4546:	7381      	lod	A, ep:0x81 <__data_size+0x1f>
    4548:	5404      	ret	#5
    454a:	6800      	lod	AH, #0
    454c:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    454e:	7381      	lod	A, ep:0x81 <__data_size+0x1f>
    4550:	5404      	ret	#5
    4552:	e684      	or	Y, io:0x4 <_LinMess>
    4554:	1102      	call	0x475a <__mlx4_flash_start+0x75a>
    4556:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4558:	29d4      	sub	X, dp:0xd4 <_LinMessage>
    455a:	7201      	lod	A, [S-2]
    455c:	e682      	or	Y, io:0x2 <_LinCmnd>
    455e:	1101      	call	0x4762 <__mlx4_flash_start+0x762>
    4560:	248f      	or	X, #-113
    4562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    4564:	1101      	call	0x4768 <__mlx4_flash_start+0x768>
    4566:	2967      	sub	X, dp:0x67 <__data_size+0x5>
    4568:	2487      	or	X, #-121
    456a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    456c:	bf8d      	xor	A, ep:0x8d <__data_size+0x2b>
    456e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    4570:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4572:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    4574:	b782      	and	A, ep:0x82 <__data_size+0x20>
    4576:	22d2      	add	X, [A++]
    4578:	0b04      	setb	io:0x00.4
    457a:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    457c:	f788      	and	Y, ep:0x88 <__data_size+0x26>
    457e:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    4580:	22e5      	add	X, MH
    4582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    4584:	b20d      	adc	A, [S-14]
    4586:	7238      	lod	A, [S-57]
    4588:	b202      	adc	A, [S-3]
    458a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    458c:	b203      	adc	A, [S-4]
    458e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    4590:	b63e      	and	A, [S-63]
    4592:	22d7      	.word	0x22d7
    4594:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    4596:	7201      	lod	A, [S-2]
    4598:	7338      	lod	A, ep:0x38 <_l_u8StallCountO>
    459a:	b365      	adc	A, ep:0x65 <__data_size+0x3>
    459c:	bf81      	xor	A, ep:0x81 <__data_size+0x1f>
    459e:	0101      	jmp	0x47a2 <__mlx4_flash_start+0x7a2>
    45a0:	6800      	lod	AH, #0
    45a2:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    45a4:	0b04      	setb	io:0x00.4
    45a6:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    45a8:	f788      	and	Y, ep:0x88 <__data_size+0x26>
    45aa:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    45ac:	22e5      	add	X, MH
    45ae:	7334      	lod	A, ep:0x34 <_l_u8VTIdx>
    45b0:	7235      	lod	A, [S-54]
    45b2:	7388      	lod	A, ep:0x88 <__data_size+0x26>
    45b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    45b6:	718a      	lod	A, dp:0x8a <__data_size+0x28>
    45b8:	b338      	adc	A, ep:0x38 <_l_u8StallCountO>
    45ba:	738b      	lod	A, ep:0x8b <__data_size+0x29>
    45bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    45be:	b20f      	adc	A, [S-16]
    45c0:	738e      	lod	A, ep:0x8e <__data_size+0x2c>
    45c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    45c4:	5408      	ret	#9
    45c6:	7ca6      	lod	X, #-90
    45c8:	7d34      	lod	X, dp:0x34 <_l_u8VTIdx>
    45ca:	6800      	lod	AH, #0
    45cc:	b384      	adc	A, ep:0x84 <__data_size+0x22>
    45ce:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    45d0:	7380      	lod	A, ep:0x80 <__data_size+0x1e>
    45d2:	7334      	lod	A, ep:0x34 <_l_u8VTIdx>
    45d4:	7235      	lod	A, [S-54]
    45d6:	7ca7      	lod	X, #-89
    45d8:	7d34      	lod	X, dp:0x34 <_l_u8VTIdx>
    45da:	6c03      	lod	YH, #3
    45dc:	2300      	add	X, ep:0x0 <__dp__>
    45de:	2295      	add	X, io:0x15 <__dp_noinit_size+0x5>
    45e0:	23ee      	add	X, ep:0xee <_g_u16ActualPosition>
    45e2:	2300      	add	X, ep:0x0 <__dp__>
    45e4:	2300      	add	X, ep:0x0 <__dp__>
    45e6:	23a1      	add	X, ep:0xa1 <__data_size+0x3f>
    45e8:	240b      	or	X, #11
    45ea:	23cb      	add	X, ep:0xcb <_LinFrameDataBuffer+0x1>
    45ec:	2300      	add	X, ep:0x0 <__dp__>
    45ee:	2300      	add	X, ep:0x0 <__dp__>
    45f0:	2304      	add	X, ep:0x4 <_LinMess>
    45f2:	23c3      	add	X, ep:0xc3 <__bss_dp_size+0x13>
    45f4:	23e6      	add	X, ep:0xe6 <_ml_driver_mode+0x10>
    45f6:	23da      	add	X, ep:0xda <_ml_driver_mode+0x4>
    45f8:	2300      	add	X, ep:0x0 <__dp__>
    45fa:	23b7      	add	X, ep:0xb7 <__bss_dp_size+0x7>
    45fc:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    45fe:	2301      	add	X, ep:0x1 <__dp__+0x1>
    4600:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4602:	7381      	lod	A, ep:0x81 <__data_size+0x1f>
    4604:	5404      	ret	#5
    4606:	6800      	lod	AH, #0
    4608:	e682      	or	Y, io:0x2 <_LinCmnd>
    460a:	0104      	jmp	0x4814 <__mlx4_flash_start+0x814>
    460c:	b681      	and	A, io:0x1 <__dp__+0x1>
    460e:	7282      	lod	A, io:0x2 <_LinCmnd>
    4610:	b684      	and	A, io:0x4 <_LinMess>
    4612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    4614:	b680      	and	A, io:0x0 <__dp__>
    4616:	7282      	lod	A, io:0x2 <_LinCmnd>
    4618:	b680      	and	A, io:0x0 <__dp__>
    461a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    461c:	22fe      	add	X, [X+6]
    461e:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4620:	a688      	or	A, io:0x8 <__bist_stat_size>
    4622:	0102      	jmp	0x4828 <__mlx4_flash_start+0x828>
    4624:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4626:	2315      	add	X, ep:0x15 <__dp_noinit_size+0x5>
    4628:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    462a:	7170      	lod	A, dp:0x70 <__data_size+0xe>
    462c:	a684      	or	A, io:0x4 <_LinMess>
    462e:	0101      	jmp	0x4832 <__mlx4_flash_start+0x832>
    4630:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    4634:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4636:	7271      	lod	A, [S-114]
    4638:	b286      	adc	A, io:0x6 <_LinMess2>
    463a:	4616      	mov	[S-23], YL
    463c:	7286      	lod	A, io:0x6 <_LinMess2>
    463e:	b271      	adc	A, [S-114]
    4640:	b5a3      	and	A, dp:0xa3 <__data_size+0x41>
    4642:	0009      	jmp	0x4656 <__mlx4_flash_start+0x656>
    4644:	6c02      	lod	YH, #2
    4646:	bd8e      	xor	A, dp:0x8e <__data_size+0x2c>
    4648:	2333      	add	X, ep:0x33 <_g_u8NAD>
    464a:	bd8d      	xor	A, dp:0x8d <__data_size+0x2b>
    464c:	2333      	add	X, ep:0x33 <_g_u8NAD>
    464e:	bd8b      	xor	A, dp:0x8b <__data_size+0x29>
    4650:	2333      	add	X, ep:0x33 <_g_u8NAD>
    4652:	bd87      	xor	A, dp:0x87 <__data_size+0x25>
    4654:	2333      	add	X, ep:0x33 <_g_u8NAD>
    4656:	6c02      	lod	YH, #2
    4658:	f581      	and	Y, dp:0x81 <__data_size+0x1f>
    465a:	2333      	add	X, ep:0x33 <_g_u8NAD>
    465c:	f582      	and	Y, dp:0x82 <__data_size+0x20>
    465e:	2333      	add	X, ep:0x33 <_g_u8NAD>
    4660:	f584      	and	Y, dp:0x84 <__data_size+0x22>
    4662:	2333      	add	X, ep:0x33 <_g_u8NAD>
    4664:	f588      	and	Y, dp:0x88 <__data_size+0x26>
    4666:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4668:	b170      	adc	A, dp:0x70 <__data_size+0xe>
    466a:	76a3      	jmp	io:0x23 <__data_dp_size+0x1>
    466c:	e78a      	or	Y, ep:0x8a <__data_size+0x28>
    466e:	1008      	call	0x4680 <__mlx4_flash_start+0x680>
    4670:	8782      	or	AL, ep:0x82 <__data_size+0x20>
    4672:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4674:	a783      	or	A, ep:0x83 <__data_size+0x21>
    4676:	4794      	mov	ep:0x94 <__data_size+0x32>, YL
    4678:	0101      	jmp	0x487c <__mlx4_flash_start+0x87c>
    467a:	231c      	add	X, ep:0x1c <_g_e8EXVMoveEnableRequestFlag>
    467c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    467e:	231d      	add	X, ep:0x1d <_g_e8CalibrationStep>
    4680:	e78c      	or	Y, ep:0x8c <__data_size+0x2a>
    4682:	1003      	call	0x468a <__mlx4_flash_start+0x68a>
    4684:	8782      	or	AL, ep:0x82 <__data_size+0x20>
    4686:	4050      	jmp	fp2:0x80
    4688:	231f      	add	X, ep:0x1f <_g_u8StallTypeComm>
    468a:	22fe      	add	X, [X+6]
    468c:	b202      	adc	A, [S-3]
    468e:	b36b      	adc	A, ep:0x6b <__data_size+0x9>
    4690:	836a      	add	AL, ep:0x6a <__data_size+0x8>
    4692:	736b      	lod	A, ep:0x6b <__data_size+0x9>
    4694:	bf81      	xor	A, ep:0x81 <__data_size+0x1f>
    4696:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4698:	6c03      	lod	YH, #3
    469a:	2375      	add	X, ep:0x75 <__data_size+0x13>
    469c:	2351      	add	X, ep:0x51 <_g_u16CommutTimerPeriod+0x1>
    469e:	236c      	add	X, ep:0x6c <__data_size+0xa>
    46a0:	2375      	add	X, ep:0x75 <__data_size+0x13>
    46a2:	8681      	or	AL, io:0x1 <__dp__+0x1>
    46a4:	7202      	lod	A, [S-3]
    46a6:	b203      	adc	A, [S-4]
    46a8:	8e80      	cmp	AL, io:0x0 <__dp__>
    46aa:	f36b      	adc	Y, ep:0x6b <__data_size+0x9>
    46ac:	736b      	lod	A, ep:0x6b <__data_size+0x9>
    46ae:	b786      	and	A, ep:0x86 <__data_size+0x24>
    46b0:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x4>
    46b2:	0002      	jmp	0x46b8 <__mlx4_flash_start+0x6b8>
    46b4:	0106      	jmp	0x48c2 <__mlx4_flash_start+0x8c2>
    46b6:	2373      	add	X, ep:0x73 <__data_size+0x11>
    46b8:	b787      	and	A, ep:0x87 <__data_size+0x25>
    46ba:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x4>
    46bc:	1003      	call	0x46c4 <__mlx4_flash_start+0x6c4>
    46be:	b78f      	and	A, ep:0x8f <__data_size+0x2d>
    46c0:	2362      	add	X, ep:0x62 <__data_size>
    46c2:	b783      	and	A, ep:0x83 <__data_size+0x21>
    46c4:	0000      	nop
    46c6:	0000      	nop
    46c8:	0000      	nop
    46ca:	0000      	nop
    46cc:	0000      	nop
    46ce:	0000      	nop
    46d0:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    46d2:	e780      	or	Y, ep:0x80 <__data_size+0x1e>
    46d4:	0108      	jmp	0x48e6 <__mlx4_flash_start+0x8e6>
    46d6:	2362      	add	X, ep:0x62 <__data_size>
    46d8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    46da:	7202      	lod	A, [S-3]
    46dc:	b203      	adc	A, [S-4]
    46de:	ce80      	cmp	AH, io:0x0 <__dp__>
    46e0:	b78e      	and	A, ep:0x8e <__data_size+0x2c>
    46e2:	bb6b      	subc	A, ep:0x6b <__data_size+0x9>
    46e4:	736b      	lod	A, ep:0x6b <__data_size+0x9>
    46e6:	7203      	lod	A, [S-4]
    46e8:	4c02 6800 	add	D, #1920034816
    46ec:	7271 
    46ee:	b16d      	adc	A, dp:0x6d <__data_size+0xb>
    46f0:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    46f2:	716d      	lod	A, dp:0x6d <__data_size+0xb>
    46f4:	0b04      	setb	io:0x00.4
    46f6:	b25e      	adc	A, [S-95]
    46f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    46fa:	725e      	lod	A, [S-95]
    46fc:	2388      	add	X, ep:0x88 <__data_size+0x26>
    46fe:	7189      	lod	A, dp:0x89 <__data_size+0x27>
    4700:	7134      	lod	A, dp:0x34 <_l_u8VTIdx>
    4702:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4704:	7335      	lod	A, ep:0x35 <_g_u8MotorStopDelay>
    4706:	b787      	and	A, ep:0x87 <__data_size+0x25>
    4708:	7388      	lod	A, ep:0x88 <__data_size+0x26>
    470a:	5408      	ret	#9
    470c:	7c55      	lod	X, #85
    470e:	7d34      	lod	X, dp:0x34 <_l_u8VTIdx>
    4710:	b691      	and	A, io:0x11 <__dp_noinit_size+0x1>
    4712:	b588      	and	A, dp:0x88 <__data_size+0x26>
    4714:	3beb      	subc	X, ep:0xeb <_g_e8MotorStatusMode>
    4716:	b5a6      	and	A, dp:0xa6 <__data_size+0x44>
    4718:	716e      	lod	A, dp:0x6e <__data_size+0xc>
    471a:	a58f      	or	A, dp:0x8f <__data_size+0x2d>
    471c:	1103      	call	0x4924 <__mlx4_flash_start+0x924>
    471e:	b16c      	adc	A, dp:0x6c <__data_size+0xa>
    4720:	bd84      	xor	A, dp:0x84 <__data_size+0x22>
    4722:	716c      	lod	A, dp:0x6c <__data_size+0xa>
    4724:	b271      	adc	A, [S-114]
    4726:	6800      	lod	AH, #0
    4728:	a688      	or	A, io:0x8 <__bist_stat_size>
    472a:	110a      	call	0x4940 <__mlx4_flash_start+0x940>
    472c:	b23b      	adc	A, [S-60]
    472e:	f684      	and	Y, io:0x4 <_LinMess>
    4730:	723b      	lod	A, [S-60]
    4732:	b35a      	adc	A, ep:0x5a <_g_NvramUser+0x2>
    4734:	7342      	lod	A, ep:0x42 <_g_DiagResponse>
    4736:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4738:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    473a:	7341      	lod	A, ep:0x41 <__data_dp_end+0x7>
    473c:	7343      	lod	A, ep:0x43 <_g_DiagResponse+0x1>
    473e:	7344      	lod	A, ep:0x44 <_g_DiagResponse+0x2>
    4740:	6800      	lod	AH, #0
    4742:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4744:	b286      	adc	A, io:0x6 <_LinMess2>
    4746:	010a      	jmp	0x495c <__mlx4_flash_start+0x95c>
    4748:	000e      	jmp	0x4766 <__mlx4_flash_start+0x766>
    474a:	e680      	or	Y, io:0x0 <__dp__>
    474c:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x7>
    474e:	0103      	jmp	0x4956 <__mlx4_flash_start+0x956>
    4750:	f782      	and	Y, ep:0x82 <__data_size+0x20>
    4752:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    4754:	22fe      	add	X, [X+6]
    4756:	bf8d      	xor	A, ep:0x8d <__data_size+0x2b>
    4758:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    475a:	22fe      	add	X, [X+6]
    475c:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    475e:	f788      	and	Y, ep:0x88 <__data_size+0x26>
    4760:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    4762:	7200      	lod	A, [S-1]
    4764:	22fe      	add	X, [X+6]
    4766:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4768:	f784      	and	Y, ep:0x84 <__data_size+0x22>
    476a:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    476c:	22fe      	add	X, [X+6]
    476e:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    4770:	bf8d      	xor	A, ep:0x8d <__data_size+0x2b>
    4772:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    4774:	a682      	or	A, io:0x2 <_LinCmnd>
    4776:	1106      	call	0x4984 <__mlx4_flash_start+0x984>
    4778:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x7>
    477a:	bf8e      	xor	A, ep:0x8e <__data_size+0x2c>
    477c:	a681      	or	A, io:0x1 <__dp__+0x1>
    477e:	0101      	jmp	0x4982 <__mlx4_flash_start+0x982>
    4780:	f781      	and	Y, ep:0x81 <__data_size+0x1f>
    4782:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    4784:	22fe      	add	X, [X+6]
    4786:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4788:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    478a:	0101      	jmp	0x498e <__mlx4_flash_start+0x98e>
    478c:	2300      	add	X, ep:0x0 <__dp__>
    478e:	7264      	lod	A, [S-101]
    4790:	b286      	adc	A, io:0x6 <_LinMess2>
    4792:	7265      	lod	A, [S-102]
    4794:	22fe      	add	X, [X+6]
    4796:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4798:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    479a:	0101      	jmp	0x499e <__mlx4_flash_start+0x99e>
    479c:	2300      	add	X, ep:0x0 <__dp__>
    479e:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    47a0:	be86      	xor	A, io:0x6 <_LinMess2>
    47a2:	6c02      	lod	YH, #2
    47a4:	3e04      	xor	X, [S-5]
    47a6:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x3>
    47a8:	3e05      	xor	X, [S-6]
    47aa:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x3>
    47ac:	3e06      	xor	X, [S-7]
    47ae:	23d9      	add	X, ep:0xd9 <_ml_driver_mode+0x3>
    47b0:	3e07      	xor	X, [S-8]
    47b2:	22fe      	add	X, [X+6]
    47b4:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    47b6:	e681      	or	Y, io:0x1 <__dp__+0x1>
    47b8:	0106      	jmp	0x49c6 <__mlx4_flash_start+0x9c6>
    47ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    47bc:	0102      	jmp	0x49c2 <__mlx4_flash_start+0x9c2>
    47be:	b680      	and	A, io:0x0 <__dp__>
    47c0:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0xe>
    47c2:	b682      	and	A, io:0x2 <_LinCmnd>
    47c4:	23e4      	add	X, ep:0xe4 <_ml_driver_mode+0xe>
    47c6:	b684      	and	A, io:0x4 <_LinMess>
    47c8:	726c      	lod	A, [S-109]
    47ca:	22fe      	add	X, [X+6]
    47cc:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    47ce:	7382      	lod	A, ep:0x82 <__data_size+0x20>
    47d0:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    47d2:	7383      	lod	A, ep:0x83 <__data_size+0x21>
    47d4:	f686      	and	Y, io:0x6 <_LinMess2>
    47d6:	bf92      	xor	A, ep:0x92 <__data_size+0x30>
    47d8:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    47da:	22fe      	add	X, [X+6]
    47dc:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    47de:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    47e0:	0101      	jmp	0x49e4 <__mlx4_flash_start+0x9e4>
    47e2:	2300      	add	X, ep:0x0 <__dp__>
    47e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    47e6:	010e      	jmp	0x4a04 <__mlx4_flash_start+0xa04>
    47e8:	763e      	jmp	[S-63]
    47ea:	7207      	lod	A, [S-8]
    47ec:	7206      	lod	A, [S-7]
    47ee:	b286      	adc	A, io:0x6 <_LinMess2>
    47f0:	7202      	lod	A, [S-3]
    47f2:	7204      	lod	A, [S-5]
    47f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    47f6:	7203      	lod	A, [S-4]
    47f8:	7205      	lod	A, [S-6]
    47fa:	b25c      	adc	A, [S-93]
    47fc:	f684      	and	Y, io:0x4 <_LinMess>
    47fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4800:	725c      	lod	A, [S-93]
    4802:	22fe      	add	X, [X+6]
    4804:	b25c      	adc	A, [S-93]
    4806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4808:	b386      	adc	A, ep:0x86 <__data_size+0x24>
    480a:	e780      	or	Y, ep:0x80 <__data_size+0x1e>
    480c:	0101      	jmp	0x4a10 <__mlx4_flash_start+0xa10>
    480e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    4812:	725c      	lod	A, [S-93]
    4814:	22fe      	add	X, [X+6]
    4816:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4818:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    481a:	0101      	jmp	0x4a1e <__mlx4_flash_start+0xa1e>
    481c:	2300      	add	X, ep:0x0 <__dp__>
    481e:	b387      	adc	A, ep:0x87 <__data_size+0x25>
    4820:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4822:	0001      	jmp	0x4826 <__mlx4_flash_start+0x826>
    4824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    4826:	7271      	lod	A, [S-114]
    4828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    482a:	4608      	mov	[S-9], YL
    482c:	6c02      	lod	YH, #2
    482e:	b11c      	adc	A, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4830:	241e      	or	X, #30
    4832:	b11d      	adc	A, dp:0x1d <_g_e8CalibrationStep>
    4834:	241e      	or	X, #30
    4836:	b12c      	adc	A, dp:0x2c <_g_e8ErrorCoil>
    4838:	241e      	or	X, #30
    483a:	b12d      	adc	A, dp:0x2d <_g_e8ErrorElectric>
    483c:	b387      	adc	A, ep:0x87 <__data_size+0x25>
    483e:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4840:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4842:	b371      	adc	A, ep:0x71 <__data_size+0xf>
    4844:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    4846:	4788      	mov	ep:0x88 <__data_size+0x26>, YL
    4848:	0009      	jmp	0x485c <__mlx4_flash_start+0x85c>
    484a:	6c03      	lod	YH, #3
    484c:	bd8e      	xor	A, dp:0x8e <__data_size+0x2c>
    484e:	2436      	or	X, #54
    4850:	bd8d      	xor	A, dp:0x8d <__data_size+0x2b>
    4852:	2436      	or	X, #54
    4854:	bd8b      	xor	A, dp:0x8b <__data_size+0x29>
    4856:	2436      	or	X, #54
    4858:	bd87      	xor	A, dp:0x87 <__data_size+0x25>
    485a:	2436      	or	X, #54
    485c:	6c03      	lod	YH, #3
    485e:	f581      	and	Y, dp:0x81 <__data_size+0x1f>
    4860:	2436      	or	X, #54
    4862:	f582      	and	Y, dp:0x82 <__data_size+0x20>
    4864:	2436      	or	X, #54
    4866:	f584      	and	Y, dp:0x84 <__data_size+0x22>
    4868:	2436      	or	X, #54
    486a:	f588      	and	Y, dp:0x88 <__data_size+0x26>
    486c:	6c02      	lod	YH, #2
    486e:	711c      	lod	A, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4870:	243e      	or	X, #62
    4872:	711d      	lod	A, dp:0x1d <_g_e8CalibrationStep>
    4874:	243e      	or	X, #62
    4876:	712c      	lod	A, dp:0x2c <_g_e8ErrorCoil>
    4878:	243e      	or	X, #62
    487a:	712d      	lod	A, dp:0x2d <_g_e8ErrorElectric>
    487c:	22fe      	add	X, [X+6]
    487e:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4880:	b682      	and	A, io:0x2 <_LinCmnd>
    4882:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4884:	7c01      	lod	X, #1
    4886:	5018      	call	fp0:0xC0
    4888:	54c0      	.word	0x54c0
    488a:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    488c:	733e      	lod	A, ep:0x3e <__data_dp_end+0x4>
    488e:	733f      	lod	A, ep:0x3f <__data_dp_end+0x5>
    4890:	5401      	ret
    4892:	3e60      	xor	X, [S-97]
    4894:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4896:	773a      	lod	PC, ep:0x3a <__data_dp_end>
    4898:	773b      	lod	PC, ep:0x3b <__data_dp_end+0x1>
    489a:	773f      	lod	PC, ep:0x3f <__data_dp_end+0x5>
    489c:	355b      	and	X, dp:0x5b <_g_NvramUser+0x3>
    489e:	365b      	and	X, [S-92]
    48a0:	3730      	and	X, ep:0x30 <_g_u8BufferOutID>
    48a2:	7736      	lod	PC, ep:0x36 <_g_u16StartupDelay>
    48a4:	3ba0      	subc	X, ep:0xa0 <__data_size+0x3e>
    48a6:	b78f      	and	A, ep:0x8f <__data_size+0x2d>
    48a8:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    48aa:	b681      	and	A, io:0x1 <__dp__+0x1>
    48ac:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48ae:	b78e      	and	A, ep:0x8e <__data_size+0x2c>
    48b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    48b2:	b680      	and	A, io:0x0 <__dp__>
    48b4:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    48b6:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    48b8:	7301      	lod	A, ep:0x1 <__dp__+0x1>
    48ba:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    48bc:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    48be:	494e      	mov	dp:0x4e <_g_u16MicroStepIdx>, AH
    48c0:	4930      	mov	dp:0x30 <_g_u8BufferOutID>, AH
    48c2:	493a      	mov	dp:0x3a <__data_dp_end>, AH
    48c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    48c6:	4964      	mov	dp:0x64 <__data_size+0x2>, AH
    48c8:	735f      	lod	A, ep:0x5f <_g_NvramUser+0x7>
    48ca:	736c      	lod	A, ep:0x6c <__data_size+0xa>
    48cc:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x4>
    48ce:	7338      	lod	A, ep:0x38 <_l_u8StallCountO>
    48d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    48d2:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    48d4:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    48d6:	b58b      	and	A, dp:0x8b <__data_size+0x29>
    48d8:	7105      	lod	A, dp:0x5 <_LinMess+0x1>
    48da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    48dc:	b58c      	and	A, dp:0x8c <__data_size+0x2a>
    48de:	7104      	lod	A, dp:0x4 <_LinMess>
    48e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    48e2:	b583      	and	A, dp:0x83 <__data_size+0x21>
    48e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    48e6:	7106      	lod	A, dp:0x6 <_LinMess2>
    48e8:	b680      	and	A, io:0x0 <__dp__>
    48ea:	77c6      	lod	PC, ep:0xc6 <__bss_dp_size+0x16>
    48ec:	77ca      	lod	PC, ep:0xca <_LinFrameDataBuffer>
    48ee:	8681      	or	AL, io:0x1 <__dp__+0x1>
    48f0:	0101      	jmp	0x4af4 <__mlx4_flash_start+0xaf4>
    48f2:	2475      	or	X, #117
    48f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    48f6:	7336      	lod	A, ep:0x36 <_g_u16StartupDelay>
    48f8:	7237      	lod	A, [S-56]
    48fa:	b788      	and	A, ep:0x88 <__data_size+0x26>
    48fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    48fe:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4900:	738c      	lod	A, ep:0x8c <__data_size+0x2a>
    4902:	b784      	and	A, ep:0x84 <__data_size+0x22>
    4904:	738d      	lod	A, ep:0x8d <__data_size+0x2b>
    4906:	7c02      	lod	X, #2
    4908:	5820      	inc	S, #33
    490a:	b681      	and	A, io:0x1 <__dp__+0x1>
    490c:	62ca      	lod	AL, [--PC]
    490e:	622b      	lod	AL, [S-44]
    4910:	3448      	and	X, #72
    4912:	5809      	inc	S, #10
    4914:	62e6      	lod	AL, Y
    4916:	2489      	or	X, #-119
    4918:	b78a      	and	A, ep:0x8a <__data_size+0x28>
    491a:	b682      	and	A, io:0x2 <_LinCmnd>
    491c:	62ca      	lod	AL, [--PC]
    491e:	5018      	call	fp0:0xC0
    4920:	54c0      	.word	0x54c0
    4922:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4924:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    4926:	24a3      	or	X, #-93
    4928:	b680      	and	A, io:0x0 <__dp__>
    492a:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    492c:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    492e:	0106      	jmp	0x4b3c <__mlx4_flash_start+0xb3c>
    4930:	bf8e      	xor	A, ep:0x8e <__data_size+0x2c>
    4932:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    4934:	b239      	adc	A, [S-58]
    4936:	7238      	lod	A, [S-57]
    4938:	b582      	and	A, dp:0x82 <__data_size+0x20>
    493a:	b686      	and	A, io:0x6 <_LinMess2>
    493c:	e680      	or	Y, io:0x0 <__dp__>
    493e:	0101      	jmp	0x4b42 <__mlx4_flash_start+0xb42>
    4940:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4942:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4944:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    4946:	b16f      	adc	A, dp:0x6f <__data_size+0xd>
    4948:	bd88      	xor	A, dp:0x88 <__data_size+0x26>
    494a:	716f      	lod	A, dp:0x6f <__data_size+0xd>
    494c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    494e:	a78d      	or	A, ep:0x8d <__data_size+0x2b>
    4950:	1101      	call	0x4b54 <__mlx4_flash_start+0xb54>
    4952:	24c2      	or	X, #-62
    4954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    4956:	494e      	mov	dp:0x4e <_g_u16MicroStepIdx>, AH
    4958:	b58e      	and	A, dp:0x8e <__data_size+0x2c>
    495a:	b561      	and	A, dp:0x61 <_g_NvramUser+0x9>
    495c:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x4>
    495e:	1101      	call	0x4b62 <__mlx4_flash_start+0xb62>
    4960:	24c2      	or	X, #-62
    4962:	b340      	adc	A, ep:0x40 <__data_dp_end+0x6>
    4964:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    4966:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    4968:	b341      	adc	A, ep:0x41 <__data_dp_end+0x7>
    496a:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    496c:	7341      	lod	A, ep:0x41 <__data_dp_end+0x7>
    496e:	b342      	adc	A, ep:0x42 <_g_DiagResponse>
    4970:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4972:	7342      	lod	A, ep:0x42 <_g_DiagResponse>
    4974:	b343      	adc	A, ep:0x43 <_g_DiagResponse+0x1>
    4976:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4978:	7343      	lod	A, ep:0x43 <_g_DiagResponse+0x1>
    497a:	b344      	adc	A, ep:0x44 <_g_DiagResponse+0x2>
    497c:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    497e:	7344      	lod	A, ep:0x44 <_g_DiagResponse+0x2>
    4980:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4982:	24ae      	or	X, #-82
    4984:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4986:	7166      	lod	A, dp:0x66 <__data_size+0x4>
    4988:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    498a:	7167      	lod	A, dp:0x67 <__data_size+0x5>
    498c:	b58e      	and	A, dp:0x8e <__data_size+0x2c>
    498e:	b561      	and	A, dp:0x61 <_g_NvramUser+0x9>
    4990:	e106      	add	Y, dp:0x6 <_LinMess2>
    4992:	0108      	jmp	0x4ba4 <__mlx4_flash_start+0xba4>
    4994:	b266      	adc	A, [S-103]
    4996:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4998:	7266      	lod	A, [S-103]
    499a:	b267      	adc	A, [S-104]
    499c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    499e:	7267      	lod	A, [S-104]
    49a0:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    49a2:	24c8      	or	X, #-56
    49a4:	4d66      	mov	dp:0x66 <__data_size+0x4>, YH
    49a6:	4968      	mov	dp:0x68 <__data_size+0x6>, AH
    49a8:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    49aa:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    49ac:	733a      	lod	A, ep:0x3a <__data_dp_end>
    49ae:	623a      	lod	AL, [S-59]
    49b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    49b2:	1104      	call	0x4bbc <__mlx4_flash_start+0xbbc>
    49b4:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    49b6:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    49b8:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    49ba:	24f2      	or	X, #-14
    49bc:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    49be:	a78d      	or	A, ep:0x8d <__data_size+0x2b>
    49c0:	0103      	jmp	0x4bc8 <__mlx4_flash_start+0xbc8>
    49c2:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    49c4:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    49c6:	2494      	or	X, #-108
    49c8:	580e      	inc	S, #15
    49ca:	0803      	clrb	dp:0x00.3
    49cc:	0906      	clrb	io:0x00.6
    49ce:	62e6      	lod	AL, Y
    49d0:	24e4      	or	X, #-28
    49d2:	623a      	lod	AL, [S-59]
    49d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    49d6:	0106      	jmp	0x4be4 <__mlx4_flash_start+0xbe4>
    49d8:	24e4      	or	X, #-28
    49da:	626f      	lod	AL, [S-112]
    49dc:	0001      	jmp	0x49e0 <__mlx4_flash_start+0x9e0>
    49de:	24e9      	or	X, #-23
    49e0:	b586      	and	A, dp:0x86 <__data_size+0x24>
    49e2:	29d4      	sub	X, dp:0xd4 <_LinMessage>
    49e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    49e6:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    49e8:	380d      	subc	X, #13
    49ea:	3805      	subc	X, #5
    49ec:	3479      	and	X, #121
    49ee:	303a      	adc	X, #58
    49f0:	39f6      	subc	X, dp:0xf6 <_g_u16ActuatorActPos>
    49f2:	b26c      	adc	A, [S-109]
    49f4:	a686      	or	A, io:0x6 <_LinMess2>
    49f6:	0106      	jmp	0x4c04 <__mlx4_flash_start+0xc04>
    49f8:	f681      	and	Y, io:0x1 <__dp__+0x1>
    49fa:	726c      	lod	A, [S-109]
    49fc:	b26e      	adc	A, [S-111]
    49fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    4a00:	1101      	call	0x4c04 <__mlx4_flash_start+0xc04>
    4a02:	6376      	lod	AL, ep:0x76 <__data_size+0x14>
    4a04:	3cc3      	xor	X, #-61
    4a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    4a08:	be38      	xor	A, [S-57]
    4a0a:	0101      	jmp	0x4c0e <__mlx4_flash_start+0xc0e>
    4a0c:	2494      	or	X, #-108
    4a0e:	580e      	inc	S, #15
    4a10:	0905      	clrb	io:0x00.5
    4a12:	0802      	clrb	dp:0x00.2
    4a14:	62e6      	lod	AL, Y
    4a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a18:	623a      	lod	AL, [S-59]
    4a1a:	2522      	or	X, dp:0x22 <__data_dp_size>
    4a1c:	623a      	lod	AL, [S-59]
    4a1e:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x4>
    4a20:	bd8e      	xor	A, dp:0x8e <__data_size+0x2c>
    4a22:	a681      	or	A, io:0x1 <__dp__+0x1>
    4a24:	1102      	call	0x4c2a <__mlx4_flash_start+0xc2a>
    4a26:	a78c      	or	A, ep:0x8c <__data_size+0x2a>
    4a28:	0101      	jmp	0x4c2c <__mlx4_flash_start+0xc2c>
    4a2a:	f581      	and	Y, dp:0x81 <__data_size+0x1f>
    4a2c:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x4>
    4a2e:	4050      	jmp	fp2:0x80
    4a30:	6c04      	lod	YH, #4
    4a32:	2528      	or	X, dp:0x28 <_g_u8StallOcc>
    4a34:	2542      	or	X, dp:0x42 <_g_DiagResponse>
    4a36:	254f      	or	X, dp:0x4f <_g_u16MicroStepIdx+0x1>
    4a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a3a:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x4>
    4a3c:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    4a3e:	0107      	jmp	0x4c4e <__mlx4_flash_start+0xc4e>
    4a40:	bd8e      	xor	A, dp:0x8e <__data_size+0x2c>
    4a42:	715c      	lod	A, dp:0x5c <_g_NvramUser+0x4>
    4a44:	484f      	macu	D, AL, [X]
    4a46:	6c04      	lod	YH, #4
    4a48:	2557      	or	X, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    4a4a:	2584      	or	X, dp:0x84 <__data_size+0x22>
    4a4c:	25c6      	or	X, dp:0xc6 <__bss_dp_size+0x16>
    4a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a50:	484e      	macu	D, AL, [X++]
    4a52:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4a54:	e583      	or	Y, dp:0x83 <__data_size+0x21>
    4a56:	1104      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a58:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x1>
    4a5a:	e585      	or	Y, dp:0x85 <__data_size+0x23>
    4a5c:	1101      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a5e:	2918      	sub	X, dp:0x18 <__data_dp_start>
    4a60:	b16c      	adc	A, dp:0x6c <__data_size+0xa>
    4a62:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    4a64:	010e      	jmp	0x4c82 <__mlx4_flash_start+0xc82>
    4a66:	b168      	adc	A, dp:0x68 <__data_size+0x6>
    4a68:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4a6a:	7168      	lod	A, dp:0x68 <__data_size+0x6>
    4a6c:	b169      	adc	A, dp:0x69 <__data_size+0x7>
    4a6e:	cd80      	cmp	AH, dp:0x80 <__data_size+0x1e>
    4a70:	7169      	lod	A, dp:0x69 <__data_size+0x7>
    4a72:	1107      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a74:	4d66      	mov	dp:0x66 <__data_size+0x4>, YH
    4a76:	4968      	mov	dp:0x68 <__data_size+0x6>, AH
    4a78:	b16e      	adc	A, dp:0x6e <__data_size+0xc>
    4a7a:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4a7c:	716e      	lod	A, dp:0x6e <__data_size+0xc>
    4a7e:	1101      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a80:	6376      	lod	AL, ep:0x76 <__data_size+0x14>
    4a82:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4a84:	61d6      	lod	AL, dp:0xd6 <_ml_driver_mode>
    4a86:	7271      	lod	A, [S-114]
    4a88:	b256      	adc	A, [S-87]
    4a8a:	c242      	add	AH, [S-67]
    4a8c:	c943      	sub	AH, dp:0x43 <_g_DiagResponse+0x1>
    4a8e:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4a90:	4616      	mov	[S-23], YL
    4a92:	e242      	add	Y, [S-67]
    4a94:	e943      	sub	Y, dp:0x43 <_g_DiagResponse+0x1>
    4a96:	1002      	call	0x4a9c <__mlx4_flash_start+0xa9c>
    4a98:	b271      	adc	A, [S-114]
    4a9a:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4a9c:	2494      	or	X, #-108
    4a9e:	b15a      	adc	A, dp:0x5a <_g_NvramUser+0x2>
    4aa0:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4aa2:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x2>
    4aa4:	e583      	or	Y, dp:0x83 <__data_size+0x21>
    4aa6:	1001      	call	0x4aaa <__mlx4_flash_start+0xaaa>
    4aa8:	251d      	or	X, dp:0x1d <_g_e8CalibrationStep>
    4aaa:	6394      	lod	AL, ep:0x94 <__data_size+0x32>
    4aac:	25ee      	or	X, dp:0xee <_g_u16ActualPosition>
    4aae:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    4ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4ab2:	1102      	call	0x4cb8 <__mlx4_flash_start+0xcb8>
    4ab4:	7c06      	lod	X, #6
    4ab6:	2494      	or	X, #-108
    4ab8:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4aba:	e144      	add	Y, dp:0x44 <_g_DiagResponse+0x2>
    4abc:	0005      	jmp	0x4ac8 <__mlx4_flash_start+0xac8>
    4abe:	b142      	adc	A, dp:0x42 <_g_DiagResponse>
    4ac0:	e589      	or	Y, dp:0x89 <__data_size+0x27>
    4ac2:	b143      	adc	A, dp:0x43 <_g_DiagResponse+0x1>
    4ac4:	ed81      	cmp	Y, dp:0x81 <__data_size+0x1f>
    4ac6:	0003      	jmp	0x4ace <__mlx4_flash_start+0xace>
    4ac8:	623d      	lod	AL, [S-62]
    4aca:	6207      	lod	AL, [S-8]
    4acc:	255c      	or	X, dp:0x5c <_g_NvramUser+0x4>
    4ace:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x4>
    4ad0:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4ad2:	1107      	call	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad4:	a784      	or	A, ep:0x84 <__data_size+0x22>
    4ad6:	0105      	jmp	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    4ada:	e73e      	or	Y, ep:0x3e <__data_dp_end+0x4>
    4adc:	1002      	call	0x4ae2 <__mlx4_flash_start+0xae2>
    4ade:	b681      	and	A, io:0x1 <__dp__+0x1>
    4ae0:	2495      	or	X, #-107
    4ae2:	b36c      	adc	A, ep:0x6c <__data_size+0xa>
    4ae4:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    4ae6:	0105      	jmp	0x4cf2 <__mlx4_flash_start+0xcf2>
    4ae8:	bf8e      	xor	A, ep:0x8e <__data_size+0x2c>
    4aea:	736c      	lod	A, ep:0x6c <__data_size+0xa>
    4aec:	b787      	and	A, ep:0x87 <__data_size+0x25>
    4aee:	b680      	and	A, io:0x0 <__dp__>
    4af0:	62d2      	lod	AL, [A++]
    4af2:	4d40      	mov	dp:0x40 <__data_dp_end+0x6>, YH
    4af4:	4954      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, AH
    4af6:	4d42      	mov	dp:0x42 <_g_DiagResponse>, YH
    4af8:	4956      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, AH
    4afa:	7c4a      	lod	X, #74
    4afc:	380e      	subc	X, #14
    4afe:	3806      	subc	X, #6
    4b00:	344c      	and	X, #76
    4b02:	484f      	macu	D, AL, [X]
    4b04:	5c01      	dec	S, #2
    4b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b08:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x6>
    4b0a:	380f      	subc	X, #15
    4b0c:	3806      	subc	X, #6
    4b0e:	300a      	adc	X, #10
    4b10:	39f0      	subc	X, dp:0xf0 <_g_u16TargetPosition>
    4b12:	348f      	and	X, #-113
    4b14:	5c02      	dec	S, #3
    4b16:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4b18:	7172      	lod	A, dp:0x72 <__data_size+0x10>
    4b1a:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x2>
    4b1c:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4b1e:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    4b20:	4948      	mov	dp:0x48 <_g_DiagResponse+0x6>, AH
    4b22:	b58f      	and	A, dp:0x8f <__data_size+0x2d>
    4b24:	714b      	lod	A, dp:0x4b <_l_u8LinInFrameMsgID+0x1>
    4b26:	714a      	lod	A, dp:0x4a <_l_u8LinInFrameMsgID>
    4b28:	b343      	adc	A, ep:0x43 <_g_DiagResponse+0x1>
    4b2a:	b242      	adc	A, [S-67]
    4b2c:	b141      	adc	A, dp:0x41 <__data_dp_end+0x7>
    4b2e:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4b30:	4942      	mov	dp:0x42 <_g_DiagResponse>, AH
    4b32:	7342      	lod	A, ep:0x42 <_g_DiagResponse>
    4b34:	7241      	lod	A, [S-66]
    4b36:	7140      	lod	A, dp:0x40 <__data_dp_end+0x6>
    4b38:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4b3a:	4616      	mov	[S-23], YL
    4b3c:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b3e:	8140      	add	AL, dp:0x40 <__data_dp_end+0x6>
    4b40:	8a41      	sub	AL, [S-66]
    4b42:	8b42      	sub	AL, ep:0x42 <_g_DiagResponse>
    4b44:	7140      	lod	A, dp:0x40 <__data_dp_end+0x6>
    4b46:	7241      	lod	A, [S-66]
    4b48:	7342      	lod	A, ep:0x42 <_g_DiagResponse>
    4b4a:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    4b4c:	7251      	lod	A, [S-82]
    4b4e:	7352      	lod	A, ep:0x52 <_g_u16TargetCommutTimerPeriod>
    4b50:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x4>
    4b52:	bf8c      	xor	A, ep:0x8c <__data_size+0x2a>
    4b54:	e784      	or	Y, ep:0x84 <__data_size+0x22>
    4b56:	0101      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4b58:	25c3      	or	X, dp:0xc3 <__bss_dp_size+0x13>
    4b5a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x4>
    4b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    4b5e:	100b      	call	0x4b76 <__mlx4_flash_start+0xb76>
    4b60:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4b62:	b152      	adc	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    4b64:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4b66:	7152      	lod	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    4b68:	b151      	adc	A, dp:0x51 <_g_u16CommutTimerPeriod+0x1>
    4b6a:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b6c:	7151      	lod	A, dp:0x51 <_g_u16CommutTimerPeriod+0x1>
    4b6e:	b150      	adc	A, dp:0x50 <_g_u16CommutTimerPeriod>
    4b70:	4516      	mov	dp:0x16 <__dp_noinit_size+0x6>, YL
    4b72:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    4b74:	25ae      	or	X, dp:0xae <__data_size+0x4c>
    4b76:	b150      	adc	A, dp:0x50 <_g_u16CommutTimerPeriod>
    4b78:	e104      	add	Y, dp:0x4 <_LinMess>
    4b7a:	b151      	adc	A, dp:0x51 <_g_u16CommutTimerPeriod+0x1>
    4b7c:	e905      	sub	Y, dp:0x5 <_LinMess+0x1>
    4b7e:	b152      	adc	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    4b80:	ed80      	cmp	Y, dp:0x80 <__data_size+0x1e>
    4b82:	1001      	call	0x4b86 <__mlx4_flash_start+0xb86>
    4b84:	2494      	or	X, #-108
    4b86:	4950      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, AH
    4b88:	4952      	mov	dp:0x52 <_g_u16TargetCommutTimerPeriod>, AH
    4b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b8c:	61dd      	lod	AL, dp:0xdd <_ml_driver_mode+0x7>
    4b8e:	1001      	call	0x4b92 <__mlx4_flash_start+0xb92>
    4b90:	25ee      	or	X, dp:0xee <_g_u16ActualPosition>
    4b92:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4b94:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x2>
    4b96:	b172      	adc	A, dp:0x72 <__data_size+0x10>
    4b98:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4b9a:	7172      	lod	A, dp:0x72 <__data_size+0x10>
    4b9c:	e588      	or	Y, dp:0x88 <__data_size+0x26>
    4b9e:	0101      	jmp	0x4da2 <__mlx4_flash_start+0xda2>
    4ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4ba2:	b150      	adc	A, dp:0x50 <_g_u16CommutTimerPeriod>
    4ba4:	4592      	mov	dp:0x92 <__data_size+0x30>, YL
    4ba6:	716a      	lod	A, dp:0x6a <__data_size+0x8>
    4ba8:	b153      	adc	A, dp:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    4baa:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4bac:	7353      	lod	A, ep:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    4bae:	b351      	adc	A, ep:0x51 <_g_u16CommutTimerPeriod+0x1>
    4bb0:	b252      	adc	A, [S-83]
    4bb2:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4bb4:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4bb6:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    4bb8:	7350      	lod	A, ep:0x50 <_g_u16CommutTimerPeriod>
    4bba:	7251      	lod	A, [S-82]
    4bbc:	7152      	lod	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    4bbe:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bc0:	4616      	mov	[S-23], YL
    4bc2:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4bc4:	e349      	add	Y, ep:0x49 <_g_DiagResponse+0x7>
    4bc6:	ea4a      	sub	Y, [S-75]
    4bc8:	e94b      	sub	Y, dp:0x4b <_l_u8LinInFrameMsgID+0x1>
    4bca:	1008      	call	0x4bdc <__mlx4_flash_start+0xbdc>
    4bcc:	8350      	add	AL, ep:0x50 <_g_u16CommutTimerPeriod>
    4bce:	8a51      	sub	AL, [S-82]
    4bd0:	8952      	sub	AL, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    4bd2:	e346      	add	Y, ep:0x46 <_g_DiagResponse+0x4>
    4bd4:	ea47      	sub	Y, [S-72]
    4bd6:	e948      	sub	Y, dp:0x48 <_g_DiagResponse+0x6>
    4bd8:	0001      	jmp	0x4bdc <__mlx4_flash_start+0xbdc>
    4bda:	25f6      	or	X, dp:0xf6 <_g_u16ActuatorActPos>
    4bdc:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x4>
    4bde:	bf8c      	xor	A, ep:0x8c <__data_size+0x2a>
    4be0:	e784      	or	Y, ep:0x84 <__data_size+0x22>
    4be2:	1103      	call	0x4dea <__mlx4_flash_start+0xdea>
    4be4:	b584      	and	A, dp:0x84 <__data_size+0x22>
    4be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4be8:	2495      	or	X, #-107
    4bea:	2494      	or	X, #-108
    4bec:	b73e      	and	A, ep:0x3e <__data_dp_end+0x4>
    4bee:	b252      	adc	A, [S-83]
    4bf0:	e680      	or	Y, io:0x0 <__dp__>
    4bf2:	b153      	adc	A, dp:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    4bf4:	ed80      	cmp	Y, dp:0x80 <__data_size+0x1e>
    4bf6:	1101      	call	0x4dfa <__mlx4_flash_start+0xdfa>
    4bf8:	260e      	or	X, [S-15]
    4bfa:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4bfc:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4bfe:	7153      	lod	A, dp:0x53 <_g_u16TargetCommutTimerPeriod+0x1>
    4c00:	4616      	mov	[S-23], YL
    4c02:	7252      	lod	A, [S-83]
    4c04:	b251      	adc	A, [S-82]
    4c06:	4616      	mov	[S-23], YL
    4c08:	7251      	lod	A, [S-82]
    4c0a:	b250      	adc	A, [S-81]
    4c0c:	4616      	mov	[S-23], YL
    4c0e:	7250      	lod	A, [S-81]
    4c10:	b26a      	adc	A, [S-107]
    4c12:	4616      	mov	[S-23], YL
    4c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    4c16:	726a      	lod	A, [S-107]
    4c18:	61fb      	lod	AL, dp:0xfb <_g_e8EXVStatusInitStat>
    4c1a:	25f7      	or	X, dp:0xf7 <_g_u16ActuatorActPos+0x1>
    4c1c:	b250      	adc	A, [S-81]
    4c1e:	b151      	adc	A, dp:0x51 <_g_u16CommutTimerPeriod+0x1>
    4c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    4c22:	ed8c      	cmp	Y, dp:0x8c <__data_size+0x2a>
    4c24:	1001      	call	0x4c28 <__mlx4_flash_start+0xc28>
    4c26:	261a      	or	X, [S-27]
    4c28:	4510      	mov	dp:0x10 <__dp_noinit_size>, YL
    4c2a:	4616      	mov	[S-23], YL
    4c2c:	7172      	lod	A, dp:0x72 <__data_size+0x10>
    4c2e:	61fb      	lod	AL, dp:0xfb <_g_e8EXVStatusInitStat>
    4c30:	b172      	adc	A, dp:0x72 <__data_size+0x10>
    4c32:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4c34:	7258      	lod	A, [S-89]
    4c36:	7159      	lod	A, dp:0x59 <_g_NvramUser+0x1>
    4c38:	b53e      	and	A, dp:0x3e <__data_dp_end+0x4>
    4c3a:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x4>
    4c3c:	623a      	lod	AL, [S-59]
    4c3e:	484f      	macu	D, AL, [X]
    4c40:	380d      	subc	X, #13
    4c42:	3806      	subc	X, #6
    4c44:	e53e      	or	Y, dp:0x3e <__data_dp_end+0x4>
    4c46:	0108      	jmp	0x4e58 <__mlx4_flash_start+0xe58>
    4c48:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4c4a:	b34f      	adc	A, ep:0x4f <_g_u16MicroStepIdx+0x1>
    4c4c:	b24e      	adc	A, [S-79]
    4c4e:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4c50:	4616      	mov	[S-23], YL
    4c52:	734f      	lod	A, ep:0x4f <_g_u16MicroStepIdx+0x1>
    4c54:	724e      	lod	A, [S-79]
    4c56:	2622      	or	X, [S-35]
    4c58:	580e      	inc	S, #15
    4c5a:	0903      	clrb	io:0x00.3
    4c5c:	0809      	clrb	dp:0x01.1
    4c5e:	62e6      	lod	AL, Y
    4c60:	262c      	or	X, [S-45]
    4c62:	623a      	lod	AL, [S-59]
    4c64:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4c66:	715a      	lod	A, dp:0x5a <_g_NvramUser+0x2>
    4c68:	6394      	lod	AL, ep:0x94 <__data_size+0x32>
    4c6a:	b583      	and	A, dp:0x83 <__data_size+0x21>
    4c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    4c6e:	2495      	or	X, #-107
    4c70:	b739      	and	A, ep:0x39 <_l_u8StallCountA>
    4c72:	b638      	and	A, [S-57]
    4c74:	348a      	and	X, #-118
    4c76:	4c58      	dadjs	D, A
    4c78:	b342      	adc	A, ep:0x42 <_g_DiagResponse>
    4c7a:	e780      	or	Y, ep:0x80 <__data_size+0x1e>
    4c7c:	0101      	jmp	0x4e80 <__mlx4_flash_start+0xe80>
    4c7e:	2647      	or	X, [S-72]
    4c80:	b340      	adc	A, ep:0x40 <__data_dp_end+0x6>
    4c82:	b241      	adc	A, [S-66]
    4c84:	e358      	add	Y, ep:0x58 <_g_NvramUser>
    4c86:	ea59      	sub	Y, [S-90]
    4c88:	1002      	call	0x4c8e <__mlx4_flash_start+0xc8e>
    4c8a:	7c04      	lod	X, #4
    4c8c:	2494      	or	X, #-108
    4c8e:	b34e      	adc	A, ep:0x4e <_g_u16MicroStepIdx>
    4c90:	b24f      	adc	A, [S-80]
    4c92:	484f      	macu	D, AL, [X]
    4c94:	834e      	add	AL, ep:0x4e <_g_u16MicroStepIdx>
    4c96:	8a4f      	sub	AL, [S-80]
    4c98:	1001      	call	0x4c9c <__mlx4_flash_start+0xc9c>
    4c9a:	2635      	or	X, [S-54]
    4c9c:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    4c9e:	724f      	lod	A, [S-80]
    4ca0:	b358      	adc	A, ep:0x58 <_g_NvramUser>
    4ca2:	b259      	adc	A, [S-90]
    4ca4:	4610      	mov	[S-17], YL
    4ca6:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4ca8:	8358      	add	AL, ep:0x58 <_g_NvramUser>
    4caa:	8a59      	sub	AL, [S-90]
    4cac:	0004      	jmp	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cae:	e34e      	add	Y, ep:0x4e <_g_u16MicroStepIdx>
    4cb0:	ea4f      	sub	Y, [S-80]
    4cb2:	1001      	call	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cb4:	2635      	or	X, [S-54]
    4cb6:	b358      	adc	A, ep:0x58 <_g_NvramUser>
    4cb8:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    4cba:	b259      	adc	A, [S-90]
    4cbc:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4cbe:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4cc0:	7130      	lod	A, dp:0x30 <_g_u8BufferOutID>
    4cc2:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    4cc4:	7331      	lod	A, ep:0x31 <_g_u8AutoAddressingFlags>
    4cc6:	7232      	lod	A, [S-51]
    4cc8:	7133      	lod	A, dp:0x33 <_g_u8NAD>
    4cca:	e355      	add	Y, ep:0x55 <_g_u16MotorCurrentMovAvgxN+0x1>
    4ccc:	ea56      	sub	Y, [S-87]
    4cce:	e957      	sub	Y, dp:0x57 <_g_u16MotorCurrentLPFx64+0x1>
    4cd0:	1002      	call	0x4cd6 <__mlx4_flash_start+0xcd6>
    4cd2:	b585      	and	A, dp:0x85 <__data_size+0x23>
    4cd4:	2636      	or	X, [S-55]
    4cd6:	b15c      	adc	A, dp:0x5c <_g_NvramUser+0x4>
    4cd8:	a588      	or	A, dp:0x88 <__data_size+0x26>
    4cda:	1102      	call	0x4ee0 <__mlx4_flash_start+0xee0>
    4cdc:	a584      	or	A, dp:0x84 <__data_size+0x22>
    4cde:	1101      	call	0x4ee2 <__mlx4_flash_start+0xee2>
    4ce0:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4ce2:	b359      	adc	A, ep:0x59 <_g_NvramUser+0x1>
    4ce4:	b158      	adc	A, dp:0x58 <_g_NvramUser>
    4ce6:	4592      	mov	dp:0x92 <__data_size+0x30>, YL
    4ce8:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4cea:	b680      	and	A, io:0x0 <__dp__>
    4cec:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cee:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4cf0:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cf2:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    4cf4:	b359      	adc	A, ep:0x59 <_g_NvramUser+0x1>
    4cf6:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    4cf8:	834e      	add	AL, ep:0x4e <_g_u16MicroStepIdx>
    4cfa:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cfc:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    4cfe:	724f      	lod	A, [S-80]
    4d00:	b358      	adc	A, ep:0x58 <_g_NvramUser>
    4d02:	b259      	adc	A, [S-90]
    4d04:	b53e      	and	A, dp:0x3e <__data_dp_end+0x4>
    4d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d08:	0102      	jmp	0x4f0e <__mlx4_flash_start+0xf0e>
    4d0a:	0005      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d0c:	269c      	or	X, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4d0e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d10:	ea05      	sub	Y, [S-6]
    4d12:	0001      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d14:	269c      	or	X, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    4d16:	834e      	add	AL, ep:0x4e <_g_u16MicroStepIdx>
    4d18:	8a4f      	sub	AL, [S-80]
    4d1a:	e788      	or	Y, ep:0x88 <__data_size+0x26>
    4d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    4d1e:	0003      	jmp	0x4d26 <__mlx4_flash_start+0xd26>
    4d20:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    4d22:	4610      	mov	[S-17], YL
    4d24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d28:	0102      	jmp	0x4f2e <__mlx4_flash_start+0xf2e>
    4d2a:	0004      	jmp	0x4d34 <__mlx4_flash_start+0xd34>
    4d2c:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4d2e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d30:	ea05      	sub	Y, [S-6]
    4d32:	100d      	call	0x4d4e <__mlx4_flash_start+0xd4e>
    4d34:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4d36:	2636      	or	X, [S-55]
    4d38:	c34e      	add	AH, ep:0x4e <_g_u16MicroStepIdx>
    4d3a:	ca4f      	sub	AH, [S-80]
    4d3c:	e783      	or	Y, ep:0x83 <__data_size+0x21>
    4d3e:	ee86      	cmp	Y, io:0x6 <_LinMess2>
    4d40:	1003      	call	0x4d48 <__mlx4_flash_start+0xd48>
    4d42:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4d44:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    4d46:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d4a:	0102      	jmp	0x4f50 <__mlx4_flash_start+0xf50>
    4d4c:	1004      	call	0x4d56 <__mlx4_flash_start+0xd56>
    4d4e:	26ad      	or	X, io:0x2d <_g_e8ErrorElectric>
    4d50:	e304      	add	Y, ep:0x4 <_LinMess>
    4d52:	ea05      	sub	Y, [S-6]
    4d54:	0002      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4d56:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4d58:	2636      	or	X, [S-55]
    4d5a:	4d58      	mov	dp:0x58 <_g_NvramUser>, YH
    4d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    4d5e:	b73e      	and	A, ep:0x3e <__data_dp_end+0x4>
    4d60:	7306      	lod	A, ep:0x6 <_LinMess2>
    4d62:	4c02 7ccb 	add	D, #2097315019
    4d66:	7d02 
    4d68:	b25e      	adc	A, [S-95]
    4d6a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4d6c:	725e      	lod	A, [S-95]
    4d6e:	344a      	and	X, #74
    4d70:	3906      	subc	X, dp:0x6 <_LinMess2>
    4d72:	b681      	and	A, io:0x1 <__dp__+0x1>
    4d74:	724e      	lod	A, [S-79]
    4d76:	7245      	lod	A, [S-70]
    4d78:	b239      	adc	A, [S-58]
    4d7a:	7271      	lod	A, [S-114]
    4d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    4d7e:	7239      	lod	A, [S-58]
    4d80:	5c00      	dec	S
    4d82:	4d1c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, YH
    4d84:	4962      	mov	dp:0x62 <__data_size>, AH
    4d86:	4d2c      	mov	dp:0x2c <_g_e8ErrorCoil>, YH
    4d88:	492e      	mov	dp:0x2e <_g_e8MotorRequest>, AH
    4d8a:	b680      	and	A, io:0x0 <__dp__>
    4d8c:	720d      	lod	A, [S-14]
    4d8e:	3807      	subc	X, #7
    4d90:	380e      	subc	X, #14
    4d92:	3430      	and	X, #48
    4d94:	580e      	inc	S, #15
    4d96:	0803      	clrb	dp:0x00.3
    4d98:	0907      	clrb	io:0x00.7
    4d9a:	62e6      	lod	AL, Y
    4d9c:	26ca      	or	X, [--PC]
    4d9e:	623a      	lod	AL, [S-59]
    4da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4da2:	0101      	jmp	0x4fa6 <__mlx4_flash_start+0xfa6>
    4da4:	26ca      	or	X, [--PC]
    4da6:	26f1      	or	X, [Y+1]
    4da8:	623a      	lod	AL, [S-59]
    4daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    4dac:	1101      	call	0x4fb0 <__mlx4_flash_start+0xfb0>
    4dae:	26f1      	or	X, [Y+1]
    4db0:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    4db2:	1105      	call	0x4fbe <__mlx4_flash_start+0xfbe>
    4db4:	626f      	lod	AL, [S-112]
    4db6:	0001      	jmp	0x4dba <__mlx4_flash_start+0xdba>
    4db8:	26ca      	or	X, [--PC]
    4dba:	b586      	and	A, dp:0x86 <__data_size+0x24>
    4dbc:	29d4      	sub	X, dp:0xd4 <_LinMessage>
    4dbe:	b239      	adc	A, [S-58]
    4dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4dc2:	110e      	call	0x4fe0 <__mlx4_flash_start+0xfe0>
    4dc4:	b680      	and	A, io:0x0 <__dp__>
    4dc6:	e24e      	add	Y, [S-79]
    4dc8:	1108      	call	0x4fda <__mlx4_flash_start+0xfda>
    4dca:	6259      	lod	AL, [S-90]
    4dcc:	6266      	lod	AL, [S-103]
    4dce:	0007      	jmp	0x4dde <__mlx4_flash_start+0xdde>
    4dd0:	b585      	and	A, dp:0x85 <__data_size+0x23>
    4dd2:	b271      	adc	A, [S-114]
    4dd4:	7239      	lod	A, [S-58]
    4dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4dd8:	2495      	or	X, #-107
    4dda:	724e      	lod	A, [S-79]
    4ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    4dde:	26ca      	or	X, [--PC]
    4de0:	26ca      	or	X, [--PC]
    4de2:	b33a      	adc	A, ep:0x3a <__data_dp_end>
    4de4:	f782      	and	Y, ep:0x82 <__data_size+0x20>
    4de6:	733a      	lod	A, ep:0x3a <__data_dp_end>
    4de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    4dea:	7c4c      	lod	X, #76
    4dec:	3805      	subc	X, #5
    4dee:	3808      	subc	X, #8
    4df0:	3906      	subc	X, dp:0x6 <_LinMess2>
    4df2:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4df4:	4940      	mov	dp:0x40 <__data_dp_end+0x6>, AH
    4df6:	4942      	mov	dp:0x42 <_g_DiagResponse>, AH
    4df8:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    4dfa:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    4dfc:	b589      	and	A, dp:0x89 <__data_size+0x27>
    4dfe:	580a      	inc	S, #11
    4e00:	0904      	clrb	io:0x00.4
    4e02:	7172      	lod	A, dp:0x72 <__data_size+0x10>
    4e04:	62e6      	lod	AL, Y
    4e06:	b172      	adc	A, dp:0x72 <__data_size+0x10>
    4e08:	26ff      	or	X, [X+7]
    4e0a:	623a      	lod	AL, [S-59]
    4e0c:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4e0e:	4008      	jmp	fp0:0x40
    4e10:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x4>
    4e12:	a58f      	or	A, dp:0x8f <__data_size+0x2d>
    4e14:	0101      	jmp	0x5018 <__mlx4_flash_start+0x1018>
    4e16:	2726      	or	X, ep:0x26 <_g_e8ErrorOverTemperature>
    4e18:	1409      	call	0x462c <__mlx4_flash_start+0x62c>
    4e1a:	3807      	subc	X, #7
    4e1c:	380e      	subc	X, #14
    4e1e:	3430      	and	X, #48
    4e20:	27bd      	or	X, ep:0xbd <__bss_dp_size+0xd>
    4e22:	b239      	adc	A, [S-58]
    4e24:	7238      	lod	A, [S-57]
    4e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    4e28:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4e2a:	24a3      	or	X, #-93
    4e2c:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    4e2e:	b239      	adc	A, [S-58]
    4e30:	7238      	lod	A, [S-57]
    4e32:	4040      	jmp	fp2:0x00
    4e34:	624a      	lod	AL, [S-75]
    4e36:	1504      	call	0x4840 <__mlx4_flash_start+0x840>
    4e38:	b23b      	adc	A, [S-60]
    4e3a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4e3c:	723b      	lod	A, [S-60]
    4e3e:	24a3      	or	X, #-93
    4e40:	b23b      	adc	A, [S-60]
    4e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4e44:	723b      	lod	A, [S-60]
    4e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    4e48:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4e4a:	24a3      	or	X, #-93
    4e4c:	4060      	jmp	fp3:0x00
    4e4e:	624a      	lod	AL, [S-75]
    4e50:	e589      	or	Y, dp:0x89 <__data_size+0x27>
    4e52:	1109      	call	0x5066 <__mlx4_flash_start+0x1066>
    4e54:	b339      	adc	A, ep:0x39 <_l_u8StallCountA>
    4e56:	e78f      	or	Y, ep:0x8f <__data_size+0x2d>
    4e58:	010a      	jmp	0x506e <__mlx4_flash_start+0x106e>
    4e5a:	1409      	call	0x466e <__mlx4_flash_start+0x66e>
    4e5c:	b686      	and	A, io:0x6 <_LinMess2>
    4e5e:	7338      	lod	A, ep:0x38 <_l_u8StallCountO>
    4e60:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4e62:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4e64:	24a3      	or	X, #-93
    4e66:	4060      	jmp	fp3:0x00
    4e68:	622e      	lod	AL, [S-47]
    4e6a:	0501      	jmp	0x486e <__mlx4_flash_start+0x86e>
    4e6c:	2739      	or	X, ep:0x39 <_l_u8StallCountA>
    4e6e:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4e70:	26ff      	or	X, [X+7]
    4e72:	e583      	or	Y, dp:0x83 <__data_size+0x21>
    4e74:	1001      	call	0x4e78 <__mlx4_flash_start+0xe78>
    4e76:	274c      	or	X, ep:0x4c <_g_u16CorrectionRatio>
    4e78:	b791      	and	A, ep:0x91 <__data_size+0x2f>
    4e7a:	d78f      	and	AH, ep:0x8f <__data_size+0x2d>
    4e7c:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4e7e:	bf87      	xor	A, ep:0x87 <__data_size+0x25>
    4e80:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    4e82:	4060      	jmp	fp3:0x00
    4e84:	4d62      	mov	dp:0x62 <__data_size>, YH
    4e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    4e88:	b63d      	and	A, [S-62]
    4e8a:	721e      	lod	A, [S-31]
    4e8c:	4962      	mov	dp:0x62 <__data_size>, AH
    4e8e:	4d2e      	mov	dp:0x2e <_g_e8MotorRequest>, YH
    4e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    4e92:	b63d      	and	A, [S-62]
    4e94:	721f      	lod	A, [S-32]
    4e96:	492e      	mov	dp:0x2e <_g_e8MotorRequest>, AH
    4e98:	7492      	lod	PC, #-110
    4e9a:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4e9c:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    4e9e:	1101      	call	0x50a2 <__mlx4_flash_start+0x10a2>
    4ea0:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    4ea2:	d245      	adc	AH, [S-70]
    4ea4:	7245      	lod	A, [S-70]
    4ea6:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    4ea8:	6c01      	lod	YH, #1
    4eaa:	2768      	or	X, ep:0x68 <__data_size+0x6>
    4eac:	277b      	or	X, ep:0x7b <__data_size+0x19>
    4eae:	278a      	or	X, ep:0x8a <__data_size+0x28>
    4eb0:	26ff      	or	X, [X+7]
    4eb2:	26ff      	or	X, [X+7]
    4eb4:	26ff      	or	X, [X+7]
    4eb6:	26ff      	or	X, [X+7]
    4eb8:	275e      	or	X, ep:0x5e <_g_NvramUser+0x6>
    4eba:	26ff      	or	X, [X+7]
    4ebc:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    4ebe:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    4ec0:	0106      	jmp	0x50ce <__mlx4_flash_start+0x10ce>
    4ec2:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    4ec4:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    4ec6:	b271      	adc	A, [S-114]
    4ec8:	7238      	lod	A, [S-57]
    4eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    4ecc:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4ece:	26ff      	or	X, [X+7]
    4ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    4ed4:	bf82      	xor	A, ep:0x82 <__data_size+0x20>
    4ed6:	d345      	adc	AH, ep:0x45 <_g_DiagResponse+0x3>
    4ed8:	b209      	adc	A, [S-10]
    4eda:	720f      	lod	A, [S-16]
    4edc:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4ede:	d792      	and	AH, ep:0x92 <__data_size+0x30>
    4ee0:	1101      	call	0x50e4 <__mlx4_flash_start+0x10e4>
    4ee2:	26ff      	or	X, [X+7]
    4ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    4ee6:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    4ee8:	b638      	and	A, [S-57]
    4eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    4eec:	1103      	call	0x50f4 <__mlx4_flash_start+0x10f4>
    4eee:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    4ef0:	f784      	and	Y, ep:0x84 <__data_size+0x22>
    4ef2:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    4ef4:	24a3      	or	X, #-93
    4ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    4ef8:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4efa:	0102      	jmp	0x5100 <__mlx4_flash_start+0x1100>
    4efc:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4efe:	26ff      	or	X, [X+7]
    4f00:	b360      	adc	A, ep:0x60 <_g_NvramUser+0x8>
    4f02:	b161      	adc	A, dp:0x61 <_g_NvramUser+0x9>
    4f04:	f580      	and	Y, dp:0x80 <__data_size+0x1e>
    4f06:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f08:	7260      	lod	A, [S-97]
    4f0a:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    4f0c:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f0e:	7261      	lod	A, [S-98]
    4f10:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    4f12:	26ff      	or	X, [X+7]
    4f14:	b209      	adc	A, [S-10]
    4f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4f18:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4f1a:	1102      	call	0x5120 <__mlx4_flash_start+0x1120>
    4f1c:	f781      	and	Y, ep:0x81 <__data_size+0x1f>
    4f1e:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    4f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4f22:	4610      	mov	[S-17], YL
    4f24:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f26:	4610      	mov	[S-17], YL
    4f28:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    4f2a:	720d      	lod	A, [S-14]
    4f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    4f30:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4f32:	0104      	jmp	0x513c <__mlx4_flash_start+0x113c>
    4f34:	b31f      	adc	A, ep:0x1f <_g_u8StallTypeComm>
    4f36:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4f38:	1105      	call	0x5144 <__mlx4_flash_start+0x1144>
    4f3a:	8788      	or	AL, ep:0x88 <__data_size+0x26>
    4f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f3e:	b680      	and	A, io:0x0 <__dp__>
    4f40:	720d      	lod	A, [S-14]
    4f42:	27b5      	or	X, ep:0xb5 <__bss_dp_size+0x5>
    4f44:	3bea      	subc	X, ep:0xea <__bss_dp_end>
    4f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    4f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f4a:	4050      	jmp	fp2:0x80
    4f4c:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    4f4e:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    4f50:	f588      	and	Y, dp:0x88 <__data_size+0x26>
    4f52:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    4f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    4f56:	0105      	jmp	0x5162 <__mlx4_flash_start+0x1162>
    4f58:	b20d      	adc	A, [S-14]
    4f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4f5c:	720d      	lod	A, [S-14]
    4f5e:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4f60:	26ff      	or	X, [X+7]
    4f62:	720d      	lod	A, [S-14]
    4f64:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    4f66:	b7a7      	and	A, ep:0xa7 <__data_size+0x45>
    4f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f6c:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    4f6e:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    4f70:	3beb      	subc	X, ep:0xeb <_g_e8MotorStatusMode>
    4f72:	7360      	lod	A, ep:0x60 <_g_NvramUser+0x8>
    4f74:	7161      	lod	A, dp:0x61 <_g_NvramUser+0x9>
    4f76:	b582      	and	A, dp:0x82 <__data_size+0x20>
    4f78:	26ff      	or	X, [X+7]
    4f7a:	1501      	call	0x497e <__mlx4_flash_start+0x97e>
    4f7c:	2800      	sub	X, #0
    4f7e:	b35c      	adc	A, ep:0x5c <_g_NvramUser+0x4>
    4f80:	a784      	or	A, ep:0x84 <__data_size+0x22>
    4f82:	1109      	call	0x5196 <__mlx4_flash_start+0x1196>
    4f84:	f784      	and	Y, ep:0x84 <__data_size+0x22>
    4f86:	735c      	lod	A, ep:0x5c <_g_NvramUser+0x4>
    4f88:	4804      	mulu	D, A, [Y++]
    4f8a:	b73e      	and	A, ep:0x3e <__data_dp_end+0x4>
    4f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    4f8e:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4f90:	a784      	or	A, ep:0x84 <__data_size+0x22>
    4f92:	0101      	jmp	0x5196 <__mlx4_flash_start+0x1196>
    4f94:	24a3      	or	X, #-93
    4f96:	5cc2      	neg	A
    4f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f9a:	a588      	or	A, dp:0x88 <__data_size+0x26>
    4f9c:	0103      	jmp	0x51a4 <__mlx4_flash_start+0x11a4>
    4f9e:	7ca8      	lod	X, #-88
    4fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    4fa2:	24a3      	or	X, #-93
    4fa4:	b261      	adc	A, [S-98]
    4fa6:	4600      	mov	[S-1], YL
    4fa8:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4faa:	0104      	jmp	0x51b4 <__mlx4_flash_start+0x11b4>
    4fac:	0001      	jmp	0x4fb0 <__mlx4_flash_start+0xfb0>
    4fae:	24a3      	or	X, #-93
    4fb0:	b783      	and	A, ep:0x83 <__data_size+0x21>
    4fb2:	27e7      	or	X, ep:0xe7 <_ml_driver_mode+0x11>
    4fb4:	5c00      	dec	S
    4fb6:	b35f      	adc	A, ep:0x5f <_g_NvramUser+0x7>
    4fb8:	a783      	or	A, ep:0x83 <__data_size+0x21>
    4fba:	1103      	call	0x51c2 <__mlx4_flash_start+0x11c2>
    4fbc:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4fbe:	bf83      	xor	A, ep:0x83 <__data_size+0x21>
    4fc0:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    4fc2:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    4fc4:	a788      	or	A, ep:0x88 <__data_size+0x26>
    4fc6:	1102      	call	0x51cc <__mlx4_flash_start+0x11cc>
    4fc8:	b784      	and	A, ep:0x84 <__data_size+0x22>
    4fca:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x2>
    4fcc:	b781      	and	A, ep:0x81 <__data_size+0x1f>
    4fce:	b260      	adc	A, [S-97]
    4fd0:	725b      	lod	A, [S-92]
    4fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4fd4:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fd6:	724c      	lod	A, [S-77]
    4fd8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fda:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4fdc:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fde:	b556      	and	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    4fe0:	7137      	lod	A, dp:0x37 <_g_u16StartupDelay+0x1>
    4fe2:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fe4:	b556      	and	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    4fe6:	7136      	lod	A, dp:0x36 <_g_u16StartupDelay>
    4fe8:	b25b      	adc	A, [S-92]
    4fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    4fec:	4788      	mov	ep:0x88 <__data_size+0x26>, YL
    4fee:	f693      	and	Y, io:0x13 <__dp_noinit_size+0x3>
    4ff0:	725b      	lod	A, [S-92]
    4ff2:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    4ff4:	0002      	jmp	0x4ffa <__mlx4_flash_start+0xffa>
    4ff6:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    4ff8:	27fe      	or	X, ep:0xfe <_g_e8EXVStatusMovInProcs>
    4ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    4ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4ffe:	281f      	sub	X, #31
    5000:	b239      	adc	A, [S-58]
    5002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    5004:	0101      	jmp	0x5208 <__mlx4_flash_start+0x1208>
    5006:	2814      	sub	X, #20
    5008:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    500a:	a782      	or	A, ep:0x82 <__data_size+0x20>
    500c:	0103      	jmp	0x5214 <__mlx4_flash_start+0x1214>
    500e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    5010:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    5012:	24a3      	or	X, #-93
    5014:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    5016:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    5018:	0107      	jmp	0x5228 <__mlx4_flash_start+0x1228>
    501a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    501c:	e580      	or	Y, dp:0x80 <__data_size+0x1e>
    501e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    5020:	ed80      	cmp	Y, dp:0x80 <__data_size+0x1e>
    5022:	1102      	call	0x5228 <__mlx4_flash_start+0x1228>
    5024:	f782      	and	Y, ep:0x82 <__data_size+0x20>
    5026:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    5028:	e24c      	add	Y, [S-77]
    502a:	0109      	jmp	0x523e <__mlx4_flash_start+0x123e>
    502c:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    502e:	bf87      	xor	A, ep:0x87 <__data_size+0x25>
    5030:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    5032:	4692      	mov	io:0x12 <__dp_noinit_size+0x2>, YL
    5034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    5036:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0x10>
    5038:	8681      	or	AL, io:0x1 <__dp__+0x1>
    503a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    503c:	77e6      	lod	PC, ep:0xe6 <_ml_driver_mode+0x10>
    503e:	b139      	adc	A, dp:0x39 <_l_u8StallCountA>
    5040:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    5042:	7139      	lod	A, dp:0x39 <_l_u8StallCountA>
    5044:	1106      	call	0x5252 <__mlx4_flash_start+0x1252>
    5046:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    5048:	4930      	mov	dp:0x30 <_g_u8BufferOutID>, AH
    504a:	b35b      	adc	A, ep:0x5b <_g_NvramUser+0x3>
    504c:	a784      	or	A, ep:0x84 <__data_size+0x22>
    504e:	1107      	call	0x525e <__mlx4_flash_start+0x125e>
    5050:	2849      	sub	X, #73
    5052:	b208      	adc	A, [S-9]
    5054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    5056:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    5058:	e14c      	add	Y, dp:0x4c <_g_u16CorrectionRatio>
    505a:	0105      	jmp	0x5266 <__mlx4_flash_start+0x1266>
    505c:	6233      	lod	AL, [S-52]
    505e:	7cce      	lod	X, #-50
    5060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    5062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5064:	26ca      	or	X, [--PC]
    5066:	820a      	add	AL, [S-11]
    5068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    506a:	8681      	or	AL, io:0x1 <__dp__+0x1>
    506c:	8f80      	cmp	AL, ep:0x80 <__data_size+0x1e>
    506e:	0103      	jmp	0x5276 <__mlx4_flash_start+0x1276>
    5070:	b684      	and	A, io:0x4 <_LinMess>
    5072:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    5074:	24a3      	or	X, #-93
    5076:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    5078:	a782      	or	A, ep:0x82 <__data_size+0x20>
    507a:	0105      	jmp	0x5286 <__mlx4_flash_start+0x1286>
    507c:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    507e:	bf8d      	xor	A, ep:0x8d <__data_size+0x2b>
    5080:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    5082:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    5084:	29d4      	sub	X, dp:0xd4 <_LinMessage>
    5086:	b35e      	adc	A, ep:0x5e <_g_NvramUser+0x6>
    5088:	f782      	and	Y, ep:0x82 <__data_size+0x20>
    508a:	735e      	lod	A, ep:0x5e <_g_NvramUser+0x6>
    508c:	b783      	and	A, ep:0x83 <__data_size+0x21>
    508e:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x2>
    5090:	24a3      	or	X, #-93
    5092:	b58f      	and	A, dp:0x8f <__data_size+0x2d>
    5094:	7139      	lod	A, dp:0x39 <_l_u8StallCountA>
    5096:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    5098:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    509a:	4940      	mov	dp:0x40 <__data_dp_end+0x6>, AH
    509c:	4942      	mov	dp:0x42 <_g_DiagResponse>, AH
    509e:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    50a0:	b738      	and	A, ep:0x38 <_l_u8StallCountO>
    50a2:	a788      	or	A, ep:0x88 <__data_size+0x26>
    50a4:	110b      	call	0x52bc <__mlx4_flash_start+0x12bc>
    50a6:	b239      	adc	A, [S-58]
    50a8:	7238      	lod	A, [S-57]
    50aa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    50ac:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    50ae:	b23b      	adc	A, [S-60]
    50b0:	f684      	and	Y, io:0x4 <_LinMess>
    50b2:	723b      	lod	A, [S-60]
    50b4:	b25e      	adc	A, [S-95]
    50b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    50b8:	725e      	lod	A, [S-95]
    50ba:	24a1      	or	X, #-95
    50bc:	3805      	subc	X, #5
    50be:	3808      	subc	X, #8
    50c0:	346b      	and	X, #107
    50c2:	34b0      	and	X, #-80
    50c4:	4930      	mov	dp:0x30 <_g_u8BufferOutID>, AH
    50c6:	b34c      	adc	A, ep:0x4c <_g_u16CorrectionRatio>
    50c8:	c781      	or	AH, ep:0x81 <__data_size+0x1f>
    50ca:	4796      	mov	ep:0x96 <__data_size+0x34>, YL
    50cc:	b65b      	and	A, [S-92]
    50ce:	7236      	lod	A, [S-55]
    50d0:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    50d2:	b65b      	and	A, [S-92]
    50d4:	7237      	lod	A, [S-56]
    50d6:	b364      	adc	A, ep:0x64 <__data_size+0x2>
    50d8:	bf84      	xor	A, ep:0x84 <__data_size+0x22>
    50da:	0101      	jmp	0x52de <__mlx4_flash_start+0x12de>
    50dc:	b581      	and	A, dp:0x81 <__data_size+0x1f>
    50de:	858a      	or	AL, dp:0x8a <__data_size+0x28>
    50e0:	715d      	lod	A, dp:0x5d <_g_NvramUser+0x5>
    50e2:	b164      	adc	A, dp:0x64 <__data_size+0x2>
    50e4:	bd83      	xor	A, dp:0x83 <__data_size+0x21>
    50e6:	8582      	or	AL, dp:0x82 <__data_size+0x20>
    50e8:	714d      	lod	A, dp:0x4d <_g_u16CorrectionRatio+0x1>
    50ea:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    50ec:	a788      	or	A, ep:0x88 <__data_size+0x26>
    50ee:	5c00      	dec	S
    50f0:	0101      	jmp	0x52f4 <__mlx4_flash_start+0x12f4>
    50f2:	5c02      	dec	S, #3
    50f4:	580e      	inc	S, #15
    50f6:	0809      	clrb	dp:0x01.1
    50f8:	090c      	clrb	io:0x01.4
    50fa:	62e6      	lod	AL, Y
    50fc:	b16f      	adc	A, dp:0x6f <__data_size+0xd>
    50fe:	a588      	or	A, dp:0x88 <__data_size+0x26>
    5100:	1103      	call	0x5308 <__mlx4_flash_start+0x1308>
    5102:	a584      	or	A, dp:0x84 <__data_size+0x22>
    5104:	0105      	jmp	0x5310 <__mlx4_flash_start+0x1310>
    5106:	24a3      	or	X, #-93
    5108:	2892      	sub	X, #-110
    510a:	623a      	lod	AL, [S-59]
    510c:	a688      	or	A, io:0x8 <__bist_stat_size>
    510e:	0106      	jmp	0x531c <__mlx4_flash_start+0x131c>
    5110:	287a      	sub	X, #122
    5112:	623a      	lod	AL, [S-59]
    5114:	a788      	or	A, ep:0x88 <__data_size+0x26>
    5116:	1102      	call	0x531c <__mlx4_flash_start+0x131c>
    5118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    511a:	1101      	call	0x531e <__mlx4_flash_start+0x131e>
    511c:	2853      	sub	X, #83
    511e:	a781      	or	A, ep:0x81 <__data_size+0x1f>
    5120:	1107      	call	0x5330 <__mlx4_flash_start+0x1330>
    5122:	287a      	sub	X, #122
    5124:	b14d      	adc	A, dp:0x4d <_g_u16CorrectionRatio+0x1>
    5126:	e580      	or	Y, dp:0x80 <__data_size+0x1e>
    5128:	1101      	call	0x532c <__mlx4_flash_start+0x132c>
    512a:	28a6      	sub	X, #-90
    512c:	5cc2      	neg	A
    512e:	287a      	sub	X, #122
    5130:	6241      	lod	AL, [S-66]
    5132:	0001      	jmp	0x5136 <__mlx4_flash_start+0x1136>
    5134:	2711      	or	X, ep:0x11 <__dp_noinit_size+0x1>
    5136:	b14d      	adc	A, dp:0x4d <_g_u16CorrectionRatio+0x1>
    5138:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    513a:	1101      	call	0x533e <__mlx4_flash_start+0x133e>
    513c:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x4>
    513e:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    5140:	8d80      	cmp	AL, dp:0x80 <__data_size+0x1e>
    5142:	714d      	lod	A, dp:0x4d <_g_u16CorrectionRatio+0x1>
    5144:	e580      	or	Y, dp:0x80 <__data_size+0x1e>
    5146:	1101      	call	0x534a <__mlx4_flash_start+0x134a>
    5148:	0501      	jmp	0x4b4c <__mlx4_flash_start+0xb4c>
    514a:	287a      	sub	X, #122
    514c:	b36f      	adc	A, ep:0x6f <__data_size+0xd>
    514e:	bf87      	xor	A, ep:0x87 <__data_size+0x25>
    5150:	736f      	lod	A, ep:0x6f <__data_size+0xd>
    5152:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    5154:	3468      	and	X, #104
    5156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5158:	b203      	adc	A, [S-4]
    515a:	4610      	mov	[S-17], YL
    515c:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    515e:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    5160:	724f      	lod	A, [S-80]
    5162:	4c4f      	dadju	D, [X]
    5164:	6217      	lod	AL, [S-24]
    5166:	6233      	lod	AL, [S-52]
    5168:	b582      	and	A, dp:0x82 <__data_size+0x20>
    516a:	7170      	lod	A, dp:0x70 <__data_size+0xe>
    516c:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    516e:	484f      	macu	D, AL, [X]
    5170:	380a      	subc	X, #10
    5172:	3420      	and	X, #32
    5174:	3965      	subc	X, dp:0x65 <__data_size+0x3>
    5176:	3501      	and	X, dp:0x1 <__dp__+0x1>
    5178:	37a4      	and	X, ep:0xa4 <__data_size+0x42>
    517a:	346b      	and	X, #107
    517c:	5806      	inc	S, #7
    517e:	090e      	clrb	io:0x01.6
    5180:	623a      	lod	AL, [S-59]
    5182:	484f      	macu	D, AL, [X]
    5184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5186:	b203      	adc	A, [S-4]
    5188:	4610      	mov	[S-17], YL
    518a:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    518c:	834e      	add	AL, ep:0x4e <_g_u16MicroStepIdx>
    518e:	8a4f      	sub	AL, [S-80]
    5190:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    5192:	724f      	lod	A, [S-80]
    5194:	4c4f      	dadju	D, [X]
    5196:	3409      	and	X, #9
    5198:	3808      	subc	X, #8
    519a:	28eb      	sub	X, #-21
    519c:	623a      	lod	AL, [S-59]
    519e:	a688      	or	A, io:0x8 <__bist_stat_size>
    51a0:	1101      	call	0x53a4 <__mlx4_flash_start+0x13a4>
    51a2:	28fb      	sub	X, #-5
    51a4:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    51a6:	b582      	and	A, dp:0x82 <__data_size+0x20>
    51a8:	b682      	and	A, io:0x2 <_LinCmnd>
    51aa:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    51ac:	b681      	and	A, io:0x1 <__dp__+0x1>
    51ae:	7201      	lod	A, [S-2]
    51b0:	2487      	or	X, #-121
    51b2:	6217      	lod	AL, [S-24]
    51b4:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    51b6:	0007      	jmp	0x51c6 <__mlx4_flash_start+0x11c6>
    51b8:	1107      	call	0x53c8 <__mlx4_flash_start+0x13c8>
    51ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    51bc:	d78f      	and	AH, ep:0x8f <__data_size+0x2d>
    51be:	7234      	lod	A, [S-53]
    51c0:	7335      	lod	A, ep:0x35 <_g_u8MotorStopDelay>
    51c2:	6228      	lod	AL, [S-41]
    51c4:	28e5      	sub	X, #-27
    51c6:	2906      	sub	X, dp:0x6 <_LinMess2>
    51c8:	6233      	lod	AL, [S-52]
    51ca:	4040      	jmp	fp2:0x00
    51cc:	3501      	and	X, dp:0x1 <__dp__+0x1>
    51ce:	580a      	inc	S, #11
    51d0:	0902      	clrb	io:0x00.2
    51d2:	62e6      	lod	AL, Y
    51d4:	28e7      	sub	X, #-25
    51d6:	623a      	lod	AL, [S-59]
    51d8:	a684      	or	A, io:0x4 <_LinMess>
    51da:	110d      	call	0x53f6 <__mlx4_flash_start+0x13f6>
    51dc:	b370      	adc	A, ep:0x70 <__data_size+0xe>
    51de:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e0:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    51e2:	624a      	lod	AL, [S-75]
    51e4:	6346      	lod	AL, ep:0x46 <_g_DiagResponse+0x4>
    51e6:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    51e8:	e15d      	add	Y, dp:0x5d <_g_NvramUser+0x5>
    51ea:	0109      	jmp	0x53fe <__mlx4_flash_start+0x13fe>
    51ec:	622e      	lod	AL, [S-47]
    51ee:	b370      	adc	A, ep:0x70 <__data_size+0xe>
    51f0:	4784      	mov	ep:0x84 <__data_size+0x22>, YL
    51f2:	7370      	lod	A, ep:0x70 <__data_size+0xe>
    51f4:	28e6      	sub	X, #-26
    51f6:	4040      	jmp	fp2:0x00
    51f8:	624a      	lod	AL, [S-75]
    51fa:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    51fc:	2853      	sub	X, #83
    51fe:	b370      	adc	A, ep:0x70 <__data_size+0xe>
    5200:	4040      	jmp	fp2:0x00
    5202:	4784      	mov	ep:0x84 <__data_size+0x22>, YL
    5204:	7370      	lod	A, ep:0x70 <__data_size+0xe>
    5206:	7ccf      	lod	X, #-49
    5208:	7d34      	lod	X, dp:0x34 <_l_u8VTIdx>
    520a:	28d9      	sub	X, #-39
    520c:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    520e:	580a      	inc	S, #11
    5210:	0902      	clrb	io:0x00.2
    5212:	62e6      	lod	AL, Y
    5214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    5216:	623a      	lod	AL, [S-59]
    5218:	a684      	or	A, io:0x4 <_LinMess>
    521a:	0101      	jmp	0x541e <__mlx4_flash_start+0x141e>
    521c:	28fb      	sub	X, #-5
    521e:	b15f      	adc	A, dp:0x5f <_g_NvramUser+0x7>
    5220:	a583      	or	A, dp:0x83 <__data_size+0x21>
    5222:	1103      	call	0x542a <__mlx4_flash_start+0x142a>
    5224:	b100      	adc	A, dp:0x0 <__dp__>
    5226:	a581      	or	A, dp:0x81 <__data_size+0x1f>
    5228:	0102      	jmp	0x542e <__mlx4_flash_start+0x142e>
    522a:	b785      	and	A, ep:0x85 <__data_size+0x23>
    522c:	62bc      	lod	AL, io:0x3c <__data_dp_end+0x2>
    522e:	24a3      	or	X, #-93
    5230:	3807      	subc	X, #7
    5232:	3809      	subc	X, #9
    5234:	3468      	and	X, #104
    5236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5238:	b638      	and	A, [S-57]
    523a:	a688      	or	A, io:0x8 <__bist_stat_size>
    523c:	0101      	jmp	0x5440 <__mlx4_flash_start+0x1440>
    523e:	2494      	or	X, #-108
    5240:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    5244:	7201      	lod	A, [S-2]
    5246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    5248:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    524a:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    524c:	580e      	inc	S, #15
    524e:	0803      	clrb	dp:0x00.3
    5250:	0906      	clrb	io:0x00.6
    5252:	62e6      	lod	AL, Y
    5254:	2926      	sub	X, dp:0x26 <_g_e8ErrorOverTemperature>
    5256:	623a      	lod	AL, [S-59]
    5258:	a688      	or	A, io:0x8 <__bist_stat_size>
    525a:	010a      	jmp	0x5470 <__mlx4_flash_start+0x1470>
    525c:	248c      	or	X, #-116
    525e:	626f      	lod	AL, [S-112]
    5260:	1007      	call	0x5270 <__mlx4_flash_start+0x1270>
    5262:	b787      	and	A, ep:0x87 <__data_size+0x25>
    5264:	b684      	and	A, io:0x4 <_LinMess>
    5266:	62ca      	lod	AL, [--PC]
    5268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    526a:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    526c:	7370      	lod	A, ep:0x70 <__data_size+0xe>
    526e:	2a05      	sub	X, [S-6]
    5270:	2926      	sub	X, dp:0x26 <_g_e8ErrorOverTemperature>
    5272:	5c00      	dec	S
    5274:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    5276:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    5278:	4954      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, AH
    527a:	4956      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, AH
    527c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    527e:	a78d      	or	A, ep:0x8d <__data_size+0x2b>
    5280:	1103      	call	0x5488 <__mlx4_flash_start+0x1488>
    5282:	4940      	mov	dp:0x40 <__data_dp_end+0x6>, AH
    5284:	4942      	mov	dp:0x42 <_g_DiagResponse>, AH
    5286:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    5288:	b78e      	and	A, ep:0x8e <__data_size+0x2c>
    528a:	b763      	and	A, ep:0x63 <__data_size+0x1>
    528c:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x4>
    528e:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    5290:	735a      	lod	A, ep:0x5a <_g_NvramUser+0x2>
    5292:	736a      	lod	A, ep:0x6a <__data_size+0x8>
    5294:	736b      	lod	A, ep:0x6b <__data_size+0x9>
    5296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    5298:	4710      	mov	ep:0x10 <__dp_noinit_size>, YL
    529a:	734f      	lod	A, ep:0x4f <_g_u16MicroStepIdx+0x1>
    529c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    529e:	4716      	mov	ep:0x16 <__dp_noinit_size+0x6>, YL
    52a0:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    52a2:	4c4e      	dadju	D, [X++]
    52a4:	34ef      	and	X, #-17
    52a6:	3985      	subc	X, dp:0x85 <__data_size+0x23>
    52a8:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    52aa:	4c4f      	dadju	D, [X]
    52ac:	484f      	macu	D, AL, [X]
    52ae:	3806      	subc	X, #6
    52b0:	380a      	subc	X, #10
    52b2:	3428      	and	X, #40
    52b4:	3beb      	subc	X, ep:0xeb <_g_e8MotorStatusMode>
    52b6:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    52b8:	736d      	lod	A, ep:0x6d <__data_size+0xb>
    52ba:	b588      	and	A, dp:0x88 <__data_size+0x26>
    52bc:	b6a7      	and	A, io:0x27 <_g_u8EmergencyRunOcc>
    52be:	726e      	lod	A, [S-111]
    52c0:	b23b      	adc	A, [S-60]
    52c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    52c4:	1103      	call	0x54cc <__mlx4_flash_start+0x14cc>
    52c6:	4930      	mov	dp:0x30 <_g_u8BufferOutID>, AH
    52c8:	b78c      	and	A, ep:0x8c <__data_size+0x2a>
    52ca:	735b      	lod	A, ep:0x5b <_g_NvramUser+0x3>
    52cc:	2282      	add	X, io:0x2 <_LinCmnd>
    52ce:	622b      	lod	AL, [S-44]
    52d0:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    52d2:	3f88      	xor	X, ep:0x88 <__data_size+0x26>
    52d4:	b680      	and	A, io:0x0 <__dp__>
    52d6:	7271      	lod	A, [S-114]
    52d8:	7c54      	lod	X, #84
    52da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    52dc:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x4>
    52de:	4c04      	add	D, [Y++]
    52e0:	3805      	subc	X, #5
    52e2:	3808      	subc	X, #8
    52e4:	3449      	and	X, #73
    52e6:	3906      	subc	X, dp:0x6 <_LinMess2>
    52e8:	3512      	and	X, dp:0x12 <__dp_noinit_size+0x2>
    52ea:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    52ec:	623a      	lod	AL, [S-59]
    52ee:	b58c      	and	A, dp:0x8c <__data_size+0x2a>
    52f0:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x5>
    52f2:	580a      	inc	S, #11
    52f4:	0902      	clrb	io:0x00.2
    52f6:	62e6      	lod	AL, Y
    52f8:	2979      	sub	X, dp:0x79 <__data_size+0x17>
    52fa:	623a      	lod	AL, [S-59]
    52fc:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    52fe:	0102      	jmp	0x5504 <__mlx4_flash_end+0x14>
    5300:	3502      	and	X, dp:0x2 <_LinCmnd>
    5302:	2979      	sub	X, dp:0x79 <__data_size+0x17>
    5304:	351b      	and	X, dp:0x1b <_g_e8EXVInitDirection>
    5306:	b271      	adc	A, [S-114]
    5308:	8681      	or	AL, io:0x1 <__dp__+0x1>
    530a:	7271      	lod	A, [S-114]
    530c:	a681      	or	A, io:0x1 <__dp__+0x1>
    530e:	1105      	call	0x551a <__mlx4_flash_end+0x2a>
    5310:	e686      	or	Y, io:0x6 <_LinMess2>
    5312:	0101      	jmp	0x5516 <__mlx4_flash_end+0x26>
    5314:	296c      	sub	X, dp:0x6c <__data_size+0xa>
    5316:	b584      	and	A, dp:0x84 <__data_size+0x22>
    5318:	29d4      	sub	X, dp:0xd4 <_LinMessage>
    531a:	3809      	subc	X, #9
    531c:	5806      	inc	S, #7
    531e:	0902      	clrb	io:0x00.2
    5320:	623a      	lod	AL, [S-59]
    5322:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    5324:	623a      	lod	AL, [S-59]
    5326:	a688      	or	A, io:0x8 <__bist_stat_size>
    5328:	0101      	jmp	0x552c <__mlx4_flash_end+0x3c>
    532a:	29b2      	sub	X, dp:0xb2 <__bss_dp_size+0x2>
    532c:	b580      	and	A, dp:0x80 <__data_size+0x1e>
    532e:	7143      	lod	A, dp:0x43 <_g_DiagResponse+0x1>
    5330:	7144      	lod	A, dp:0x44 <_g_DiagResponse+0x2>
    5332:	b304      	adc	A, ep:0x4 <_LinMess>
    5334:	b205      	adc	A, [S-6]
    5336:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    5338:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    533a:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    533c:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    533e:	7241      	lod	A, [S-66]
    5340:	7142      	lod	A, dp:0x42 <_g_DiagResponse>
    5342:	4792      	mov	ep:0x92 <__data_size+0x30>, YL
    5344:	4696      	mov	io:0x16 <__dp_noinit_size+0x6>, YL
    5346:	4596      	mov	dp:0x96 <__data_size+0x34>, YL
    5348:	8340      	add	AL, ep:0x40 <__data_dp_end+0x6>
    534a:	8a41      	sub	AL, [S-66]
    534c:	8942      	sub	AL, dp:0x42 <_g_DiagResponse>
    534e:	7340      	lod	A, ep:0x40 <__data_dp_end+0x6>
    5350:	7241      	lod	A, [S-66]
    5352:	7142      	lod	A, dp:0x42 <_g_DiagResponse>
    5354:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    5356:	b788      	and	A, ep:0x88 <__data_size+0x26>
    5358:	b682      	and	A, io:0x2 <_LinCmnd>
    535a:	62ca      	lod	AL, [--PC]
    535c:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    535e:	f784      	and	Y, ep:0x84 <__data_size+0x22>
    5360:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    5362:	24a3      	or	X, #-93
    5364:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    5366:	b271      	adc	A, [S-114]
    5368:	e685      	or	Y, io:0x5 <_LinMess+0x1>
    536a:	0103      	jmp	0x5572 <_INDXtbl+0x32>
    536c:	b784      	and	A, ep:0x84 <__data_size+0x22>
    536e:	b585      	and	A, dp:0x85 <__data_size+0x23>
    5370:	29bb      	sub	X, dp:0xbb <__bss_dp_size+0xb>
    5372:	b786      	and	A, ep:0x86 <__data_size+0x24>
    5374:	b587      	and	A, dp:0x87 <__data_size+0x25>
    5376:	b763      	and	A, ep:0x63 <__data_size+0x1>
    5378:	b561      	and	A, dp:0x61 <_g_NvramUser+0x9>
    537a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    537c:	77bc      	lod	PC, ep:0xbc <__bss_dp_size+0xc>
    537e:	b682      	and	A, io:0x2 <_LinCmnd>
    5380:	75bc      	lod	PC, dp:0xbc <__bss_dp_size+0xc>
    5382:	3b33      	subc	X, ep:0x33 <_g_u8NAD>
    5384:	580f      	inc	S, #16
    5386:	080b      	clrb	dp:0x01.3
    5388:	0902      	clrb	io:0x00.2
    538a:	62e6      	lod	AL, Y
    538c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    538e:	623a      	lod	AL, [S-59]
    5390:	a688      	or	A, io:0x8 <__bist_stat_size>
    5392:	0105      	jmp	0x559e <_INDXtbl+0x5e>
    5394:	b726      	and	A, ep:0x26 <_g_e8ErrorOverTemperature>
    5396:	bf8f      	xor	A, ep:0x8f <__data_size+0x2d>
    5398:	0101      	jmp	0x559c <_INDXtbl+0x5c>
    539a:	2982      	sub	X, dp:0x82 <__data_size+0x20>
    539c:	29c2      	sub	X, dp:0xc2 <__bss_dp_size+0x12>
    539e:	623a      	lod	AL, [S-59]
    53a0:	b785      	and	A, ep:0x85 <__data_size+0x23>
    53a2:	b682      	and	A, io:0x2 <_LinCmnd>
    53a4:	62ca      	lod	AL, [--PC]
    53a6:	24a3      	or	X, #-93
    53a8:	7172      	lod	A, dp:0x72 <__data_size+0x10>
    53aa:	b738      	and	A, ep:0x38 <_l_u8StallCountO>
    53ac:	7370      	lod	A, ep:0x70 <__data_size+0xe>
    53ae:	b787      	and	A, ep:0x87 <__data_size+0x25>
    53b0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    53b2:	734f      	lod	A, ep:0x4f <_g_u16MicroStepIdx+0x1>
    53b4:	b786      	and	A, ep:0x86 <__data_size+0x24>
    53b6:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    53b8:	734e      	lod	A, ep:0x4e <_g_u16MicroStepIdx>
    53ba:	4c4e      	dadju	D, [X++]
    53bc:	4c4f      	dadju	D, [X]
    53be:	b784      	and	A, ep:0x84 <__data_size+0x22>
    53c0:	b75f      	and	A, ep:0x5f <_g_NvramUser+0x7>
    53c2:	773e      	lod	PC, ep:0x3e <__data_dp_end+0x4>
    53c4:	3469      	and	X, #105
    53c6:	3807      	subc	X, #7
    53c8:	380a      	subc	X, #10
    53ca:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    53cc:	b585      	and	A, dp:0x85 <__data_size+0x23>
    53ce:	b55d      	and	A, dp:0x5d <_g_NvramUser+0x5>
    53d0:	8581      	or	AL, dp:0x81 <__data_size+0x1f>
    53d2:	580e      	inc	S, #15
    53d4:	0803      	clrb	dp:0x00.3
    53d6:	0906      	clrb	io:0x00.6
    53d8:	62e6      	lod	AL, Y
    53da:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x13>
    53dc:	623a      	lod	AL, [S-59]
    53de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    53e0:	110c      	call	0x55fa <_start+0x12>
    53e2:	2a3c      	sub	X, [S-61]
    53e4:	627c      	lod	AL, [S-125]
    53e6:	0101      	jmp	0x55ea <_start+0x2>
    53e8:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x13>
    53ea:	623a      	lod	AL, [S-59]
    53ec:	c581      	or	AH, dp:0x81 <__data_size+0x1f>
    53ee:	0107      	jmp	0x55fe <_start+0x16>
    53f0:	bf84      	xor	A, ep:0x84 <__data_size+0x22>
    53f2:	1104      	call	0x55fc <_start+0x14>
    53f4:	a681      	or	A, io:0x1 <__dp__+0x1>
    53f6:	1102      	call	0x55fc <_start+0x14>
    53f8:	29ef      	sub	X, dp:0xef <_g_u16ActualPosition+0x1>
    53fa:	29e9      	sub	X, dp:0xe9 <_ml_driver_mode+0x13>
    53fc:	29ef      	sub	X, dp:0xef <_g_u16ActualPosition+0x1>
    53fe:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5400:	e584      	or	Y, dp:0x84 <__data_size+0x22>
    5402:	0103      	jmp	0x560a <__ram_section_init>
    5404:	b372      	adc	A, ep:0x72 <__data_size+0x10>
    5406:	b684      	and	A, io:0x4 <_LinMess>
    5408:	62ca      	lod	AL, [--PC]
    540a:	b365      	adc	A, ep:0x65 <__data_size+0x3>
    540c:	a784      	or	A, ep:0x84 <__data_size+0x22>
    540e:	1101      	call	0x5612 <__ram_section_init+0x8>
    5410:	2a1b      	sub	X, [S-28]
    5412:	3448      	and	X, #72
    5414:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    5416:	3804      	subc	X, #4
    5418:	3e40      	xor	X, [S-65]
    541a:	3f8c      	xor	X, ep:0x8c <__data_size+0x2a>
    541c:	b723      	and	A, ep:0x23 <__data_dp_size+0x1>
    541e:	bf84      	xor	A, ep:0x84 <__data_size+0x22>
    5420:	0105      	jmp	0x562c <__ram_section_init+0x22>
    5422:	623a      	lod	AL, [S-59]
    5424:	bf88      	xor	A, ep:0x88 <__data_size+0x26>
    5426:	1101      	call	0x562a <__ram_section_init+0x20>
    5428:	2a0e      	sub	X, [S-15]
    542a:	2a3a      	sub	X, [S-59]
    542c:	3e98      	xor	X, io:0x18 <__data_dp_start>
    542e:	580b      	inc	S, #12
    5430:	090d      	clrb	io:0x01.5
    5432:	62e6      	lod	AL, Y
    5434:	2a17      	sub	X, [S-24]
    5436:	3468      	and	X, #104
    5438:	3790      	and	X, ep:0x90 <__data_size+0x2e>
    543a:	3806      	subc	X, #6
    543c:	380a      	subc	X, #10
    543e:	b370      	adc	A, ep:0x70 <__data_size+0xe>
    5440:	bf88      	xor	A, ep:0x88 <__data_size+0x26>
    5442:	010d      	jmp	0x565e <_STACK_IT+0x12>
    5444:	b638      	and	A, [S-57]
    5446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5448:	110a      	call	0x565e <_STACK_IT+0x12>
    544a:	2a3c      	sub	X, [S-61]
    544c:	627c      	lod	AL, [S-125]
    544e:	0101      	jmp	0x5652 <_STACK_IT+0x6>
    5450:	2a17      	sub	X, [S-24]
    5452:	b723      	and	A, ep:0x23 <__data_dp_size+0x1>
    5454:	bf84      	xor	A, ep:0x84 <__data_size+0x22>
    5456:	110e      	call	0x5674 <_STACK_IT+0x28>
    5458:	623a      	lod	AL, [S-59]
    545a:	7c05      	lod	X, #5
    545c:	2a17      	sub	X, [S-24]
    545e:	580e      	inc	S, #15
    5460:	0805      	clrb	dp:0x00.5
    5462:	0902      	clrb	io:0x00.2
    5464:	62e6      	lod	AL, Y
    5466:	2a2f      	sub	X, [S-48]
    5468:	627c      	lod	AL, [S-125]
    546a:	2a2f      	sub	X, [S-48]
    546c:	623a      	lod	AL, [S-59]
    546e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5470:	0103      	jmp	0x5678 <_STACK_IT+0x2c>
    5472:	2a2f      	sub	X, [S-48]
    5474:	622b      	lod	AL, [S-44]
    5476:	2a72      	sub	X, [S-115]
    5478:	4d3e      	mov	dp:0x3e <__data_dp_end+0x4>, YH
    547a:	4930      	mov	dp:0x30 <_g_u8BufferOutID>, AH
    547c:	3449      	and	X, #73
    547e:	3809      	subc	X, #9
    5480:	3805      	subc	X, #5
    5482:	37a0      	and	X, ep:0xa0 <__data_size+0x3e>
    5484:	3986      	subc	X, dp:0x86 <__data_size+0x24>
    5486:	580e      	inc	S, #15
    5488:	0803      	clrb	dp:0x00.3
    548a:	0903      	clrb	io:0x00.3
    548c:	62e6      	lod	AL, Y
    548e:	2a43      	sub	X, [S-68]
    5490:	2a60      	sub	X, [S-97]
    5492:	627c      	lod	AL, [S-125]
    5494:	0101      	jmp	0x5698 <__fatal+0xa>
    5496:	2a43      	sub	X, [S-68]
    5498:	623a      	lod	AL, [S-59]
    549a:	b330      	adc	A, ep:0x30 <_g_u8BufferOutID>
    549c:	b231      	adc	A, [S-50]
    549e:	8781      	or	AL, ep:0x81 <__data_size+0x1f>
    54a0:	8e80      	cmp	AL, io:0x0 <__dp__>
    54a2:	7330      	lod	A, ep:0x30 <_g_u8BufferOutID>
    54a4:	7231      	lod	A, [S-50]
    54a6:	b588      	and	A, dp:0x88 <__data_size+0x26>
    54a8:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x5>
    54aa:	b589      	and	A, dp:0x89 <__data_size+0x27>
    54ac:	ee5d      	cmp	Y, [S-94]
    54ae:	1102      	call	0x56b4 <__fatal+0x26>
    54b0:	b782      	and	A, ep:0x82 <__data_size+0x20>
    54b2:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    54b4:	b58a      	and	A, dp:0x8a <__data_size+0x28>
    54b6:	e75d      	or	Y, ep:0x5d <_g_NvramUser+0x5>
    54b8:	b58b      	and	A, dp:0x8b <__data_size+0x29>
    54ba:	ee5d      	cmp	Y, [S-94]
    54bc:	0001      	jmp	0x54c0 <__mlx4_flash_start+0x14c0>
    54be:	2918      	sub	X, dp:0x18 <__data_dp_start>
    54c0:	623a      	lod	AL, [S-59]
    54c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    54c4:	1101      	call	0x56c8 <__fatal+0x3a>
    54c6:	2a43      	sub	X, [S-68]
    54c8:	b201      	adc	A, [S-2]
    54ca:	b33b      	adc	A, ep:0x3b <__data_dp_end+0x1>
    54cc:	a782      	or	A, ep:0x82 <__data_size+0x20>
    54ce:	1105      	call	0x56da <__fatal+0x4c>
    54d0:	7c05      	lod	X, #5
    54d2:	e684      	or	Y, io:0x4 <_LinMess>
    54d4:	0101      	jmp	0x56d8 <__fatal+0x4a>
    54d6:	29e2      	sub	X, dp:0xe2 <_ml_driver_mode+0xc>
    54d8:	2a1b      	sub	X, [S-28]
    54da:	e684      	or	Y, io:0x4 <_LinMess>
    54dc:	0103      	jmp	0x56e4 <__fatal+0x56>
    54de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    54e0:	62b5      	lod	AL, io:0x35 <_g_u8MotorStopDelay>
    54e2:	24a3      	or	X, #-93
    54e4:	b783      	and	A, ep:0x83 <__data_size+0x21>
    54e6:	b682      	and	A, io:0x2 <_LinCmnd>
    54e8:	62ca      	lod	AL, [--PC]
    54ea:	b780      	and	A, ep:0x80 <__data_size+0x1e>
    54ec:	733b      	lod	A, ep:0x3b <__data_dp_end+0x1>
    54ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00005540 <_INDXtbl>:
    5540:	4042      	jmp	fp2:0x10
    5542:	4040      	jmp	fp2:0x00
    5544:	4040      	jmp	fp2:0x00
    5546:	4040      	jmp	fp2:0x00
    5548:	4040      	jmp	fp2:0x00
    554a:	4040      	jmp	fp2:0x00
    554c:	4040      	jmp	fp2:0x00
    554e:	4040      	jmp	fp2:0x00
    5550:	4040      	jmp	fp2:0x00
    5552:	4040      	jmp	fp2:0x00
    5554:	4040      	jmp	fp2:0x00
    5556:	c040      	add	AH, #64
    5558:	c0c0      	add	AH, #-64
    555a:	c0c0      	add	AH, #-64
    555c:	c0c0      	add	AH, #-64
    555e:	c0c0      	add	AH, #-64
    5560:	c0c0      	add	AH, #-64
    5562:	c0c0      	add	AH, #-64
    5564:	c0c0      	add	AH, #-64
    5566:	c0c0      	add	AH, #-64
    5568:	c0c0      	add	AH, #-64
    556a:	c0c0      	add	AH, #-64
    556c:	c0c0      	add	AH, #-64
    556e:	c0c0      	add	AH, #-64
    5570:	c0c0      	add	AH, #-64
    5572:	c0c0      	add	AH, #-64
    5574:	c0c0      	add	AH, #-64
    5576:	c0c0      	add	AH, #-64
    5578:	c0c0      	add	AH, #-64
    557a:	c0c0      	add	AH, #-64
    557c:	1110      	call	0x579e <__prestart+0x78>
    557e:	c0c0      	add	AH, #-64
    5580:	0fa0      	lod	C, io:0x14.0
    5582:	a02f      	add	A, #47
    5584:	a0a0      	add	A, #-96
    5586:	a0a0      	add	A, #-96
    5588:	a0a0      	add	A, #-96
    558a:	a0a0      	add	A, #-96
    558c:	a0a0      	add	A, #-96
    558e:	a0a0      	add	A, #-96
    5590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    5592:	a0a0      	add	A, #-96
    5594:	a0a0      	add	A, #-96
    5596:	a0a0      	add	A, #-96
    5598:	a0a0      	add	A, #-96
    559a:	a0a0      	add	A, #-96
    559c:	a0a0      	add	A, #-96
    559e:	a0a0      	add	A, #-96
    55a0:	a0a0      	add	A, #-96
    55a2:	a0a0      	add	A, #-96
    55a4:	a0a0      	add	A, #-96
    55a6:	a0a0      	add	A, #-96
    55a8:	a0a0      	add	A, #-96
    55aa:	a0a0      	add	A, #-96
    55ac:	a0a0      	add	A, #-96
    55ae:	a0a0      	add	A, #-96
    55b0:	a0a0      	add	A, #-96
    55b2:	a0a0      	add	A, #-96
    55b4:	a0a0      	add	A, #-96
    55b6:	a0a0      	add	A, #-96
    55b8:	a0a0      	add	A, #-96
    55ba:	a0a0      	add	A, #-96
    55bc:	a0a0      	add	A, #-96
    55be:	a0a0      	add	A, #-96

000055c0 <_AUTOADDtbl>:
    55c0:	2610      	or	X, [S-17]
    55c2:	1626      	call	0x5210 <__mlx4_flash_start+0x1210>
    55c4:	0000      	nop
    55c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 5726 	jmpf	0x5726 <__prestart>
    bf6e:	a55a      	or	A, dp:0x5a <_g_NvramUser+0x2>
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da 564c 	jmpf	0x564c <_STACK_IT>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	6402      	lod	YL, #2
    bf7c:	76da 568e 	jmpf	0x568e <__fatal>
    bf80:	54f8      	mov	UPr, #8
    bf82:	6403      	lod	YL, #3
    bf84:	76da 568e 	jmpf	0x568e <__fatal>
    bf88:	54f8      	mov	UPr, #8
    bf8a:	6404      	lod	YL, #4
    bf8c:	76da 568e 	jmpf	0x568e <__fatal>
    bf90:	54f0      	mov	UPr, #0
    bf92:	6405      	lod	YL, #5
    bf94:	76da 568e 	jmpf	0x568e <__fatal>
    bf98:	54f0      	mov	UPr, #0
    bf9a:	6406      	lod	YL, #6
    bf9c:	76da 568e 	jmpf	0x568e <__fatal>
    bfa0:	54f0      	mov	UPr, #0
    bfa2:	6407      	lod	YL, #7
    bfa4:	76da 568e 	jmpf	0x568e <__fatal>
    bfa8:	54f0      	mov	UPr, #0
    bfaa:	6408      	lod	YL, #8
    bfac:	76da 568e 	jmpf	0x568e <__fatal>
    bfb0:	54d4      	psup	#4
    bfb2:	76da 5dc0 	jmpf	0x5dc0 <_linit>
    bfb6:	0000      	nop
    bfb8:	54d5      	psup	#5
    bfba:	76da a9dc 	jmpf	0xa9dc <_TIMER_IT>
    bfbe:	0000      	nop
    bfc0:	54d4      	psup	#4
    bfc2:	76da 8f0e 	jmpf	0x8f0e <_ADC_IT>
    bfc6:	0000      	nop
    bfc8:	54f0      	mov	UPr, #0
    bfca:	640c      	lod	YL, #12
    bfcc:	76da 568e 	jmpf	0x568e <__fatal>
    bfd0:	54d3      	psup	#3
    bfd2:	76da 9d82 	jmpf	0x9d82 <_EXT0_IT>
    bfd6:	0000      	nop
    bfd8:	54f0      	mov	UPr, #0
    bfda:	640e      	lod	YL, #14
    bfdc:	76da 568e 	jmpf	0x568e <__fatal>
    bfe0:	54f0      	mov	UPr, #0
    bfe2:	640f      	lod	YL, #15
    bfe4:	76da 568e 	jmpf	0x568e <__fatal>
    bfe8:	54f0      	mov	UPr, #0
    bfea:	6410      	lod	YL, #16
    bfec:	76da 568e 	jmpf	0x568e <__fatal>
    bff0:	54d2      	psup	#2
    bff2:	76da 928e 	jmpf	0x928e <_EXT4_IT>
    bff6:	0000      	nop
    bff8:	54f0      	mov	UPr, #0
    bffa:	6412      	lod	YL, #18
    bffc:	76da 568e 	jmpf	0x568e <__fatal>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000055e8 <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    55e8:	7000      	lod	A, #0
    55ea:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    55ec:	70ff      	lod	A, #-1
    55ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    55f2:	72da 0378 	lod	A, #888
    55f6:	52ef      	mov	S, A

    _low_level_init();
    55f8:	82db 693a 	callf	0x693a <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    55fc:	1006      	call	0x560a <__ram_section_init>
    _premain();
    55fe:	82db 6a8c 	callf	0x6a8c <__premain>
    (void)main();
    5602:	82db 6fd2 	callf	0x6fd2 <_main>
    _fatal();
    5606:	1043      	call	0x568e <__fatal>
    5608:	5401      	ret

0000560a <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    560a:	7ada 003a 	lod	Y, #58
    560e:	eeda 00ea 	cmp	Y, #234
    5612:	1c03      	jnc	0x561a <__ram_section_init+0x10>
        *w++ = 0;
    5614:	7000      	lod	A, #0
    5616:	52d6      	mov	[Y++], A
    5618:	07fa      	jmp	0x560e <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    561a:	7ada 015c 	lod	Y, #348
    561e:	eeda 0370 	cmp	Y, #880
    5622:	1c03      	jnc	0x562a <__ram_section_init+0x20>
        *w++ = 0;
    5624:	7000      	lod	A, #0
    5626:	52d6      	mov	[Y++], A
    5628:	07fa      	jmp	0x561e <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    562a:	7eda acc0 	lod	X, #44224

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    562e:	7ada 0018 	lod	Y, #24
    5632:	eeda 003a 	cmp	Y, #58
    5636:	1c02      	jnc	0x563c <__ram_section_init+0x32>
        *w++ = *r++;
    5638:	54ce      	movsw	[Y++], [X++]
    563a:	07fb      	jmp	0x5632 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    563c:	7ada 00fa 	lod	Y, #250
    5640:	eeda 015c 	cmp	Y, #348
    5644:	1c02      	jnc	0x564a <__ram_section_init+0x40>
        *w++ = *r++;
    5646:	54ce      	movsw	[Y++], [X++]
    5648:	07fb      	jmp	0x5640 <__ram_section_init+0x36>
    564a:	5401      	ret

0000564c <_STACK_IT>:
 */
__MLX_TEXT__ void STACK_IT(void)
{
//	SET_STACK( &stack);
	/* Chip header is valid and chip successfully initialised; LIN Command Reset use AWD to reset chip */
	if ( (bistHeader == C_CHIP_HEADER) && ((bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET) || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)) )
    564c:	72d8 0370 	lod	A, 0x370 <__bss_end>
    5650:	aeda b598 	cmp	A, #46488
    5654:	1d19      	jne	0x5688 <_STACK_IT+0x3c>
    5656:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    565a:	aeda 3072 	cmp	A, #12402
    565e:	1905      	je	0x566a <_STACK_IT+0x1e>
    5660:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5664:	aeda 3212 	cmp	A, #12818
    5668:	1d0f      	jne	0x5688 <_STACK_IT+0x3c>
	{
		/* INLINE MLX16_RESET (Don't use stack) */
		do
		{
			if ( (PLL_CTRL & PLL_EN) != 0 )								/* Only delay in case of PLL is active */
    566a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    566e:	b401      	and	A, #1
    5670:	1903      	je	0x5678 <_STACK_IT+0x2c>
			{
				DELAY_US( 250);											/* Should be called with period > 200us, otherwise bit AWD_WRITE_FAIL will be set and further acknowledgment will fail during next 200 us */
    5672:	7eda 06d6 	lod	X, #1750
    5676:	1bff      	djnz	X, 0x5676 <_STACK_IT+0x2a>
			}
			AWD_CTRL = (AWD_ATT | AWD_WRITE_FAIL | (3u << 8) | 1);		/* Set 1:1 pre-scaler and minimal period; AWD timeout will be 100 us */
    5678:	72da 6301 	lod	A, #25345
    567c:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
		} while ( AWD_CTRL & (AWD_ATT | AWD_WRITE_FAIL) );
    567e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    5680:	b6da 6000 	and	A, #24576
    5684:	1d72      	jne	0x566a <_STACK_IT+0x1e>
		for ( ; ; ) {
    5686:	07ff      	jmp	0x5686 <_STACK_IT+0x3a>
			/* wait for reset */
		}
	}
	__asm__( "mov yl, #01");
    5688:	6401      	lod	YL, #1
	__asm__( "jmp __fatal");
    568a:	0001      	jmp	0x568e <__fatal>
    568c:	5401      	ret

0000568e <__fatal>:
 * 0x079C: Address of failure (from stack)
 */
__MLX_TEXT__ void _fatal (void)
{
	/* YL = Error-reason; Don't use stack (MMP151125-1) */
	__asm__("lod X, 0x2026");													/* X = [FL_CTRL0] */
    568e:	7ed8 2026 	lod	X, 0x2026 <__ep__+0x1026>
	__asm__("and X, #0x07");													/* X[2:0] = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) */
    5692:	3407      	and	X, #7
	__asm__("lod A, 0x2040");													/* A = [PLL_STAT] */
    5694:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
	__asm__("and A, #0x03");													/* A[1:0] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) */
    5698:	b403      	and	A, #3
	__asm__("asl A, #2");
    569a:	44a2      	asl	A, #2
	__asm__("asl A, #2");														/* A[5:4] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569c:	44a2      	asl	A, #2
	__asm__("or  A, X");														/* A(L) = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569e:	a6ee      	or	A, X
	__asm__("lod YH, AL");														/* YH = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    56a0:	6ee0      	lod	YH, AL
	__asm__("mov _bistError, Y");
    56a2:	5ad8 0374 	mov	0x374 <_bistError>, Y
	__asm__("lod A, [S-2]");													/* Save address of failed instruction */
    56a6:	7201      	lod	A, [S-2]
	__asm__("mov _bistErrorInfo, A");											/* Failure address */
    56a8:	52d8 0376 	mov	0x376 <_bistErrorInfo>, A

#if _SUPPORT_CRASH_RECOVERY
	/* Crash recovery */
	if ( (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) && ((uint8)(bistError & 0xFF) < 0x05) )	/* MMP151125-1 */
    56ac:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    56b0:	aeda 1a45 	cmp	A, #6725
    56b4:	1d26      	jne	0x5702 <__fatal+0x74>
    56b6:	72d8 0374 	lod	A, 0x374 <_bistError>
    56ba:	8c04      	cmp	AL, #4
    56bc:	1e22      	jug	0x5702 <__fatal+0x74>
	{
		/* Crash recovery is enabled, and type of IRQ is between 0x01 and 0x04 */
		bistResetInfo = C_CHIP_STATE_FATAL_CRASH_RECOVERY;						/* Start recovery (on-going) */
    56be:	72da 1872 	lod	A, #6258
    56c2:	52d8 0372 	mov	0x372 <_bistResetInfo>, A
		SET_STACK( &stack);														/* Re-initialise stack */
    56c6:	72da 0378 	lod	A, #888
    56ca:	52ef      	mov	S, A
		ENTER_SYSTEM_MODE();													/* Protected mode, highest priority (0) (MMP141023-1) */
    56cc:	4407      	mov	R, #0
    56ce:	500c      	call	fp0:0x60
    56d0:	54f0      	mov	UPr, #0
		XI0_PEND = CLR_T1_INT4;
    56d2:	7040      	lod	A, #64
    56d4:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI2_PEND = 0xFFFF;														/* Clear all XI2_PEND flags */
    56d8:	70ff      	lod	A, #-1
    56da:	52d8 2038 	mov	0x2038 <__ep__+0x1038>, A
		XI4_PEND = (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV);
    56de:	72da e100 	lod	A, #57600
    56e2:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		g_u8Mlx4ErrorState = (uint8) C_MLX4_STATE_IMMEDIATE_RST;				/* Reset MLX4 always */
    56e6:	6080      	lod	AL, #-128
    56e8:	42d8 010c 	mov	0x10c <_g_u8Mlx4ErrorState>, AL
		PEND = CLR_TIMER_IT;													/* Core-Timer */
    56ec:	7020      	lod	A, #32
    56ee:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		SET_PRIORITY( 7);														/* Protected mode, low priority (7) */
    56f2:	54f7      	mov	UPr, #7
		(void) FlashBackgroundTest( 0);
    56f4:	7000      	lod	A, #0
    56f6:	82db 6d24 	callf	0x6d24 <_FlashBackgroundTest>
				NVRAM_SavePage( NVRAM1_PAGE2 | NVRAM_PAGE_WR_SKIP_WAIT);
			}
		}
#endif /* (_DEBUG_FATAL != FALSE) */

		(void) main();
    56fa:	82db 6fd2 	callf	0x6fd2 <_main>

		/* Should never come here, as main should not be left */
		__asm__( "mov YL, #0x19");												/* C_MLX16_MAIN_FATAL */
    56fe:	6419      	lod	YL, #25
		/* lint -e{974} */ _fatal();
    5700:	17c6      	call	0x568e <__fatal>
	}
#endif /* _SUPPORT_CRASH_RECOVERY */

	SET_STACK( &stack);															/* Re-initialise stack (MMP141023-1) */
    5702:	72da 0378 	lod	A, #888
    5706:	52ef      	mov	S, A
	ENTER_SYSTEM_MODE();														/* Protected mode, highest priority (0) (MMP141023-1) */
    5708:	4407      	mov	R, #0
    570a:	500c      	call	fp0:0x60
    570c:	54f0      	mov	UPr, #0
	FL_CTRL0 &= ~(FL_DBE | FL_SBE);												/* Clear DBE and SBE errors (MMP141023-1) */
    570e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5712:	b4f9      	and	A, #-7
    5714:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
		}
	}
#endif /* (_DEBUG_FATAL != FALSE) */

	/* Disable motor driver first, before waiting for watchdog */
	DRVCFG_DIS_UVWT();															/* Tri-state (disconnect) the phase U, V, W and T (MMP130919-1) */
    5718:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    571c:	b6da fe00 	and	A, #65024
    5720:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	for (;;) {
    5724:	07ff      	jmp	0x5724 <__fatal+0x96>

00005726 <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    5726:	5801      	inc	S, #2
    5728:	7000      	lod	A, #0
    572a:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    572c:	70ff      	lod	A, #-1
    572e:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    5732:	72da 0378 	lod	A, #888
    5736:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    5738:	1130      	call	0x599a <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    573a:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    573e:	b401      	and	A, #1
    5740:	1d27      	jne	0x5790 <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5742:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5746:	5cf2      	usex	A
    5748:	4422      	asl	A
    574a:	7ada 10e8 	lod	Y, #4328
    574e:	eae2      	sub	Y, A
    5750:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5754:	5cf2      	usex	A
    5756:	7ee2      	lod	X, A
    5758:	7014      	lod	A, #20
    575a:	aaee      	sub	A, X
    575c:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    575e:	7ee2      	lod	X, A
    5760:	7000      	lod	A, #0
    5762:	08a7      	clrb	ML.7
    5764:	b2d6      	adc	A, [Y++]
    5766:	1bfe      	djnz	X, 0x5764 <__prestart+0x3e>
    5768:	92e4      	adc	AL, AH
    576a:	9000      	adc	AL, #0
    576c:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    576e:	aeda 00ff 	cmp	A, #255
    5772:	1d0e      	jne	0x5790 <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    5774:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    5778:	b4f8      	and	A, #-8
    577a:	aeda 04b8 	cmp	A, #1208
    577e:	1d08      	jne	0x5790 <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    5780:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    5784:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    5788:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    578a:	eeda 201a 	cmp	Y, #8218
    578e:	1a7c      	jule	0x5788 <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    5790:	72d8 0370 	lod	A, 0x370 <__bss_end>
    5794:	aeda b598 	cmp	A, #46488
    5798:	1901      	je	0x579c <__prestart+0x76>
    579a:	0037      	jmp	0x580a <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    579c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    579e:	ac00      	cmp	A, #0
    57a0:	1a84      	jsl	0x57aa <__prestart+0x84>
    57a2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    57a6:	8c00      	cmp	AL, #0
    57a8:	1e98      	jsge	0x57da <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    57aa:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57ae:	aeda 3072 	cmp	A, #12402
    57b2:	1d01      	jne	0x57b6 <__prestart+0x90>
    57b4:	0031      	jmp	0x5818 <__prestart+0xf2>
    57b6:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57ba:	aeda 3212 	cmp	A, #12818
    57be:	192c      	je	0x5818 <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    57c0:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57c4:	1905      	je	0x57d0 <__prestart+0xaa>
    57c6:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57ca:	aeda 1a45 	cmp	A, #6725
    57ce:	1d03      	jne	0x57d6 <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    57d0:	72da 5c92 	lod	A, #23698
    57d4:	000d      	jmp	0x57f0 <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    57d6:	7c00      	lod	X, #0
    57d8:	0015      	jmp	0x5804 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    57da:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57de:	aeda 3072 	cmp	A, #12402
    57e2:	1909      	je	0x57f6 <__prestart+0xd0>
    57e4:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57e8:	aeda 3212 	cmp	A, #12818
    57ec:	1904      	je	0x57f6 <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    57ee:	7000      	lod	A, #0
    57f0:	52d8 0372 	mov	0x372 <_bistResetInfo>, A
    57f4:	0011      	jmp	0x5818 <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    57f6:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    57fa:	aeda 1a45 	cmp	A, #6725
    57fe:	1d0c      	jne	0x5818 <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    5800:	7eda 56d2 	lod	X, #22226
    5804:	5ed8 0372 	mov	0x372 <_bistResetInfo>, X
    5808:	0007      	jmp	0x5818 <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    580a:	7000      	lod	A, #0
    580c:	52d8 0372 	mov	0x372 <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    5810:	7eda b598 	lod	X, #46488
    5814:	5ed8 0370 	mov	0x370 <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    5818:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    581c:	aeda 3072 	cmp	A, #12402
    5820:	1919      	je	0x5854 <__prestart+0x12e>
    5822:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5826:	aeda 3212 	cmp	A, #12818
    582a:	1914      	je	0x5854 <__prestart+0x12e>
    582c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5830:	aeda 5c92 	cmp	A, #23698
    5834:	190f      	je	0x5854 <__prestart+0x12e>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5836:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    583a:	7c20      	lod	X, #32
    583c:	7000      	lod	A, #0
    583e:	08a7      	clrb	ML.7
    5840:	b2d6      	adc	A, [Y++]
    5842:	1bfe      	djnz	X, 0x5840 <__prestart+0x11a>
    5844:	92e4      	adc	AL, AH
    5846:	9000      	adc	AL, #0
    5848:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    584a:	aeda 00ff 	cmp	A, #255
    584e:	1902      	je	0x5854 <__prestart+0x12e>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    5850:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    5852:	071d      	jmp	0x568e <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    5854:	6030      	lod	AL, #48
    5856:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    585a:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    585e:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    5862:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    5866:	a6da 8000 	or	A, #32768
    586a:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    586e:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    5872:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    5876:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    587a:	b6da 00ff 	and	A, #255
    587e:	a6da c000 	or	A, #49152
    5882:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    5886:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    588a:	94cf      	and	AL, #-49
    588c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    5890:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    5894:	b4f9      	and	A, #-7
    5896:	a402      	or	A, #2
    5898:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    589c:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    58a0:	b401      	and	A, #1
    58a2:	1914      	je	0x58cc <__prestart+0x1a6>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    58a4:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    58a8:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    58ac:	a6e6      	or	A, Y
    58ae:	190e      	je	0x58cc <__prestart+0x1a6>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    58b0:	7eda 55c8 	lod	X, #21960

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    58b4:	7ada 0740 	lod	Y, #1856
    58b8:	eeda 075e 	cmp	Y, #1886
    58bc:	1c05      	jnc	0x58c8 <__prestart+0x1a2>
        *w++ = *r++;
    58be:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c0:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c2:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58c4:	54ce      	movsw	[Y++], [X++]
    58c6:	07f8      	jmp	0x58b8 <__prestart+0x192>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    58c8:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    58cc:	72da 6fd1 	lod	A, #28625
    58d0:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58d4:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    58d6:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    58da:	b401      	and	A, #1
    58dc:	1d03      	jne	0x58e4 <__prestart+0x1be>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58de:	e001      	add	Y, #1
    58e0:	ec63      	cmp	Y, #99
    58e2:	1a79      	jule	0x58d6 <__prestart+0x1b0>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    58e4:	ec64      	cmp	Y, #100
    58e6:	1d01      	jne	0x58ea <__prestart+0x1c4>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    58e8:	07ff      	jmp	0x58e8 <__prestart+0x1c2>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    58ea:	6024      	lod	AL, #36
    58ec:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    58f0:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    58f4:	aeda 3072 	cmp	A, #12402
    58f8:	190e      	je	0x5916 <__prestart+0x1f0>
    58fa:	82db 6646 	callf	0x6646 <_LDR_GetState>
    58fe:	8c00      	cmp	AL, #0
    5900:	1d0a      	jne	0x5916 <__prestart+0x1f0>
    5902:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5906:	aeda 3212 	cmp	A, #12818
    590a:	1905      	je	0x5916 <__prestart+0x1f0>
    590c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5910:	aeda 5c92 	cmp	A, #23698
    5914:	1d02      	jne	0x591a <__prestart+0x1f4>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    5916:	0668      	jmp	0x55e8 <_start>
    5918:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    591a:	76da 68ea 	jmpf	0x68ea <_RAM_Test>
    591e:	5403      	ret	#4

00005920 <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    5920:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    5922:	4407      	mov	R, #0
    5924:	500c      	call	fp0:0x60
    5926:	54f0      	mov	UPr, #0
    5928:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    592a:	b430      	and	A, #48
    592c:	ac10      	cmp	A, #16
    592e:	1914      	je	0x5958 <_MLX16_RESET+0x38>
    5930:	1e03      	jug	0x5938 <_MLX16_RESET+0x18>
    5932:	ac00      	cmp	A, #0
    5934:	190c      	je	0x594e <_MLX16_RESET+0x2e>
    5936:	002f      	jmp	0x5996 <_MLX16_RESET+0x76>
    5938:	ac20      	cmp	A, #32
    593a:	1903      	je	0x5942 <_MLX16_RESET+0x22>
    593c:	ac30      	cmp	A, #48
    593e:	1904      	je	0x5948 <_MLX16_RESET+0x28>
    5940:	002a      	jmp	0x5996 <_MLX16_RESET+0x76>
    5942:	6000      	lod	AL, #0
    5944:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5946:	07fd      	jmp	0x5942 <_MLX16_RESET+0x22>
    5948:	6000      	lod	AL, #0
    594a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    594c:	07ff      	jmp	0x594c <_MLX16_RESET+0x2c>
    594e:	6001      	lod	AL, #1
    5950:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5952:	6010      	lod	AL, #16
    5954:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    5956:	07ff      	jmp	0x5956 <_MLX16_RESET+0x36>
    5958:	6282      	lod	AL, io:0x2 <_LinCmnd>
    595a:	66e0      	lod	YL, AL
    595c:	5cf6      	usex	Y
    595e:	44a6      	asl	Y, #2
    5960:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5962:	b403      	and	A, #3
    5964:	4422      	asl	A
    5966:	ac00      	cmp	A, #0
    5968:	1b03      	jsle	0x5970 <_MLX16_RESET+0x50>
    596a:	42e9      	mov	Cx, AL
    596c:	4426      	asl	Y
    596e:	1ffe      	djnz	Cx, 0x596c <_MLX16_RESET+0x4c>
    5970:	ec7d      	cmp	Y, #125
    5972:	1c01      	jnc	0x5976 <_MLX16_RESET+0x56>
    5974:	07ff      	jmp	0x5974 <_MLX16_RESET+0x54>
    5976:	7eda 06d6 	lod	X, #1750
    597a:	1bff      	djnz	X, 0x597a <_MLX16_RESET+0x5a>
    597c:	72da 6301 	lod	A, #25345
    5980:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
    5982:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    5984:	b6da 6000 	and	A, #24576
    5988:	1d76      	jne	0x5976 <_MLX16_RESET+0x56>
    598a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    598e:	b4fe      	and	A, #-2
    5990:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    5994:	07ff      	jmp	0x5994 <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    5996:	5ae3      	mov	M, Y
    5998:	5401      	ret

0000599a <_NVRAM_LoadAll>:
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
        WD_T = 0;                       /* .. acknowledge the watchdog */
    599a:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    599e:	b401      	and	A, #1
    59a0:	1908      	je	0x59b2 <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59a2:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59a4:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59a6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59a8:	b430      	and	A, #48
    59aa:	1977      	je	0x599a <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59ac:	6000      	lod	AL, #0
    59ae:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59b0:	07f4      	jmp	0x599a <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    59b2:	72da 8000 	lod	A, #32768
    59b6:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    59ba:	72da 8001 	lod	A, #32769
    59be:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59c2:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59c6:	b401      	and	A, #1
    59c8:	1908      	je	0x59da <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59ca:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59cc:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59ce:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59d0:	b430      	and	A, #48
    59d2:	1977      	je	0x59c2 <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59d4:	6000      	lod	AL, #0
    59d6:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59d8:	07f4      	jmp	0x59c2 <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    59da:	7000      	lod	A, #0
    59dc:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    59e0:	7001      	lod	A, #1
    59e2:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59e6:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59ea:	b401      	and	A, #1
    59ec:	1908      	je	0x59fe <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59ee:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    59f0:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59f2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59f4:	b430      	and	A, #48
    59f6:	1977      	je	0x59e6 <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59f8:	6000      	lod	AL, #0
    59fa:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59fc:	07f4      	jmp	0x59e6 <_NVRAM_LoadAll+0x4c>
    59fe:	5401      	ret

00005a00 <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    5a00:	7ee2      	lod	X, A
    5a02:	b6da 7fff 	and	A, #32767
    5a06:	ac01      	cmp	A, #1
    5a08:	1906      	je	0x5a16 <_NVRAM_SavePage+0x16>
    5a0a:	1803      	jc	0x5a12 <_NVRAM_SavePage+0x12>
    5a0c:	ac02      	cmp	A, #2
    5a0e:	1905      	je	0x5a1a <_NVRAM_SavePage+0x1a>
    5a10:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    5a12:	7810      	lod	Y, #16
            break;
    5a14:	0004      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    5a16:	7818      	lod	Y, #24
            break;
    5a18:	0002      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    5a1a:	7ada 8400 	lod	Y, #33792
    5a1e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a22:	b401      	and	A, #1
    5a24:	1908      	je	0x5a36 <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a26:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5a28:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a2a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a2c:	b430      	and	A, #48
    5a2e:	1977      	je	0x5a1e <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a30:	6000      	lod	AL, #0
    5a32:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a34:	07f4      	jmp	0x5a1e <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    5a36:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    5a3a:	e403      	or	Y, #3
    5a3c:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    5a40:	2c00      	cmp	X, #0
    5a42:	1a8c      	jsl	0x5a5c <_NVRAM_SavePage+0x5c>
    5a44:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a48:	b401      	and	A, #1
    5a4a:	1908      	je	0x5a5c <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a4c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5a4e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a50:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a52:	b430      	and	A, #48
    5a54:	1977      	je	0x5a44 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a56:	6000      	lod	AL, #0
    5a58:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a5a:	07f4      	jmp	0x5a44 <_NVRAM_SavePage+0x44>
    5a5c:	5401      	ret

00005a5e <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    5a5e:	7ae2      	lod	Y, A
    5a60:	6203      	lod	AL, [S-4]
    5a62:	5cf2      	usex	A
    5a64:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    5a66:	72e6      	lod	A, Y
    5a68:	b401      	and	A, #1
    5a6a:	1908      	je	0x5a7c <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    5a6c:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a6e:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    5a70:	b6da 00ff 	and	A, #255
    5a74:	36da 00ff 	and	X, #255
    5a78:	7eec      	swap	X
    5a7a:	0003      	jmp	0x5a82 <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a7c:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    5a7e:	b6da ff00 	and	A, #65280
    5a82:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    5a84:	52f0      	mov	[Y], A
    5a86:	5401      	ret

00005a88 <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    5a88:	7000      	lod	A, #0
    5a8a:	17ba      	call	0x5a00 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    5a8c:	7001      	lod	A, #1
    5a8e:	17b8      	call	0x5a00 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    5a90:	7002      	lod	A, #2
    5a92:	17b6      	call	0x5a00 <_NVRAM_SavePage>
    5a94:	5401      	ret

00005a96 <_ml_ReleaseBuffer>:
    5a96:	602f      	lod	AL, #47
    5a98:	0033      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005a9a <_ml_ReleaseBufferProg>:
    5a9a:	9401      	and	AL, #1
    5a9c:	44a0      	asl	AL, #2
    5a9e:	44a0      	asl	AL, #2
    5aa0:	840f      	or	AL, #15
    5aa2:	002e      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005aa4 <_ml_DataReady>:
    5aa4:	6ae0      	lod	AH, AL
    5aa6:	6015      	lod	AL, #21
    5aa8:	7eda 0008 	lod	X, #8
    5aac:	7ada 00ca 	lod	Y, #202
    5ab0:	54c6      	movsw	[X++], [Y++]
    5ab2:	54c6      	movsw	[X++], [Y++]
    5ab4:	54c6      	movsw	[X++], [Y++]
    5ab6:	54c6      	movsw	[X++], [Y++]
    5ab8:	0023      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005aba <_ml_AssignFrameToMessageID>:
    5aba:	6a03      	lod	AH, [S-4]
    5abc:	d43f      	and	AH, #63
    5abe:	0004      	jmp	0x5ac8 <_ml_EnableMessage+0x4>

00005ac0 <_ml_DisableMessage>:
    5ac0:	6802      	lod	AH, #2
    5ac2:	0001      	jmp	0x5ac6 <_ml_EnableMessage+0x2>

00005ac4 <_ml_EnableMessage>:
    5ac4:	6803      	lod	AH, #3
    5ac6:	44d4      	rr	AH, #2
    5ac8:	44a0      	asl	AL, #2
    5aca:	44a0      	asl	AL, #2
    5acc:	8406      	or	AL, #6
    5ace:	0018      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ad0 <_ml_AutoAddressingConfig>:
    5ad0:	44a0      	asl	AL, #2
    5ad2:	44a0      	asl	AL, #2
    5ad4:	840d      	or	AL, #13
    5ad6:	0014      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ad8 <_ml_SetSlewRate>:
    5ad8:	44a2      	asl	A, #2
    5ada:	44a2      	asl	A, #2
    5adc:	a407      	or	A, #7
    5ade:	0010      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ae0 <_ml_SetOptions>:
    5ae0:	6a03      	lod	AH, [S-4]
    5ae2:	44a4      	asl	AH, #2
    5ae4:	86e4      	or	AL, AH
    5ae6:	44a0      	asl	AL, #2
    5ae8:	44a0      	asl	AL, #2
    5aea:	840b      	or	AL, #11
    5aec:	c607      	or	AH, [S-8]
    5aee:	44a4      	asl	AH, #2
    5af0:	c605      	or	AH, [S-6]
    5af2:	dc01      	xor	AH, #1
    5af4:	0005      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005af6 <_ml_DiscardFrame>:
    5af6:	6005      	lod	AL, #5
    5af8:	0003      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005afa <_ml_ContFrame>:
    5afa:	6ae0      	lod	AH, AL
    5afc:	6025      	lod	AL, #37
    5afe:	0000      	nop
    5b00:	54e2      	mov	Cx, #2
    5b02:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    5b06:	7ae2      	lod	Y, A
    5b08:	6041      	lod	AL, #65
    5b0a:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5b0e:	7eda 03e8 	lod	X, #1000
    5b12:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5b16:	9402      	and	AL, #2
    5b18:	1d03      	jne	0x5b20 <_ml_ContFrame+0x26>
    5b1a:	1bfb      	djnz	X, 0x5b12 <_ml_ContFrame+0x18>
    5b1c:	7002      	lod	A, #2
    5b1e:	5401      	ret
    5b20:	7ee6      	lod	X, Y
    5b22:	340f      	and	X, #15
    5b24:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b28:	6800      	lod	AH, #0
    5b2a:	aeee      	cmp	A, X
    5b2c:	1d02      	jne	0x5b32 <_ml_ContFrame+0x38>
    5b2e:	7000      	lod	A, #0
    5b30:	5401      	ret
    5b32:	72e6      	lod	A, Y
    5b34:	1fe6      	djnz	Cx, 0x5b02 <_ml_ContFrame+0x8>
    5b36:	7001      	lod	A, #1
    5b38:	5401      	ret

00005b3a <_ml_LinModuleVersion>:
    5b3a:	602a      	lod	AL, #42
    5b3c:	17e1      	call	0x5b00 <_ml_ContFrame+0x6>
    5b3e:	ac00      	cmp	A, #0
    5b40:	1d11      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b42:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b46:	940f      	and	AL, #15
    5b48:	8c0a      	cmp	AL, #10
    5b4a:	1d0c      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b4c:	66e4      	lod	YL, AH
    5b4e:	601a      	lod	AL, #26
    5b50:	17d7      	call	0x5b00 <_ml_ContFrame+0x6>
    5b52:	ac00      	cmp	A, #0
    5b54:	1d07      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b56:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b5a:	940f      	and	AL, #15
    5b5c:	8c0a      	cmp	AL, #10
    5b5e:	1d02      	jne	0x5b64 <_ml_LinModuleVersion+0x2a>
    5b60:	62e8      	lod	AL, YL
    5b62:	5401      	ret
    5b64:	7000      	lod	A, #0
    5b66:	5401      	ret

00005b68 <_ml_GetState>:
    5b68:	44a2      	asl	A, #2
    5b6a:	44a2      	asl	A, #2
    5b6c:	a40c      	or	A, #12
    5b6e:	17c8      	call	0x5b00 <_ml_ContFrame+0x6>
    5b70:	ac00      	cmp	A, #0
    5b72:	1d0b      	jne	0x5b8a <_ml_GetState+0x22>
    5b74:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b78:	8c0c      	cmp	AL, #12
    5b7a:	1d07      	jne	0x5b8a <_ml_GetState+0x22>
    5b7c:	62e4      	lod	AL, AH
    5b7e:	44f4      	asr	AH, #2
    5b80:	44f4      	asr	AH, #2
    5b82:	4ad8 6a03 	mov	0x36a <_LinStatus>, AH
    5b86:	b40f      	and	A, #15
    5b88:	5401      	ret
    5b8a:	70ff      	lod	A, #-1
    5b8c:	5401      	ret

00005b8e <_ml_SetBaudRate>:
    5b8e:	44a0      	asl	AL, #2
    5b90:	44a0      	asl	AL, #2
    5b92:	8402      	or	AL, #2
    5b94:	7a03      	lod	Y, [S-4]
    5b96:	6ae8      	lod	AH, YL
    5b98:	07b3      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005b9a <_ml_SetAutoBaudRateMode>:
    5b9a:	6ae0      	lod	AH, AL
    5b9c:	6002      	lod	AL, #2
    5b9e:	84e0      	or	AL, #-32
    5ba0:	07af      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005ba2 <_ml_Connect>:
    5ba2:	6002      	lod	AL, #2
    5ba4:	0008      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005ba6 <_ml_Disconnect>:
    5ba6:	6001      	lod	AL, #1
    5ba8:	0006      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005baa <_ml_SwitchToFast>:
    5baa:	600f      	lod	AL, #15
    5bac:	0004      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005bae <_ml_WakeUp>:
    5bae:	6008      	lod	AL, #8
    5bb0:	0002      	jmp	0x5bb6 <_ml_GotoSleep+0x4>

00005bb2 <_ml_GotoSleep>:
    5bb2:	6004      	lod	AL, #4
    5bb4:	0000      	nop
    5bb6:	44a0      	asl	AL, #2
    5bb8:	44a0      	asl	AL, #2
    5bba:	8401      	or	AL, #1
    5bbc:	07a1      	jmp	0x5b00 <_ml_ContFrame+0x6>

00005bbe <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    5bbe:	60aa      	lod	AL, #-86
    5bc0:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    5bc4:	7104      	lod	A, dp:0x4 <_LinMess>
    5bc6:	51d4      	mov	dp:0xd4 <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    5bc8:	7810      	lod	Y, #16
    5bca:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bce:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    5bd0:	ac03      	cmp	A, #3
    5bd2:	1d09      	jne	0x5be6 <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    5bd4:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    5bd6:	51ca      	mov	dp:0xca <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    5bd8:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    5bda:	59cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    5bdc:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    5bde:	51ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    5be0:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    5be2:	59d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    5be4:	1758      	call	0x5a96 <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    5be6:	6042      	lod	AL, #66
    5be8:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5bec:	5401      	ret

00005bee <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    5bee:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bf0:	79d4      	lod	Y, dp:0xd4 <_LinMessage>
    5bf2:	72e6      	lod	A, Y
    5bf4:	b40f      	and	A, #15
    5bf6:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    5bf8:	ac07      	cmp	A, #7
    5bfa:	1d07      	jne	0x5c0a <_ml_ProccessLinEvent+0x1c>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    5bfc:	44b6      	lsr	Y, #2
    5bfe:	44b6      	lsr	Y, #2
    5c00:	72e6      	lod	A, Y
    5c02:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    5c04:	82db 7c26 	callf	0x7c26 <_mlu_AutoAddressingStep>
    5c08:	00c7      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    5c0a:	72e6      	lod	A, Y
    5c0c:	6000      	lod	AL, #0
    5c0e:	72e4      	swap	A
    5c10:	b43f      	and	A, #63
    5c12:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    5c14:	62d8 00d6 	lod	AL, 0xd6 <_ml_driver_mode>
    5c18:	8c55      	cmp	AL, #85
    5c1a:	1d01      	jne	0x5c1e <_ml_ProccessLinEvent+0x30>
    5c1c:	009d      	jmp	0x5d58 <_ml_ProccessLinEvent+0x16a>
        if (LDR_GetState() == 0) {
    5c1e:	82db 6646 	callf	0x6646 <_LDR_GetState>
    5c22:	8c00      	cmp	AL, #0
    5c24:	1901      	je	0x5c28 <_ml_ProccessLinEvent+0x3a>
    5c26:	006a      	jmp	0x5cfc <_ml_ProccessLinEvent+0x10e>
#endif
            switch(LinCommand) {
    5c28:	7203      	lod	A, [S-4]
    5c2a:	a0ff      	add	A, #-1
    5c2c:	ac04      	cmp	A, #4
    5c2e:	1a01      	jule	0x5c32 <_ml_ProccessLinEvent+0x44>
    5c30:	00b3      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5c32:	4422      	asl	A
    5c34:	7ae2      	lod	Y, A
    5c36:	e2da 6be0 	add	Y, #27616
    5c3a:	72f0      	lod	A, [Y]
    5c3c:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    5c3e:	79d4      	lod	Y, dp:0xd4 <_LinMessage>
    5c40:	72e6      	lod	A, Y
    5c42:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    5c46:	ac40      	cmp	A, #64
    5c48:	1901      	je	0x5c4c <_ml_ProccessLinEvent+0x5e>
    5c4a:	00a6      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    5c4c:	44c6      	rl	Y, #2
    5c4e:	44c6      	rl	Y, #2
    5c50:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    5c52:	72e6      	lod	A, Y
    5c54:	82db 7b8e 	callf	0x7b8e <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    5c58:	009f      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    5c5a:	79d4      	lod	Y, dp:0xd4 <_LinMessage>
    5c5c:	72e6      	lod	A, Y
    5c5e:	44b2      	lsr	A, #2
    5c60:	44b2      	lsr	A, #2
    5c62:	b40f      	and	A, #15
    5c64:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    5c66:	ac05      	cmp	A, #5
    5c68:	1d0e      	jne	0x5c86 <_ml_ProccessLinEvent+0x98>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    5c6a:	6400      	lod	YL, #0
    5c6c:	7ae8      	swap	Y
    5c6e:	72e6      	lod	A, Y
    5c70:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    5c72:	44b6      	lsr	Y, #2
    5c74:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    5c76:	80ff      	add	AL, #-1
    5c78:	8c08      	cmp	AL, #8
    5c7a:	1a17      	jule	0x5caa <_ml_ProccessLinEvent+0xbc>
    5c7c:	62e8      	lod	AL, YL
    5c7e:	8c0f      	cmp	AL, #15
    5c80:	1914      	je	0x5caa <_ml_ProccessLinEvent+0xbc>
                            Error = ml_erStopBitTX;
    5c82:	7c10      	lod	X, #16
    5c84:	0012      	jmp	0x5caa <_ml_ProccessLinEvent+0xbc>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    5c86:	ac0c      	cmp	A, #12
    5c88:	1d05      	jne	0x5c94 <_ml_ProccessLinEvent+0xa6>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    5c8a:	44c6      	rl	Y, #2
    5c8c:	44c6      	rl	Y, #2
    5c8e:	f40f      	and	Y, #15
                        if(nbytes == 0)
    5c90:	1d0c      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    5c92:	0082      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    5c94:	ac02      	cmp	A, #2
    5c96:	1d09      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    5c98:	6400      	lod	YL, #0
    5c9a:	7ae8      	swap	Y
    5c9c:	72e6      	lod	A, Y
    5c9e:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    5ca0:	8c02      	cmp	AL, #2
    5ca2:	1d03      	jne	0x5caa <_ml_ProccessLinEvent+0xbc>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    5ca4:	1780      	call	0x5ba6 <_ml_Disconnect>
                            (void)ml_Connect();
    5ca6:	177d      	call	0x5ba2 <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    5ca8:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    5caa:	72ee      	lod	A, X
    5cac:	82db 7b70 	callf	0x7b70 <_mlu_ErrorDetected>
                    break;
    5cb0:	0073      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5cb2:	7104      	lod	A, dp:0x4 <_LinMess>
    5cb4:	52d8 0158 	mov	0x158 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cb8:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cba:	42d8 015a 	mov	0x15a <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    5cbe:	6201      	lod	AL, [S-2]
    5cc0:	8c10      	cmp	AL, #16
    5cc2:	1902      	je	0x5cc8 <_ml_ProccessLinEvent+0xda>
                        mlu_MessageReceived(LinID); /* notify application */
    5cc4:	7201      	lod	A, [S-2]
    5cc6:	000a      	jmp	0x5cdc <_ml_ProccessLinEvent+0xee>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    5cc8:	54ca 0000 	pushw	#0
    5ccc:	72da 00ca 	lod	A, #202
    5cd0:	10ce      	call	0x5e6e <_ldr_isReadByIdMessage>
    5cd2:	5c01      	dec	S, #2
    5cd4:	8c00      	cmp	AL, #0
    5cd6:	1901      	je	0x5cda <_ml_ProccessLinEvent+0xec>
    5cd8:	0034      	jmp	0x5d42 <_ml_ProccessLinEvent+0x154>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    5cda:	7010      	lod	A, #16
    5cdc:	82db 7ba6 	callf	0x7ba6 <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    5ce0:	005b      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5ce2:	7104      	lod	A, dp:0x4 <_LinMess>
    5ce4:	52d8 0158 	mov	0x158 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5ce8:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cea:	42d8 015a 	mov	0x15a <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    5cee:	7201      	lod	A, [S-2]
    5cf0:	82db 7b2a 	callf	0x7b2a <_mlu_DataRequest>
                    break;
    5cf4:	0051      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    5cf6:	82db 7b6e 	callf	0x7b6e <_mlu_DataTransmitted>
                    break;
    5cfa:	004e      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    5cfc:	7203      	lod	A, [S-4]
    5cfe:	ac03      	cmp	A, #3
    5d00:	190d      	je	0x5d1c <_ml_ProccessLinEvent+0x12e>
    5d02:	1e03      	jug	0x5d0a <_ml_ProccessLinEvent+0x11c>
    5d04:	ac02      	cmp	A, #2
    5d06:	1905      	je	0x5d12 <_ml_ProccessLinEvent+0x124>
    5d08:	0047      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d0a:	7203      	lod	A, [S-4]
    5d0c:	ac04      	cmp	A, #4
    5d0e:	191d      	je	0x5d4a <_ml_ProccessLinEvent+0x15c>
    5d10:	0043      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d12:	61d4      	lod	AL, dp:0xd4 <_LinMessage>
    5d14:	44b2      	lsr	A, #2
    5d16:	44b2      	lsr	A, #2
    5d18:	b40f      	and	A, #15
    5d1a:	002f      	jmp	0x5d7a <_ml_ProccessLinEvent+0x18c>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d1c:	7104      	lod	A, dp:0x4 <_LinMess>
    5d1e:	52d8 0158 	mov	0x158 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d22:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d24:	42d8 015a 	mov	0x15a <_LINBaud>, AL

                    if (LinID == D_DIA) {
    5d28:	6201      	lod	AL, [S-2]
    5d2a:	8c10      	cmp	AL, #16
    5d2c:	1901      	je	0x5d30 <_ml_ProccessLinEvent+0x142>
    5d2e:	0034      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    5d30:	54ca 0001 	pushw	#1
    5d34:	72da 00ca 	lod	A, #202
    5d38:	109a      	call	0x5e6e <_ldr_isReadByIdMessage>
    5d3a:	5c01      	dec	S, #2
    5d3c:	8c00      	cmp	AL, #0
    5d3e:	1d01      	jne	0x5d42 <_ml_ProccessLinEvent+0x154>
    5d40:	002b      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    5d42:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x3>
    5d44:	5cf2      	usex	A
    5d46:	1207      	call	0x6156 <_ml_ldr_ReadByIdMessage>
    5d48:	0027      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d4a:	7104      	lod	A, dp:0x4 <_LinMess>
    5d4c:	52d8 0158 	mov	0x158 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d50:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d52:	42d8 015a 	mov	0x15a <_LINBaud>, AL
    5d56:	001d      	jmp	0x5d92 <_ml_ProccessLinEvent+0x1a4>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    5d58:	7203      	lod	A, [S-4]
    5d5a:	ac03      	cmp	A, #3
    5d5c:	1910      	je	0x5d7e <_ml_ProccessLinEvent+0x190>
    5d5e:	1e03      	jug	0x5d66 <_ml_ProccessLinEvent+0x178>
    5d60:	ac02      	cmp	A, #2
    5d62:	1907      	je	0x5d72 <_ml_ProccessLinEvent+0x184>
    5d64:	0019      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d66:	7203      	lod	A, [S-4]
    5d68:	ac04      	cmp	A, #4
    5d6a:	1913      	je	0x5d92 <_ml_ProccessLinEvent+0x1a4>
    5d6c:	ac05      	cmp	A, #5
    5d6e:	1913      	je	0x5d96 <_ml_ProccessLinEvent+0x1a8>
    5d70:	0013      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d72:	44b6      	lsr	Y, #2
    5d74:	44b6      	lsr	Y, #2
    5d76:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    5d78:	72e6      	lod	A, Y
    5d7a:	1155      	call	0x6026 <_ml_ldr_ErrorDetected>
                 break;
    5d7c:	000d      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    5d7e:	6201      	lod	AL, [S-2]
    5d80:	8c10      	cmp	AL, #16
    5d82:	1d0a      	jne	0x5d98 <_ml_ProccessLinEvent+0x1aa>
    5d84:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer>
    5d86:	8dd2      	cmp	AL, dp:0xd2 <_LIN_nad>
    5d88:	1902      	je	0x5d8e <_ml_ProccessLinEvent+0x1a0>
    5d8a:	8c7f      	cmp	AL, #127
    5d8c:	1d05      	jne	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    5d8e:	1231      	call	0x61f2 <_ml_DiagReceived>
    5d90:	0003      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    5d92:	16b1      	call	0x5af6 <_ml_DiscardFrame>
                 break;
    5d94:	0001      	jmp	0x5d98 <_ml_ProccessLinEvent+0x1aa>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    5d96:	11fb      	call	0x618e <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    5d98:	60ab      	lod	AL, #-85
    5d9a:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    5d9e:	5405      	ret	#6

00005da0 <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    5da0:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5da4:	7ada 0010 	lod	Y, #16
    5da8:	7eda 72ef 	lod	X, #29423
    5dac:	5ef0      	mov	[Y], X
    5dae:	7eda e861 	lod	X, #59489
    5db2:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    5db4:	41d2      	mov	dp:0xd2 <_LIN_nad>, AL
    return ML_SUCCESS;
}
    5db6:	7000      	lod	A, #0
    5db8:	5401      	ret

00005dba <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    5dba:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5dbc:	5cf2      	usex	A
}
    5dbe:	5401      	ret

00005dc0 <_linit>:
 * This function is called whenever an EVENT interrupt from the LIN task (Mlx4)
 * occurs
 */
void __interrupt__ ml_LinInterruptHandler(void);
__MLX_TEXT__  void ml_LinInterruptHandler(void)
{
    5dc0:	52df      	push	A
    5dc2:	5edf      	push	X
    5dc4:	5adf      	push	Y
    5dc6:	4c83      	push	D
    ml_GetLinEventData();
    5dc8:	16fa      	call	0x5bbe <_ml_GetLinEventData>
    ml_ProccessLinEvent();
    5dca:	1711      	call	0x5bee <_ml_ProccessLinEvent>
    5dcc:	4cc3      	pop	D
    5dce:	7acf      	pop	Y
    5dd0:	7ecf      	pop	X
    5dd2:	72cf      	pop	A
    5dd4:	4407      	mov	R, #0
    5dd6:	72cb      	pop	M
    5dd8:	5401      	ret

00005dda <_ml_GetBaudRate>:
 *
 *  With this max presc 8 the limit for PLL is:
 *  PLL_max = 2^(pres+1) * div * baud = 2^9 * 100 * 1000 = 51.2 MHz
 */
__MLX_TEXT__ ml_uint16 ml_GetBaudRate (void)
{
    5dda:	5803      	inc	S, #4
#if (FPLL < 50000)

    uint8_t presc = (uint8_t)((LINPresc & 0x00F0) >> 4);  /* Prescaller |XXXX|XXXX|PRES|XXXX| */
    5ddc:	66d8 0158 	lod	YL, 0x158 <_LINPresc>
    5de0:	f6da 00f0 	and	Y, #240
    5de4:	44b6      	lsr	Y, #2
    5de6:	44b6      	lsr	Y, #2
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    5de8:	4cc2 9f80 	mov	D, #14000000
    5dec:	00d5 
    5dee:	62d8 015a 	lod	AL, 0x15a <_LINBaud>
    5df2:	5cf2      	usex	A
    5df4:	ec00      	cmp	Y, #0
    5df6:	1b03      	jsle	0x5dfe <_ml_GetBaudRate+0x24>
    5df8:	46e9      	mov	Cx, YL
    5dfa:	4422      	asl	A
    5dfc:	1ffe      	djnz	Cx, 0x5dfa <_ml_GetBaudRate+0x20>
    5dfe:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    5e00:	4c80      	mov	YA, D
    5e02:	7e03      	lod	X, [S-4]
    5e04:	4c63      	divu	YA, X
    5e06:	4c63      	divu	YA, X
    5e08:	5203      	mov	[S-4], A

#else
    #warning "Function can't work with FPLL > 50MHz (overflow in 2nd argument of divU16_U32byU16)"
    return 0U;
#endif
}
    5e0a:	5405      	ret	#6

00005e0c <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    5e0c:	82db 6646 	callf	0x6646 <_LDR_GetState>
    5e10:	8c00      	cmp	AL, #0
    5e12:	1d0a      	jne	0x5e28 <_ml_InitLinModule+0x1c>
    5e14:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    5e18:	aeda 3212 	cmp	A, #12818
    5e1c:	1905      	je	0x5e28 <_ml_InitLinModule+0x1c>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    5e1e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    5e22:	a410      	or	A, #16
    5e24:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5e28:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    5e2a:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5e2c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5e2e:	b430      	and	A, #48
    5e30:	1902      	je	0x5e36 <_ml_InitLinModule+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5e32:	6000      	lod	AL, #0
    5e34:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    5e36:	6084      	lod	AL, #-124
    5e38:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    5e3c:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5e40:	b404      	and	A, #4
    5e42:	197c      	je	0x5e3c <_ml_InitLinModule+0x30>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    5e44:	60ab      	lod	AL, #-85
    5e46:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    5e4a:	6000      	lod	AL, #0
    5e4c:	42d8 00d6 	mov	0xd6 <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    5e50:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    5e54:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    5e58:	4cb2 72ef 	cmp	YA, #-396266769
    5e5c:	e861 
    5e5e:	1d03      	jne	0x5e66 <_ml_InitLinModule+0x5a>
    {
        LIN_nad = stFixedRamNAD.nad;
    5e60:	62d8 0014 	lod	AL, 0x14 <__dp_noinit_size+0x4>
    5e64:	0001      	jmp	0x5e68 <_ml_InitLinModule+0x5c>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    5e66:	6001      	lod	AL, #1
    5e68:	41d2      	mov	dp:0xd2 <_LIN_nad>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    5e6a:	7000      	lod	A, #0
    5e6c:	5401      	ret

00005e6e <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    5e6e:	5801      	inc	S, #2
    5e70:	7ae2      	lod	Y, A
    5e72:	6205      	lod	AL, [S-6]
    5e74:	5cf2      	usex	A
    5e76:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    5e78:	7ef0      	lod	X, [Y]
    5e7a:	2eda 067f 	cmp	X, #1663
    5e7e:	1907      	je	0x5e8e <_ldr_isReadByIdMessage+0x20>
    5e80:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5e82:	b6da 06ff 	and	A, #1791
    5e86:	a6da 0600 	or	A, #1536
    5e8a:	2ee2      	cmp	X, A
    5e8c:	1d15      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5e8e:	72f2      	lod	A, [Y+2]
    5e90:	8cb2      	cmp	AL, #-78
    5e92:	1d12      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5e94:	7ef4      	lod	X, [Y+4]
    5e96:	2c13      	cmp	X, #19
    5e98:	1d04      	jne	0x5ea2 <_ldr_isReadByIdMessage+0x34>
    5e9a:	72f6      	lod	A, [Y+6]
    5e9c:	aeda cafe 	cmp	A, #51966
    5ea0:	1909      	je	0x5eb4 <_ldr_isReadByIdMessage+0x46>
    5ea2:	6201      	lod	AL, [S-2]
    5ea4:	8c01      	cmp	AL, #1
    5ea6:	1d08      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5ea8:	2eda 7fff 	cmp	X, #32767
    5eac:	1d05      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
    5eae:	72f6      	lod	A, [Y+6]
    5eb0:	acff      	cmp	A, #-1
    5eb2:	1d02      	jne	0x5eb8 <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    5eb4:	7001      	lod	A, #1
    5eb6:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    5eb8:	7000      	lod	A, #0
    }
}
    5eba:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    5ebc:	5801      	inc	S, #2
    5ebe:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    5ec0:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5ec2:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    5ec4:	6003      	lod	AL, #3
    5ec6:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    5ec8:	607f      	lod	AL, #127
    5eca:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    5ecc:	13bc      	call	0x6646 <_LDR_GetState>
    5ece:	8480      	or	AL, #-128
    5ed0:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    5ed2:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x1>
    5ed4:	8601      	or	AL, [S-2]
    5ed6:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    5ed8:	60ff      	lod	AL, #-1
    5eda:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    5edc:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL
    LinFrameDataBuffer[7] = 0xFF;
    5ede:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    5ee0:	6000      	lod	AL, #0
    5ee2:	41d7      	mov	dp:0xd7 <_ml_driver_mode+0x1>, AL
    5ee4:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    5ee6:	5801      	inc	S, #2
    5ee8:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    5eea:	aeda 00f0 	cmp	A, #240
    5eee:	1d02      	jne	0x5ef4 <_ldr_isReadByIdMessage+0x86>
    5ef0:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x1>
    5ef2:	1904      	je	0x5efc <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    5ef4:	72e6      	lod	A, Y
    5ef6:	17e2      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    5ef8:	7000      	lod	A, #0
    5efa:	000e      	jmp	0x5f18 <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    5efc:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5efe:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    5f00:	6002      	lod	AL, #2
    5f02:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    5f04:	60f4      	lod	AL, #-12
    5f06:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    5f08:	139e      	call	0x6646 <_LDR_GetState>
    5f0a:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    5f0c:	60ff      	lod	AL, #-1
    5f0e:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    5f10:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    5f12:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL
        LinFrameDataBuffer[7] = 0xFF;
    5f14:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL
        blReturn = ML_TRUE;
    5f16:	7001      	lod	A, #1
    5f18:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    5f1a:	7000      	lod	A, #0
    5f1c:	15c3      	call	0x5aa4 <_ml_DataReady>

    return ( blReturn );
}
    5f1e:	7201      	lod	A, [S-2]
    5f20:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    5f22:	5807      	inc	S, #8
    5f24:	660b      	lod	YL, [S-12]
    5f26:	5cf6      	usex	Y
    5f28:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    5f2a:	79de      	lod	Y, dp:0xde <_ml_driver_mode+0x8>
    5f2c:	e1e6      	add	Y, dp:0xe6 <_ml_driver_mode+0x10>
    5f2e:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    5f30:	7ae2      	lod	Y, A
    5f32:	e2da 00ca 	add	Y, #202


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    5f36:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0x10>
    5f38:	5205      	mov	[S-6], A
    5f3a:	72e6      	lod	A, Y
    5f3c:	a001      	add	A, #1
    5f3e:	5203      	mov	[S-4], A
    5f40:	20ff      	add	X, #-1
    5f42:	5e01      	mov	[S-2], X
    5f44:	7e05      	lod	X, [S-6]
    5f46:	2de2      	cmp	X, dp:0xe2 <_ml_driver_mode+0xc>
    5f48:	1c04      	jnc	0x5f52 <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    5f4a:	7e07      	lod	X, [S-8]
    5f4c:	62de      	lod	AL, [X++]
    5f4e:	5e07      	mov	[S-8], X
    5f50:	0001      	jmp	0x5f54 <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    5f52:	60ff      	lod	AL, #-1
    5f54:	42f0      	mov	[Y], AL
    5f56:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    5f58:	7205      	lod	A, [S-6]
    5f5a:	a001      	add	A, #1
    5f5c:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    5f5e:	7e01      	lod	X, [S-2]
    5f60:	1d6a      	jne	0x5f36 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    5f62:	ade2      	cmp	A, dp:0xe2 <_ml_driver_mode+0xc>
    5f64:	1802      	jc	0x5f6a <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    5f66:	7000      	lod	A, #0
    5f68:	15c8      	call	0x5afa <_ml_ContFrame>
    5f6a:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    5f6c:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    5f6e:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x1>
    5f70:	1904      	je	0x5f7a <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5f72:	72da 00f0 	lod	A, #240
    5f76:	17a2      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    5f78:	0039      	jmp	0x5fec <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    5f7a:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xc>
    5f7c:	7ae2      	lod	Y, A
    5f7e:	e002      	add	Y, #2
    5f80:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    5f82:	ac04      	cmp	A, #4
    5f84:	1a17      	jule	0x5fb4 <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    5f86:	7001      	lod	A, #1
    5f88:	15b8      	call	0x5afa <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    5f8a:	6000      	lod	AL, #0
    5f8c:	41e8      	mov	dp:0xe8 <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    5f8e:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5f90:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    5f92:	7201      	lod	A, [S-2]
    5f94:	b6da 0f00 	and	A, #3840
    5f98:	6000      	lod	AL, #0
    5f9a:	72e4      	swap	A
    5f9c:	8410      	or	AL, #16
    5f9e:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    5fa0:	6601      	lod	YL, [S-2]
    5fa2:	45cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    5fa4:	60f4      	lod	AL, #-12
    5fa6:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    5fa8:	134e      	call	0x6646 <_LDR_GetState>
    5faa:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    5fac:	54ca 0003 	pushw	#3
    5fb0:	7005      	lod	A, #5
    5fb2:	001a      	jmp	0x5fe8 <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    5fb4:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    5fb6:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    5fb8:	6201      	lod	AL, [S-2]
    5fba:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    5fbc:	60f4      	lod	AL, #-12
    5fbe:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    5fc0:	1342      	call	0x6646 <_LDR_GetState>
    5fc2:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    5fc4:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    5fc6:	aeda bf66 	cmp	A, #48998
    5fca:	1d0b      	jne	0x5fe2 <_ldr_isReadByIdMessage+0x174>
    5fcc:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xc>
    5fce:	ac02      	cmp	A, #2
    5fd0:	1d08      	jne	0x5fe2 <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    5fd2:	1339      	call	0x6646 <_LDR_GetState>
    5fd4:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    5fd6:	6400      	lod	YL, #0
    5fd8:	45cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    5fda:	60ff      	lod	AL, #-1
    5fdc:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    5fde:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL
    5fe0:	0005      	jmp	0x5fec <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    5fe2:	54ca 0004 	pushw	#4
    5fe6:	7004      	lod	A, #4
    5fe8:	179c      	call	0x5f22 <_ldr_isReadByIdMessage+0xb4>
    5fea:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    5fec:	7000      	lod	A, #0
    5fee:	155a      	call	0x5aa4 <_ml_DataReady>
    5ff0:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    5ff2:	5801      	inc	S, #2
    5ff4:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    5ff6:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x1>
    5ff8:	1904      	je	0x6002 <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5ffa:	72da 00f0 	lod	A, #240
    5ffe:	175e      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    6000:	000f      	jmp	0x6020 <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    6002:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    6004:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    6006:	6006      	lod	AL, #6
    6008:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    600a:	60f4      	lod	AL, #-12
    600c:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    600e:	131b      	call	0x6646 <_LDR_GetState>
    6010:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    6012:	79e2      	lod	Y, dp:0xe2 <_ml_driver_mode+0xc>
    6014:	4dce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    6016:	45cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    6018:	7201      	lod	A, [S-2]
    601a:	49d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    601c:	6201      	lod	AL, [S-2]
    601e:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    6020:	7000      	lod	A, #0
    6022:	1540      	call	0x5aa4 <_ml_DataReady>
    6024:	5403      	ret	#4

00006026 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    6026:	ac0a      	cmp	A, #10
    6028:	1901      	je	0x602c <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    602a:	41d7      	mov	dp:0xd7 <_ml_driver_mode+0x1>, AL
    602c:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    602e:	5807      	inc	S, #8
    6030:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    6032:	61d7      	lod	AL, dp:0xd7 <_ml_driver_mode+0x1>
    6034:	1904      	je	0x603e <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    6036:	72da 00f0 	lod	A, #240
    603a:	1740      	call	0x5ebc <_ldr_isReadByIdMessage+0x4e>
    603c:	0040      	jmp	0x60be <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    603e:	15b3      	call	0x5ba6 <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    6040:	79de      	lod	Y, dp:0xde <_ml_driver_mode+0x8>
    6042:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    6044:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    6046:	7000      	lod	A, #0
    6048:	5201      	mov	[S-2], A
    604a:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xc>
    604c:	5203      	mov	[S-4], A
    604e:	7000      	lod	A, #0
    6050:	ae03      	cmp	A, [S-4]
    6052:	1c26      	jnc	0x60a0 <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    6054:	7ae8      	swap	Y
        crc ^= *data;
    6056:	7e05      	lod	X, [S-6]
    6058:	62de      	lod	AL, [X++]
    605a:	5e05      	mov	[S-6], X
    605c:	5cf2      	usex	A
    605e:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    6060:	62e8      	lod	AL, YL
    6062:	44b0      	lsr	AL, #2
    6064:	44b0      	lsr	AL, #2
    6066:	5cf2      	usex	A
    6068:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    606a:	72e6      	lod	A, Y
    606c:	b40f      	and	A, #15
    606e:	44d2      	rr	A, #2
    6070:	44d2      	rr	A, #2
    6072:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    6074:	72e6      	lod	A, Y
    6076:	b6da 00ff 	and	A, #255
    607a:	44a2      	asl	A, #2
    607c:	44a2      	asl	A, #2
    607e:	4422      	asl	A
    6080:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    6082:	7201      	lod	A, [S-2]
    6084:	b6da 0fff 	and	A, #4095
    6088:	1d07      	jne	0x6098 <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    608a:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    608c:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    608e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6090:	b430      	and	A, #48
    6092:	1902      	je	0x6098 <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6094:	6000      	lod	AL, #0
    6096:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    6098:	7201      	lod	A, [S-2]
    609a:	a001      	add	A, #1
    609c:	5201      	mov	[S-2], A
    609e:	07d8      	jmp	0x6050 <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    60a0:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    60a2:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    60a4:	6006      	lod	AL, #6
    60a6:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    60a8:	60f4      	lod	AL, #-12
    60aa:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    60ac:	60ff      	lod	AL, #-1
    60ae:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    60b0:	4dce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    60b2:	45cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    60b4:	7207      	lod	A, [S-8]
    60b6:	49d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    60b8:	6607      	lod	YL, [S-8]
    60ba:	45d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    60bc:	1572      	call	0x5ba2 <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    60be:	7000      	lod	A, #0
    60c0:	14f1      	call	0x5aa4 <_ml_DataReady>
    60c2:	5409      	ret	#10

000060c4 <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    60c4:	5801      	inc	S, #2
    60c6:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    60c8:	12be      	call	0x6646 <_LDR_GetState>
    60ca:	8c00      	cmp	AL, #0
    60cc:	1d09      	jne	0x60e0 <_ml_ldr_SwitchToProgMode+0x1c>
    60ce:	82db 7aec 	callf	0x7aec <_mlu_ApplicationStop>
    60d2:	8c00      	cmp	AL, #0
    60d4:	1905      	je	0x60e0 <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    60d6:	6000      	lod	AL, #0
    60d8:	41d6      	mov	dp:0xd6 <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    60da:	7000      	lod	A, #0
    60dc:	14de      	call	0x5a9a <_ml_ReleaseBufferProg>
    60de:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    60e0:	7000      	lod	A, #0
    60e2:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    60e6:	12af      	call	0x6646 <_LDR_GetState>
    60e8:	8c00      	cmp	AL, #0
    60ea:	1d0b      	jne	0x6102 <_ml_ldr_SwitchToProgMode+0x3e>
    60ec:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    60f0:	aeda 3212 	cmp	A, #12818
    60f4:	1906      	je	0x6102 <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    60f6:	14c8      	call	0x5a88 <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    60f8:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    60fc:	a410      	or	A, #16
    60fe:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    6102:	6055      	lod	AL, #85
    6104:	41d6      	mov	dp:0xd6 <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    6106:	6000      	lod	AL, #0
    6108:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    610a:	12a8      	call	0x665c <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    610c:	7001      	lod	A, #1
    610e:	14c5      	call	0x5a9a <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    6110:	6201      	lod	AL, [S-2]
    6112:	8c01      	cmp	AL, #1
    6114:	1d0c      	jne	0x612e <_ml_ldr_SwitchToProgMode+0x6a>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    6116:	72da 3212 	lod	A, #12818
    611a:	52d8 0372 	mov	0x372 <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    611e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6122:	94fe      	and	AL, #-2
    6124:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    6128:	82db 5920 	callf	0x5920 <_MLX16_RESET>
            for (;;) {
    612c:	07ff      	jmp	0x612c <_ml_ldr_SwitchToProgMode+0x68>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    612e:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    6130:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    6132:	6006      	lod	AL, #6
    6134:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6136:	60f2      	lod	AL, #-14
    6138:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    613a:	4cea 0004 	movu	YA, #4
    613e:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    6140:	4cea 0401 	movu	YA, #1025
    6144:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    6146:	6000      	lod	AL, #0
    6148:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    614a:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    614c:	127c      	call	0x6646 <_LDR_GetState>
    614e:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6150:	7000      	lod	A, #0
    6152:	14a8      	call	0x5aa4 <_ml_DataReady>
    6154:	5403      	ret	#4

00006156 <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    6156:	8c33      	cmp	AL, #51
    6158:	1d03      	jne	0x6160 <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    615a:	7001      	lod	A, #1
    615c:	17b3      	call	0x60c4 <_ml_ldr_SwitchToProgMode>
    615e:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    6160:	ac00      	cmp	A, #0
    6162:	1d14      	jne	0x618c <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    6164:	7001      	lod	A, #1
    6166:	1499      	call	0x5a9a <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    6168:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    616a:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    616c:	6006      	lod	AL, #6
    616e:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6170:	60f2      	lod	AL, #-14
    6172:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    6174:	6013      	lod	AL, #19
    6176:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    6178:	6000      	lod	AL, #0
    617a:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    617c:	60fe      	lod	AL, #-2
    617e:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    6180:	60ca      	lod	AL, #-54
    6182:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    6184:	6001      	lod	AL, #1
    6186:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6188:	7000      	lod	A, #0
    618a:	148c      	call	0x5aa4 <_ml_DataReady>
    618c:	5401      	ret

0000618e <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    618e:	61e9      	lod	AL, dp:0xe9 <_ml_driver_mode+0x13>
    6190:	8c03      	cmp	AL, #3
    6192:	1d15      	jne	0x61be <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    6194:	7000      	lod	A, #0
    6196:	14b1      	call	0x5afa <_ml_ContFrame>
            (void)ml_Disconnect();
    6198:	1506      	call	0x5ba6 <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    619a:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x4>
    619c:	5cf2      	usex	A
    619e:	1377      	call	0x688e <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    61a0:	54ca 0000 	pushw	#0
    61a4:	54ca 0001 	pushw	#1
    61a8:	54ca 0000 	pushw	#0
    61ac:	7001      	lod	A, #1
    61ae:	1498      	call	0x5ae0 <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    61b0:	7001      	lod	A, #1
    61b2:	1492      	call	0x5ad8 <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    61b4:	14fa      	call	0x5baa <_ml_SwitchToFast>
            pendingAction = 0;
    61b6:	6000      	lod	AL, #0
    61b8:	41e9      	mov	dp:0xe9 <_ml_driver_mode+0x13>, AL
            break;
    61ba:	5c05      	dec	S, #6
    61bc:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    61be:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    61c0:	8c06      	cmp	AL, #6
    61c2:	1902      	je	0x61c8 <_ml_DiagRequest+0x3a>
    61c4:	8c08      	cmp	AL, #8
    61c6:	1d14      	jne	0x61f0 <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    61c8:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0x10>
    61ca:	ade2      	cmp	A, dp:0xe2 <_ml_driver_mode+0xc>
    61cc:	1c11      	jnc	0x61f0 <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    61ce:	61e8      	lod	AL, dp:0xe8 <_ml_driver_mode+0x12>
    61d0:	8001      	add	AL, #1
    61d2:	66e0      	lod	YL, AL
    61d4:	41e8      	mov	dp:0xe8 <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    61d6:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    61d8:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    61da:	62e8      	lod	AL, YL
    61dc:	940f      	and	AL, #15
    61de:	8420      	or	AL, #32
    61e0:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    61e2:	54ca 0006 	pushw	#6
    61e6:	7002      	lod	A, #2
    61e8:	169c      	call	0x5f22 <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    61ea:	7000      	lod	A, #0
    61ec:	145b      	call	0x5aa4 <_ml_DataReady>
    61ee:	5c01      	dec	S, #2
    61f0:	5401      	ret

000061f2 <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    61f2:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    61f4:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x1>
    61f6:	5cf2      	usex	A
    61f8:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    61fa:	b6da 00f0 	and	A, #240
    61fe:	ac20      	cmp	A, #32
    6200:	1901      	je	0x6204 <_ml_DiagReceived+0x12>
    6202:	0073      	jmp	0x62ea <_ml_DiagReceived+0xf8>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    6204:	7a0b      	lod	Y, [S-12]
    6206:	f40f      	and	Y, #15
    6208:	61e8      	lod	AL, dp:0xe8 <_ml_driver_mode+0x12>
    620a:	4209      	mov	[S-10], AL
    620c:	b40f      	and	A, #15
    620e:	eee2      	cmp	Y, A
    6210:	1901      	je	0x6214 <_ml_DiagReceived+0x22>
    6212:	0067      	jmp	0x62e2 <_ml_DiagReceived+0xf0>
                ddFrameCounter += 1;
    6214:	6209      	lod	AL, [S-10]
    6216:	8001      	add	AL, #1
    6218:	41e8      	mov	dp:0xe8 <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    621a:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    621c:	8c85      	cmp	AL, #-123
    621e:	1901      	je	0x6222 <_ml_DiagReceived+0x30>
    6220:	003d      	jmp	0x629c <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6222:	7800      	lod	Y, #0
    6224:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    6226:	79e6      	lod	Y, dp:0xe6 <_ml_driver_mode+0x10>
    6228:	ede2      	cmp	Y, dp:0xe2 <_ml_driver_mode+0xc>
    622a:	1c0a      	jnc	0x6240 <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    622c:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xa>
    622e:	a2e6      	add	A, Y
    6230:	7a0d      	lod	Y, [S-14]
    6232:	e2da 00cc 	add	Y, #204
    6236:	66f0      	lod	YL, [Y]
    6238:	5cf6      	usex	Y
    623a:	5adf      	push	Y
    623c:	1246      	call	0x66ca <_Flash_PageBufferFill>
    623e:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6240:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0x10>
    6242:	a001      	add	A, #1
    6244:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6246:	7a0d      	lod	Y, [S-14]
    6248:	e001      	add	Y, #1
    624a:	5a0d      	mov	[S-14], Y
    624c:	ec05      	cmp	Y, #5
    624e:	1a6b      	jule	0x6226 <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6250:	ade2      	cmp	A, dp:0xe2 <_ml_driver_mode+0xc>
    6252:	1c01      	jnc	0x6256 <_ml_DiagReceived+0x64>
    6254:	01f7      	jmp	0x6644 <_ml_DiagReceived+0x452>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    6256:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    6258:	1308      	call	0x686a <_Flash_PageWriteFiltered>
    625a:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    625c:	ac00      	cmp	A, #0
    625e:	1901      	je	0x6262 <_ml_DiagReceived+0x70>
    6260:	0042      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    6262:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0x10>
    6264:	79e4      	lod	Y, dp:0xe4 <_ml_driver_mode+0xe>
    6266:	aee6      	cmp	A, Y
    6268:	1c15      	jnc	0x6294 <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    626a:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    626c:	7ee2      	lod	X, A
    626e:	22da 0080 	add	X, #128
    6272:	5dde      	mov	dp:0xde <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    6274:	7000      	lod	A, #0
    6276:	51e0      	mov	dp:0xe0 <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    6278:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    627a:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    627c:	eeda 0080 	cmp	Y, #128
    6280:	1a03      	jule	0x6288 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    6282:	72da 0080 	lod	A, #128
    6286:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    6288:	72e6      	lod	A, Y
    628a:	a9e2      	sub	A, dp:0xe2 <_ml_driver_mode+0xc>
    628c:	51e4      	mov	dp:0xe4 <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    628e:	72ee      	lod	A, X
    6290:	120d      	call	0x66ac <_Flash_PageRead>
    6292:	0029      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    6294:	7800      	lod	Y, #0
    6296:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    6298:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xe>, Y
    629a:	0025      	jmp	0x62e6 <_ml_DiagReceived+0xf4>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    629c:	8c47      	cmp	AL, #71
    629e:	1d23      	jne	0x62e6 <_ml_DiagReceived+0xf4>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62a0:	7000      	lod	A, #0
    62a2:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    62a4:	79e6      	lod	Y, dp:0xe6 <_ml_driver_mode+0x10>
    62a6:	ede2      	cmp	Y, dp:0xe2 <_ml_driver_mode+0xc>
    62a8:	1c0b      	jnc	0x62c0 <_ml_DiagReceived+0xce>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    62aa:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    62ac:	a2e6      	add	A, Y
    62ae:	7a0d      	lod	Y, [S-14]
    62b0:	e2da 00cc 	add	Y, #204
    62b4:	66f0      	lod	YL, [Y]
    62b6:	5cf6      	usex	Y
    62b8:	5adf      	push	Y
    62ba:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
    62be:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    62c0:	71e6      	lod	A, dp:0xe6 <_ml_driver_mode+0x10>
    62c2:	a001      	add	A, #1
    62c4:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    62c6:	7a0d      	lod	Y, [S-14]
    62c8:	e001      	add	Y, #1
    62ca:	5a0d      	mov	[S-14], Y
    62cc:	ec05      	cmp	Y, #5
    62ce:	1a6a      	jule	0x62a4 <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    62d0:	ade2      	cmp	A, dp:0xe2 <_ml_driver_mode+0xc>
    62d2:	1c01      	jnc	0x62d6 <_ml_DiagReceived+0xe4>
    62d4:	01b7      	jmp	0x6644 <_ml_DiagReceived+0x452>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    62d6:	82db 5a88 	callf	0x5a88 <_NVRAM_SaveAll>
                        ddDataSize = 0;
    62da:	7000      	lod	A, #0
    62dc:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    62de:	140d      	call	0x5afa <_ml_ContFrame>
    62e0:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    62e2:	6400      	lod	YL, #0
    62e4:	45d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    62e6:	7000      	lod	A, #0
    62e8:	07fa      	jmp	0x62de <_ml_DiagReceived+0xec>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    62ea:	ac10      	cmp	A, #16
    62ec:	1901      	je	0x62f0 <_ml_DiagReceived+0xfe>
    62ee:	0041      	jmp	0x6372 <_ml_DiagReceived+0x180>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    62f0:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    62f2:	8cb4      	cmp	AL, #-76
    62f4:	1901      	je	0x62f8 <_ml_DiagReceived+0x106>
    62f6:	01a0      	jmp	0x6638 <_ml_DiagReceived+0x446>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    62f8:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x4>
    62fa:	8cd3      	cmp	AL, #-45
    62fc:	1901      	je	0x6300 <_ml_DiagReceived+0x10e>
    62fe:	019c      	jmp	0x6638 <_ml_DiagReceived+0x446>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    6300:	6001      	lod	AL, #1
    6302:	41e8      	mov	dp:0xe8 <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    6304:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    6306:	8c85      	cmp	AL, #-123
    6308:	1d14      	jne	0x6332 <_ml_DiagReceived+0x140>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    630a:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x5>
    630c:	5cf2      	usex	A
    630e:	52df      	push	A
    6310:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xa>
    6312:	11db      	call	0x66ca <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    6314:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xa>
    6316:	a001      	add	A, #1
    6318:	65d0      	lod	YL, dp:0xd0 <_LinFrameDataBuffer+0x6>
    631a:	5cf6      	usex	Y
    631c:	5adf      	push	Y
    631e:	11d5      	call	0x66ca <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    6320:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xa>
    6322:	a002      	add	A, #2
    6324:	65d1      	lod	YL, dp:0xd1 <_LinFrameDataBuffer+0x7>
    6326:	5cf6      	usex	Y
    6328:	5adf      	push	Y
    632a:	11cf      	call	0x66ca <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    632c:	7003      	lod	A, #3
    632e:	51e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, A
    6330:	0018      	jmp	0x6362 <_ml_DiagReceived+0x170>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    6332:	8c47      	cmp	AL, #71
    6334:	1d1b      	jne	0x636c <_ml_DiagReceived+0x17a>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    6336:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x5>
    6338:	5cf2      	usex	A
    633a:	52df      	push	A
    633c:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    633e:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    6342:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    6344:	a001      	add	A, #1
    6346:	65d0      	lod	YL, dp:0xd0 <_LinFrameDataBuffer+0x6>
    6348:	5cf6      	usex	Y
    634a:	5adf      	push	Y
    634c:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    6350:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    6352:	a002      	add	A, #2
    6354:	65d1      	lod	YL, dp:0xd1 <_LinFrameDataBuffer+0x7>
    6356:	5cf6      	usex	Y
    6358:	5adf      	push	Y
    635a:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    635e:	7803      	lod	Y, #3
    6360:	59e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    6362:	7001      	lod	A, #1
    6364:	82db 5afa 	callf	0x5afa <_ml_ContFrame>
    6368:	5c05      	dec	S, #6
    636a:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    636c:	7020      	lod	A, #32
    636e:	15bb      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
    6370:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    6372:	620b      	lod	AL, [S-12]
    6374:	94f0      	and	AL, #-16
    6376:	1901      	je	0x637a <_ml_DiagReceived+0x188>
    6378:	0162      	jmp	0x663e <_ml_DiagReceived+0x44c>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    637a:	7000      	lod	A, #0
    637c:	82db 5afa 	callf	0x5afa <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    6380:	720b      	lod	A, [S-12]
    6382:	b40f      	and	A, #15
    6384:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    6386:	61cc      	lod	AL, dp:0xcc <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    6388:	8cb4      	cmp	AL, #-76
    638a:	190d      	je	0x63a6 <_ml_DiagReceived+0x1b4>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    638c:	54ca 0001 	pushw	#1
    6390:	72da 00ca 	lod	A, #202
    6394:	156c      	call	0x5e6e <_ldr_isReadByIdMessage>
    6396:	5c01      	dec	S, #2
    6398:	8c00      	cmp	AL, #0
    639a:	1d01      	jne	0x639e <_ml_DiagReceived+0x1ac>
    639c:	014d      	jmp	0x6638 <_ml_DiagReceived+0x446>
                ml_ldr_ReadByIdMessage(Data[0]);
    639e:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x3>
    63a0:	5cf2      	usex	A
    63a2:	16d9      	call	0x6156 <_ml_ldr_ReadByIdMessage>
    63a4:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    63a6:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x3>
    63a8:	4207      	mov	[S-8], AL
    63aa:	8cd3      	cmp	AL, #-45
    63ac:	190a      	je	0x63c2 <_ml_DiagReceived+0x1d0>
    63ae:	8c80      	cmp	AL, #-128
    63b0:	1908      	je	0x63c2 <_ml_DiagReceived+0x1d0>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    63b2:	69ce      	lod	AH, dp:0xce <_LinFrameDataBuffer+0x4>
    63b4:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x5>
    63b6:	51de      	mov	dp:0xde <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    63b8:	69d0      	lod	AH, dp:0xd0 <_LinFrameDataBuffer+0x6>
    63ba:	61d1      	lod	AL, dp:0xd1 <_LinFrameDataBuffer+0x7>
    63bc:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    63be:	7800      	lod	Y, #0
    63c0:	59e6      	mov	dp:0xe6 <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    63c2:	6607      	lod	YL, [S-8]
    63c4:	5cf6      	usex	Y
    63c6:	72e6      	lod	A, Y
    63c8:	b420      	and	A, #32
    63ca:	1929      	je	0x641e <_ml_DiagReceived+0x22c>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    63cc:	72e6      	lod	A, Y
    63ce:	b430      	and	A, #48
    63d0:	ac20      	cmp	A, #32
    63d2:	1d18      	jne	0x6404 <_ml_DiagReceived+0x212>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    63d4:	6085      	lod	AL, #-123
    63d6:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    63d8:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    63da:	7ae2      	lod	Y, A
    63dc:	f47f      	and	Y, #127
    63de:	59e0      	mov	dp:0xe0 <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    63e0:	b480      	and	A, #-128
    63e2:	5205      	mov	[S-6], A
    63e4:	51de      	mov	dp:0xde <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    63e6:	7de2      	lod	X, dp:0xe2 <_ml_driver_mode+0xc>
    63e8:	5de4      	mov	dp:0xe4 <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    63ea:	72da 0080 	lod	A, #128
    63ee:	aae6      	sub	A, Y
    63f0:	51e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    63f2:	aeee      	cmp	A, X
    63f4:	1a01      	jule	0x63f8 <_ml_DiagReceived+0x206>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    63f6:	5de2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    63f8:	7205      	lod	A, [S-6]
    63fa:	1148      	call	0x668c <_Flash_GetWriteTime>
    63fc:	15fa      	call	0x5ff2 <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    63fe:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    6400:	1155      	call	0x66ac <_Flash_PageRead>
    6402:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    6404:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    6406:	8cd6      	cmp	AL, #-42
    6408:	1901      	je	0x640c <_ml_DiagReceived+0x21a>
    640a:	0087      	jmp	0x651a <_ml_DiagReceived+0x328>
    640c:	61d9      	lod	AL, dp:0xd9 <_ml_driver_mode+0x3>
    640e:	1901      	je	0x6412 <_ml_DiagReceived+0x220>
    6410:	0084      	jmp	0x651a <_ml_DiagReceived+0x328>
    6412:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x4>
    6414:	8c01      	cmp	AL, #1
    6416:	1901      	je	0x641a <_ml_DiagReceived+0x228>
    6418:	0080      	jmp	0x651a <_ml_DiagReceived+0x328>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    641a:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xc>
    641c:	0106      	jmp	0x662a <_ml_DiagReceived+0x438>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    641e:	eeda 0080 	cmp	Y, #128
    6422:	1d01      	jne	0x6426 <_ml_DiagReceived+0x234>
    6424:	002d      	jmp	0x6480 <_ml_DiagReceived+0x28e>
    6426:	1f0c      	jsg	0x6440 <_ml_DiagReceived+0x24e>
    6428:	ec08      	cmp	Y, #8
    642a:	1d01      	jne	0x642e <_ml_DiagReceived+0x23c>
    642c:	0065      	jmp	0x64f8 <_ml_DiagReceived+0x306>
    642e:	1f04      	jsg	0x6438 <_ml_DiagReceived+0x246>
    6430:	ec03      	cmp	Y, #3
    6432:	1d01      	jne	0x6436 <_ml_DiagReceived+0x244>
    6434:	0039      	jmp	0x64a8 <_ml_DiagReceived+0x2b6>
    6436:	0100      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6438:	ec47      	cmp	Y, #71
    643a:	1d01      	jne	0x643e <_ml_DiagReceived+0x24c>
    643c:	0059      	jmp	0x64f0 <_ml_DiagReceived+0x2fe>
    643e:	00fc      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6440:	eeda 00c1 	cmp	Y, #193
    6444:	190f      	je	0x6464 <_ml_DiagReceived+0x272>
    6446:	1f05      	jsg	0x6452 <_ml_DiagReceived+0x260>
    6448:	eeda 0092 	cmp	Y, #146
    644c:	1d01      	jne	0x6450 <_ml_DiagReceived+0x25e>
    644e:	0059      	jmp	0x6502 <_ml_DiagReceived+0x310>
    6450:	00f3      	jmp	0x6638 <_ml_DiagReceived+0x446>
    6452:	eeda 00d3 	cmp	Y, #211
    6456:	1d01      	jne	0x645a <_ml_DiagReceived+0x268>
    6458:	0063      	jmp	0x6520 <_ml_DiagReceived+0x32e>
    645a:	eeda 00d6 	cmp	Y, #214
    645e:	1d01      	jne	0x6462 <_ml_DiagReceived+0x270>
    6460:	00c6      	jmp	0x65ee <_ml_DiagReceived+0x3fc>
    6462:	00ea      	jmp	0x6638 <_ml_DiagReceived+0x446>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    6464:	10f0      	call	0x6646 <_LDR_GetState>
    6466:	66e0      	lod	YL, AL
    6468:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x4>
    646a:	8ee8      	cmp	AL, YL
    646c:	1d01      	jne	0x6470 <_ml_DiagReceived+0x27e>
    646e:	00ea      	jmp	0x6644 <_ml_DiagReceived+0x452>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    6470:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6474:	94fe      	and	AL, #-2
    6476:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    647a:	82db 5920 	callf	0x5920 <_MLX16_RESET>
                            }
                            break;
    647e:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    6480:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    6482:	8c85      	cmp	AL, #-123
    6484:	1d09      	jne	0x6498 <_ml_DiagReceived+0x2a6>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    6486:	71dc      	lod	A, dp:0xdc <_ml_driver_mode+0x6>
    6488:	1d05      	jne	0x6494 <_ml_DiagReceived+0x2a2>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    648a:	71e2      	lod	A, dp:0xe2 <_ml_driver_mode+0xc>
    648c:	1901      	je	0x6490 <_ml_DiagReceived+0x29e>
    648e:	076e      	jmp	0x636c <_ml_DiagReceived+0x17a>
                                        ddCurrentOp = 0;            /* operation done */
    6490:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
    6492:	0007      	jmp	0x64a2 <_ml_DiagReceived+0x2b0>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    6494:	7050      	lod	A, #80
    6496:	076b      	jmp	0x636e <_ml_DiagReceived+0x17c>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6498:	8c47      	cmp	AL, #71
    649a:	1901      	je	0x649e <_ml_DiagReceived+0x2ac>
    649c:	00b6      	jmp	0x660a <_ml_DiagReceived+0x418>
                                ddCurrentOp = 0;                /* operation done */
    649e:	6400      	lod	YL, #0
    64a0:	45d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    64a2:	7000      	lod	A, #0
    64a4:	15a6      	call	0x5ff2 <_ldr_isReadByIdMessage+0x184>
    64a6:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    64a8:	620b      	lod	AL, [S-12]
    64aa:	8c03      	cmp	AL, #3
    64ac:	1d08      	jne	0x64be <_ml_DiagReceived+0x2cc>
                                peCurrentValue = Data[1];
    64ae:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x4>
    64b0:	41da      	mov	dp:0xda <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    64b2:	8c64      	cmp	AL, #100
    64b4:	1e04      	jug	0x64be <_ml_DiagReceived+0x2cc>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    64b6:	8c12      	cmp	AL, #18
    64b8:	1e04      	jug	0x64c2 <_ml_DiagReceived+0x2d0>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    64ba:	6013      	lod	AL, #19
    64bc:	0001      	jmp	0x64c0 <_ml_DiagReceived+0x2ce>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    64be:	6064      	lod	AL, #100
    64c0:	41da      	mov	dp:0xda <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    64c2:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    64c4:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    64c6:	6403      	lod	YL, #3
    64c8:	45cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    64ca:	60f4      	lod	AL, #-12
    64cc:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    64ce:	10bb      	call	0x6646 <_LDR_GetState>
    64d0:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    64d2:	61da      	lod	AL, dp:0xda <_ml_driver_mode+0x4>
    64d4:	41ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    64d6:	60ff      	lod	AL, #-1
    64d8:	41cf      	mov	dp:0xcf <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    64da:	41d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    64dc:	41d1      	mov	dp:0xd1 <_LinFrameDataBuffer+0x7>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    64de:	7000      	lod	A, #0
    64e0:	82db 5aa4 	callf	0x5aa4 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    64e4:	7001      	lod	A, #1
    64e6:	82db 5afa 	callf	0x5afa <_ml_ContFrame>
                            pendingAction = ddFastProt;
    64ea:	6003      	lod	AL, #3
    64ec:	41e9      	mov	dp:0xe9 <_ml_driver_mode+0x13>, AL
                            break;
    64ee:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    64f0:	45d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64f2:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
    64f6:	07d5      	jmp	0x64a2 <_ml_DiagReceived+0x2b0>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    64f8:	45d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64fa:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    64fe:	1536      	call	0x5f6c <_ldr_isReadByIdMessage+0xfe>
                            break;
    6500:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    6502:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    6504:	6000      	lod	AL, #0
    6506:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    6508:	ac08      	cmp	A, #8
    650a:	1902      	je	0x6510 <_ml_DiagReceived+0x31e>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    650c:	7010      	lod	A, #16
    650e:	072f      	jmp	0x636e <_ml_DiagReceived+0x17c>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    6510:	7801      	lod	Y, #1
    6512:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    6514:	72da 6bec 	lod	A, #27628
    6518:	51de      	mov	dp:0xde <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    651a:	6006      	lod	AL, #6
    651c:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
    651e:	07ef      	jmp	0x64fe <_ml_DiagReceived+0x30c>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    6520:	61d8      	lod	AL, dp:0xd8 <_ml_driver_mode+0x2>
    6522:	8c85      	cmp	AL, #-123
    6524:	1901      	je	0x6528 <_ml_DiagReceived+0x336>
    6526:	0042      	jmp	0x65ac <_ml_DiagReceived+0x3ba>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    6528:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    652a:	a1e0      	add	A, dp:0xe0 <_ml_driver_mode+0xa>
    652c:	aeda bf66 	cmp	A, #48998
    6530:	1d24      	jne	0x657a <_ml_DiagReceived+0x388>
    6532:	71e4      	lod	A, dp:0xe4 <_ml_driver_mode+0xe>
    6534:	ac02      	cmp	A, #2
    6536:	1d21      	jne	0x657a <_ml_DiagReceived+0x388>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    6538:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x4>
    653a:	5cf2      	usex	A

                                    switch (new_state) {
    653c:	1903      	je	0x6544 <_ml_DiagReceived+0x352>
    653e:	ac01      	cmp	A, #1
    6540:	190d      	je	0x655c <_ml_DiagReceived+0x36a>
    6542:	0051      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    6544:	72da be84 	lod	A, #48772
    6548:	10b1      	call	0x66ac <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    654a:	72da be84 	lod	A, #48772
    654e:	b47f      	and	A, #127
    6550:	54ca 0001 	pushw	#1
    6554:	10ba      	call	0x66ca <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    6556:	72da be84 	lod	A, #48772
    655a:	000b      	jmp	0x6572 <_ml_DiagReceived+0x380>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    655c:	72da be80 	lod	A, #48768
    6560:	10a5      	call	0x66ac <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    6562:	72da be80 	lod	A, #48768
    6566:	b47f      	and	A, #127
    6568:	54ca 0001 	pushw	#1
    656c:	10ae      	call	0x66ca <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    656e:	72da be80 	lod	A, #48768
    6572:	10c3      	call	0x66fa <_Flash_PageWrite>
    6574:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    6576:	5c01      	dec	S, #2
    6578:	0036      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    657a:	7800      	lod	Y, #0
    657c:	5a0d      	mov	[S-14], Y
    657e:	20fe      	add	X, #-2
    6580:	5e03      	mov	[S-4], X
    6582:	eeee      	cmp	Y, X
    6584:	1c0f      	jnc	0x65a4 <_ml_DiagReceived+0x3b2>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    6586:	71e0      	lod	A, dp:0xe0 <_ml_driver_mode+0xa>
    6588:	a20d      	add	A, [S-14]
    658a:	7a0d      	lod	Y, [S-14]
    658c:	e2da 00ce 	add	Y, #206
    6590:	66f0      	lod	YL, [Y]
    6592:	5cf6      	usex	Y
    6594:	5adf      	push	Y
    6596:	1099      	call	0x66ca <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6598:	5c01      	dec	S, #2
    659a:	720d      	lod	A, [S-14]
    659c:	a001      	add	A, #1
    659e:	520d      	mov	[S-14], A
    65a0:	ae03      	cmp	A, [S-4]
    65a2:	1871      	jc	0x6586 <_ml_DiagReceived+0x394>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    65a4:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    65a6:	1161      	call	0x686a <_Flash_PageWriteFiltered>
    65a8:	51dc      	mov	dp:0xdc <_ml_driver_mode+0x6>, A
    65aa:	001d      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    65ac:	8c47      	cmp	AL, #71
    65ae:	1d19      	jne	0x65e2 <_ml_DiagReceived+0x3f0>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    65b0:	7800      	lod	Y, #0
    65b2:	5a0d      	mov	[S-14], Y
    65b4:	20fe      	add	X, #-2
    65b6:	5e01      	mov	[S-2], X
    65b8:	eeee      	cmp	Y, X
    65ba:	1c10      	jnc	0x65dc <_ml_DiagReceived+0x3ea>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    65bc:	71de      	lod	A, dp:0xde <_ml_driver_mode+0x8>
    65be:	a20d      	add	A, [S-14]
    65c0:	7a0d      	lod	Y, [S-14]
    65c2:	e2da 00ce 	add	Y, #206
    65c6:	66f0      	lod	YL, [Y]
    65c8:	5cf6      	usex	Y
    65ca:	5adf      	push	Y
    65cc:	82db 5a5e 	callf	0x5a5e <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    65d0:	5c01      	dec	S, #2
    65d2:	720d      	lod	A, [S-14]
    65d4:	a001      	add	A, #1
    65d6:	520d      	mov	[S-14], A
    65d8:	ae01      	cmp	A, [S-2]
    65da:	1870      	jc	0x65bc <_ml_DiagReceived+0x3ca>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    65dc:	82db 5a88 	callf	0x5a88 <_NVRAM_SaveAll>
    65e0:	0002      	jmp	0x65e6 <_ml_DiagReceived+0x3f4>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    65e2:	7020      	lod	A, #32
    65e4:	1480      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    65e6:	7800      	lod	Y, #0
    65e8:	59e4      	mov	dp:0xe4 <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    65ea:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    65ec:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    65ee:	60d6      	lod	AL, #-42
    65f0:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    65f2:	61ce      	lod	AL, dp:0xce <_LinFrameDataBuffer+0x4>
    65f4:	41d9      	mov	dp:0xd9 <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    65f6:	1d0c      	jne	0x6610 <_ml_DiagReceived+0x41e>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65f8:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x5>
    65fa:	41da      	mov	dp:0xda <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65fc:	5cf2      	usex	A
    65fe:	1903      	je	0x6606 <_ml_DiagReceived+0x414>
    6600:	ac01      	cmp	A, #1
    6602:	1903      	je	0x660a <_ml_DiagReceived+0x418>
    6604:	0017      	jmp	0x6634 <_ml_DiagReceived+0x442>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    6606:	6000      	lod	AL, #0
    6608:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    660a:	72da 00f0 	lod	A, #240
    660e:	06af      	jmp	0x636e <_ml_DiagReceived+0x17c>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    6610:	8c01      	cmp	AL, #1
    6612:	1d10      	jne	0x6634 <_ml_DiagReceived+0x442>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    6614:	61cf      	lod	AL, dp:0xcf <_LinFrameDataBuffer+0x5>
    6616:	41da      	mov	dp:0xda <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    6618:	1d0a      	jne	0x662e <_ml_DiagReceived+0x43c>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    661a:	61d0      	lod	AL, dp:0xd0 <_LinFrameDataBuffer+0x6>
    661c:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    661e:	1101      	call	0x6822 <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    6620:	7ada 4000 	lod	Y, #16384
    6624:	59de      	mov	dp:0xde <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    6626:	7800      	lod	Y, #0
    6628:	59e2      	mov	dp:0xe2 <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    662a:	1501      	call	0x602e <_ml_ldr_ErrorDetected+0x8>
                                    break;
    662c:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    662e:	6000      	lod	AL, #0
    6630:	41d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, AL
    6632:	0002      	jmp	0x6638 <_ml_DiagReceived+0x446>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    6634:	6400      	lod	YL, #0
    6636:	45d8      	mov	dp:0xd8 <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    6638:	72da 00d0 	lod	A, #208
    663c:	0698      	jmp	0x636e <_ml_DiagReceived+0x17c>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    663e:	72da 00b0 	lod	A, #176
    6642:	1451      	call	0x5ee6 <_ldr_isReadByIdMessage+0x78>
    6644:	540f      	ret	#16

00006646 <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    6646:	7ada be80 	lod	Y, #48768
    664a:	62f0      	lod	AL, [Y]
    664c:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    6650:	66e0      	lod	YL, AL
    6652:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    6656:	a2e6      	add	A, Y
    6658:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    665a:	5401      	ret

0000665c <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    665c:	17f4      	call	0x6646 <_LDR_GetState>
    665e:	8c03      	cmp	AL, #3
    6660:	1d03      	jne	0x6668 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    6662:	72da 8000 	lod	A, #32768
    6666:	0001      	jmp	0x666a <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    6668:	7000      	lod	A, #0
    666a:	52d8 036e 	mov	0x36e <_page_buffer+0x2>, A
    666e:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    6670:	a2da c000 	add	A, #49152
    6674:	72e4      	swap	A
    6676:	b6da 00ff 	and	A, #255
    667a:	44b2      	lsr	A, #2
    667c:	4432      	lsr	A
}
    667e:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    6680:	44e2      	sfb	A
    6682:	b6d8 036e 	and	A, 0x36e <_page_buffer+0x2>
    6686:	1901      	je	0x668a <_Flash_InitDriver+0x2e>
    6688:	7001      	lod	A, #1
}
    668a:	5401      	ret

0000668c <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    668c:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    668e:	17f0      	call	0x6670 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    6690:	17f7      	call	0x6680 <_Flash_InitDriver+0x24>
    6692:	8c00      	cmp	AL, #0
    6694:	1d09      	jne	0x66a8 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6696:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    669a:	8c01      	cmp	AL, #1
    669c:	1a02      	jule	0x66a2 <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    669e:	7030      	lod	A, #48
    66a0:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    66a2:	72da 02a6 	lod	A, #678
    66a6:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    66a8:	7006      	lod	A, #6
    }

    return wr_time;
}
    66aa:	5401      	ret

000066ac <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    66ac:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    66ae:	b480      	and	A, #-128
    66b0:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    66b2:	7ed8 036c 	lod	X, 0x36c <_page_buffer>
    66b6:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    66b8:	7a03      	lod	Y, [S-4]
    66ba:	54c6      	movsw	[X++], [Y++]
    66bc:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66be:	7201      	lod	A, [S-2]
    66c0:	a2da 0080 	add	A, #128
    66c4:	2ee2      	cmp	X, A
    66c6:	1878      	jc	0x66b8 <_Flash_PageRead+0xc>
    66c8:	5405      	ret	#6

000066ca <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    66ca:	b47f      	and	A, #127
    66cc:	7ae2      	lod	Y, A
    66ce:	e2d8 036c 	add	Y, 0x36c <_page_buffer>
    66d2:	6203      	lod	AL, [S-4]
    66d4:	42f0      	mov	[Y], AL
    66d6:	5401      	ret

000066d8 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    66d8:	b480      	and	A, #-128
    66da:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    66dc:	7ad8 036c 	lod	Y, 0x36c <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    66e0:	72d6      	lod	A, [Y++]
    66e2:	aede      	cmp	A, [X++]
    66e4:	1902      	je	0x66ea <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    66e6:	7001      	lod	A, #1
    66e8:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66ea:	72d8 036c 	lod	A, 0x36c <_page_buffer>
    66ee:	a2da 0080 	add	A, #128
    66f2:	eee2      	cmp	Y, A
    66f4:	1875      	jc	0x66e0 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    66f6:	7000      	lod	A, #0
}
    66f8:	5401      	ret

000066fa <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    66fa:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    66fc:	b480      	and	A, #-128
    66fe:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    6700:	17a2      	call	0x6646 <_LDR_GetState>
    6702:	8c01      	cmp	AL, #1
    6704:	1d0b      	jne	0x671c <_Flash_PageWrite+0x22>
    6706:	72da bf66 	lod	A, #48998
    670a:	b480      	and	A, #-128
    670c:	7a09      	lod	Y, [S-10]
    670e:	eee2      	cmp	Y, A
    6710:	1d05      	jne	0x671c <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    6712:	7ad8 036c 	lod	Y, 0x36c <_page_buffer>
    6716:	e076      	add	Y, #118
    6718:	61d2      	lod	AL, dp:0xd2 <_LIN_nad>
    671a:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    671c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    671e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6720:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6722:	b430      	and	A, #48
    6724:	1902      	je	0x672a <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6726:	6000      	lod	AL, #0
    6728:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    672a:	11fc      	call	0x6b24 <_mlx_isPowerOk>
    672c:	8c00      	cmp	AL, #0
    672e:	1d02      	jne	0x6734 <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    6730:	7001      	lod	A, #1
    6732:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    6734:	7a09      	lod	Y, [S-10]
    6736:	eeda be80 	cmp	Y, #48768
    673a:	1d01      	jne	0x673e <_Flash_PageWrite+0x44>
    673c:	0045      	jmp	0x67c8 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    673e:	72e6      	lod	A, Y
    6740:	1797      	call	0x6670 <_Flash_InitDriver+0x14>
    6742:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    6744:	179d      	call	0x6680 <_Flash_InitDriver+0x24>
    6746:	8c00      	cmp	AL, #0
    6748:	1901      	je	0x674c <_Flash_PageWrite+0x52>
    674a:	003e      	jmp	0x67c8 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    674c:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    674e:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6750:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6752:	b430      	and	A, #48
    6754:	1902      	je	0x675a <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6756:	6000      	lod	AL, #0
    6758:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    675a:	7207      	lod	A, [S-8]
    675c:	487a 0800 	muls	Y, A, #2048
    6760:	e2da 4000 	add	Y, #16384
    6764:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6766:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    676a:	8c01      	cmp	AL, #1
    676c:	1a03      	jule	0x6774 <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    676e:	7801      	lod	Y, #1
    6770:	5a03      	mov	[S-4], Y
    6772:	0002      	jmp	0x6778 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    6774:	7010      	lod	A, #16
    6776:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    6778:	7800      	lod	Y, #0
    677a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    677e:	7a05      	lod	Y, [S-6]
    6780:	7000      	lod	A, #0
    6782:	52d6      	mov	[Y++], A
        *dst++ = 0;
    6784:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6786:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    6788:	72da 00c8 	lod	A, #200
    678c:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    6790:	62d8 00d6 	lod	AL, 0xd6 <_ml_driver_mode>
    6794:	8c55      	cmp	AL, #85
    6796:	1903      	je	0x679e <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    6798:	7000      	lod	A, #0
    679a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    679e:	7000      	lod	A, #0
    67a0:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    67a2:	72ee      	lod	A, X
    67a4:	80ff      	add	AL, #-1
    67a6:	5cf2      	usex	A
    67a8:	7ee2      	lod	X, A
    67aa:	1d6e      	jne	0x6788 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    67ac:	7a05      	lod	Y, [S-6]
    67ae:	e2da 0080 	add	Y, #128
    67b2:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    67b4:	7203      	lod	A, [S-4]
    67b6:	a0ff      	add	A, #-1
    67b8:	5203      	mov	[S-4], A
    67ba:	1d5e      	jne	0x6778 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    67bc:	7207      	lod	A, [S-8]
    67be:	44e2      	sfb	A
    67c0:	a6d8 036e 	or	A, 0x36e <_page_buffer+0x2>
    67c4:	52d8 036e 	mov	0x36e <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67c8:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    67ca:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67cc:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67ce:	b430      	and	A, #48
    67d0:	1902      	je	0x67d6 <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67d2:	6400      	lod	YL, #0
    67d4:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    67d6:	7000      	lod	A, #0
    67d8:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    67dc:	7ad8 036c 	lod	Y, 0x36c <_page_buffer>
    dst = (uint16_t *)addr;
    67e0:	7e09      	lod	X, [S-10]
    67e2:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    67e4:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    67e6:	7201      	lod	A, [S-2]
    67e8:	a2da 0080 	add	A, #128
    67ec:	eee2      	cmp	Y, A
    67ee:	187a      	jc	0x67e4 <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    67f0:	7818      	lod	Y, #24
    67f2:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    67f6:	62d8 00d6 	lod	AL, 0xd6 <_ml_driver_mode>
    67fa:	8c55      	cmp	AL, #85
    67fc:	1903      	je	0x6804 <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    67fe:	7000      	lod	A, #0
    6800:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    6804:	7a09      	lod	Y, [S-10]
    6806:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    6808:	7000      	lod	A, #0
    680a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    680e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6810:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6812:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6814:	b430      	and	A, #48
    6816:	1902      	je	0x681c <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6818:	6400      	lod	YL, #0
    681a:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    681c:	7209      	lod	A, [S-10]
    681e:	175c      	call	0x66d8 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    6820:	540b      	ret	#12

00006822 <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    6822:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    6824:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    6828:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    682a:	7ae8      	swap	Y
    682c:	f6da 00ff 	and	Y, #255
    6830:	4436      	lsr	Y
    6832:	7ee6      	lod	X, Y
    6834:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    6836:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    6838:	ac3f      	cmp	A, #63
    683a:	1b02      	jsle	0x6840 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    683c:	703f      	lod	A, #63
    683e:	0003      	jmp	0x6846 <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    6840:	ac00      	cmp	A, #0
    6842:	1e81      	jsge	0x6846 <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    6844:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    6846:	7ae2      	lod	Y, A
    6848:	f43f      	and	Y, #63
    684a:	f6da 00ff 	and	Y, #255
    684e:	7ae8      	swap	Y
    6850:	4426      	asl	Y
    6852:	7201      	lod	A, [S-2]
    6854:	b6da 81ff 	and	A, #33279
    6858:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    685a:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    685e:	4432      	lsr	A
    6860:	b6da 3f00 	and	A, #16128
    6864:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    6866:	72ee      	lod	A, X
    6868:	5403      	ret	#4

0000686a <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    686a:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    686c:	b480      	and	A, #-128
    686e:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    6870:	aeda be80 	cmp	A, #48768
    6874:	1907      	je	0x6884 <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    6876:	7201      	lod	A, [S-2]
    6878:	aeda bf00 	cmp	A, #48896
    687c:	1d05      	jne	0x6888 <_Flash_PageWriteFiltered+0x1e>
    687e:	16e3      	call	0x6646 <_LDR_GetState>
    6880:	8c03      	cmp	AL, #3
    6882:	1d02      	jne	0x6888 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    6884:	7000      	lod	A, #0
    6886:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    6888:	7201      	lod	A, [S-2]
    688a:	1737      	call	0x66fa <_Flash_PageWrite>
}
    688c:	5403      	ret	#4

0000688e <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    688e:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6890:	4cc2 45c0 	mov	D, #280000
    6894:	0004 
    6896:	4872 0006 	muls	A, A, #6
    689a:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    689c:	4c80      	mov	YA, D
    689e:	7e03      	lod	X, [S-4]
    68a0:	4c63      	divu	YA, X
    68a2:	4c63      	divu	YA, X
    68a4:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    68a6:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    68a8:	7000      	lod	A, #0
    68aa:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    68ac:	eeda 027a 	cmp	Y, #634
    68b0:	1e04      	jug	0x68ba <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    68b2:	80ff      	add	AL, #-1
    68b4:	b40f      	and	A, #15
    68b6:	5205      	mov	[S-6], A
            break;
    68b8:	0005      	jmp	0x68c4 <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    68ba:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    68bc:	8001      	add	AL, #1
    68be:	5cf2      	usex	A
    68c0:	8c02      	cmp	AL, #2
    68c2:	1a74      	jule	0x68ac <_ml_SetFastBaudRate+0x1e>
    68c4:	72e6      	lod	A, Y
    68c6:	a005      	add	A, #5
    68c8:	4cf2      	usex	YA
    68ca:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    68cc:	4c63      	divu	YA, X
    68ce:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    68d0:	8080      	add	AL, #-128
    68d2:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    68d4:	52df      	push	A
    68d6:	7207      	lod	A, [S-8]
    68d8:	82db 5b8e 	callf	0x5b8e <_ml_SetBaudRate>
    68dc:	5c01      	dec	S, #2
    68de:	5407      	ret	#8
    68e0:	b66d      	and	A, [S-110]
    68e2:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x5>
    68e4:	dbb6      	subc	AH, ep:0xb6 <__bss_dp_size+0x6>
    68e6:	b66d      	and	A, [S-110]
    68e8:	6ddb      	lod	YH, dp:0xdb <_ml_driver_mode+0x5>

000068ea <_RAM_Test>:
    68ea:	7ada 68e0 	lod	Y, #26848
    68ee:	4cc0      	mov	D, YA
    68f0:	7c00      	lod	X, #0
    68f2:	54c6      	movsw	[X++], [Y++]
    68f4:	54c6      	movsw	[X++], [Y++]
    68f6:	54c6      	movsw	[X++], [Y++]
    68f8:	7800      	lod	Y, #0
    68fa:	54c6      	movsw	[X++], [Y++]
    68fc:	2eda 07fe 	cmp	X, #2046
    6900:	1a7c      	jule	0x68fa <_RAM_Test+0x10>
    6902:	4c80      	mov	YA, D
    6904:	7c00      	lod	X, #0
    6906:	72de      	lod	A, [X++]
    6908:	aed6      	cmp	A, [Y++]
    690a:	1d0a      	jne	0x6920 <_RAM_Test+0x36>
    690c:	72de      	lod	A, [X++]
    690e:	aed6      	cmp	A, [Y++]
    6910:	1d07      	jne	0x6920 <_RAM_Test+0x36>
    6912:	72de      	lod	A, [X++]
    6914:	aed6      	cmp	A, [Y++]
    6916:	1d04      	jne	0x6920 <_RAM_Test+0x36>
    6918:	7800      	lod	Y, #0
    691a:	72de      	lod	A, [X++]
    691c:	aed6      	cmp	A, [Y++]
    691e:	1903      	je	0x6926 <_RAM_Test+0x3c>
    6920:	64f3      	lod	YL, #-13
    6922:	76da 568e 	jmpf	0x568e <__fatal>
    6926:	2eda 07fe 	cmp	X, #2046
    692a:	1a77      	jule	0x691a <_RAM_Test+0x30>
    692c:	4c80      	mov	YA, D
    692e:	e002      	add	Y, #2
    6930:	eeda 68e6 	cmp	Y, #26854
    6934:	1d5c      	jne	0x68ee <_RAM_Test+0x4>
    6936:	76da 55e8 	jmpf	0x55e8 <_start>

0000693a <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    693a:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    693c:	72d8 0370 	lod	A, 0x370 <__bss_end>
    6940:	aeda b598 	cmp	A, #46488
    6944:	1907      	je	0x6954 <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    6946:	72da b598 	lod	A, #46488
    694a:	52d8 0370 	mov	0x370 <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    694e:	7800      	lod	Y, #0
    6950:	5ad8 0372 	mov	0x372 <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if (   (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    6954:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6958:	aeda 3072 	cmp	A, #12402
    695c:	1d01      	jne	0x6960 <__low_level_init+0x26>
    695e:	0071      	jmp	0x6a42 <__low_level_init+0x108>
    6960:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6964:	aeda 3212 	cmp	A, #12818
    6968:	1d01      	jne	0x696c <__low_level_init+0x32>
    696a:	006b      	jmp	0x6a42 <__low_level_init+0x108>
    696c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6970:	aeda 5c92 	cmp	A, #23698
    6974:	1d01      	jne	0x6978 <__low_level_init+0x3e>
    6976:	0065      	jmp	0x6a42 <__low_level_init+0x108>
    6978:	7c0f      	lod	X, #15
    697a:	7ada 11c0 	lod	Y, #4544
    697e:	7000      	lod	A, #0
    6980:	08a7      	clrb	ML.7
    6982:	b2d6      	adc	A, [Y++]
    6984:	1bfe      	djnz	X, 0x6982 <__low_level_init+0x48>
    6986:	92e4      	adc	AL, AH
    6988:	9000      	adc	AL, #0
    698a:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    698c:	aeda 00ff 	cmp	A, #255
    6990:	1903      	je	0x6998 <__low_level_init+0x5e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    6992:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    6994:	76da 568e 	jmpf	0x568e <__fatal>
    6998:	7c0c      	lod	X, #12
    699a:	7ada 11de 	lod	Y, #4574
    699e:	7000      	lod	A, #0
    69a0:	08a7      	clrb	ML.7
    69a2:	b2d6      	adc	A, [Y++]
    69a4:	1bfe      	djnz	X, 0x69a2 <__low_level_init+0x68>
    69a6:	92e4      	adc	AL, AH
    69a8:	9000      	adc	AL, #0
    69aa:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    69ac:	aeda 00ff 	cmp	A, #255
    69b0:	1903      	je	0x69b8 <__low_level_init+0x7e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    69b2:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    69b4:	76da 568e 	jmpf	0x568e <__fatal>
    69b8:	7c05      	lod	X, #5
    69ba:	7ada 11f6 	lod	Y, #4598
    69be:	7000      	lod	A, #0
    69c0:	08a7      	clrb	ML.7
    69c2:	b2d6      	adc	A, [Y++]
    69c4:	1bfe      	djnz	X, 0x69c2 <__low_level_init+0x88>
    69c6:	92e4      	adc	AL, AH
    69c8:	9000      	adc	AL, #0
    69ca:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    69cc:	aeda 00ff 	cmp	A, #255
    69d0:	1903      	je	0x69d8 <__low_level_init+0x9e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    69d2:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    69d4:	76da 568e 	jmpf	0x568e <__fatal>
    69d8:	7ada 10fc 	lod	Y, #4348
    69dc:	7c02      	lod	X, #2
    69de:	7000      	lod	A, #0
    69e0:	08a7      	clrb	ML.7
    69e2:	b2d6      	adc	A, [Y++]
    69e4:	1bfe      	djnz	X, 0x69e2 <__low_level_init+0xa8>
    69e6:	92e4      	adc	AL, AH
    69e8:	9000      	adc	AL, #0
    69ea:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    69ec:	aeda 00ff 	cmp	A, #255
    69f0:	1d07      	jne	0x6a00 <__low_level_init+0xc6>
    69f2:	7eda 11f8 	lod	X, #4600
    69f6:	7ada 10fe 	lod	Y, #4350
    69fa:	72f0      	lod	A, [Y]
    69fc:	aef8      	cmp	A, [X]
    69fe:	1921      	je	0x6a42 <__low_level_init+0x108>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    6a00:	7000      	lod	A, #0
    6a02:	7eda 10fc 	lod	X, #4348
    6a06:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    6a08:	7eda 10fe 	lod	X, #4350
    6a0c:	7ada 11f8 	lod	Y, #4600
    6a10:	7af0      	lod	Y, [Y]
    6a12:	5af8      	mov	[X], Y
    6a14:	7ada 10fc 	lod	Y, #4348
    6a18:	7c02      	lod	X, #2
    6a1a:	7000      	lod	A, #0
    6a1c:	08a7      	clrb	ML.7
    6a1e:	b2d6      	adc	A, [Y++]
    6a20:	1bfe      	djnz	X, 0x6a1e <__low_level_init+0xe4>
    6a22:	92e4      	adc	AL, AH
    6a24:	9000      	adc	AL, #0
    6a26:	5cf2      	usex	A
    6a28:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    6a2a:	72da 00ff 	lod	A, #255
    6a2e:	aa05      	sub	A, [S-6]
    6a30:	7ada 10fc 	lod	Y, #4348
    6a34:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    6a36:	7001      	lod	A, #1
    6a38:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    6a3c:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    6a3e:	76da 568e 	jmpf	0x568e <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    6a42:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a46:	8408      	or	AL, #8
    6a48:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    6a4c:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    6a50:	b6da ff7f 	and	A, #65407
    6a54:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    6a58:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a5c:	94f7      	and	AL, #-9
    6a5e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    6a62:	7c04      	lod	X, #4
    6a64:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    6a68:	72da 7c50 	lod	A, #31824
    6a6c:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    6a70:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a74:	94fe      	and	AL, #-2
    6a76:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    6a7a:	0000      	nop
    NOP();
    6a7c:	0000      	nop
    NOP();
    6a7e:	0000      	nop
    MLX4_START();
    6a80:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a84:	8401      	or	AL, #1
    6a86:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    6a8a:	540f      	ret	#16

00006a8c <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    6a8c:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    6a8e:	72ef      	lod	A, S
    6a90:	a080      	add	A, #-128
    6a92:	52d8 036c 	mov	0x36c <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    6a96:	15d7      	call	0x6646 <_LDR_GetState>
    6a98:	8c00      	cmp	AL, #0
    6a9a:	1d06      	jne	0x6aa8 <__premain+0x1c>
    6a9c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6aa0:	aeda 3212 	cmp	A, #12818
    6aa4:	1901      	je	0x6aa8 <__premain+0x1c>
    6aa6:	003b      	jmp	0x6b1e <__premain+0x92>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
	    if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    6aa8:	72d8 0010 	lod	A, 0x10 <__dp_noinit_size>
    6aac:	7ad8 0012 	lod	Y, 0x12 <__dp_noinit_size+0x2>
    6ab0:	4cb2 72ef 	cmp	YA, #-396266769
    6ab4:	e861 
    6ab6:	1913      	je	0x6ade <__premain+0x52>
		{
			uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76);					/* Get NAD from Flash at STACK_IT Segment */
    6ab8:	7ada bf76 	lod	Y, #49014
    6abc:	72f0      	lod	A, [Y]
    6abe:	5cf2      	usex	A
			if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    6ac0:	8c00      	cmp	AL, #0
    6ac2:	1a82      	jsl	0x6ac8 <__premain+0x3c>
    6ac4:	ac00      	cmp	A, #0
    6ac6:	1d01      	jne	0x6aca <__premain+0x3e>
			{
				u8NAD = 0x7F;													/* Invalid NAD; Use default NAD */
    6ac8:	707f      	lod	A, #127
			}
			stFixedRamNAD.nad = u8NAD;
    6aca:	42d8 0014 	mov	0x14 <__dp_noinit_size+0x4>, AL
			stFixedRamNAD.key = _mlx_NAD_Security_Key;
    6ace:	72da 72ef 	lod	A, #29423
    6ad2:	52d8 0010 	mov	0x10 <__dp_noinit_size>, A
    6ad6:	72da e861 	lod	A, #59489
    6ada:	52d8 0012 	mov	0x12 <__dp_noinit_size+0x2>, A
		}
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    6ade:	54f7      	mov	UPr, #7

        ml_LinInit();
    6ae0:	106e      	call	0x6bbe <_ml_LinInit>
        (void)ml_Connect();
    6ae2:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    6ae6:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6aea:	aeda 3212 	cmp	A, #12818
    6aee:	1d07      	jne	0x6afe <__premain+0x72>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    6af0:	7000      	lod	A, #0
    6af2:	82db 60c4 	callf	0x60c4 <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    6af6:	72da 5c92 	lod	A, #23698
    6afa:	52d8 0372 	mov	0x372 <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6afe:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6b00:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b02:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b04:	b430      	and	A, #48
    6b06:	1902      	je	0x6b0c <__premain+0x80>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b08:	6000      	lod	AL, #0
    6b0a:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    6b0c:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b10:	b410      	and	A, #16
    6b12:	1975      	je	0x6afe <__premain+0x72>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    6b14:	82db 5bbe 	callf	0x5bbe <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    6b18:	82db 5bee 	callf	0x5bee <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    6b1c:	07f0      	jmp	0x6afe <__premain+0x72>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    6b1e:	54f7      	mov	UPr, #7
    6b20:	5c7f      	dec	S, #128
    6b22:	5401      	ret

00006b24 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    6b24:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    6b26:	7003      	lod	A, #3
    6b28:	5205      	mov	[S-6], A
    6b2a:	70ff      	lod	A, #-1
    6b2c:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    6b2e:	7000      	lod	A, #0
    6b30:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    6b32:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b34:	b401      	and	A, #1
    6b36:	1917      	je	0x6b66 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b38:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6b3a:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b3c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b3e:	b430      	and	A, #48
    6b40:	1902      	je	0x6b46 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b42:	6000      	lod	AL, #0
    6b44:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    6b46:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b48:	b4fb      	and	A, #-5
    6b4a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b4c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b4e:	b401      	and	A, #1
    6b50:	190a      	je	0x6b66 <_mlx_isPowerOk+0x42>
    6b52:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    6b54:	7eda 15e0 	lod	X, #5600
    6b58:	1bff      	djnz	X, 0x6b58 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b5a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b5c:	b401      	and	A, #1
    6b5e:	1903      	je	0x6b66 <_mlx_isPowerOk+0x42>
    6b60:	e0ff      	add	Y, #-1
    6b62:	ecff      	cmp	Y, #-1
    6b64:	1d77      	jne	0x6b54 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    6b66:	7000      	lod	A, #0
    6b68:	5290      	mov	io:0x10 <__dp_noinit_size>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    6b6a:	72ef      	lod	A, S
    6b6c:	a0fe      	add	A, #-2
    6b6e:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
    6b70:	72ef      	lod	A, S
    6b72:	a0fa      	add	A, #-6
    6b74:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
    6b76:	72da 0080 	lod	A, #128
    6b7a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    6b7c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b7e:	a401      	or	A, #1
    6b80:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    DELAY(500);                     /* some delay for sample and hold */
    6b82:	7eda 01f4 	lod	X, #500
    6b86:	1bff      	djnz	X, 0x6b86 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    6b88:	7040      	lod	A, #64
    6b8a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    6b8e:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    6b90:	a6da 0100 	or	A, #256
    6b94:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    6b96:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b9a:	b440      	and	A, #64
    6b9c:	1d08      	jne	0x6bae <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b9e:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    6ba0:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6ba2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6ba4:	b430      	and	A, #48
    6ba6:	1977      	je	0x6b96 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6ba8:	6000      	lod	AL, #0
    6baa:	4282      	mov	io:0x2 <_LinCmnd>, AL
    6bac:	07f4      	jmp	0x6b96 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    6bae:	7201      	lod	A, [S-2]
    6bb0:	aeda 0158 	cmp	A, #344
    6bb4:	1e02      	jug	0x6bba <_mlx_isPowerOk+0x96>
        return false;
    6bb6:	7000      	lod	A, #0
    6bb8:	5407      	ret	#8
    }
    else {
        return true;
    6bba:	7001      	lod	A, #1
    }
}
    6bbc:	5407      	ret	#8

00006bbe <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    6bbe:	82db 5e0c 	callf	0x5e0c <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6bc2:	54ca 0000 	pushw	#0
    6bc6:	54ca 0001 	pushw	#1
    6bca:	54ca 0000 	pushw	#0
    6bce:	7001      	lod	A, #1
    6bd0:	82db 5ae0 	callf	0x5ae0 <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    6bd4:	7000      	lod	A, #0
    6bd6:	82db 5ad8 	callf	0x5ad8 <_ml_SetSlewRate>
    6bda:	5c05      	dec	S, #6
    6bdc:	5401      	ret
    6bde:	0000      	nop
    6be0:	5c3e      	dec	S, #63
    6be2:	5c5a      	dec	S, #91
    6be4:	5cb2      	ssg	A
    6be6:	5ce2      	ssex	A
    6be8:	5cf6      	usex	Y
    6bea:	0000      	nop
    6bec:	0001      	jmp	0x6bf0 <_muldivI16_I16byI16byI16+0x2>

00006bee <_muldivI16_I16byI16byI16>:
    6bee:	7a03      	lod	Y, [S-4]
    6bf0:	4831      	muls	YA, A, Y
    6bf2:	7e05      	lod	X, [S-6]
    6bf4:	4c73      	divs	YA, X
    6bf6:	4c73      	divs	YA, X
    6bf8:	4c7b      	dadjs	YA, X
    6bfa:	5401      	ret

00006bfc <_muldivU16_U16byU16byU16>:
    6bfc:	7a03      	lod	Y, [S-4]
    6bfe:	4821      	mulu	YA, A, Y
    6c00:	7e05      	lod	X, [S-6]
    6c02:	4c63      	divu	YA, X
    6c04:	4c63      	divu	YA, X
    6c06:	5401      	ret

00006c08 <_divI32_I32byI16>:
    6c08:	7e03      	lod	X, [S-4]
    6c0a:	1d87      	jnn	0x6c1a <_divI32_I32byU16+0x2>
    6c0c:	5cce      	neg	X
    6c0e:	5e03      	mov	[S-4], X
    6c10:	e000      	add	Y, #0
    6c12:	1d86      	jnn	0x6c20 <_divI32_I32byU16+0x8>
    6c14:	4cf0      	neg	YA
    6c16:	0011      	jmp	0x6c3a <_divU32_U32byU16>

00006c18 <_divI32_I32byU16>:
    6c18:	7e03      	lod	X, [S-4]
    6c1a:	e000      	add	Y, #0
    6c1c:	1d8e      	jnn	0x6c3a <_divU32_U32byU16>
    6c1e:	4cf0      	neg	YA
    6c20:	4ca3      	push	YA
    6c22:	72e6      	lod	A, Y
    6c24:	7800      	lod	Y, #0
    6c26:	7e07      	lod	X, [S-8]
    6c28:	4c63      	divu	YA, X
    6c2a:	4c63      	divu	YA, X
    6c2c:	5201      	mov	[S-2], A
    6c2e:	7203      	lod	A, [S-4]
    6c30:	4c63      	divu	YA, X
    6c32:	4c63      	divu	YA, X
    6c34:	7a01      	lod	Y, [S-2]
    6c36:	4cf0      	neg	YA
    6c38:	5405      	ret	#6

00006c3a <_divU32_U32byU16>:
    6c3a:	4ca3      	push	YA
    6c3c:	72e6      	lod	A, Y
    6c3e:	7800      	lod	Y, #0
    6c40:	7e07      	lod	X, [S-8]
    6c42:	4c63      	divu	YA, X
    6c44:	4c63      	divu	YA, X
    6c46:	5201      	mov	[S-2], A
    6c48:	7203      	lod	A, [S-4]
    6c4a:	4c63      	divu	YA, X
    6c4c:	4c63      	divu	YA, X
    6c4e:	7a01      	lod	Y, [S-2]
    6c50:	5405      	ret	#6

00006c52 <_mulI32_I16byU16>:
    6c52:	a000      	add	A, #0
    6c54:	1d85      	jnn	0x6c60 <_mulU32_U16byU16>
    6c56:	5cc2      	neg	A
    6c58:	7a03      	lod	Y, [S-4]
    6c5a:	4821      	mulu	YA, A, Y
    6c5c:	4cf0      	neg	YA
    6c5e:	5401      	ret

00006c60 <_mulU32_U16byU16>:
    6c60:	7a03      	lod	Y, [S-4]
    6c62:	4821      	mulu	YA, A, Y
    6c64:	5401      	ret

00006c66 <___mulsi3>:
    6c66:	5edf      	push	X
    6c68:	7eef      	lod	X, S
    6c6a:	2808      	sub	X, #8
    6c6c:	1002      	call	0x6c72 <___mulsi3_1>
    6c6e:	7ecf      	pop	X
    6c70:	5401      	ret

00006c72 <___mulsi3_1>:
    6c72:	4c83      	push	D
    6c74:	4cf3      	swap	YA
    6c76:	4806      	mulu	D, A, [X++]
    6c78:	4cf3      	swap	YA
    6c7a:	4847      	macu	D, A, [X]
    6c7c:	2802      	sub	X, #2
    6c7e:	48cf      	asl	D, #16
    6c80:	4847      	macu	D, A, [X]
    6c82:	4c80      	mov	YA, D
    6c84:	4cc3      	pop	D
    6c86:	5401      	ret

00006c88 <___mulsi3_D>:
    6c88:	5edf      	push	X
    6c8a:	7eef      	lod	X, S
    6c8c:	2002      	add	X, #2
    6c8e:	17f1      	call	0x6c72 <___mulsi3_1>
    6c90:	7ecf      	pop	X
    6c92:	5401      	ret

00006c94 <___udivsi3>:
    6c94:	7c00      	lod	X, #0
    6c96:	0002      	jmp	0x6c9c <___udivmodsi4>

00006c98 <___umodsi3>:
    6c98:	7c01      	lod	X, #1
    6c9a:	0000      	nop

00006c9c <___udivmodsi4>:
    6c9c:	5edf      	push	X
    6c9e:	2c00      	cmp	X, #0
    6ca0:	1d06      	jne	0x6cae <___udivmodsi4+0x12>
    6ca2:	7e05      	lod	X, [S-6]
    6ca4:	1d05      	jne	0x6cb0 <___udivmodsi4+0x14>
    6ca6:	7e07      	lod	X, [S-8]
    6ca8:	5e01      	mov	[S-2], X
    6caa:	1024      	call	0x6cf4 <__divU32_U32byU16>
    6cac:	5403      	ret	#4
    6cae:	7e05      	lod	X, [S-6]
    6cb0:	2607      	or	X, [S-8]
    6cb2:	1d03      	jne	0x6cba <___udivmodsi4+0x1e>
    6cb4:	4cfa ffff 	movs	YA, #65535
    6cb8:	5403      	ret	#4
    6cba:	4cc0      	mov	D, YA
    6cbc:	7eef      	lod	X, S
    6cbe:	2808      	sub	X, #8
    6cc0:	4cea 0000 	movu	YA, #0
    6cc4:	54e0      	mov	Cx, #0
    6cc6:	48c0      	asl	D, #1
    6cc8:	4402      	rlc	A
    6cca:	4406      	rlc	Y
    6ccc:	1802      	jc	0x6cd2 <___udivmodsi4+0x36>
    6cce:	4cb7      	cmp	YA, [X]
    6cd0:	1803      	jc	0x6cd8 <___udivmodsi4+0x3c>
    6cd2:	4c37      	sub	YA, [X]
    6cd4:	4c0a 0001 	addu	D, #1
    6cd8:	48c0      	asl	D, #1
    6cda:	4402      	rlc	A
    6cdc:	4406      	rlc	Y
    6cde:	1802      	jc	0x6ce4 <___udivmodsi4+0x48>
    6ce0:	4cb7      	cmp	YA, [X]
    6ce2:	1803      	jc	0x6cea <___udivmodsi4+0x4e>
    6ce4:	4c37      	sub	YA, [X]
    6ce6:	4c0a 0001 	addu	D, #1
    6cea:	1fed      	djnz	Cx, 0x6cc6 <___udivmodsi4+0x2a>
    6cec:	7ecf      	pop	X
    6cee:	1d01      	jne	0x6cf2 <___udivmodsi4+0x56>
    6cf0:	4c80      	mov	YA, D
    6cf2:	5401      	ret

00006cf4 <__divU32_U32byU16>:
    6cf4:	5edf      	push	X
    6cf6:	4ca3      	push	YA
    6cf8:	72e6      	lod	A, Y
    6cfa:	7800      	lod	Y, #0
    6cfc:	7e09      	lod	X, [S-10]
    6cfe:	4c63      	divu	YA, X
    6d00:	4c63      	divu	YA, X
    6d02:	5201      	mov	[S-2], A
    6d04:	7203      	lod	A, [S-4]
    6d06:	4c63      	divu	YA, X
    6d08:	4c63      	divu	YA, X
    6d0a:	7a01      	lod	Y, [S-2]
    6d0c:	7e05      	lod	X, [S-6]
    6d0e:	5407      	ret	#8

00006d10 <_RamBackgroundTest>:
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;
	else
		pu16Page = (uint16 *) C_ADDR_USERPAGE1;
#else  /* (LINPROT == LIN2J_VALVE_GM) */
	if ( u16Page == 0 )
    6d10:	ac00      	cmp	A, #0
    6d12:	1d03      	jne	0x6d1a <_RamBackgroundTest+0xa>
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE1;									/* Compare NVRAM User-page #1 against RAM */
    6d14:	72da 1000 	lod	A, #4096
    6d18:	0002      	jmp	0x6d1e <_RamBackgroundTest+0xe>
	}
	else 
	{
		pu16Page = (uint16 *) C_ADDR_USERPAGE2;									/* Compare NVRAM User-page #2 against RAM */
    6d1a:	72da 1100 	lod	A, #4352
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */

	return ( NVRAM_PageVerify( pu16Page) );
    6d1e:	82db a0b0 	callf	0xa0b0 <_NVRAM_PageVerify>

} /* End of RamBackgroundTest() */
    6d22:	5401      	ret

00006d24 <_FlashBackgroundTest>:
#define C_FLASH_CRC_FAILED			0
#define C_FLASH_CRC_OK				1
#define C_FLASH_CRC_CALCULATING		2

uint16 FlashBackgroundTest( uint16 u16Size)
{
    6d24:	5807      	inc	S, #8
    6d26:	7ee2      	lod	X, A
	uint16 u16Result = C_FLASH_CRC_CALCULATING;
    6d28:	4cd3      	swap	D
    6d2a:	48cf      	asl	D, #16
    6d2c:	4c0a 0002 	addu	D, #2
	static uint16 *pu16Segment = (uint16 *) FLASH_START_ADDR;
	static uint16 u16FlashCRC = 0;

	if ( u16Size == 0U )
    6d30:	ac00      	cmp	A, #0
    6d32:	1d06      	jne	0x6d40 <_FlashBackgroundTest+0x1c>
	{
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6d34:	72da 4000 	lod	A, #16384
    6d38:	52d8 0116 	mov	0x116 <_g_i16SupplyVoltage+0x2>, A
		return ( u16Result );
    6d3c:	7002      	lod	A, #2
    6d3e:	5409      	ret	#10
	}
	if ( pu16Segment == (uint16 *) FLASH_START_ADDR )
    6d40:	7ad8 0116 	lod	Y, 0x116 <_g_i16SupplyVoltage+0x2>
    6d44:	eeda 4000 	cmp	Y, #16384
    6d48:	1d03      	jne	0x6d50 <_FlashBackgroundTest+0x2c>
	{
		u16FlashCRC = 0xFFFF;													/* Initialise the CRC preset with 0xFFFF */
    6d4a:	70ff      	lod	A, #-1
    6d4c:	52d8 0118 	mov	0x118 <_g_i16SupplyVoltage+0x4>, A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
    6d50:	72e6      	lod	A, Y
    6d52:	a2ee      	add	A, X
    6d54:	aeda c000 	cmp	A, #49152
    6d58:	1a04      	jule	0x6d62 <_FlashBackgroundTest+0x3e>
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
    6d5a:	72da c000 	lod	A, #49152
    6d5e:	7ee2      	lod	X, A
    6d60:	2ae6      	sub	X, Y
	}
	for ( ; u16Size > 0; u16Size-- )
    6d62:	2c00      	cmp	X, #0
    6d64:	192b      	je	0x6dbc <_FlashBackgroundTest+0x98>
    6d66:	5a03      	mov	[S-4], Y
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
    6d68:	7a03      	lod	Y, [S-4]
    6d6a:	eeda bf4e 	cmp	Y, #48974
    6d6e:	1920      	je	0x6db0 <_FlashBackgroundTest+0x8c>
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
    6d70:	72f0      	lod	A, [Y]
    6d72:	5205      	mov	[S-6], A
			for ( u8Count = 16; u8Count > 0; u8Count-- )
    6d74:	7810      	lod	Y, #16
    6d76:	5a07      	mov	[S-8], Y
    6d78:	7ad8 0118 	lod	Y, 0x118 <_g_i16SupplyVoltage+0x4>
			{
				uint16 u16XorFlag = !!(u16FlashCRC & 0x8000);
    6d7c:	72e6      	lod	A, Y
    6d7e:	b6da 8000 	and	A, #32768
    6d82:	5201      	mov	[S-2], A
    6d84:	1902      	je	0x6d8a <_FlashBackgroundTest+0x66>
    6d86:	7001      	lod	A, #1
    6d88:	5201      	mov	[S-2], A
				u16FlashCRC = (u16FlashCRC << 1);
    6d8a:	4426      	asl	Y
				if ( u16Data & 0x8000 )
    6d8c:	7205      	lod	A, [S-6]
    6d8e:	ac00      	cmp	A, #0
    6d90:	1e81      	jsge	0x6d94 <_FlashBackgroundTest+0x70>
				{
					u16FlashCRC++;
    6d92:	e001      	add	Y, #1
				}
				if ( u16XorFlag )
    6d94:	7201      	lod	A, [S-2]
    6d96:	1902      	je	0x6d9c <_FlashBackgroundTest+0x78>
				{
					u16FlashCRC ^= POLY;
    6d98:	feda 1021 	xor	Y, #4129
				}
				u16Data <<= 1;
    6d9c:	7205      	lod	A, [S-6]
    6d9e:	4422      	asl	A
    6da0:	5205      	mov	[S-6], A
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
			for ( u8Count = 16; u8Count > 0; u8Count-- )
    6da2:	6207      	lod	AL, [S-8]
    6da4:	80ff      	add	AL, #-1
    6da6:	5cf2      	usex	A
    6da8:	5207      	mov	[S-8], A
    6daa:	1d68      	jne	0x6d7c <_FlashBackgroundTest+0x58>
    6dac:	5ad8 0118 	mov	0x118 <_g_i16SupplyVoltage+0x4>, Y
					u16FlashCRC ^= POLY;
				}
				u16Data <<= 1;
			}
		}
		pu16Segment++;
    6db0:	7203      	lod	A, [S-4]
    6db2:	a002      	add	A, #2
    6db4:	5203      	mov	[S-4], A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
	}
	for ( ; u16Size > 0; u16Size-- )
    6db6:	1bd8      	djnz	X, 0x6d68 <_FlashBackgroundTest+0x44>
    6db8:	52d8 0116 	mov	0x116 <_g_i16SupplyVoltage+0x2>, A
			}
		}
		pu16Segment++;
	}

	if ( (uint16) pu16Segment >= FLASH_END_ADDR )
    6dbc:	72d8 0116 	lod	A, 0x116 <_g_i16SupplyVoltage+0x2>
    6dc0:	aeda bfff 	cmp	A, #49151
    6dc4:	1a14      	jule	0x6dee <_FlashBackgroundTest+0xca>
	{
		/* CRC fully calculated, check values */
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    6dc6:	7ada 4000 	lod	Y, #16384
    6dca:	5ad8 0116 	mov	0x116 <_g_i16SupplyVoltage+0x2>, Y
		if ( *(uint16 *) FLASH_CRC_ADDR != 0 )									/* Flash/ROM Checksum programmed? */
    6dce:	7ada bf4e 	lod	Y, #48974
    6dd2:	72f0      	lod	A, [Y]
    6dd4:	190c      	je	0x6dee <_FlashBackgroundTest+0xca>
		{
			if ( *(uint16 *) FLASH_CRC_ADDR != u16FlashCRC )
    6dd6:	aed8 0118 	cmp	A, 0x118 <_g_i16SupplyVoltage+0x4>
    6dda:	1905      	je	0x6de6 <_FlashBackgroundTest+0xc2>
			{
				u16Result = C_FLASH_CRC_FAILED;
    6ddc:	4cd3      	swap	D
    6dde:	48cf      	asl	D, #16
    6de0:	4c0a 0000 	addu	D, #0
    6de4:	0004      	jmp	0x6dee <_FlashBackgroundTest+0xca>
			}
			else
			{
				u16Result = C_FLASH_CRC_OK;
    6de6:	4cd3      	swap	D
    6de8:	48cf      	asl	D, #16
    6dea:	4c0a 0001 	addu	D, #1
			}
		}
	}

	return ( u16Result );
    6dee:	4c88      	mov	A, DL

} /* End of FlashBackgroundTest() */
    6df0:	5409      	ret	#10

00006df2 <_noinit_section_init>:
 * noinit_section_init
 * MMP151118-2 *
 * ****************************************************************************	*/
void noinit_section_init(void)
{
	g_e8MotorCtrlMode = (uint8) C_MOTOR_CTRL_STOP;
    6df2:	6000      	lod	AL, #0
    6df4:	41ea      	mov	dp:0xea <__bss_dp_end>, AL
	//g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;								/* Control-flag Stall-detector enabled [WD] */;
	g_u8MotorHoldingCurrEna = FALSE;
    6df6:	41ed      	mov	dp:0xed <_g_u8MotorHoldingCurrEna>, AL
	g_u16ActualPosition = 32767U;
    6df8:	72da 7fff 	lod	A, #32767
    6dfc:	51ee      	mov	dp:0xee <_g_u16ActualPosition>, A
	g_u16TargetPosition = 65535U;
    6dfe:	70ff      	lod	A, #-1
    6e00:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
	g_u8MotorCtrlSpeed = (uint8) C_DEFAULT_MOTOR_SPEED;
    6e02:	6003      	lod	AL, #3
    6e04:	41f2      	mov	dp:0xf2 <_g_u8MotorCtrlSpeed>, AL
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    6e06:	6000      	lod	AL, #0
    6e08:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
	g_u16CalibTravel = C_EXV_DEF_TRAVEL;									/* Number of steps between two end-stops */
    6e0a:	658c      	lod	YL, dp:0x8c <__data_size+0x2a>
    6e0c:	44b6      	lsr	Y, #2
    6e0e:	44b6      	lsr	Y, #2
    6e10:	4436      	lsr	Y
    6e12:	f403      	and	Y, #3
    6e14:	716a      	lod	A, dp:0x6a <__data_size+0x8>
    6e16:	ec00      	cmp	Y, #0
    6e18:	1b03      	jsle	0x6e20 <_noinit_section_init+0x2e>
    6e1a:	46e9      	mov	Cx, YL
    6e1c:	4422      	asl	A
    6e1e:	1ffe      	djnz	Cx, 0x6e1c <_noinit_section_init+0x2a>
    6e20:	51f4      	mov	dp:0xf4 <_g_u16CalibTravel>, A

	/* MotorDriver.c variables */
	g_u16ActuatorActPos = 0;
    6e22:	7000      	lod	A, #0
    6e24:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = 0;
    6e26:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
    6e28:	5401      	ret

00006e2a <_RteExv2Lin>:
} /* End of noinit_section_init() */

void RteExv2Lin(void)
{
    6e2a:	580b      	inc	S, #12

//	g_e8CalibrationStep = (uint8)C_CALIB_DONE;

//	g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;

	if (g_e8CalibrationStep == (uint8)C_CALIB_NONE)
    6e2c:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    6e2e:	1903      	je	0x6e36 <_RteExv2Lin+0xc>
	{
		g_e8EXVStatusInitStat = C_STATUS_NOT_INIT;
	}
	else if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6e30:	8c0a      	cmp	AL, #10
    6e32:	1904      	je	0x6e3c <_RteExv2Lin+0x12>
		g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;

	}
	else
	{
		g_e8EXVStatusInitStat = C_STATUS_INIT_BUSY;
    6e34:	6001      	lod	AL, #1
    6e36:	42d8 00fb 	mov	0xfb <_g_e8EXVStatusInitStat>, AL
	}

	if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6e3a:	0009      	jmp	0x6e4e <_RteExv2Lin+0x24>
	{
		g_e8EXVStatusInitStat = C_STATUS_NOT_INIT;
	}
	else if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
	{
		g_e8EXVStatusInitStat = C_STATUS_INIT_DONE;
    6e3c:	6002      	lod	AL, #2
    6e3e:	42d8 00fb 	mov	0xfb <_g_e8EXVStatusInitStat>, AL
		g_e8EXVStatusInitStat = C_STATUS_INIT_BUSY;
	}

	if(g_e8CalibrationStep == (uint8)C_CALIB_DONE)
	{
		if(g_u8StallOcc == TRUE)
    6e42:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    6e44:	8c01      	cmp	AL, #1
    6e46:	1d03      	jne	0x6e4e <_RteExv2Lin+0x24>
		{
			g_e8EXVErrorBlock = TRUE;
    6e48:	4118      	mov	dp:0x18 <__data_dp_start>, AL
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban,
    6e4a:	6002      	lod	AL, #2
    6e4c:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
		}
	}

	//TODO need to add the indetermint, ban debug
	if(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_OVER)
    6e4e:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    6e50:	8c02      	cmp	AL, #2
    6e52:	1d02      	jne	0x6e58 <_RteExv2Lin+0x2e>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_VOLTAGE;
    6e54:	6001      	lod	AL, #1
    6e56:	0020      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_UNDER)
    6e58:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    6e5a:	8c01      	cmp	AL, #1
    6e5c:	1d02      	jne	0x6e62 <_RteExv2Lin+0x38>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_UNDER_VLOTAGE;
    6e5e:	6002      	lod	AL, #2
    6e60:	001b      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if((g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_A) || (g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_B))
    6e62:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e64:	8cea      	cmp	AL, #-22
    6e66:	1903      	je	0x6e6e <_RteExv2Lin+0x44>
    6e68:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e6a:	8ceb      	cmp	AL, #-21
    6e6c:	1d02      	jne	0x6e72 <_RteExv2Lin+0x48>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_COIL_SHORT;
    6e6e:	6003      	lod	AL, #3
    6e70:	0013      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorCoil == (uint8) C_ERR_SELFTEST_C)
    6e72:	612c      	lod	AL, dp:0x2c <_g_e8ErrorCoil>
    6e74:	8cec      	cmp	AL, #-20
    6e76:	1d02      	jne	0x6e7c <_RteExv2Lin+0x52>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_COIL_OPEN;
    6e78:	6004      	lod	AL, #4
    6e7a:	000e      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if(g_e8ErrorOverTemperature == (uint8)C_ERR_OTEMP_YES)
    6e7c:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    6e7e:	8c01      	cmp	AL, #1
    6e80:	1d02      	jne	0x6e86 <_RteExv2Lin+0x5c>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_TEMP_SHUTDOWN;
    6e82:	6005      	lod	AL, #5
    6e84:	0009      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if(g_e8EXVErrorBlock == TRUE)
    6e86:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    6e88:	8c01      	cmp	AL, #1
    6e8a:	1d02      	jne	0x6e90 <_RteExv2Lin+0x66>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_UNEXPECT_STALL;
    6e8c:	6006      	lod	AL, #6
    6e8e:	0004      	jmp	0x6e98 <_RteExv2Lin+0x6e>
	}
	else if(g_e8WarningOverTemperature == C_WARNING_OTEMP_YES)
    6e90:	611a      	lod	AL, dp:0x1a <_g_e8WarningOverTemperature>
    6e92:	8c01      	cmp	AL, #1
    6e94:	1d04      	jne	0x6e9e <_RteExv2Lin+0x74>
	{
		g_e8EXVStatusFaultState = C_STATUS_FAULT_OVER_TEMP_WARNING;
    6e96:	600a      	lod	AL, #10
    6e98:	42d8 00ff 	mov	0xff <_g_e8EXVStatusFaultState>, AL
    6e9c:	0003      	jmp	0x6ea4 <_RteExv2Lin+0x7a>
	}
	else
	{
		g_e8EXVStatusFaultState = C_STATUS_NO_FAULT;
    6e9e:	6400      	lod	YL, #0
    6ea0:	46d8 00ff 	mov	0xff <_g_e8EXVStatusFaultState>, YL
	}

	//if(((g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM) && (g_e8EXVStatusFaultState != C_STATUS_NO_FAULT)) || ((g_e8CalibrationStep > C_CALIB_NONE) && (g_e8CalibrationStep < C_CALIB_DONE) && ((g_e8ErrorVoltage != C_ERR_VOLTAGE_IN_RANGE) || (g_e8ErrorOverTemperature == (uint8)C_ERR_OTEMP_YES))))//coil open/short/over temp/stall,ov/uv, changed to un-initialized
	if((g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM) && (g_e8EXVStatusFaultState != C_STATUS_NO_FAULT))//coil open/short/stall, changed to un-initialized
    6ea4:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    6ea6:	8c02      	cmp	AL, #2
    6ea8:	1d0d      	jne	0x6ec4 <_RteExv2Lin+0x9a>
    6eaa:	62d8 00ff 	lod	AL, 0xff <_g_e8EXVStatusFaultState>
    6eae:	190a      	je	0x6ec4 <_RteExv2Lin+0x9a>
	{
		g_e8CalibrationStep = C_CALIB_NONE;
    6eb0:	6000      	lod	AL, #0
    6eb2:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
		g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    6eb4:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    6eb6:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
		g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    6eb8:	42d8 0104 	mov	0x104 <_g_e8CalibPostMotorRequest>, AL
		g_u16TargetPosition = g_u16ActualPosition;
    6ebc:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    6ebe:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
		g_u16ActuatorActPos = g_u16ActualPosition;
    6ec0:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
		g_u16ActuatorTgtPos = g_u16TargetPosition;
    6ec2:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
	}

	if((g_e8EXVStatusInitStat == (uint8)C_STATUS_INIT_BUSY) || (g_e8EXVStatusInitStat == (uint8)C_STATUS_INIT_DONE))
    6ec4:	62d8 00fb 	lod	AL, 0xfb <_g_e8EXVStatusInitStat>
    6ec8:	420b      	mov	[S-12], AL
    6eca:	80ff      	add	AL, #-1
    6ecc:	8c01      	cmp	AL, #1
    6ece:	1a01      	jule	0x6ed2 <_RteExv2Lin+0xa8>
    6ed0:	003c      	jmp	0x6f4a <_RteExv2Lin+0x120>
	{
		if(g_u16ActualPosition <= C_EXV_ZERO_POS)
    6ed2:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    6ed4:	44b2      	lsr	A, #2
    6ed6:	44b2      	lsr	A, #2
    6ed8:	4432      	lsr	A
    6eda:	b403      	and	A, #3
    6edc:	5207      	mov	[S-8], A
    6ede:	7c64      	lod	X, #100
    6ee0:	ac00      	cmp	A, #0
    6ee2:	1b03      	jsle	0x6eea <_RteExv2Lin+0xc0>
    6ee4:	42e9      	mov	Cx, AL
    6ee6:	442e      	asl	X
    6ee8:	1ffe      	djnz	Cx, 0x6ee6 <_RteExv2Lin+0xbc>
    6eea:	79ee      	lod	Y, dp:0xee <_g_u16ActualPosition>
    6eec:	5a01      	mov	[S-2], Y
    6eee:	eeee      	cmp	Y, X
    6ef0:	1e02      	jug	0x6ef6 <_RteExv2Lin+0xcc>
		{
			g_u16EXVStatusCurrentPositon = 0;
    6ef2:	7000      	lod	A, #0
    6ef4:	0010      	jmp	0x6f16 <_RteExv2Lin+0xec>
		}
		else if(g_u16ActualPosition >= C_EXV_POSITION_STD + C_EXV_ZERO_POS)
    6ef6:	7ada 0120 	lod	Y, #288
    6efa:	7207      	lod	A, [S-8]
    6efc:	ac00      	cmp	A, #0
    6efe:	1b03      	jsle	0x6f06 <_RteExv2Lin+0xdc>
    6f00:	42e9      	mov	Cx, AL
    6f02:	4426      	asl	Y
    6f04:	1ffe      	djnz	Cx, 0x6f02 <_RteExv2Lin+0xd8>
    6f06:	5a09      	mov	[S-10], Y
    6f08:	72e6      	lod	A, Y
    6f0a:	a2ee      	add	A, X
    6f0c:	7a01      	lod	Y, [S-2]
    6f0e:	eee2      	cmp	Y, A
    6f10:	1805      	jc	0x6f1c <_RteExv2Lin+0xf2>
		{
			g_u16EXVStatusCurrentPositon = 0x3FF;
    6f12:	72da 03ff 	lod	A, #1023
    6f16:	52d8 00fc 	mov	0xfc <_g_u16EXVStatusCurrentPositon>, A
    6f1a:	540d      	ret	#14
		}
		else
		{
			g_u16EXVStatusCurrentPositon = ((uint32)(g_u16ActualPosition - C_EXV_ZERO_POS)*1023+C_EXV_POSITION_STD/2)/C_EXV_POSITION_STD;
    6f1c:	7201      	lod	A, [S-2]
    6f1e:	aaee      	sub	A, X
    6f20:	4802 03ff 	mulu	D, A, #1023
    6f24:	7aef      	lod	Y, S
    6f26:	e0fa      	add	Y, #-6
    6f28:	4c85      	mov	[Y], D
    6f2a:	7209      	lod	A, [S-10]
    6f2c:	4432      	lsr	A
    6f2e:	4cc8      	movu	D, A
    6f30:	4c80      	mov	YA, D
    6f32:	a205      	add	A, [S-6]
    6f34:	f203      	adc	Y, [S-4]
    6f36:	5205      	mov	[S-6], A
    6f38:	5a03      	mov	[S-4], Y
    6f3a:	7a09      	lod	Y, [S-10]
    6f3c:	4cc9      	movu	D, Y
    6f3e:	4c83      	push	D
    6f40:	7209      	lod	A, [S-10]
    6f42:	7a07      	lod	Y, [S-8]
    6f44:	16a7      	call	0x6c94 <___udivsi3>
    6f46:	5c03      	dec	S, #4
    6f48:	07e6      	jmp	0x6f16 <_RteExv2Lin+0xec>
		}
	}
	else if(g_e8EXVStatusInitStat == (uint8)C_STATUS_NOT_INIT)
    6f4a:	620b      	lod	AL, [S-12]
    6f4c:	1d03      	jne	0x6f54 <_RteExv2Lin+0x12a>
	{
		g_u16EXVStatusCurrentPositon = 0;
    6f4e:	7800      	lod	Y, #0
    6f50:	5ad8 00fc 	mov	0xfc <_g_u16EXVStatusCurrentPositon>, Y
    6f54:	540d      	ret	#14

00006f56 <_UpdateMotorSpeed>:
}

//In default MLX, update speed during motor start or receive motor speed change command(will not excute other command)
//In updated MLX by Ban, update speed during motor start and receive motor speed change command(doesn't impact other command)
void UpdateMotorSpeed(void)
{
    6f56:	5809      	inc	S, #10
	uint8 u8MotorSpeedIdx;
	if(g_u8TorqueBoostRequest == 0)//normal torque
    6f58:	62d8 0108 	lod	AL, 0x108 <_g_u8TorqueBoostRequest>
    6f5c:	4209      	mov	[S-10], AL
    6f5e:	1d0c      	jne	0x6f78 <_UpdateMotorSpeed+0x22>
	{
		g_u8MotorCtrlSpeed = (uint8) C_DEFAULT_MOTOR_SPEED;//speed 1
    6f60:	6003      	lod	AL, #3
    6f62:	41f2      	mov	dp:0xf2 <_g_u8MotorCtrlSpeed>, AL
		u8MotorSpeedIdx = (g_u8MotorCtrlSpeed & 0x07);
    6f64:	7003      	lod	A, #3
		g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    6f66:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
		g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[u8MotorSpeedIdx];
    6f68:	7ad8 02c4 	lod	Y, 0x2c4 <_g_au16MotorSpeedRPS+0x6>
    6f6c:	5ad8 02a6 	mov	0x2a6 <_g_u16MotorSpeedRPS>, Y
		g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[u8MotorSpeedIdx];
    6f70:	7ed8 02b4 	lod	X, 0x2b4 <_g_au16MotorSpeedCommutTimerPeriod+0x6>
    6f74:	5d52      	mov	dp:0x52 <_g_u16TargetCommutTimerPeriod>, X
    6f76:	540b      	ret	#12
	}
	else//boost torque, reduce the speed
	{
		g_u8MotorCtrlSpeed = (uint8) C_MOTOR_SPEED_MID_LOW;//Speed 0
    6f78:	6002      	lod	AL, #2
    6f7a:	41f2      	mov	dp:0xf2 <_g_u8MotorCtrlSpeed>, AL
		u8MotorSpeedIdx = (g_u8MotorCtrlSpeed & 0x07);
    6f7c:	7002      	lod	A, #2
		g_u8MotorStatusSpeed = u8MotorSpeedIdx;
    6f7e:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6f80:	7190      	lod	A, dp:0x90 <__data_size+0x2e>
    6f82:	a98e      	sub	A, dp:0x8e <__data_size+0x2c>
    6f84:	5203      	mov	[S-4], A
    6f86:	6609      	lod	YL, [S-10]
    6f88:	5cf6      	usex	Y
    6f8a:	5a01      	mov	[S-2], Y
    6f8c:	7c64      	lod	X, #100
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    6f8e:	7201      	lod	A, [S-2]
    6f90:	7a03      	lod	Y, [S-4]
    6f92:	4821      	mulu	YA, A, Y
    6f94:	4c63      	divu	YA, X
    6f96:	4c63      	divu	YA, X
    6f98:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    6f9a:	7190      	lod	A, dp:0x90 <__data_size+0x2e>
    6f9c:	aaee      	sub	A, X
    6f9e:	5207      	mov	[S-8], A
		uint16 u16RPM = NVRAM_SPEED1 - muldivU16_U16byU16byU16((NVRAM_SPEED1 - NVRAM_SPEED0),g_u8TorqueBoostRequest,100);
		uint32 u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60), g_u16MotorMicroStepsPerMechRotation);
    6fa0:	7ad8 02aa 	lod	Y, 0x2aa <_g_u16MotorMicroStepsPerMechRotation>
    6fa4:	5adf      	push	Y
    6fa6:	4ce2 2c40 	mov	YA, #105000000
    6faa:	0642 
    6fac:	1646      	call	0x6c3a <_divU32_U32byU16>
    6fae:	4cc0      	mov	D, YA
    6fb0:	5c01      	dec	S, #2
    6fb2:	7207      	lod	A, [S-8]
    6fb4:	a01e      	add	A, #30
    6fb6:	4cf2      	usex	YA
    6fb8:	7c3c      	lod	X, #60
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6fba:	4c63      	divu	YA, X
    6fbc:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6fbe:	52d8 02a6 	mov	0x2a6 <_g_u16MotorSpeedRPS>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    6fc2:	4c80      	mov	YA, D
    6fc4:	7e07      	lod	X, [S-8]
    6fc6:	4c63      	divu	YA, X
    6fc8:	4c63      	divu	YA, X
    6fca:	5201      	mov	[S-2], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6fcc:	a0ff      	add	A, #-1
    6fce:	5152      	mov	dp:0x52 <_g_u16TargetCommutTimerPeriod>, A
    6fd0:	540b      	ret	#12

00006fd2 <_main>:
 *	S. (Optional) Determine actuator position
 *	T. (Watch-dog Reset) Start actuator (if needed)
 *	U. Main application loop
 * ****************************************************************************	*/
int16 main( void)
{
    6fd2:	581f      	inc	S, #32
	/* *************************************************** */
	/* *** A. Initialise background schedule (Task-ID) *** */
	/* *************************************************** */
	uint8 u8BackgroundSchedulerTaskID = 0;
    6fd4:	7000      	lod	A, #0
    6fd6:	521f      	mov	[S-32], A

#if _SUPPORT_CRASH_RECOVERY
	/* **************************************************************** */
	/* *** B. (Optional) Check crash-recovery (fatal-error handler) *** */
	/* **************************************************************** */
	if ( bistResetInfo == C_CHIP_STATE_FATAL_CRASH_RECOVERY )
    6fd8:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    6fdc:	aeda 1872 	cmp	A, #6258
    6fe0:	1d0d      	jne	0x6ffc <_main+0x2a>
	{
#if LIN_COMM
		g_u8LinInFrameBufState = C_LIN_IN_FREE;
    6fe2:	6400      	lod	YL, #0
    6fe4:	46d8 0122 	mov	0x122 <_g_u8LinInFrameBufState>, YL
#endif /* LIN_COMM */
		if ( (g_e8StallDetectorEna != (uint8) C_STALLDET_NONE) && ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0)) /*lint !e845 */
    6fe8:	61ec      	lod	AL, dp:0xec <_g_e8StallDetectorEna>
    6fea:	1d01      	jne	0x6fee <_main+0x1c>
    6fec:	00ca      	jmp	0x7182 <_main+0x1b0>
    6fee:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    6ff0:	b401      	and	A, #1
    6ff2:	1d01      	jne	0x6ff6 <_main+0x24>
    6ff4:	00c6      	jmp	0x7182 <_main+0x1b0>
		{
			/* Actuator is active; clear motor-raw-current moving-average buffer */
			MotorDriverCurrentMeasureInit();
    6ff6:	82db 9800 	callf	0x9800 <_MotorDriverCurrentMeasureInit>
    6ffa:	00c3      	jmp	0x7182 <_main+0x1b0>
#if WATCHDOG == DISABLED
		WD_CTRL = 0;															/* Disable digital Watch-dog */
		AWD_CTRL = 0x8000;														/* Disable analogue Watch-dog */
#endif /* WATCHDOG == DISABLED */
#if WATCHDOG == ENABLED
		WD_T = WatchDog_PeriodOf100ms;											/* Initialise the (Digital) watch-dog comparator to 100ms */
    6ffc:	60c3      	lod	AL, #-61
    6ffe:	4282      	mov	io:0x2 <_LinCmnd>, AL
		WD_CTRL = WatchDog_ModeTimer;											/* Define the mode and start the watchdog */
    7000:	6012      	lod	AL, #18
    7002:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
 *
 *****************************************************************************
 */
__MLX_TEXT__  static INLINE void awdg_init (uint8 prescaler, uint8 timer)
{
    AWD_CTRL = ((uint16)(prescaler & 3) << 8) | timer;
    7004:	72da 019c 	lod	A, #412
    7008:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
		awdg_init( AWDG_DIV_16, C_AWD_PERIOD_250MS);
		/* Maximum Watch-dog period */
#endif /* WATCHDOG == ENABLED */
#if MCU_ASSP_MODE
		ANA_OUTL |= ASSP;														/* ASSP-mode */
    700a:	72d8 28d4 	lod	A, 0x28d4 <__io__+0xd4>
    700e:	a401      	or	A, #1
    7010:	52d8 28d4 	mov	0x28d4 <__io__+0xd4>, A

#if _SUPPORT_TESTMODE_OFF
		/* ******************************************** */
		/* *** D. (Optional) Chip test-mode disable *** */
		/* ******************************************** */
		CONTROL |= OUTA_WE;														/* Grant access to ANA_OUTx registers */
    7014:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7018:	8408      	or	AL, #8
    701a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
		ANA_OUTA |= TEST_MODE_DIS;												/* Disable test-mode */
    701e:	72d8 201c 	lod	A, 0x201c <__ep__+0x101c>
    7022:	a6da 0080 	or	A, #128
    7026:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
		CONTROL &= ~OUTA_WE;
    702a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    702e:	94f7      	and	AL, #-9
    7030:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
#endif /* MCU_ASSP_MODE */
#endif /* _DEBUG_SPI */
#endif /* _DEBUG */

		/* Application mode */
		SET_PRIORITY(0);
    7034:	54f0      	mov	UPr, #0
		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    7036:	6002      	lod	AL, #2
    7038:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
		/* ******************************* */
		/* *** E. Load user NVRAM page *** */
		/* ******************************* */
		NVRAM_LoadUserPage();													/* Load User NVRAM storage parameters */
    703a:	82db a1d4 	callf	0xa1d4 <_NVRAM_LoadUserPage>

#if USE_MULTI_PURPOSE_BUFFER
		g_MPBuf.u8Type = (uint8) C_MP_BUF_NONE;
    703e:	6400      	lod	YL, #0
    7040:	46d8 015e 	mov	0x15e <_g_MPBuf>, YL
		g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;
    7044:	46d8 015f 	mov	0x15f <_g_MPBuf+0x1>, YL
#endif /* USE_MULTI_PURPOSE_BUFFER */

		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )						/* MMP151118 - Begin */
    7048:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    704c:	aeda 5c92 	cmp	A, #23698
    7050:	1901      	je	0x7054 <_main+0x82>
		{
			noinit_section_init();
    7052:	16cf      	call	0x6df2 <_noinit_section_init>
		}																		/* MMP151118 - End */
		g_e8StallDetectorEna = C_STALLDET_NONE;
    7054:	6000      	lod	AL, #0
    7056:	41ec      	mov	dp:0xec <_g_e8StallDetectorEna>, AL
		if ( g_NvramUser.StallDetectorEna )
    7058:	6168      	lod	AL, dp:0x68 <__data_size+0x6>
    705a:	421d      	mov	[S-30], AL
    705c:	44b0      	lsr	AL, #2
    705e:	4430      	lsr	AL
    7060:	b401      	and	A, #1
    7062:	1902      	je	0x7068 <_main+0x96>
		{
#if _SUPPORT_STALLDET_H
			g_e8StallDetectorEna |= C_STALLDET_H;								/* Control-flag Stall-detector "H" and "A" enabled */
#else  /* _SUPPORT_STALLDET_H */
			g_e8StallDetectorEna |= C_STALLDET_A;								/* Control-flag Stall-detector "A" enabled */
    7064:	6001      	lod	AL, #1
    7066:	41ec      	mov	dp:0xec <_g_e8StallDetectorEna>, AL
#endif /* _SUPPORT_STALLDET_H */
		}
		if ( NVRAM_STALL_O )
    7068:	61c7      	lod	AL, dp:0xc7 <__bss_dp_size+0x17>
    706a:	44b2      	lsr	A, #2
    706c:	44b2      	lsr	A, #2
    706e:	44b2      	lsr	A, #2
    7070:	b401      	and	A, #1
    7072:	1903      	je	0x707a <_main+0xa8>
		{
			g_e8StallDetectorEna |= C_STALLDET_O;								/* Control-flag Stall-detector "O" enabled */
    7074:	61ec      	lod	AL, dp:0xec <_g_e8StallDetectorEna>
    7076:	8402      	or	AL, #2
    7078:	41ec      	mov	dp:0xec <_g_e8StallDetectorEna>, AL
		}

		//g_e8StallDetectorEna = C_STALLDET_NONE;//Ban for GM CV, stall O is enabled and not programmable. TODO
		g_u8MotorHoldingCurrEna = g_NvramUser.MotorHoldingCurrentEna;			/* Control-flag motor Holding-current enabled */
    707a:	621d      	lod	AL, [S-30]
    707c:	44b0      	lsr	AL, #2
    707e:	44b0      	lsr	AL, #2
    7080:	b401      	and	A, #1
    7082:	41ed      	mov	dp:0xed <_g_u8MotorHoldingCurrEna>, AL

		/* ********************************************** */
		/* *** F. Initialise Error-logging management *** */
		/* ********************************************** */
		ErrorLogInit();
    7084:	82db 9300 	callf	0x9300 <_ErrorLogInit>

		/* Log Watch-dog reset */
		if ( bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET )						/* LIN-command chip reset use WD; No need to log */
    7088:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    708c:	aeda 3072 	cmp	A, #12402
    7090:	1918      	je	0x70c2 <_main+0xf0>
		{
			if ( (CONTROL & WD_BOOT) || (AWD_CTRL & AWD_RST) )
    7092:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7096:	8c00      	cmp	AL, #0
    7098:	1a83      	jsl	0x70a0 <_main+0xce>
    709a:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    709c:	ac00      	cmp	A, #0
    709e:	1e91      	jsge	0x70c2 <_main+0xf0>
			{
				if ( CONTROL & WD_BOOT )
    70a0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    70a4:	8c00      	cmp	AL, #0
    70a6:	1e89      	jsge	0x70ba <_main+0xe8>
				{
					if ( AWD_CTRL & AWD_RST )
    70a8:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    70aa:	ac00      	cmp	A, #0
    70ac:	1e83      	jsge	0x70b4 <_main+0xe2>
					{
						SetLastError( (uint8) C_ERR_WD_AWD_RST);				/* Both Analogue & Digital Watch-dog reset */
    70ae:	72da 00f3 	lod	A, #243
    70b2:	0005      	jmp	0x70be <_main+0xec>
					}
					else
					{
						SetLastError( (uint8) C_ERR_WD_RST);					/* Digital Watch-dog reset */
    70b4:	72da 00f1 	lod	A, #241
    70b8:	0002      	jmp	0x70be <_main+0xec>
					}
				}
				else
				{
					SetLastError( (uint8) C_ERR_AWD_RST);						/* Analogue Watch-dog reset */
    70ba:	72da 00f2 	lod	A, #242
    70be:	82db 9328 	callf	0x9328 <_SetLastError>
		}

		/* ******************************************* */
		/* *** G. Initialise chip (H/W) Diagnostic *** */
		/* ******************************************* */
		DiagnosticsInit();														/* Initialise Diagnostic */
    70c2:	82db 9220 	callf	0x9220 <_DiagnosticsInit>

		/* ************************* */
		/* *** H. Initialise ADC *** */
		/* ************************* */
		ADC_Init();																/* Initialise ADC */
    70c6:	82db 8e82 	callf	0x8e82 <_ADC_Init>

		/* ********************************** */
		/* *** I. Initialise Motor-driver *** */
		/* ********************************** */
		MotorDriverInit();														/* Initialise Motor-Driver */
    70ca:	82db 93e4 	callf	0x93e4 <_MotorDriverInit>

		/* *************************************** */
		/* *** J. Initialise rewind management *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0) )
    70ce:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    70d2:	aeda 5c92 	cmp	A, #23698
    70d6:	1907      	je	0x70e6 <_main+0x114>
    70d8:	61a3      	lod	AL, dp:0xa3 <__data_size+0x41>
    70da:	8c00      	cmp	AL, #0
    70dc:	1e84      	jsge	0x70e6 <_main+0x114>
    70de:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    70e0:	1902      	je	0x70e6 <_main+0x114>
#else  /* _SUPPORT_WD_RST_RECOVERY */
			if ( (NVRAM_RESTALL_POR != FALSE) && (NVRAM_REWIND_STEPS != 0) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
			{
				g_u8RewindFlags = (uint8) (C_REWIND_STALL_DETECT | C_REWIND_DIRECTION_AUTO);/* After POR: Enable Rewind and set auto-direction */
    70e2:	6006      	lod	AL, #6
    70e4:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
			}

		SET_PRIORITY(7);
    70e6:	54f7      	mov	UPr, #7

		/* ********************************* */
		/* *** K. Motor-driver self-test *** */
		/* ********************************* */
#if _SUPPORT_WD_RST_RECOVERY
		if ( (bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
    70e8:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    70ec:	aeda 5c92 	cmp	A, #23698
    70f0:	190a      	je	0x7106 <_main+0x134>
    70f2:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    70f6:	aeda 3072 	cmp	A, #12402
    70fa:	1905      	je	0x7106 <_main+0x134>
#else  /* _SUPPORT_WD_RST_RECOVERY */
			if ( ((CONTROL & WD_BOOT) == 0) && ((AWD_CTRL & AWD_RST) == 0) && (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) )
#endif /* _SUPPORT_WD_RST_RECOVERY */
			{
#if (_SUPPORT_MOTOR_SELFTEST != FALSE)
				g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_SELFTEST;
    70fc:	6004      	lod	AL, #4
    70fe:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
				MotorDriverSelfTest();												/* Self-test Motor-Driver */
    7100:	82db 9616 	callf	0x9616 <_MotorDriverSelfTest>
    7104:	0007      	jmp	0x7114 <_main+0x142>
#endif /* (_SUPPORT_MOTOR_SELFTEST != FALSE) */
			}
#if _SUPPORT_WD_RST_RECOVERY
			else if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )				/* MMP130626-11 */
    7106:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    710a:	aeda 5c92 	cmp	A, #23698
    710e:	1d02      	jne	0x7114 <_main+0x142>
			{
				g_u8ChipResetOcc = FALSE;											/* Clear chip-reset flag before LIN initialisation */
    7110:	6400      	lod	YL, #0
    7112:	4529      	mov	dp:0x29 <_g_u8ChipResetOcc>, YL
			}
#endif /* _SUPPORT_WD_RST_RECOVERY */

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_INIT;
    7114:	6002      	lod	AL, #2
    7116:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL

		/* ********************************* */
		/* *** L. Initialise PID-Control *** */
		/* ********************************* */
		PID_Init();																/* PID Control initialisation */
    7118:	82db a586 	callf	0xa586 <_PID_Init>

		/* *************************************** */
		/* *** M. Initialise (Task) Core Timer *** */
		/* *************************************** */
		Timer_Init();															/* Initialise (Core) Timer */
    711c:	82db a8f8 	callf	0xa8f8 <_Timer_Init>

		g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_STOP;
    7120:	6000      	lod	AL, #0
    7122:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
#if LIN_COMM
		/* *************************************** */
		/* *** O. Initialise LIN-communication *** */
		/* *************************************** */
#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    7124:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    7128:	aeda 5c92 	cmp	A, #23698
    712c:	1d02      	jne	0x7132 <_main+0x160>
		{
			/* Do not change actual and target position */
			LIN_Init( TRUE);													/* Initialise LIN communication interface */
    712e:	7001      	lod	A, #1
    7130:	0001      	jmp	0x7134 <_main+0x162>
		}
		else
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			LIN_Init( FALSE);													/* Initialise LIN communication interface */
    7132:	7000      	lod	A, #0
    7134:	82db 7aaa 	callf	0x7aaa <_LIN_Init>
		}

		/* Check chip-state for LIN-command RESET, to setup diagnostic-response */
		if ( bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET )
    7138:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    713c:	aeda 3072 	cmp	A, #12402
    7140:	1d05      	jne	0x714c <_main+0x17a>
		{
#if (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
    7142:	82db 8dee 	callf	0x8dee <_RfrDiagReset>
#endif /* (((LINPROT & LINXX) == LIN2X) && _SUPPORT_MLX_DEBUG_MODE) */
#if ((LINPROT & LINXX) == LIN2J)
			RfrDiagReset();														/* Prepare a diagnostics response reply */
#endif /* ((LINPROT & LINXX) == LIN2J) */
			bistResetInfo = C_CHIP_STATE_COLD_START;
    7146:	7800      	lod	Y, #0
    7148:	5ad8 0372 	mov	0x372 <_bistResetInfo>, Y
		}
#endif /* LIN_COMM */

#if _SUPPORT_WD_RST_RECOVERY
		if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    714c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    7150:	aeda 5c92 	cmp	A, #23698
    7154:	1904      	je	0x715e <_main+0x18c>
#endif /* _SUPPORT_WD_RST_RECOVERY */
		{
			g_u16ActuatorActPos = g_u16ActualPosition;							/* Initialise the Actuator positions too */
    7156:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    7158:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
			g_u16ActuatorTgtPos = g_u16TargetPosition;
    715a:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    715c:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
		}

		/* **************************************************************** */
		/* *** Q. Perform an initial supply and temperature measurement *** */
		/* **************************************************************** */
		MeasureVsupplyAndTemperature();
    715e:	82db 9088 	callf	0x9088 <_MeasureVsupplyAndTemperature>
		GetChipTemperature( TRUE);												/* MMP131020-1 */;
    7162:	7001      	lod	A, #1
    7164:	82db 8fb0 	callf	0x8fb0 <_GetChipTemperature>

		/* ********************************************** */
		/* *** R. Stop any motor activity immediately *** */
		/* ********************************************** */
		MotorDriverStop( (uint16) C_STOP_IMMEDIATE);							/* Start-up: Energyce coils if needed */
    7168:	7001      	lod	A, #1
    716a:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>

#if _SUPPORT_WD_RST_RECOVERY
		/* ****************************************************** */
		/* *** T. (Watch-dog Reset) Start actuator (if needed) *** */
		/* ****************************************************** */
		if ( bistResetInfo == C_CHIP_STATE_WATCHDOG_RESET )
    716e:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    7172:	aeda 5c92 	cmp	A, #23698
    7176:	1d05      	jne	0x7182 <_main+0x1b0>
		{
			if ( g_u16ActuatorActPos != g_u16ActuatorTgtPos )
    7178:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    717a:	adf8      	cmp	A, dp:0xf8 <_g_u16ActuatorTgtPos>
    717c:	1902      	je	0x7182 <_main+0x1b0>
			{
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    717e:	6003      	lod	AL, #3
    7180:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		}
#endif /* _SUPPORT_WD_RST_RECOVERY */
	}

#if _SUPPORT_CRASH_RECOVERY
	bistResetInfo = C_CHIP_STATE_FATAL_RECOVER_ENA;							/* Enable Fatal crash recovery */
    7182:	7ada 1a45 	lod	Y, #6725
    7186:	5ad8 0372 	mov	0x372 <_bistResetInfo>, Y
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    718a:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    718c:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    718e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    7190:	b430      	and	A, #48
    7192:	1902      	je	0x7198 <_main+0x1c6>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    7194:	6000      	lod	AL, #0
    7196:	4282      	mov	io:0x2 <_LinCmnd>, AL

		/* ********************************* */
		/* *** c. LIN(-IN) communication *** */
		/* ********************************* */
#if LIN_COMM
		if ( g_u8LinInFrameBufState != C_LIN_IN_FREE )
    7198:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
    719c:	1902      	je	0x71a2 <_main+0x1d0>
		{
			/* LIN message buffer filled */
			HandleLinInMsg();
    719e:	82db 7bd4 	callf	0x7bd4 <_HandleLinInMsg>
		}
#if ((LINPROT & LINXX) == LIN2X)
		if ( g_u8LinAAMode != 0 )												/* MMP140417-2: Don't allow any motor control */
    71a2:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    71a6:	1d71      	jne	0x718a <_main+0x1b8>

		/* ******************************* */
		/* *** d. Motor Driver current *** */
		/* ******************************* */
		/* Calculate Current (1000LSB/A) [mA] */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) || (g_u8MotorHoldingCurrState != FALSE) )
    71a8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    71aa:	b401      	and	A, #1
    71ac:	1d03      	jne	0x71b4 <_main+0x1e2>
    71ae:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    71b2:	191a      	je	0x71e8 <_main+0x216>
    71b4:	82db 906c 	callf	0x906c <_GetMotorDriverCurrent>
    71b8:	794c      	lod	Y, dp:0x4c <_g_u16CorrectionRatio>
    71ba:	7eda 5760 	lod	X, #22368
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    71be:	4821      	mulu	YA, A, Y
    71c0:	4c63      	divu	YA, X
    71c2:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    71c4:	52d8 0110 	mov	0x110 <_g_i16Current>, A
		{
			/* Average current = unfiltered_current * Motor_PWM_DutyCycle */
			g_i16Current = (int16) muldivU16_U16byU16byU16( (uint16) GetMotorDriverCurrent(), g_u16CorrectionRatio, (PWM_REG_PERIOD << (4 + PWM_PRESCALER_N)));

			if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    71c8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    71ca:	b401      	and	A, #1
    71cc:	1d17      	jne	0x71fc <_main+0x22a>
			{
				/* Motor holding mode: Update motor-current LPF for PID-control */
				g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 16) >> 4)) + (g_i16Current << 2);
    71ce:	7156      	lod	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    71d0:	7ae2      	lod	Y, A
    71d2:	e010      	add	Y, #16
    71d4:	44b6      	lsr	Y, #2
    71d6:	44b6      	lsr	Y, #2
    71d8:	aae6      	sub	A, Y
    71da:	7ad8 0110 	lod	Y, 0x110 <_g_i16Current>
    71de:	44a6      	asl	Y, #2
    71e0:	a2e6      	add	A, Y
    71e2:	5156      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, A
#if (C_MOVAVG_SSZ < 6)
				g_u16MotorCurrentMovAvgxN = ((g_u16MotorCurrentLPFx64 + 2) >> (6 - C_MOVAVG_SSZ));	/* -=#=- Just for debug feedback */
#endif /* (C_MOVAVG_SSZ < 6 ) */
#if (C_MOVAVG_SSZ == 6 )
				g_u16MotorCurrentMovAvgxN = g_u16MotorCurrentLPFx64;			/* -=#=- Just for debug feedback */
    71e4:	5154      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, A
    71e6:	000a      	jmp	0x71fc <_main+0x22a>
#endif /* (C_MOVAVG_SSZ == 6 ) */
			}
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    71e8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    71ea:	b401      	and	A, #1
    71ec:	1d07      	jne	0x71fc <_main+0x22a>
#else  /* LIN_COMM */
			if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
#endif /* LIN_COMM */
			{
				g_i16Current = 0;
    71ee:	7800      	lod	Y, #0
    71f0:	5ad8 0110 	mov	0x110 <_g_i16Current>, Y
				g_u16MotorCurrentLPFx64 = 0;
    71f4:	5956      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, Y
				g_u16MotorCurrentMovAvgxN = 0;
    71f6:	5954      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, Y
				MeasureVsupplyAndTemperature();										/* Perform Vbat/Temperature measurement incase motor is stopped */
    71f8:	82db 9088 	callf	0x9088 <_MeasureVsupplyAndTemperature>

		/* ************************************************************** */
		/* *** e. Chip and Motor Driver voltage (degraded-mode check) *** */
		/* ************************************************************** */
		/* Calculate Voltage (100LSB/V) [10mV] */
		GetVsupply();
    71fc:	82db 8f30 	callf	0x8f30 <_GetVsupply>
		GetVsupplyMotor();
    7200:	82db 8f6c 	callf	0x8f6c <_GetVsupplyMotor>
		if ( g_i16MotorVoltage < (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS) )//under voltage is 9-0.5=8.5V accroding to FMEA, set in NVRAM
    7204:	61aa      	lod	AL, dp:0xaa <__data_size+0x48>
    7206:	5cf2      	usex	A
    7208:	4872 0019 	muls	A, A, #25
    720c:	4472      	asr	A
    720e:	521b      	mov	[S-28], A
    7210:	7ae2      	lod	Y, A
    7212:	e0ce      	add	Y, #-50
    7214:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7216:	aee6      	cmp	A, Y
    7218:	1e94      	jsge	0x7242 <_main+0x270>
		{
			/* First time application under-voltage error */					/* MMP150128-1 - Begin */
			if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_UV) == 0x00 )
    721a:	66d8 0107 	lod	YL, 0x107 <_l_e8ErrorDebounceFilter>
    721e:	72e6      	lod	A, Y
    7220:	b404      	and	A, #4
    7222:	1d03      	jne	0x722a <_main+0x258>
			{
				/* Need twice a under-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_UV;
    7224:	62e8      	lod	AL, YL
    7226:	8404      	or	AL, #4
    7228:	003c      	jmp	0x72a2 <_main+0x2d0>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_UNDER )
    722a:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    722c:	8c01      	cmp	AL, #1
    722e:	1d01      	jne	0x7232 <_main+0x260>
    7230:	003a      	jmp	0x72a6 <_main+0x2d4>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_UNDER;				/* 9.5.3.4 */
    7232:	6001      	lod	AL, #1
    7234:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    7236:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7238:	42d8 0109 	mov	0x109 <_g_e8ErrorVoltageComm>, AL
					SetLastError( (uint8) C_ERR_APPL_UNDER_VOLT);
    723c:	72da 00a2 	lod	A, #162
    7240:	001d      	jmp	0x727c <_main+0x2aa>
#if (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44)
				u16DegradeDelay = 0xFFFF;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		else if ( g_i16MotorVoltage > (NVRAM_APPL_OVOLT + C_VOLTAGE_HYS) )//Over voltage is 19+0.5=19.5V, according to FMEA, set in NVRAM
    7242:	61ab      	lod	AL, dp:0xab <__data_size+0x49>
    7244:	5cf2      	usex	A
    7246:	4872 0019 	muls	A, A, #25
    724a:	7ee2      	lod	X, A
    724c:	447e      	asr	X
    724e:	7aee      	lod	Y, X
    7250:	e032      	add	Y, #50
    7252:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7254:	aee6      	cmp	A, Y
    7256:	1b15      	jsle	0x7282 <_main+0x2b0>
		{
			/* First time application over-voltage error */
			if ( (l_e8ErrorDebounceFilter & C_DEBFLT_ERR_OV) == 0x00 )
    7258:	66d8 0107 	lod	YL, 0x107 <_l_e8ErrorDebounceFilter>
    725c:	72e6      	lod	A, Y
    725e:	b408      	and	A, #8
    7260:	1d03      	jne	0x7268 <_main+0x296>
			{
				/* Need twice a over-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OV;
    7262:	62e8      	lod	AL, YL
    7264:	8408      	or	AL, #8
    7266:	001d      	jmp	0x72a2 <_main+0x2d0>
			}
			else
			{
				if ( g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_OVER )
    7268:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    726a:	8c02      	cmp	AL, #2
    726c:	191c      	je	0x72a6 <_main+0x2d4>
				{
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_OVER;				/* 9.5.3.4 */
    726e:	6002      	lod	AL, #2
    7270:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
					g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    7272:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7274:	42d8 0109 	mov	0x109 <_g_e8ErrorVoltageComm>, AL
					SetLastError( (uint8) C_ERR_APPL_OVER_VOLT);
    7278:	72da 00a3 	lod	A, #163
    727c:	82db 9328 	callf	0x9328 <_SetLastError>
    7280:	0012      	jmp	0x72a6 <_main+0x2d4>
				u16DegradeDelay = 0xFFFF;										/* Disable degrade delay timer */
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			}
		}
		//else if ( (g_i16MotorVoltage >= (NVRAM_APPL_UVOLT + C_VOLTAGE_HYS)) && (g_i16SupplyVoltage <= (NVRAM_APPL_OVOLT - C_VOLTAGE_HYS)) )
		else if ( (g_i16MotorVoltage >= (NVRAM_APPL_UVOLT - 10)) && (g_i16SupplyVoltage <= (NVRAM_APPL_OVOLT + 10)) )//Accroding to FMEA, set the voltage to 8.9V & 19.1V
    7282:	7a1b      	lod	Y, [S-28]
    7284:	e0f6      	add	Y, #-10
    7286:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    7288:	aee6      	cmp	A, Y
    728a:	1a8d      	jsl	0x72a6 <_main+0x2d4>
    728c:	7aee      	lod	Y, X
    728e:	e00a      	add	Y, #10
    7290:	72d8 0114 	lod	A, 0x114 <_g_i16SupplyVoltage>
    7294:	aee6      	cmp	A, Y
    7296:	1f07      	jsg	0x72a6 <_main+0x2d4>
					g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;			/* Signal voltage-in range */
				}
			}
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
#else  /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */
			g_e8ErrorVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
    7298:	6000      	lod	AL, #0
    729a:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
    729c:	62d8 0107 	lod	AL, 0x107 <_l_e8ErrorDebounceFilter>
    72a0:	94f3      	and	AL, #-13
    72a2:	42d8 0107 	mov	0x107 <_l_e8ErrorDebounceFilter>, AL
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */		/* MMP150128-1 - End */
		}

#if _SUPPORT_LIN_UV
		if ( NVRAM_LIN_UV != 0 )												/* MMP131216-1 - Begin */
    72a6:	61c5      	lod	AL, dp:0xc5 <__bss_dp_size+0x15>
    72a8:	b407      	and	A, #7
    72aa:	191b      	je	0x72e2 <_main+0x310>
		{
			if ( g_i16MotorVoltage >= (int16) (600 + (NVRAM_LIN_UV * 50)) )
    72ac:	4872 0032 	muls	A, A, #50
    72b0:	a2da 0258 	add	A, #600
    72b4:	7920      	lod	Y, dp:0x20 <_g_i16MotorVoltage>
    72b6:	eee2      	cmp	Y, A
    72b8:	1a82      	jsl	0x72be <_main+0x2ec>
			{
				g_u16LinUVTimeCounter = 0;										/* Stop LIN UV time-counter */
    72ba:	7800      	lod	Y, #0
    72bc:	0010      	jmp	0x72de <_main+0x30c>
			}
			else if ( g_u16LinUVTimeCounter > PI_TICKS_PER_SECOND )
    72be:	72d8 0156 	lod	A, 0x156 <_g_u16LinUVTimeCounter>
    72c2:	aeda 07d0 	cmp	A, #2000
    72c6:	1a08      	jule	0x72d8 <_main+0x306>
			{
				/* Restart MLX4 Bus-timeout */
				(void) ml_Disconnect();
    72c8:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
				(void) ml_Connect();
    72cc:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
				g_u16LinUVTimeCounter = 1;										/* Re-start LIN UV time-counter */
    72d0:	7001      	lod	A, #1
    72d2:	52d8 0156 	mov	0x156 <_g_u16LinUVTimeCounter>, A
    72d6:	0005      	jmp	0x72e2 <_main+0x310>
			}
			else if ( g_u16LinUVTimeCounter == 0 )
    72d8:	ac00      	cmp	A, #0
    72da:	1d03      	jne	0x72e2 <_main+0x310>
			{
				g_u16LinUVTimeCounter = 1;										/* Start LIN UV time-counter */
    72dc:	7801      	lod	Y, #1
    72de:	5ad8 0156 	mov	0x156 <_g_u16LinUVTimeCounter>, Y

		/* ************************************************************* */
		/* *** f. Chip and ambient temperature (degraded-mode check) *** */
		/* ************************************************************* */
		/* Calculate Chip internal temperature (1LSB/C) [C] */
		GetChipTemperature( FALSE)												/* MMP131020-1 */;
    72e2:	7000      	lod	A, #0
    72e4:	82db 8fb0 	callf	0x8fb0 <_GetChipTemperature>
#endif /* (_SUPPORT_DIAG_OVT != FALSE) */
#else  /* _SUPPORT_AMBIENT_TEMP */
		//if ( ((g_i16ChipTemperature > (int16) (NVRAM_APPL_OTEMP + C_TEMPERATURE_HYS)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) ||
		//	 (g_i16ChipTemperature > C_CHIP_OVERTEMP_LEVEL) )
		//Ban, the over temperate is set to 150 degree, also go to degrade mode
		if ( ((g_i16ChipTemperature > (int16) (NVRAM_APPL_OTEMP + 10)) && ((g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0)) || (g_i16ChipTemperature > (int16) C_CHIP_OVERTEMP_LEVEL) )
    72e8:	61a9      	lod	AL, dp:0xa9 <__data_size+0x47>
    72ea:	5cf2      	usex	A
    72ec:	7ee2      	lod	X, A
    72ee:	7ae2      	lod	Y, A
    72f0:	e0ce      	add	Y, #-50
    72f2:	7122      	lod	A, dp:0x22 <__data_dp_size>
    72f4:	aee6      	cmp	A, Y
    72f6:	1b03      	jsle	0x72fe <_main+0x32c>
    72f8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    72fa:	b401      	and	A, #1
    72fc:	1904      	je	0x7306 <_main+0x334>
    72fe:	7122      	lod	A, dp:0x22 <__data_dp_size>
    7300:	aeda 0096 	cmp	A, #150
    7304:	1b1b      	jsle	0x733c <_main+0x36a>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT) == 0x00 )
    7306:	66d8 0107 	lod	YL, 0x107 <_l_e8ErrorDebounceFilter>
    730a:	72e6      	lod	A, Y
    730c:	b402      	and	A, #2
    730e:	1d05      	jne	0x731a <_main+0x348>
			{
				/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
				l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVT;
    7310:	62e8      	lod	AL, YL
    7312:	8402      	or	AL, #2
    7314:	42d8 0107 	mov	0x107 <_l_e8ErrorDebounceFilter>, AL
    7318:	0020      	jmp	0x735a <_main+0x388>
			}
			else if ( g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_YES )
    731a:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    731c:	8c01      	cmp	AL, #1
    731e:	191d      	je	0x735a <_main+0x388>
			{
				g_u8OverTemperatureCount++;
    7320:	62d8 010b 	lod	AL, 0x10b <_g_u8OverTemperatureCount>
    7324:	8001      	add	AL, #1
    7326:	42d8 010b 	mov	0x10b <_g_u8OverTemperatureCount>, AL
				if ( g_u8OverTemperatureCount >= (uint8) C_OVERTEMP_TO_PERMDEFECT_THRSHLD )
    732a:	8c03      	cmp	AL, #3
    732c:	1a16      	jule	0x735a <_main+0x388>
				{
					g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    732e:	6001      	lod	AL, #1
    7330:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
					SetLastError( (uint8) C_ERR_APPL_OVER_TEMP);
    7332:	72da 00a1 	lod	A, #161
    7336:	82db 9328 	callf	0x9328 <_SetLastError>
    733a:	000f      	jmp	0x735a <_main+0x388>
		}
#if _SUPPORT_AMBIENT_TEMP
		else if ( g_i16AmbjTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
			//else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP - C_TEMPERATURE_HYS) )
			else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP) )//Over temp pass criteria is 140 degree
    733c:	7aee      	lod	Y, X
    733e:	e0c4      	add	Y, #-60
    7340:	7122      	lod	A, dp:0x22 <__data_dp_size>
    7342:	aee6      	cmp	A, Y
    7344:	1e8a      	jsge	0x735a <_main+0x388>
#endif /* _SUPPORT_AMBIENT_TEMP */
			{
				g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_NO;
    7346:	6000      	lod	AL, #0
    7348:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
				l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVT;
    734a:	62d8 0107 	lod	AL, 0x107 <_l_e8ErrorDebounceFilter>
    734e:	94fd      	and	AL, #-3
    7350:	42d8 0107 	mov	0x107 <_l_e8ErrorDebounceFilter>, AL
				g_u8OverTemperatureCount = 0;
    7354:	6400      	lod	YL, #0
    7356:	46d8 010b 	mov	0x10b <_g_u8OverTemperatureCount>, YL
			}

		if (g_i16ChipTemperature > (int16) (C_CHIP_WARNING_OVERTEMP_LEVEL + C_TEMPERATURE_HYS))//over temperature waning process
    735a:	7122      	lod	A, dp:0x22 <__data_dp_size>
    735c:	aeda 0094 	cmp	A, #148
    7360:	1b05      	jsle	0x736c <_main+0x39a>
		{
			if ( g_e8WarningOverTemperature != (uint8) C_WARNING_OTEMP_YES )
    7362:	611a      	lod	AL, dp:0x1a <_g_e8WarningOverTemperature>
    7364:	8c01      	cmp	AL, #1
    7366:	1908      	je	0x7378 <_main+0x3a6>
			{
				g_e8WarningOverTemperature = (uint8) C_WARNING_OTEMP_YES;
    7368:	6001      	lod	AL, #1
    736a:	0005      	jmp	0x7376 <_main+0x3a4>
			}
		}
		else if(g_i16ChipTemperature < (int16) (C_CHIP_WARNING_OVERTEMP_LEVEL - C_TEMPERATURE_HYS))
    736c:	7122      	lod	A, dp:0x22 <__data_dp_size>
    736e:	aeda 008d 	cmp	A, #141
    7372:	1f02      	jsg	0x7378 <_main+0x3a6>
		{
			g_e8WarningOverTemperature = (uint8) C_WARNING_OTEMP_NO;
    7374:	6000      	lod	AL, #0
    7376:	411a      	mov	dp:0x1a <_g_e8WarningOverTemperature>, AL

		/* ****************************** */
		/* *** g. Degraded-mode check *** */
		/* ****************************** */
		/* Degraded check */
		if ( ((g_e8ErrorVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE) || (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_YES)) && ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) == 0))
    7378:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    737a:	1d03      	jne	0x7382 <_main+0x3b0>
    737c:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    737e:	8c01      	cmp	AL, #1
    7380:	1d1d      	jne	0x73bc <_main+0x3ea>
    7382:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7384:	8c00      	cmp	AL, #0
    7386:	1a9a      	jsl	0x73bc <_main+0x3ea>
		{
			/* Not in degradation state; Stop motor, remember last "request" and enter degradation state */
			if ( g_e8MotorRequest != (uint8) C_MOTOR_REQUEST_NONE )				/* MMP150313-3 - Begin */
    7388:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    738a:	1904      	je	0x7394 <_main+0x3c2>
			{
				g_e8DegradedMotorRequest = g_e8MotorRequest;
    738c:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    738e:	6400      	lod	YL, #0
    7390:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
    7392:	0008      	jmp	0x73a4 <_main+0x3d2>
				MotorDriverStop( (uint16) C_STOP_RAMPDOWN);						/* Degraded-mode (Running) */
			}
			else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0 )	/* MMP150313-3 - End */
    7394:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7396:	b401      	and	A, #1
    7398:	1907      	je	0x73a8 <_main+0x3d6>
			{
				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )
    739a:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    739c:	8c01      	cmp	AL, #1
    739e:	1d0b      	jne	0x73b6 <_main+0x3e4>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;	/* Set before Diagnostics UV/OV kicks-in */
    73a0:	6003      	lod	AL, #3
    73a2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Degraded-mode (Running) */
    73a4:	7000      	lod	A, #0
    73a6:	0005      	jmp	0x73b2 <_main+0x3e0>
				else
				{
					/* "Stopping" */
				}
			}
			else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    73a8:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    73aa:	1d05      	jne	0x73b6 <_main+0x3e4>
			{
				/* Actuator is stopped, but maybe still powered (holding-mode);
				 * Request to stop without ramp-down */
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;		/* In case non-degraded mode, (optionally) turn on holding-mode */
    73ac:	6001      	lod	AL, #1
    73ae:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Degraded-mode (MMP150313-2) */
    73b0:	7002      	lod	A, #2
    73b2:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
			}
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    73b6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    73b8:	8480      	or	AL, #-128
    73ba:	0017      	jmp	0x73ea <_main+0x418>
		}
		else if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) && 
    73bc:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    73be:	8c00      	cmp	AL, #0
    73c0:	1e95      	jsge	0x73ec <_main+0x41a>
    73c2:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    73c4:	1d13      	jne	0x73ec <_main+0x41a>
    73c6:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    73c8:	1d11      	jne	0x73ec <_main+0x41a>
				(g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && (g_e8ErrorOverTemperature == (uint8) C_ERR_OTEMP_NO))
		{
			/* No longer degraded mode */
			if ( g_e8DegradedMotorRequest != (uint8) C_MOTOR_REQUEST_NONE ) 
    73ca:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    73cc:	190c      	je	0x73e6 <_main+0x414>
			{
				g_e8MotorRequest = (uint8) g_e8DegradedMotorRequest;
    73ce:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    73d0:	6000      	lod	AL, #0
    73d2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
				if(g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS)//go back to continue calibration
    73d4:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    73d6:	8c03      	cmp	AL, #3
    73d8:	1d02      	jne	0x73de <_main+0x40c>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_HI_ENDPOS;
    73da:	6002      	lod	AL, #2
    73dc:	0003      	jmp	0x73e4 <_main+0x412>
				}
				else if(g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS)
    73de:	8c06      	cmp	AL, #6
    73e0:	1d02      	jne	0x73e6 <_main+0x414>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_LO_ENDPOS;
    73e2:	6005      	lod	AL, #5
    73e4:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				}
			}
			g_e8MotorStatusMode &= (uint8) ~C_MOTOR_STATUS_DEGRADED;
    73e6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    73e8:	947f      	and	AL, #127
    73ea:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
		/* ************************************************* */
		/* *** i. Handling Motor Request (Emergency Run) *** */
		/* ************************************************* */
#if (_SUPPORT_BUSTIMEOUT)
		/* Bus-timeout occurred */
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_EMRUN )
    73ec:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    73ee:	8c07      	cmp	AL, #7
    73f0:	1d29      	jne	0x7444 <_main+0x472>
		{
			//TODO, where to clear the emergency run flag, emergency run only occurred in initialized stage
			/* Actuator move's towards Emergency Run position */
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    73f2:	6400      	lod	YL, #0
    73f4:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL


#if (((LINPROT & LINXX) == LIN2X) || ((LINPROT & LINXX) == LIN2J))
			if(g_e8CalibrationStep == (uint8) C_CALIB_DONE)
    73f6:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    73f8:	8c0a      	cmp	AL, #10
    73fa:	1d24      	jne	0x7444 <_main+0x472>
			{
				if ( g_NvramUser.EmergencyRunEndStopHi == 0 )
    73fc:	6168      	lod	AL, dp:0x68 <__data_size+0x6>
    73fe:	44b2      	lsr	A, #2
    7400:	b401      	and	A, #1
    7402:	1d0c      	jne	0x741c <_main+0x44a>
				{
					/* Move to Low EndStop */
					g_u16TargetPosition = C_EXV_ZERO_POS;
    7404:	658c      	lod	YL, dp:0x8c <__data_size+0x2a>
    7406:	44b6      	lsr	Y, #2
    7408:	44b6      	lsr	Y, #2
    740a:	4436      	lsr	Y
    740c:	f403      	and	Y, #3
    740e:	7064      	lod	A, #100
    7410:	ec00      	cmp	Y, #0
    7412:	1b03      	jsle	0x741a <_main+0x448>
    7414:	46e9      	mov	Cx, YL
    7416:	4422      	asl	A
    7418:	1ffe      	djnz	Cx, 0x7416 <_main+0x444>
    741a:	0001      	jmp	0x741e <_main+0x44c>
				}
				else
				{
					/* Move to High EndStop */
					g_u16TargetPosition = g_u16CalibTravel;
    741c:	71f4      	lod	A, dp:0xf4 <_g_u16CalibTravel>
    741e:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
				}
				if ( g_u16TargetPosition != g_u16ActualPosition)
    7420:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    7422:	adee      	cmp	A, dp:0xee <_g_u16ActualPosition>
    7424:	190f      	je	0x7444 <_main+0x472>
				{
					/* Only move actuator when not already at position */
					g_u8EmergencyRunOcc = TRUE;
    7426:	6001      	lod	AL, #1
    7428:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
					//g_e8StallDetectorEna = (uint8) C_STALLDET_ALL;
					g_u8StallOcc = FALSE;
    742a:	6400      	lod	YL, #0
    742c:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
					g_u8StallTypeComm &= ~M_STALL_MODE;								/* MMP130916-1 */
    742e:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7430:	9487      	and	AL, #-121
    7432:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

					if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    7434:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7436:	8c00      	cmp	AL, #0
    7438:	1e83      	jsge	0x7440 <_main+0x46e>
					{
						g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    743a:	6003      	lod	AL, #3
    743c:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
    743e:	0002      	jmp	0x7444 <_main+0x472>
					}
					else
					{
						g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7440:	6003      	lod	AL, #3
    7442:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
#endif /* (_SUPPORT_BUSTIMEOUT_SLEEP != FALSE) */								/* MMP130815-1 - End */
#endif /* (((LINPROT & LINXX) == LIN2X) || ((LINPROT & LINXX) == LIN2J)) */
		}
#endif /* (_SUPPORT_BUSTIMEOUT) */
		//Ban, Go to sleep after emergency run
		if((g_u8EmergencyRunOcc == TRUE) && (g_u16ActualPosition == g_u16CalibTravel))
    7444:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    7446:	8c01      	cmp	AL, #1
    7448:	1d05      	jne	0x7454 <_main+0x482>
    744a:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    744c:	adf4      	cmp	A, dp:0xf4 <_g_u16CalibTravel>
    744e:	1d02      	jne	0x7454 <_main+0x482>
		{
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    7450:	6006      	lod	AL, #6
    7452:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		/* ********************************************************************************************* */

//		g_e8MotorRequest = C_MOTOR_REQUEST_START;
//		g_e8CalibrationStep = C_CALIB_DONE;

		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_STOP )
    7454:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    7456:	4219      	mov	[S-26], AL
    7458:	8c01      	cmp	AL, #1
    745a:	1d0a      	jne	0x7470 <_main+0x49e>
		{
			/* Stop Actuator */
			g_u8RewindFlags &= (uint8) ~(C_REWIND_ACTIVE | C_REWIND_REWIND);
    745c:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    745e:	94d7      	and	AL, #-41
    7460:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
			MotorDriverStop( (uint16) C_STOP_RAMPDOWN);							/* LIN-cmd request */
    7462:	7000      	lod	A, #0
    7464:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7468:	6400      	lod	YL, #0
    746a:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;			/* MMP150313-1 */
    746c:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
    746e:	01b3      	jmp	0x77d6 <_main+0x804>
			//g_e8CalibrationStep = (uint8) C_CALIB_NONE;
			//g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_INIT) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_INIT) )	/* MMP150313-1 */
    7470:	6219      	lod	AL, [S-26]
    7472:	8c02      	cmp	AL, #2
    7474:	1904      	je	0x747e <_main+0x4ac>
    7476:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    7478:	4218      	mov	[S-25], AL
    747a:	8c02      	cmp	AL, #2
    747c:	1d08      	jne	0x748e <_main+0x4bc>
		{
			/* Actuator initialisation: Set new actual position */
			g_u16ActuatorActPos = g_u16ActualPosition;
    747e:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    7480:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7482:	6400      	lod	YL, #0
    7484:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
			g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;			/* MMP150313-1 */
    7486:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
			g_e8CalibrationStep = (uint8) C_CALIB_DONE;
    7488:	600a      	lod	AL, #10
    748a:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    748c:	01a4      	jmp	0x77d6 <_main+0x804>
		}
#endif /* LIN_COMM */
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_START) && (g_u8MotorStartDelay == 0))
    748e:	6219      	lod	AL, [S-26]
    7490:	8c03      	cmp	AL, #3
    7492:	1901      	je	0x7496 <_main+0x4c4>
    7494:	004c      	jmp	0x752e <_main+0x55c>
    7496:	62d8 010a 	lod	AL, 0x10a <_g_u8MotorStartDelay>
    749a:	1901      	je	0x749e <_main+0x4cc>
    749c:	0158      	jmp	0x774e <_main+0x77c>
		{
			//g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;//make sure just run once
			if((g_u8EmergencyRunOcc == FALSE) && (g_e8EXVMoveEnableRequestFlag == (uint8) C_EXV_MOVE_ENABLE))
    749e:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    74a0:	1d29      	jne	0x74f4 <_main+0x522>
    74a2:	611c      	lod	AL, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    74a4:	8c01      	cmp	AL, #1
    74a6:	1d26      	jne	0x74f4 <_main+0x522>
					g_u16TargetPosition = C_EXV_ZERO_POS + C_EXV_RANGE_MAX;
				}
				else
#endif
				{
					g_u16TargetPosition = (((uint32)g_u16EXVTargetPositionTemp)*C_EXV_POSITION_STD+512)/1023 + C_EXV_ZERO_POS;//update the target position
    74a8:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    74aa:	44b2      	lsr	A, #2
    74ac:	44b2      	lsr	A, #2
    74ae:	4432      	lsr	A
    74b0:	b403      	and	A, #3
    74b2:	5217      	mov	[S-24], A
    74b4:	72da 0120 	lod	A, #288
    74b8:	7a17      	lod	Y, [S-24]
    74ba:	ec00      	cmp	Y, #0
    74bc:	1b03      	jsle	0x74c4 <_main+0x4f2>
    74be:	46e9      	mov	Cx, YL
    74c0:	4422      	asl	A
    74c2:	1ffe      	djnz	Cx, 0x74c0 <_main+0x4ee>
    74c4:	7ad8 0100 	lod	Y, 0x100 <_g_u16EXVTargetPositionTemp>
    74c8:	4821      	mulu	YA, A, Y
    74ca:	4c22 0200 	add	YA, #512
    74ce:	0000 
    74d0:	54ca 03ff 	pushw	#1023
    74d4:	54ca 0000 	pushw	#0
    74d8:	82db 6c94 	callf	0x6c94 <___udivsi3>
    74dc:	5c03      	dec	S, #4
    74de:	5215      	mov	[S-22], A
    74e0:	5a13      	mov	[S-20], Y
    74e2:	7064      	lod	A, #100
    74e4:	7a17      	lod	Y, [S-24]
    74e6:	ec00      	cmp	Y, #0
    74e8:	1b03      	jsle	0x74f0 <_main+0x51e>
    74ea:	46e9      	mov	Cx, YL
    74ec:	4422      	asl	A
    74ee:	1ffe      	djnz	Cx, 0x74ec <_main+0x51a>
    74f0:	a215      	add	A, [S-22]
    74f2:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
				}
			}
			/* Start Actuator */
			if (( g_u16ActualPosition != g_u16TargetPosition ) && (g_e8CalibrationStep == C_CALIB_DONE))
    74f4:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    74f6:	adf0      	cmp	A, dp:0xf0 <_g_u16TargetPosition>
    74f8:	1917      	je	0x7528 <_main+0x556>
    74fa:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    74fc:	8c0a      	cmp	AL, #10
    74fe:	1d14      	jne	0x7528 <_main+0x556>
			{
				uint8 u8NewMotorDirectionCCW;
#if LIN_COMM
				UpdateMotorSpeed();//TODO, when accelerate or Decelerate, may changed the speed
    7500:	152a      	call	0x6f56 <_UpdateMotorSpeed>
				g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_2;
				g_u16MotorSpeedRPS = g_au16MotorSpeedRPS[C_MOTOR_SPEED_2];		/* Use Speed #2 as default */
				g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[C_MOTOR_SPEED_2];
#endif /* LIN_COMM */

				u8NewMotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? TRUE : FALSE;
    7502:	7800      	lod	Y, #0
    7504:	7df0      	lod	X, dp:0xf0 <_g_u16TargetPosition>
    7506:	2dee      	cmp	X, dp:0xee <_g_u16ActualPosition>
    7508:	1c01      	jnc	0x750c <_main+0x53a>
    750a:	7801      	lod	Y, #1
						g_u8RewindFlags = 0;									/* Clear previous detected stall flags */
					}															/* MMP140331-1 - End */
				}
#endif

				if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP )
    750c:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    750e:	1d04      	jne	0x7518 <_main+0x546>
				{
					g_e8MotorDirectionCCW = u8NewMotorDirectionCCW;
    7510:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
					MotorDriverStart();
    7512:	82db 9a38 	callf	0x9a38 <_MotorDriverStart>
    7516:	0008      	jmp	0x7528 <_main+0x556>
				}
				else if ( u8NewMotorDirectionCCW != g_e8MotorDirectionCCW )
    7518:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    751a:	8ee8      	cmp	AL, YL
    751c:	1904      	je	0x7526 <_main+0x554>
				{
					/* Changing direction; Stop motor first before starting in opposite direction */
					MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Change of direction */
    751e:	7000      	lod	A, #0
    7520:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
					continue;
    7524:	0632      	jmp	0x718a <_main+0x1b8>
				}
				else
				{
					g_u16ActuatorTgtPos = g_u16TargetPosition;					/* Motor already started; Update target-position only */
    7526:	5df8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, X
				}
			}
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7528:	6000      	lod	AL, #0
    752a:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    752c:	0154      	jmp	0x77d6 <_main+0x804>
		}
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_CALIBRATION) && (g_e8EXVMoveEnableRequestFlag == (uint8) C_EXV_MOVE_ENABLE) )
    752e:	6219      	lod	AL, [S-26]
    7530:	8c05      	cmp	AL, #5
    7532:	1901      	je	0x7536 <_main+0x564>
    7534:	0109      	jmp	0x7748 <_main+0x776>
    7536:	611c      	lod	AL, dp:0x1c <_g_e8EXVMoveEnableRequestFlag>
    7538:	8c01      	cmp	AL, #1
    753a:	1901      	je	0x753e <_main+0x56c>
    753c:	0108      	jmp	0x774e <_main+0x77c>
		{
			//TODO, ban, how about emergency run?
			//g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;//make sure just run once
			if ( g_e8CalibrationStep == (uint8) C_CALIB_START )//not initialized, case 00
    753e:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7540:	4211      	mov	[S-18], AL
    7542:	8c01      	cmp	AL, #1
    7544:	1901      	je	0x7548 <_main+0x576>
    7546:	003d      	jmp	0x75c2 <_main+0x5f0>
			{
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_NO;
    7548:	6400      	lod	YL, #0
    754a:	452d      	mov	dp:0x2d <_g_e8ErrorElectric>, YL
				g_e8ErrorCoil = 0;//Clean coil status because this is not updated until error happened, need to debug(ban debug)
    754c:	452c      	mov	dp:0x2c <_g_e8ErrorCoil>, YL
				g_u8StallOcc = FALSE;
    754e:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
				g_e8EXVErrorBlock = FALSE;
    7550:	4518      	mov	dp:0x18 <__data_dp_start>, YL
				g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_NO;
    7552:	4526      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, YL

				g_e8CalibrationStep = (uint8) C_CALIB_SETUP_HI_ENDPOS;
    7554:	6002      	lod	AL, #2
    7556:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				if(g_u16EXVTargetPositionTemp == (uint16)C_EXV_FULLY_OPEN_LIN)//Move to Full open, 100% first
    7558:	72d8 0100 	lod	A, 0x100 <_g_u16EXVTargetPositionTemp>
    755c:	aeda 03ff 	cmp	A, #1023
    7560:	1d27      	jne	0x75b0 <_main+0x5de>
				{
					g_u16ActualPosition = (uint16)C_EXV_ZERO_POS;
    7562:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    7564:	44b2      	lsr	A, #2
    7566:	44b2      	lsr	A, #2
    7568:	4432      	lsr	A
    756a:	7ee2      	lod	X, A
    756c:	3403      	and	X, #3
    756e:	7864      	lod	Y, #100
    7570:	2c00      	cmp	X, #0
    7572:	1b04      	jsle	0x757c <_main+0x5aa>
    7574:	5edf      	push	X
    7576:	4426      	asl	Y
    7578:	1bfe      	djnz	X, 0x7576 <_main+0x5a4>
    757a:	7ecf      	pop	X
    757c:	5a0f      	mov	[S-16], Y
    757e:	59ee      	mov	dp:0xee <_g_u16ActualPosition>, Y
					g_u16TargetPosition = (uint16)C_EXV_RANGE_MAX + C_EXV_ZERO_POS;
    7580:	616c      	lod	AL, dp:0x6c <__data_size+0xa>
    7582:	66e0      	lod	YL, AL
    7584:	5cf6      	usex	Y
    7586:	e16a      	add	Y, dp:0x6a <__data_size+0x8>
    7588:	616d      	lod	AL, dp:0x6d <__data_size+0xb>
    758a:	5cf2      	usex	A
    758c:	a2e6      	add	A, Y
    758e:	2c00      	cmp	X, #0
    7590:	1b04      	jsle	0x759a <_main+0x5c8>
    7592:	5edf      	push	X
    7594:	4422      	asl	A
    7596:	1bfe      	djnz	X, 0x7594 <_main+0x5c2>
    7598:	7ecf      	pop	X
    759a:	7818      	lod	Y, #24
    759c:	2c00      	cmp	X, #0
    759e:	1b02      	jsle	0x75a4 <_main+0x5d2>
    75a0:	4426      	asl	Y
    75a2:	1bfe      	djnz	X, 0x75a0 <_main+0x5ce>
    75a4:	a2e6      	add	A, Y
    75a6:	a20f      	add	A, [S-16]
    75a8:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
					l_e8GmcvInitDirection = (uint8)C_GMCV_INIT_DIR_OPEN_FIRST;
    75aa:	6211      	lod	AL, [S-18]
    75ac:	42d8 00fa 	mov	0xfa <__dp_noinit_end>, AL
				}

//				DefTravelToleranceLo

				if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_STOP ) //stop the motor if it is running
    75b0:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    75b2:	1907      	je	0x75c2 <_main+0x5f0>
				{
					MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    75b4:	7001      	lod	A, #1
    75b6:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
					g_u16CalibPauseCounter = C_PI_TICKS_STABILISE_CALIB;
    75ba:	7ada 00c8 	lod	Y, #200
    75be:	5ad8 0102 	mov	0x102 <_g_u16CalibPauseCounter>, Y
				}
			}

			if ( (g_e8CalibrationStep == (uint8) C_CALIB_SETUP_HI_ENDPOS) && (g_u16CalibPauseCounter == 0) )//moving to full open
    75c2:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    75c4:	8c02      	cmp	AL, #2
    75c6:	1d0f      	jne	0x75e6 <_main+0x614>
    75c8:	72d8 0102 	lod	A, 0x102 <_g_u16CalibPauseCounter>
    75cc:	1901      	je	0x75d0 <_main+0x5fe>
    75ce:	0099      	jmp	0x7702 <_main+0x730>
			{
				UpdateMotorSpeed();
    75d0:	14c2      	call	0x6f56 <_UpdateMotorSpeed>
				g_e8MotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? (uint8) C_MOTOR_DIR_CLOSING : (uint8) C_MOTOR_DIR_OPENING;
    75d2:	6400      	lod	YL, #0
    75d4:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    75d6:	adee      	cmp	A, dp:0xee <_g_u16ActualPosition>
    75d8:	1c01      	jnc	0x75dc <_main+0x60a>
    75da:	6401      	lod	YL, #1
    75dc:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
				MotorDriverStart();
    75de:	82db 9a38 	callf	0x9a38 <_MotorDriverStart>
				g_e8CalibrationStep = (uint8) C_CALIB_CHECK_HI_ENDPOS;		/* Check for FIRST End-stop */
    75e2:	6003      	lod	AL, #3
    75e4:	008d      	jmp	0x7700 <_main+0x72e>
			}
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS )//At the full open
    75e6:	8c03      	cmp	AL, #3
    75e8:	1d12      	jne	0x760e <_main+0x63c>
			{
				if ( g_u8StallOcc || (g_u16TargetPosition == g_u16ActualPosition))//Ban
    75ea:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    75ec:	1d04      	jne	0x75f6 <_main+0x624>
    75ee:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    75f0:	adee      	cmp	A, dp:0xee <_g_u16ActualPosition>
    75f2:	1901      	je	0x75f6 <_main+0x624>
    75f4:	0086      	jmp	0x7702 <_main+0x730>
				{
					g_e8CalibrationStep = (uint8) C_CALIB_SETUP_LO_ENDPOS;
    75f6:	6005      	lod	AL, #5
    75f8:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
					g_u16CalibPauseCounter = C_PI_TICKS_STABILISE_CALIB;
    75fa:	72da 00c8 	lod	A, #200
    75fe:	52d8 0102 	mov	0x102 <_g_u16CalibPauseCounter>, A
					g_u8StallOcc = FALSE;
    7602:	6400      	lod	YL, #0
    7604:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
					g_u8StallTypeComm &= ~M_STALL_MODE;
    7606:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7608:	9487      	and	AL, #-121
    760a:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
    760c:	007a      	jmp	0x7702 <_main+0x730>
				}
			}
			else if ( (g_e8CalibrationStep == (uint8) C_CALIB_SETUP_LO_ENDPOS) && (g_u16CalibPauseCounter == 0) )
    760e:	8c05      	cmp	AL, #5
    7610:	1901      	je	0x7614 <_main+0x642>
    7612:	0035      	jmp	0x767e <_main+0x6ac>
    7614:	72d8 0102 	lod	A, 0x102 <_g_u16CalibPauseCounter>
    7618:	1901      	je	0x761c <_main+0x64a>
    761a:	0073      	jmp	0x7702 <_main+0x730>
			{
				UpdateMotorSpeed();
    761c:	149c      	call	0x6f56 <_UpdateMotorSpeed>
				g_u16ActualPosition = C_EXV_RANGE_MAX + C_EXV_ZERO_POS;
    761e:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    7620:	44b2      	lsr	A, #2
    7622:	44b2      	lsr	A, #2
    7624:	4432      	lsr	A
    7626:	7ee2      	lod	X, A
    7628:	3403      	and	X, #3
    762a:	616c      	lod	AL, dp:0x6c <__data_size+0xa>
    762c:	5cf2      	usex	A
    762e:	a16a      	add	A, dp:0x6a <__data_size+0x8>
    7630:	656d      	lod	YL, dp:0x6d <__data_size+0xb>
    7632:	5cf6      	usex	Y
    7634:	e2e2      	add	Y, A
    7636:	2c00      	cmp	X, #0
    7638:	1b04      	jsle	0x7642 <_main+0x670>
    763a:	5edf      	push	X
    763c:	4426      	asl	Y
    763e:	1bfe      	djnz	X, 0x763c <_main+0x66a>
    7640:	7ecf      	pop	X
    7642:	7018      	lod	A, #24
    7644:	2c00      	cmp	X, #0
    7646:	1b04      	jsle	0x7650 <_main+0x67e>
    7648:	5edf      	push	X
    764a:	4422      	asl	A
    764c:	1bfe      	djnz	X, 0x764a <_main+0x678>
    764e:	7ecf      	pop	X
    7650:	e2e2      	add	Y, A
    7652:	7064      	lod	A, #100
    7654:	2c00      	cmp	X, #0
    7656:	1b02      	jsle	0x765c <_main+0x68a>
    7658:	4422      	asl	A
    765a:	1bfe      	djnz	X, 0x7658 <_main+0x686>
    765c:	5201      	mov	[S-2], A
    765e:	e2e2      	add	Y, A
    7660:	59ee      	mov	dp:0xee <_g_u16ActualPosition>, Y
				g_u16TargetPosition = C_EXV_ZERO_POS;
    7662:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
				g_e8MotorDirectionCCW = (g_u16TargetPosition < g_u16ActualPosition) ? C_MOTOR_DIR_CLOSING : C_MOTOR_DIR_OPENING;
    7664:	6000      	lod	AL, #0
    7666:	420d      	mov	[S-14], AL
    7668:	7201      	lod	A, [S-2]
    766a:	aee6      	cmp	A, Y
    766c:	1c02      	jnc	0x7672 <_main+0x6a0>
    766e:	6001      	lod	AL, #1
    7670:	420d      	mov	[S-14], AL
    7672:	660d      	lod	YL, [S-14]
    7674:	452a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, YL
				MotorDriverStart();
    7676:	82db 9a38 	callf	0x9a38 <_MotorDriverStart>
				g_e8CalibrationStep = (uint8) C_CALIB_CHECK_LO_ENDPOS;		/* Check for SECOND End-stop */
    767a:	6006      	lod	AL, #6
    767c:	0041      	jmp	0x7700 <_main+0x72e>
			}
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS )//////////////////////////////
    767e:	8c06      	cmp	AL, #6
    7680:	1901      	je	0x7684 <_main+0x6b2>
    7682:	003f      	jmp	0x7702 <_main+0x730>
			{
				if ( g_u8StallOcc ||  (g_u16TargetPosition == g_u16ActualPosition))
    7684:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    7686:	1d04      	jne	0x7690 <_main+0x6be>
    7688:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    768a:	adee      	cmp	A, dp:0xee <_g_u16ActualPosition>
    768c:	1901      	je	0x7690 <_main+0x6be>
    768e:	0039      	jmp	0x7702 <_main+0x730>
				{
					g_u16CalibTravel = (C_EXV_RANGE_MAX + C_EXV_ZERO_POS) - g_u16ActualPosition;
    7690:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    7692:	44b2      	lsr	A, #2
    7694:	44b2      	lsr	A, #2
    7696:	4432      	lsr	A
    7698:	7ee2      	lod	X, A
    769a:	3403      	and	X, #3
    769c:	616c      	lod	AL, dp:0x6c <__data_size+0xa>
    769e:	5cf2      	usex	A
    76a0:	a16a      	add	A, dp:0x6a <__data_size+0x8>
    76a2:	656d      	lod	YL, dp:0x6d <__data_size+0xb>
    76a4:	5cf6      	usex	Y
    76a6:	e2e2      	add	Y, A
    76a8:	2c00      	cmp	X, #0
    76aa:	1b04      	jsle	0x76b4 <_main+0x6e2>
    76ac:	5edf      	push	X
    76ae:	4426      	asl	Y
    76b0:	1bfe      	djnz	X, 0x76ae <_main+0x6dc>
    76b2:	7ecf      	pop	X
    76b4:	7018      	lod	A, #24
    76b6:	2c00      	cmp	X, #0
    76b8:	1b04      	jsle	0x76c2 <_main+0x6f0>
    76ba:	5edf      	push	X
    76bc:	4422      	asl	A
    76be:	1bfe      	djnz	X, 0x76bc <_main+0x6ea>
    76c0:	7ecf      	pop	X
    76c2:	e2e2      	add	Y, A
    76c4:	5a0b      	mov	[S-12], Y
    76c6:	7064      	lod	A, #100
    76c8:	2c00      	cmp	X, #0
    76ca:	1b04      	jsle	0x76d4 <_main+0x702>
    76cc:	5edf      	push	X
    76ce:	4422      	asl	A
    76d0:	1bfe      	djnz	X, 0x76ce <_main+0x6fc>
    76d2:	7ecf      	pop	X
    76d4:	a2e6      	add	A, Y
    76d6:	7ae2      	lod	Y, A
    76d8:	e9ee      	sub	Y, dp:0xee <_g_u16ActualPosition>
    76da:	59f4      	mov	dp:0xf4 <_g_u16CalibTravel>, Y
					if((g_u16CalibTravel < C_EXV_POSITION_STD) || (g_u16CalibTravel >= C_EXV_RANGE_MAX))//unexpect stall, under range or over range, TODO
    76dc:	72da 0120 	lod	A, #288
    76e0:	2c00      	cmp	X, #0
    76e2:	1b02      	jsle	0x76e8 <_main+0x716>
    76e4:	4422      	asl	A
    76e6:	1bfe      	djnz	X, 0x76e4 <_main+0x712>
    76e8:	eee2      	cmp	Y, A
    76ea:	1802      	jc	0x76f0 <_main+0x71e>
    76ec:	ee0b      	cmp	Y, [S-12]
    76ee:	1807      	jc	0x76fe <_main+0x72c>
					{
						g_e8CalibrationStep = C_CALIB_NONE;
    76f0:	6400      	lod	YL, #0
    76f2:	451d      	mov	dp:0x1d <_g_e8CalibrationStep>, YL
						g_e8EXVErrorBlock = TRUE;
    76f4:	6001      	lod	AL, #1
    76f6:	4118      	mov	dp:0x18 <__data_dp_start>, AL
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban, stop the motor in case of unexpect stall
    76f8:	6002      	lod	AL, #2
    76fa:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
    76fc:	0002      	jmp	0x7702 <_main+0x730>
					}
					else
					{
						g_e8CalibrationStep = (uint8) C_CALIB_END;
    76fe:	6009      	lod	AL, #9
    7700:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
					}
				}
			}
			if(g_e8CalibrationStep == (uint8) C_CALIB_END)
    7702:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7704:	8c09      	cmp	AL, #9
    7706:	1901      	je	0x770a <_main+0x738>
    7708:	0066      	jmp	0x77d6 <_main+0x804>
			{
				g_u8StallOcc = FALSE;
    770a:	6000      	lod	AL, #0
    770c:	4128      	mov	dp:0x28 <_g_u8StallOcc>, AL
				g_u8StallTypeComm &= ~M_STALL_MODE;
    770e:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    7710:	9487      	and	AL, #-121
    7712:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

				g_u16ActualPosition = C_EXV_ZERO_POS;
    7714:	658c      	lod	YL, dp:0x8c <__data_size+0x2a>
    7716:	44b6      	lsr	Y, #2
    7718:	44b6      	lsr	Y, #2
    771a:	4436      	lsr	Y
    771c:	f403      	and	Y, #3
    771e:	7064      	lod	A, #100
    7720:	ec00      	cmp	Y, #0
    7722:	1b03      	jsle	0x772a <_main+0x758>
    7724:	46e9      	mov	Cx, YL
    7726:	4422      	asl	A
    7728:	1ffe      	djnz	Cx, 0x7726 <_main+0x754>
    772a:	51ee      	mov	dp:0xee <_g_u16ActualPosition>, A
				g_u16TargetPosition = C_EXV_ZERO_POS;
    772c:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A

				g_u16ActuatorActPos = g_u16ActualPosition;
    772e:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
				g_u16ActuatorTgtPos = g_u16TargetPosition;
    7730:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A

				g_e8CalibrationStep = C_CALIB_DONE;
    7732:	600a      	lod	AL, #10
    7734:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
				g_u8MotorStartDelay = 255;	//C_PI_TICKS_STABILISE_CALIB;
    7736:	60ff      	lod	AL, #-1
    7738:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
				g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    773c:	6400      	lod	YL, #0
    773e:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
				g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7740:	4525      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, YL
				//TODO, the post motor request, related to emergency run
				g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    7742:	46d8 0104 	mov	0x104 <_g_e8CalibPostMotorRequest>, YL
    7746:	0047      	jmp	0x77d6 <_main+0x804>
			}
		}
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) || (g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_SLEEP) )	/* MMP150313-1 */
    7748:	6219      	lod	AL, [S-26]
    774a:	8c06      	cmp	AL, #6
    774c:	1904      	je	0x7756 <_main+0x784>
    774e:	6218      	lod	AL, [S-25]
    7750:	8c06      	cmp	AL, #6
    7752:	1901      	je	0x7756 <_main+0x784>
    7754:	0036      	jmp	0x77c2 <_main+0x7f0>
		{
			/* Actuator enters (Deep-)SLEEP mode (lowest power mode; Only LIN/PWM msg can wake-up) */
			if ( ((g_e8MotorStatusMode & ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) && /* MMP130730-1 */
    7756:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7758:	b47f      	and	A, #127
    775a:	1d2d      	jne	0x77b6 <_main+0x7e4>
    775c:	6135      	lod	AL, dp:0x35 <_g_u8MotorStopDelay>
    775e:	1d2b      	jne	0x77b6 <_main+0x7e4>
    7760:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    7764:	b401      	and	A, #1
    7766:	1d27      	jne	0x77b6 <_main+0x7e4>
					(g_u8MotorStopDelay == 0) &&
					((NV_CTRL & NV_BUSY) == 0) ) /* MMP140812-3 */
			{
				if ( g_u8MotorHoldingCurrEna &&									/* Holding mode enabled */
    7768:	61ed      	lod	AL, dp:0xed <_g_u8MotorHoldingCurrEna>
    776a:	1908      	je	0x777c <_main+0x7aa>
    776c:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    776e:	8c02      	cmp	AL, #2
    7770:	1905      	je	0x777c <_main+0x7aa>
    7772:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    7774:	1d03      	jne	0x777c <_main+0x7aa>
						(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) )
				{
					MotorDriverStop( (uint16) C_STOP_SLEEP);					/* Disable holding current */
    7776:	7003      	lod	A, #3
    7778:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
				 * Wake up is done by resetting the chip. The source of the wake up can be found in ANA_INB.
				 * Note: In case between MLX4_HALT and MLX16_HALT a LIN-bus event happens, the chip will not
				 * enter SLEEP but HALT-mode. To allow a LIN-wakeup, the Analogue Watchdog is set to minimum
				 * period of 100us to allow a chip reset.
				 */
				IO_WU = 0;														/* Disable IO3 wake up */
    777c:	7800      	lod	Y, #0
    777e:	5ad8 28c8 	mov	0x28c8 <__io__+0xc8>, Y
				ANA_OUTG = ANA_OUTG & 0xFF9E;									/* Clear Internal WU delay and DIS_GTSM */
    7782:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    7786:	b49e      	and	A, #-98
    7788:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
				MASK = 0;
    778c:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y
				ADC_Stop();														/* MMP140812-4 - End */
    7790:	82db 8e44 	callf	0x8e44 <_ADC_Stop>
				/* Go into sleep/halt */
				AWD_CTRL = (3u << 8) | 1;										/* Set 1:1 prescaler and minimal period; AWD timeout will be 100 us (MMP140813-2) */
    7794:	72da 0301 	lod	A, #769
    7798:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
				MLX4_RESET();
    779a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    779e:	94fe      	and	AL, #-2
    77a0:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				MLX16_HALT();													/* See MELEXIS doc */
    77a4:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77a8:	8402      	or	AL, #2
    77aa:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    77ae:	0000      	nop
				/* Chip should reset upon LIN bus changes */
				/* We should never make it to here, as a backup we add a chip reset */
				MLX16_RESET();
    77b0:	82db 5920 	callf	0x5920 <_MLX16_RESET>
    77b4:	0010      	jmp	0x77d6 <_main+0x804>
			}
			else if ( g_e8MotorStatusMode != (uint8) C_MOTOR_STATUS_STOP )
    77b6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    77b8:	190e      	je	0x77d6 <_main+0x804>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);	
    77ba:	7001      	lod	A, #1
    77bc:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
    77c0:	000a      	jmp	0x77d6 <_main+0x804>
			}
		}
#if LIN_COMM
		else if ( (g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_SPEED_CHANGE) && (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) )
    77c2:	6219      	lod	AL, [S-26]
    77c4:	8c08      	cmp	AL, #8
    77c6:	1d07      	jne	0x77d6 <_main+0x804>
    77c8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    77ca:	8c01      	cmp	AL, #1
    77cc:	1d04      	jne	0x77d6 <_main+0x804>
		{
			UpdateMotorSpeed();
    77ce:	82db 6f56 	callf	0x6f56 <_UpdateMotorSpeed>
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_NONE;
    77d2:	6400      	lod	YL, #0
    77d4:	452e      	mov	dp:0x2e <_g_e8MotorRequest>, YL
		}
#endif /* _SUPPORT_SPEED_AUTO */

		/* Update status actual-position (only incase not the initial position have been changed) */
		//if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) && ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0) )				/* MMP130626-4 */
		if ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0)//Ban, fix the move to 0 bug, because it stopped,but g_u16ActuatorActPos = 0,g_u16ActualPosition is not zero
    77d6:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    77d8:	b408      	and	A, #8
    77da:	1d02      	jne	0x77e0 <_main+0x80e>
		{
			g_u16ActualPosition = g_u16ActuatorActPos;
    77dc:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    77de:	51ee      	mov	dp:0xee <_g_u16ActualPosition>, A
//--------------------------------------------------------------------------------------------------------------------

		/* ********************************************************** */
		/* *** l. Threshold control (Stepper: Current-threshold) *** */
		/* ********************************************************** */
		ThresholdControl();													
    77e0:	82db a7b8 	callf	0xa7b8 <_ThresholdControl>
//------------------------------------------------------------------------------------------------------------------

		/* ************************************************* */
		/* *** m. PID control (Stepper: current-control) *** */
		/* ************************************************* */
		PID_Control();															/* PID-control (Current) */
    77e4:	82db a67e 	callf	0xa67e <_PID_Control>
		{
			uint16 u16Mlx4CounterThreshold = C_MLX4_STATE_TIMEOUT;				/* MMP130905-4 - Begin */
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4)
			{
				/* MLX4 LIN-Bus activity check when not in LIN-AA mode (only __MLX_PLTF_VERSION_MAJOR__ == 4) */
				if ( (ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0) )
    77e8:	7009      	lod	A, #9
    77ea:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    77ee:	acff      	cmp	A, #-1
    77f0:	190e      	je	0x780e <_main+0x83c>
    77f2:	62d8 036a 	lod	AL, 0x36a <_LinStatus>
    77f6:	b401      	and	A, #1
    77f8:	190a      	je	0x780e <_main+0x83c>
				{
					/* MLX4 has detected a SYNC field */
					g_u16Mlx4StateCheckCounter = 0;
    77fa:	7000      	lod	A, #0
    77fc:	52d8 010e 	mov	0x10e <_g_u16Mlx4StateCheckCounter>, A
					g_u8ErrorCommBusTimeout = FALSE;
    7800:	6400      	lod	YL, #0
    7802:	46d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, YL
					(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    7806:	7008      	lod	A, #8
    7808:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    780c:	0005      	jmp	0x7818 <_main+0x846>
				}
				else
				{
					g_u16Mlx4StateCheckCounter++;								/* State check counter */
    780e:	72d8 010e 	lod	A, 0x10e <_g_u16Mlx4StateCheckCounter>
    7812:	a001      	add	A, #1
    7814:	52d8 010e 	mov	0x10e <_g_u16Mlx4StateCheckCounter>, A
				}
			}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 4) */

			if ( (g_u16Mlx4StateCheckCounter >= u16Mlx4CounterThreshold) || ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0) ) /* MMP130905-4 - End */
    7818:	72d8 010e 	lod	A, 0x10e <_g_u16Mlx4StateCheckCounter>
    781c:	aeda 03e8 	cmp	A, #1000
    7820:	1c05      	jnc	0x782c <_main+0x85a>
    7822:	62d8 010c 	lod	AL, 0x10c <_g_u8Mlx4ErrorState>
    7826:	8c00      	cmp	AL, #0
    7828:	1a81      	jsl	0x782c <_main+0x85a>
    782a:	0037      	jmp	0x789a <_main+0x8c8>
			{
				/* Didn't receive MLX4 LIN command and/or data-request in the last period, or need immediate reset */
				g_u16Mlx4StateCheckCounter = 0;										/* MLX4 State check counter reset; MLX4 still active */
    782c:	7000      	lod	A, #0
    782e:	52d8 010e 	mov	0x10e <_g_u16Mlx4StateCheckCounter>, A
				if ( ((g_u8Mlx4ErrorState & (uint8) C_MLX4_STATE_IMMEDIATE_RST) != 0) ||
    7832:	62d8 010c 	lod	AL, 0x10c <_g_u8Mlx4ErrorState>
    7836:	8c00      	cmp	AL, #0
    7838:	1a8b      	jsl	0x7850 <_main+0x87e>
    783a:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    783c:	b440      	and	A, #64
    783e:	1d2a      	jne	0x7894 <_main+0x8c2>
    7840:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    7842:	8c06      	cmp	AL, #6
    7844:	1927      	je	0x7894 <_main+0x8c2>
    7846:	7009      	lod	A, #9
    7848:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    784c:	acff      	cmp	A, #-1
    784e:	1d22      	jne	0x7894 <_main+0x8c2>
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 4) */
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
					&& (ml_GetState() == ml_stINVALID) ) )					/* MMP130811-1 */
#endif /*((__MLX_PLTF_VERSION_MAJOR__ == 3) */
		{
			g_u8Mlx4ErrorState++;
    7850:	62d8 010c 	lod	AL, 0x10c <_g_u8Mlx4ErrorState>
    7854:	8001      	add	AL, #1
    7856:	42d8 010c 	mov	0x10c <_g_u8Mlx4ErrorState>, AL
			if ( g_u8Mlx4ErrorState >= (uint8) C_MLX4_STATE_ERROR_THRSHLD )
    785a:	8c03      	cmp	AL, #3
    785c:	1a1e      	jule	0x789a <_main+0x8c8>
			{
				/* Signal Error; Reset MLX4 */
				MLX4_RESET();
    785e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7862:	94fe      	and	AL, #-2
    7864:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				NOP();
    7868:	0000      	nop
				NOP();
    786a:	0000      	nop
				NOP();
    786c:	0000      	nop
				MLX4_START();
    786e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7872:	8401      	or	AL, #1
    7874:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				if ( (g_u8Mlx4ErrorState & C_MLX4_STATE_NOT_LOGGED) == 0 )	/* MMP131126-1 */
    7878:	62d8 010c 	lod	AL, 0x10c <_g_u8Mlx4ErrorState>
    787c:	b440      	and	A, #64
    787e:	1d04      	jne	0x7888 <_main+0x8b6>
				{
					SetLastError( (uint8) C_ERR_MLX4_RESTART);
    7880:	72da 00fa 	lod	A, #250
    7884:	82db 9328 	callf	0x9328 <_SetLastError>
				}
				LIN_Init( TRUE);										/* Re-initialise LIN interface w/o changing position */
    7888:	7001      	lod	A, #1
    788a:	110f      	call	0x7aaa <_LIN_Init>
				g_u8Mlx4ErrorState = 0;
    788c:	6400      	lod	YL, #0
    788e:	46d8 010c 	mov	0x10c <_g_u8Mlx4ErrorState>, YL
    7892:	0003      	jmp	0x789a <_main+0x8c8>
			}
		}
		else
		{
			g_u8Mlx4ErrorState = 0;
    7894:	6000      	lod	AL, #0
    7896:	42d8 010c 	mov	0x10c <_g_u8Mlx4ErrorState>, AL
//--------------------------------------------------------------------------------------------------------------------------------

		/* ********************************** */
		/* *** o. Background System check *** */
		/* ********************************** */
		if ( (u8BackgroundSchedulerTaskID == 0) || (u8BackgroundSchedulerTaskID == 128) )
    789a:	7a1f      	lod	Y, [S-32]
    789c:	1903      	je	0x78a4 <_main+0x8d2>
    789e:	621f      	lod	AL, [S-32]
    78a0:	8c80      	cmp	AL, #-128
    78a2:	1d1a      	jne	0x78d8 <_main+0x906>
		{
#if (LINPROT == LIN2J_VALVE_GM)
			if ( RamBackgroundTest( 0) == FALSE )								/* Check RAM against NVRAM User-page */
#else  /* (LINPROT == LIN2J_VALVE_GM) */
				if ( RamBackgroundTest( u8BackgroundSchedulerTaskID ? 1 : 0) == FALSE )	/* Check RAM against NVRAM User-page #1/#2 */
    78a4:	7000      	lod	A, #0
    78a6:	7a1f      	lod	Y, [S-32]
    78a8:	1901      	je	0x78ac <_main+0x8da>
    78aa:	7001      	lod	A, #1
    78ac:	82db 6d10 	callf	0x6d10 <_RamBackgroundTest>
    78b0:	ac00      	cmp	A, #0
    78b2:	1d0e      	jne	0x78d0 <_main+0x8fe>
#endif /* (LINPROT == LIN2J_VALVE_GM) */
				{
					/* MMP150925-1: RAM g_NvramUser structure not same as NVRAM Page #1.1.
					 * Either System RAM is corrupted or the NVRAM. Allow one time NVRAM reload */
					if ( l_u8RamPreError == FALSE )
    78b4:	62d8 0106 	lod	AL, 0x106 <_l_u8RamPreError>
    78b8:	1d04      	jne	0x78c2 <_main+0x8f0>
					{
						NVRAM_LoadAll();
    78ba:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
						l_u8RamPreError = TRUE;
    78be:	6001      	lod	AL, #1
    78c0:	0008      	jmp	0x78d2 <_main+0x900>
					}
					else
					{
						SetLastError( (uint8) C_ERR_RAM_BG);						/* Log RAM failure */
    78c2:	72da 00f8 	lod	A, #248
    78c6:	82db 9328 	callf	0x9328 <_SetLastError>
#if (LINPROT == LIN2J_VALVE_GM)
						MLX4_RESET();												/* Reset the Mlx4   */
						bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
						MLX16_RESET();												/* Reset the Mlx16  */
#else  /* (LINPROT == LIN2J_VALVE_GM) */
						g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;			/* Permanent electric failure */
    78ca:	6002      	lod	AL, #2
    78cc:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
    78ce:	0011      	jmp	0x78f2 <_main+0x920>
#endif /* (LINPROT == LIN2J_VALVE_GM) */
					}
				}
				else
				{
					l_u8RamPreError = FALSE;										/* Error is gone (caused by wrong NVRAM shadow-RAM) */
    78d0:	6000      	lod	AL, #0
    78d2:	42d8 0106 	mov	0x106 <_l_u8RamPreError>, AL
    78d6:	000d      	jmp	0x78f2 <_main+0x920>
				}
		}
		else if ( (FL_CTRL0 & FL_DETECT) != 0 )									/* MMP150603-2 */
    78d8:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    78dc:	b401      	and	A, #1
    78de:	1909      	je	0x78f2 <_main+0x920>
		{
			if ( FlashBackgroundTest( C_FLASH_SEGMENT_SZ) == C_FLASH_CRC_FAILED )	/* Check Flash/ROM Memory Checksum (max. 250us) */
    78e0:	7004      	lod	A, #4
    78e2:	82db 6d24 	callf	0x6d24 <_FlashBackgroundTest>
    78e6:	ac00      	cmp	A, #0
    78e8:	1d04      	jne	0x78f2 <_main+0x920>
			{
				SetLastError( (uint8) C_ERR_FLASH_BG);
    78ea:	72da 00f9 	lod	A, #249
    78ee:	82db 9328 	callf	0x9328 <_SetLastError>
				bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
				MLX16_RESET();													/* Reset the Mlx16  */
#endif /* (LINPROT == LIN2J_VALVE_GM) */
			}
		}
		u8BackgroundSchedulerTaskID++; 
    78f2:	621f      	lod	AL, [S-32]
    78f4:	8001      	add	AL, #1
    78f6:	5cf2      	usex	A
    78f8:	521f      	mov	[S-32], A
#if _SUPPORT_MLX16_HALT
		/* ************************************* */
		/* *** r. Power-saving (non-running) *** */
		/* ************************************* */
		/* In case MLX4 is inactive, don't enter HALT mode, because the chip enters SLEEP mode which will stop the Core-timer as well */
		if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0) && (g_u8MotorStopDelay == 0) && ((CONTROL & M4_RB) != 0) && (g_u8LinInFrameBufState == C_LIN_IN_FREE) )
    78fa:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    78fc:	b401      	and	A, #1
    78fe:	1901      	je	0x7902 <_main+0x930>
    7900:	0062      	jmp	0x79c6 <_main+0x9f4>
    7902:	6135      	lod	AL, dp:0x35 <_g_u8MotorStopDelay>
    7904:	1901      	je	0x7908 <_main+0x936>
    7906:	005f      	jmp	0x79c6 <_main+0x9f4>
    7908:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    790c:	b401      	and	A, #1
    790e:	1d01      	jne	0x7912 <_main+0x940>
    7910:	005a      	jmp	0x79c6 <_main+0x9f4>
    7912:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
    7916:	1901      	je	0x791a <_main+0x948>
    7918:	0056      	jmp	0x79c6 <_main+0x9f4>
		{
			uint16 u16XI0_Mask = XI0_MASK;
    791a:	7ad8 202a 	lod	Y, 0x202a <__ep__+0x102a>
    791e:	5a09      	mov	[S-10], Y
			uint16 u16IsrMask = MASK;
    7920:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7924:	5207      	mov	[S-8], A
			uint16 u16Timer1Ctrl = TMR1_CTRL;
    7926:	7aaa      	lod	Y, io:0x2a <_g_e8MotorDirectionCCW>
    7928:	5a05      	mov	[S-6], Y

			ADC_PowerOff();														/* Stop ADC, including turning off reference voltage (Approx: 0.6mA) */
    792a:	82db 8ef2 	callf	0x8ef2 <_ADC_PowerOff>
			DRVCFG |= DIS_SHOA;													/* Disable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    792e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7932:	a6da 0400 	or	A, #1024
    7936:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			/* Setup wake-up timer event */
			TMR1_CTRL = (2 * TMRx_DIV0) | (0 * TMRx_MODE0) | TMRx_T_EBLK;		/* Timer mode 0, Divider 256 */
    793a:	72da 8001 	lod	A, #32769
    793e:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
			TMR1_REGB = C_SLEEP_PERIOD;											/* Set sleep-period */
    7940:	7ada 155c 	lod	Y, #5468
    7944:	5aac      	mov	io:0x2c <_g_e8ErrorCoil>, Y
			XI0_PEND = CLR_T1_INT4;												/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    7946:	7040      	lod	A, #64
    7948:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
			XI0_MASK = EN_T1_INT4;												/* Disable Timer1 all 2nd level interrupts, except INT4 (CMP) */
    794c:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
			PEND = CLR_EXT0_IT;
    7950:	7ada 0100 	lod	Y, #256
    7954:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y
			MASK = EN_EXT4_IT | EN_EXT0_IT | EN_M4_SHE_IT;						/* Enable Diagnostics, Timer1 and MLX4 IRQ's only */
    7958:	72da 1110 	lod	A, #4368
    795c:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
			TMR1_CTRL = (2 * TMRx_DIV0) | (0 * TMRx_MODE0) | TMRx_T_EBLK | TMRx_START;	/* Start timer */
    7960:	7ada 8003 	lod	Y, #32771
    7964:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
			 * the LinInFrameBufState check and before the actual entering of
			 * the HALT-state. The LIN message is not lost, but delayed by the
			 * HALT time-out period. Below code blocks the IRQ's (post-pone)
			 * until the MLX16 enters HALT-state.
			 */
			__asm__("psup #0");													/* Block IRQ's */
    7966:	54d0      	psup	#0
			__asm__("lod AL, _g_u8LinInFrameBufState");							/* Check for LIN message received */
    7968:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
			__asm__("jne _HALT_10");											/* Skip HALT in case LIN message received */
    796c:	1d0b      	jne	0x7984 <_main+0x9b2>
			__asm__("lod X, #_au16HaltZero");									/* X pointer to flash memory with 0x0000 (MMP150224-2) */
    796e:	7eda aad8 	lod	X, #43736
			__asm__("lod AL, 0x2000");											/* Get MLX16 Control-state */
    7972:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
			__asm__("or  AL, #0x02");											/* Set HALT-state */
    7976:	8402      	or	AL, #2
			__asm__("mov R, #0");												/* Restore IRQ-state */
    7978:	4407      	mov	R, #0
			__asm__("pop M");
    797a:	72cb      	pop	M
			__asm__("mov 0x2000, AL");											/* Enter HALT-state */
    797c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			__asm__("mov A,[X]");												/* MMP150224-2 */
    7980:	72f8      	lod	A, [X]
			__asm__("jmp _HALT_20");											/* Leave HALT-state */
    7982:	0002      	jmp	0x7988 <_main+0x9b6>
			__asm__("_HALT_10:");
			__asm__("mov R, #0");
    7984:	4407      	mov	R, #0
			__asm__("pop M");
    7986:	72cb      	pop	M
			__asm__("_HALT_20:");

			DRVCFG &= ~DIS_SHOA;												/* Enable OpAmp for ADC measurement of shunt current (Approx: 0.6mA) */
    7988:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    798c:	b6da fbff 	and	A, #64511
    7990:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

			{
				uint16 u16TimerCnt = TMR1_CNT;									/* Take a copy of the Timer-count value */
    7994:	72b0      	lod	A, io:0x30 <_g_u8BufferOutID>
    7996:	5203      	mov	[S-4], A
				TMR1_CTRL = u16Timer1Ctrl & ~TMRx_START;						/* Stop Timer */
    7998:	7205      	lod	A, [S-6]
    799a:	b4fd      	and	A, #-3
    799c:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
				XI0_PEND = u16XI0_Mask;											/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    799e:	7a09      	lod	Y, [S-10]
    79a0:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
				XI0_MASK = u16XI0_Mask;											/* Restore Timer1 interrupt mask */
    79a4:	5ad8 202a 	mov	0x202a <__ep__+0x102a>, Y
				PEND = CLR_EXT0_IT;
    79a8:	72da 0100 	lod	A, #256
    79ac:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
				MASK = u16IsrMask;												/* Restore 1st level interrupt mask */
    79b0:	7a07      	lod	Y, [S-8]
    79b2:	5ad8 2006 	mov	0x2006 <__ep__+0x1006>, Y

				if ( g_u8MotorHoldingCurrState != FALSE )
    79b6:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    79ba:	1902      	je	0x79c0 <_main+0x9ee>
							l_u16AdcHoldMode = (l_u16AdcHoldMode + 1);
						}
					}
					ADC_Start( l_u16AdcHoldMode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					ADC_Start();
    79bc:	82db 8ec2 	callf	0x8ec2 <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				Timer_SleepCompensation( u16TimerCnt);							/* Compensate Timer counters for sleep-period */
    79c0:	7203      	lod	A, [S-4]
    79c2:	82db a91a 	callf	0xa91a <_Timer_SleepCompensation>

#if _SUPPORT_IOREG_CHECK
		/* ************************************ */
		/* *** s. Critical peripheral check *** */
		/* ************************************ */
		if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_APPL_STOP) == 0x00 )	/* If application is NOT stopped ... */
    79c6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    79c8:	b440      	and	A, #64
    79ca:	1901      	je	0x79ce <_main+0x9fc>
    79cc:	006a      	jmp	0x7aa2 <_main+0xad0>
		{
			/* Check: Motor commutation timer disabled */
			if ( (TMR1_CTRL & TMRx_T_EBLK) == 0 )
    79ce:	72aa      	lod	A, io:0x2a <_g_e8MotorDirectionCCW>
    79d0:	b401      	and	A, #1
    79d2:	1d0e      	jne	0x79f0 <_main+0xa1e>
			{
				/* Communication timer is disabled; Motor is stopped too */
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    79d4:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    79d6:	b401      	and	A, #1
    79d8:	1904      	je	0x79e2 <_main+0xa10>
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;					/* Start timer mode 0 */
    79da:	72da 4003 	lod	A, #16387
    79de:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
    79e0:	0003      	jmp	0x79e8 <_main+0xa16>
				}
				else
				{
					TMR1_CTRL = C_TMRx_CTRL_MODE0;								/* Timer mode 0 */
    79e2:	7ada 4001 	lod	Y, #16385
    79e6:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
				}
				SetLastError( (uint8) C_ERR_IOREG);
    79e8:	72da 00fc 	lod	A, #252
    79ec:	82db 9328 	callf	0x9328 <_SetLastError>
			}
			/* Check: Administrative timer disabled */
			if ( (TIMER & TMR_EN) == 0 )							
    79f0:	7286      	lod	A, io:0x6 <_LinMess2>
    79f2:	ac00      	cmp	A, #0
    79f4:	1a87      	jsl	0x7a04 <_main+0xa32>
			{
				TIMER = TMR_EN | CT_PERIODIC_RATE;
    79f6:	72da 81f4 	lod	A, #33268
    79fa:	5286      	mov	io:0x6 <_LinMess2>, A
				SetLastError( (uint8) C_ERR_IOREG);
    79fc:	72da 00fc 	lod	A, #252
    7a00:	82db 9328 	callf	0x9328 <_SetLastError>
			}
			/* Check: IRQ-Mask (Respectively: Diagnostics, Timer1, CoreTimer and LIN-Communication */
			if ( (MASK & (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT)) != (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT) )
    7a04:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7a08:	b6da 1130 	and	A, #4400
    7a0c:	aeda 1130 	cmp	A, #4400
    7a10:	190e      	je	0x7a2e <_main+0xa5c>
			{
				PEND = (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7a12:	7ada 1130 	lod	Y, #4400
    7a16:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y
				MASK |= (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7a1a:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7a1e:	a6da 1130 	or	A, #4400
    7a22:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a26:	72da 00fc 	lod	A, #252
    7a2a:	82db 9328 	callf	0x9328 <_SetLastError>
			}
			/* Check: IRQ-priority (Respectively: Diagnostics, Timer1, CoreTimer) */
			if ( (PRIO & ((3u << 14) | (3u << 6) | (3u << 0))) != (/*((3-3) << 14) |*/ ((4-3) << 6) | ((6-3) << 0)) )
    7a2e:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7a32:	b6da c0c3 	and	A, #49347
    7a36:	ac43      	cmp	A, #67
    7a38:	190b      	je	0x7a50 <_main+0xa7e>
			{
				PRIO = (PRIO & ~((3u << 14) | (3u << 6) | (3u << 0))) | (/*((3-3) << 14) |*/ ((4-3) << 6) | ((6-3) << 0));
    7a3a:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7a3e:	b6da 3f3c 	and	A, #16188
    7a42:	a443      	or	A, #67
    7a44:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a48:	72da 00fc 	lod	A, #252
    7a4c:	82db 9328 	callf	0x9328 <_SetLastError>
			}
			/* Check: 2nd level IRQ Timer1 */
			if ( (XI0_MASK & EN_T1_INT4) == 0 )
    7a50:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    7a54:	b440      	and	A, #64
    7a56:	1d09      	jne	0x7a6a <_main+0xa98>
			{
				XI0_PEND = EN_T1_INT4;
    7a58:	7040      	lod	A, #64
    7a5a:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
				XI0_MASK = EN_T1_INT4;
    7a5e:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
				SetLastError( (uint8) C_ERR_IOREG);
    7a62:	72da 00fc 	lod	A, #252
    7a66:	82db 9328 	callf	0x9328 <_SetLastError>
			}
			/* Check: 2nd level IRQ Diagnostics */
			if ( (XI4_MASK & (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV)) != C_DIAG_MASK )
    7a6a:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    7a6e:	b6da e100 	and	A, #57600
    7a72:	aeda e100 	cmp	A, #57600
    7a76:	190a      	je	0x7a8c <_main+0xaba>
			{
				XI4_PEND = C_DIAG_MASK;											/* MMP150409-1 */
    7a78:	7ada e100 	lod	Y, #57600
    7a7c:	5ad8 203c 	mov	0x203c <__ep__+0x103c>, Y
				XI4_MASK = C_DIAG_MASK;											/* MMP150409-1 */
    7a80:	5ad8 2032 	mov	0x2032 <__ep__+0x1032>, Y
				SetLastError( (uint8) C_ERR_IOREG);
    7a84:	72da 00fc 	lod	A, #252
    7a88:	82db 9328 	callf	0x9328 <_SetLastError>
			{
				ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
				SetLastError( (uint8) C_ERR_IOREG);
			}
#endif /* 0 */
			if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) && ((DRVCFG & (DRV_CFG_T|DRV_CFG_W|DRV_CFG_V|DRV_CFG_U)) == 0) )
    7a8c:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7a8e:	b401      	and	A, #1
    7a90:	1908      	je	0x7aa2 <_main+0xad0>
    7a92:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7a96:	8c00      	cmp	AL, #0
    7a98:	1d04      	jne	0x7aa2 <_main+0xad0>
			{
				/* Driver have been disabled */
				SetLastError( (uint8) C_ERR_IOREG);
    7a9a:	72da 00fc 	lod	A, #252
    7a9e:	82db 9328 	callf	0x9328 <_SetLastError>
			}
		}
#endif /* _SUPPORT_IOREG_CHECK */

		//DiagnosticCheck();//Ban
		RteExv2Lin();
    7aa2:	82db 6e2a 	callf	0x6e2a <_RteExv2Lin>
#endif /* _SUPPORT_DIG_LIN */

	/* ******************************** */
	/* *** U. Main application loop *** */
	/* ******************************** */
	for(;;)
    7aa6:	76da 718a 	jmpf	0x718a <_main+0x1b8>

00007aaa <_LIN_Init>:
 *
 * Initialise LIN communication interface.
 * Default start-up, at 9600 Baud
 * ****************************************************************************	*/
void LIN_Init( uint16 u16WarmStart)
{
    7aaa:	5801      	inc	S, #2
    7aac:	5201      	mov	[S-2], A
	/* Initialise LIN Communication */
	LIN_XCFG &= ~DISTERM;														/* Enable LIN pull-up resistor (MMP150811-2) */
    7aae:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7ab0:	b4fb      	and	A, #-5
    7ab2:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A
	(void) ml_InitLinModule();													/* Initialise the LIN module */
    7ab4:	82db 5e0c 	callf	0x5e0c <_ml_InitLinModule>
#if (_SUPPORT_AUTO_BAUDRATE != FALSE)
	/* Auto baudrate only on first LIN frame */
	(void) ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);						/* MMP141215-1 */
#else  /* (_SUPPORT_AUTO_BAUDRATE != FALSE) */
	/* Fixed baudrate */
	(void) ml_SetBaudRate( (ml_uint8) LIN_BR_PRESCALER, (ml_uint8)LIN_BR_DIV);	/* Program the baudrate : default startup : 9600baud @ 20.0 Mhz	*/
    7ab8:	54ca 00b6 	pushw	#182
    7abc:	7002      	lod	A, #2
    7abe:	82db 5b8e 	callf	0x5b8e <_ml_SetBaudRate>
						  ML_ENABLED,											/* StateChangeSignal */
						  1,													/* Light-sleep mode with timeout */
						  ML_SLEWHIGH);											/* SlewRate: ML_SLEWHIGH=20kbps / ML_SLEWLOW=10kbps */
#endif /* ((LIN_BR < 10000) && (_SUPPORT_AUTO_BAUDRATE == FALSE)) */
#elif (__MLX_PLTF_VERSION_MAJOR__ == 4)
	(void) ml_SetOptions( 1U,													/* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    7ac2:	54ca 0000 	pushw	#0
    7ac6:	54ca 0001 	pushw	#1
    7aca:	54ca 0000 	pushw	#0
    7ace:	7001      	lod	A, #1
    7ad0:	82db 5ae0 	callf	0x5ae0 <_ml_SetOptions>
						  ML_LIGHTSLEEP);										/* SleepMode: light-sleep mode */

#if ((LIN_BR < 12000) && (_SUPPORT_AUTO_BAUDRATE == FALSE))
	(void) ml_SetSlewRate( ML_SLEWLOW);
#else /* ((LIN_BR < 10000) && (_SUPPORT_AUTO_BAUDRATE == FALSE)) */
	(void) ml_SetSlewRate( ML_SLEWHIGH);
    7ad4:	7000      	lod	A, #0
    7ad6:	82db 5ad8 	callf	0x5ad8 <_ml_SetSlewRate>
	(void) ml_EnableFilter( 0);													/* Enable filter */
#endif

	/* Initialise communication layer */
#if ((LINPROT & LINXX) == LIN2X)
	LIN_2x_Init( u16WarmStart);
    7ada:	7209      	lod	A, [S-10]
    7adc:	1225      	call	0x7f28 <_LIN_2x_Init>

#if ((LINPROT & LINXX) == LIN2J)
	LIN_SAE_J2602_Init( u16WarmStart);
#endif /* ((LINPROT & LINXX) == LIN2J) */

	(void) ml_Connect();
    7ade:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
	g_u8ErrorCommBusTimeout = FALSE;
    7ae2:	6000      	lod	AL, #0
    7ae4:	42d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, AL
    7ae8:	5c07      	dec	S, #8
    7aea:	5403      	ret	#4

00007aec <_mlu_ApplicationStop>:
 *  LIN API event: mlu_ApplicationStop
 * ****************************************************************************	*/
ml_Status mlu_ApplicationStop(void)
{
	/* Stop motor (e.g. disconnect drivers) */
	MotorDriverStop( (uint16) C_STOP_IMMEDIATE);								/* Application stop */
    7aec:	7001      	lod	A, #1
    7aee:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
	SetLastError( (uint8) C_ERR_APPL_STOP);
    7af2:	72da 00a8 	lod	A, #168
    7af6:	82db 9328 	callf	0x9328 <_SetLastError>

	/* Disable all IRQ's, except LIN */
	XI0_MASK = 0;
    7afa:	7000      	lod	A, #0
    7afc:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	XI1_MASK = 0;
    7b00:	52d8 202c 	mov	0x202c <__ep__+0x102c>, A
	XI2_MASK = 0;
    7b04:	52d8 202e 	mov	0x202e <__ep__+0x102e>, A
	XI3_MASK = 0;
    7b08:	52d8 2030 	mov	0x2030 <__ep__+0x1030>, A
	XI4_MASK = 0;
    7b0c:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	MASK = EN_M4_SHE_IT;														/* Disable all interrupts, except LIN M4_SHE_IT */
    7b10:	7010      	lod	A, #16
    7b12:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_APPL_STOP;					/* Don't perform periodic MLX4 Status checks */
    7b16:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7b18:	8440      	or	AL, #64
    7b1a:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL

	return ( ML_SUCCESS );														/* Return that the application has stopped */
} /* End of mlu_ApplicationStop */
    7b1c:	7000      	lod	A, #0
    7b1e:	5401      	ret

00007b20 <_ml_GetAutoaddressingStatus>:

	g_u8AdcIsrMode = (uint8) C_ADC_ISR_NONE;									/* Set switch ADC off */
#endif /* (LINAA_BSM_SNPD_R1p0 == FALSE) */

	/* the slave is addressed in this cylce if the flag in step 6 is set */
	if ( g_u8AutoAddressingFlags & LASTSLAVE )
    7b20:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
	{
		return ( 1 );
    7b22:	5ce2      	ssex	A
    7b24:	4442      	rl	A
    7b26:	b401      	and	A, #1
	}
	else
	{
		return ( 0 );
	}
} /* End of ml_GetAutoaddressingstatus() */
    7b28:	5401      	ret

00007b2a <_mlu_DataRequest>:
/* ****************************************************************************	*
 *  LIN API event: Data Request (slave TX)
 * ****************************************************************************	*/
void mlu_DataRequest( ml_MessageID MessageID) 
{
	g_u8ErrorCommBusTimeout = FALSE;											/* Data requested; No longer Bus time-out */
    7b2a:	6400      	lod	YL, #0
    7b2c:	46d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, YL
	g_u8EmergencyRunOcc = FALSE;//clear emergency run flag,Ban
    7b30:	4527      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, YL

#if ((LINPROT & LINXX) == LIN2X)
	if ( MessageID == (uint8) mlxRFR_DIAG )
    7b32:	8c11      	cmp	AL, #17
    7b34:	1d14      	jne	0x7b5e <_mlu_DataRequest+0x34>
	{
		/* Diagnostic */
		if ( g_u8BufferOutID == (uint8) QR_RFR_DIAG )
    7b36:	6130      	lod	AL, dp:0x30 <_g_u8BufferOutID>
    7b38:	8c07      	cmp	AL, #7
    7b3a:	1d0e      	jne	0x7b58 <_mlu_DataRequest+0x2e>
		{
			/* Copy g_DiagResponse to LinFrameDataBuffer */
			RFR_DIAG *pDiag = &g_DiagResponse;
			uint16 *src = (uint16 *) pDiag;
			uint16 *dst = (uint16 *) LinFrameDataBuffer;
			dst[0] = src[0];
    7b3c:	7142      	lod	A, dp:0x42 <_g_DiagResponse>
    7b3e:	51ca      	mov	dp:0xca <_LinFrameDataBuffer>, A
			dst[1] = src[1];
    7b40:	7944      	lod	Y, dp:0x44 <_g_DiagResponse+0x2>
    7b42:	59cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, Y
			dst[2] = src[2];
    7b44:	7146      	lod	A, dp:0x46 <_g_DiagResponse+0x4>
    7b46:	51ce      	mov	dp:0xce <_LinFrameDataBuffer+0x4>, A
			dst[3] = src[3];
    7b48:	7948      	lod	Y, dp:0x48 <_g_DiagResponse+0x6>
    7b4a:	59d0      	mov	dp:0xd0 <_LinFrameDataBuffer+0x6>, Y

			(void) ml_DataReady( ML_END_OF_TX_DISABLED);
    7b4c:	7000      	lod	A, #0
    7b4e:	82db 5aa4 	callf	0x5aa4 <_ml_DataReady>
			g_u8BufferOutID = (uint8) QR_INVALID;								/* Invalidate LIN output buffer */
    7b52:	60ff      	lod	AL, #-1
    7b54:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
    7b56:	0006      	jmp	0x7b64 <_mlu_DataRequest+0x3a>
		}
		else
		{
			(void) ml_DiscardFrame();											/* Output buffer response doesn't match requested response */
    7b58:	82db 5af6 	callf	0x5af6 <_ml_DiscardFrame>
    7b5c:	0003      	jmp	0x7b64 <_mlu_DataRequest+0x3a>
		}
	}
#if (LINPROT == LIN2X_ACT44)
	else if ( MessageID == MSG_STATUS )
    7b5e:	8c02      	cmp	AL, #2
    7b60:	1d01      	jne	0x7b64 <_mlu_DataRequest+0x3a>
	{
		HandleActStatus();														/* Handle HVAC or AGS Status */
    7b62:	1270      	call	0x8044 <_HandleActStatus>
	(void) ml_ReleaseBuffer();													/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
#endif /* ((LINPROT & LINXX) == LIN2J) */

#if ((LINPROT & LINXX) == LIN2X)												/* MMP140414-1 */
	if ( g_u8LinAAMode != 0 )
    7b64:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    7b68:	1901      	je	0x7b6c <_mlu_DataRequest+0x42>
	{
		(void)ml_GetAutoaddressingStatus();
    7b6a:	17da      	call	0x7b20 <_ml_GetAutoaddressingStatus>
    7b6c:	5401      	ret

00007b6e <_mlu_DataTransmitted>:

/* ****************************************************************************	*
 *  LIN API event: mlu_DataTransmitted
 * ****************************************************************************	*/
void mlu_DataTransmitted(void) 
{
    7b6e:	5401      	ret

00007b70 <_mlu_ErrorDetected>:

/* ****************************************************************************	*
 *  LIN API event: mlu_ErrorDetected
 * ****************************************************************************	*/
void mlu_ErrorDetected( ml_LinError Error)
{
    7b70:	5801      	inc	S, #2
    7b72:	5201      	mov	[S-2], A
	SetLastError( (uint8) C_ERR_LIN_COMM | ((uint8)Error & 0x1F));
    7b74:	a6da 0080 	or	A, #128
    7b78:	b6da 009f 	and	A, #159
    7b7c:	82db 9328 	callf	0x9328 <_SetLastError>
#if (LINPROT == LIN2X_ACT44)
	LIN2x_ErrorHandling( Error);
    7b80:	7201      	lod	A, [S-2]
    7b82:	1314      	call	0x81ac <_LIN2x_ErrorHandling>
		default :																/* Unrecognised error                                        */
			break;
	}
#endif /* (LINPROT == LIN2X_ACT44) */
#if ((LINPROT & LINXX) == LIN2X)												/* MMP140414-1 */
	if ( g_u8LinAAMode != 0 )
    7b84:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    7b88:	1901      	je	0x7b8c <_mlu_ErrorDetected+0x1c>
	{
		(void)ml_GetAutoaddressingStatus();
    7b8a:	17ca      	call	0x7b20 <_ml_GetAutoaddressingStatus>
    7b8c:	5403      	ret	#4

00007b8e <_mlu_LinSleepMode>:
{
	/*
	 * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
	 * and does not report it via mlu_MessageReceived event.
	 */
	if ( (Reason == ml_reasonMaster) || (Reason == ml_reasonCommand) )			/* MMP130918-1 */
    7b8e:	7ae2      	lod	Y, A
    7b90:	a0ff      	add	A, #-1
    7b92:	ac01      	cmp	A, #1
    7b94:	1e02      	jug	0x7b9a <_mlu_LinSleepMode+0xc>
	{
		{
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    7b96:	6006      	lod	AL, #6
    7b98:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
		}
	}

	if ( (Reason == ml_reasonTimeOut) || (Reason == ml_reasonTimeOutDominant) )
    7b9a:	72e6      	lod	A, Y
    7b9c:	a0fa      	add	A, #-6
    7b9e:	ac01      	cmp	A, #1
    7ba0:	1e01      	jug	0x7ba4 <_mlu_LinSleepMode+0x16>
		/*
		 * LIN bus was inactive for 4 seconds without receiving an explicit
		 * "Go-to-Sleep frame". This can be considered as a failure of the Master or
		 * PHY layer. Slave can enter limp-home mode.
		 */
		HandleBusTimeout();
    7ba2:	12e0      	call	0x8164 <_HandleBusTimeout>
    7ba4:	5401      	ret

00007ba6 <_mlu_MessageReceived>:

/* ****************************************************************************	*
 *  LIN API event: MessageReceived (slave RX)
 * ****************************************************************************	*/
void mlu_MessageReceived( ml_MessageID byMessageID)
{
    7ba6:	7ae2      	lod	Y, A
	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_FULL )
    7ba8:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
    7bac:	8c01      	cmp	AL, #1
    7bae:	1911      	je	0x7bd2 <_mlu_MessageReceived+0x2c>
	{
		/* Buffer is either empty or message is postpone (overwrite allowed) */
		l_u8LinInFrameMsgID = byMessageID;
    7bb0:	454a      	mov	dp:0x4a <_l_u8LinInFrameMsgID>, YL

		/* LIN In-frame buffer to a Copy LIN In-frame buffer */
		{
			uint16 *pu16Source = (uint16 *) LinFrameDataBuffer;
			uint16 *pu16Target = (uint16 *) &g_LinCmdFrameBuffer;
			*pu16Target = *pu16Source;
    7bb2:	71ca      	lod	A, dp:0xca <_LinFrameDataBuffer>
    7bb4:	513a      	mov	dp:0x3a <__data_dp_end>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7bb6:	71cc      	lod	A, dp:0xcc <_LinFrameDataBuffer+0x2>
    7bb8:	513c      	mov	dp:0x3c <__data_dp_end+0x2>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7bba:	71ce      	lod	A, dp:0xce <_LinFrameDataBuffer+0x4>
    7bbc:	513e      	mov	dp:0x3e <__data_dp_end+0x4>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7bbe:	71d0      	lod	A, dp:0xd0 <_LinFrameDataBuffer+0x6>
    7bc0:	5140      	mov	dp:0x40 <__data_dp_end+0x6>, A
		}
#if (__MLX_PLTF_VERSION_MAJOR__ == 3)
		(void) ml_ReleaseBuffer();												/* See MELEXIS doc */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7bc2:	6001      	lod	AL, #1
    7bc4:	42d8 0122 	mov	0x122 <_g_u8LinInFrameBufState>, AL
		g_u8ErrorCommBusTimeout = FALSE;										/* Frame received; No longer Bus time-out */
    7bc8:	6000      	lod	AL, #0
    7bca:	42d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, AL
		g_u8EmergencyRunOcc = FALSE;//clear emergency run flag,Ban
    7bce:	4127      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, AL
		LinFrame[0] = 0x00;														/* Clear NAD address */
    7bd0:	4108      	mov	dp:0x8 <__bist_stat_size>, AL
    7bd2:	5401      	ret

00007bd4 <_HandleLinInMsg>:
	}
} /* End of mlu_MessageReceived() */

void HandleLinInMsg( void)
{
	if ( g_u8LinInFrameBufState == (uint8) C_LIN_IN_POSTPONE )
    7bd4:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
    7bd8:	8c02      	cmp	AL, #2
    7bda:	1d03      	jne	0x7be2 <_HandleLinInMsg+0xe>
	{
		/* Last message postponed; Try again (without overwritten by LIN message ISR */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7bdc:	6001      	lod	AL, #1
    7bde:	42d8 0122 	mov	0x122 <_g_u8LinInFrameBufState>, AL
	}

#if ((LINPROT & LINXX) == LIN2X)												/* LIN 2.x */
	if ( l_u8LinInFrameMsgID == (uint8) mlxDFR_DIAG )
    7be2:	614a      	lod	AL, dp:0x4a <_l_u8LinInFrameMsgID>
    7be4:	8c10      	cmp	AL, #16
    7be6:	1d02      	jne	0x7bec <_HandleLinInMsg+0x18>
	{
		/* Diagnostic */
		HandleDfrDiag();
    7be8:	1341      	call	0x826c <_HandleDfrDiag>
    7bea:	0003      	jmp	0x7bf2 <_HandleLinInMsg+0x1e>
	}
#if (LINPROT == LIN2X_ACT44)													/* LIN 2.x - HVAC Actuator 4.4 or (Valeo) AGS 13 */
	else if ( l_u8LinInFrameMsgID == (uint8) MSG_CONTROL )
    7bec:	8c01      	cmp	AL, #1
    7bee:	1d01      	jne	0x7bf2 <_HandleLinInMsg+0x1e>
	{
		/* Control */
#if (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE)										/* MMP150125-1 - Begin */
		HandleActCtrl( FALSE);
#else  /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */
		HandleActCtrl();
    7bf0:	11b9      	call	0x7f64 <_HandleActCtrl>
		HandleActCfrCtrl();
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */
#endif /* ((LINPROT & LINXX) == LIN2J) */

	if ( g_u8LinInFrameBufState != (uint8) C_LIN_IN_POSTPONE )
    7bf2:	62d8 0122 	lod	AL, 0x122 <_g_u8LinInFrameBufState>
    7bf6:	8c02      	cmp	AL, #2
    7bf8:	1903      	je	0x7c00 <_HandleLinInMsg+0x2c>
	{
		/* LIN Message is handled; Release LIN message buffer */
		g_u8LinInFrameBufState = (uint8) C_LIN_IN_FREE;
    7bfa:	6000      	lod	AL, #0
    7bfc:	42d8 0122 	mov	0x122 <_g_u8LinInFrameBufState>, AL
	}

#if ((LINPROT & LINXX) == LIN2X)												/* MMP140414-1 */
	if ( g_u8LinAAMode != 0 )
    7c00:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    7c04:	1901      	je	0x7c08 <_HandleLinInMsg+0x34>
	{
		(void)ml_GetAutoaddressingStatus();
    7c06:	178c      	call	0x7b20 <_ml_GetAutoaddressingStatus>
    7c08:	5401      	ret

00007c0a <_ml_AutoAddressingCfgADC>:
 * 2. Differential-mode current measurement (8x)
 * ****************************************************************************	*/
void ml_AutoAddressingCfgADC( void)
{
	/* switch off the ADC */
	ADC_CTRL = 0x00;
    7c0a:	7000      	lod	A, #0
    7c0c:	5290      	mov	io:0x10 <__dp_noinit_size>, A

	/* Enable ADC IRQ */
	PEND = CLR_ADC_IT;
    7c0e:	7040      	lod	A, #64
    7c10:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_ADC_IT;
    7c14:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7c18:	a440      	or	A, #64
    7c1a:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

	/* Set AdcCtrl to start CM, continuous */
	ADC_CTRL = ADC_TRIG_SRC | ADC_SYNC_SOC;										/* Sync ADC with Timer, skip first pulse */
    7c1e:	72da 0082 	lod	A, #130
    7c22:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    7c24:	5401      	ret

00007c26 <_mlu_AutoAddressingStep>:
#define LINAA_TIMER_STOP()			{TMR2_CTRL = (0 * TMRx_DIV0) | (0 * TMRx_MODE0) | TMRx_T_EBLK;}
#define LINAA_TIMER_PERIOD(p)		{TMR2_REGB = p;}
#define LINAA_TIMER_IRQ_DIS()		{BEGIN_CRITICAL_SECTION(); MASK &= ~EN_EXT1_IT; END_CRITICAL_SECTION();}

void mlu_AutoAddressingStep( ml_uint8 StepNumber)
{
    7c26:	5803      	inc	S, #4
    7c28:	5203      	mov	[S-4], A
#if (LINAA_BSM_SNPD_R1p0 == FALSE)
	l_u8AutoAddressingPulse = StepNumber;
#else  /* (LINAA_BSM_SNPD_R1p0 == FALSE) */
	if ( StepNumber == 1 )
    7c2a:	8c01      	cmp	AL, #1
    7c2c:	1d20      	jne	0x7c6e <_mlu_AutoAddressingStep+0x48>
	{
		/* *** Step 0: Setup LIN-AA for current-offset measurement *** */
		/* configure Auto addressing hardware cell on all slaves*/
		LIN_XCFG |= DISTERM;													/* Disable LIN pull-up resistor */
    7c2e:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7c30:	a404      	or	A, #4
    7c32:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A
		ANA_OUTH = 0x0000;														/* Reset at start */
    7c34:	7000      	lod	A, #0
    7c36:	52d8 28ce 	mov	0x28ce <__io__+0xce>, A
		ANA_OUTH = EN_LIN_AGC | ((0 << 3) & TRIM_LIN_CS) | (0 & SEL_LIN_CS);	/* Enable LIN shunt measurement, zero-current measurement */
    7c3a:	7c40      	lod	X, #64
    7c3c:	5ed8 28ce 	mov	0x28ce <__io__+0xce>, X
		{
			uint8 u8AutoAddressingFlags = g_u8AutoAddressingFlags;
    7c40:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
			u8AutoAddressingFlags &= (uint8) ~(SLAVEFINALSTEP | LASTSLAVE);		/* LASTSLAVE flag is cleared */
    7c42:	b47d      	and	A, #125
			g_u8AutoAddressingFlags = u8AutoAddressingFlags;
    7c44:	4131      	mov	dp:0x31 <_g_u8AutoAddressingFlags>, AL

			if ( (u8AutoAddressingFlags & SLAVEADDRESSED) == 0 )
    7c46:	b401      	and	A, #1
    7c48:	1901      	je	0x7c4c <_mlu_AutoAddressingStep+0x26>
    7c4a:	0099      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
			{
				/* Configure LIN-AA Timer to be used for ADC LIN shunt current measurement. */
				LINAA_TIMER_SETUP();											/* Setup LIN-AA Timer: Divider = 1, Mode = 0 (Timer Mode) */
    7c4c:	7001      	lod	A, #1
    7c4e:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A
				LINAA_TIMER_PERIOD( l_u16LinAATimerPeriod);
    7c50:	72d8 0262 	lod	A, 0x262 <_l_u16LinAATimerPeriod>
    7c54:	52b4      	mov	io:0x34 <_l_u8VTIdx>, A

				ml_AutoAddressingCfgADC();										/* Setup LIN-shunt current measurement */
    7c56:	17d9      	call	0x7c0a <_ml_AutoAddressingCfgADC>

#if ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE))
				pSNPD_Data = LIN_AA_DATA + l_u8SNPD_CycleCount;
    7c58:	62d8 0260 	lod	AL, 0x260 <_l_u8SNPD_CycleCount>
    7c5c:	44a2      	asl	A, #2
    7c5e:	44a2      	asl	A, #2
    7c60:	b6da 0ff0 	and	A, #4080
    7c64:	a2da 0160 	add	A, #352
    7c68:	52d8 0264 	mov	0x264 <_pSNPD_Data>, A
    7c6c:	0088      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
#endif /* ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE)) */
			}
		}
	}
	else if ( (g_u8AutoAddressingFlags & SLAVEADDRESSED) == 0 )
    7c6e:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7c70:	b401      	and	A, #1
    7c72:	1901      	je	0x7c76 <_mlu_AutoAddressingStep+0x50>
    7c74:	0084      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
	{
		if ( StepNumber == 2 )
    7c76:	6203      	lod	AL, [S-4]
    7c78:	8c02      	cmp	AL, #2
    7c7a:	1d0b      	jne	0x7c92 <_mlu_AutoAddressingStep+0x6c>
#define C_TEMP_STABIL_TIMEOUT				C_PI_TICKS_250MS					/* Temperature interval of 250ms */
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
    7c7c:	7ed8 011e 	lod	X, 0x11e <_l_u16SlowBaudrateAdjustment>
	for (; u16DelayCount > 0; u16DelayCount-- )
    7c80:	1902      	je	0x7c86 <_mlu_AutoAddressingStep+0x60>
	{
		NOP();
    7c82:	0000      	nop
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    7c84:	1bfe      	djnz	X, 0x7c82 <_mlu_AutoAddressingStep+0x5c>
		{
			/* *** Step 1: Perform current-offset measurement *** */
			NopDelay( l_u16SlowBaudrateAdjustment); /*lint !e522 */

			/* Test-module: No ADC-measurement, only current source */
			ADC_CTRL = (ADC_TRIG_SRC | ADC_SYNC_SOC | ADC_START);				/* MMP140812-1 */
    7c86:	7eda 0083 	lod	X, #131
    7c8a:	5e90      	mov	io:0x10 <__dp_noinit_size>, X
			LINAA_TIMER_START();												/* Start LIN-shunt current measurement (LIN-AA Timer) */
    7c8c:	7003      	lod	A, #3
    7c8e:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A
    7c90:	0076      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
		}
		else if ( StepNumber == 3 )
    7c92:	6203      	lod	AL, [S-4]
    7c94:	8c03      	cmp	AL, #3
    7c96:	1d0e      	jne	0x7cb4 <_mlu_AutoAddressingStep+0x8e>
		{
			/* *** Step 2: Setup for pull-up LIN-shunt current measurement *** */
			if ( l_u16SlowBaudrateAdjustment )
    7c98:	72d8 011e 	lod	A, 0x11e <_l_u16SlowBaudrateAdjustment>
    7c9c:	1903      	je	0x7ca4 <_mlu_AutoAddressingStep+0x7e>
    7c9e:	7c38      	lod	X, #56
	{
		NOP();
    7ca0:	0000      	nop
    7ca2:	1bfe      	djnz	X, 0x7ca0 <_mlu_AutoAddressingStep+0x7a>
			}

			/* Setup 2nd current measurement; Either enable pull-up or enable current-source of 1.12mA */
#if (FORCE_LINAA_OLD != FALSE)
			/* switch on LIN Pull up resistor */
			LIN_XCFG &= ~DISTERM;												/* Enable LIN pull-up resistor (LIN 1.3/Cooling) */
    7ca4:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7ca6:	b4fb      	and	A, #-5
    7ca8:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A
				ANA_OUTH = EN_LIN_AGC | (CalibrationParams.EE_ANA_OUTH_112_205 & (TRIM_LIN_CS | SEL_LIN_CS));
			}
#endif /* (FORCE_LINAA_OLD != FALSE) */

			/* Normal slave module */
			l_i16Ishunt1 = l_i16Ishunt;
    7caa:	7ed8 0266 	lod	X, 0x266 <_l_i16Ishunt>
    7cae:	5ed8 0268 	mov	0x268 <_l_i16Ishunt1>, X
    7cb2:	0043      	jmp	0x7d3a <_mlu_AutoAddressingStep+0x114>

			ml_AutoAddressingCfgADC();											/* Start LIN-shunt current measurement */
		}
		else if ( StepNumber == 4 )
    7cb4:	6203      	lod	AL, [S-4]
    7cb6:	8c04      	cmp	AL, #4
    7cb8:	1d13      	jne	0x7ce0 <_mlu_AutoAddressingStep+0xba>
		{
			/* *** Step 3: Perform pull-up LIN-shunt measurement *** */

			/* Test-module: No ADC-measurement, only current source */
			ADC_CTRL = (ADC_TRIG_SRC | ADC_SYNC_SOC | ADC_START);				/* MMP140812-1 */
    7cba:	7eda 0083 	lod	X, #131
    7cbe:	5e90      	mov	io:0x10 <__dp_noinit_size>, X
			LINAA_TIMER_START();												/* Start LIN-shunt current measurement (LIN-AA Timer) */
    7cc0:	7003      	lod	A, #3
    7cc2:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A

#if ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE))
			pSNPD_Data->u16CM_1 = l_u16AutoAddressingCM;
    7cc4:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7cc8:	7ed8 011c 	lod	X, 0x11c <_l_u16AutoAddressingCM>
    7ccc:	5ef4      	mov	[Y+4], X
			pSNPD_Data->u16DM_1 = (uint16) l_i16AutoAddressingDM;
    7cce:	72d8 011a 	lod	A, 0x11a <_l_i16AutoAddressingDM>
    7cd2:	52f6      	mov	[Y+6], A
#endif /* ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE)) */
			/* Clear variables */
			l_u16AutoAddressingCM = 0;
    7cd4:	7c00      	lod	X, #0
    7cd6:	5ed8 011c 	mov	0x11c <_l_u16AutoAddressingCM>, X
			l_i16AutoAddressingDM = 0;
    7cda:	5ed8 011a 	mov	0x11a <_l_i16AutoAddressingDM>, X
    7cde:	004f      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
		}
		else if ( StepNumber == 5 )
    7ce0:	6203      	lod	AL, [S-4]
    7ce2:	8c05      	cmp	AL, #5
    7ce4:	1d2c      	jne	0x7d3e <_mlu_AutoAddressingStep+0x118>
#define C_TEMP_STABIL_TIMEOUT				C_PI_TICKS_250MS					/* Temperature interval of 250ms */
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
    7ce6:	7ed8 011e 	lod	X, 0x11e <_l_u16SlowBaudrateAdjustment>
	for (; u16DelayCount > 0; u16DelayCount-- )
    7cea:	1902      	je	0x7cf0 <_mlu_AutoAddressingStep+0xca>
	{
		NOP();
    7cec:	0000      	nop
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    7cee:	1bfe      	djnz	X, 0x7cec <_mlu_AutoAddressingStep+0xc6>
		{
			/* *** Step 4: Pre-select: Check I2-I1 < threshold1 then Setup for current-source measurement, otherwise "quit" (wait) *** */
			NopDelay( l_u16SlowBaudrateAdjustment); /*lint !e522 */

			l_i16Ishunt2 = l_i16Ishunt;
    7cf0:	72d8 0266 	lod	A, 0x266 <_l_i16Ishunt>
    7cf4:	52d8 026a 	mov	0x26a <_l_i16Ishunt2>, A
#if (FORCE_LINAA_OLD != FALSE)
			if ( (l_i16Ishunt2 - l_i16Ishunt1) > C_LIN13AA_dI_1 )				/* Calculate difference Ishunt2 - Ishunt1 */
    7cf8:	aad8 0268 	sub	A, 0x268 <_l_i16Ishunt1>
    7cfc:	ac0c      	cmp	A, #12
    7cfe:	1b12      	jsle	0x7d24 <_mlu_AutoAddressingStep+0xfe>
			if ( ((g_u8LinAAMode & C_SNPD_METHOD_2) && ((l_i16Ishunt2 - l_i16Ishunt1) > C_LIN2xAA_dI_1_BSM2)) ||		/* BSM 2: Calculate difference Ishunt2 - Ishunt1 > 0.5mA */
				 (((g_u8LinAAMode & C_SNPD_METHOD_2) == 0) && ((l_i16Ishunt2 - l_i16Ishunt1) > C_LIN2xAA_dI_1_BSM)) )	/* BSM 1: Calculate difference Ishunt2 - Ishunt1 > 2.0mA */
#endif /* (FORCE_LINAA_OLD != FALSE) */
			{
				/* If Ishunt2 - Ishunt1 > It_1, disable standard pull up and goto wait state */
				ANA_OUTH = EN_LIN_AGC | ((0 << 3) & TRIM_LIN_CS) | (0 & SEL_LIN_CS);/* Enable LIN shunt measurement, zero-current measurement */
    7d00:	7c40      	lod	X, #64
    7d02:	5ed8 28ce 	mov	0x28ce <__io__+0xce>, X
				LIN_XCFG |= DISTERM;											/* Disable LIN pull-up resistor */
    7d06:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7d08:	a404      	or	A, #4
    7d0a:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A

#if ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE))
				pSNPD_Data->u16CM_2 = l_u16AutoAddressingCM;
    7d0c:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7d10:	7ee6      	lod	X, Y
    7d12:	2008      	add	X, #8
    7d14:	72d8 011c 	lod	A, 0x11c <_l_u16AutoAddressingCM>
    7d18:	52f8      	mov	[X], A
				pSNPD_Data->u16DM_2 = (uint16) l_i16AutoAddressingDM;
    7d1a:	e00a      	add	Y, #10
    7d1c:	7ed8 011a 	lod	X, 0x11a <_l_i16AutoAddressingDM>
    7d20:	5ef0      	mov	[Y], X
    7d22:	002d      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
			else
			{
				/* Setup 3th current measurement; Either enable pull-up + current-source of 2.05mA or enable current-source of 4.62mA */
#if (FORCE_LINAA_OLD != FALSE)
				/* Turn on current source value of 2.05mA */
				ANA_OUTH = EN_LIN_AGC | ((CalibrationParams.EE_ANA_OUTH_112_205 >> 8) & (TRIM_LIN_CS | SEL_LIN_CS)); /* Enable LIN shunt measurement, LIN high-current measurement (2.05mA) */
    7d24:	72d8 11ec 	lod	A, 0x11ec <__ep__+0x1ec>
    7d28:	6000      	lod	AL, #0
    7d2a:	72e4      	swap	A
    7d2c:	b43f      	and	A, #63
    7d2e:	a440      	or	A, #64
    7d30:	52d8 28ce 	mov	0x28ce <__io__+0xce>, A
				{
					/* Enable LIN shunt measurement, LIN high-current measurement (4.62mA) (LIN 2.x/BSM); Use 3.5mA current-source only */
					ANA_OUTH = EN_LIN_AGC | (CalibrationParams.EE_ANA_OUTH_350_800 & (TRIM_LIN_CS | SEL_LIN_CS));
				}
#endif /* (FORCE_LINAA_OLD != FALSE) */
				g_u8AutoAddressingFlags |= SLAVEFINALSTEP;
    7d34:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7d36:	8402      	or	AL, #2
    7d38:	4131      	mov	dp:0x31 <_g_u8AutoAddressingFlags>, AL

				ml_AutoAddressingCfgADC();										/* Start LIN-shunt current measurement */
    7d3a:	1767      	call	0x7c0a <_ml_AutoAddressingCfgADC>
    7d3c:	0020      	jmp	0x7d7e <_mlu_AutoAddressingStep+0x158>
			}
		}
		else if ( (StepNumber == 6) && ((g_u8AutoAddressingFlags & SLAVEFINALSTEP) != 0) ) /*lint !e845 */
    7d3e:	6203      	lod	AL, [S-4]
    7d40:	8c06      	cmp	AL, #6
    7d42:	1d1d      	jne	0x7d7e <_mlu_AutoAddressingStep+0x158>
    7d44:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7d46:	b402      	and	A, #2
    7d48:	191a      	je	0x7d7e <_mlu_AutoAddressingStep+0x158>
#define C_TEMP_STABIL_TIMEOUT				C_PI_TICKS_250MS					/* Temperature interval of 250ms */
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
    7d4a:	7ed8 011e 	lod	X, 0x11e <_l_u16SlowBaudrateAdjustment>
	for (; u16DelayCount > 0; u16DelayCount-- )
    7d4e:	1902      	je	0x7d54 <_mlu_AutoAddressingStep+0x12e>
	{
		NOP();
    7d50:	0000      	nop
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    7d52:	1bfe      	djnz	X, 0x7d50 <_mlu_AutoAddressingStep+0x12a>
		{
			/* *** Step 5: Perform current source measurement *** */
			NopDelay( l_u16SlowBaudrateAdjustment); /*lint !e522 */

			/* Test-module: No ADC-measurement, only current source */
			ADC_CTRL = (ADC_TRIG_SRC | ADC_SYNC_SOC | ADC_START);				/* MMP140812-1 */
    7d54:	7eda 0083 	lod	X, #131
    7d58:	5e90      	mov	io:0x10 <__dp_noinit_size>, X
			LINAA_TIMER_START();												/* Start LIN-shunt current measurement (LIN-AA Timer) */
    7d5a:	7003      	lod	A, #3
    7d5c:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A

#if ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE))
			pSNPD_Data->u16CM_2 = l_u16AutoAddressingCM;
    7d5e:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7d62:	7ee6      	lod	X, Y
    7d64:	2008      	add	X, #8
    7d66:	72d8 011c 	lod	A, 0x11c <_l_u16AutoAddressingCM>
    7d6a:	52f8      	mov	[X], A
			pSNPD_Data->u16DM_2 = (uint16) l_i16AutoAddressingDM;
    7d6c:	e00a      	add	Y, #10
    7d6e:	7ed8 011a 	lod	X, 0x11a <_l_i16AutoAddressingDM>
    7d72:	5ef0      	mov	[Y], X
#endif /* ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE)) */
			/* Clear variables */
			l_u16AutoAddressingCM = 0;
    7d74:	7000      	lod	A, #0
    7d76:	52d8 011c 	mov	0x11c <_l_u16AutoAddressingCM>, A
			l_i16AutoAddressingDM = 0;
    7d7a:	52d8 011a 	mov	0x11a <_l_i16AutoAddressingDM>, A
		}
	}
	if (StepNumber >= 7)
    7d7e:	6203      	lod	AL, [S-4]
    7d80:	8c06      	cmp	AL, #6
    7d82:	1e01      	jug	0x7d86 <_mlu_AutoAddressingStep+0x160>
    7d84:	0047      	jmp	0x7e14 <_mlu_AutoAddressingStep+0x1ee>
	{
		/* All slaves switch off current source and switch on pull up */
		ANA_OUTH &= ~EN_LIN_AGC;												/* Turn off LIN Shunt Current measurement */
    7d86:	72d8 28ce 	lod	A, 0x28ce <__io__+0xce>
    7d8a:	b4bf      	and	A, #-65
    7d8c:	52d8 28ce 	mov	0x28ce <__io__+0xce>, A
		LIN_XCFG &= ~DISTERM;													/* Enable LIN pull-up resistor */
    7d90:	72a0      	lod	A, io:0x20 <_g_i16MotorVoltage>
    7d92:	b4fb      	and	A, #-5
    7d94:	52a0      	mov	io:0x20 <_g_i16MotorVoltage>, A
		LINAA_TIMER_RESET();													/* Reset LIN-AA timer */
    7d96:	7c00      	lod	X, #0
    7d98:	5eb2      	mov	io:0x32 <_l_u8ActDirection>, X

		if ( (StepNumber == 7) && ((g_u8AutoAddressingFlags & SLAVEFINALSTEP) != 0) ) /*lint !e845 */
    7d9a:	6203      	lod	AL, [S-4]
    7d9c:	8c07      	cmp	AL, #7
    7d9e:	1d1b      	jne	0x7dd6 <_mlu_AutoAddressingStep+0x1b0>
    7da0:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7da2:	b402      	and	A, #2
    7da4:	1918      	je	0x7dd6 <_mlu_AutoAddressingStep+0x1b0>
		{
			/* *** Step 6 is only updated for slaves that did not skip any step before;
				 Last-slave?: Check I3-I1 < threshold2, then last-slave otherwise not  *** */
			l_i16Ishunt3 = l_i16Ishunt;
    7da6:	7ed8 0266 	lod	X, 0x266 <_l_i16Ishunt>
    7daa:	5ed8 026c 	mov	0x26c <_l_i16Ishunt3>, X
#if ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE))
			pSNPD_Data->u16CM_3 = l_u16AutoAddressingCM;
    7dae:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7db2:	7ee6      	lod	X, Y
    7db4:	200c      	add	X, #12
    7db6:	72d8 011c 	lod	A, 0x11c <_l_u16AutoAddressingCM>
    7dba:	52f8      	mov	[X], A
			pSNPD_Data->u16DM_3 = (uint16) l_i16AutoAddressingDM;
    7dbc:	e00e      	add	Y, #14
    7dbe:	7ed8 011a 	lod	X, 0x11a <_l_i16AutoAddressingDM>
    7dc2:	5ef0      	mov	[Y], X
#endif /* ((LIN_AA_INFO != FALSE) && (LIN_AA_SCREENTEST != FALSE)) */

#if (FORCE_LINAA_OLD != FALSE)
			if ( (l_i16Ishunt3 - l_i16Ishunt1) < C_LIN13AA_dI_2 )				/* Check current difference between Ishunt3 and Ishunt1 */
    7dc4:	72d8 0266 	lod	A, 0x266 <_l_i16Ishunt>
    7dc8:	aad8 0268 	sub	A, 0x268 <_l_i16Ishunt1>
    7dcc:	ac0b      	cmp	A, #11
    7dce:	1f03      	jsg	0x7dd6 <_mlu_AutoAddressingStep+0x1b0>
#else  /* (FORCE_LINAA_OLD != FALSE) */
			if ( ((g_u8LinAAMode & C_SNPD_METHOD_2) && ((l_i16Ishunt3 - l_i16Ishunt1) < C_LIN2xAA_dI_2_BSM2)) ||		/* BSM 2: Calculate difference Ishunt2 - Ishunt1 < 1.2mA */
				(((g_u8LinAAMode & C_SNPD_METHOD_2) == 0) && ((l_i16Ishunt2 - l_i16Ishunt1) < C_LIN2xAA_dI_2_BSM)) )	/* BSM 1: Calculate difference Ishunt2 - Ishunt1 < 2.0mA */
#endif /* (FORCE_LINAA_OLD != FALSE) */
			{
				g_u8AutoAddressingFlags |= (uint8) LASTSLAVE;					/* This LIN-slave is the last slave: take the address and set SLAVEADDRESSED flag (MMP140414-1) */
    7dd0:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7dd2:	8480      	or	AL, #-128
    7dd4:	4131      	mov	dp:0x31 <_g_u8AutoAddressingFlags>, AL
			}
		}
		if ( StepNumber == 7 )
    7dd6:	6203      	lod	AL, [S-4]
    7dd8:	8c07      	cmp	AL, #7
    7dda:	1d1c      	jne	0x7e14 <_mlu_AutoAddressingStep+0x1ee>
		{
#if LIN_AA_INFO
			pSNPD_Data->byStepAndFlags = (7 << 3) | (g_u8AutoAddressingFlags & 0x87);	/* MMP130818-1 */
    7ddc:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7de0:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7de2:	9487      	and	AL, #-121
    7de4:	8438      	or	AL, #56
    7de6:	42f0      	mov	[Y], AL
			pSNPD_Data->byIshunt1 = (uint8) l_i16Ishunt1;
    7de8:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7dec:	72d8 0268 	lod	A, 0x268 <_l_i16Ishunt1>
    7df0:	42f1      	mov	[Y+1], AL
			pSNPD_Data->byIshunt2 = (uint8) l_i16Ishunt2;
    7df2:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7df6:	72d8 026a 	lod	A, 0x26a <_l_i16Ishunt2>
    7dfa:	42f2      	mov	[Y+2], AL
			pSNPD_Data->byIshunt3 = (uint8) l_i16Ishunt3;
    7dfc:	7ad8 0264 	lod	Y, 0x264 <_pSNPD_Data>
    7e00:	72d8 026c 	lod	A, 0x26c <_l_i16Ishunt3>
    7e04:	42f3      	mov	[Y+3], AL
			if ( l_u8SNPD_CycleCount < (LIN_AA_INFO_SZ - 1) )					/* Don't increase index in case last AA-structure index */
    7e06:	62d8 0260 	lod	AL, 0x260 <_l_u8SNPD_CycleCount>
    7e0a:	8c0e      	cmp	AL, #14
    7e0c:	1e03      	jug	0x7e14 <_mlu_AutoAddressingStep+0x1ee>
			{
				l_u8SNPD_CycleCount++;
    7e0e:	8001      	add	AL, #1
    7e10:	42d8 0260 	mov	0x260 <_l_u8SNPD_CycleCount>, AL
    7e14:	5405      	ret	#6

00007e16 <_ml_SetSlaveNotAddressed>:
 * Resets the SLAVEADDRESSED flag. The actuator will try to acquire a new  
 * address next sync break.
 * ****************************************************************************	*/
void ml_SetSlaveNotAddressed( void)
{
	g_u8AutoAddressingFlags &= (uint8) ~SLAVEADDRESSED;
    7e16:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7e18:	94fe      	and	AL, #-2
    7e1a:	4131      	mov	dp:0x31 <_g_u8AutoAddressingFlags>, AL
    7e1c:	5401      	ret

00007e1e <_ml_SetSlaveAddressed>:
 * Sets the SLAVEADDRESSED flag. The actuator will assume it is already addressed
 * and not execute all auto-addressing steps.
 * ****************************************************************************	*/
void ml_SetSlaveAddressed( void)
{
	g_u8AutoAddressingFlags |= (uint8) SLAVEADDRESSED;
    7e1e:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    7e20:	8401      	or	AL, #1
    7e22:	4131      	mov	dp:0x31 <_g_u8AutoAddressingFlags>, AL
    7e24:	5401      	ret

00007e26 <_ml_InitAutoAddressing>:
#if (LINAA_BSM_SNPD_R1p0 != FALSE)												/* MMP140414-1 - Begin */
void ml_InitAutoAddressing( void)
{
	/* Calculate the detected MLX4 LIN Baudrate, based on baudrate divider and pre-scaler */
#if (__MLX_PLTF_VERSION_MAJOR__ == 4)
	if ( ml_GetBaudRate() < 12000 )
    7e26:	82db 5dda 	callf	0x5dda <_ml_GetBaudRate>
    7e2a:	aeda 2edf 	cmp	A, #11999
    7e2e:	1e03      	jug	0x7e36 <_ml_InitAutoAddressing+0x10>
	if ( divU16_U32byU16( (PLL_freq/2), (((uint16) u8NominalBaudRateDiv) << (u8BaudRatePreScaler & 0x0F))) < 12000 )
#else  /* ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1)) */
	if ( divU16_U32byU16( (PLL_freq/2), (((uint16) u8NominalBaudRateDiv) << (u8BaudRatePreScaler >> 4))) < 12000 )
#endif /* ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1)) */
	{
		l_u16SlowBaudrateAdjustment = DELAY_40US;								/* Time at 9600 Baud */
    7e30:	7070      	lod	A, #112
    7e32:	52d8 011e 	mov	0x11e <_l_u16SlowBaudrateAdjustment>, A
	}

	/* LIN-AA will claim the ADC and a Timer */
	/* Disable the ADC & IRQ */
	ADC_Stop();
    7e36:	82db 8e44 	callf	0x8e44 <_ADC_Stop>
	g_u8AdcIsrMode = (uint8) C_ADC_ISR_LIN_AA;									/* Set switch ADC to Auto-addressing-mode */
    7e3a:	6001      	lod	AL, #1
    7e3c:	42d8 0137 	mov	0x137 <_g_u8AdcIsrMode>, AL
	ADC_SBASE = (uint16) SBASE_LIN;												/* Switch ADC input source to LIN Shunt */
    7e40:	72da aadc 	lod	A, #43740
    7e44:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
#if (_LINAA_ASM == FALSE)														/* MMP140417-2 - Begin */
	ADC_DBASE = (uint16) &LinAutoAddressing.Result_LinShunt1_CommonMode;
#else  /* (_LINAA_ASM == FALSE) */
	ADC_DBASE = (uint16) &LinAutoAddressing.Result_LinAA[0];
    7e46:	72da 026e 	lod	A, #622
    7e4a:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
#endif /* (_LINAA_ASM == FALSE) */												/* MMP140417-2 - End */

	/* Disable Timer2 & IRQ */
	LINAA_TIMER_RESET();														/* Reset timer */
    7e4c:	7000      	lod	A, #0
    7e4e:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A
	LINAA_TIMER_IRQ_DIS();														/* Disable LIN-AA Timer interrupt */
    7e50:	54d0      	psup	#0
    7e52:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7e56:	b6da fdff 	and	A, #65023
    7e5a:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    7e5e:	72cb      	pop	M
#if ((LINPROT & LINXX) == LIN13)
	/* LIN 1.3: 18T @ 9600 Baud or 36T @ 19200T, Measurement = 3.5-4T @ 9600 => 350us --> max 18us */
	l_u16LinAATimerPeriod = (PLL_freq/71428);									/* Set to 71.4kHz rate, 14us (266-280us) */
#else /* ((LINPROT & LINXX) == LIN13) */
	/* LIN 2.x: 13T, Measurement = 3T; At 9600Baud: 312.5us --> max 16us, At 19200 Baud: 156us --> max 8us */
	if ( l_u16SlowBaudrateAdjustment == DELAY_40US )
    7e60:	72d8 011e 	lod	A, 0x11e <_l_u16SlowBaudrateAdjustment>
    7e64:	ac70      	cmp	A, #112
    7e66:	1d03      	jne	0x7e6e <_ml_InitAutoAddressing+0x48>
	{
		l_u16LinAATimerPeriod = (PLL_freq/83333);								/* Set to 83.3kHz rate, 12us (228-240us) */
    7e68:	72da 0150 	lod	A, #336
    7e6c:	0002      	jmp	0x7e72 <_ml_InitAutoAddressing+0x4c>
	}
	else
	{
#if (LINAA_NON_CHOPPER_MODE == FALSE)
		l_u16LinAATimerPeriod = (PLL_freq/142857);								/* Set to 143kHz rate, 7us (133-150us) */
    7e6e:	72da 00c4 	lod	A, #196
    7e72:	52d8 0262 	mov	0x262 <_l_u16LinAATimerPeriod>, A
	}
#endif /* ((LINPROT & LINXX) == LIN13) */

#if defined (HAS_LIN_AUTOADDRESSING)
	/* enable the MLX4 auto addressing pulses */
	(void) ml_AutoAddressingConfig( TRUE);
    7e76:	7001      	lod	A, #1
    7e78:	82db 5ad0 	callf	0x5ad0 <_ml_AutoAddressingConfig>
    7e7c:	5401      	ret

00007e7e <_ml_StopAutoAddressing>:

void ml_StopAutoAddressing( void)
{
#if defined (HAS_LIN_AUTOADDRESSING)
	/* enable the MLX4 auto addressing pulses */
	(void) ml_AutoAddressingConfig( FALSE);
    7e7e:	7000      	lod	A, #0
    7e80:	82db 5ad0 	callf	0x5ad0 <_ml_AutoAddressingConfig>
#endif

	g_u8AdcIsrMode = (uint8) C_ADC_ISR_NONE;									/* Set switch ADC off */
    7e84:	6000      	lod	AL, #0
    7e86:	42d8 0137 	mov	0x137 <_g_u8AdcIsrMode>, AL

#if (LIN_AA_INFO != FALSE) && (USE_MULTI_PURPOSE_BUFFER != FALSE)
	g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;									/* Multi-purpose buffer is free */
    7e8a:	42d8 015f 	mov	0x15f <_g_MPBuf+0x1>, AL
    7e8e:	5401      	ret

00007e90 <_AutoAddressingReadADCResult>:
 * function called when an ADC result has to be fetched in the
 * auto addressing mode
 * ****************************************************************************	*/
void AutoAddressingReadADCResult( void)
{
	LINAA_TIMER_STOP();															/* Stop LIN-AA Timer */
    7e90:	7001      	lod	A, #1
    7e92:	52b2      	mov	io:0x32 <_l_u8ActDirection>, A
	int16 i16Sum;
	i16Sum =  *(int16 *) &LinAutoAddressing.Result_LinShunt1_CommonMode;
	i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt2_CommonMode;
	l_u16AutoAddressingCM = (i16Sum >> 1);
#else  /* (_LINAA_ASM == FALSE) */
	asm("mov x, #_LinAutoAddressing");
    7e94:	7eda 026e 	lod	X, #622
	asm("mov a, [x++]");		/* i16Sum =  *(int16 *) &LinAutoAddressing.Result_LinShunt1_CommonMode */
    7e98:	72de      	lod	A, [X++]
	asm("add a, [x++]");		/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt2_CommonMode */ /* MMP140812-2 */
    7e9a:	a2de      	add	A, [X++]
	asm("lsr a, #1");			/* l_u16AutoAddressingCM = (i16Sum >> 1) */
    7e9c:	4432      	lsr	A
	asm("mov _l_u16AutoAddressingCM, a");
    7e9e:	52d8 011c 	mov	0x11c <_l_u16AutoAddressingCM>, A
	i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt7_mode2;
	i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt8_mode1;
	i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt8_mode2;
	l_i16AutoAddressingDM = (i16Sum >> 4);
#else  /* (_LINAA_ASM == FALSE) */
	asm("mov a, [x++]");	/* i16Sum =  *(int16 *) &LinAutoAddressing.Result_LinShunt1_mode1 */
    7ea2:	72de      	lod	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt1_mode2 */
    7ea4:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt2_mode1 */
    7ea6:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt2_mode2 */
    7ea8:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt3_mode1 */
    7eaa:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt3_mode2 */
    7eac:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt4_mode1 */
    7eae:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt4_mode2 */
    7eb0:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt5_mode1 */
    7eb2:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt5_mode2 */
    7eb4:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt6_mode1 */
    7eb6:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt6_mode2 */
    7eb8:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt7_mode1 */
    7eba:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt7_mode2 */
    7ebc:	aade      	sub	A, [X++]
	asm("add a, [x++]");	/* i16Sum += *(int16 *) &LinAutoAddressing.Result_LinShunt8_mode1 */
    7ebe:	a2de      	add	A, [X++]
	asm("sub a, [x++]");	/* i16Sum -= *(int16 *) &LinAutoAddressing.Result_LinShunt8_mode2 */
    7ec0:	aade      	sub	A, [X++]
	asm("asr a, #2");
    7ec2:	44f2      	asr	A, #2
	asm("asr a, #2");
    7ec4:	44f2      	asr	A, #2
	asm("mov _l_i16AutoAddressingDM, a");
    7ec6:	52d8 011a 	mov	0x11a <_l_i16AutoAddressingDM>, A
	asm("mov _AutoAddressingDM, a");
#endif /* (_LINAA_ASM == FALSE) */												/* MMP140417-2 - End */
#endif /*  LINAA_NON_CHOPPER_MODE == FALSE */

	{
		int16 i16AA_CM = (int16) l_u16AutoAddressingCM - EE_OCMAA;					/* MMP140404-2 */
    7eca:	7ad8 011c 	lod	Y, 0x11c <_l_u16AutoAddressingCM>
    7ece:	72d8 11da 	lod	A, 0x11da <__ep__+0x1da>
    7ed2:	eae2      	sub	Y, A
#if (LIN_AA_INFO && LIN_AA_SCREENTEST)
		int16 AASDMCM = EE_GDMCMAA;
    7ed4:	72d8 11d8 	lod	A, 0x11d8 <__ep__+0x1d8>
		AASDMCM -= (int16)g_NvramUser.AASDMCM_delta;
    7ed8:	a962      	sub	A, dp:0x62 <__data_size>
		/* l_i16Ishunt = (int16) (mulI32_I16byI16( l_i16Ishunt, AASDMCM) >> 15); */
		l_i16Ishunt = (int16) (((int32) i16AA_CM * AASDMCM) >> 15);			/* MMP140404-1/MMP140404-2 */
    7eda:	4831      	muls	YA, A, Y
    7edc:	48be      	asr	YA, #15
		l_i16Ishunt = (int16) (((int32) i16AA_CM * EE_GDMCMAA) >> 15);			/* MMP140404-1/MMP140404-2 */
#endif /* (LIN_AA_INFO && LIN_AA_SCREENTEST) */
	}

	/* Get CM corrected DM data minus DM offset */
	l_i16Ishunt = (l_i16AutoAddressingDM - l_i16Ishunt) - EE_ODMAA;
    7ede:	7ed8 011a 	lod	X, 0x11a <_l_i16AutoAddressingDM>
    7ee2:	2ae2      	sub	X, A
    7ee4:	72d8 11dc 	lod	A, 0x11dc <__ep__+0x1dc>
    7ee8:	2ae2      	sub	X, A

	/* Correct DM gain to target gain (scale correction) */
	/* l_i16Ishunt = (int16) (mulI32_I16byI16( l_i16Ishunt, EE_GLAA) >> 12); */
	l_i16Ishunt = (int16) (((int32) l_i16Ishunt * EE_GLAA) >> 12);				/* MMP140404-1 */
    7eea:	72d8 11d6 	lod	A, 0x11d6 <__ep__+0x1d6>
    7eee:	4833      	muls	YA, A, X
    7ef0:	48bb      	asr	YA, #12
    7ef2:	52d8 0266 	mov	0x266 <_l_i16Ishunt>, A

	PEND = CLR_ADC_IT;
    7ef6:	7040      	lod	A, #64
    7ef8:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK &= ~EN_ADC_IT;
    7efc:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7f00:	b4bf      	and	A, #-65
    7f02:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    7f06:	5401      	ret

00007f08 <_ClearAAData>:
 * ****************************************************************************	*/
#if LIN_AA_INFO
void ClearAAData(void)
{
	uint16 i;
	uint16 *pLinAAInfo = (uint16*) LIN_AA_DATA;
    7f08:	7ada 0160 	lod	Y, #352
    7f0c:	7eda 0080 	lod	X, #128
	for ( i = (sizeof(LIN_AA_DATA)/sizeof(uint16)); i > 0; i-- )
	{
		*pLinAAInfo = 0;
    7f10:	7000      	lod	A, #0
    7f12:	52d6      	mov	[Y++], A
    7f14:	1bfd      	djnz	X, 0x7f10 <_ClearAAData+0x8>
		pLinAAInfo++;
	}
	l_u8SNPD_CycleCount = 0;
    7f16:	42d8 0260 	mov	0x260 <_l_u8SNPD_CycleCount>, AL
#if USE_MULTI_PURPOSE_BUFFER
	g_MPBuf.u8Type = (uint8) C_MP_BUF_LIN_AA;
    7f1a:	6002      	lod	AL, #2
    7f1c:	42d8 015e 	mov	0x15e <_g_MPBuf>, AL
	g_MPBuf.u8Usage = (uint8) C_MP_BUF_INUSE;									/* Multi-purpose buffer is in use */
    7f20:	6001      	lod	AL, #1
    7f22:	42d8 015f 	mov	0x15f <_g_MPBuf+0x1>, AL
    7f26:	5401      	ret

00007f28 <_LIN_2x_Init>:
/* ****************************************************************************	* 
 * LIN 2.x initialisation
 * ****************************************************************************	*/
void LIN_2x_Init( uint16 u16WarmStart)
{
	if ( (g_NvramUser.NAD & 0x80) == 0x00 )
    7f28:	615a      	lod	AL, dp:0x5a <_g_NvramUser+0x2>
    7f2a:	8c00      	cmp	AL, #0
    7f2c:	1a82      	jsl	0x7f32 <_LIN_2x_Init+0xa>
	{
		g_u8NAD = g_NvramUser.NAD;
    7f2e:	4133      	mov	dp:0x33 <_g_u8NAD>, AL
    7f30:	0004      	jmp	0x7f3a <_LIN_2x_Init+0x12>
	}
	else
	{
		/* Keep original default NAD address */
		SetLastError( (uint8) C_ERR_INV_NAD);
    7f32:	72da 00c3 	lod	A, #195
    7f36:	82db 9328 	callf	0x9328 <_SetLastError>
	}
#if (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE)										/* MMP150125-1 - Begin */
	l_u8GAD = g_NvramUser.GAD;
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */

	l_u8ActDirection = g_NvramUser.MotorDirectionCCW;
    7f3a:	6168      	lod	AL, dp:0x68 <__data_size+0x6>
    7f3c:	b401      	and	A, #1
    7f3e:	4132      	mov	dp:0x32 <_l_u8ActDirection>, AL

	(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_NvramUser.ControlFrameID);
    7f40:	615e      	lod	AL, dp:0x5e <_g_NvramUser+0x6>
    7f42:	5cf2      	usex	A
    7f44:	52df      	push	A
    7f46:	7001      	lod	A, #1
    7f48:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
	(void) ml_AssignFrameToMessageID( MSG_STATUS, g_NvramUser.StatusFrameID);
    7f4c:	615f      	lod	AL, dp:0x5f <_g_NvramUser+0x7>
    7f4e:	5cf2      	usex	A
    7f50:	52df      	push	A
    7f52:	7002      	lod	A, #2
    7f54:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
#if (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE)										/* MMP150125-1 - Begin */
	(void) ml_AssignFrameToMessageID( MSG_GROUP_CONTROL, g_NvramUser.GroupControlFrameID);
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */

	(void) ml_SetLoaderNAD( g_u8NAD);											/* Setup NAD at power-up */
    7f58:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    7f5a:	5cf2      	usex	A
    7f5c:	82db 5da0 	callf	0x5da0 <_ml_SetLoaderNAD>

	if ( u16WarmStart == FALSE )
    7f60:	5c03      	dec	S, #4
    7f62:	5401      	ret

00007f64 <_HandleActCtrl>:
#else  /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */


void HandleActCtrl( void)
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
{
    7f64:	580b      	inc	S, #12

	ACT_CTRL *pCfrCtrl = &g_LinCmdFrameBuffer.Ctrl;

//		ACT_CTRL *pCtrl = &g_LinCmdFrameBuffer.Ctrl;

		g_u16EXVTargetPositionTemp = (((uint16)pCfrCtrl->byPositionMSB & 0x03) << 8) | pCfrCtrl->byPositionLSB;
    7f66:	653b      	lod	YL, dp:0x3b <__data_dp_end+0x1>
    7f68:	f403      	and	Y, #3
    7f6a:	6c00      	lod	YH, #0
    7f6c:	7ae8      	swap	Y
    7f6e:	613a      	lod	AL, dp:0x3a <__data_dp_end>
    7f70:	5cf2      	usex	A
    7f72:	e6e2      	or	Y, A
    7f74:	5ad8 0100 	mov	0x100 <_g_u16EXVTargetPositionTemp>, Y
				if((g_e8MotorStatusMode & ((uint8) C_MOTOR_STATUS_DEGRADED)) == 0) //not degrade mode, otherwise, just update the target position
    7f78:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    7f7a:	8c00      	cmp	AL, #0
    7f7c:	1aa5      	jsl	0x7fc8 <_HandleActCtrl+0x64>
				{
					if(pCfrCtrl->byMovEn == C_CTRL_MOVE_ENA){
    7f7e:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    7f80:	420b      	mov	[S-12], AL
    7f82:	9401      	and	AL, #1
    7f84:	191c      	je	0x7fbe <_HandleActCtrl+0x5a>
						g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_ENABLE;
    7f86:	6001      	lod	AL, #1
    7f88:	411c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, AL
						if(((g_e8CalibrationStep == (uint8) C_CALIB_NONE) || (g_e8CalibrationStep == (uint8) C_CALIB_DONE)) && (g_u16EXVTargetPositionTemp == 0x3FF))
    7f8a:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    7f8c:	1902      	je	0x7f92 <_HandleActCtrl+0x2e>
    7f8e:	8c0a      	cmp	AL, #10
    7f90:	1d08      	jne	0x7fa2 <_HandleActCtrl+0x3e>
    7f92:	eeda 03ff 	cmp	Y, #1023
    7f96:	1d05      	jne	0x7fa2 <_HandleActCtrl+0x3e>
						{
							g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_CALIBRATION;
    7f98:	6005      	lod	AL, #5
    7f9a:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
							g_e8CalibrationStep = (uint8) C_CALIB_START;
    7f9c:	6001      	lod	AL, #1
    7f9e:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    7fa0:	0006      	jmp	0x7fae <_HandleActCtrl+0x4a>
						}
						else if(g_e8CalibrationStep == (uint8) C_CALIB_DONE)
    7fa2:	8c0a      	cmp	AL, #10
    7fa4:	1d02      	jne	0x7faa <_HandleActCtrl+0x46>
						{
							g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    7fa6:	6003      	lod	AL, #3
    7fa8:	0001      	jmp	0x7fac <_HandleActCtrl+0x48>
						}
						else
						{
							//TODO,Ban,what to do if during initalization?
							g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_CALIBRATION;
    7faa:	6005      	lod	AL, #5
    7fac:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
						}
						if(pCfrCtrl->byStallEnable == C_CTRL_STALL_ENABLE)
    7fae:	620b      	lod	AL, [S-12]
    7fb0:	9408      	and	AL, #8
    7fb2:	1902      	je	0x7fb8 <_HandleActCtrl+0x54>
						{
							g_e8StallDetectorEna = C_STALLDET_H;
    7fb4:	6004      	lod	AL, #4
    7fb6:	0001      	jmp	0x7fba <_HandleActCtrl+0x56>
						}
						else
						{
							g_e8StallDetectorEna = C_STALLDET_NONE;
    7fb8:	6000      	lod	AL, #0
    7fba:	41ec      	mov	dp:0xec <_g_e8StallDetectorEna>, AL
    7fbc:	002a      	jmp	0x8012 <_HandleActCtrl+0xae>
						}
					}else{
						g_e8EXVMoveEnableRequestFlag = (uint8) C_EXV_MOVE_DISABLE;
    7fbe:	6000      	lod	AL, #0
    7fc0:	411c      	mov	dp:0x1c <_g_e8EXVMoveEnableRequestFlag>, AL
						g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    7fc2:	6001      	lod	AL, #1
    7fc4:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    7fc6:	0025      	jmp	0x8012 <_HandleActCtrl+0xae>
					}
				}
				else
				{
					g_u16TargetPosition = (((uint32)g_u16EXVTargetPositionTemp)*g_u16CalibTravel+128)/255 + C_EXV_ZERO_POS;//update the target position in degrade mode,
    7fc8:	71f4      	lod	A, dp:0xf4 <_g_u16CalibTravel>
    7fca:	4801      	mulu	D, A, Y
    7fcc:	72ef      	lod	A, S
    7fce:	a0fc      	add	A, #-4
    7fd0:	4cf3      	swap	YA
    7fd2:	4c85      	mov	[Y], D
    7fd4:	7203      	lod	A, [S-4]
    7fd6:	a2da 0080 	add	A, #128
    7fda:	5203      	mov	[S-4], A
    7fdc:	7201      	lod	A, [S-2]
    7fde:	b000      	adc	A, #0
    7fe0:	5201      	mov	[S-2], A
    7fe2:	54ca 00ff 	pushw	#255
    7fe6:	54ca 0000 	pushw	#0
    7fea:	7207      	lod	A, [S-8]
    7fec:	7a05      	lod	Y, [S-6]
    7fee:	82db 6c94 	callf	0x6c94 <___udivsi3>
    7ff2:	5c03      	dec	S, #4
    7ff4:	5209      	mov	[S-10], A
    7ff6:	5a07      	mov	[S-8], Y
    7ff8:	658c      	lod	YL, dp:0x8c <__data_size+0x2a>
    7ffa:	44b6      	lsr	Y, #2
    7ffc:	44b6      	lsr	Y, #2
    7ffe:	4436      	lsr	Y
    8000:	f403      	and	Y, #3
    8002:	7064      	lod	A, #100
    8004:	ec00      	cmp	Y, #0
    8006:	1b03      	jsle	0x800e <_HandleActCtrl+0xaa>
    8008:	46e9      	mov	Cx, YL
    800a:	4422      	asl	A
    800c:	1ffe      	djnz	Cx, 0x800a <_HandleActCtrl+0xa6>
    800e:	a209      	add	A, [S-10]
    8010:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
				}
				if ( (pCfrCtrl->byTorqueLevel >= C_CTRL_TORQUE_NOMINAL) && (pCfrCtrl->byTorqueLevel <= C_CTRL_TORQUE_BOOST_40PCT) )
    8012:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8014:	4205      	mov	[S-6], AL
    8016:	9406      	and	AL, #6
    8018:	190d      	je	0x8034 <_HandleActCtrl+0xd0>
    801a:	6205      	lod	AL, [S-6]
    801c:	4430      	lsr	AL
    801e:	9403      	and	AL, #3
    8020:	4204      	mov	[S-5], AL
    8022:	8c03      	cmp	AL, #3
    8024:	1e07      	jug	0x8034 <_HandleActCtrl+0xd0>
				{
					g_u8TorqueBoostRequest = (pCfrCtrl->byTorqueLevel - C_CTRL_TORQUE_NOMINAL) * 10U;
    8026:	640a      	lod	YL, #10
    8028:	4829      	mulu	Y, AL, YL
    802a:	62e8      	lod	AL, YL
    802c:	80f6      	add	AL, #-10
    802e:	42d8 0108 	mov	0x108 <_g_u8TorqueBoostRequest>, AL
    8032:	0005      	jmp	0x803e <_HandleActCtrl+0xda>
				}
				else//undefined torque, just stop the motor
				{
					g_u8TorqueBoostRequest = C_CTRL_TORQUE_NO;
    8034:	6000      	lod	AL, #0
    8036:	42d8 0108 	mov	0x108 <_g_u8TorqueBoostRequest>, AL
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    803a:	6001      	lod	AL, #1
    803c:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
				}

				g_u8ChipResetOcc = FALSE;											/* Clear 'reset'-flag only after CFR_INI (4.2.6.3) */
    803e:	6000      	lod	AL, #0
    8040:	4129      	mov	dp:0x29 <_g_u8ChipResetOcc>, AL
    8042:	540d      	ret	#14

00008044 <_HandleActStatus>:
#define METHOD_BYTE			1
#define FUNC_ACT_STATUS		METHOD_BYTE

#if (FUNC_ACT_STATUS == METHOD_BYTE)
void HandleActStatus( void)
{
    8044:	5817      	inc	S, #24


	ACT_STATUS *pRfrSta = (ACT_STATUS *)LinFrameDataBuffer;

		/*	if ( g_u8SAE_ErrorFlags != 0 )		(MMP160613-1) */
		if ( g_u8ErrorCommunication != FALSE )
    8046:	62d8 0121 	lod	AL, 0x121 <_g_u8ErrorCommunication>
    804a:	4207      	mov	[S-8], AL
    804c:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer>
    804e:	4212      	mov	[S-19], AL
    8050:	62d8 00ff 	lod	AL, 0xff <_g_e8EXVStatusFaultState>
    8054:	4211      	mov	[S-18], AL
    8056:	6207      	lod	AL, [S-8]
    8058:	1903      	je	0x8060 <_HandleActStatus+0x1c>
		{
			pRfrSta->byLinErr = C_STATUS_LIN_ERR;
    805a:	6212      	lod	AL, [S-19]
    805c:	8401      	or	AL, #1
    805e:	0002      	jmp	0x8064 <_HandleActStatus+0x20>
		}
		else
		{
			pRfrSta->byLinErr = C_STATUS_LIN_OK;
    8060:	6212      	lod	AL, [S-19]
    8062:	94fe      	and	AL, #-2
    8064:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
		}
		g_u8SAE_SendErrorState = g_u8ErrorCommunication;
    8066:	62d8 0121 	lod	AL, 0x121 <_g_u8ErrorCommunication>
    806a:	42d8 0123 	mov	0x123 <_g_u8SAE_SendErrorState>, AL

		pRfrSta->byFaultState = g_e8EXVStatusFaultState;
    806e:	6211      	lod	AL, [S-18]
    8070:	940f      	and	AL, #15
    8072:	4420      	asl	AL
    8074:	4217      	mov	[S-24], AL
    8076:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer>
    8078:	94e1      	and	AL, #-31
    807a:	66e0      	lod	YL, AL
    807c:	6217      	lod	AL, [S-24]
    807e:	86e8      	or	AL, YL
    8080:	66e0      	lod	YL, AL
    8082:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL

		if ( (g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0 )
    8084:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    8086:	b401      	and	A, #1
    8088:	1d03      	jne	0x8090 <_HandleActStatus+0x4c>
		{
			pRfrSta->byMoveState = C_STATUS_MOVE_IDLE;
    808a:	62e8      	lod	AL, YL
    808c:	94df      	and	AL, #-33
    808e:	0002      	jmp	0x8094 <_HandleActStatus+0x50>
		}
		else
		{
			pRfrSta->byMoveState = C_STATUS_MOVE_ACTIVE;
    8090:	62e8      	lod	AL, YL
    8092:	8420      	or	AL, #32
    8094:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
		}

		if ( (g_e8MotorStatusMode & C_MOTOR_STATUS_RUNNING) == 0 )
    8096:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    8098:	7ae2      	lod	Y, A
    809a:	f401      	and	Y, #1
    809c:	61ca      	lod	AL, dp:0xca <_LinFrameDataBuffer>
    809e:	4212      	mov	[S-19], AL
    80a0:	72d8 00fc 	lod	A, 0xfc <_g_u16EXVStatusCurrentPositon>
    80a4:	520f      	mov	[S-16], A
    80a6:	61cd      	lod	AL, dp:0xcd <_LinFrameDataBuffer+0x3>
    80a8:	420d      	mov	[S-14], AL
    80aa:	62d8 00fb 	lod	AL, 0xfb <_g_e8EXVStatusInitStat>
    80ae:	420c      	mov	[S-13], AL
    80b0:	61cb      	lod	AL, dp:0xcb <_LinFrameDataBuffer+0x1>
    80b2:	420b      	mov	[S-12], AL
    80b4:	62d8 0126 	lod	AL, 0x126 <_l_u8StaCounter>
    80b8:	420a      	mov	[S-11], AL
    80ba:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    80bc:	4209      	mov	[S-10], AL
    80be:	ec00      	cmp	Y, #0
    80c0:	1d03      	jne	0x80c8 <_HandleActStatus+0x84>
		{
			pRfrSta->byTorqueLevel = (uint8)C_CTRL_TORQUE_NO;
    80c2:	6212      	lod	AL, [S-19]
    80c4:	943f      	and	AL, #63
    80c6:	0012      	jmp	0x80ec <_HandleActStatus+0xa8>
    80c8:	66d8 0108 	lod	YL, 0x108 <_g_u8TorqueBoostRequest>
    80cc:	5cf6      	usex	Y
    80ce:	5a05      	mov	[S-6], Y
    80d0:	7205      	lod	A, [S-6]
    80d2:	7800      	lod	Y, #0
    80d4:	5205      	mov	[S-6], A
    80d6:	5a03      	mov	[S-4], Y
    80d8:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    80da:	4c63      	divu	YA, X
    80dc:	4c63      	divu	YA, X
    80de:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    80e0:	44d0      	rr	AL, #2
    80e2:	94c0      	and	AL, #-64
    80e4:	4216      	mov	[S-23], AL
    80e6:	6212      	lod	AL, [S-19]
    80e8:	943f      	and	AL, #63
    80ea:	8616      	or	AL, [S-23]
    80ec:	41ca      	mov	dp:0xca <_LinFrameDataBuffer>, AL
		{
			pRfrSta->byTorqueLevel = (uint8) divU16_U32byU16( (uint32) g_u8TorqueBoostRequest, 10U);
		}

		//Byte 2
		pRfrSta->byActPositionLSB = g_u16EXVStatusCurrentPositon&0xFF;
    80ee:	620f      	lod	AL, [S-16]
    80f0:	41cc      	mov	dp:0xcc <_LinFrameDataBuffer+0x2>, AL
		pRfrSta->byActPositionMSB = (g_u16EXVStatusCurrentPositon>>8)&0x3;
    80f2:	7a0f      	lod	Y, [S-16]
    80f4:	6400      	lod	YL, #0
    80f6:	7ae8      	swap	Y
    80f8:	5a0f      	mov	[S-16], Y
    80fa:	620f      	lod	AL, [S-16]
    80fc:	9403      	and	AL, #3
    80fe:	4215      	mov	[S-22], AL
    8100:	620d      	lod	AL, [S-14]
    8102:	94fc      	and	AL, #-4
    8104:	8615      	or	AL, [S-22]
    8106:	41cd      	mov	dp:0xcd <_LinFrameDataBuffer+0x3>, AL

		//Byte 3
		pRfrSta->byInitState = g_e8EXVStatusInitStat;
    8108:	620c      	lod	AL, [S-13]
    810a:	9403      	and	AL, #3
    810c:	4214      	mov	[S-21], AL
    810e:	620b      	lod	AL, [S-12]
    8110:	94f0      	and	AL, #-16
    8112:	4213      	mov	[S-20], AL

		pRfrSta->byArcState = l_u8StaCounter;
    8114:	620a      	lod	AL, [S-11]
    8116:	9403      	and	AL, #3
    8118:	44a0      	asl	AL, #2
    811a:	4205      	mov	[S-6], AL
    811c:	6213      	lod	AL, [S-20]
    811e:	8614      	or	AL, [S-21]
    8120:	66e0      	lod	YL, AL
    8122:	6205      	lod	AL, [S-6]
    8124:	86e8      	or	AL, YL
    8126:	66e0      	lod	YL, AL
    8128:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
		l_u8StaCounter++;
    812a:	620a      	lod	AL, [S-11]
    812c:	8001      	add	AL, #1
    812e:	42d8 0126 	mov	0x126 <_l_u8StaCounter>, AL

		if(g_e8EXVErrorBlock == TRUE)
    8132:	6209      	lod	AL, [S-10]
    8134:	8c01      	cmp	AL, #1
    8136:	1d03      	jne	0x813e <_HandleActStatus+0xfa>
		{
			pRfrSta->byStallDetectStatus = TRUE;
    8138:	62e8      	lod	AL, YL
    813a:	8410      	or	AL, #16
    813c:	0002      	jmp	0x8142 <_HandleActStatus+0xfe>
		}
		else
		{
			pRfrSta->byStallDetectStatus = FALSE;
    813e:	62e8      	lod	AL, YL
    8140:	94ef      	and	AL, #-17
    8142:	41cb      	mov	dp:0xcb <_LinFrameDataBuffer+0x1>, AL
    8144:	5419      	ret	#26

00008146 <_LinAATimeoutControl>:
 *
 * ****************************************************************************	*/
void LinAATimeoutControl( void)
{
	/* LIN-AA takes too long time */
	g_u8NAD = g_NvramUser.NAD;													/* Restore original NAD */
    8146:	615a      	lod	AL, dp:0x5a <_g_NvramUser+0x2>
    8148:	4133      	mov	dp:0x33 <_g_u8NAD>, AL
#if (LINAA_BSM_SNPD_R1p0 != FALSE)												/* MMP140417-2 - Begin */
	ml_StopAutoAddressing();
    814a:	1699      	call	0x7e7e <_ml_StopAutoAddressing>
#endif /* (LINAA_BSM_SNPD_R1p0 != FALSE) */										/* MMP140417-2 - End */
	(void) ml_SetLoaderNAD( g_u8NAD);
    814c:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    814e:	5cf2      	usex	A
    8150:	82db 5da0 	callf	0x5da0 <_ml_SetLoaderNAD>
	g_u16LinAATicker = 0;														/* Stop LIN-AA timeout counter */
    8154:	7000      	lod	A, #0
    8156:	52d8 0128 	mov	0x128 <_g_u16LinAATicker>, A
	g_u8LinAAMode = 0;															/* Cancel LIN-AA mode */
    815a:	42d8 012b 	mov	0x12b <_g_u8LinAAMode>, AL
	mlu_AutoAddressingStep( 8);													/* Cancel pending LIN-AA process too */
    815e:	7008      	lod	A, #8
    8160:	1562      	call	0x7c26 <_mlu_AutoAddressingStep>
    8162:	5401      	ret

00008164 <_HandleBusTimeout>:
 *
 * ****************************************************************************	*/
void HandleBusTimeout( void)
{
#if _SUPPORT_BUSTIMEOUT
	if ( g_u8LinAAMode & (uint8) C_SNPD_METHOD_2 )
    8164:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    8168:	8c00      	cmp	AL, #0
    816a:	1e81      	jsge	0x816e <_HandleBusTimeout+0xa>
	{
		LinAATimeoutControl();
    816c:	17ec      	call	0x8146 <_LinAATimeoutControl>
	}
	if ( g_u8ErrorCommBusTimeout == FALSE )
    816e:	62d8 0120 	lod	AL, 0x120 <_g_u8ErrorCommBusTimeout>
    8172:	1d1b      	jne	0x81aa <_HandleBusTimeout+0x46>
	{
		/* Emergency run is enabled */
		g_u8ErrorCommBusTimeout = TRUE;
    8174:	6001      	lod	AL, #1
    8176:	42d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, AL
		SetLastError( (uint8) C_ERR_LIN_BUS_TIMEOUT);
    817a:	72da 00bf 	lod	A, #191
    817e:	82db 9328 	callf	0x9328 <_SetLastError>
		{
			if ( g_NvramUser.EmergencyRunEna )
    8182:	6168      	lod	AL, dp:0x68 <__data_size+0x6>
    8184:	4432      	lsr	A
    8186:	b401      	and	A, #1
    8188:	1910      	je	0x81aa <_HandleBusTimeout+0x46>
			{
				if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_CALIBRATION )
    818a:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    818c:	8c05      	cmp	AL, #5
    818e:	1d04      	jne	0x8198 <_HandleBusTimeout+0x34>
				{
					/* Calibration is on-going; Postpone emergency-run till after calibration-process have been finished */
					g_e8CalibPostMotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    8190:	6007      	lod	AL, #7
    8192:	42d8 0104 	mov	0x104 <_g_e8CalibPostMotorRequest>, AL
    8196:	5401      	ret
				}
				else if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED )
    8198:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    819a:	8c00      	cmp	AL, #0
    819c:	1e84      	jsge	0x81a6 <_HandleBusTimeout+0x42>
				{
					/* Module is in degraded-mode; Postpone emergency-run till after degraded-mode have been obsoleted */
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    819e:	6007      	lod	AL, #7
    81a0:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
					g_e8DegradedMotorRequest = g_e8MotorRequest;
    81a2:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
    81a4:	5401      	ret
				}
				else
				{
					/* Perform emergency-run immediately */
					g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_EMRUN;
    81a6:	6007      	lod	AL, #7
    81a8:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    81aa:	5401      	ret

000081ac <_LIN2x_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The 
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2x_ErrorHandling( ml_LinError Error)
{
    81ac:	5803      	inc	S, #4
    81ae:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) LinProtectedID & 0x3F;							/* Get Frame-ID without parity bits */
    81b0:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    81b2:	b43f      	and	A, #63
    81b4:	5203      	mov	[S-4], A
	if ( (u8FrameID == (uint8) ML_MRF_ID) && ((Error == ml_erDataFraming) || (Error == ml_erCheckSum)) )
    81b6:	8c3c      	cmp	AL, #60
    81b8:	1d06      	jne	0x81c6 <_LIN2x_ErrorHandling+0x1a>
    81ba:	ec06      	cmp	Y, #6
    81bc:	1902      	je	0x81c2 <_LIN2x_ErrorHandling+0x16>
    81be:	ec04      	cmp	Y, #4
    81c0:	1d02      	jne	0x81c6 <_LIN2x_ErrorHandling+0x1a>
	{
		/*
		 * Abort Diagnostic communication with corrupted Diagnostic request
		 * Checked by LIN2.1 CT test case 13.2.2
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    81c2:	60ff      	lod	AL, #-1
    81c4:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
	}

	/* ---- ml_erLinModuleReset -------------------------------------------- */
	if ( Error == ml_erLinModuleReset )
    81c6:	ec02      	cmp	Y, #2
    81c8:	191e      	je	0x8206 <_LIN2x_ErrorHandling+0x5a>
	{
		/* Non-recoverable failure has occurred in the LIN Module */
		/* switch to System Mode and reinitialise LIN module */
	}
	/* ---- ml_erIdParity -------------------------------------------------- */
	else if ( Error == ml_erIdParity )
    81ca:	ec03      	cmp	Y, #3
    81cc:	191c      	je	0x8206 <_LIN2x_ErrorHandling+0x5a>
	{
		/* Do NOT set response_error bit, because error occurred in a header */
	}
	else if ( u8FrameID == (g_NvramUser.StatusFrameID & 0x3F) )
    81ce:	615f      	lod	AL, dp:0x5f <_g_NvramUser+0x7>
    81d0:	b43f      	and	A, #63
    81d2:	7a03      	lod	Y, [S-4]
    81d4:	eee2      	cmp	Y, A
    81d6:	1d07      	jne	0x81e6 <_LIN2x_ErrorHandling+0x3a>
	{
		uint8 u8CommNAD = LinFrame[6];											/* Seventh byte in LIN-frame is NAD */
    81d8:	610e      	lod	AL, dp:0xe <__bist_stat_size+0x6>
		if ( u8CommNAD == g_u8NAD )
    81da:	8d33      	cmp	AL, dp:0x33 <_g_u8NAD>
    81dc:	1d14      	jne	0x8206 <_LIN2x_ErrorHandling+0x5a>
		{
			g_u8ErrorCommunication = TRUE;
    81de:	6001      	lod	AL, #1
    81e0:	42d8 0121 	mov	0x121 <_g_u8ErrorCommunication>, AL
    81e4:	5405      	ret	#6
		}
	}
	else if ( (u8FrameID == (g_NvramUser.ControlFrameID & 0x3F)) ||
    81e6:	615e      	lod	AL, dp:0x5e <_g_NvramUser+0x6>
    81e8:	b43f      	and	A, #63
    81ea:	7a03      	lod	Y, [S-4]
    81ec:	eee2      	cmp	Y, A
    81ee:	1905      	je	0x81fa <_LIN2x_ErrorHandling+0x4e>
    81f0:	6203      	lod	AL, [S-4]
    81f2:	8c3c      	cmp	AL, #60
    81f4:	1902      	je	0x81fa <_LIN2x_ErrorHandling+0x4e>
    81f6:	8c3d      	cmp	AL, #61
    81f8:	1d06      	jne	0x8206 <_LIN2x_ErrorHandling+0x5a>
			  (u8FrameID == ML_MRF_ID) ||
			  (u8FrameID == ML_SRF_ID) )
	{
		uint8 u8CommNAD = LinFrame[0];											/* First byte in LIN-frame is NAD */
    81fa:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
		if ( u8CommNAD == g_u8NAD )
    81fc:	8d33      	cmp	AL, dp:0x33 <_g_u8NAD>
    81fe:	1d03      	jne	0x8206 <_LIN2x_ErrorHandling+0x5a>
		{
			g_u8ErrorCommunication = TRUE;
    8200:	6001      	lod	AL, #1
    8202:	42d8 0121 	mov	0x121 <_g_u8ErrorCommunication>, AL
    8206:	5405      	ret	#6

00008208 <_SetupDiagResponse>:

/* ****************************************************************************	*
 * SetupDiagResponse
 * ****************************************************************************	*/
void SetupDiagResponse( uint8 u8NAD, uint8 u8SID, uint8 u8ResponseCode)
{
    8208:	5801      	inc	S, #2
    820a:	6605      	lod	YL, [S-6]
    820c:	5cf6      	usex	Y
    820e:	5a01      	mov	[S-2], Y
    8210:	6607      	lod	YL, [S-8]
    8212:	5cf6      	usex	Y
	g_DiagResponse.byNAD = u8NAD;
    8214:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
	if ( u8ResponseCode == (uint8) C_ERRCODE_POSITIVE_RESPONSE )
    8216:	1d09      	jne	0x822a <_SetupDiagResponse+0x22>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x01|  SID | Reserved | Reserved | Reserved | Reserved | Reserved |
		 *	|  NAD  |     | |0x40|   0xFF   |   0xFF   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_REASSIGN_NAD;
    8218:	6001      	lod	AL, #1
    821a:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (u8SID | C_RSID_OK);
    821c:	6201      	lod	AL, [S-2]
    821e:	8440      	or	AL, #64
    8220:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    8222:	60ff      	lod	AL, #-1
    8224:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    8226:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
    8228:	0007      	jmp	0x8238 <_SetupDiagResponse+0x30>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x03| 0x7F | Requested| Response | Reserved | Reserved | Reserved |
		 *	|  NAD  |     |      |    SID   |   Code   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_NOK;
    822a:	6003      	lod	AL, #3
    822c:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_RSID_NOK;
    822e:	607f      	lod	AL, #127
    8230:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = u8SID;
    8232:	6201      	lod	AL, [S-2]
    8234:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = u8ResponseCode;
    8236:	4546      	mov	dp:0x46 <_g_DiagResponse+0x4>, YL
	}

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    8238:	6007      	lod	AL, #7
    823a:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
    823c:	5403      	ret	#4

0000823e <_CheckSupplier>:
/* ****************************************************************************	*
 * CheckSupplier
 * ****************************************************************************	*/
uint16 CheckSupplier( uint16 const u16SupplierID)
{
	uint16 u16Result = FALSE;
    823e:	7800      	lod	Y, #0
	if ( (u16SupplierID == (uint16) C_WILDCARD_SUPPLIER_ID)
    8240:	aeda 7fff 	cmp	A, #32767
    8244:	1902      	je	0x824a <_CheckSupplier+0xc>
    8246:	ac13      	cmp	A, #19
    8248:	1d01      	jne	0x824c <_CheckSupplier+0xe>
		|| (u16SupplierID == (uint16)C_SUPPLIER_ID) )
	{
		u16Result = TRUE;
    824a:	7801      	lod	Y, #1
	}
	return ( u16Result );
} /* End of CheckSupplier() */
    824c:	72e6      	lod	A, Y
    824e:	5401      	ret

00008250 <_ValidSupplierFunctionID>:
 * Pre:		Pointer to address of supplier and function ID
 * Post:	FALSE: Incorrect supplier and/or function ID
 *			TRUE: Correct supplier and function ID
 * ****************************************************************************	*/
uint16 ValidSupplierFunctionID( uint16 const u16SupplierID, uint16 const u16FunctionID )
{
    8250:	7a03      	lod	Y, [S-4]
	uint16 u16Result = FALSE;
    8252:	7c00      	lod	X, #0
	if ( ((u16SupplierID == C_SUPPLIER_ID)
    8254:	ac13      	cmp	A, #19
    8256:	1903      	je	0x825e <_ValidSupplierFunctionID+0xe>
    8258:	aeda 7fff 	cmp	A, #32767
    825c:	1d05      	jne	0x8268 <_ValidSupplierFunctionID+0x18>
    825e:	ec13      	cmp	Y, #19
    8260:	1902      	je	0x8266 <_ValidSupplierFunctionID+0x16>
    8262:	ecff      	cmp	Y, #-1
    8264:	1d01      	jne	0x8268 <_ValidSupplierFunctionID+0x18>
		|| (u16SupplierID == C_WILDCARD_SUPPLIER_ID)) &&
		((u16FunctionID == C_FUNCTION_ID)
		|| (u16FunctionID == C_WILDCARD_FUNCTION_ID)) )
	{
		u16Result = TRUE;
    8266:	7c01      	lod	X, #1
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */
    8268:	72ee      	lod	A, X
    826a:	5401      	ret

0000826c <_HandleDfrDiag>:

/* ****************************************************************************	*
 * Diagnostic
 * ****************************************************************************	*/
void HandleDfrDiag( void)
{
    826c:	581f      	inc	S, #32
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;

#if ((LINPROT & LINXX) == LIN2X)
	g_u16DiagResponseTimeoutCount = PI_TICKS_PER_SECOND;						/* Set LIN Diagnostics Response time-out to 1 sec */
    826e:	72da 07d0 	lod	A, #2000
    8272:	52d8 012e 	mov	0x12e <_g_u16DiagResponseTimeoutCount>, A

#if ((((LINPROT & LINXX) >= LIN21) && ((LINPROT & LINXX) <= LIN22)) || ((LINPROT & LINXX) == LIN2X))			/* LIN 2.1, LIN 2.2 */
	if ( pDiag->byNAD != 0x7E )
    8276:	613a      	lod	AL, dp:0x3a <__data_dp_end>
    8278:	421f      	mov	[S-32], AL
    827a:	8c7e      	cmp	AL, #126
    827c:	1902      	je	0x8282 <_HandleDfrDiag+0x16>
	{
		g_u8BufferOutID = (uint8) QR_INVALID;
    827e:	60ff      	lod	AL, #-1
    8280:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
	}
#endif /* ((((LINPROT & LINXX) >= LIN21) && ((LINPROT & LINXX) <= LIN22)) || ((LINPROT & LINXX) == LIN2X)) */	/* LIN 2.1, LIN 2.2 */

	if ( pDiag->byNAD == 0x00 )	/* Other bytes should be 0xFF, and are ignored */
    8282:	621f      	lod	AL, [S-32]
    8284:	1d03      	jne	0x828c <_HandleDfrDiag+0x20>
	{
		/* ACT_DFR_DIAG_SLEEP: Sleep request (Optional) */
		g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_SLEEP;
    8286:	6006      	lod	AL, #6
    8288:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    828a:	5421      	ret	#34
	}
	else if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == (uint8) C_BROADCAST_NAD) )
    828c:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    828e:	421e      	mov	[S-31], AL
    8290:	621f      	lod	AL, [S-32]
    8292:	8e1e      	cmp	AL, [S-31]
    8294:	1904      	je	0x829e <_HandleDfrDiag+0x32>
    8296:	8c7f      	cmp	AL, #127
    8298:	1902      	je	0x829e <_HandleDfrDiag+0x32>
    829a:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
#if ((LINPROT & LINXX) == LIN2J)
	/* Targeted or Broadcast */
	if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == C_BROADCAST_J2602_NAD) )
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		uint16 u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8) | ((uint16)pDiag->bySID);
    829e:	6d3b      	lod	YH, dp:0x3b <__data_dp_end+0x1>
    82a0:	6400      	lod	YL, #0
    82a2:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    82a4:	421d      	mov	[S-30], AL
    82a6:	5cf2      	usex	A
    82a8:	e6e2      	or	Y, A

		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    82aa:	60ff      	lod	AL, #-1
    82ac:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    82ae:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    82b0:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    82b2:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    82b4:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL

#if ((LINPROT & LINXX) == LIN2X)
		if ( (u16DiagPCI_SID == C_PCI_SID_STOP_ACTUATOR) && (pDiag->byD5 == 0xFE) )
    82b6:	eeda 06b5 	cmp	Y, #1717
    82ba:	1d1d      	jne	0x82f6 <_HandleDfrDiag+0x8a>
    82bc:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    82be:	8cfe      	cmp	AL, #-2
    82c0:	1d1a      	jne	0x82f6 <_HandleDfrDiag+0x8a>
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB5| Supplier | Supplier | Function | Function |  "Stop"  |
			 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xFE   |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8)) )
    82c2:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    82c4:	5cf2      	usex	A
    82c6:	7ee2      	lod	X, A
    82c8:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x6>
    82ca:	6000      	lod	AL, #0
    82cc:	26e2      	or	X, A
    82ce:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    82d0:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    82d2:	5edf      	push	X
    82d4:	17bd      	call	0x8250 <_ValidSupplierFunctionID>
    82d6:	5c01      	dec	S, #2
    82d8:	ac00      	cmp	A, #0
    82da:	1d02      	jne	0x82e0 <_HandleDfrDiag+0x74>
    82dc:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
			{
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Stop actuator NOW (LIN-AA) */
    82e0:	7002      	lod	A, #2
    82e2:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
				g_u8ChipResetOcc = FALSE;										/* Clear all event flags too (Reset, ... */
    82e6:	6400      	lod	YL, #0
    82e8:	4529      	mov	dp:0x29 <_g_u8ChipResetOcc>, YL
				g_u8StallOcc = FALSE;											/* ... Stall detected, and ... */
    82ea:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
				g_u8StallTypeComm &= ~M_STALL_MODE;								/* MMP130916-1 */
    82ec:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    82ee:	9487      	and	AL, #-121
    82f0:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
				g_u8EmergencyRunOcc = FALSE;									/* ... Emergency Run occurred  */
    82f2:	4527      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, YL
    82f4:	5421      	ret	#34
			}
		}
#if 1
		else if (  (g_e8MotorCtrlMode != (uint8) C_MOTOR_CTRL_STOP) &&
    82f6:	61ea      	lod	AL, dp:0xea <__bss_dp_end>
    82f8:	1914      	je	0x8322 <_HandleDfrDiag+0xb6>
    82fa:	621d      	lod	AL, [S-30]
    82fc:	8050      	add	AL, #80
    82fe:	8c01      	cmp	AL, #1
    8300:	1a05      	jule	0x830c <_HandleDfrDiag+0xa0>
    8302:	621d      	lod	AL, [S-30]
    8304:	8cb4      	cmp	AL, #-76
    8306:	1902      	je	0x830c <_HandleDfrDiag+0xa0>
    8308:	8cb7      	cmp	AL, #-73
    830a:	1d0b      	jne	0x8322 <_HandleDfrDiag+0xb6>
				  ((pDiag->bySID == (uint8) C_SID_REASSIGN_NAD) || (pDiag->bySID == (uint8) C_SID_ASSIGN_FRAME_ID) ||
				   (pDiag->bySID == (uint8) C_SID_DATA_DUMP) || (pDiag->bySID == (uint8) C_SID_ASSIGN_FRAME_ID_RNG)) )
		{
			/* Do not allow any "Write" except in STOP-mode, without Event-mode */
#endif
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_COND_SEQ);	/* Status = Negative feedback */
    830c:	621e      	lod	AL, [S-31]
    830e:	5cf2      	usex	A
    8310:	54ca 0022 	pushw	#34
    8314:	661f      	lod	YL, [S-32]
    8316:	5cf6      	usex	Y
    8318:	5adf      	push	Y
    831a:	1776      	call	0x8208 <_SetupDiagResponse>
			SetLastError( (uint8) C_ERR_LIN2X_WRITE);
    831c:	72da 00b9 	lod	A, #185
    8320:	02b7      	jmp	0x8890 <_HandleDfrDiag+0x624>
		}
		else if ( (u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD) && (pDiag->byNAD != (uint8) C_DEFAULT_NAD) )
    8322:	eeda 06b0 	cmp	Y, #1712
    8326:	1901      	je	0x832a <_HandleDfrDiag+0xbe>
    8328:	003c      	jmp	0x83a2 <_HandleDfrDiag+0x136>
    832a:	621f      	lod	AL, [S-32]
    832c:	8c16      	cmp	AL, #22
    832e:	1d01      	jne	0x8332 <_HandleDfrDiag+0xc6>
    8330:	02b2      	jmp	0x8896 <_HandleDfrDiag+0x62a>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB0 | Supplier | Supplier | Function | Function |  New NAD |
			 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8)) )
    8332:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8334:	5cf2      	usex	A
    8336:	7ee2      	lod	X, A
    8338:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x6>
    833a:	6000      	lod	AL, #0
    833c:	26e2      	or	X, A
    833e:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    8340:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8342:	5edf      	push	X
    8344:	1785      	call	0x8250 <_ValidSupplierFunctionID>
    8346:	5c01      	dec	S, #2
    8348:	ac00      	cmp	A, #0
    834a:	1d02      	jne	0x8350 <_HandleDfrDiag+0xe4>
    834c:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
			{
				uint8 byInitialNAD = g_NvramUser.NAD;
    8350:	615a      	lod	AL, dp:0x5a <_g_NvramUser+0x2>
    8352:	5cf2      	usex	A
    8354:	521b      	mov	[S-28], A
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);		/* Status = Negative feedback */
				}
				else
#endif /* ((LINPROT & LINXX) == LIN2J) */
				{
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);				/* Status = Pending */
    8356:	54ca 0078 	pushw	#120
    835a:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    835c:	5cf2      	usex	A
    835e:	52df      	push	A
    8360:	721f      	lod	A, [S-32]
    8362:	1752      	call	0x8208 <_SetupDiagResponse>
					g_NvramUser.NAD = pDiag->byD5;
    8364:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    8366:	415a      	mov	dp:0x5a <_g_NvramUser+0x2>, AL
					g_u8NAD = g_NvramUser.NAD;
    8368:	4133      	mov	dp:0x33 <_g_u8NAD>, AL
					/* Store NVRAM */
					if ( (NVRAM_Store( (uint16) C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.NAD == pDiag->byD5) )
    836a:	7003      	lod	A, #3
    836c:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    8370:	5c03      	dec	S, #4
    8372:	ac00      	cmp	A, #0
    8374:	1d0c      	jne	0x838e <_HandleDfrDiag+0x122>
    8376:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    8378:	8d5a      	cmp	AL, dp:0x5a <_g_NvramUser+0x2>
    837a:	1d09      	jne	0x838e <_HandleDfrDiag+0x122>
					{
						/* NAD changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    837c:	54ca 0000 	pushw	#0
    8380:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8382:	5cf2      	usex	A
    8384:	52df      	push	A
    8386:	721f      	lod	A, [S-32]
    8388:	173f      	call	0x8208 <_SetupDiagResponse>
    838a:	5c03      	dec	S, #4
    838c:	5421      	ret	#34
					}
					else
					{
						/* NAD couldn't be changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);		/* Status = Negative feedback */
    838e:	54ca 0012 	pushw	#18
    8392:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8394:	5cf2      	usex	A
    8396:	52df      	push	A
    8398:	721f      	lod	A, [S-32]
    839a:	1736      	call	0x8208 <_SetupDiagResponse>
						SetLastError( (uint8) C_ERR_LIN2X_B0);
    839c:	72da 00b0 	lod	A, #176
    83a0:	0277      	jmp	0x8890 <_HandleDfrDiag+0x624>
					}
				}
			}
		}
#if ((LINPROT & LINXX) == LIN2X)
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID )
    83a2:	eeda 06b1 	cmp	Y, #1713
    83a6:	1901      	je	0x83aa <_HandleDfrDiag+0x13e>
    83a8:	005d      	jmp	0x8464 <_HandleDfrDiag+0x1f8>
			 *	| NAD | 0x06| 0xB1| Supplier | Supplier |  Message |  Message |   Frame  |
			 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 * Only LIN 2.0 (Obsolete in LIN 2.1)
			 */
			if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8)) )
    83aa:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    83ac:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    83ae:	1747      	call	0x823e <_CheckSupplier>
    83b0:	ac00      	cmp	A, #0
    83b2:	1d02      	jne	0x83b8 <_HandleDfrDiag+0x14c>
    83b4:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
			{
				uint16 wMessageID = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    83b8:	6d40      	lod	YH, dp:0x40 <__data_dp_end+0x6>
    83ba:	653f      	lod	YL, dp:0x3f <__data_dp_end+0x5>
				if ( wMessageID == MSG_CONTROL )
    83bc:	ec01      	cmp	Y, #1
    83be:	1d1f      	jne	0x83fe <_HandleDfrDiag+0x192>
				{
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);				/* Status = Pending */
    83c0:	621e      	lod	AL, [S-31]
    83c2:	5cf2      	usex	A
    83c4:	54ca 0078 	pushw	#120
    83c8:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    83ca:	5cf6      	usex	Y
    83cc:	5adf      	push	Y
    83ce:	171c      	call	0x8208 <_SetupDiagResponse>
					g_NvramUser.ControlFrameID = pDiag->byD5;
    83d0:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    83d2:	415e      	mov	dp:0x5e <_g_NvramUser+0x6>, AL
					(void) ml_Disconnect();
    83d4:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
					(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_NvramUser.ControlFrameID);
    83d8:	615e      	lod	AL, dp:0x5e <_g_NvramUser+0x6>
    83da:	5cf2      	usex	A
    83dc:	52df      	push	A
    83de:	7001      	lod	A, #1
    83e0:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
					(void) ml_Connect();
    83e4:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
					/* Store NVRAM */
					if ( (NVRAM_Store( C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.ControlFrameID == pDiag->byD5) )
    83e8:	7003      	lod	A, #3
    83ea:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    83ee:	5c05      	dec	S, #6
    83f0:	ac00      	cmp	A, #0
    83f2:	1d27      	jne	0x8442 <_HandleDfrDiag+0x1d6>
    83f4:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    83f6:	8d5e      	cmp	AL, dp:0x5e <_g_NvramUser+0x6>
    83f8:	1d01      	jne	0x83fc <_HandleDfrDiag+0x190>
    83fa:	01fd      	jmp	0x87f6 <_HandleDfrDiag+0x58a>
    83fc:	0022      	jmp	0x8442 <_HandleDfrDiag+0x1d6>
    83fe:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8400:	4205      	mov	[S-6], AL
						/* Control Frame-ID couldn't be changed */
						SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);		/* Status = Negative feedback */
						SetLastError( (uint8) C_ERR_LIN2X_B1);
					}
				}
				else if ( wMessageID == MSG_STATUS )
    8402:	ec02      	cmp	Y, #2
    8404:	1d24      	jne	0x844e <_HandleDfrDiag+0x1e2>
				{
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);				/* Status = Pending */
    8406:	621e      	lod	AL, [S-31]
    8408:	5cf2      	usex	A
    840a:	54ca 0078 	pushw	#120
    840e:	6607      	lod	YL, [S-8]
    8410:	5cf6      	usex	Y
    8412:	5adf      	push	Y
    8414:	16f9      	call	0x8208 <_SetupDiagResponse>
					g_NvramUser.StatusFrameID = pDiag->byD5;
    8416:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    8418:	415f      	mov	dp:0x5f <_g_NvramUser+0x7>, AL
					(void) ml_Disconnect();
    841a:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
					(void) ml_AssignFrameToMessageID( MSG_STATUS, g_NvramUser.StatusFrameID);
    841e:	615f      	lod	AL, dp:0x5f <_g_NvramUser+0x7>
    8420:	5cf2      	usex	A
    8422:	52df      	push	A
    8424:	7002      	lod	A, #2
    8426:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
					(void) ml_Connect();
    842a:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
					/* Store NVRAM */
					if ( (NVRAM_Store( C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.StatusFrameID == pDiag->byD5) )
    842e:	7003      	lod	A, #3
    8430:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    8434:	5c05      	dec	S, #6
    8436:	ac00      	cmp	A, #0
    8438:	1d04      	jne	0x8442 <_HandleDfrDiag+0x1d6>
    843a:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    843c:	8d5f      	cmp	AL, dp:0x5f <_g_NvramUser+0x7>
    843e:	1d01      	jne	0x8442 <_HandleDfrDiag+0x1d6>
    8440:	01da      	jmp	0x87f6 <_HandleDfrDiag+0x58a>
						SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
					}
					else
					{
						/* Status Frame-ID couldn't be changed */
						SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);		/* Status = Negative feedback */
    8442:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    8444:	5cf2      	usex	A
    8446:	54ca 0012 	pushw	#18
    844a:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    844c:	0005      	jmp	0x8458 <_HandleDfrDiag+0x1ec>
				}
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
				else
				{
					/* Wrong Message-ID */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    844e:	621e      	lod	AL, [S-31]
    8450:	5cf2      	usex	A
    8452:	54ca 0012 	pushw	#18
    8456:	6607      	lod	YL, [S-8]
    8458:	5cf6      	usex	Y
    845a:	5adf      	push	Y
    845c:	16d5      	call	0x8208 <_SetupDiagResponse>
					SetLastError( (uint8) C_ERR_LIN2X_B1);
    845e:	72da 00b1 	lod	A, #177
    8462:	0216      	jmp	0x8890 <_HandleDfrDiag+0x624>
				}
			}
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else if ( u16DiagPCI_SID == C_PCI_SID_READ_BY_ID )
    8464:	eeda 06b2 	cmp	Y, #1714
    8468:	1901      	je	0x846c <_HandleDfrDiag+0x200>
    846a:	003b      	jmp	0x84e2 <_HandleDfrDiag+0x276>
			 * (0x40-0xFF: Reserved)
			 * (M) = Mandatory
			 * (O) = Optional
			 * (U) = User defined
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD2) | ((uint16)(pDiag->byD3) << 8), (pDiag->byD4) | ((uint16)(pDiag->byD5) << 8)) )
    846c:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    846e:	5cf2      	usex	A
    8470:	7ee2      	lod	X, A
    8472:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x7>
    8474:	6000      	lod	AL, #0
    8476:	26e2      	or	X, A
    8478:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x5>
    847a:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    847c:	5edf      	push	X
    847e:	16e8      	call	0x8250 <_ValidSupplierFunctionID>
    8480:	5c01      	dec	S, #2
    8482:	ac00      	cmp	A, #0
    8484:	1d02      	jne	0x848a <_HandleDfrDiag+0x21e>
    8486:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
			{
				if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    848a:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    848c:	1d0e      	jne	0x84aa <_HandleDfrDiag+0x23e>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xF2 | Supplier | Supplier | Function | Function |  Variant |
					 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    848e:	661e      	lod	YL, [S-31]
    8490:	4542      	mov	dp:0x42 <_g_DiagResponse>, YL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
    8492:	6006      	lod	AL, #6
    8494:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    8496:	60f2      	lod	AL, #-14
    8498:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
    849a:	6001      	lod	AL, #1
    849c:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    849e:	7813      	lod	Y, #19
	__asm__ __volatile__
    84a0:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
    84a2:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    84a4:	4547      	mov	dp:0x47 <_g_DiagResponse+0x5>, YL
    84a6:	4d48      	mov	dp:0x48 <_g_DiagResponse+0x6>, YH
    84a8:	000e      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
					g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* g_NvramUser.Variant; (MMP160613-3) */
					StoreD1to4( C_SUPPLIER_ID, C_FUNCTION_ID);					/* Supplier & Function-ID */
				}
				else if ( pDiag->byD1 == C_SERIAL_NR_ID )
    84aa:	8c01      	cmp	AL, #1
    84ac:	1d0f      	jne	0x84cc <_HandleDfrDiag+0x260>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x05| 0xF2 | SerialNr | SerialNr | SerialNr | SerialNr | Reserved |
					 *	|     |     |      |   (LSB)  |		     |          |   (MSB)  |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byNAD = g_u8NAD;
    84ae:	621e      	lod	AL, [S-31]
    84b0:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
					g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
    84b2:	6005      	lod	AL, #5
    84b4:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
					g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    84b6:	60f2      	lod	AL, #-14
    84b8:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    84ba:	7164      	lod	A, dp:0x64 <__data_size+0x2>
    84bc:	7966      	lod	Y, dp:0x66 <__data_size+0x4>
	__asm__ __volatile__
    84be:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
    84c0:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    84c2:	4547      	mov	dp:0x47 <_g_DiagResponse+0x5>, YL
    84c4:	4d48      	mov	dp:0x48 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    84c6:	6007      	lod	AL, #7
    84c8:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
    84ca:	5421      	ret	#34
#endif 	//LIN_2X_NO_USE
#endif /* ((LINPROT & LINXX) == LIN2X) */
				else
				{
					/* Identifier not supported */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    84cc:	621e      	lod	AL, [S-31]
    84ce:	5cf2      	usex	A
    84d0:	54ca 0012 	pushw	#18
    84d4:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    84d6:	5cf6      	usex	Y
    84d8:	5adf      	push	Y
    84da:	1696      	call	0x8208 <_SetupDiagResponse>
					SetLastError( (uint8) C_ERR_LIN2X_B2);
    84dc:	72da 00b2 	lod	A, #178
    84e0:	01d7      	jmp	0x8890 <_HandleDfrDiag+0x624>
				}
			}
		}
#if ((LINPROT & LINXX) == LIN2X)
		else if ( u16DiagPCI_SID == C_PCI_SID_CC_NAD )
    84e2:	eeda 06b3 	cmp	Y, #1715
    84e6:	1901      	je	0x84ea <_HandleDfrDiag+0x27e>
    84e8:	0059      	jmp	0x859c <_HandleDfrDiag+0x330>
			 *	| NAD | 0x06| 0xB3|Identifier|   Byte   |   Mask   |  Invert  | New NAD  |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 */
			/* Get the identifier of possible read by ID response and selected by Id */
			/* Extract the data byte selected by Byte */
			uint8 u8DataByte = 0x00;
    84ea:	7800      	lod	Y, #0
			uint8 u8Error = (uint8) C_ERR_NONE;
			if ( pDiag->byD1 == 0x00 ) /* Requested Id = LIN Product Identification */
    84ec:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    84ee:	1d0f      	jne	0x850e <_HandleDfrDiag+0x2a2>
			{
				if ( pDiag->byD2 == 1 )
    84f0:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    84f2:	8c01      	cmp	AL, #1
    84f4:	1904      	je	0x84fe <_HandleDfrDiag+0x292>
				{
					u8DataByte = (uint8) (C_SUPPLIER_ID & 0xFF);				/* LSB of Supplier-ID */
				}
				else if ( pDiag->byD2 == 2 )
    84f6:	8c02      	cmp	AL, #2
    84f8:	192a      	je	0x854e <_HandleDfrDiag+0x2e2>
				{
					u8DataByte = (uint8) (C_SUPPLIER_ID >> 8);					/* MSB of Supplier-ID */
				}
				else if ( pDiag->byD2 == 3 )
    84fa:	8c03      	cmp	AL, #3
    84fc:	1d02      	jne	0x8502 <_HandleDfrDiag+0x296>
				{
					u8DataByte = (uint8) (C_FUNCTION_ID & 0xFF);				/* LSB of Function-ID */
    84fe:	7813      	lod	Y, #19
    8500:	0026      	jmp	0x854e <_HandleDfrDiag+0x2e2>
				}
				else if ( pDiag->byD2 == 4 )
    8502:	8c04      	cmp	AL, #4
    8504:	1924      	je	0x854e <_HandleDfrDiag+0x2e2>
				{
					u8DataByte = (uint8) (C_FUNCTION_ID >> 8); /*lint !e572 */	/* MSB of Function-ID */
				}
				else if ( pDiag->byD2 == 5 )
    8506:	8c05      	cmp	AL, #5
    8508:	1d09      	jne	0x851c <_HandleDfrDiag+0x2b0>
				{
					u8DataByte = g_NvramUser.Variant;
    850a:	615b      	lod	AL, dp:0x5b <_g_NvramUser+0x3>
    850c:	0012      	jmp	0x8532 <_HandleDfrDiag+0x2c6>
				else
				{
					u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ;					/* Selected byte not in range, not valid => no response */
				}
			}
			else if ( pDiag->byD1 == 0x01 ) /* Requested Id = Serial number (optional) */
    850e:	8c01      	cmp	AL, #1
    8510:	1d13      	jne	0x8538 <_HandleDfrDiag+0x2cc>
			{
				if ( (pDiag->byD2 == 0) || (pDiag->byD2 > 4) )
    8512:	653e      	lod	YL, dp:0x3e <__data_dp_end+0x4>
    8514:	62e8      	lod	AL, YL
    8516:	80ff      	add	AL, #-1
    8518:	8c03      	cmp	AL, #3
    851a:	1a05      	jule	0x8526 <_HandleDfrDiag+0x2ba>
				{
					/* Selected byte not in range, not valid => no response */
					u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ;					/* Status = Invalid Format */
    851c:	4cd3      	swap	D
    851e:	48cf      	asl	D, #16
    8520:	4c0a 0013 	addu	D, #19
    8524:	000d      	jmp	0x8540 <_HandleDfrDiag+0x2d4>
				}
				else
				{
					uint8 *pu8Nvram = (uint8 *) &g_NvramUser.SerialNumberLSW;
					u8DataByte = pu8Nvram[pDiag->byD2 - 1];						/* Serial-number[n] */
    8526:	62e8      	lod	AL, YL
    8528:	5cf2      	usex	A
    852a:	7ae2      	lod	Y, A
    852c:	e2da 0063 	add	Y, #99
    8530:	62f0      	lod	AL, [Y]
    8532:	66e0      	lod	YL, AL
    8534:	5cf6      	usex	Y
    8536:	000b      	jmp	0x854e <_HandleDfrDiag+0x2e2>
				}
			}
			else
			{
				/* Identifier not supported */
				u8Error = (uint8) C_ERRCODE_SFUNC_NOSUP;						/* Status = Negative feedback */
    8538:	4cd3      	swap	D
    853a:	48cf      	asl	D, #16
    853c:	4c0a 0012 	addu	D, #18
			}

			if ( u8Error != (uint8) C_ERR_NONE )
			{
				SetupDiagResponse( g_u8NAD, pDiag->bySID, u8Error);
    8540:	621e      	lod	AL, [S-31]
    8542:	5cf2      	usex	A
    8544:	4c8b      	push	DL
    8546:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8548:	5cf6      	usex	Y
    854a:	5adf      	push	Y
    854c:	0023      	jmp	0x8594 <_HandleDfrDiag+0x328>
				SetLastError( (uint8) C_ERR_LIN2X_B3);
			}
			else
			{
				/* Do a bitwise XOR with Invert */
				u8DataByte ^= pDiag->byD4;
    854e:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8550:	9ee8      	xor	AL, YL

				/* Do a bitwise AND with Mask */
				u8DataByte &= pDiag->byD3;
    8552:	953f      	and	AL, dp:0x3f <__data_dp_end+0x5>

				if ( u8DataByte == 0 )												/* Condition PASSED */
    8554:	1902      	je	0x855a <_HandleDfrDiag+0x2ee>
    8556:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
				{
					uint8 byInitialNAD = g_NvramUser.NAD;
    855a:	615a      	lod	AL, dp:0x5a <_g_NvramUser+0x2>
    855c:	5cf2      	usex	A
    855e:	5219      	mov	[S-26], A
					SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);	/* Status = Pending */
    8560:	54ca 0078 	pushw	#120
    8564:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8566:	5cf2      	usex	A
    8568:	52df      	push	A
    856a:	721d      	lod	A, [S-30]
    856c:	164d      	call	0x8208 <_SetupDiagResponse>
					g_NvramUser.NAD = pDiag->byD5;									/* New NAD */
    856e:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    8570:	415a      	mov	dp:0x5a <_g_NvramUser+0x2>, AL
					g_u8NAD = g_NvramUser.NAD;
    8572:	4133      	mov	dp:0x33 <_g_u8NAD>, AL
					/* Store NVRAM */
					if ( (NVRAM_Store( C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.NAD == pDiag->byD5) )
    8574:	7003      	lod	A, #3
    8576:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    857a:	5c03      	dec	S, #4
    857c:	ac00      	cmp	A, #0
    857e:	1d04      	jne	0x8588 <_HandleDfrDiag+0x31c>
    8580:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    8582:	8d5a      	cmp	AL, dp:0x5a <_g_NvramUser+0x2>
    8584:	1d01      	jne	0x8588 <_HandleDfrDiag+0x31c>
    8586:	0137      	jmp	0x87f6 <_HandleDfrDiag+0x58a>
						SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
					}
					else
					{
						/* NAD couldn't be changed */
						SetupDiagResponse( byInitialNAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    8588:	54ca 0012 	pushw	#18
    858c:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    858e:	5cf2      	usex	A
    8590:	52df      	push	A
    8592:	721d      	lod	A, [S-30]
    8594:	1639      	call	0x8208 <_SetupDiagResponse>
						SetLastError( (uint8) C_ERR_LIN2X_B3);
    8596:	72da 00b3 	lod	A, #179
    859a:	017a      	jmp	0x8890 <_HandleDfrDiag+0x624>
					}
				}
			}
		}
		else if ( u16DiagPCI_SID == C_PCI_SID_DATA_DUMP )
    859c:	eeda 06b4 	cmp	Y, #1716
    85a0:	1901      	je	0x85a4 <_HandleDfrDiag+0x338>
    85a2:	0034      	jmp	0x860c <_HandleDfrDiag+0x3a0>
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB4| Supplier | Supplier |  Variant |  HW-Ref  |  SW-Ref  |
			 *	|     |     |     | ID (LSB) | ID (MSB) |    ID    |    ID    |    ID    |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 */
			if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8)) )
    85a4:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    85a6:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    85a8:	164a      	call	0x823e <_CheckSupplier>
    85aa:	ac00      	cmp	A, #0
    85ac:	1d02      	jne	0x85b2 <_HandleDfrDiag+0x346>
    85ae:	76da 8dec 	jmpf	0x8dec <_HandleDfrDiag+0xb80>
			{
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);	/* Status = Pending */
    85b2:	621e      	lod	AL, [S-31]
    85b4:	5cf2      	usex	A
    85b6:	54ca 0078 	pushw	#120
    85ba:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    85bc:	5cf6      	usex	Y
    85be:	5adf      	push	Y
    85c0:	1623      	call	0x8208 <_SetupDiagResponse>
				if ( pDiag->byD3 != 0xFF )
    85c2:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    85c4:	5c03      	dec	S, #4
    85c6:	8cff      	cmp	AL, #-1
    85c8:	1901      	je	0x85cc <_HandleDfrDiag+0x360>
				{
					g_NvramUser.Variant = pDiag->byD3;							/* Set new Variant-ID */
    85ca:	415b      	mov	dp:0x5b <_g_NvramUser+0x3>, AL
				}
				if ( pDiag->byD4 != 0xFF )
    85cc:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    85ce:	8cff      	cmp	AL, #-1
    85d0:	1901      	je	0x85d4 <_HandleDfrDiag+0x368>
				{
					g_NvramUser.HwRef = pDiag->byD4;							/* Set new HW-Reference */
    85d2:	415c      	mov	dp:0x5c <_g_NvramUser+0x4>, AL
				{
					/* -=#=- Note: SW-Ref should not be changed by this function, but be reprogramming the flash */
					/* g_NvramUser.SwRef = pDiag->byD5;	*/						/* Set new SW-Reference */
				}
				/* Store NVRAM */
				if ( (NVRAM_Store( C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY)
    85d4:	7003      	lod	A, #3
    85d6:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    85da:	ac00      	cmp	A, #0
    85dc:	1d0c      	jne	0x85f6 <_HandleDfrDiag+0x38a>
    85de:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    85e0:	8cff      	cmp	AL, #-1
    85e2:	1902      	je	0x85e8 <_HandleDfrDiag+0x37c>
    85e4:	8d5b      	cmp	AL, dp:0x5b <_g_NvramUser+0x3>
    85e6:	1d07      	jne	0x85f6 <_HandleDfrDiag+0x38a>
    85e8:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    85ea:	8cff      	cmp	AL, #-1
    85ec:	1d01      	jne	0x85f0 <_HandleDfrDiag+0x384>
    85ee:	0103      	jmp	0x87f6 <_HandleDfrDiag+0x58a>
    85f0:	8d5c      	cmp	AL, dp:0x5c <_g_NvramUser+0x4>
    85f2:	1d01      	jne	0x85f6 <_HandleDfrDiag+0x38a>
    85f4:	0100      	jmp	0x87f6 <_HandleDfrDiag+0x58a>
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
				}
				else
				{
					/* Variant-ID and/or HW-reference and/or SW-reference counldn't be changed */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    85f6:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    85f8:	5cf2      	usex	A
    85fa:	54ca 0012 	pushw	#18
    85fe:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8600:	5cf6      	usex	Y
    8602:	5adf      	push	Y
    8604:	1601      	call	0x8208 <_SetupDiagResponse>
					SetLastError( (uint8) C_ERR_LIN2X_B4);
    8606:	72da 00b4 	lod	A, #180
    860a:	0142      	jmp	0x8890 <_HandleDfrDiag+0x624>
				}
			}
		}
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_NAD )
    860c:	eeda 06b5 	cmp	Y, #1717
    8610:	1901      	je	0x8614 <_HandleDfrDiag+0x3a8>
    8612:	0087      	jmp	0x8722 <_HandleDfrDiag+0x4b6>
			/* This is a broadcast LIN-command; Therefore no feedback is returned */
			/* Beginning with the BSM-Initialisation, all SNPD nodes with BSM
			 * capability start their measurement sequence within the next
			 * break field.
			 */
			if ( ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8)) != FALSE ) && ((pDiag->byD4 == (uint8) C_SNPD_METHOD_BSM) || (pDiag->byD4 == (uint8) C_SNPD_METHOD_BSM2)) )	/* SNPD Method ID */
    8614:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    8616:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8618:	1612      	call	0x823e <_CheckSupplier>
    861a:	ac00      	cmp	A, #0
    861c:	1d01      	jne	0x8620 <_HandleDfrDiag+0x3b4>
    861e:	03e6      	jmp	0x8dec <_HandleDfrDiag+0xb80>
    8620:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8622:	4217      	mov	[S-24], AL
    8624:	8c02      	cmp	AL, #2
    8626:	1903      	je	0x862e <_HandleDfrDiag+0x3c2>
    8628:	8cf1      	cmp	AL, #-15
    862a:	1901      	je	0x862e <_HandleDfrDiag+0x3c2>
    862c:	03df      	jmp	0x8dec <_HandleDfrDiag+0xb80>
			{
				if ( (pDiag->byD3 == (uint8) C_SNPD_SUBFUNC_START) && (g_u8LinAAMode == 0) )	/* Sub-function ID */
    862e:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8630:	4216      	mov	[S-23], AL
    8632:	8c01      	cmp	AL, #1
    8634:	1d2a      	jne	0x868a <_HandleDfrDiag+0x41e>
    8636:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    863a:	1d27      	jne	0x868a <_HandleDfrDiag+0x41e>
					 * All SNPD slaves with BSM capability start their measurement
					 * sequence with the next break field.
					 * Function ID (MSB): 0x02 = Bus Shunt Method
					 * Function ID (LSB): 0x01 = BSM Initialisation
					 */
					if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )	/* If actuator is not stopped ... */
    863c:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    863e:	8c01      	cmp	AL, #1
    8640:	1d03      	jne	0x8648 <_HandleDfrDiag+0x3dc>
					{
						MotorDriverStop( (uint16) C_STOP_RAMPDOWN);				/* ... stop actuator NOW (LIN-AA) */
    8642:	7000      	lod	A, #0
    8644:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
					}
					g_u8ChipResetOcc = FALSE;
    8648:	6400      	lod	YL, #0
    864a:	4529      	mov	dp:0x29 <_g_u8ChipResetOcc>, YL
					g_u8StallOcc = FALSE;
    864c:	4528      	mov	dp:0x28 <_g_u8StallOcc>, YL
					g_u8StallTypeComm &= ~M_STALL_MODE;							/* MMP130916-1 */
    864e:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    8650:	9487      	and	AL, #-121
    8652:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
					g_u8EmergencyRunOcc = FALSE;
    8654:	4527      	mov	dp:0x27 <_g_u8EmergencyRunOcc>, YL
					g_e8MotorDirectionCCW = (uint8) C_MOTOR_DIR_UNKNOWN;		/* Direction is unknown (9.5.3.13) */
    8656:	6002      	lod	AL, #2
    8658:	412a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, AL

					ml_SetSlaveNotAddressed();									/* (Test) Allow re-addressing */
    865a:	82db 7e16 	callf	0x7e16 <_ml_SetSlaveNotAddressed>
#if LIN_AA_INFO
					ClearAAData();												/* Clear AA-ModuleScreening data */
    865e:	1454      	call	0x7f08 <_ClearAAData>
#endif /* LIN_AA_INFO */
					g_u16LinAATicker = PI_TICKS_PER_SECOND;						/* Re-start g_u16LinAATicker to time LIN-AA timeout of 40sec */
    8660:	72da 07d0 	lod	A, #2000
    8664:	52d8 0128 	mov	0x128 <_g_u16LinAATicker>, A
					g_u8LinAATimeout = (uint8) C_LINAA_TIMEOUT;					/* LIN-AA time-out counter (seconds) */
    8668:	6028      	lod	AL, #40
    866a:	42d8 012a 	mov	0x12a <_g_u8LinAATimeout>, AL
					g_u8LinAAMode = (uint8) C_SNPD_SUBFUNC_START;				/* LIN-AA mode (BSM-init) */
    866e:	6616      	lod	YL, [S-23]
    8670:	46d8 012b 	mov	0x12b <_g_u8LinAAMode>, YL
					if ( pDiag->byD4 == (uint8) C_SNPD_METHOD_BSM2 )
    8674:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8676:	8cf1      	cmp	AL, #-15
    8678:	1d05      	jne	0x8684 <_HandleDfrDiag+0x418>
					{
						g_u8LinAAMode |= (uint8) C_SNPD_METHOD_2;
    867a:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    867e:	8480      	or	AL, #-128
    8680:	42d8 012b 	mov	0x12b <_g_u8LinAAMode>, AL
					}
#if (LINAA_BSM_SNPD_R1p0 != FALSE)												/* MMP140417-2 - Begin */
					ml_InitAutoAddressing();
    8684:	82db 7e26 	callf	0x7e26 <_ml_InitAutoAddressing>
    8688:	5421      	ret	#34
#endif /* (LINAA_BSM_SNPD_R1p0 != FALSE) */										/* MMP140417-2 - End */
				}
				else if ( ((pDiag->byD4 == (uint8) C_SNPD_METHOD_BSM ) && ((g_u8LinAAMode & (uint8) C_SNPD_METHOD_2) == 0)) ||
    868a:	6217      	lod	AL, [S-24]
    868c:	8c02      	cmp	AL, #2
    868e:	1d05      	jne	0x869a <_HandleDfrDiag+0x42e>
    8690:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    8694:	8c00      	cmp	AL, #0
    8696:	1e8a      	jsge	0x86ac <_HandleDfrDiag+0x440>
    8698:	5421      	ret	#34
    869a:	6217      	lod	AL, [S-24]
    869c:	8cf1      	cmp	AL, #-15
    869e:	1901      	je	0x86a2 <_HandleDfrDiag+0x436>
    86a0:	03a5      	jmp	0x8dec <_HandleDfrDiag+0xb80>
    86a2:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    86a6:	8c00      	cmp	AL, #0
    86a8:	1a81      	jsl	0x86ac <_HandleDfrDiag+0x440>
    86aa:	03a0      	jmp	0x8dec <_HandleDfrDiag+0xb80>
						  ((pDiag->byD4 == (uint8) C_SNPD_METHOD_BSM2) && ((g_u8LinAAMode & (uint8) C_SNPD_METHOD_2) != 0)) )
				{
					if ( (pDiag->byD3 == (uint8) C_SNPD_SUBFUNC_ADDR) && ((g_u8LinAAMode & (uint8) M_SNPD_SUBFUNC) == (uint8) C_SNPD_SUBFUNC_START) )
    86ac:	6216      	lod	AL, [S-23]
    86ae:	8c02      	cmp	AL, #2
    86b0:	1d13      	jne	0x86d8 <_HandleDfrDiag+0x46c>
    86b2:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    86b6:	b407      	and	A, #7
    86b8:	ac01      	cmp	A, #1
    86ba:	1901      	je	0x86be <_HandleDfrDiag+0x452>
    86bc:	0397      	jmp	0x8dec <_HandleDfrDiag+0xb80>
						 *	+-----+-----+-----+----------+----------+----------+----------+----------+
						 * All SNPD slaves with BSM capability start their measurement sequence
						 * within the break field; after the break the selected SNPD slave takes
						 * the NAD.
						 */
						if ( ml_GetAutoaddressingStatus() )							/* MMP140417-2 */
    86be:	82db 7b20 	callf	0x7b20 <_ml_GetAutoaddressingStatus>
    86c2:	8c00      	cmp	AL, #0
    86c4:	1d01      	jne	0x86c8 <_HandleDfrDiag+0x45c>
    86c6:	0392      	jmp	0x8dec <_HandleDfrDiag+0xb80>
						{
							g_u8NAD = (pDiag->byD5);								/* New NAD (into RAM) */
    86c8:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    86ca:	4133      	mov	dp:0x33 <_g_u8NAD>, AL
							(void) ml_SetLoaderNAD( g_u8NAD);						/* Inform new NAD to LIN */
    86cc:	5cf2      	usex	A
    86ce:	82db 5da0 	callf	0x5da0 <_ml_SetLoaderNAD>
							ml_SetSlaveAddressed();									/* MMP140414-1 */
    86d2:	82db 7e1e 	callf	0x7e1e <_ml_SetSlaveAddressed>
    86d6:	5421      	ret	#34
						}
					}
					else if ( (pDiag->byD3 == (uint8) C_SNPD_SUBFUNC_STORE) && ((g_u8LinAAMode & (uint8) M_SNPD_SUBFUNC) == (uint8) C_SNPD_SUBFUNC_START) )
    86d8:	6216      	lod	AL, [S-23]
    86da:	8c03      	cmp	AL, #3
    86dc:	1d10      	jne	0x86fe <_HandleDfrDiag+0x492>
    86de:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    86e2:	b407      	and	A, #7
    86e4:	ac01      	cmp	A, #1
    86e6:	1901      	je	0x86ea <_HandleDfrDiag+0x47e>
    86e8:	0381      	jmp	0x8dec <_HandleDfrDiag+0xb80>
						 *	|     |     |     |  (0xFF)  |  (0x7F)  |  (0x03)  |0x02||0xF1|  (0xFF)  |
						 *	+-----+-----+-----+----------+----------+----------+----------+----------+
						 * All SNPD slaves with BSM capability store their new NAD from the
						 * RAM in to the NVM, if available.
						 */
						g_NvramUser.NAD = g_u8NAD;
    86ea:	661e      	lod	YL, [S-31]
    86ec:	455a      	mov	dp:0x5a <_g_NvramUser+0x2>, YL
						(void) NVRAM_Store( (uint16) C_NVRAM_USER_PAGE_ALL);
    86ee:	7003      	lod	A, #3
    86f0:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
						g_u8LinAAMode = (g_u8LinAAMode & (uint8) ~M_SNPD_SUBFUNC) | (uint8) C_SNPD_SUBFUNC_STORE;
    86f4:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    86f8:	94f8      	and	AL, #-8
    86fa:	8403      	or	AL, #3
    86fc:	000f      	jmp	0x871c <_HandleDfrDiag+0x4b0>
					}
					else if ( (pDiag->byD3 == (uint8) C_SNPD_SUBFUNC_FINISH) && ((g_u8LinAAMode & (uint8) M_SNPD_SUBFUNC) != 0) )
    86fe:	6216      	lod	AL, [S-23]
    8700:	8c04      	cmp	AL, #4
    8702:	1901      	je	0x8706 <_HandleDfrDiag+0x49a>
    8704:	0373      	jmp	0x8dec <_HandleDfrDiag+0xb80>
    8706:	62d8 012b 	lod	AL, 0x12b <_g_u8LinAAMode>
    870a:	b407      	and	A, #7
    870c:	1d01      	jne	0x8710 <_HandleDfrDiag+0x4a4>
    870e:	036e      	jmp	0x8dec <_HandleDfrDiag+0xb80>
						 *	+-----+-----+-----+----------+----------+----------+----------+----------+
						 * All SNPD slaves with BSM capability stop their measurement sequence
						 * in the break field.
						 */
#if (LINAA_BSM_SNPD_R1p0 != FALSE)												/* MMP140417-2 - Begin */
						ml_StopAutoAddressing();
    8710:	82db 7e7e 	callf	0x7e7e <_ml_StopAutoAddressing>
#endif /* (LINAA_BSM_SNPD_R1p0 != FALSE) */										/* MMP140417-2 - End */
						g_u16LinAATicker = 0;
    8714:	7800      	lod	Y, #0
    8716:	5ad8 0128 	mov	0x128 <_g_u16LinAATicker>, Y
						g_u8LinAAMode = 0;
    871a:	6000      	lod	AL, #0
    871c:	42d8 012b 	mov	0x12b <_g_u8LinAAMode>, AL
    8720:	5421      	ret	#34
				SetupDiagResponse( g_u8NAD, pDiag->bySID, C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
				SetLastError( (uint8) C_ERR_LIN2X_B6);
			}
		}
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID_RNG )
    8722:	eeda 06b7 	cmp	Y, #1719
    8726:	1901      	je	0x872a <_HandleDfrDiag+0x4be>
    8728:	006d      	jmp	0x8804 <_HandleDfrDiag+0x598>
			 * correct PIDs.
			 *
			 * A response shall only be sent if the NAD match.
			 */
			/* Since the slave node has only two frames the last two must be set to do not care (0xFF), otherwise the request will fail. */
			if ( (pDiag->byD4 != 0xFF) || (pDiag->byD5 != 0xFF) || (pDiag->byD1 > 1) || ((pDiag->byD1 == 1) && (pDiag->byD3 != 0xFF)) )
    872a:	7140      	lod	A, dp:0x40 <__data_dp_end+0x6>
    872c:	acff      	cmp	A, #-1
    872e:	1d07      	jne	0x873e <_HandleDfrDiag+0x4d2>
    8730:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8732:	8c01      	cmp	AL, #1
    8734:	1e04      	jug	0x873e <_HandleDfrDiag+0x4d2>
    8736:	1d0b      	jne	0x874e <_HandleDfrDiag+0x4e2>
    8738:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    873a:	8cff      	cmp	AL, #-1
    873c:	1908      	je	0x874e <_HandleDfrDiag+0x4e2>
			{
				/* Negative feedback */
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    873e:	621e      	lod	AL, [S-31]
    8740:	5cf2      	usex	A
    8742:	54ca 0012 	pushw	#18
    8746:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8748:	5cf6      	usex	Y
    874a:	5adf      	push	Y
    874c:	061d      	jmp	0x8388 <_HandleDfrDiag+0x11c>
			}
			else
			{
				uint16 u16NvramStoreResult;
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);		/* Status = Pending */
    874e:	621e      	lod	AL, [S-31]
    8750:	5cf2      	usex	A
    8752:	54ca 0078 	pushw	#120
    8756:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8758:	5cf6      	usex	Y
    875a:	5adf      	push	Y
    875c:	1555      	call	0x8208 <_SetupDiagResponse>

				u16NvramStoreResult = ~C_NVRAM_STORE_OKAY;
    875e:	78ff      	lod	Y, #-1
				if ( pDiag->byD1 == 0 )
    8760:	5c03      	dec	S, #4
    8762:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8764:	1d17      	jne	0x8794 <_HandleDfrDiag+0x528>
				{
					/* Starting with first message-index */
					if ( pDiag->byD2 != 0xFF )
    8766:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8768:	8cff      	cmp	AL, #-1
    876a:	1910      	je	0x878c <_HandleDfrDiag+0x520>
					{
						/* First Frame-ID is Control-message Frame-ID */
						g_NvramUser.ControlFrameID = pDiag->byD2;
    876c:	415e      	mov	dp:0x5e <_g_NvramUser+0x6>, AL
						(void) ml_Disconnect();
    876e:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
						if ( g_NvramUser.ControlFrameID != 0x00 )				/* MMP130913-1 - Begin */
    8772:	615e      	lod	AL, dp:0x5e <_g_NvramUser+0x6>
    8774:	1907      	je	0x8784 <_HandleDfrDiag+0x518>
						{
							(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_NvramUser.ControlFrameID);
    8776:	5cf2      	usex	A
    8778:	52df      	push	A
    877a:	7001      	lod	A, #1
    877c:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
    8780:	5c01      	dec	S, #2
    8782:	0003      	jmp	0x878a <_HandleDfrDiag+0x51e>
						}
						else
						{
							(void) ml_DisableMessage( MSG_CONTROL);
    8784:	7001      	lod	A, #1
    8786:	82db 5ac0 	callf	0x5ac0 <_ml_DisableMessage>
						}														/* MMP130913-1 - End */
						u16NvramStoreResult = C_NVRAM_STORE_OKAY;
    878a:	7800      	lod	Y, #0
					}
					if ( pDiag->byD3 != 0xFF )
    878c:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    878e:	8cff      	cmp	AL, #-1
    8790:	1918      	je	0x87c2 <_HandleDfrDiag+0x556>
    8792:	0007      	jmp	0x87a2 <_HandleDfrDiag+0x536>
						}
						u16NvramStoreResult = C_NVRAM_STORE_OKAY;
					}
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
				}
				else if ( pDiag->byD1 == 1 )
    8794:	8c01      	cmp	AL, #1
    8796:	1901      	je	0x879a <_HandleDfrDiag+0x52e>
    8798:	0033      	jmp	0x8800 <_HandleDfrDiag+0x594>
				{
					if ( pDiag->byD2 != 0xFF )
    879a:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    879c:	8cff      	cmp	AL, #-1
    879e:	1d01      	jne	0x87a2 <_HandleDfrDiag+0x536>
    87a0:	002f      	jmp	0x8800 <_HandleDfrDiag+0x594>
					{
						/* Starting with second message-index; First Frame-ID is Status-msg Frame-ID */
						g_NvramUser.StatusFrameID = pDiag->byD2;
    87a2:	415f      	mov	dp:0x5f <_g_NvramUser+0x7>, AL
						(void) ml_Disconnect();
    87a4:	82db 5ba6 	callf	0x5ba6 <_ml_Disconnect>
						if ( g_NvramUser.StatusFrameID != 0x00 )					/* MMP130913-1 - Begin */
    87a8:	615f      	lod	AL, dp:0x5f <_g_NvramUser+0x7>
    87aa:	1907      	je	0x87ba <_HandleDfrDiag+0x54e>
						{
							(void) ml_AssignFrameToMessageID( MSG_STATUS, g_NvramUser.StatusFrameID);
    87ac:	5cf2      	usex	A
    87ae:	52df      	push	A
    87b0:	7002      	lod	A, #2
    87b2:	82db 5aba 	callf	0x5aba <_ml_AssignFrameToMessageID>
    87b6:	5c01      	dec	S, #2
    87b8:	0006      	jmp	0x87c6 <_HandleDfrDiag+0x55a>
						}
						else
						{
							(void) ml_DisableMessage( MSG_STATUS);
    87ba:	7002      	lod	A, #2
    87bc:	82db 5ac0 	callf	0x5ac0 <_ml_DisableMessage>
    87c0:	0002      	jmp	0x87c6 <_HandleDfrDiag+0x55a>
						}
						u16NvramStoreResult = C_NVRAM_STORE_OKAY;
					}
				}
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
				if ( u16NvramStoreResult == C_NVRAM_STORE_OKAY )
    87c2:	ec00      	cmp	Y, #0
    87c4:	1d06      	jne	0x87d2 <_HandleDfrDiag+0x566>
				{
					(void) ml_Connect();
    87c6:	82db 5ba2 	callf	0x5ba2 <_ml_Connect>
					u16NvramStoreResult = NVRAM_Store( C_NVRAM_USER_PAGE_ALL);		/* Store NVRAM */
    87ca:	7003      	lod	A, #3
    87cc:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    87d0:	7ae2      	lod	Y, A
				}

				if ( (u16NvramStoreResult == C_NVRAM_STORE_OKAY) &&
    87d2:	ec00      	cmp	Y, #0
    87d4:	1d15      	jne	0x8800 <_HandleDfrDiag+0x594>
    87d6:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    87d8:	1d07      	jne	0x87e8 <_HandleDfrDiag+0x57c>
    87da:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    87dc:	8cff      	cmp	AL, #-1
    87de:	1902      	je	0x87e4 <_HandleDfrDiag+0x578>
    87e0:	8d5e      	cmp	AL, dp:0x5e <_g_NvramUser+0x6>
    87e2:	1d0e      	jne	0x8800 <_HandleDfrDiag+0x594>
    87e4:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    87e6:	0003      	jmp	0x87ee <_HandleDfrDiag+0x582>
    87e8:	8c01      	cmp	AL, #1
    87ea:	1d0a      	jne	0x8800 <_HandleDfrDiag+0x594>
    87ec:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    87ee:	8cff      	cmp	AL, #-1
    87f0:	1902      	je	0x87f6 <_HandleDfrDiag+0x58a>
    87f2:	8d5f      	cmp	AL, dp:0x5f <_g_NvramUser+0x7>
    87f4:	1d05      	jne	0x8800 <_HandleDfrDiag+0x594>
					)
#endif /* (_SUPPORT_HVAC_GROUP_ADDRESS != FALSE) */								/* MMP150125-1 - End */
					) )
				{
					/* Positive feedback */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    87f6:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    87f8:	5cf2      	usex	A
    87fa:	54ca 0000 	pushw	#0
    87fe:	07a3      	jmp	0x8746 <_HandleDfrDiag+0x4da>
				}
				else
				{
					/* Negative feedback */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    8800:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    8802:	079e      	jmp	0x8740 <_HandleDfrDiag+0x4d4>
				}
			}
		}
		else if ( u16DiagPCI_SID == C_PCI_SID_WRITE_BY_ID )
    8804:	eeda 06cb 	cmp	Y, #1739
    8808:	1901      	je	0x880c <_HandleDfrDiag+0x5a0>
    880a:	0045      	jmp	0x8896 <_HandleDfrDiag+0x62a>
			 *	| NAD | 0x06| 0x0B |Identifier| ID Data1 | ID Data2 | ID Data3 | ID Data4 |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 * Identifier: 00
			 * ID data 1-4
			 */
			uint16 u16SupplierID = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    880c:	6d3f      	lod	YH, dp:0x3f <__data_dp_end+0x5>
    880e:	6400      	lod	YL, #0
    8810:	7ee6      	lod	X, Y
    8812:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8814:	5cf2      	usex	A
    8816:	26e2      	or	X, A
			uint16 u16ParamID = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8818:	6d41      	lod	YH, dp:0x41 <__data_dp_end+0x7>
    881a:	6540      	lod	YL, dp:0x40 <__data_dp_end+0x6>
			if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    881c:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    881e:	1d2e      	jne	0x887c <_HandleDfrDiag+0x610>
			{
				/* Write Function ID */
				if ( (u16SupplierID == C_SUPPLIER_ID) && (u16ParamID == C_FUNCTION_ID) )			/* MMP130626-1 */
    8820:	2c13      	cmp	X, #19
    8822:	1d27      	jne	0x8872 <_HandleDfrDiag+0x606>
    8824:	ec13      	cmp	Y, #19
    8826:	1d25      	jne	0x8872 <_HandleDfrDiag+0x606>
				{
					/* Correct Supplier ID; Change Function ID allowed */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);			/* Status = Pending */
    8828:	621e      	lod	AL, [S-31]
    882a:	5cf2      	usex	A
    882c:	54ca 0078 	pushw	#120
    8830:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8832:	5cf6      	usex	Y
    8834:	5adf      	push	Y
    8836:	14e8      	call	0x8208 <_SetupDiagResponse>
					g_NvramUser.FunctionID = u16ParamID;
    8838:	7013      	lod	A, #19
    883a:	516e      	mov	dp:0x6e <__data_size+0xc>, A
					/* Store NVRAM */
					if ( (NVRAM_Store( C_NVRAM_USER_PAGE_ALL) == C_NVRAM_STORE_OKAY) && (g_NvramUser.FunctionID == u16ParamID) )
    883c:	7003      	lod	A, #3
    883e:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
    8842:	5c03      	dec	S, #4
    8844:	ac00      	cmp	A, #0
    8846:	1d13      	jne	0x886e <_HandleDfrDiag+0x602>
    8848:	716e      	lod	A, dp:0x6e <__data_size+0xc>
    884a:	ac13      	cmp	A, #19
    884c:	1d10      	jne	0x886e <_HandleDfrDiag+0x602>
					{
						/* Function-ID changed */
						g_DiagResponse.byNAD = g_u8NAD;
    884e:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    8850:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
						g_DiagResponse.byPCI = (uint8) C_RSID_WRITE_BY_ID;							/* Positive feedback */
    8852:	6006      	lod	AL, #6
    8854:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
						g_DiagResponse.byRSID = (uint8) C_RPCI_WRITE_BY_ID;
    8856:	600b      	lod	AL, #11
    8858:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
						g_DiagResponse.byD1 = pDiag->byD1;
    885a:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    885c:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
						g_DiagResponse.byD2 = pDiag->byD2;
    885e:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8860:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
						g_DiagResponse.byD3 = pDiag->byD3;
    8862:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8864:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
						g_DiagResponse.byD4 = pDiag->byD4;
    8866:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8868:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
						g_DiagResponse.byD5 = pDiag->byD5;
    886a:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    886c:	024a      	jmp	0x8d02 <_HandleDfrDiag+0xa96>
						g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
					}
					else
					{
						/* Function-ID couldn't be changed */
						SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    886e:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    8870:	0006      	jmp	0x887e <_HandleDfrDiag+0x612>
					}
				}
				else
				{
					/* Wrong Supplier ID (Wild-card not allowed) */
					SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);	/* Status = Negative feedback */
    8872:	621e      	lod	AL, [S-31]
    8874:	5cf2      	usex	A
    8876:	54ca 0013 	pushw	#19
    887a:	0004      	jmp	0x8884 <_HandleDfrDiag+0x618>
			}
#endif
			else
			{
				/* Identifier not supported */
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    887c:	621e      	lod	AL, [S-31]
    887e:	5cf2      	usex	A
    8880:	54ca 0012 	pushw	#18
    8884:	653c      	lod	YL, dp:0x3c <__data_dp_end+0x2>
    8886:	5cf6      	usex	Y
    8888:	5adf      	push	Y
    888a:	14be      	call	0x8208 <_SetupDiagResponse>
				SetLastError( (uint8) C_ERR_LIN2X_CB);
    888c:	72da 00bd 	lod	A, #189
    8890:	82db 9328 	callf	0x9328 <_SetLastError>
    8894:	057a      	jmp	0x838a <_HandleDfrDiag+0x11e>
			MLX16_RESET();														/* Reset the Mlx16  */
			/* This reset restart the chip as POR, and doesn't come back (no answer) */
		}
#endif /* ((LINPROT & LINXX) == LIN2J) */
#if _SUPPORT_MLX_DEBUG_MODE
		else if ( pDiag->bySID == C_SID_MLX_DEBUG )
    8896:	613c      	lod	AL, dp:0x3c <__data_dp_end+0x2>
    8898:	4215      	mov	[S-22], AL
    889a:	8cdb      	cmp	AL, #-37
    889c:	1901      	je	0x88a0 <_HandleDfrDiag+0x634>
    889e:	021f      	jmp	0x8cde <_HandleDfrDiag+0xa72>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| Debug| Supplier | Supplier | Param #1 | Param #2 | Function |
			 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |    ID    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			uint16 u16SupplierID = (((uint16) pDiag->byD2) << 8) | ((uint16) pDiag->byD1);
    88a0:	693e      	lod	AH, dp:0x3e <__data_dp_end+0x4>
    88a2:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
			if ( u16SupplierID == C_SUPPLIER_ID )
    88a4:	ac13      	cmp	A, #19
    88a6:	1901      	je	0x88aa <_HandleDfrDiag+0x63e>
    88a8:	0212      	jmp	0x8cce <_HandleDfrDiag+0xa62>
			{
				/* MMP131024-1: Reply diagnostics response with NAD, length and RSID.*/
				g_DiagResponse.byNAD = g_u8NAD;
    88aa:	661e      	lod	YL, [S-31]
    88ac:	4542      	mov	dp:0x42 <_g_DiagResponse>, YL
				g_DiagResponse.byPCI = 0x06;
    88ae:	6006      	lod	AL, #6
    88b0:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
    88b2:	6215      	lod	AL, [S-22]
    88b4:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
				 * 0xF8: NVRAM Clear function
				 * 0xFC: Clear Fatal-handler error logging
				 * 0xFD: Get I/O-register value (16-bits)
				 * 0xFE: Get Fatal-error: error-code, info and address
				 */
				if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT )				/* MMP140519-2 - Begin */
    88b6:	6141      	lod	AL, dp:0x41 <__data_dp_end+0x7>
    88b8:	4213      	mov	[S-20], AL
    88ba:	1d07      	jne	0x88ca <_HandleDfrDiag+0x65e>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  |MLX DBG[i]|MLX DBG[i]| Reserved | Reserved |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0F);
    88bc:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    88be:	b40f      	and	A, #15
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    88c0:	4422      	asl	A
    88c2:	7ae2      	lod	Y, A
    88c4:	e2da ab02 	add	Y, #43778
    88c8:	010b      	jmp	0x8ae0 <_HandleDfrDiag+0x874>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x0F);
					StoreD1to2( tMlxDbgSupport[u16Index]);
				}																/* MMP140519-2 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_STALLDET )
    88ca:	6213      	lod	AL, [S-20]
    88cc:	8c5d      	cmp	AL, #93
    88ce:	1d32      	jne	0x8934 <_HandleDfrDiag+0x6c8>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    88d0:	7ad8 0358 	lod	Y, 0x358 <_l_u16MotorCurrentStallThrshldxN>
    88d4:	44b6      	lsr	Y, #2
    88d6:	44b6      	lsr	Y, #2
    88d8:	44b6      	lsr	Y, #2
    88da:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    88de:	b6da 00ff 	and	A, #255
    88e2:	a2da 0100 	add	A, #256
    uint32 result;

    __asm__ __volatile__ (
    88e6:	4801      	mulu	D, A, Y
    88e8:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    88ea:	4c22 0040 	add	YA, #64
    88ee:	0000 
    88f0:	48a6      	lsr	YA, #7
					 *	| NAD | 0x06| 0xDB |Stallcurrent|Stallcurrent|Motorcurrent|Motorcurrent|StallFlags|
					 *	|     |     |      |Thrshld(LSB)|Thrshld(LSB)|MovAvg (LSB)|MovAvg (MSB)|          |
					 *	+-----+-----+------+------------+------------+------------+------------+----------+
					 */
					uint16 u16Value = (uint16) ((mulU32_U16byU16( (l_u16MotorCurrentStallThrshldxN >> C_MOVAVG_SSZ), EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Stall motor-current threshold [mA] */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
    88f2:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
					g_DiagResponse.byD2 = (uint8) (u16Value >> 8);
    88f4:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    88f6:	7954      	lod	Y, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    88f8:	44b6      	lsr	Y, #2
    88fa:	44b6      	lsr	Y, #2
    88fc:	44b6      	lsr	Y, #2
    88fe:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    8902:	b6da 00ff 	and	A, #255
    8906:	a2da 0100 	add	A, #256
    uint32 result;

    __asm__ __volatile__ (
    890a:	4801      	mulu	D, A, Y
    890c:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    890e:	4c22 0040 	add	YA, #64
    8912:	0000 
    8914:	48a6      	lsr	YA, #7
					u16Value = (uint16) ((mulU32_U16byU16( (g_u16MotorCurrentMovAvgxN >> C_MOVAVG_SSZ), EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV); /* Moving average-motor current [mA] */
					g_DiagResponse.byD3 = (uint8) (u16Value & 0xFF);
    8916:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
					g_DiagResponse.byD4 = (uint8) (u16Value >> 8);
    8918:	4948      	mov	dp:0x48 <_g_DiagResponse+0x6>, AH
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountO & 0x07);	/* Stall detection & count */
					}
					else
#endif /* _SUPPORT_STALLDET_O */												/* MMP140330-1 */
					{
						g_DiagResponse.byD5 = (g_u8StallTypeComm & M_STALL_MODE) | (l_u8StallCountA & 0x07);	/* Stall detection & count */
    891a:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    891c:	9478      	and	AL, #120
    891e:	4211      	mov	[S-18], AL
    8920:	6139      	lod	AL, dp:0x39 <_l_u8StallCountA>
    8922:	9407      	and	AL, #7
    8924:	8611      	or	AL, [S-18]
    8926:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL
					}
					if ( g_e8StallDetectorEna != C_STALLDET_NONE )				/* MMP130916-1 */
    8928:	61ec      	lod	AL, dp:0xec <_g_e8StallDetectorEna>
    892a:	1d01      	jne	0x892e <_HandleDfrDiag+0x6c2>
    892c:	05cc      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					{
						g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;
    892e:	6000      	lod	AL, #0
    8930:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
    8932:	05c9      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_INFO != FALSE)
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LINAA_1 )
    8934:	6213      	lod	AL, [S-20]
    8936:	8ca1      	cmp	AL, #-95
    8938:	1d26      	jne	0x8986 <_HandleDfrDiag+0x71a>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   Step   |  Ishunt1 |  Ishunt2 |  Ishunt3 | AA-Flags |
					 *	|     |     |      |CycleCount|          |          |          |          |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					PSNPD_DATA pSNPD_Data = LIN_AA_DATA + l_u8SNPD_CycleCountComm;
    893a:	62d8 012c 	lod	AL, 0x12c <_l_u8SNPD_CycleCountComm>
    893e:	4210      	mov	[S-17], AL
    8940:	5cf2      	usex	A
    8942:	4872 0010 	muls	A, A, #16
    8946:	7ae2      	lod	Y, A
    8948:	e2da 0160 	add	Y, #352
					g_DiagResponse.byD1 = (uint8) ((pSNPD_Data->byStepAndFlags << 1) & 0xF0) | (l_u8SNPD_CycleCountComm & 0x0F); /* MMP130818-1 */
    894c:	62f0      	lod	AL, [Y]
    894e:	420f      	mov	[S-16], AL
    8950:	4420      	asl	AL
    8952:	94f0      	and	AL, #-16
    8954:	420e      	mov	[S-15], AL
    8956:	6210      	lod	AL, [S-17]
    8958:	940f      	and	AL, #15
    895a:	860e      	or	AL, [S-15]
    895c:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
					g_DiagResponse.byD2 = pSNPD_Data->byIshunt1;
    895e:	62f1      	lod	AL, [Y+1]
    8960:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
					g_DiagResponse.byD3 = pSNPD_Data->byIshunt2;
    8962:	62f2      	lod	AL, [Y+2]
    8964:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
					g_DiagResponse.byD4 = pSNPD_Data->byIshunt3;
    8966:	62f3      	lod	AL, [Y+3]
    8968:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
					g_DiagResponse.byD5 = (pSNPD_Data->byStepAndFlags & 0x87);	/* MMP130818-1 */
    896a:	620f      	lod	AL, [S-16]
    896c:	9487      	and	AL, #-121
    896e:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL
					l_u8SNPD_CycleCountComm++;
    8970:	6210      	lod	AL, [S-17]
    8972:	8001      	add	AL, #1
    8974:	42d8 012c 	mov	0x12c <_l_u8SNPD_CycleCountComm>, AL
					if ( l_u8SNPD_CycleCountComm >= LIN_AA_INFO_SZ )								/* Don't increase index incase last AA-structure index */
    8978:	8c0f      	cmp	AL, #15
    897a:	1e01      	jug	0x897e <_HandleDfrDiag+0x712>
    897c:	05a4      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					{
						l_u8SNPD_CycleCountComm = 0;
    897e:	6400      	lod	YL, #0
    8980:	46d8 012c 	mov	0x12c <_l_u8SNPD_CycleCountComm>, YL
    8984:	05a0      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;											/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_SCREENTEST != FALSE)
				else if ( (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_LINAA_2) && (pDiag->byD5 <= (uint8) C_DBG_SUBFUNC_LINAA_4) )
    8986:	6213      	lod	AL, [S-20]
    8988:	805e      	add	AL, #94
    898a:	8c02      	cmp	AL, #2
    898c:	1e19      	jug	0x89c0 <_HandleDfrDiag+0x754>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |CycleCount|CommonMode|CommonMode|DifferMode|DifferMode|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					PSNPD_DATA pSNPD_Data = LIN_AA_DATA + l_u8SNPD_CycleCountComm;
    898e:	66d8 012c 	lod	YL, 0x12c <_l_u8SNPD_CycleCountComm>
    8992:	62e8      	lod	AL, YL
    8994:	5cf2      	usex	A
    8996:	4872 0010 	muls	A, A, #16
    899a:	7ee2      	lod	X, A
    899c:	22da 0160 	add	X, #352
					uint16 *pu16CMDM;
					g_DiagResponse.byD1 = l_u8SNPD_CycleCountComm;
    89a0:	4545      	mov	dp:0x45 <_g_DiagResponse+0x3>, YL
					if ( (pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LINAA_2))
    89a2:	6213      	lod	AL, [S-20]
    89a4:	8ca2      	cmp	AL, #-94
    89a6:	1d03      	jne	0x89ae <_HandleDfrDiag+0x742>
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_1);
    89a8:	7aee      	lod	Y, X
    89aa:	e004      	add	Y, #4
    89ac:	01f6      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
					else if (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_LINAA_3)
    89ae:	6213      	lod	AL, [S-20]
    89b0:	8ca2      	cmp	AL, #-94
    89b2:	1a03      	jule	0x89ba <_HandleDfrDiag+0x74e>
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_2);
    89b4:	7aee      	lod	Y, X
    89b6:	e008      	add	Y, #8
    89b8:	01f0      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
					else
						pu16CMDM = (uint16 *) &(pSNPD_Data->u16CM_3);
    89ba:	7aee      	lod	Y, X
    89bc:	e00c      	add	Y, #12
    89be:	01ed      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
					StoreD2to5( pu16CMDM[0], pu16CMDM[1]); /*lint !e415 */
				}
#endif /* (LIN_AA_SCREENTEST != FALSE) */
#endif /* (LIN_AA_INFO != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APPLSTATE )
    89c0:	6213      	lod	AL, [S-20]
    89c2:	8ca5      	cmp	AL, #-91
    89c4:	1d25      	jne	0x8a10 <_HandleDfrDiag+0x7a4>
					 *	bit 5: Emergency Run occurred
					 *	bit 4: Over-temperature
					 *  bit 3:2: Voltage (In-range, UV and OV)
					 *  bit 1:0: Electric Error (Ok, Error, Permanent)
					 */
					g_DiagResponse.byD1 = g_e8MotorStatusMode;
    89c6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    89c8:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
					{
						uint16 u16CopyPosition = g_u16ActualPosition;
    89ca:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
						g_DiagResponse.byD2 = (uint8) (u16CopyPosition & 0xFF);
    89cc:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
						g_DiagResponse.byD3 = (uint8) (u16CopyPosition >> 8);
    89ce:	4947      	mov	dp:0x47 <_g_DiagResponse+0x5>, AH
					}
					g_DiagResponse.byD4 = (g_e8MotorRequest & 0x0F);
    89d0:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    89d2:	940f      	and	AL, #15
    89d4:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
					{
						uint8 u8D5 = ((g_e8ErrorVoltage & 0x03) << 2) | (g_e8ErrorElectric & 0x03);
    89d6:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    89d8:	b403      	and	A, #3
    89da:	44a2      	asl	A, #2
    89dc:	652d      	lod	YL, dp:0x2d <_g_e8ErrorElectric>
    89de:	f403      	and	Y, #3
    89e0:	e6e2      	or	Y, A
						if ( g_e8ErrorOverTemperature != FALSE )
    89e2:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    89e4:	1901      	je	0x89e8 <_HandleDfrDiag+0x77c>
							u8D5 |= 0x10;
    89e6:	e410      	or	Y, #16
						if ( g_u8EmergencyRunOcc != FALSE )
    89e8:	6127      	lod	AL, dp:0x27 <_g_u8EmergencyRunOcc>
    89ea:	1904      	je	0x89f4 <_HandleDfrDiag+0x788>
							u8D5 |= 0x20;
    89ec:	62e8      	lod	AL, YL
    89ee:	8420      	or	AL, #32
    89f0:	66e0      	lod	YL, AL
    89f2:	5cf6      	usex	Y
						if ( g_u8StallOcc != FALSE )
    89f4:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    89f6:	1904      	je	0x8a00 <_HandleDfrDiag+0x794>
							u8D5 |= 0x40;
    89f8:	62e8      	lod	AL, YL
    89fa:	8440      	or	AL, #64
    89fc:	66e0      	lod	YL, AL
    89fe:	5cf6      	usex	Y
						if (g_u8ChipResetOcc != FALSE)
    8a00:	6129      	lod	AL, dp:0x29 <_g_u8ChipResetOcc>
    8a02:	1904      	je	0x8a0c <_HandleDfrDiag+0x7a0>
							u8D5 |= 0x80;
    8a04:	62e8      	lod	AL, YL
    8a06:	8480      	or	AL, #-128
    8a08:	66e0      	lod	YL, AL
    8a0a:	5cf6      	usex	Y
						g_DiagResponse.byD5 = u8D5;
    8a0c:	4549      	mov	dp:0x49 <_g_DiagResponse+0x7>, YL
    8a0e:	055b      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					}
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;											/* LIN Output buffer is valid (RFR_DIAG) */
				}
#if (LIN_AA_INFO && LIN_AA_SCREENTEST)
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_LIN_BAUDRATE )	/* MMP130810-1 - Begin */
    8a10:	6213      	lod	AL, [S-20]
    8a12:	8ca6      	cmp	AL, #-90
    8a14:	1d07      	jne	0x8a24 <_HandleDfrDiag+0x7b8>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |  MCU_PLL |NomLINBaud|NomLINBaud|ActLINBaud|ActLINBaud|
					 *	|     |     |      |   _MULT  |rate (LSB)|rate (MSB)|rate (LSB)|rate (MSB)|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD1 = (uint8) MCU_PLL_MULT;					/* MMP131022-1 */
    8a16:	6070      	lod	AL, #112
    8a18:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8a1a:	82db 5dda 	callf	0x5dda <_ml_GetBaudRate>
    8a1e:	7ae2      	lod	Y, A
	__asm__ __volatile__
    8a20:	70ff      	lod	A, #-1
    8a22:	01bd      	jmp	0x8d9e <_HandleDfrDiag+0xb32>
					g_DiagResponse.byD5 = (uint8) (u16Baudrate >> 8);
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 3) */
				}																/* MMP130810-1 - End */
#endif /* (LIN_AA_INFO && LIN_AA_SCREENTEST) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_RESTART_AUTO_BAUDRATE )	/* MMP130828-1 - Begin */
    8a24:	6213      	lod	AL, [S-20]
    8a26:	8ca7      	cmp	AL, #-89
    8a28:	1d07      	jne	0x8a38 <_HandleDfrDiag+0x7cc>
					 */
#if ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1))
					__asm__("clrb dp:_LinBusStatus.1");							/* LinBusStatus &= ~ML_LIN_BAUDRATE_DETECTED; */
#endif /* ((__MLX_PLTF_VERSION_MAJOR__ == 3) && (__MLX_PLTF_VERSION_MINOR__ >= 1)) */
#if (__MLX_PLTF_VERSION_MAJOR__ == 4)
					(void)ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);		/* MMP141215-1 */
    8a2a:	7000      	lod	A, #0
    8a2c:	82db 5b9a 	callf	0x5b9a <_ml_SetAutoBaudRateMode>
#endif /* (__MLX_PLTF_VERSION_MAJOR__ == 4) */
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK
					g_u8Mlx4ErrorState = C_MLX4_STATE_IMMEDIATE_RST;			/* Reset MLX4 too */
    8a30:	6080      	lod	AL, #-128
    8a32:	42d8 010c 	mov	0x10c <_g_u8Mlx4ErrorState>, AL
    8a36:	5421      	ret	#34
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK */
				}																/* MMP130828-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_ADC_RAW )
    8a38:	6213      	lod	AL, [S-20]
    8a3a:	8cac      	cmp	AL, #-84
    8a3c:	1d06      	jne	0x8a4a <_HandleDfrDiag+0x7de>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8a3e:	12fa      	call	0x9034 <_GetRawTemperature>
    8a40:	520d      	mov	[S-14], A
    8a42:	1291      	call	0x8f66 <_GetRawChipSupply>
    8a44:	7ae2      	lod	Y, A
	__asm__ __volatile__
    8a46:	720d      	lod	A, [S-14]
    8a48:	053a      	jmp	0x84be <_HandleDfrDiag+0x252>
					 *	|     |     |      |   (LSB)   |   (MSB)   |  (LSB)  |  (MSB)  |          |
					 *	+-----+-----+------+-----------+-----------+---------+---------+----------+
					 */
					StoreD1to4( GetRawTemperature(), GetRawChipSupply());
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_AMBJENV )
    8a4a:	6213      	lod	AL, [S-20]
    8a4c:	8cae      	cmp	AL, #-82
    8a4e:	1d03      	jne	0x8a56 <_HandleDfrDiag+0x7ea>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8a50:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    8a52:	78ff      	lod	Y, #-1
    8a54:	01a4      	jmp	0x8d9e <_HandleDfrDiag+0xb32>
					StoreD2to5( (uint16) g_i16MotorVoltage, (uint16) g_i16PhaseVoltage);
#else  /* _SUPPORT_PHASE_SHORT_DET */
					StoreD2to5( (uint16) g_i16MotorVoltage, 0xFFFF);
#endif /* _SUPPORT_PHASE_SHORT_DET */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX16_CLK )		/* MMP140527-1 - Begin */
    8a56:	6213      	lod	AL, [S-20]
    8a58:	8cc0      	cmp	AL, #-64
    8a5a:	1d30      	jne	0x8abc <_HandleDfrDiag+0x850>
    8a5c:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    8a60:	5ce2      	ssex	A
    8a62:	a2da 0800 	add	A, #2048
    8a66:	5201      	mov	[S-2], A
    8a68:	7ada 03e8 	lod	Y, #1000
    8a6c:	7eda 0800 	lod	X, #2048
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8a70:	4821      	mulu	YA, A, Y
    8a72:	4c63      	divu	YA, X
    8a74:	4c63      	divu	YA, X
    8a76:	520b      	mov	[S-12], A
					 *	| NAD | 0x06| 0xDB |MLX16Clock|MLX16Clock| Reserved | Reserved | Reserved |
					 *	|     |     |      |[kHz](LSB)|[kHz](MSB)|   0xFF   |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16RC_Clock = muldivU16_U16byU16byU16( (2048 + EE_OCLOCK), 1000, 2048);
					int16 i16ADC_Temp = (int16) (GetRawTemperature() - EE_OTEMP);
    8a78:	12dd      	call	0x9034 <_GetRawTemperature>
    8a7a:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    8a7e:	aae6      	sub	A, Y
    8a80:	7ae2      	lod	Y, A
					int16 i16Coef;
					if ( i16ADC_Temp <= 0 )
    8a82:	ac00      	cmp	A, #0
    8a84:	1f05      	jsg	0x8a90 <_HandleDfrDiag+0x824>
					{
						/* ((dTemp * Gp) * 1000)/131072 --> ((dTemp * Gp) * 125)/16384 */
						i16Coef = EE_GPCLOCK;
    8a86:	72d8 11c4 	lod	A, 0x11c4 <__ep__+0x1c4>
    8a8a:	62e4      	lod	AL, AH
    8a8c:	5ce2      	ssex	A
    8a8e:	0003      	jmp	0x8a96 <_HandleDfrDiag+0x82a>
					}
					else
					{
						/* ((dTemp * Gn) * 1000)/131072 --> ((dTemp * Gn) * 125)/16384 */
						i16Coef = EE_GNCLOCK;
    8a90:	72d8 11c6 	lod	A, 0x11c6 <__ep__+0x1c6>
    8a94:	5ce2      	ssex	A
					}
					i16Coef = (125 * i16Coef);
    8a96:	4872 007d 	muls	A, A, #125
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    8a9a:	7eda 4000 	lod	X, #16384
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8a9e:	4831      	muls	YA, A, Y
    8aa0:	4c73      	divs	YA, X
    8aa2:	4c73      	divs	YA, X
    8aa4:	4c7b      	dadjs	YA, X
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    8aa6:	7a0b      	lod	Y, [S-12]
    8aa8:	e2e2      	add	Y, A
    8aaa:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    8aae:	6000      	lod	AL, #0
    8ab0:	72e4      	swap	A
    8ab2:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    8ab4:	4801      	mulu	D, A, Y
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8ab6:	4881      	lsr	D, #2
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
	__asm__ __volatile__
    8ab8:	4c88      	mov	A, DL
    8aba:	0013      	jmp	0x8ae2 <_HandleDfrDiag+0x876>
					}
					i16Coef = (125 * i16Coef);
					u16RC_Clock += muldivI16_I16byI16byI16( i16ADC_Temp, i16Coef, 16384);
					StoreD1to2( (uint16) (mulU32_U16byU16( u16RC_Clock, ((PLL_CTRL >> 8) + 1)) >> 2));
				}																/* MMP140527-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPID )
    8abc:	6213      	lod	AL, [S-20]
    8abe:	8cc1      	cmp	AL, #-63
    8ac0:	1d08      	jne	0x8ad2 <_HandleDfrDiag+0x866>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x02);
    8ac2:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8ac4:	b402      	and	A, #2
					g_DiagResponse.byD1 = (uint8) u16Index;
    8ac6:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLX_CHIPID) + u16Index;			/* NVRAM 16-bit pointer */
    8ac8:	4422      	asl	A
    8aca:	7ae2      	lod	Y, A
    8acc:	e2da 1188 	add	Y, #4488
    8ad0:	0164      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_HWSWID )
    8ad2:	6213      	lod	AL, [S-20]
    8ad4:	8cc2      	cmp	AL, #-62
    8ad6:	1d08      	jne	0x8ae8 <_HandleDfrDiag+0x87c>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | HW/SW ID | HW/SW ID | CPU-Clock| Reserved | Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |          |   0xFF   |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
    8ad8:	6070      	lod	AL, #112
    8ada:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    8adc:	7ada 1182 	lod	Y, #4482
    8ae0:	72f0      	lod	A, [Y]
	__asm__ __volatile__
    8ae2:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
    8ae4:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    8ae6:	04ef      	jmp	0x84c6 <_HandleDfrDiag+0x25a>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD3 = (uint8) MCU_PLL_MULT;
					StoreD1to2( *((uint16 *) C_ADDR_MLX_HWSWID));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_SUPPORT_OPTIONS )	/* MMP140904-1 - Begin */
    8ae8:	6213      	lod	AL, [S-20]
    8aea:	8cc6      	cmp	AL, #-58
    8aec:	1d0a      	jne	0x8b02 <_HandleDfrDiag+0x896>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | SUPPORT  | SUPPORT  |  SUPPORT |  SUPPORT | Reserved |
					 *	|     |     |      |   (LSB)  |          |          |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					g_DiagResponse.byD1 = (uint8) (C_DIAG_RES
    8aee:	6084      	lod	AL, #-124
    8af0:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
#endif /* _SUPPORT_MLX16_HALT */
#if _SUPPORT_CHIP_TEMP_PROFILE
													& ~(1U << 7)				/* bit 7: Chip temperature profile check (dT/dt) support */
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */
																);
					g_DiagResponse.byD2 = (uint8) (C_DIAG_RES
    8af2:	60f9      	lod	AL, #-7
    8af4:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
#endif /* _SUPPORT_LINNETWORK_LOADER */
#if _SUPPORT_BUSTIMEOUT_SLEEP
													& ~(1U << 3)				/* bit 3: Bus-time-out to sleep support */
#endif /* _SUPPORT_BUSTIMEOUT_SLEEP */
																);
					g_DiagResponse.byD3 = (uint8) (C_DIAG_RES
    8af6:	60cd      	lod	AL, #-51
    8af8:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
#endif /* _SUPPORT_PHASE_SHORT_DET */
#if _SUPPORT_STALLDET_O
													& ~(1U << 7)				/* bit 7: Current-oscillation stall-detection support */
#endif /* _SUPPORT_STALLDET_O */
																);
					g_DiagResponse.byD4 = (uint8) (C_DIAG_RES
    8afa:	60f6      	lod	AL, #-10
    8afc:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
#endif /* _SUPPORT_DIAG_OC */
#if _SUPPORT_DOUBLE_USTEP
													& ~(1U << 3)				/* bit 3: Double uStep support */
#endif /* _SUPPORT_DOUBLE_USTEP */
																);
					g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    8afe:	60ff      	lod	AL, #-1
    8b00:	0100      	jmp	0x8d02 <_HandleDfrDiag+0xa96>
					g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
				}																/* MMP140904-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLX4_VERSION )	/* MMP140523-1 - Begin */
    8b02:	6213      	lod	AL, [S-20]
    8b04:	8cc7      	cmp	AL, #-57
    8b06:	1d07      	jne	0x8b16 <_HandleDfrDiag+0x8aa>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8b08:	7ada 4018 	lod	Y, #16408
    8b0c:	72f0      	lod	A, [Y]
    8b0e:	7ada 401a 	lod	Y, #16410
    8b12:	7af0      	lod	Y, [Y]
    8b14:	04d4      	jmp	0x84be <_HandleDfrDiag+0x252>
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( *((uint16 *) 0x4018), *((uint16 *) 0x401A));
				}																/* MMP140523-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_PLTF_VERSION )	/* MMP140519-1 - Begin */
    8b16:	6213      	lod	AL, [S-20]
    8b18:	8cc8      	cmp	AL, #-56
    8b1a:	1d04      	jne	0x8b24 <_HandleDfrDiag+0x8b8>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8b1c:	72da 0104 	lod	A, #260
    8b20:	7800      	lod	Y, #0
    8b22:	04cd      	jmp	0x84be <_HandleDfrDiag+0x252>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD1to4( (__MLX_PLTF_VERSION_MAJOR__ | (__MLX_PLTF_VERSION_MINOR__ << 8)),
								(__MLX_PLTF_VERSION_REVISION__ | (__MLX_PLTF_VERSION_CUSTOMER_BUILD__ << 8)));
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_APP_VERSION )
    8b24:	6213      	lod	AL, [S-20]
    8b26:	8cc9      	cmp	AL, #-55
    8b28:	1d15      	jne	0x8b54 <_HandleDfrDiag+0x8e8>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Appl ver | Appl ver | Appl ver | Appl ver | Appl ver |
					 *	|     |     |      |  (Major) |  (Minor) | (Rev LSB)| (Rev MSB)|   0xFF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					if ( pDiag->byD3 == 0 )									/* MMP140618-2 */
    8b2a:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8b2c:	1d04      	jne	0x8b36 <_HandleDfrDiag+0x8ca>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8b2e:	7001      	lod	A, #1
    8b30:	7ada e008 	lod	Y, #57352
    8b34:	04c4      	jmp	0x84be <_HandleDfrDiag+0x252>
					 */
					if ( pDiag->byD3 == 0 )									/* MMP140618-2 */
					{
						StoreD1to4( (__APP_VERSION_MAJOR__ | (__APP_VERSION_MINOR__ << 8)), __APP_VERSION_REVISION__);
					}
					else if ( pDiag->byD3 == 1 )								/* MMP140618-2 - Begin */
    8b36:	8c01      	cmp	AL, #1
    8b38:	1d05      	jne	0x8b44 <_HandleDfrDiag+0x8d8>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8b3a:	72d8 bf50 	lod	A, 0xbf50 <_product_id>
    8b3e:	7ad8 bf52 	lod	Y, 0xbf52 <_product_id+0x2>
    8b42:	04bd      	jmp	0x84be <_HandleDfrDiag+0x252>
					}
					else if ( pDiag->byD3 == 1 )								/* MMP140618-2 - Begin */
					{
						StoreD1to4( *((uint16 *) &product_id[0]), *((uint16 *) &product_id[2]));
					}
					else if ( pDiag->byD3 == 2 )
    8b44:	8c02      	cmp	AL, #2
    8b46:	1901      	je	0x8b4a <_HandleDfrDiag+0x8de>
    8b48:	0151      	jmp	0x8dec <_HandleDfrDiag+0xb80>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8b4a:	72d8 bf54 	lod	A, 0xbf54 <_product_id+0x4>
    8b4e:	7ad8 bf56 	lod	Y, 0xbf56 <_product_id+0x6>
    8b52:	04b5      	jmp	0x84be <_HandleDfrDiag+0x252>
					else if ( pDiag->byD3 == 2 )
					{
						StoreD1to4( *((uint16 *) &product_id[4]), *((uint16 *) &product_id[6]));
					}
				}																/* MMP140519-1 - End */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPAGE )
    8b54:	6213      	lod	AL, [S-20]
    8b56:	8cca      	cmp	AL, #-54
    8b58:	1d08      	jne	0x8b6a <_HandleDfrDiag+0x8fe>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   index  | NVRAM[i] | NVRAM[i] |NVRAM[i+1]|NVRAM[i+1]|
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x3E);
    8b5a:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8b5c:	b43e      	and	A, #62
					g_DiagResponse.byD1 = (uint8) u16Index;
    8b5e:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
					{
						uint16 *pu16NvramData = ((uint16 *) C_ADDR_MLXF_PAGE) + u16Index;			/* NVRAM 16-bit pointer */
    8b60:	4422      	asl	A
    8b62:	7ae2      	lod	Y, A
    8b64:	e2da 1180 	add	Y, #4480
    8b68:	0118      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
						StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_MLXPID )
    8b6a:	6213      	lod	AL, [S-20]
    8b6c:	8ccb      	cmp	AL, #-53
    8b6e:	1d04      	jne	0x8b78 <_HandleDfrDiag+0x90c>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8b70:	72d8 035a 	lod	A, 0x35a <_g_u16PidCtrlRatio>
    8b74:	79c8      	lod	Y, dp:0xc8 <_g_u16PID_I>
    8b76:	0113      	jmp	0x8d9e <_HandleDfrDiag+0xb32>
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					StoreD2to5( g_u16PidCtrlRatio, g_u16PID_I);
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_NVRAM_ERRORCODES )
    8b78:	6213      	lod	AL, [S-20]
    8b7a:	8ccc      	cmp	AL, #-52
    8b7c:	1d13      	jne	0x8ba4 <_HandleDfrDiag+0x938>
					 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |   Index  | ErrorCode| ErrorCode| ErrorCode| ErrorCode|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Index = (uint16) (pDiag->byD3 & 0x1C);
    8b7e:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8b80:	b41c      	and	A, #28
					if ( u16Index < (2 * (C_MAX_ERRORS_PER_PAGE - 1)) )
    8b82:	ac15      	cmp	A, #21
    8b84:	1a01      	jule	0x8b88 <_HandleDfrDiag+0x91c>
    8b86:	0132      	jmp	0x8dec <_HandleDfrDiag+0xb80>
					{
						uint16 *pu16ErrorCode;
						g_DiagResponse.byD1 = (uint8) (u16Index & 0xFF);
    8b88:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
						u16Index = u16Index >> 1;
    8b8a:	4432      	lsr	A
						if ( u16Index < (C_MAX_ERRORS_PER_PAGE/2) )
    8b8c:	ac05      	cmp	A, #5
    8b8e:	1e05      	jug	0x8b9a <_HandleDfrDiag+0x92e>
						{
							pu16ErrorCode = (uint16 *) &(((PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER)))->ErrorLog[u16Index]);
    8b90:	4422      	asl	A
    8b92:	7ae2      	lod	Y, A
    8b94:	e2da 1074 	add	Y, #4212
    8b98:	0100      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
						}
						else
						{
							u16Index -= (C_MAX_ERRORS_PER_PAGE/2);
							pu16ErrorCode = (uint16 *) &(((PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER)))->ErrorLog[u16Index]);
    8b9a:	4422      	asl	A
    8b9c:	7ae2      	lod	Y, A
    8b9e:	e2da 1168 	add	Y, #4456
    8ba2:	00fb      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
						}
						StoreD2to5( *pu16ErrorCode, *(pu16ErrorCode+1)); /*lint !e661 */
					}
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CLR_NVRAM_ERRORCODES )
    8ba4:	6213      	lod	AL, [S-20]
    8ba6:	8ccd      	cmp	AL, #-51
    8ba8:	1d03      	jne	0x8bb0 <_HandleDfrDiag+0x944>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| Debug| Supplier | Supplier | Reserved | Reserved |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |   0xCD   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					NVRAM_ClearErrorLog();
    8baa:	82db a4f0 	callf	0xa4f0 <_NVRAM_ClearErrorLog>
    8bae:	5421      	ret	#34
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_CHIPENV )
    8bb0:	6213      	lod	AL, [S-20]
    8bb2:	8cce      	cmp	AL, #-50
    8bb4:	1d08      	jne	0x8bc6 <_HandleDfrDiag+0x95a>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB | Chip-Temp|  Current |  Current |  Voltage |  Voltage |
					 *	|     |     |      |          |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
    8bb6:	7122      	lod	A, dp:0x22 <__data_dp_size>
    8bb8:	a03c      	add	A, #60
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
    8bba:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8bbc:	72d8 0110 	lod	A, 0x110 <_g_i16Current>
    8bc0:	7ad8 0114 	lod	Y, 0x114 <_g_i16SupplyVoltage>
    8bc4:	00ec      	jmp	0x8d9e <_HandleDfrDiag+0xb32>
					 */
					uint16 u16Value = (uint16) (g_i16ChipTemperature + C_TEMPOFF);					/* Chip Junction temperature + offset (C_TEMPOFF); Range: -C_TEMPOFF .. +(255-C_TEMPOFF) */
					g_DiagResponse.byD1 = (uint8) (u16Value & 0xFF);
					StoreD2to5( (uint16) g_i16Current, (uint16) g_i16SupplyVoltage); /* Motor driver current [mA] & Supply voltage [10mV] */
				}
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FUNC )
    8bc6:	6213      	lod	AL, [S-20]
    8bc8:	8ccf      	cmp	AL, #-49
    8bca:	1d12      	jne	0x8bf0 <_HandleDfrDiag+0x984>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | Function | Function |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xCF   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint16 u16FunctionID = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8bcc:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x6>
    8bce:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>

					if ( u16FunctionID == C_DBG_DBGFUNC_RESET )
    8bd0:	aeda 4a74 	cmp	A, #19060
    8bd4:	1901      	je	0x8bd8 <_HandleDfrDiag+0x96c>
    8bd6:	010a      	jmp	0x8dec <_HandleDfrDiag+0xb80>
					{
						/* Function ID = Chip reset */
						(void) mlu_ApplicationStop();
    8bd8:	82db 7aec 	callf	0x7aec <_mlu_ApplicationStop>
						MLX4_RESET();											/* Reset the Mlx4   */
    8bdc:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8be0:	94fe      	and	AL, #-2
    8be2:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
						bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    8be6:	7ada 3072 	lod	Y, #12402
    8bea:	5ad8 0372 	mov	0x372 <_bistResetInfo>, Y
    8bee:	00f3      	jmp	0x8dd6 <_HandleDfrDiag+0xb6a>
					{
						MLX16_RESET();											/* Reset the Mlx16  */
					}
#endif /* _SUPPORT_LINCMD_WD_RST */
				}
				else if ( (pDiag->byD5 >= (uint8) C_DBG_SUBFUNC_SET_ANAOUTA) && (pDiag->byD5 <= (uint8) C_DBG_SUBFUNC_SET_ANAOUTH) )
    8bf0:	6213      	lod	AL, [S-20]
    8bf2:	8030      	add	AL, #48
    8bf4:	8c07      	cmp	AL, #7
    8bf6:	1e15      	jug	0x8c22 <_HandleDfrDiag+0x9b6>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| Debug| Supplier | Supplier |   Value  |   Value  |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |   (LSB)  |   (MSB)  | 0xD0-0xD7|
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 *pu16IoReg = (uint16*) au16AnaOutRegs[pDiag->byD5 & 0x07];
    8bf8:	6213      	lod	AL, [S-20]
    8bfa:	b407      	and	A, #7
    8bfc:	4422      	asl	A
    8bfe:	7ae2      	lod	Y, A
    8c00:	e2da ab22 	add	Y, #43810
    8c04:	7ef0      	lod	X, [Y]
					CONTROL |= (OUTA_WE | OUTB_WE | OUTC_WE);					/* Grant access to ANA_OUTx registers */
    8c06:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8c0a:	8438      	or	AL, #56
    8c0c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
					*pu16IoReg = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8c10:	6940      	lod	AH, dp:0x40 <__data_dp_end+0x6>
    8c12:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8c14:	52f8      	mov	[X], A
					CONTROL &= ~(OUTA_WE | OUTB_WE | OUTC_WE);
    8c16:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8c1a:	94c7      	and	AL, #-57
    8c1c:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    8c20:	5421      	ret	#34
						uint16 *pu16MotorCurrRaw = (uint16*) &l_au8MotorCurrRaw[u16Index];
						StoreD1to4( pu16MotorCurrRaw[0], pu16MotorCurrRaw[1]);
					}
				}
#endif /* _DEBUG_MOTOR_CURRENT_FLT */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_FILLNVRAM )		/* MMP140407-1 - Begin */
    8c22:	6213      	lod	AL, [S-20]
    8c24:	8cf8      	cmp	AL, #-8
    8c26:	1901      	je	0x8c2a <_HandleDfrDiag+0x9be>
    8c28:	0035      	jmp	0x8c94 <_HandleDfrDiag+0xa28>
					 *	| NAD | 0x06| Debug| Supplier | Supplier | NVRAM ID |  Pattern |   FUNC   |
					 *	|     |     | 0xDB | ID (LSB) | ID (MSB) |          |          |   0xF8   |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 * (No response)
					 */
					uint8 u8NvramID = pDiag->byD3;
    8c2a:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8c2c:	5cf2      	usex	A
    8c2e:	5209      	mov	[S-10], A
					uint16 u16Pattern = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD4);
    8c30:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8c32:	5cf2      	usex	A
    8c34:	7ae2      	lod	Y, A
    8c36:	6c00      	lod	YH, #0
    8c38:	7ae8      	swap	Y
    8c3a:	a6e6      	or	A, Y
    8c3c:	5207      	mov	[S-8], A
					if ( u8NvramID & 0x01 )
    8c3e:	7209      	lod	A, [S-10]
    8c40:	b401      	and	A, #1
    8c42:	1909      	je	0x8c56 <_HandleDfrDiag+0x9ea>
					{
						/* Fill NVRAM #1, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE1_ADDRESS);
    8c44:	7ada 1000 	lod	Y, #4096
    8c48:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    8c4a:	7207      	lod	A, [S-8]
    8c4c:	52d6      	mov	[Y++], A
    8c4e:	1bfd      	djnz	X, 0x8c4a <_HandleDfrDiag+0x9de>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE1);
    8c50:	7000      	lod	A, #0
    8c52:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x02 )
    8c56:	7209      	lod	A, [S-10]
    8c58:	b402      	and	A, #2
    8c5a:	1909      	je	0x8c6e <_HandleDfrDiag+0xa02>
					{
						/* Fill NVRAM #1, 2 (Don't overwrite the NVRAM1 trim value) */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM1_PAGE2_ADDRESS);
    8c5c:	7ada 1080 	lod	Y, #4224
    8c60:	7c3e      	lod	X, #62
						do
						{
							*pu16NvramData++ = u16Pattern;
    8c62:	7207      	lod	A, [S-8]
    8c64:	52d6      	mov	[Y++], A
    8c66:	1bfd      	djnz	X, 0x8c62 <_HandleDfrDiag+0x9f6>
						} while (pu16NvramData < (uint16 *) END_NVRAM1_PAGE2_ADDRESS);
						NVRAM_SavePage( NVRAM1_PAGE2);
    8c68:	7001      	lod	A, #1
    8c6a:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x04 )
    8c6e:	7209      	lod	A, [S-10]
    8c70:	b404      	and	A, #4
    8c72:	1909      	je	0x8c86 <_HandleDfrDiag+0xa1a>
					{
						/* Fill NVRAM #2, 1 */
						uint16 *pu16NvramData = ((uint16 *) BGN_NVRAM2_PAGE1_ADDRESS);
    8c74:	7ada 1100 	lod	Y, #4352
    8c78:	7c40      	lod	X, #64
						do
						{
							*pu16NvramData++ = u16Pattern;
    8c7a:	7207      	lod	A, [S-8]
    8c7c:	52d6      	mov	[Y++], A
    8c7e:	1bfd      	djnz	X, 0x8c7a <_HandleDfrDiag+0xa0e>
						} while (pu16NvramData < (uint16 *) END_NVRAM2_PAGE1_ADDRESS);
						NVRAM_SavePage( NVRAM2_PAGE1);
    8c80:	7002      	lod	A, #2
    8c82:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
					}
					if ( u8NvramID & 0x80 )
    8c86:	6209      	lod	AL, [S-10]
    8c88:	8c00      	cmp	AL, #0
    8c8a:	1a81      	jsl	0x8c8e <_HandleDfrDiag+0xa22>
    8c8c:	00af      	jmp	0x8dec <_HandleDfrDiag+0xb80>
					{
						NVRAM_LoadUserPage();
    8c8e:	82db a1d4 	callf	0xa1d4 <_NVRAM_LoadUserPage>
    8c92:	5421      	ret	#34
						pu16NvramData++;
					} while ( (uint16) pu16NvramData < (C_ADDR_FATALPAGE + 0x7C));
					NVRAM_StorePatch();
				}
#endif /* (_DEBUG_FATAL != FALSE) */
				else if ( pDiag->byD5 == (uint8) C_DBG_SUBFUNC_GET_IO_REG )
    8c94:	6213      	lod	AL, [S-20]
    8c96:	8cfd      	cmp	AL, #-3
    8c98:	1901      	je	0x8c9c <_HandleDfrDiag+0xa30>
    8c9a:	00a8      	jmp	0x8dec <_HandleDfrDiag+0xb80>
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 *	| NAD | 0x06| 0xDB |  I/O-reg |  I/O-reg | I/O-value| I/O-value| Reserved |
					 *	|     |     |      |   (LSB)  |   (MSB)  |   (LSB)  |   (MSB)  |  (0xFF)  |
					 *	+-----+-----+------+----------+----------+----------+----------+----------+
					 */
					uint16 u16IoAddress = (((uint16) pDiag->byD4) << 8) | ((uint16) pDiag->byD3);
    8c9c:	6d40      	lod	YH, dp:0x40 <__data_dp_end+0x6>
    8c9e:	6400      	lod	YL, #0
    8ca0:	7ee6      	lod	X, Y
    8ca2:	613f      	lod	AL, dp:0x3f <__data_dp_end+0x5>
    8ca4:	5cf2      	usex	A
    8ca6:	26e2      	or	X, A
					if ( ((u16IoAddress >= 0x2000) && (u16IoAddress <= 0x2056)) ||	/* System I/O */
    8ca8:	72ee      	lod	A, X
    8caa:	a2da e000 	add	A, #57344
    8cae:	ac56      	cmp	A, #86
    8cb0:	1a0a      	jule	0x8cc6 <_HandleDfrDiag+0xa5a>
    8cb2:	2eda 07fe 	cmp	X, #2046
    8cb6:	1a07      	jule	0x8cc6 <_HandleDfrDiag+0xa5a>
    8cb8:	72ee      	lod	A, X
    8cba:	a2da d800 	add	A, #55296
    8cbe:	aeda 00da 	cmp	A, #218
    8cc2:	1a01      	jule	0x8cc6 <_HandleDfrDiag+0xa5a>
    8cc4:	0093      	jmp	0x8dec <_HandleDfrDiag+0xb80>
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8cc6:	7af8      	lod	Y, [X]
	__asm__ __volatile__
    8cc8:	72ee      	lod	A, X
    8cca:	76da 84be 	jmpf	0x84be <_HandleDfrDiag+0x252>
				}
#endif /* (_DEBUG_FATAL != FALSE) */
			}
			else
			{
				SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    8cce:	621e      	lod	AL, [S-31]
    8cd0:	5cf2      	usex	A
    8cd2:	54ca 0012 	pushw	#18
    8cd6:	54ca 00db 	pushw	#219
    8cda:	76da 8388 	jmpf	0x8388 <_HandleDfrDiag+0x11c>
			}
		}
#endif /* _SUPPORT_MLX_DEBUG_MODE */
		else if ( pDiag->bySID == (uint8) C_SID_MLX_ERROR_CODES )
    8cde:	6215      	lod	AL, [S-22]
    8ce0:	8cec      	cmp	AL, #-20
    8ce2:	1d12      	jne	0x8d08 <_HandleDfrDiag+0xa9c>
			 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xEC | Error[0] | Error[1] | Error[2] | Error[3] | Error[4] |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    8ce4:	661e      	lod	YL, [S-31]
    8ce6:	4542      	mov	dp:0x42 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = 0x06;
    8ce8:	6006      	lod	AL, #6
    8cea:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_SID_MLX_ERROR_CODES;
    8cec:	6215      	lod	AL, [S-22]
    8cee:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = GetLastError();													/* Oldest Error-code */
    8cf0:	134a      	call	0x9386 <_GetLastError>
    8cf2:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
			g_DiagResponse.byD2 = GetLastError();
    8cf4:	1348      	call	0x9386 <_GetLastError>
    8cf6:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
			g_DiagResponse.byD3 = GetLastError();
    8cf8:	1346      	call	0x9386 <_GetLastError>
    8cfa:	4147      	mov	dp:0x47 <_g_DiagResponse+0x5>, AL
			g_DiagResponse.byD4 = GetLastError();
    8cfc:	1344      	call	0x9386 <_GetLastError>
    8cfe:	4148      	mov	dp:0x48 <_g_DiagResponse+0x6>, AL
			g_DiagResponse.byD5 = GetLastError();
    8d00:	1342      	call	0x9386 <_GetLastError>
    8d02:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL
    8d04:	76da 84c6 	jmpf	0x84c6 <_HandleDfrDiag+0x25a>

			g_u8BufferOutID = (uint8) QR_RFR_DIAG;													/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( (pDiag->bySID == (uint8) C_SID_MLX_EE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0) )	/* MMP150603-2 */
    8d08:	6215      	lod	AL, [S-22]
    8d0a:	8ced      	cmp	AL, #-19
    8d0c:	1d26      	jne	0x8d5a <_HandleDfrDiag+0xaee>
    8d0e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    8d12:	b401      	and	A, #1
    8d14:	1d22      	jne	0x8d5a <_HandleDfrDiag+0xaee>
			/* EEPROM/NVRAM Patch support
			 * D1.bit 7 = 0 : Read Patch area
			 *			  1 : Write Patch area
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3D.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3F);
    8d16:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8d18:	4201      	mov	[S-2], AL
    8d1a:	66e0      	lod	YL, AL
    8d1c:	f43f      	and	Y, #63
    8d1e:	72e6      	lod	A, Y
    8d20:	4422      	asl	A
    8d22:	5203      	mov	[S-4], A
			if ( pDiag->byD1 & 0x80 )
    8d24:	6201      	lod	AL, [S-2]
    8d26:	8c00      	cmp	AL, #0
    8d28:	1e8d      	jsge	0x8d44 <_HandleDfrDiag+0xad8>
				 *	| NAD | 0x06| 0xED |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
			     * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    8d2a:	7e03      	lod	X, [S-4]
    8d2c:	22da 1080 	add	X, #4224
				*pu16NvramData = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    8d30:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x5>
    8d32:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8d34:	52f8      	mov	[X], A
				pu16NvramData++;
    8d36:	7e03      	lod	X, [S-4]
    8d38:	22da 1082 	add	X, #4226
				*pu16NvramData = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8d3c:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x7>
    8d3e:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8d40:	52f8      	mov	[X], A
    8d42:	5421      	ret	#34
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xED |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    8d44:	621e      	lod	AL, [S-31]
    8d46:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06;
    8d48:	6006      	lod	AL, #6
    8d4a:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_PATCH;
    8d4c:	6215      	lod	AL, [S-22]
    8d4e:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    8d50:	4545      	mov	dp:0x45 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    8d52:	7a03      	lod	Y, [S-4]
    8d54:	e2da 1080 	add	Y, #4224
    8d58:	0020      	jmp	0x8d9a <_HandleDfrDiag+0xb2e>
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_USERPG1 )
    8d5a:	6215      	lod	AL, [S-22]
    8d5c:	8cee      	cmp	AL, #-18
    8d5e:	1d25      	jne	0x8daa <_HandleDfrDiag+0xb3e>
			/* EEPROM/NVRAM User-page #1 support
			 * D1.bit 7 = 0 : Read User-page #1
			 *			  1 : Write User-page #1
			 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3F.
			 */
			uint16 u16Index = (uint16) (pDiag->byD1 & 0x3F);
    8d60:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8d62:	4201      	mov	[S-2], AL
    8d64:	66e0      	lod	YL, AL
    8d66:	f43f      	and	Y, #63
    8d68:	72e6      	lod	A, Y
    8d6a:	4422      	asl	A
    8d6c:	7ee2      	lod	X, A
			if ( pDiag->byD1 & 0x80 )
    8d6e:	6201      	lod	AL, [S-2]
    8d70:	8c00      	cmp	AL, #0
    8d72:	1e89      	jsge	0x8d86 <_HandleDfrDiag+0xb1a>
				 *	| NAD | 0x06| 0xEE |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
				 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
			     * No Response
				 */
				uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    8d74:	22da 0058 	add	X, #88
				pu16NvramData[0] = (((uint16) pDiag->byD3) << 8) | ((uint16) pDiag->byD2);
    8d78:	693f      	lod	AH, dp:0x3f <__data_dp_end+0x5>
    8d7a:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8d7c:	52f8      	mov	[X], A
				pu16NvramData[1] = (((uint16) pDiag->byD5) << 8) | ((uint16) pDiag->byD4);
    8d7e:	6941      	lod	AH, dp:0x41 <__data_dp_end+0x7>
    8d80:	6140      	lod	AL, dp:0x40 <__data_dp_end+0x6>
    8d82:	52fa      	mov	[X+2], A
    8d84:	5421      	ret	#34
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 *	| NAD | 0x06| 0xEE |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
				 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 */
				g_DiagResponse.byNAD = g_u8NAD;
    8d86:	621e      	lod	AL, [S-31]
    8d88:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = 0x06;
    8d8a:	6006      	lod	AL, #6
    8d8c:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_USERPG1;
    8d8e:	6215      	lod	AL, [S-22]
    8d90:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = (uint8) u16Index;
    8d92:	4545      	mov	dp:0x45 <_g_DiagResponse+0x3>, YL
				{
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
    8d94:	7aee      	lod	Y, X
    8d96:	e2da 0058 	add	Y, #88
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8d9a:	72f0      	lod	A, [Y]
    8d9c:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    8d9e:	4146      	mov	dp:0x46 <_g_DiagResponse+0x4>, AL
    8da0:	4947      	mov	dp:0x47 <_g_DiagResponse+0x5>, AH
    8da2:	4548      	mov	dp:0x48 <_g_DiagResponse+0x6>, YL
    8da4:	4d49      	mov	dp:0x49 <_g_DiagResponse+0x7>, YH
    8da6:	76da 84c6 	jmpf	0x84c6 <_HandleDfrDiag+0x25a>
					uint16 *pu16NvramData = ((uint16 *) &g_NvramUser) + u16Index;	/* NVRAM 16-bit pointer */
					StoreD2to5( pu16NvramData[0], pu16NvramData[1]);
				}
			}
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_STORE )
    8daa:	6215      	lod	AL, [S-22]
    8dac:	8cef      	cmp	AL, #-17
    8dae:	1d1e      	jne	0x8dec <_HandleDfrDiag+0xb80>
		{
			if ( pDiag->byD1 == (uint8) C_EE_STORE_USERPG1 )
    8db0:	613d      	lod	AL, dp:0x3d <__data_dp_end+0x3>
    8db2:	8cee      	cmp	AL, #-18
    8db4:	1d13      	jne	0x8ddc <_HandleDfrDiag+0xb70>
				 *	| NAD | 0x06| 0xEF |   0xEE   | Pages &  |          |          |          |
				 *	|     |     |      |          | ResetFlg |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				(void) NVRAM_Store( pDiag->byD2);
    8db6:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8db8:	5cf2      	usex	A
    8dba:	82db a0ca 	callf	0xa0ca <_NVRAM_Store>
				if ( (pDiag->byD2 != 0xFF) && ((pDiag->byD2 & C_NVRAM_USER_PAGE_RESET) != 0) )
    8dbe:	613e      	lod	AL, dp:0x3e <__data_dp_end+0x4>
    8dc0:	8cff      	cmp	AL, #-1
    8dc2:	1914      	je	0x8dec <_HandleDfrDiag+0xb80>
    8dc4:	b420      	and	A, #32
    8dc6:	1912      	je	0x8dec <_HandleDfrDiag+0xb80>
				{
					(void) mlu_ApplicationStop();
    8dc8:	82db 7aec 	callf	0x7aec <_mlu_ApplicationStop>
					MLX4_RESET();												/* Reset the Mlx4   */
    8dcc:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8dd0:	94fe      	and	AL, #-2
    8dd2:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
					MLX16_RESET();												/* Reset the Mlx16  */
    8dd6:	82db 5920 	callf	0x5920 <_MLX16_RESET>
    8dda:	5421      	ret	#34
				}
			}
			else if ( (pDiag->byD1 == (uint8) C_EE_STORE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0) )	/* MMP150603-2 */
    8ddc:	8ced      	cmp	AL, #-19
    8dde:	1d06      	jne	0x8dec <_HandleDfrDiag+0xb80>
    8de0:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    8de4:	b401      	and	A, #1
    8de6:	1d02      	jne	0x8dec <_HandleDfrDiag+0xb80>
				 *	| NAD | 0x06| 0xEF |   0xED   |          |          |          |          |
				 *	|     |     |      |          |          |          |          |          |
				 *	+-----+-----+------+----------+----------+----------+----------+----------+
				 * No Response
				 */
				NVRAM_StorePatch();
    8de8:	82db a546 	callf	0xa546 <_NVRAM_StorePatch>
    8dec:	5421      	ret	#34

00008dee <_RfrDiagReset>:
 *
 * ****************************************************************************	*/
void RfrDiagReset()
{
#if ((LINPROT & LINXX) == LIN2X)
	if ( g_u8NAD != (uint8) C_BROADCAST_NAD )
    8dee:	6133      	lod	AL, dp:0x33 <_g_u8NAD>
    8df0:	8c7f      	cmp	AL, #127
    8df2:	190e      	je	0x8e10 <_RfrDiagReset+0x22>
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	if ( pDiag->byNAD != C_BROADCAST_J2602_NAD )
#endif /* ((LINPROT & LINXX) == LIN2J) */
	{
		/* Positive Response */
		g_DiagResponse.byNAD = g_u8NAD;
    8df4:	4142      	mov	dp:0x42 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    8df6:	6006      	lod	AL, #6
    8df8:	4143      	mov	dp:0x43 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_DEBUG;
    8dfa:	60db      	lod	AL, #-37
    8dfc:	4144      	mov	dp:0x44 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD5 = (uint8) g_NvramUser.Variant;
    8dfe:	615b      	lod	AL, dp:0x5b <_g_NvramUser+0x3>
    8e00:	4149      	mov	dp:0x49 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8e02:	7813      	lod	Y, #19
	__asm__ __volatile__
    8e04:	4145      	mov	dp:0x45 <_g_DiagResponse+0x3>, AL
    8e06:	4946      	mov	dp:0x46 <_g_DiagResponse+0x4>, AH
    8e08:	4547      	mov	dp:0x47 <_g_DiagResponse+0x5>, YL
    8e0a:	4d48      	mov	dp:0x48 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    8e0c:	6007      	lod	AL, #7
    8e0e:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
    8e10:	5401      	ret

00008e12 <_ADC_StartSoftTrig>:
 *
 * Start ADC measurement using Software trigger.
 * ****************************************************************************	*/
void ADC_StartSoftTrig( void)													/* MMP140709-1 - Begin */
{
	PEND = CLR_ADC_IT;
    8e12:	7040      	lod	A, #64
    8e14:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    8e18:	7001      	lod	A, #1
    8e1a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff )
    8e1c:	62d8 0136 	lod	AL, 0x136 <_l_u8AdcPowerOff>
    8e20:	1904      	je	0x8e2a <_ADC_StartSoftTrig+0x18>
    8e22:	7eda 008b 	lod	X, #139
	{
		NOP();
    8e26:	0000      	nop
    8e28:	1bfe      	djnz	X, 0x8e26 <_ADC_StartSoftTrig+0x14>
	{
		NopDelay( DELAY_50us); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    8e2a:	6000      	lod	AL, #0
    8e2c:	42d8 0136 	mov	0x136 <_l_u8AdcPowerOff>, AL
    8e30:	7c06      	lod	X, #6
    8e32:	0000      	nop
    8e34:	1bfe      	djnz	X, 0x8e32 <_ADC_StartSoftTrig+0x20>
	NopDelay( ADC_SETTING); /*lint !e522 */
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    8e36:	72da 0101 	lod	A, #257
    8e3a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;							/* Wait for ADC result */
    8e3c:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e3e:	b401      	and	A, #1
    8e40:	1d7d      	jne	0x8e3c <_ADC_StartSoftTrig+0x2a>
    8e42:	5401      	ret

00008e44 <_ADC_Stop>:
 *
 * Stop ADC (with waiting for pending ADC conversions to be finished)
 * ****************************************************************************	*/
void ADC_Stop(void)
{	
	if ( ADC_CTRL & ADC_START )													/* In case ADC is active, wait to finish it */
    8e44:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e46:	b401      	and	A, #1
    8e48:	190f      	je	0x8e68 <_ADC_Stop+0x24>
		while ( (ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0) )
		{
			NopDelay( ADC_DELAY); /*lint !e522 */
		}
#endif
		ADC_CTRL &= ~(ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);					/* Stop looping and HW-triggers */
    8e4a:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e4c:	b6da ff79 	and	A, #65401
    8e50:	5290      	mov	io:0x10 <__dp_noinit_size>, A
#define C_TEMP_STABIL_INT_FILTER_COEF		8U									/* Temperature stability integrator filter coefficient: 1/(2^n) */
#define C_TEMP_STABIL_THRESHOLD				20U									/* Temperature threshold (output integrator filter) 30C * (1 - ((2^n-1)/2^n)^(4*60)) = 19 */

static INLINE void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0; u16DelayCount-- )
    8e52:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e54:	b401      	and	A, #1
    8e56:	1908      	je	0x8e68 <_ADC_Stop+0x24>
		while ( ADC_CTRL & ADC_START )											/* As long as the ADC is active ... */
		{
			ADC_CTRL |= ADC_SOFT_TRIG;											/* ... Set S/W trigger */
    8e58:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8e5a:	a6da 0100 	or	A, #256
    8e5e:	5290      	mov	io:0x10 <__dp_noinit_size>, A
    8e60:	7c12      	lod	X, #18
	{
		NOP();
    8e62:	0000      	nop
    8e64:	1bfe      	djnz	X, 0x8e62 <_ADC_Stop+0x1e>
    8e66:	07f5      	jmp	0x8e52 <_ADC_Stop+0xe>
			NopDelay( DELAY_7us); /*lint !e522 */
		}
	}
	ADC_CTRL = 0;																/* Clear the ADC control register */
    8e68:	7000      	lod	A, #0
    8e6a:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	BEGIN_CRITICAL_SECTION();
    8e6c:	54d0      	psup	#0
	MASK &= ~EN_ADC_IT;															/* Disable ADC Interrupt */
    8e6e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    8e72:	b4bf      	and	A, #-65
    8e74:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	END_CRITICAL_SECTION();
    8e78:	72cb      	pop	M
#if ((LINPROT & LINXX) != LIN2J)
	g_u8AdcIsrMode = C_ADC_ISR_NONE;
    8e7a:	6000      	lod	AL, #0
    8e7c:	42d8 0137 	mov	0x137 <_g_u8AdcIsrMode>, AL
    8e80:	5401      	ret

00008e82 <_ADC_Init>:
 *
 * Measure Zero-current offset
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Init( void)
{
    8e82:	5801      	inc	S, #2
	uint16 volatile u16ZCO;
	ADC_Stop();																	/* clear the ADC control register */
    8e84:	17df      	call	0x8e44 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURROFF;
    8e86:	72da ab7e 	lod	A, #43902
    8e8a:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16ZCO;
    8e8c:	72ef      	lod	A, S
    8e8e:	a0fe      	add	A, #-2
    8e90:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    8e92:	17bf      	call	0x8e12 <_ADC_StartSoftTrig>
	l_u16CurrentZeroOffset = /* lint -e{530} */ u16ZCO;
    8e94:	7201      	lod	A, [S-2]
    8e96:	52d8 0138 	mov	0x138 <_l_u16CurrentZeroOffset>, A
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    8e9a:	72da 0101 	lod	A, #257
    8e9e:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;							/* Wait for ADC result */
    8ea0:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8ea2:	b401      	and	A, #1
    8ea4:	1d7d      	jne	0x8ea0 <_ADC_Init+0x1e>
	l_u16CurrentZeroOffset = (l_u16CurrentZeroOffset + u16ZCO) >> 1;
    8ea6:	72d8 0138 	lod	A, 0x138 <_l_u16CurrentZeroOffset>
    8eaa:	7a01      	lod	Y, [S-2]
    8eac:	a2e6      	add	A, Y
    8eae:	4432      	lsr	A
    8eb0:	52d8 0138 	mov	0x138 <_l_u16CurrentZeroOffset>, A
		u16Delta = EE_OMCURR - l_u16CurrentZeroOffset;
	if ( u16Delta > 6 )															/* Need to define this value: 6 LSB's is approx. 5mA */
		l_u16CurrentZeroOffset = EE_OMCURR;										/* Take calibrated current offset, insetad of measured offset */
#endif /* SUPPORT_CALIBRATED_ZERO_CURRENT */

	PRIO = (PRIO & ~(3 << 2)) | ((5 - 3) << 2);									/* ADC IRQ Priority: 5 (3..6) (MMP150106-1) */
    8eb4:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8eb8:	b4f3      	and	A, #-13
    8eba:	a408      	or	A, #8
    8ebc:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
    8ec0:	5403      	ret	#4

00008ec2 <_ADC_Start>:
void ADC_Start( uint16 u16Mode)
#else  /* _SUPPORT_PHASE_SHORT_DET */
void ADC_Start( void)
#endif /* _SUPPORT_PHASE_SHORT_DET */
{
	ADC_Stop();																	/* clear the ADC control register */
    8ec2:	17c0      	call	0x8e44 <_ADC_Stop>
#if _SUPPORT_PHASE_SHORT_DET
	ADC_SetupShortDetection( u16Mode);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_SBASE = (uint16) SBASE_INIT_4PH;
    8ec4:	72da ab62 	lod	A, #43874
    8ec8:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
#endif /* _SUPPORT_PHASE_SHORT_DET */
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4;
    8eca:	72da 0292 	lod	A, #658
    8ece:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_CTRL  = (ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);						/* Loop cycle of conversion is done */
    8ed0:	72da 0086 	lod	A, #134
    8ed4:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_CTRL |= ADC_START;														/* Start ADC */
    8ed6:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    8ed8:	a401      	or	A, #1
    8eda:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	if ( l_u8AdcPowerOff )														/* MMP140618-1: Add delay */
    8edc:	62d8 0136 	lod	AL, 0x136 <_l_u8AdcPowerOff>
    8ee0:	1904      	je	0x8eea <_ADC_Start+0x28>
    8ee2:	7eda 008b 	lod	X, #139
    8ee6:	0000      	nop
    8ee8:	1bfe      	djnz	X, 0x8ee6 <_ADC_Start+0x24>
	{
		NopDelay( DELAY_mPWM); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    8eea:	6000      	lod	AL, #0
    8eec:	42d8 0136 	mov	0x136 <_l_u8AdcPowerOff>, AL
    8ef0:	5401      	ret

00008ef2 <_ADC_PowerOff>:
 *
 * Power-off ADC, by disabling reference voltage
 * ****************************************************************************	*/
void ADC_PowerOff( void)
{
	ADC_Stop();																	/* Stop ADC conversion, and disable ADC-IRQ */
    8ef2:	17a8      	call	0x8e44 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_VREF_OFF;
    8ef4:	72da ab82 	lod	A, #43906
    8ef8:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	PEND = CLR_ADC_IT;
    8efa:	7040      	lod	A, #64
    8efc:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    8f00:	7001      	lod	A, #1
    8f02:	5290      	mov	io:0x10 <__dp_noinit_size>, A
	ADC_Stop();
    8f04:	179f      	call	0x8e44 <_ADC_Stop>
	l_u8AdcPowerOff = TRUE;
    8f06:	6001      	lod	AL, #1
    8f08:	42d8 0136 	mov	0x136 <_l_u8AdcPowerOff>, AL
    8f0c:	5401      	ret

00008f0e <_ADC_IT>:
 * ADC Interrupt Service Routine
 * In case no ADC_ISR action required, this ISR has 4us overhead (is approx: 9.5% at 24kHz PWM)
 * (push/pop + check for LIN-AA + Check BEMF ZC)
 * ****************************************************************************	*/
__interrupt__ void ADC_IT(void) 
{
    8f0e:	52df      	push	A
    8f10:	5edf      	push	X
    8f12:	5adf      	push	Y
    8f14:	4c83      	push	D
#if ((LINPROT & LINXX) != LIN2J)
	if ( g_u8AdcIsrMode == C_ADC_ISR_LIN_AA ) 									/* LIN-AutoAddressing sequence */
    8f16:	62d8 0137 	lod	AL, 0x137 <_g_u8AdcIsrMode>
    8f1a:	8c01      	cmp	AL, #1
    8f1c:	1d02      	jne	0x8f22 <_ADC_IT+0x14>
	{
		AutoAddressingReadADCResult();											/* See MELEXIS doc */
    8f1e:	82db 7e90 	callf	0x7e90 <_AutoAddressingReadADCResult>
    8f22:	4cc3      	pop	D
    8f24:	7acf      	pop	Y
    8f26:	7ecf      	pop	X
    8f28:	72cf      	pop	A
    8f2a:	4407      	mov	R, #0
    8f2c:	72cb      	pop	M
    8f2e:	5401      	ret

00008f30 <_GetVsupply>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8f30:	7ad8 0294 	lod	Y, 0x294 <_g_AdcMotorRunStepper4+0x2>
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8f34:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8f38:	5ce2      	ssex	A
    8f3a:	eae2      	sub	Y, A
    8f3c:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8f40:	6000      	lod	AL, #0
    8f42:	72e4      	swap	A
    int32 result;

    __asm__ __volatile__ (
    8f44:	4811      	muls	D, A, Y
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8f46:	4c80      	mov	YA, D
    8f48:	4c22 0020 	add	YA, #32
    8f4c:	0000 
    8f4e:	4cb2 0000 	cmp	YA, #0
    8f52:	0000 
    8f54:	1e84      	jsge	0x8f5e <_GetVsupply+0x2e>
    8f56:	4c80      	mov	YA, D
    8f58:	4c22 005f 	add	YA, #95
    8f5c:	0000 
    8f5e:	48b5      	asr	YA, #6
    8f60:	52d8 0114 	mov	0x114 <_g_i16SupplyVoltage>, A
    8f64:	5401      	ret

00008f66 <_GetRawChipSupply>:
} /* End of GetVsupply() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawChipSupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8f66:	72d8 0294 	lod	A, 0x294 <_g_AdcMotorRunStepper4+0x2>
	return ( u16FilteredSupplyVoltage );
} /* End of GetRawChipSupply() */
    8f6a:	5401      	ret

00008f6c <_GetVsupplyMotor>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupplyMotor( void)
{
	uint16 u16FilteredDriverVoltage = g_AdcMotorRunStepper4.FilteredDriverVoltage;
    8f6c:	72d8 0298 	lod	A, 0x298 <_g_AdcMotorRunStepper4+0x6>
#if _SUPPORT_VSMFILTERED
	g_i16MotorVoltage = (int16) ((mulI32_I16byU16( (int16)(u16FilteredDriverVoltage - EE_OVOLTAGE), EE_GVOLTAGE) + (C_GVOLTAGE_DIV/2)) / C_GVOLTAGE_DIV);
    8f70:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    8f74:	5ce6      	ssex	Y
    8f76:	aae6      	sub	A, Y
    8f78:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    8f7c:	6400      	lod	YL, #0
    8f7e:	7ae8      	swap	Y
    8f80:	5adf      	push	Y
    8f82:	82db 6c52 	callf	0x6c52 <_mulI32_I16byU16>
    8f86:	4cc0      	mov	D, YA
    8f88:	4c22 0020 	add	YA, #32
    8f8c:	0000 
    8f8e:	4cb2 0000 	cmp	YA, #0
    8f92:	0000 
    8f94:	1e84      	jsge	0x8f9e <_GetVsupplyMotor+0x32>
    8f96:	4c80      	mov	YA, D
    8f98:	4c22 005f 	add	YA, #95
    8f9c:	0000 
    8f9e:	48b5      	asr	YA, #6
    8fa0:	5120      	mov	dp:0x20 <_g_i16MotorVoltage>, A
    8fa2:	5c01      	dec	S, #2
    8fa4:	5401      	ret

00008fa6 <_ResetChipTemperature>:
 *
 * Reset Chip temperature
 * ****************************************************************************	*/
void ResetChipTemperature( void)
{
	g_AdcMotorRunStepper4.IntTemperatureSensor = 0;
    8fa6:	7ada 0292 	lod	Y, #658
    8faa:	7000      	lod	A, #0
    8fac:	52f0      	mov	[Y], A
    8fae:	5401      	ret

00008fb0 <_GetChipTemperature>:
 * GetChipTemperature()
 *
 * Get Chip temperature [C]
 * ****************************************************************************	*/
void GetChipTemperature( uint16 u16Init)										/* MMP131020-1 */
{
    8fb0:	580b      	inc	S, #12
    8fb2:	520b      	mov	[S-12], A
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    8fb4:	7ad8 0292 	lod	Y, 0x292 <_g_AdcMotorRunStepper4>
	int16 i16ChipTemperature, i16ChipTempDelta;

#if _SUPPORT_TWO_LINE_TEMP_INTERPOLATION
	if ( u16ChipTemperatureSensor < EE_OTEMP )
    8fb8:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8fbc:	eee2      	cmp	Y, A
    8fbe:	1c11      	jnc	0x8fe2 <_GetChipTemperature+0x32>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8fc0:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8fc4:	aae6      	sub	A, Y
    8fc6:	5203      	mov	[S-4], A
    8fc8:	785a      	lod	Y, #90
    8fca:	7ed8 11ba 	lod	X, 0x11ba <__ep__+0x1ba>
    8fce:	72d8 11bc 	lod	A, 0x11bc <__ep__+0x1bc>
    8fd2:	2ae2      	sub	X, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8fd4:	7203      	lod	A, [S-4]
    8fd6:	4821      	mulu	YA, A, Y
    8fd8:	4c63      	divu	YA, X
    8fda:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8fdc:	7ae2      	lod	Y, A
    8fde:	e023      	add	Y, #35
    8fe0:	0012      	jmp	0x9006 <_GetChipTemperature+0x56>
    8fe2:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8fe6:	eae2      	sub	Y, A
    8fe8:	5a01      	mov	[S-2], Y
    8fea:	7ed8 11b8 	lod	X, 0x11b8 <__ep__+0x1b8>
    8fee:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    8ff2:	2ae6      	sub	X, Y
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8ff4:	704b      	lod	A, #75
    8ff6:	7a01      	lod	Y, [S-2]
    8ff8:	4821      	mulu	YA, A, Y
    8ffa:	4c63      	divu	YA, X
    8ffc:	4c63      	divu	YA, X
    8ffe:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9000:	7023      	lod	A, #35
    9002:	7ae2      	lod	Y, A
    9004:	eaee      	sub	Y, X
	}
#else  /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */
	i16ChipTemperature = (mulI32_I16byI16( (EE_OTEMP - u16ChipTemperatureSensor), EE_GTEMP) / C_GTEMP_DIV) + EE_MIDTEMP;
#endif /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */

	if ( u16Init == FALSE )														/* MMP131020-1 */
    9006:	7e0b      	lod	X, [S-12]
    9008:	1d13      	jne	0x9030 <_GetChipTemperature+0x80>
	{
		i16ChipTempDelta = i16ChipTemperature - g_i16ChipTemperature;			/* Delta-temp = new-temp - previous-temp */
    900a:	7122      	lod	A, dp:0x22 <__data_dp_size>
    900c:	7ee6      	lod	X, Y
    900e:	2ae2      	sub	X, A
    9010:	72ee      	lod	A, X
		if ( i16ChipTempDelta < 0 )
		{
			i16ChipTempDelta = -i16ChipTempDelta;								/* Absolute temperature change */
    9012:	ac00      	cmp	A, #0
    9014:	1e81      	jsge	0x9018 <_GetChipTemperature+0x68>
    9016:	5cc2      	neg	A
		}
		if ( (uint16) i16ChipTempDelta > C_TEMPERATURE_JUMP )					/* Temperature change small, then accept new temperature */
    9018:	ac0a      	cmp	A, #10
    901a:	1a0a      	jule	0x9030 <_GetChipTemperature+0x80>
		{
			if ( i16ChipTemperature > g_i16ChipTemperature )					/* To great temperature change; Check temperature change "direction" */
    901c:	7122      	lod	A, dp:0x22 <__data_dp_size>
    901e:	eee2      	cmp	Y, A
    9020:	1b04      	jsle	0x902a <_GetChipTemperature+0x7a>
			{
				i16ChipTemperature = g_i16ChipTemperature + 1;					/* Increase by one degree */
    9022:	7122      	lod	A, dp:0x22 <__data_dp_size>
    9024:	7ae2      	lod	Y, A
    9026:	e001      	add	Y, #1
    9028:	0003      	jmp	0x9030 <_GetChipTemperature+0x80>
			}
			else
			{
				i16ChipTemperature = g_i16ChipTemperature - 1;					/* Decrease by one degree */
    902a:	7122      	lod	A, dp:0x22 <__data_dp_size>
    902c:	7ae2      	lod	Y, A
    902e:	e0ff      	add	Y, #-1
			}
		}
	}																			/* MMP131020-1 */
	g_i16ChipTemperature = i16ChipTemperature;
    9030:	5922      	mov	dp:0x22 <__data_dp_size>, Y
    9032:	540d      	ret	#14

00009034 <_GetRawTemperature>:
} /* End of GetChipTemperature() */

#if _SUPPORT_MLX_DEBUG_MODE
uint16 GetRawTemperature( void)
{
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    9034:	7ada 0292 	lod	Y, #658
    9038:	72f0      	lod	A, [Y]
	return ( u16ChipTemperatureSensor );
} /* End of GetRawTemperature() */
    903a:	5401      	ret

0000903c <_GetRawMotorDriverCurrent>:
 * GetRawMotorDriverCurrent()
 *
 * Get (raw) Motor Driver Current [ADC-LSB]
 * ****************************************************************************	*/
uint16 GetRawMotorDriverCurrent( void)
{
    903c:	5801      	inc	S, #2
	uint16 u16Current = 0;
    903e:	7000      	lod	A, #0
    9040:	5201      	mov	[S-2], A
#if ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL))
	g_u16CurrentMotorCoilA = g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    9042:	7ad8 029a 	lod	Y, 0x29a <_g_AdcMotorRunStepper4+0x8>
    9046:	5ad8 0134 	mov	0x134 <_g_u16CurrentMotorCoilA>, Y
	if ( g_u16CurrentMotorCoilA > l_u16CurrentZeroOffset )
    904a:	7ed8 0138 	lod	X, 0x138 <_l_u16CurrentZeroOffset>
    904e:	eeee      	cmp	Y, X
    9050:	1a02      	jule	0x9056 <_GetRawMotorDriverCurrent+0x1a>
	{
		u16Current = g_u16CurrentMotorCoilA - (int16) l_u16CurrentZeroOffset;
    9052:	eaee      	sub	Y, X
    9054:	5a01      	mov	[S-2], Y
	}
	g_u16CurrentMotorCoilB = g_AdcMotorRunStepper4.UnfilteredDriverCurrent2;
    9056:	72d8 0296 	lod	A, 0x296 <_g_AdcMotorRunStepper4+0x4>
    905a:	52d8 0132 	mov	0x132 <_g_u16CurrentMotorCoilB>, A
	if ( g_u16CurrentMotorCoilB > l_u16CurrentZeroOffset )
    905e:	aeee      	cmp	A, X
    9060:	1a03      	jule	0x9068 <_GetRawMotorDriverCurrent+0x2c>
	{
		u16Current = u16Current + (g_u16CurrentMotorCoilB - l_u16CurrentZeroOffset);
    9062:	aaee      	sub	A, X
    9064:	a201      	add	A, [S-2]
    9066:	5201      	mov	[S-2], A
	{
		u16Current = u16Current - (int16) l_u16CurrentZeroOffset;
	}
#endif /* ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)) */
	return ( u16Current );
} /* End of GetRawMotorDriverCurrent() */
    9068:	7201      	lod	A, [S-2]
    906a:	5403      	ret	#4

0000906c <_GetMotorDriverCurrent>:
 *
 * Get Motor Driver Current [mA]
 * ****************************************************************************	*/
int16 GetMotorDriverCurrent( void)
{
	uint16 u16Current = GetRawMotorDriverCurrent();
    906c:	17e7      	call	0x903c <_GetRawMotorDriverCurrent>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    906e:	7ad8 11d0 	lod	Y, 0x11d0 <__ep__+0x1d0>
    9072:	f6da 00ff 	and	Y, #255
    9076:	e2da 0100 	add	Y, #256
    uint32 result;

    __asm__ __volatile__ (
    907a:	4801      	mulu	D, A, Y
    907c:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    907e:	4c22 0040 	add	YA, #64
    9082:	0000 
    9084:	48a6      	lsr	YA, #7
	u16Current = (uint16) ((mulU32_U16byU16( u16Current, EE_GMCURR) + (C_GMCURR_DIV/2)) / C_GMCURR_DIV);	/* MMP131117-1 */
	return ( (int16) u16Current);
} /* End of GetMotorDriverCurrent() */
    9086:	5401      	ret

00009088 <_MeasureVsupplyAndTemperature>:
 *
 * Measure Vbat and Temperature (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureVsupplyAndTemperature( void)
{	
	ADC_Stop();
    9088:	16dd      	call	0x8e44 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_MOTORVOLT;										/* switch ADC input source to Voltage */
    908a:	72da ab72 	lod	A, #43890
    908e:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredDriverVoltage;
    9090:	72da 0298 	lod	A, #664
    9094:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    9096:	16bd      	call	0x8e12 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_SUPPLYVOLT;										/* switch ADC input source to Voltage */
    9098:	72da ab76 	lod	A, #43894
    909c:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    909e:	72da 0294 	lod	A, #660
    90a2:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    90a4:	16b6      	call	0x8e12 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_TEMP;											/* switch ADC input source to Temperature */
    90a6:	72da ab7a 	lod	A, #43898
    90aa:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.IntTemperatureSensor;
    90ac:	72da 0292 	lod	A, #658
    90b0:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    90b2:	16af      	call	0x8e12 <_ADC_StartSoftTrig>
    90b4:	5401      	ret

000090b6 <_MeasureMotorCurrent>:
 *
 * Measure Motor-current (filtered) (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureMotorCurrent( void)
{
	ADC_Stop();
    90b6:	16c6      	call	0x8e44 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURRENT;											/* switch ADC input source to Motor-driver current */
    90b8:	72da ab6e 	lod	A, #43886
    90bc:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    90be:	72da 029a 	lod	A, #666
    90c2:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    90c4:	16a6      	call	0x8e12 <_ADC_StartSoftTrig>
    90c6:	5401      	ret

000090c8 <_MeasurePhaseVoltage>:
 * MeasurePhaseVoltage()
 *
 * Measure Phase voltage (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasurePhaseVoltage( uint16 u16AdcSbase)									/* MMP130919-1 - Begin */
{
    90c8:	5803      	inc	S, #4
    90ca:	5201      	mov	[S-2], A
	uint16 u16PhaseVoltage;
	ADC_Stop();
    90cc:	16bb      	call	0x8e44 <_ADC_Stop>
	ADC_SBASE = (uint16) u16AdcSbase;											/* switch ADC input source to Motor-driver current */
    90ce:	7201      	lod	A, [S-2]
    90d0:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
	ADC_DBASE = (uint16) &u16PhaseVoltage;
    90d2:	72ef      	lod	A, S
    90d4:	a0fc      	add	A, #-4
    90d6:	5294      	mov	io:0x14 <__dp_noinit_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    90d8:	169c      	call	0x8e12 <_ADC_StartSoftTrig>
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    90da:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    90de:	5ce2      	ssex	A
    90e0:	7a03      	lod	Y, [S-4]
    90e2:	eae2      	sub	Y, A
    90e4:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    90e8:	6000      	lod	AL, #0
    90ea:	72e4      	swap	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    90ec:	4831      	muls	YA, A, Y
    90ee:	48b5      	asr	YA, #6
    90f0:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    90f2:	52d8 0112 	mov	0x112 <_g_i16PhaseVoltage>, A
    90f6:	5405      	ret	#6

000090f8 <_HandleDiagnosticEvent>:
 * HandleDiagnosticEvent()
 *
 * Handle Diagnostic Events
 * ****************************************************************************	*/
void HandleDiagnosticEvent( uint16 u16Event)
{
    90f8:	5803      	inc	S, #4
    90fa:	5203      	mov	[S-4], A
	if ( u16Event & (XI4_OC_DRV | XI4_OVT) )
    90fc:	b6da 8100 	and	A, #33024
    9100:	1d01      	jne	0x9104 <_HandleDiagnosticEvent+0xc>
    9102:	0045      	jmp	0x918e <_HandleDiagnosticEvent+0x96>
	{
		/* In case over-current or over-temperature, switch off motor */
#if _SUPPORT_DIAG_OC
		if ( u16Event & XI4_OC_DRV )
    9104:	7203      	lod	A, [S-4]
    9106:	b6da 0100 	and	A, #256
    910a:	191c      	je	0x9144 <_HandleDiagnosticEvent+0x4c>
			/* Chip over-current */
			/* The over-current may occur then chips has entered test-mode. The test-mode freezes the
			 * complete digital part of the chip, including the Motor PWM and driver. This may result
			 * in a phase H and a phase L, having a DC-current flow!!
			 */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    910c:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    910e:	8c01      	cmp	AL, #1
    9110:	1903      	je	0x9118 <_HandleDiagnosticEvent+0x20>
    9112:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    9116:	190c      	je	0x9130 <_HandleDiagnosticEvent+0x38>
    9118:	7eda 008b 	lod	X, #139
    911c:	0000      	nop
    911e:	1bfe      	djnz	X, 0x911c <_HandleDiagnosticEvent+0x24>
			{
				/* Average between two driver-current measurements */
				NopDelay( DELAY_mPWM); /*lint !e522 */							/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
				g_i16Current = GetMotorDriverCurrent();
    9120:	17a5      	call	0x906c <_GetMotorDriverCurrent>
    9122:	52d8 0110 	mov	0x110 <_g_i16Current>, A
				if ( g_i16Current > 1400 )
    9126:	72d8 0110 	lod	A, 0x110 <_g_i16Current>
    912a:	aeda 0578 	cmp	A, #1400
    912e:	1b0a      	jsle	0x9144 <_HandleDiagnosticEvent+0x4c>
				}
			}
			else
			{
				//g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_YES;
				g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;// Ban, stop the motor in case of coil short
    9130:	6002      	lod	AL, #2
    9132:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
				MotorDriverStop( (uint16) C_STOP_EMERGENCY);					/* Over-current */
    9134:	7002      	lod	A, #2
    9136:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
				//g_u16TargetPosition = g_u16ActualPosition;						/* 9.5.3.3 */
				SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    913a:	72da 00d0 	lod	A, #208
    913e:	10f4      	call	0x9328 <_SetLastError>
				g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;
    9140:	60eb      	lod	AL, #-21
    9142:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			}
		}
#endif /* _SUPPORT_DIAG_OC */
		if ( u16Event & XI4_OVT )
    9144:	7203      	lod	A, [S-4]
    9146:	ac00      	cmp	A, #0
    9148:	1ea2      	jsge	0x918e <_HandleDiagnosticEvent+0x96>
		{
			/* Chip over-temperature */
			if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    914a:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    914c:	8c01      	cmp	AL, #1
    914e:	1903      	je	0x9156 <_HandleDiagnosticEvent+0x5e>
    9150:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    9154:	1906      	je	0x9162 <_HandleDiagnosticEvent+0x6a>
			{
				ResetChipTemperature();
    9156:	1727      	call	0x8fa6 <_ResetChipTemperature>
    9158:	7eda 008b 	lod	X, #139
    915c:	0000      	nop
    915e:	1bfe      	djnz	X, 0x915c <_HandleDiagnosticEvent+0x64>
    9160:	0001      	jmp	0x9164 <_HandleDiagnosticEvent+0x6c>
				NopDelay( DELAY_mPWM); /*lint !e522 */
				GetChipTemperature( FALSE);										/* MMP131020-1 */
			}
			else
			{
				MeasureVsupplyAndTemperature();
    9162:	1792      	call	0x9088 <_MeasureVsupplyAndTemperature>
				GetChipTemperature( FALSE);										/* MMP131020-1 */
    9164:	7000      	lod	A, #0
    9166:	1724      	call	0x8fb0 <_GetChipTemperature>
			}
			if ( (g_i16ChipTemperature > (int16) C_CHIP_OVERTEMP_LEVEL) && (g_e8ErrorOverTemperature != (uint8) C_ERR_OTEMP_YES))
    9168:	7122      	lod	A, dp:0x22 <__data_dp_size>
    916a:	aeda 0096 	cmp	A, #150
    916e:	1b0f      	jsle	0x918e <_HandleDiagnosticEvent+0x96>
    9170:	6126      	lod	AL, dp:0x26 <_g_e8ErrorOverTemperature>
    9172:	8c01      	cmp	AL, #1
    9174:	190c      	je	0x918e <_HandleDiagnosticEvent+0x96>
			{
				g_u8OverTemperatureCount++;
    9176:	62d8 010b 	lod	AL, 0x10b <_g_u8OverTemperatureCount>
    917a:	8001      	add	AL, #1
    917c:	42d8 010b 	mov	0x10b <_g_u8OverTemperatureCount>, AL
				if ( g_u8OverTemperatureCount >= (uint8) C_OVERTEMP_TO_PERMDEFECT_THRSHLD )
    9180:	8c03      	cmp	AL, #3
    9182:	1a05      	jule	0x918e <_HandleDiagnosticEvent+0x96>
				{
					g_e8ErrorOverTemperature = (uint8) C_ERR_OTEMP_YES;
    9184:	6001      	lod	AL, #1
    9186:	4126      	mov	dp:0x26 <_g_e8ErrorOverTemperature>, AL
					SetLastError( (uint8) C_ERR_DIAG_OVER_TEMP);
    9188:	72da 00d1 	lod	A, #209
    918c:	10cd      	call	0x9328 <_SetLastError>
					//g_u8OverTemperatureCount = 0;
				}
			}
		}
	}
	if ( u16Event & (XI4_UV | XI4_OV) )
    918e:	7203      	lod	A, [S-4]
    9190:	b6da 6000 	and	A, #24576
    9194:	1d01      	jne	0x9198 <_HandleDiagnosticEvent+0xa0>
    9196:	0043      	jmp	0x921e <_HandleDiagnosticEvent+0x126>
	{
		/* Chip under- or over-voltage */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING) || (g_u8MotorHoldingCurrState != FALSE) )
    9198:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    919a:	8c01      	cmp	AL, #1
    919c:	1903      	je	0x91a4 <_HandleDiagnosticEvent+0xac>
    919e:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    91a2:	1905      	je	0x91ae <_HandleDiagnosticEvent+0xb6>
    91a4:	7eda 008b 	lod	X, #139
    91a8:	0000      	nop
    91aa:	1bfe      	djnz	X, 0x91a8 <_HandleDiagnosticEvent+0xb0>
    91ac:	0001      	jmp	0x91b0 <_HandleDiagnosticEvent+0xb8>
			NopDelay( DELAY_mPWM); /*lint !e522 */								/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
			GetVsupply();
		}
		else
		{
			MeasureVsupplyAndTemperature();
    91ae:	176c      	call	0x9088 <_MeasureVsupplyAndTemperature>
			GetVsupply();
    91b0:	16bf      	call	0x8f30 <_GetVsupply>
		}
		{
			uint8 e8DiagVoltage = (uint8) C_ERR_VOLTAGE_IN_RANGE;
			if ( g_i16SupplyVoltage < (int16)((6 + NVRAM_BROWNOUT_LEVEL) * 100) )
    91b2:	6188      	lod	AL, dp:0x88 <__data_size+0x26>
    91b4:	44b2      	lsr	A, #2
    91b6:	44b2      	lsr	A, #2
    91b8:	44b2      	lsr	A, #2
    91ba:	b403      	and	A, #3
    91bc:	4872 0064 	muls	A, A, #100
    91c0:	a2da 0258 	add	A, #600
    91c4:	7ad8 0114 	lod	Y, 0x114 <_g_i16SupplyVoltage>
    91c8:	eee2      	cmp	Y, A
    91ca:	1e85      	jsge	0x91d6 <_HandleDiagnosticEvent+0xde>
			{
				/* Chip under-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_UNDER;
    91cc:	7001      	lod	A, #1
    91ce:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_UNDER_VOLT);
    91d0:	72da 00d2 	lod	A, #210
    91d4:	0009      	jmp	0x91e8 <_HandleDiagnosticEvent+0xf0>
			}
			else if ( g_i16SupplyVoltage > 2800 )
    91d6:	72d8 0114 	lod	A, 0x114 <_g_i16SupplyVoltage>
    91da:	aeda 0af0 	cmp	A, #2800
    91de:	1b1f      	jsle	0x921e <_HandleDiagnosticEvent+0x126>
			{
				/* Chip over-voltage */
				e8DiagVoltage = (uint8) C_ERR_VOLTAGE_OVER;
    91e0:	7002      	lod	A, #2
    91e2:	5201      	mov	[S-2], A
				SetLastError( (uint8) C_ERR_DIAG_OVER_VOLT);
    91e4:	72da 00d3 	lod	A, #211
    91e8:	109f      	call	0x9328 <_SetLastError>
			}
			if ( e8DiagVoltage != (uint8) C_ERR_VOLTAGE_IN_RANGE)
			{
				g_e8ErrorVoltage = e8DiagVoltage;								/* 9.5.3.4 */
    91ea:	6201      	lod	AL, [S-2]
    91ec:	412b      	mov	dp:0x2b <_g_e8ErrorVoltage>, AL
				g_e8ErrorVoltageComm = g_e8ErrorVoltage;
    91ee:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    91f0:	42d8 0109 	mov	0x109 <_g_e8ErrorVoltageComm>, AL
				if ( g_e8MotorRequest != C_MOTOR_REQUEST_NONE )					/* MMP150313-3 - Begin */
    91f4:	612e      	lod	AL, dp:0x2e <_g_e8MotorRequest>
    91f6:	1904      	je	0x9200 <_HandleDiagnosticEvent+0x108>
				{
					g_e8DegradedMotorRequest = g_e8MotorRequest;
    91f8:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					g_e8MotorRequest = C_MOTOR_REQUEST_NONE;
    91fa:	6000      	lod	AL, #0
    91fc:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    91fe:	0009      	jmp	0x9212 <_HandleDiagnosticEvent+0x11a>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_RUNNING )	/* MMP150313-3 - End */
    9200:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9202:	8c01      	cmp	AL, #1
    9204:	1d02      	jne	0x920a <_HandleDiagnosticEvent+0x112>
				{
					/* Enter degraded-mode; Stop motor and resume when voltage decreases below upper-application threshold or raise above lower-application threshold */
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_START;
    9206:	6003      	lod	AL, #3
    9208:	0003      	jmp	0x9210 <_HandleDiagnosticEvent+0x118>
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Under/Over-voltage */
				}
				else if ( g_e8DegradedMotorRequest == (uint8) C_MOTOR_REQUEST_NONE )
    920a:	6125      	lod	AL, dp:0x25 <_g_e8DegradedMotorRequest>
    920c:	1d05      	jne	0x9218 <_HandleDiagnosticEvent+0x120>
				{
					g_e8DegradedMotorRequest = (uint8) C_MOTOR_REQUEST_STOP;
    920e:	6001      	lod	AL, #1
    9210:	4125      	mov	dp:0x25 <_g_e8DegradedMotorRequest>, AL
					MotorDriverStop( (uint16) C_STOP_EMERGENCY);				/* Degraded-mode */
    9212:	7002      	lod	A, #2
    9214:	82db 9b76 	callf	0x9b76 <_MotorDriverStop>
				}
				g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_DEGRADED;
    9218:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    921a:	8480      	or	AL, #-128
    921c:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
    921e:	5405      	ret	#6

00009220 <_DiagnosticsInit>:
 * Don't automatically shut-off motor-driver on over- or under-voltage, or over-temperature.
 * Diagnostic ISR priority: 3 
 * ****************************************************************************	*/
void DiagnosticsInit( void)
{
	DRVCFG = (DRVCFG | (DIS_OC | DIS_OT | DIS_OV | DIS_UV));					/* Disable over-current, over-temperature, over-voltage, under-voltage */
    9220:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9224:	a6da f000 	or	A, #61440
    9228:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	ANA_OUTI &= ~SEL_UV_VS;														/* Enable UV & OV debounce circuitry */
    922c:	72d8 28d0 	lod	A, 0x28d0 <__io__+0xd0>
    9230:	b6da efff 	and	A, #61439
    9234:	52d8 28d0 	mov	0x28d0 <__io__+0xd0>, A
	ANA_OUTG = (ANA_OUTG & 0xFCFF) | (NVRAM_BROWNOUT_LEVEL << 8);				/* Brown-out UV-level = 6V + n * 1V; */
    9238:	7ad8 28cc 	lod	Y, 0x28cc <__io__+0xcc>
    923c:	f6da fcff 	and	Y, #64767
    9240:	6188      	lod	AL, dp:0x88 <__data_size+0x26>
    9242:	44a2      	asl	A, #2
    9244:	b6da 0300 	and	A, #768
    9248:	e6e2      	or	Y, A
    924a:	5ad8 28cc 	mov	0x28cc <__io__+0xcc>, Y
	{
		/* IO[0] is low; Set IRQ-event on rising-edge */
		IO_CFG &= ~FRB_IO5;
	}
#else  /* (_SUPPORT_HALL_SENSOR) */
	XI4_PEND = C_DIAG_MASK;
    924e:	72da e100 	lod	A, #57600
    9252:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	XI4_MASK |= C_DIAG_MASK;
    9256:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    925a:	a6da e100 	or	A, #57600
    925e:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
#endif /* (_SUPPORT_HALL_SENSOR) */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */						/* EXT4_IT Priority: 3 (3..6) */
	PRIO = (PRIO & ~(3U << 14));												/* EXT4_IT Priority: 3 (3..6) */
    9262:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    9266:	b6da 3fff 	and	A, #16383
    926a:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT4_IT;
    926e:	72da 1000 	lod	A, #4096
    9272:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    9276:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    927a:	a6da 1000 	or	A, #4096
    927e:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* MMP141212-1: Check for OVT and OV. Perform Diagnostics handling if required */
	{
#if (_SUPPORT_DIAG_OVT == FALSE)
		uint16 u16DiagnosticEvent = (ANA_INA & XI4_OV);
#else  /* (_SUPPORT_DIAG_OVT == FALSE) */
		uint16 u16DiagnosticEvent = (ANA_INA & (XI4_OVT | XI4_OV));
    9282:	729c      	lod	A, io:0x1c <_g_e8EXVMoveEnableRequestFlag>
    9284:	b6da a000 	and	A, #40960
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */
		if ( u16DiagnosticEvent != 0 )
    9288:	1901      	je	0x928c <_DiagnosticsInit+0x6c>
		{
			HandleDiagnosticEvent( u16DiagnosticEvent);
    928a:	1736      	call	0x90f8 <_HandleDiagnosticEvent>
    928c:	5401      	ret

0000928e <_EXT4_IT>:
 * EXT4_IT()
 *
 * Diagnostic & IO Interrupt Service Routine.
 * ****************************************************************************	*/
__interrupt__ void EXT4_IT(void)
{
    928e:	52df      	push	A
    9290:	5edf      	push	X
    9292:	5adf      	push	Y
    9294:	4c83      	push	D
    9296:	5801      	inc	S, #2
	uint16 u16Pending = (XI4_PEND & XI4_MASK);									/* Copy interrupt requests which are not masked   */
    9298:	7ad8 203c 	lod	Y, 0x203c <__ep__+0x103c>
    929c:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    92a0:	f6e2      	and	Y, A
    92a2:	5a01      	mov	[S-2], Y
	do
	{
		XI4_PEND = u16Pending;													/* Clear requests which are going to be processed */
    92a4:	7201      	lod	A, [S-2]
    92a6:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	} while (XI4_PEND & u16Pending);
    92aa:	72d8 203c 	lod	A, 0x203c <__ep__+0x103c>
    92ae:	b601      	and	A, [S-2]
    92b0:	1d79      	jne	0x92a4 <_EXT4_IT+0x16>

	/* Multiple diagnostics events is most likely caused by Rinnen/ESD-pulse */
	if ( ((u16Pending & XI4_UV) != 0) && ((u16Pending & (XI4_OC_DRV | XI4_OVT | XI4_OV)) != 0) )
    92b2:	7201      	lod	A, [S-2]
    92b4:	b6da 4000 	and	A, #16384
    92b8:	1904      	je	0x92c2 <_EXT4_IT+0x34>
    92ba:	7201      	lod	A, [S-2]
    92bc:	b6da a100 	and	A, #41216
    92c0:	1d17      	jne	0x92f0 <_EXT4_IT+0x62>
	{
		/* Under-voltage together with any other diagnostic event is strange */
	}
	else
	{
		HandleDiagnosticEvent( u16Pending);
    92c2:	7201      	lod	A, [S-2]
    92c4:	1719      	call	0x90f8 <_HandleDiagnosticEvent>

		if ( (u16Pending & XI4_IO5) != 0 )
    92c6:	7201      	lod	A, [S-2]
    92c8:	b420      	and	A, #32
    92ca:	1912      	je	0x92f0 <_EXT4_IT+0x62>
		{
			g_u8HallSwitchState = IO_IN & XI4_IO5;
    92cc:	72d8 28ca 	lod	A, 0x28ca <__io__+0xca>
    92d0:	9420      	and	AL, #32
    92d2:	42d8 013c 	mov	0x13c <_g_u8HallSwitchState>, AL
			if ( g_u8HallSwitchState )
    92d6:	1904      	je	0x92e0 <_EXT4_IT+0x52>
			{
				/* IO[0] is high; Set IRQ-event on falling-edge */
				IO_CFG |= FRB_IO5;
    92d8:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    92dc:	a420      	or	A, #32
    92de:	0003      	jmp	0x92e6 <_EXT4_IT+0x58>
			}
			else
			{
				/* IO[0] is low; Set IRQ-event on rising-edge */
				IO_CFG &= ~FRB_IO5;
    92e0:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    92e4:	b4df      	and	A, #-33
    92e6:	52d8 28be 	mov	0x28be <__io__+0xbe>, A
			}
			//g_u16HallMicroStepIdx = g_u16MicroStepIdx;
			g_u16HallMicroStepIdx = g_u16ActuatorActPos;//Ban
    92ea:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    92ec:	52d8 013a 	mov	0x13a <_g_u16HallMicroStepIdx>, A
    92f0:	5c01      	dec	S, #2
    92f2:	4cc3      	pop	D
    92f4:	7acf      	pop	Y
    92f6:	7ecf      	pop	X
    92f8:	72cf      	pop	A
    92fa:	4407      	mov	R, #0
    92fc:	72cb      	pop	M
    92fe:	5401      	ret

00009300 <_ErrorLogInit>:
 *
 *	Comments:	Clear Error-FiFo-buffer, in case watchdog reset occurred, 
 *				otherwise leave untouched.
 * ****************************************************************************	*/
void ErrorLogInit( void)
{
    9300:	5803      	inc	S, #4
	if ( (AWD_CTRL & AWD_RST) != 0 )
    9302:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    9304:	ac00      	cmp	A, #0
    9306:	1e8f      	jsge	0x9326 <_ErrorLogInit+0x26>
	{
		uint16 i;
		for ( i = 0; i < C_ERR_LOG_SZ; i++ )
    9308:	7000      	lod	A, #0
    930a:	780a      	lod	Y, #10
    930c:	5a01      	mov	[S-2], Y
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
    930e:	7ee2      	lod	X, A
    9310:	22da 029c 	add	X, #668
    9314:	6400      	lod	YL, #0
    9316:	46f8      	mov	[X], YL
void ErrorLogInit( void)
{
	if ( (AWD_CTRL & AWD_RST) != 0 )
	{
		uint16 i;
		for ( i = 0; i < C_ERR_LOG_SZ; i++ )
    9318:	a001      	add	A, #1
    931a:	7e01      	lod	X, [S-2]
    931c:	20ff      	add	X, #-1
    931e:	5e01      	mov	[S-2], X
    9320:	1d76      	jne	0x930e <_ErrorLogInit+0xe>
		{
			l_au8FiFoErrorLog[i] = C_ERR_NONE;
		}
		l_u8ErrorLogIdx = 0;
    9322:	46d8 013d 	mov	0x13d <_l_u8ErrorLogIdx>, YL
    9326:	5405      	ret	#6

00009328 <_SetLastError>:
 *
 *	Comments:	Save error-code in Error-FiFo-buffer, unless last error is the 
 *				same as error posted.
 * ****************************************************************************	*/
void SetLastError( uint8 u8ErrorCode)
{
    9328:	5801      	inc	S, #2
    932a:	7ee2      	lod	X, A
	if ( (l_u8ErrorLogIdx == 0) || (l_au8FiFoErrorLog[l_u8ErrorLogIdx - 1] != u8ErrorCode) )
    932c:	62d8 013d 	lod	AL, 0x13d <_l_u8ErrorLogIdx>
    9330:	4201      	mov	[S-2], AL
    9332:	1908      	je	0x9344 <_SetLastError+0x1c>
    9334:	5cf2      	usex	A
    9336:	7ae2      	lod	Y, A
    9338:	e2da 029b 	add	Y, #667
    933c:	62f0      	lod	AL, [Y]
    933e:	7aee      	lod	Y, X
    9340:	8ee8      	cmp	AL, YL
    9342:	1920      	je	0x9384 <_SetLastError+0x5c>
	{
		/* Don't log the same error over and over again */
		l_au8FiFoErrorLog[l_u8ErrorLogIdx] = u8ErrorCode;
    9344:	6201      	lod	AL, [S-2]
    9346:	5cf2      	usex	A
    9348:	7ae2      	lod	Y, A
    934a:	e2da 029c 	add	Y, #668
    934e:	72ee      	lod	A, X
    9350:	42f0      	mov	[Y], AL
		if ( l_u8ErrorLogIdx < (C_ERR_LOG_SZ - 1) )
    9352:	6201      	lod	AL, [S-2]
    9354:	8c08      	cmp	AL, #8
    9356:	1e03      	jug	0x935e <_SetLastError+0x36>
		{
			l_u8ErrorLogIdx++;
    9358:	8001      	add	AL, #1
    935a:	42d8 013d 	mov	0x13d <_l_u8ErrorLogIdx>, AL
		}

		/* Log serious error-codes also in NVRAM */
		/* Serious errors are:
		  	  Unsupported IRQ's   or C_ERR_INV_MLXPAGE_CRC1..4, CAL_GN or Over-temperature                   or 'Fatal'-errors */
		if ( (u8ErrorCode < 0x20) || ((u8ErrorCode & 0xC8) == 0xC8) || (u8ErrorCode == (uint8) C_ERR_DIAG_OVER_TEMP) || ((u8ErrorCode & 0xF0) == 0xF0) ) /*lint !e845 */
    935e:	72ee      	lod	A, X
    9360:	8c1f      	cmp	AL, #31
    9362:	1a0d      	jule	0x937e <_SetLastError+0x56>
    9364:	b6da 00c8 	and	A, #200
    9368:	aeda 00c8 	cmp	A, #200
    936c:	1908      	je	0x937e <_SetLastError+0x56>
    936e:	72ee      	lod	A, X
    9370:	8cd1      	cmp	AL, #-47
    9372:	1905      	je	0x937e <_SetLastError+0x56>
    9374:	b6da 00f0 	and	A, #240
    9378:	aeda 00f0 	cmp	A, #240
    937c:	1d03      	jne	0x9384 <_SetLastError+0x5c>
		{
			(void) NVRAM_LogError( u8ErrorCode);
    937e:	72ee      	lod	A, X
    9380:	82db a32a 	callf	0xa32a <_NVRAM_LogError>
    9384:	5403      	ret	#4

00009386 <_GetLastError>:
		}
	}
} /* End of SetLastError() */

uint8 GetLastError( void)
{
    9386:	5809      	inc	S, #10
	uint8 u8Reply = l_au8FiFoErrorLog[0];
    9388:	62d8 029c 	lod	AL, 0x29c <_l_au8FiFoErrorLog>
    938c:	5cf2      	usex	A
    938e:	5209      	mov	[S-10], A
	if ( l_u8ErrorLogIdx != 0 )
    9390:	62d8 013d 	lod	AL, 0x13d <_l_u8ErrorLogIdx>
    9394:	4207      	mov	[S-8], AL
    9396:	1924      	je	0x93e0 <_GetLastError+0x5a>
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    9398:	72e3      	lod	A, M
    939a:	5203      	mov	[S-4], A
	{
		uint16 i;
		ATOMIC_CODE
    939c:	4407      	mov	R, #0
    939e:	500c      	call	fp0:0x60
    93a0:	54f0      	mov	UPr, #0
    93a2:	7001      	lod	A, #1
    93a4:	5205      	mov	[S-6], A
    93a6:	6207      	lod	AL, [S-8]
    93a8:	5cf2      	usex	A
    93aa:	5201      	mov	[S-2], A
    93ac:	7001      	lod	A, #1
    93ae:	ae01      	cmp	A, [S-2]
    93b0:	1c0b      	jnc	0x93c8 <_GetLastError+0x42>
    93b2:	7a05      	lod	Y, [S-6]
    93b4:	e2da 029c 	add	Y, #668
    93b8:	7ee6      	lod	X, Y
    93ba:	20ff      	add	X, #-1
    93bc:	62f0      	lod	AL, [Y]
    93be:	42f8      	mov	[X], AL
    93c0:	7205      	lod	A, [S-6]
    93c2:	a001      	add	A, #1
    93c4:	5205      	mov	[S-6], A
    93c6:	07f3      	jmp	0x93ae <_GetLastError+0x28>
    93c8:	6207      	lod	AL, [S-8]
    93ca:	80ff      	add	AL, #-1
    93cc:	42d8 013d 	mov	0x13d <_l_u8ErrorLogIdx>, AL
    93d0:	5cf2      	usex	A
    93d2:	7ae2      	lod	Y, A
    93d4:	e2da 029c 	add	Y, #668
    93d8:	6000      	lod	AL, #0
    93da:	42f0      	mov	[Y], AL
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    93dc:	7203      	lod	A, [S-4]
    93de:	52e3      	mov	M, A
			l_u8ErrorLogIdx--;
			l_au8FiFoErrorLog[l_u8ErrorLogIdx] = C_ERR_NONE;
		);
	}
	return ( u8Reply );
} /* End of GetLastError() */
    93e0:	7209      	lod	A, [S-10]
    93e2:	540b      	ret	#12

000093e4 <_MotorDriverInit>:
 * MotorDriverInit()
 *
 * Initialise Motor Driver
 * ****************************************************************************	*/
void MotorDriverInit( void)
{
    93e4:	5835      	inc	S, #54
#if _SUPPORT_DOUBLE_USTEP
	uint16 u16MotorMicroStepsPerFullStep = (1 << (NVRAM_MICRO_STEPS + 1));		/* Number of micro-steps per full-step (2, 4, 8 or 16) */
    93e6:	618c      	lod	AL, dp:0x8c <__data_size+0x2a>
    93e8:	4233      	mov	[S-52], AL
    93ea:	44b0      	lsr	AL, #2
    93ec:	44b0      	lsr	AL, #2
    93ee:	4430      	lsr	AL
    93f0:	b403      	and	A, #3
    93f2:	a001      	add	A, #1
    93f4:	44e2      	sfb	A
    93f6:	5235      	mov	[S-54], A
    93f8:	6233      	lod	AL, [S-52]
    93fa:	4440      	rl	AL
    93fc:	9401      	and	AL, #1
    93fe:	5cf2      	usex	A
    9400:	7ae2      	lod	Y, A
    9402:	e002      	add	Y, #2
    9404:	4426      	asl	Y
    uint32 result;

    __asm__ __volatile__ (
    9406:	7235      	lod	A, [S-54]
    9408:	4801      	mulu	D, A, Y
    940a:	72ef      	lod	A, S
    940c:	a0ce      	add	A, #-50
    940e:	4cf3      	swap	YA
    9410:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    9412:	7a31      	lod	Y, [S-50]
    9414:	5ad8 02a8 	mov	0x2a8 <_g_u16MotorMicroStepsPerElecRotation>, Y
    9418:	618b      	lod	AL, dp:0x8b <__data_size+0x29>
    941a:	44b2      	lsr	A, #2
    941c:	44b2      	lsr	A, #2
    941e:	b40f      	and	A, #15
    9420:	a001      	add	A, #1
    uint32 result;

    __asm__ __volatile__ (
    9422:	4801      	mulu	D, A, Y
    9424:	7aef      	lod	Y, S
    9426:	e0d2      	add	Y, #-46
    9428:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    942a:	7e2d      	lod	X, [S-46]
    942c:	5ed8 02aa 	mov	0x2aa <_g_u16MotorMicroStepsPerMechRotation>, X
	uint16 u16MotorMicroStepsPerFullStep = (1 << NVRAM_MICRO_STEPS);			/* Number of micro-steps per full-step (1, 2, 4 or 8) */
#endif /* _SUPPORT_DOUBLE_USTEP */
	g_u16MotorMicroStepsPerElecRotation = (uint16) mulU32_U16byU16( u16MotorMicroStepsPerFullStep, (NVRAM_MOTOR_PHASES + 2) << 1);
	g_u16MotorMicroStepsPerMechRotation = (uint16) mulU32_U16byU16( NVRAM_POLE_PAIRS, g_u16MotorMicroStepsPerElecRotation);
	{
		uint16 u16ConstAccelaration = NVRAM_ACCELERATION_CONST;
    9430:	71a0      	lod	A, dp:0xa0 <__data_size+0x3e>
		if ( u16ConstAccelaration != 0 )
    9432:	1d01      	jne	0x9436 <_MotorDriverInit+0x52>
    9434:	0085      	jmp	0x9540 <_MotorDriverInit+0x15c>
		{
			l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60), g_u16MotorMicroStepsPerMechRotation);
    9436:	722d      	lod	A, [S-46]
    9438:	52df      	push	A
    943a:	4ce2 2c40 	mov	YA, #105000000
    943e:	0642 
    9440:	82db 6c3a 	callf	0x6c3a <_divU32_U32byU16>
    9444:	4cc0      	mov	D, YA
    9446:	52d8 0352 	mov	0x352 <_l_u32Temp>, A
    944a:	5ad8 0354 	mov	0x354 <_l_u32Temp+0x2>, Y
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    944e:	5c01      	dec	S, #2
    9450:	799e      	lod	Y, dp:0x9e <__data_size+0x3c>
    9452:	5a29      	mov	[S-42], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9454:	4c80      	mov	YA, D
    9456:	7e29      	lod	X, [S-42]
    9458:	4c63      	divu	YA, X
    945a:	4c63      	divu	YA, X
    945c:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    945e:	a0ff      	add	A, #-1
    9460:	52d8 02bc 	mov	0x2bc <_g_au16MotorSpeedCommutTimerPeriod+0xe>, A
    9464:	52d8 02ae 	mov	0x2ae <_g_au16MotorSpeedCommutTimerPeriod>, A
    9468:	79c2      	lod	Y, dp:0xc2 <__bss_dp_size+0x12>
    946a:	5a25      	mov	[S-38], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    946c:	4c80      	mov	YA, D
    946e:	7e25      	lod	X, [S-38]
    9470:	4c63      	divu	YA, X
    9472:	4c63      	divu	YA, X
    9474:	5223      	mov	[S-36], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9476:	a0ff      	add	A, #-1
    9478:	52d8 02ba 	mov	0x2ba <_g_au16MotorSpeedCommutTimerPeriod+0xc>, A
    947c:	52d8 02b0 	mov	0x2b0 <_g_au16MotorSpeedCommutTimerPeriod+0x2>, A
    9480:	798e      	lod	Y, dp:0x8e <__data_size+0x2c>
    9482:	5a1f      	mov	[S-32], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9484:	4c80      	mov	YA, D
    9486:	7e1f      	lod	X, [S-32]
    9488:	4c63      	divu	YA, X
    948a:	4c63      	divu	YA, X
    948c:	521d      	mov	[S-30], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    948e:	a0ff      	add	A, #-1
    9490:	5150      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, A
    9492:	52d8 02b2 	mov	0x2b2 <_g_au16MotorSpeedCommutTimerPeriod+0x4>, A
    9496:	7990      	lod	Y, dp:0x90 <__data_size+0x2e>
    9498:	5a19      	mov	[S-26], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    949a:	4c80      	mov	YA, D
    949c:	7e19      	lod	X, [S-26]
    949e:	4c63      	divu	YA, X
    94a0:	4c63      	divu	YA, X
    94a2:	5217      	mov	[S-24], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    94a4:	a0ff      	add	A, #-1
    94a6:	52d8 02b4 	mov	0x2b4 <_g_au16MotorSpeedCommutTimerPeriod+0x6>, A
    94aa:	7992      	lod	Y, dp:0x92 <__data_size+0x30>
    94ac:	5a13      	mov	[S-20], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    94ae:	4c80      	mov	YA, D
    94b0:	7e13      	lod	X, [S-20]
    94b2:	4c63      	divu	YA, X
    94b4:	4c63      	divu	YA, X
    94b6:	5211      	mov	[S-18], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    94b8:	a0ff      	add	A, #-1
    94ba:	52d8 02b6 	mov	0x2b6 <_g_au16MotorSpeedCommutTimerPeriod+0x8>, A
    94be:	7994      	lod	Y, dp:0x94 <__data_size+0x32>
    94c0:	5a0d      	mov	[S-14], Y
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    94c2:	4c80      	mov	YA, D
    94c4:	7e0d      	lod	X, [S-14]
    94c6:	4c63      	divu	YA, X
    94c8:	4c63      	divu	YA, X
    94ca:	5205      	mov	[S-6], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    94cc:	a0ff      	add	A, #-1
    94ce:	52d8 02b8 	mov	0x2b8 <_g_au16MotorSpeedCommutTimerPeriod+0xa>, A
			g_au16MotorSpeedCommutTimerPeriod[3] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED1) - 1;
			g_au16MotorSpeedCommutTimerPeriod[4] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED2) - 1;
			g_au16MotorSpeedCommutTimerPeriod[5] = divU16_U32byU16( l_u32Temp, NVRAM_SPEED3) - 1;
			g_au16MotorSpeedCommutTimerPeriod[6] = g_au16MotorSpeedCommutTimerPeriod[1];
			g_au16MotorSpeedCommutTimerPeriod[7] = g_au16MotorSpeedCommutTimerPeriod[0];
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[2];	/* Target commutation timer period (target speed) */
    94d2:	7950      	lod	Y, dp:0x50 <_g_u16CommutTimerPeriod>
    94d4:	5952      	mov	dp:0x52 <_g_u16TargetCommutTimerPeriod>, Y
    94d6:	7229      	lod	A, [S-42]
    94d8:	a01e      	add	A, #30
    94da:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    94dc:	4c80      	mov	YA, D
    94de:	7c3c      	lod	X, #60
    94e0:	4c63      	divu	YA, X
    94e2:	4c63      	divu	YA, X
    94e4:	520b      	mov	[S-12], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    94e6:	52d8 02be 	mov	0x2be <_g_au16MotorSpeedRPS>, A
    94ea:	7225      	lod	A, [S-38]
    94ec:	a01e      	add	A, #30
    94ee:	4cc8      	movu	D, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    94f0:	4c80      	mov	YA, D
    94f2:	4c63      	divu	YA, X
    94f4:	4c63      	divu	YA, X
    94f6:	5209      	mov	[S-10], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    94f8:	52d8 02c0 	mov	0x2c0 <_g_au16MotorSpeedRPS+0x2>, A
    94fc:	721f      	lod	A, [S-32]
    94fe:	a01e      	add	A, #30
    9500:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9502:	4c63      	divu	YA, X
    9504:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9506:	52d8 02c2 	mov	0x2c2 <_g_au16MotorSpeedRPS+0x4>, A
    950a:	7219      	lod	A, [S-26]
    950c:	a01e      	add	A, #30
    950e:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9510:	4c63      	divu	YA, X
    9512:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9514:	52d8 02c4 	mov	0x2c4 <_g_au16MotorSpeedRPS+0x6>, A
    9518:	7213      	lod	A, [S-20]
    951a:	a01e      	add	A, #30
    951c:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    951e:	4c63      	divu	YA, X
    9520:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9522:	52d8 02c6 	mov	0x2c6 <_g_au16MotorSpeedRPS+0x8>, A
    9526:	720d      	lod	A, [S-14]
    9528:	a01e      	add	A, #30
    952a:	4cf2      	usex	YA
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    952c:	4c63      	divu	YA, X
    952e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9530:	52d8 02c8 	mov	0x2c8 <_g_au16MotorSpeedRPS+0xa>, A
			g_au16MotorSpeedRPS[1] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED_TORQUE_BOOST + 30U), 60);
			g_au16MotorSpeedRPS[2] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED0 + 30U), 60);
			g_au16MotorSpeedRPS[3] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED1 + 30U), 60);
			g_au16MotorSpeedRPS[4] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED2 + 30U), 60);
			g_au16MotorSpeedRPS[5] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60);
			g_au16MotorSpeedRPS[6] = g_au16MotorSpeedRPS[1];
    9534:	7a09      	lod	Y, [S-10]
    9536:	5ad8 02ca 	mov	0x2ca <_g_au16MotorSpeedRPS+0xc>, Y
			g_au16MotorSpeedRPS[7] = g_au16MotorSpeedRPS[0];
    953a:	7e0b      	lod	X, [S-12]
    953c:	5ed8 02cc 	mov	0x2cc <_g_au16MotorSpeedRPS+0xe>, X
		}
	}

	g_u16CorrectionRatio = NVRAM_MIN_CORR_RATIO;
    9540:	61bc      	lod	AL, dp:0xbc <__bss_dp_size+0xc>
    9542:	5cf2      	usex	A
    9544:	4832 0576 	muls	YA, A, #1398
    9548:	48a3      	lsr	YA, #4
    954a:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
	/* BLDC motor Commutation/Stepper timer */
	g_u16MicroStepIdx = 0;
    954c:	7000      	lod	A, #0
    954e:	514e      	mov	dp:0x4e <_g_u16MicroStepIdx>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0;												/* Timer mode 0 */
    9550:	7ada 4001 	lod	Y, #16385
    9554:	5aaa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, Y
	TMR1_REGB = g_u16CommutTimerPeriod;											/* Will be overwritten by MotorDriverStart() */
    9556:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    9558:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    955a:	7c40      	lod	X, #64
    955c:	5ed8 2034 	mov	0x2034 <__ep__+0x1034>, X
	XI0_MASK |= EN_T1_INT4;														/* Enable Timer1, CompareB (T1_INT4) */
    9560:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    9564:	a440      	or	A, #64
    9566:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	PRIO = (PRIO & ~(3 << 6)) | ((4 - 3) << 6);									/* Set Timer1 priority to 4 (3..6) */
    956a:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    956e:	b6da ff3f 	and	A, #65343
    9572:	a440      	or	A, #64
    9574:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT0_IT;
    9578:	72da 0100 	lod	A, #256
    957c:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT0_IT;
    9580:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    9584:	a6da 0100 	or	A, #256
    9588:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    958c:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    958e:	5cf2      	usex	A
    uint32 result;

    __asm__ __volatile__ (
    9590:	7a35      	lod	Y, [S-54]
    9592:	4801      	mulu	D, A, Y
    9594:	7aef      	lod	Y, S
    9596:	e0fa      	add	Y, #-6
    9598:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    959a:	7e05      	lod	X, [S-6]
    959c:	5ed8 02ac 	mov	0x2ac <_g_u16MotorRewindSteps>, X

	g_u16MotorRewindSteps = (uint16) mulU32_U16byU16( NVRAM_REWIND_STEPS, u16MotorMicroStepsPerFullStep);

	/* Setup Motor PWM */	
	PWM1_CTRL = 0;																/* Disable master */
    95a0:	6000      	lod	AL, #0
    95a2:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = 0;																/* Disable Slave 1 */
    95a6:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = 0;																/* Disable Slave 2 */
    95aa:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = 0;																/* Disable Slave 3 */
    95ae:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = 0;																/* Disable Slave 4 */
    95b2:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
	PWM1_PSCL = PWM_PRESCALER;													/* Initialise the master pre-scaler ratio (Fck/8) */
    95b6:	42d8 284b 	mov	0x284b <__io__+0x4b>, AL
	PWM1_PER = PWM_REG_PERIOD;
    95ba:	7ada 0576 	lod	Y, #1398
    95be:	5ad8 284c 	mov	0x284c <__io__+0x4c>, Y
	PWM2_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    95c2:	5ad8 2856 	mov	0x2856 <__io__+0x56>, Y
	PWM3_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    95c6:	5ad8 2860 	mov	0x2860 <__io__+0x60>, Y
	PWM4_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    95ca:	5ad8 286a 	mov	0x286a <__io__+0x6a>, Y
	PWM5_PER = PWM_REG_PERIOD;													/* -=#=- Probably not needed to set slave period too */
    95ce:	5ad8 2874 	mov	0x2874 <__io__+0x74>, Y
	PWM5_CMP = (((83L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 83% of period */
#else  /* _SUPPORT_PHASE_SHORT_DET */
	/* (Single PWM)	17%			33%			50%			75%			100%		(7.0us/ADC-conversion)
	 * MF_STEPPER:	Temperature	Vs-filt		Imotor1		Vsm-unfilt	Imotor2
	 */
	PWM1_CMP = (((17L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 17% of period */
    95d2:	7eda 00ee 	lod	X, #238
    95d6:	5ed8 2852 	mov	0x2852 <__io__+0x52>, X
	PWM2_CMP = (((33L * PWM_REG_PERIOD) + 50)/100);		/*  7.0us */			/* 33% of period */
    95da:	72da 01cd 	lod	A, #461
    95de:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
	PWM3_CMP = (((50L * PWM_REG_PERIOD) + 50)/100);		/*  10.5us */			/* 50% of period */
    95e2:	7ada 02bb 	lod	Y, #699
    95e6:	5ad8 2866 	mov	0x2866 <__io__+0x66>, Y
	PWM4_CMP = (((75L * PWM_REG_PERIOD) + 50)/100);		/*  10.5us */			/* 75% of period */
    95ea:	7eda 0419 	lod	X, #1049
    95ee:	5ed8 2870 	mov	0x2870 <__io__+0x70>, X
	PWM3_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 2 control register - CMPI enabled */
	PWM4_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 3 control register - CMPI enabled */
	PWM5_CTRL = (MODE | EXT | EBLK);											/* Initialise the slave 4 control register - CMPI disabled */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	/* In-depended mode */
	PWM1_CTRL = (EBLK | ECI | EPI);												/* Initialise the master control register - CMPI and PWMI enabled */
    95f2:	6019      	lod	AL, #25
    95f4:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 1 control register - CMPI enabled */
    95f8:	6013      	lod	AL, #19
    95fa:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 2 control register - CMPI enabled */
    95fe:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 3 control register - CMPI enabled */
    9602:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = (ECI | EXT | EBLK);												/* Initialise the slave 4 control register - CMPI enabled */
    9606:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	PWM1_CTRL |= EBLK;															/* Start PWM in application mode */
    960a:	62d8 284a 	lod	AL, 0x284a <__io__+0x4a>
    960e:	8401      	or	AL, #1
    9610:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
    9614:	5437      	ret	#56

00009616 <_MotorDriverSelfTest>:
 * 3. Test Open connection with motor-phase
 * 4. Test BEMF Voltage levels
 * ****************************************************************************	*/
#define FET_SETTING (((10*PLL_freq)/(1000000*CYCLES_PER_INSTR*2)) + 1)			/* 10us: 10us*PLL-freq/(10000000us/s * #cycles/instruction) * instructions */
void MotorDriverSelfTest( void)
{
    9616:	5823      	inc	S, #36
	uint16 u16SelfTestIdx;
	uint16 u16VdsThreshold;														/* MMP130919-1/MMP140403-1 */
	T_ADC_SELFTEST_4PH adcMotorSelfTest4Ph;
	uint16 u16Pwm2Storage = PWM2_CMP;											/* MMP150219-2: Save PWM2 ADC trigger CMP time */
    9618:	72d8 285c 	lod	A, 0x285c <__io__+0x5c>
    961c:	5209      	mov	[S-10], A
	PWM2_CMP = (((50L * PWM_REG_PERIOD) + 50)/100);								/* MMP150219-2: Set PWM2 ADC trigger CMP time at 50% or period */
    961e:	7eda 02bb 	lod	X, #699
    9622:	5ed8 285c 	mov	0x285c <__io__+0x5c>, X

	g_e8ErrorCoil = 0;//init
    9626:	6000      	lod	AL, #0
    9628:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL

	MeasureVsupplyAndTemperature();												/* MMP130919-1 - Begin */
    962a:	152e      	call	0x9088 <_MeasureVsupplyAndTemperature>
	GetVsupplyMotor();
    962c:	149f      	call	0x8f6c <_GetVsupplyMotor>
	if ( NVRAM_VDS_THRESHOLD != 0 )
    962e:	61c7      	lod	AL, dp:0xc7 <__bss_dp_size+0x17>
    9630:	b43f      	and	A, #63
    9632:	4872 0019 	muls	A, A, #25
    9636:	4432      	lsr	A
    9638:	1910      	je	0x965a <_MotorDriverSelfTest+0x44>
    963a:	0011      	jmp	0x965e <_MotorDriverSelfTest+0x48>
		DRVCFG_GND_UVWT();

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
		{
			/* Over-current trigger; Phase makes short with other phase */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    963c:	6002      	lod	AL, #2
    963e:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_B);
    9640:	72da 00eb 	lod	A, #235
    9644:	1671      	call	0x9328 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;//Ban, phase shot with other phase
    9646:	60eb      	lod	AL, #-21
    9648:	0006      	jmp	0x9656 <_MotorDriverSelfTest+0x40>
#endif // _SUPPORT_COIL_RESISTANCE_CHECK
		extern uint16 l_u16CurrentZeroOffset;
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
		{
			/* No current (less than 10 LSB's); Coil Open */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    964a:	6002      	lod	AL, #2
    964c:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( C_ERR_SELFTEST_C);
    964e:	72da 00ec 	lod	A, #236
    9652:	166a      	call	0x9328 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;
    9654:	60ec      	lod	AL, #-20
    9656:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			break;
    9658:	00b7      	jmp	0x97c8 <_MotorDriverSelfTest+0x1b2>
	{
		u16VdsThreshold = NVRAM_VDS_THRESHOLD;
	}
	else
	{
		u16VdsThreshold = 200U;
    965a:	72da 00c8 	lod	A, #200
    965e:	520b      	mov	[S-12], A
	}																			/* MMP130919-1 - End */

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    9660:	7000      	lod	A, #0
    9662:	520d      	mov	[S-14], A
    9664:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9666:	1901      	je	0x966a <_MotorDriverSelfTest+0x54>
    9668:	003e      	jmp	0x96e6 <_MotorDriverSelfTest+0xd0>
	{
		int16 i16DriverCurrent = 0;												/* MMP140403-1 */
    966a:	7000      	lod	A, #0
    966c:	5207      	mov	[S-8], A

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestA[u16SelfTestIdx]);		/* MMP130904-1 */
    966e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9672:	b6da fe00 	and	A, #65024
    9676:	7a0d      	lod	Y, [S-14]
    9678:	e2da ac40 	add	Y, #44096
    967c:	66f0      	lod	YL, [Y]
    967e:	5cf6      	usex	Y
    9680:	a6e6      	or	A, Y
    9682:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		MeasurePhaseVoltage( (uint16)c_au16DrvAdcSelfTestA[u16SelfTestIdx>>1]);	/* MMP140403-1/MMP130919-1 - Begin */
    9686:	720d      	lod	A, [S-14]
    9688:	4432      	lsr	A
    968a:	44a2      	asl	A, #2
    968c:	a2da ac30 	add	A, #44080
    9690:	151b      	call	0x90c8 <_MeasurePhaseVoltage>
		if ( (u16SelfTestIdx & 1) == 0 )
    9692:	720d      	lod	A, [S-14]
    9694:	b401      	and	A, #1
    9696:	5205      	mov	[S-6], A
    9698:	1d03      	jne	0x96a0 <_MotorDriverSelfTest+0x8a>
		{
			/* Even-index (0,2,4,6) are phase to ground: Check current too (< 20 mA) */
			MeasureMotorCurrent();
    969a:	150d      	call	0x90b6 <_MeasureMotorCurrent>
			i16DriverCurrent = GetMotorDriverCurrent();
    969c:	14e7      	call	0x906c <_GetMotorDriverCurrent>
    969e:	5207      	mov	[S-8], A
		}
		/* Even-index (0,2,4,6) are phase to ground: Vphase < Vds; Odd-index (1,3,5,7) are phase to supply: Vphase > (Vsup - Vds) */
		if ( (g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO) ||
    96a0:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    96a2:	1d10      	jne	0x96c4 <_MotorDriverSelfTest+0xae>
    96a4:	7205      	lod	A, [S-6]
    96a6:	1d08      	jne	0x96b8 <_MotorDriverSelfTest+0xa2>
    96a8:	72d8 0112 	lod	A, 0x112 <_g_i16PhaseVoltage>
    96ac:	ae0b      	cmp	A, [S-12]
    96ae:	1f0a      	jsg	0x96c4 <_MotorDriverSelfTest+0xae>
    96b0:	7e07      	lod	X, [S-8]
    96b2:	2c14      	cmp	X, #20
    96b4:	1f07      	jsg	0x96c4 <_MotorDriverSelfTest+0xae>
    96b6:	000e      	jmp	0x96d4 <_MotorDriverSelfTest+0xbe>
    96b8:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    96ba:	aa0b      	sub	A, [S-12]
    96bc:	7ad8 0112 	lod	Y, 0x112 <_g_i16PhaseVoltage>
    96c0:	eee2      	cmp	Y, A
    96c2:	1e88      	jsge	0x96d4 <_MotorDriverSelfTest+0xbe>
			(((u16SelfTestIdx & 1) == 0) && ((g_i16PhaseVoltage > (int16)u16VdsThreshold) || (i16DriverCurrent > 20))) ||
			(((u16SelfTestIdx & 1) != 0) && (g_i16PhaseVoltage < (int16)(g_i16MotorVoltage - u16VdsThreshold))) )
		{																		/* MMP130919-1 - End */
			/* Over-current trigger; Phase makes short with supply or Ground */
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    96c4:	6002      	lod	AL, #2
    96c6:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( (uint8) C_ERR_SELFTEST_A);
    96c8:	72da 00ea 	lod	A, #234
    96cc:	162d      	call	0x9328 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_A;//Ban, FET short with ground or supply
    96ce:	60ea      	lod	AL, #-22
    96d0:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			break;
    96d2:	0009      	jmp	0x96e6 <_MotorDriverSelfTest+0xd0>
	{
		u16VdsThreshold = 200U;
	}																			/* MMP130919-1 - End */

	/* Test for FET shortages; Note: Diagnostics configuration will switch off driver at over-current */
	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestA)/sizeof(c_au8DrvCfgSelfTestA[0]))); u16SelfTestIdx++ )
    96d4:	720d      	lod	A, [S-14]
    96d6:	a001      	add	A, #1
    96d8:	520d      	mov	[S-14], A
    96da:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    96dc:	1d04      	jne	0x96e6 <_MotorDriverSelfTest+0xd0>
    96de:	720d      	lod	A, [S-14]
    96e0:	ac07      	cmp	A, #7
    96e2:	1e01      	jug	0x96e6 <_MotorDriverSelfTest+0xd0>
    96e4:	07c2      	jmp	0x966a <_MotorDriverSelfTest+0x54>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    96e6:	7840      	lod	Y, #64
    96e8:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    96ec:	6000      	lod	AL, #0
    96ee:	72e4      	swap	A
    96f0:	5201      	mov	[S-2], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    96f2:	720b      	lod	A, [S-12]
    96f4:	7e01      	lod	X, [S-2]
    96f6:	4821      	mulu	YA, A, Y
    96f8:	4c63      	divu	YA, X
    96fa:	4c63      	divu	YA, X
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    96fc:	7000      	lod	A, #0
    96fe:	520d      	mov	[S-14], A
    9700:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9702:	1901      	je	0x9706 <_MotorDriverSelfTest+0xf0>
    9704:	0061      	jmp	0x97c8 <_MotorDriverSelfTest+0x1b2>
		uint16 u16VphH;
		uint16 u16VphL;
		uint16 u16Vds;
		uint16 u16MotorCoilCurrent;
		register uint16 u16DC;
		if ( u16SelfTestIdx & 0x02 )
    9706:	720d      	lod	A, [S-14]
    9708:	b402      	and	A, #2
    970a:	5203      	mov	[S-4], A
    970c:	1903      	je	0x9714 <_MotorDriverSelfTest+0xfe>
		{
			/* Phase LOW + phase -PWM */
			u16DC = (PWM_REG_PERIOD >> 3);
    970e:	7ada 00ae 	lod	Y, #174
    9712:	0002      	jmp	0x9718 <_MotorDriverSelfTest+0x102>
		}
		else
		{
			/* Phase HIGH + phase PWM */
			u16DC = PWM_REG_PERIOD - (PWM_REG_PERIOD >> 3);						/* Approx. 12.5% */
    9714:	7ada 04c8 	lod	Y, #1224
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
		u16DC = u16DC/2;
    9718:	4436      	lsr	Y
		PWM2_LT = u16DC;														/* Copy the results into the PWM register for phase U */
    971a:	5ad8 2858 	mov	0x2858 <__io__+0x58>, Y
		PWM2_HT = PWM_REG_PERIOD - u16DC;
    971e:	72da 0576 	lod	A, #1398
    9722:	aae6      	sub	A, Y
    9724:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM3_LT = u16DC;														/* Copy the results into the PWM register for phase V */
    9728:	5ad8 2862 	mov	0x2862 <__io__+0x62>, Y
		PWM3_HT = PWM_REG_PERIOD - u16DC;
    972c:	52d8 2864 	mov	0x2864 <__io__+0x64>, A
		PWM4_LT = u16DC;														/* Copy the results into the PWM register for phase W */
    9730:	5ad8 286c 	mov	0x286c <__io__+0x6c>, Y
		PWM4_HT = PWM_REG_PERIOD - u16DC;
    9734:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM5_LT = u16DC;														/* Copy the results into the PWM register for phase T */
    9738:	5ad8 2876 	mov	0x2876 <__io__+0x76>, Y
		PWM5_HT = PWM_REG_PERIOD - u16DC;
    973c:	52d8 2878 	mov	0x2878 <__io__+0x78>, A
		PWM1_LT = u16DC;														/* Master must be modified at last (value is not important) */
    9740:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */

		DRVCFG_CNFG_UVWT( (uint16) c_au8DrvCfgSelfTestB4[u16SelfTestIdx]);
    9744:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9748:	b6da fe00 	and	A, #65024
    974c:	7a0d      	lod	Y, [S-14]
    974e:	e2da ac26 	add	Y, #44070
    9752:	66f0      	lod	YL, [Y]
    9754:	5cf6      	usex	Y
    9756:	a6e6      	or	A, Y
    9758:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		ADC_Stop();																/* clear the ADC control register */
    975c:	82db 8e44 	callf	0x8e44 <_ADC_Stop>
		if ( u16SelfTestIdx & 2 )
    9760:	7203      	lod	A, [S-4]
    9762:	1904      	je	0x976c <_MotorDriverSelfTest+0x156>
		{
			ADC_SBASE = (uint16) tAdcSelfTest4B;								/* Phase = Low */
    9764:	7eda ab32 	lod	X, #43826
    9768:	5e92      	mov	io:0x12 <__dp_noinit_size+0x2>, X
    976a:	0003      	jmp	0x9772 <_MotorDriverSelfTest+0x15c>
		}
		else
		{
			ADC_SBASE = (uint16) tAdcSelfTest4A;								/* Phase = High */
    976c:	72da ab4a 	lod	A, #43850
    9770:	5292      	mov	io:0x12 <__dp_noinit_size+0x2>, A
		}
		ADC_DBASE = (uint16) &adcMotorSelfTest4Ph;
    9772:	7eef      	lod	X, S
    9774:	20dc      	add	X, #-36
    9776:	5e94      	mov	io:0x14 <__dp_noinit_size+0x4>, X
		ADC_CTRL |= (ADC_TRIG_SRC | ADC_SYNC_SOC);								/* Single cycle of conversion is done */
    9778:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    977a:	a6da 0082 	or	A, #130
    977e:	5290      	mov	io:0x10 <__dp_noinit_size>, A
		ADC_CTRL |= ADC_START;													/* Start ADC */
    9780:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    9782:	a401      	or	A, #1
    9784:	5290      	mov	io:0x10 <__dp_noinit_size>, A

		/* This takes about 4 Motor PWM-periods per self-test */
		while (ADC_CTRL & ADC_START) /* lint -e{722} */ ;						/* Wait for ADC result (Time-out?) */
    9786:	7290      	lod	A, io:0x10 <__dp_noinit_size>
    9788:	b401      	and	A, #1
    978a:	1d7d      	jne	0x9786 <_MotorDriverSelfTest+0x170>

		DRVCFG_GND_UVWT();
    978c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9790:	b6da fe00 	and	A, #65024
    9794:	a6da 00aa 	or	A, #170
    9798:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_NO )					/* Over-current ? */
    979c:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    979e:	1901      	je	0x97a2 <_MotorDriverSelfTest+0x18c>
    97a0:	074d      	jmp	0x963c <_MotorDriverSelfTest+0x26>
			SetLastError( C_ERR_SELFTEST_B);
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_B;//Ban, phase shot with other phase
			break;
		}

		if ( u16SelfTestIdx & 2 )
    97a2:	7203      	lod	A, [S-4]
    97a4:	1902      	je	0x97aa <_MotorDriverSelfTest+0x194>
		{
			/* Use tAdcSelfTest4B */
			u16Vsm = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;				/* Current becomes voltage */
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
    97a6:	7211      	lod	A, [S-18]
    97a8:	0001      	jmp	0x97ac <_MotorDriverSelfTest+0x196>
		}
		else
		{
			/* Use tAdcSelfTest4A */
			u16Vsm = adcMotorSelfTest4Ph.FilteredSupplyVoltage;
			u16MotorCoilCurrent = adcMotorSelfTest4Ph.UnfilteredDriverCurrent;
    97aa:	720f      	lod	A, [S-16]
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_E;//Ban, phase resistance is too small
			break;
		}
#endif // _SUPPORT_COIL_RESISTANCE_CHECK
		extern uint16 l_u16CurrentZeroOffset;
		if ( (int16) (u16MotorCoilCurrent - l_u16CurrentZeroOffset) < C_MIN_COIL_CURRENT )
    97ac:	aad8 0138 	sub	A, 0x138 <_l_u16CurrentZeroOffset>
    97b0:	ac09      	cmp	A, #9
    97b2:	1f01      	jsg	0x97b6 <_MotorDriverSelfTest+0x1a0>
    97b4:	074a      	jmp	0x964a <_MotorDriverSelfTest+0x34>
	}

	/* Convert Vds-voltage (10mV units) to ADC-LSB */
	u16VdsThreshold = muldivU16_U16byU16byU16( u16VdsThreshold, C_GVOLTAGE_DIV, EE_GADC);

	for ( u16SelfTestIdx = 0; (g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_NO) && (u16SelfTestIdx < (sizeof(c_au8DrvCfgSelfTestB4)/sizeof(c_au8DrvCfgSelfTestB4[0]))); u16SelfTestIdx++ )
    97b6:	720d      	lod	A, [S-14]
    97b8:	a001      	add	A, #1
    97ba:	520d      	mov	[S-14], A
    97bc:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    97be:	1d04      	jne	0x97c8 <_MotorDriverSelfTest+0x1b2>
    97c0:	720d      	lod	A, [S-14]
    97c2:	ac09      	cmp	A, #9
    97c4:	1e01      	jug	0x97c8 <_MotorDriverSelfTest+0x1b2>
    97c6:	079f      	jmp	0x9706 <_MotorDriverSelfTest+0xf0>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;
			break;
		}
	}	

	DRVCFG_DIS_UVWT();
    97c8:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    97cc:	b6da fe00 	and	A, #65024
    97d0:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase U */
    97d4:	7eda 02bb 	lod	X, #699
    97d8:	5ed8 2858 	mov	0x2858 <__io__+0x58>, X
	PWM3_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase V */
    97dc:	5ed8 2862 	mov	0x2862 <__io__+0x62>, X
	PWM4_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase W */
    97e0:	5ed8 286c 	mov	0x286c <__io__+0x6c>, X
	PWM5_LT = PWM_SCALE_OFFSET;													/* 50% PWM duty cycle for phase T */
    97e4:	5ed8 2876 	mov	0x2876 <__io__+0x76>, X
	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    97e8:	5ed8 284e 	mov	0x284e <__io__+0x4e>, X
	DRVCFG_DIS();																/* MMP140903-1 */
    97ec:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    97f0:	a6da 0100 	or	A, #256
    97f4:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	PWM2_CMP = u16Pwm2Storage;													/* MMP150219-2: Restore PWM2 ADC trigger CMP time */
    97f8:	7209      	lod	A, [S-10]
    97fa:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
    97fe:	5425      	ret	#38

00009800 <_MotorDriverCurrentMeasureInit>:
 * Performance: <10us
 * ****************************************************************************	*/
void MotorDriverCurrentMeasureInit( void)
{
	uint16 u16Count;															/* MMP140331-2 - Begin */
	l_u16StartupDelayInit = 64 * NVRAM_ACCELERATION_POINTS;						/* Calculate the startup-delay, based on acceleration steps */
    9800:	61a2      	lod	AL, dp:0xa2 <__data_size+0x40>
    9802:	b43f      	and	A, #63
    9804:	487a 0040 	muls	Y, A, #64
    9808:	5ad8 0144 	mov	0x144 <_l_u16StartupDelayInit>, Y
	if ( l_u16StartupDelayInit < (2*C_MOVAVG_SZ) )
    980c:	ec7f      	cmp	Y, #127
    980e:	1e03      	jug	0x9816 <_MotorDriverCurrentMeasureInit+0x16>
	{
		l_u16StartupDelayInit = (2*C_MOVAVG_SZ);								/* Minimum of twice the moving-average filter size */
    9810:	72da 0080 	lod	A, #128
    9814:	0007      	jmp	0x9824 <_MotorDriverCurrentMeasureInit+0x24>
	}
	else if ( l_u16StartupDelayInit > NVRAM_STALL_DETECTOR_DELAY )
    9816:	61c4      	lod	AL, dp:0xc4 <__bss_dp_size+0x14>
    9818:	44a2      	asl	A, #2
    981a:	4422      	asl	A
    981c:	b6da 07f8 	and	A, #2040
    9820:	eee2      	cmp	Y, A
    9822:	1a02      	jule	0x9828 <_MotorDriverCurrentMeasureInit+0x28>
	{
		l_u16StartupDelayInit = NVRAM_STALL_DETECTOR_DELAY;						/* Maximum of NVRAM specified */
    9824:	52d8 0144 	mov	0x144 <_l_u16StartupDelayInit>, A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    9828:	72e3      	lod	A, M
	}																			/* MMP140331-2 - End */

	ATOMIC_CODE
    982a:	4407      	mov	R, #0
    982c:	500c      	call	fp0:0x60
    982e:	54f0      	mov	UPr, #0
    9830:	7ad8 0144 	lod	Y, 0x144 <_l_u16StartupDelayInit>
    9834:	5936      	mov	dp:0x36 <_g_u16StartupDelay>, Y
    9836:	7800      	lod	Y, #0
    9838:	5956      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, Y
    983a:	5ad8 02ce 	mov	0x2ce <_l_u16MotorCurrentRawIdx>, Y
    983e:	5954      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, Y
    9840:	5ad8 02d0 	mov	0x2d0 <_l_au16MotorCurrentRaw>, Y
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    9844:	52e3      	mov	M, A
		l_u16MotorCurrentRawIdx = 0;											/* Raw current moving average index */
		g_u16MotorCurrentMovAvgxN = 0;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
    9846:	7ada 02d2 	lod	Y, #722
    984a:	7c3f      	lod	X, #63
		for ( u16Count = 1; u16Count < C_MOVAVG_SZ; u16Count++ )
		{
			*pStallCurrentRaw = 0;
    984c:	7000      	lod	A, #0
    984e:	52d6      	mov	[Y++], A
    9850:	1bfd      	djnz	X, 0x984c <_MotorDriverCurrentMeasureInit+0x4c>
		g_u16MotorCurrentMovAvgxN = 0;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
		for ( u16Count = 1; u16Count < C_MOVAVG_SZ; u16Count++ )
    9852:	5401      	ret

00009854 <_MotorDriverCurrentMeasure>:
 *
 * Measure a average motor current, based on ADC current's
 * Performance: Approximate: 10us @ 20MHz
 * ****************************************************************************	*/
void MotorDriverCurrentMeasure( void)
{
    9854:	5803      	inc	S, #4
#if (C_MOVAVG_SSZ < 6)
	uint16 u16MotorCurrentAcc;
#endif /* (C_MOVAVG_SSZ < 6 ) */
	uint16 u16MicroStepMotorCurrent = GetRawMotorDriverCurrent();
    9856:	82db 903c 	callf	0x903c <_GetRawMotorDriverCurrent>
    985a:	7ee2      	lod	X, A
	//SpiDebugWriteFirst(g_u16HallMicroStepIdx);
	//SpiDebugWriteNext(u16MicroStepMotorCurrent);
#endif /* _DEBUG_SPI */

	/* Moving average (sum) of motor-driver current */
	uint16 *pu16MotorCurrentElement = &l_au16MotorCurrentRaw[l_u16MotorCurrentRawIdx];
    985c:	72d8 02ce 	lod	A, 0x2ce <_l_u16MotorCurrentRawIdx>
    9860:	487a 0002 	muls	Y, A, #2
    9864:	e2da 02d0 	add	Y, #720
    9868:	5a03      	mov	[S-4], Y
	uint16 u16PrevMotorCurrent = *pu16MotorCurrentElement;
    986a:	7af0      	lod	Y, [Y]
    986c:	5a01      	mov	[S-2], Y
	l_u16MotorCurrentRawIdx = (l_u16MotorCurrentRawIdx + 1) & (C_MOVAVG_SZ - 1);
    986e:	a001      	add	A, #1
    9870:	b43f      	and	A, #63
    9872:	52d8 02ce 	mov	0x2ce <_l_u16MotorCurrentRawIdx>, A
	if ( (g_u16StartupDelay != 0) || (u16MicroStepMotorCurrent < (u16PrevMotorCurrent << 1)) )	/* Check for valid motor-driver current (at least smaller than 2x previous current)  */
    9876:	7136      	lod	A, dp:0x36 <_g_u16StartupDelay>
    9878:	1d04      	jne	0x9882 <_MotorDriverCurrentMeasure+0x2e>
    987a:	72e6      	lod	A, Y
    987c:	4422      	asl	A
    987e:	2ee2      	cmp	X, A
    9880:	1c06      	jnc	0x988e <_MotorDriverCurrentMeasure+0x3a>
	{
		g_u16MotorCurrentMovAvgxN -= u16PrevMotorCurrent;						/* Subtract oldest raw motor-driver current */
    9882:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    9884:	aa01      	sub	A, [S-2]
		g_u16MotorCurrentMovAvgxN += u16MicroStepMotorCurrent;					/* Add newest raw motor-driver current */
    9886:	a2ee      	add	A, X
    9888:	5154      	mov	dp:0x54 <_g_u16MotorCurrentMovAvgxN>, A
		*pu16MotorCurrentElement = u16MicroStepMotorCurrent;					/* Overwrite oldest with newest motor-driver current */
    988a:	7a03      	lod	Y, [S-4]
    988c:	5ef0      	mov	[Y], X
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2*C_MOVAVG_SZ))) || (g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || ((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (u16MotorCurrentAcc < g_u16MotorCurrentLPFx64)) )
	{
		g_u16MotorCurrentLPFx64 = u16MotorCurrentAcc;
#endif /* (C_MOVAVG_SSZ < 6 ) */
#if (C_MOVAVG_SSZ == 6 )
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2*C_MOVAVG_SZ))) || (g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || ((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (g_u16MotorCurrentMovAvgxN < g_u16MotorCurrentLPFx64)) )
    988e:	72d8 0144 	lod	A, 0x144 <_l_u16StartupDelayInit>
    9892:	a080      	add	A, #-128
    9894:	ad36      	cmp	A, dp:0x36 <_g_u16StartupDelay>
    9896:	1809      	jc	0x98aa <_MotorDriverCurrentMeasure+0x56>
    9898:	62d8 0149 	lod	AL, 0x149 <_g_u8MotorStartupMode>
    989c:	8c02      	cmp	AL, #2
    989e:	1905      	je	0x98aa <_MotorDriverCurrentMeasure+0x56>
    98a0:	8c01      	cmp	AL, #1
    98a2:	1d05      	jne	0x98ae <_MotorDriverCurrentMeasure+0x5a>
    98a4:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    98a6:	ad56      	cmp	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    98a8:	1c02      	jnc	0x98ae <_MotorDriverCurrentMeasure+0x5a>
	{
		g_u16MotorCurrentLPFx64 = g_u16MotorCurrentMovAvgxN;
    98aa:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    98ac:	000c      	jmp	0x98c6 <_MotorDriverCurrentMeasure+0x72>
#if (MOTOR_MICROSTEPS < 3)
		/* LPF_B: IIR of 0.9921875 (127/128) & 0.0078125 (1/128) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63) >> 7)) + ((g_u16MotorCurrentMovAvgxN + (1 << C_MOVAVG_SSZ)) >> (1 + C_MOVAVG_SSZ));
#else  /* (MOTOR_MICROSTEPS < 3) */
		/* LPF_B: IIR of 0.99609375 (255/256) & 0.00390625 (1/256) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63) >> 8)) + ((g_u16MotorCurrentMovAvgxN + (1 << (1 + C_MOVAVG_SSZ))) >> (2 + C_MOVAVG_SSZ));
    98ae:	7156      	lod	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    98b0:	7ae2      	lod	Y, A
    98b2:	e03f      	add	Y, #63
    98b4:	6400      	lod	YL, #0
    98b6:	7ae8      	swap	Y
    98b8:	aae6      	sub	A, Y
    98ba:	7954      	lod	Y, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    98bc:	e2da 0080 	add	Y, #128
    98c0:	6400      	lod	YL, #0
    98c2:	7ae8      	swap	Y
    98c4:	a2e6      	add	A, Y
    98c6:	5156      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, A
#endif /* (MOTOR_MICROSTEPS < 3) */
	}

	if ( g_u16StartupDelay > 0 )
    98c8:	7136      	lod	A, dp:0x36 <_g_u16StartupDelay>
    98ca:	1902      	je	0x98d0 <_MotorDriverCurrentMeasure+0x7c>
	{
		g_u16StartupDelay--;
    98cc:	a0ff      	add	A, #-1
    98ce:	5136      	mov	dp:0x36 <_g_u16StartupDelay>, A
    98d0:	5405      	ret	#6

000098d2 <_MotorDriver_InitialPwmDutyCycle>:
 * MotorDriver_InitialPwmDutyCycle()
 *
 * Calculate Motor PWM (initial) Duty-cycle, based on current threshold level and speed
 * ****************************************************************************	*/
void MotorDriver_InitialPwmDutyCycle( uint16 u16CurrentLevel, uint16 u16MotorSpeed)
{
    98d2:	5807      	inc	S, #8
    98d4:	7ae2      	lod	Y, A
    98d6:	7e0b      	lod	X, [S-12]
    98d8:	61a5      	lod	AL, dp:0xa5 <__data_size+0x43>
    98da:	4205      	mov	[S-6], AL
    98dc:	6189      	lod	AL, dp:0x89 <__data_size+0x27>
    98de:	4207      	mov	[S-8], AL
	if ( u16MotorSpeed == 0 )														/* MMP140228-1 - Begin */
    98e0:	2c00      	cmp	X, #0
    98e2:	1d08      	jne	0x98f4 <_MotorDriver_InitialPwmDutyCycle+0x22>
	{
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + 2 * C_FETS_RTOT) * u16CurrentLevel);
    98e4:	6205      	lod	AL, [S-6]
    98e6:	5cf2      	usex	A
    98e8:	a002      	add	A, #2
    98ea:	4871      	muls	A, A, Y
    98ec:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 4;
    98ee:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    98f0:	44b2      	lsr	A, #2
    98f2:	0013      	jmp	0x991a <_MotorDriver_InitialPwmDutyCycle+0x48>
	}																				/* MMP140228-1 - End */
	else
	{
		/* Ohmic losses: Ur-losses = (0.5 * R[ohm] * I[mA])/10 [10mV] = (R[ohm] * I[mA])/20 [10mV]
		 * FET losses: Ufet-losses = (Rfet * I[mA])/10 [10mV] = (2 * Rfet * I[mA])/20 [10mV]*/
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2 * C_FETS_RTOT)) * u16CurrentLevel);
    98f4:	6205      	lod	AL, [S-6]
    98f6:	5cf2      	usex	A
    98f8:	a002      	add	A, #2
    98fa:	4871      	muls	A, A, Y
    98fc:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 20;													/* Divided by 20 */
    98fe:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    9900:	4822 cccd 	mulu	YA, A, #52429
    9904:	72e6      	lod	A, Y
    9906:	44b2      	lsr	A, #2
    9908:	44b2      	lsr	A, #2
    990a:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio += (NVRAM_MOTOR_CONSTANT * u16MotorSpeed);				/* BEMF = Kmotor[10mV/RPS] * Speed[RPS] */
    990c:	61a4      	lod	AL, dp:0xa4 <__data_size+0x42>
    990e:	66e0      	lod	YL, AL
    9910:	5cf6      	usex	Y
    9912:	72e6      	lod	A, Y
    9914:	487b      	muls	Y, A, X
    9916:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    9918:	a2e6      	add	A, Y
    991a:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    991c:	794c      	lod	Y, dp:0x4c <_g_u16CorrectionRatio>
    991e:	44a6      	asl	Y, #2
    9920:	4426      	asl	Y
    9922:	6207      	lod	AL, [S-8]
    9924:	5cf2      	usex	A
    9926:	4872 0019 	muls	A, A, #25
    992a:	4432      	lsr	A
    992c:	5205      	mov	[S-6], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    992e:	72da 0aec 	lod	A, #2796
    9932:	7e05      	lod	X, [S-6]
    9934:	4821      	mulu	YA, A, Y
    9936:	4c63      	divu	YA, X
    9938:	4c63      	divu	YA, X
    993a:	5203      	mov	[S-4], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    993c:	52d8 035a 	mov	0x35a <_g_u16PidCtrlRatio>, A
	}
	g_u16PidCtrlRatio =  muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1 + PWM_PRESCALER_N), NVRAM_VSUP_REF);
	g_u16PID_I = g_u16PidCtrlRatio;
    9940:	51c8      	mov	dp:0xc8 <_g_u16PID_I>, A
	if ( g_i16MotorVoltage > 0 )
    9942:	7120      	lod	A, dp:0x20 <_g_i16MotorVoltage>
    9944:	ac00      	cmp	A, #0
    9946:	1b0b      	jsle	0x995e <_MotorDriver_InitialPwmDutyCycle+0x8c>
    9948:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    994a:	44a2      	asl	A, #2
    994c:	4422      	asl	A
    994e:	7d20      	lod	X, dp:0x20 <_g_i16MotorVoltage>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9950:	7ada 0aec 	lod	Y, #2796
    9954:	4821      	mulu	YA, A, Y
    9956:	4c63      	divu	YA, X
    9958:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    995a:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
    995c:	0002      	jmp	0x9962 <_MotorDriver_InitialPwmDutyCycle+0x90>
	{
		g_u16CorrectionRatio = muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3, PWM_REG_PERIOD << (1 + PWM_PRESCALER_N), (uint16) g_i16MotorVoltage);
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    995e:	7e03      	lod	X, [S-4]
    9960:	5d4c      	mov	dp:0x4c <_g_u16CorrectionRatio>, X
	}
	g_i16PID_D = 0;
    9962:	7000      	lod	A, #0
    9964:	52d8 0154 	mov	0x154 <_g_i16PID_D>, A
	g_i16PID_E = 0;
    9968:	52d8 0152 	mov	0x152 <_g_i16PID_E>, A
	g_u16PID_CtrlCounter = 0;													/* Re-start Current-control PID */
    996c:	52d8 0150 	mov	0x150 <_g_u16PID_CtrlCounter>, A
    9970:	5409      	ret	#10

00009972 <_MotorDriver_4PhaseStepper>:
 * Performance: 13.5us @ 28MHz (BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
 *
 * Based on a 32-step c_ai16MicroStepVector4PH-table!!
 * ****************************************************************************	*/
void MotorDriver_4PhaseStepper( void)
{
    9972:	5805      	inc	S, #6
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) */

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND)					/* MMP150515-1 */
	/* EMC CE/RE reduction */
	int16 iPwm1, iPwm2;
	int16 *pi16Vector = (int16 *) &c_ai16MicroStepVector4PH[g_u16MicroStepIdx];
    9974:	714e      	lod	A, dp:0x4e <_g_u16MicroStepIdx>
    9976:	5203      	mov	[S-4], A
    9978:	487a 0002 	muls	Y, A, #2
    997c:	7ee6      	lod	X, Y
    997e:	22da ab86 	add	X, #43910
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    9982:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9984:	7af8      	lod	Y, [X]
    9986:	4831      	muls	YA, A, Y
    9988:	48b3      	asr	YA, #4
    998a:	5a01      	mov	[S-2], Y
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    998c:	5a05      	mov	[S-6], Y
	iPwm1 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	iPwm2 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
#elif (PWM_PRESCALER_N == 0)
	iPwm1 = mulI16_I16byI16Shft4( *pi16Vector, (int16) g_u16CorrectionRatio);	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
    998e:	2020      	add	X, #32
    9990:	7af8      	lod	Y, [X]
    9992:	714c      	lod	A, dp:0x4c <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9994:	4831      	muls	YA, A, Y
    9996:	48b3      	asr	YA, #4
#else
	i16PwmU = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	i16PwmV = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* V */
#endif
	if ( g_u16MicroStepIdx & (2*C_MICROSTEP_PER_FULLSTEP) )
    9998:	7203      	lod	A, [S-4]
    999a:	b420      	and	A, #32
    999c:	1913      	je	0x99c4 <_MotorDriver_4PhaseStepper+0x52>
	{
		/* 3rd and 4th Quadrant (Pwm1) */
		iPwm1 = (PWM_SCALE_OFFSET + iPwm1);
    999e:	7205      	lod	A, [S-6]
    99a0:	a2da 02bb 	add	A, #699
    99a4:	5205      	mov	[S-6], A
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = PWM */
		PWM4_LT = (uint16) iPwm1;
    99a6:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM4_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    99aa:	72da 0576 	lod	A, #1398
    99ae:	aa05      	sub	A, [S-6]
    99b0:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM3_LT = (uint16) iPwm1;
		PWM3_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */

		/* W = LOW */
		PWM2_HT = 0;
    99b4:	7000      	lod	A, #0
    99b6:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM2_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */;
    99ba:	72da 0577 	lod	A, #1399
    99be:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
    99c2:	0012      	jmp	0x99e8 <_MotorDriver_4PhaseStepper+0x76>
	}
	else
	{
		/* 1st and 2nd Quadrant (Pwm1)*/
		/* W = PWM */
		iPwm1 = ((int16) PWM_SCALE_OFFSET - iPwm1);
    99c4:	72da 02bb 	lod	A, #699
    99c8:	aa01      	sub	A, [S-2]
    99ca:	5205      	mov	[S-6], A
		PWM2_LT = (uint16) iPwm1;
    99cc:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
		PWM2_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
    99d0:	72da 0576 	lod	A, #1398
    99d4:	aa05      	sub	A, [S-6]
    99d6:	52d8 285a 	mov	0x285a <__io__+0x5a>, A

#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = LOW */
		PWM4_HT = 0;
    99da:	7000      	lod	A, #0
    99dc:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM4_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
    99e0:	72da 0577 	lod	A, #1399
    99e4:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM3_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}

	{
		uint16 u16Quad = g_u16MicroStepIdx & (3*C_MICROSTEP_PER_FULLSTEP);
    99e8:	714e      	lod	A, dp:0x4e <_g_u16MicroStepIdx>
    99ea:	b430      	and	A, #48
		if ( (u16Quad == 0) || (u16Quad == (3*C_MICROSTEP_PER_FULLSTEP)) )
    99ec:	1902      	je	0x99f2 <_MotorDriver_4PhaseStepper+0x80>
    99ee:	ac30      	cmp	A, #48
    99f0:	1d0f      	jne	0x9a10 <_MotorDriver_4PhaseStepper+0x9e>
		{
			/* 1st and 4th Quadrant (Pwm2) */
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* T = PWM */
			PWM5_HT = (uint16) iPwm2;
    99f2:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    99f6:	72da 0576 	lod	A, #1398
    99fa:	aae6      	sub	A, Y
    99fc:	52d8 2876 	mov	0x2876 <__io__+0x76>, A

			/* V = LOW */
			PWM3_HT = 0;
    9a00:	7800      	lod	Y, #0
    9a02:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = PWM_REG_PERIOD + 1;										/* MMP150603-1 */
    9a06:	72da 0577 	lod	A, #1399
    9a0a:	52d8 2862 	mov	0x2862 <__io__+0x62>, A
    9a0e:	000f      	jmp	0x9a2e <_MotorDriver_4PhaseStepper+0xbc>
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
		}
		else
		{
			/* 3rd Quadrant (Pwm2) */
			iPwm2 = (0 - iPwm2);
    9a10:	5cc6      	neg	Y
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* V = PWM */
			PWM3_HT = (uint16) iPwm2;
    9a12:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16) (PWM_REG_PERIOD - iPwm2);
    9a16:	72da 0576 	lod	A, #1398
    9a1a:	aae6      	sub	A, Y
    9a1c:	52d8 2862 	mov	0x2862 <__io__+0x62>, A

			/* T = LOW */
			PWM5_HT = 0;
    9a20:	7800      	lod	Y, #0
    9a22:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = PWM_REG_PERIOD + 1;										/* MMP150603-1 */
    9a26:	72da 0577 	lod	A, #1399
    9a2a:	52d8 2876 	mov	0x2876 <__io__+0x76>, A
		PWM4_LT = (uint16) (0 - iPwm);						/* U = PWM */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */

	PWM1_LT = PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    9a2e:	7ada 02bb 	lod	Y, #699
    9a32:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
    9a36:	5407      	ret	#8

00009a38 <_MotorDriverStart>:
 * MotorDriverStart()
 *
 * Start Motor Driver
 * ****************************************************************************	*/
void MotorDriverStart( void)
{
    9a38:	5801      	inc	S, #2
	if ( g_e8ErrorElectric == (uint8) C_ERR_ELECTRIC_PERM )						/* Don't start motor in case of permanent electric failure */
    9a3a:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9a3c:	8c02      	cmp	AL, #2
    9a3e:	1d01      	jne	0x9a42 <_MotorDriverStart+0xa>
    9a40:	0099      	jmp	0x9b74 <_MotorDriverStart+0x13c>
	}

#if USE_MULTI_PURPOSE_BUFFER
	/* Fill multi-purpose buffer with acceleration-data */
	{
		l_u16SpeedRPM = NVRAM_MIN_SPEED;
    9a42:	719e      	lod	A, dp:0x9e <__data_size+0x3c>
    9a44:	52d8 0350 	mov	0x350 <_l_u16SpeedRPM>, A
		l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    9a48:	72d8 02aa 	lod	A, 0x2aa <_g_u16MotorMicroStepsPerMechRotation>
    9a4c:	52df      	push	A
    9a4e:	4ce2 2c40 	mov	YA, #105000000
    9a52:	0642 
    9a54:	82db 6c3a 	callf	0x6c3a <_divU32_U32byU16>
    9a58:	52d8 0352 	mov	0x352 <_l_u32Temp>, A
    9a5c:	5ad8 0354 	mov	0x354 <_l_u32Temp+0x2>, Y
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9a60:	5c01      	dec	S, #2
    9a62:	7ed8 0350 	lod	X, 0x350 <_l_u16SpeedRPM>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9a66:	4c63      	divu	YA, X
    9a68:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9a6a:	a0ff      	add	A, #-1
    9a6c:	52d8 0356 	mov	0x356 <_l_u16LowSpeedPeriod>, A
		l_u16LowSpeedPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;
	}
#endif /* USE_MULTI_PURPOSE_BUFFER */

	if ( g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT )
    9a70:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9a72:	b402      	and	A, #2
    9a74:	1d01      	jne	0x9a78 <_MotorDriverStart+0x40>
    9a76:	0030      	jmp	0x9ad8 <_MotorDriverStart+0xa0>
	{
		if ( (g_u16MotorRewindSteps != 0) &&									/* MMP140331-1 */
    9a78:	7ed8 02ac 	lod	X, 0x2ac <_g_u16MotorRewindSteps>
    9a7c:	1924      	je	0x9ac6 <_MotorDriverStart+0x8e>
    9a7e:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9a80:	7ae2      	lod	Y, A
    9a82:	f401      	and	Y, #1
    9a84:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9a86:	4201      	mov	[S-2], AL
    9a88:	5cf2      	usex	A
    9a8a:	eee2      	cmp	Y, A
    9a8c:	1903      	je	0x9a94 <_MotorDriverStart+0x5c>
    9a8e:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9a90:	b404      	and	A, #4
    9a92:	1919      	je	0x9ac6 <_MotorDriverStart+0x8e>
			(((g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == g_e8MotorDirectionCCW) || (g_u8RewindFlags & C_REWIND_DIRECTION_AUTO)) )
		{
			/* Start rewind-function, with "rewinding" */
			g_u8RewindFlags = (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND);		/* Start rewind-process (MMP140331-1) */
    9a94:	6028      	lod	AL, #40
    9a96:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
			g_u16TargetPositionRewind = g_u16TargetPosition;
    9a98:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    9a9a:	52d8 015c 	mov	0x15c <__data_end>, A
    9a9e:	79ee      	lod	Y, dp:0xee <_g_u16ActualPosition>
			if ( g_e8MotorDirectionCCW )
    9aa0:	6201      	lod	AL, [S-2]
    9aa2:	1909      	je	0x9ab6 <_MotorDriverStart+0x7e>
			{
				if ( g_u16ActualPosition <= (uint16) (C_MAX_POS - g_u16MotorRewindSteps) )
    9aa4:	70fe      	lod	A, #-2
    9aa6:	aaee      	sub	A, X
    9aa8:	eee2      	cmp	Y, A
    9aaa:	1e14      	jug	0x9ad4 <_MotorDriverStart+0x9c>
				{
					g_u16TargetPosition = g_u16ActualPosition + g_u16MotorRewindSteps;
    9aac:	72e6      	lod	A, Y
    9aae:	a2ee      	add	A, X
    9ab0:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = FALSE;								/* MMP140331-3 */
    9ab2:	6000      	lod	AL, #0
    9ab4:	0006      	jmp	0x9ac2 <_MotorDriverStart+0x8a>
					g_u8RewindFlags = 0;										/* No rewind possible */
				}
			}
			else
			{
				if ( g_u16ActualPosition >= g_u16MotorRewindSteps )
    9ab6:	eeee      	cmp	Y, X
    9ab8:	180d      	jc	0x9ad4 <_MotorDriverStart+0x9c>
				{
					g_u16TargetPosition = g_u16ActualPosition - g_u16MotorRewindSteps;
    9aba:	72e6      	lod	A, Y
    9abc:	aaee      	sub	A, X
    9abe:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
					g_e8MotorDirectionCCW = TRUE;								/* MMP140331-3 */
    9ac0:	6001      	lod	AL, #1
    9ac2:	412a      	mov	dp:0x2a <_g_e8MotorDirectionCCW>, AL
    9ac4:	0009      	jmp	0x9ad8 <_MotorDriverStart+0xa0>
				{
					g_u8RewindFlags = 0;										/* No rewind possible */
				}
			}
		}
		else if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != g_e8MotorDirectionCCW ) /* MMP140331-1 - Begin */
    9ac6:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9ac8:	7ae2      	lod	Y, A
    9aca:	f401      	and	Y, #1
    9acc:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9ace:	5cf2      	usex	A
    9ad0:	eee2      	cmp	Y, A
    9ad2:	1902      	je	0x9ad8 <_MotorDriverStart+0xa0>
		{
			g_u8RewindFlags = 0;												/* Clear previous detected stall flags */
    9ad4:	6000      	lod	AL, #0
    9ad6:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
		}																		/* MMP140331-1 - End */
	}

	g_u16ActuatorActPos = g_u16ActualPosition;
    9ad8:	71ee      	lod	A, dp:0xee <_g_u16ActualPosition>
    9ada:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
	g_u16ActuatorTgtPos = g_u16TargetPosition;
    9adc:	71f0      	lod	A, dp:0xf0 <_g_u16TargetPosition>
    9ade:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
	//g_u8StallOcc = FALSE; TODO,Ban
	//g_u8MechError = FALSE;

	/* Clear motor-driver current measurement */
	MotorDriverCurrentMeasureInit();
    9ae0:	168f      	call	0x9800 <_MotorDriverCurrentMeasureInit>
#if _DEBUG_MOTOR_CURRENT_FLT
	l_u16MotorCurrIdx = 0;
#endif /* _DEBUG_MOTOR_CURRENT_FLT */

	g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;								/* Start-up in Acceleration stepper mode */
    9ae2:	6001      	lod	AL, #1
    9ae4:	42d8 0149 	mov	0x149 <_g_u8MotorStartupMode>, AL
	/* (MMP140331-2) g_u16StartupDelay = NVRAM_STALL_DETECTOR_DELAY; */
	MotorStallInitA();
    9ae8:	126f      	call	0x9fc8 <_MotorStallInitA>
#endif /* _SUPPORT_STALLDET_H */

#if _DEBUG_VOLTAGE_COMPENSATION
	u16MotorVoltIdx = 0;
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	l_u16CoilZeroCurrCountA = 0;
    9aea:	7000      	lod	A, #0
    9aec:	52d8 0142 	mov	0x142 <_l_u16CoilZeroCurrCountA>, A
	l_u16CoilZeroCurrCountB = 0;
    9af0:	52d8 0140 	mov	0x140 <_l_u16CoilZeroCurrCountB>, A
	l_u16CoilCurrentStartDelay = C_COIL_CURRENT_START_DELAY;
    9af4:	72da 0080 	lod	A, #128
    9af8:	52d8 013e 	mov	0x13e <_l_u16CoilCurrentStartDelay>, A

	/* Connect drivers */
	/* Stepper 4-phase/32-steps */

	{
		MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_au16MotorSpeedRPS[1]);	/* MMP140822-1 - Begin */
    9afc:	72d8 02c0 	lod	A, 0x2c0 <_g_au16MotorSpeedRPS+0x2>
    9b00:	52df      	push	A
    9b02:	72d8 035c 	lod	A, 0x35c <_g_u16PidRunningThreshold>
    9b06:	16e5      	call	0x98d2 <_MotorDriver_InitialPwmDutyCycle>
	}
	MotorDriver_4PhaseStepper();
    9b08:	1734      	call	0x9972 <_MotorDriver_4PhaseStepper>
#if (_SUPPORT_PWM_DC_RAMPUP == FALSE)											/* MMP140903-2 - Begin */
	if ( g_u16MotorSpeedRPS > g_au16MotorSpeedRPS[1] )
    9b0a:	72d8 02a6 	lod	A, 0x2a6 <_g_u16MotorSpeedRPS>
    9b0e:	5c01      	dec	S, #2
    9b10:	aed8 02c0 	cmp	A, 0x2c0 <_g_au16MotorSpeedRPS+0x2>
    9b14:	1a05      	jule	0x9b20 <_MotorDriverStart+0xe8>
	{
		MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_u16MotorSpeedRPS);
    9b16:	52df      	push	A
    9b18:	72d8 035c 	lod	A, 0x35c <_g_u16PidRunningThreshold>
    9b1c:	16da      	call	0x98d2 <_MotorDriver_InitialPwmDutyCycle>
    9b1e:	5c01      	dec	S, #2
	}																			/* MMP140822-1 - End */
#endif /* (_SUPPORT_PWM_DC_RAMPUP == FALSE) */									/* MMP140903-2 - End */
	DRVCFG_PWM_UVWT();															/* Enable the driver and the PWM phase W, V, U and T */
    9b20:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9b24:	b6da fe00 	and	A, #65024
    9b28:	a455      	or	A, #85
    9b2a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	g_u8MotorHoldingCurrState = FALSE;
    9b2e:	6000      	lod	AL, #0
    9b30:	42d8 0148 	mov	0x148 <_g_u8MotorHoldingCurrState>, AL

	/* Setup ADC for Motor Current/Voltage measurements */
#if _SUPPORT_PHASE_SHORT_DET
	ADC_Start( 0);
#else  /* _SUPPORT_PHASE_SHORT_DET */
	ADC_Start();
    9b34:	82db 8ec2 	callf	0x8ec2 <_ADC_Start>
#endif /* _SUPPORT_PHASE_SHORT_DET */

	l_u8VTIdx = 0;
    9b38:	6000      	lod	AL, #0
    9b3a:	4134      	mov	dp:0x34 <_l_u8VTIdx>, AL
	if ( g_u8MotorStartupMode == (uint8) MSM_STEPPER_A )
    9b3c:	62d8 0149 	lod	AL, 0x149 <_g_u8MotorStartupMode>
    9b40:	8c01      	cmp	AL, #1
    9b42:	1d08      	jne	0x9b54 <_MotorDriverStart+0x11c>
	{
		if ( g_u16TargetCommutTimerPeriod < l_u16LowSpeedPeriod )
    9b44:	7952      	lod	Y, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    9b46:	72d8 0356 	lod	A, 0x356 <_l_u16LowSpeedPeriod>
    9b4a:	eee2      	cmp	Y, A
    9b4c:	1c02      	jnc	0x9b52 <_MotorDriverStart+0x11a>
		{
			/* Target speed too fast for motor to start-up with */
			g_u16CommutTimerPeriod = l_u16LowSpeedPeriod;						/* Initial start-up speed */
    9b4e:	5150      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, A
    9b50:	0001      	jmp	0x9b54 <_MotorDriverStart+0x11c>
		}
		else
		{
			/* Target speed is slower than maximum motor start-up speed */
			g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9b52:	5950      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, Y
		}
	}
	TMR1_REGB = g_u16CommutTimerPeriod;
    9b54:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    9b56:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
	TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;									/* Start Timer mode 0 */
    9b58:	72da 4003 	lod	A, #16387
    9b5c:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
	g_e8MotorStatusMode = (uint8) C_MOTOR_STATUS_RUNNING;
    9b5e:	6001      	lod	AL, #1
    9b60:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
	g_u8MotorStopDelay = 0;
    9b62:	6000      	lod	AL, #0
    9b64:	4135      	mov	dp:0x35 <_g_u8MotorStopDelay>, AL

	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) C_REWIND_ACTIVE )
    9b66:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9b68:	b428      	and	A, #40
    9b6a:	ac08      	cmp	A, #8
    9b6c:	1d03      	jne	0x9b74 <_MotorDriverStart+0x13c>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_ACTIVE;							/* Rewind-function is finished */
    9b6e:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9b70:	94f7      	and	AL, #-9
    9b72:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
    9b74:	5403      	ret	#4

00009b76 <_MotorDriverStop>:
 *						C_STOP_EMERGENCY : Immediate stop (without ramp-down) + delay
 *
 * Stop Motor Driver
 * ****************************************************************************	*/
void MotorDriverStop( uint16 u16Immediate)
{
    9b76:	5803      	inc	S, #4
    9b78:	5203      	mov	[S-4], A
	if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) != (uint8) C_MOTOR_STATUS_STOP )
    9b7a:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9b7c:	b47f      	and	A, #127
    9b7e:	1d01      	jne	0x9b82 <_MotorDriverStop+0xc>
    9b80:	0045      	jmp	0x9c0c <_MotorDriverStop+0x96>
	{
		/* Not STOP status */
		if ( (u16Immediate == (uint16) C_STOP_RAMPDOWN) && (l_u8VTIdx > 1) ) /*lint !e845 */	/* MMP150922-1 */
    9b82:	7203      	lod	A, [S-4]
    9b84:	1901      	je	0x9b88 <_MotorDriverStop+0x12>
    9b86:	0034      	jmp	0x9bf0 <_MotorDriverStop+0x7a>
    9b88:	6134      	lod	AL, dp:0x34 <_l_u8VTIdx>
    9b8a:	4201      	mov	[S-2], AL
    9b8c:	8c01      	cmp	AL, #1
    9b8e:	1e01      	jug	0x9b92 <_MotorDriverStop+0x1c>
    9b90:	003a      	jmp	0x9c06 <_MotorDriverStop+0x90>
		{
			TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;							/* Start timer mode 0 */
    9b92:	72da 4003 	lod	A, #16387
    9b96:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A

			/* Request to ramp-down */
			if ( (g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOPPING )
    9b98:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9b9a:	b47f      	and	A, #127
    9b9c:	ac09      	cmp	A, #9
    9b9e:	1d02      	jne	0x9ba4 <_MotorDriverStop+0x2e>
			{
				/* Already stopping */
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;					/* Motor status change to STOP soon */
    9ba0:	6014      	lod	AL, #20
    9ba2:	0023      	jmp	0x9bea <_MotorDriverStop+0x74>
				return;
			}

			/* Set TargetPos near CurrentPos, including ramp-down */
			{
				if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    9ba4:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9ba6:	79f8      	lod	Y, dp:0xf8 <_g_u16ActuatorTgtPos>
    9ba8:	aee6      	cmp	A, Y
    9baa:	1a0d      	jule	0x9bc6 <_MotorDriverStop+0x50>
				{
					uint32 u32DeltaPos = g_u16ActuatorActPos - g_u16ActuatorTgtPos;
    9bac:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9bae:	aae6      	sub	A, Y
    9bb0:	4cc8      	movu	D, A
					if ( u32DeltaPos > l_u8VTIdx )
    9bb2:	6201      	lod	AL, [S-2]
    9bb4:	5cf2      	usex	A
    9bb6:	4cf2      	usex	YA
    9bb8:	4c90      	cmp	D, YA
    9bba:	1a12      	jule	0x9be0 <_MotorDriverStop+0x6a>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos - l_u8VTIdx;
    9bbc:	6601      	lod	YL, [S-2]
    9bbe:	5cf6      	usex	Y
    9bc0:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9bc2:	aae6      	sub	A, Y
    9bc4:	000c      	jmp	0x9bde <_MotorDriverStop+0x68>
					}
				}
				else
				{
					uint32 u32DeltaPos = g_u16ActuatorTgtPos - g_u16ActuatorActPos;
    9bc6:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9bc8:	eae2      	sub	Y, A
    9bca:	4cc9      	movu	D, Y
					if ( u32DeltaPos > l_u8VTIdx )
    9bcc:	6201      	lod	AL, [S-2]
    9bce:	5cf2      	usex	A
    9bd0:	4cf2      	usex	YA
    9bd2:	4c90      	cmp	D, YA
    9bd4:	1a05      	jule	0x9be0 <_MotorDriverStop+0x6a>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos + l_u8VTIdx;
    9bd6:	6601      	lod	YL, [S-2]
    9bd8:	5cf6      	usex	Y
    9bda:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9bdc:	a2e6      	add	A, Y
    9bde:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
					}
				}
			}

			g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOPPING);
    9be0:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9be2:	9480      	and	AL, #-128
    9be4:	8409      	or	AL, #9
    9be6:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;						/* Motor status change to STOP when ramp-down is finished */
    9be8:	6028      	lod	AL, #40
    9bea:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
			return;
    9bee:	5405      	ret	#6
		}
		else if ( u16Immediate == (uint16) C_STOP_EMERGENCY )
    9bf0:	7203      	lod	A, [S-4]
    9bf2:	ac02      	cmp	A, #2
    9bf4:	1d08      	jne	0x9c06 <_MotorDriverStop+0x90>
		{
			g_u8MotorStartDelay = (uint8) C_PI_TICKS_10MS;						/* Wait 10 (up to 20 ms) before continue */
    9bf6:	6014      	lod	AL, #20
    9bf8:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
			if ( g_u8MotorStatusSpeed > (uint8) C_MOTOR_SPEED_MID )
    9bfc:	611e      	lod	AL, dp:0x1e <__ramfunc_size>
    9bfe:	8c03      	cmp	AL, #3
    9c00:	1a05      	jule	0x9c0c <_MotorDriverStop+0x96>
			{
				g_u8MotorStartDelay = (uint8) C_PI_TICKS_20MS;
    9c02:	6028      	lod	AL, #40
    9c04:	0001      	jmp	0x9c08 <_MotorDriverStop+0x92>
			}
		}
		else
		{
			g_u8MotorStartDelay = 0;
    9c06:	6000      	lod	AL, #0
    9c08:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
		}
	}

	/* Re-stall code */
	if ( (g_u8StallOcc != FALSE) && ((g_u8RewindFlags & (uint8) C_REWIND_ACTIVE) == 0) )
    9c0c:	6128      	lod	AL, dp:0x28 <_g_u8StallOcc>
    9c0e:	1d01      	jne	0x9c12 <_MotorDriverStop+0x9c>
    9c10:	002d      	jmp	0x9c6c <_MotorDriverStop+0xf6>
    9c12:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c14:	b408      	and	A, #8
    9c16:	1d2a      	jne	0x9c6c <_MotorDriverStop+0xf6>
	{
		/* 'Restore' actual-position in case of re-stall without rewind; MMP140331-4 - Begin */
		if ( (NVRAM_REWIND_STEPS == 0) && ((g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT) != 0) )
    9c18:	61c0      	lod	AL, dp:0xc0 <__bss_dp_size+0x10>
    9c1a:	1d1d      	jne	0x9c56 <_MotorDriverStop+0xe0>
    9c1c:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c1e:	b402      	and	A, #2
    9c20:	191a      	je	0x9c56 <_MotorDriverStop+0xe0>
		{
			/* Stall detected before (no rewind support) */
			if ( g_e8MotorDirectionCCW )
    9c22:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9c24:	1908      	je	0x9c36 <_MotorDriverStop+0xc0>
			{
				if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) != 0 )
    9c26:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c28:	b401      	and	A, #1
    9c2a:	1915      	je	0x9c56 <_MotorDriverStop+0xe0>
				{
					/* Stall in same direction; 'Restore' actual-position */
					g_u16ActuatorActPos += (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET));		/* MMP140428-1 */
    9c2c:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9c2e:	a2d8 0144 	add	A, 0x144 <_l_u16StartupDelayInit>
    9c32:	a020      	add	A, #32
    9c34:	000f      	jmp	0x9c54 <_MotorDriverStop+0xde>
				}
			}
			else
			{
				if ( (g_u8RewindFlags & (uint8) C_REWIND_DIRECTION_CCW) == 0 )
    9c36:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c38:	b401      	and	A, #1
    9c3a:	1d0d      	jne	0x9c56 <_MotorDriverStop+0xe0>
				{
					/* Stall in same direction; 'Restore' actual-position */
					if ( g_u16ActuatorActPos > (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET)) )	/* MMP140428-1 */
    9c3c:	7ed8 0144 	lod	X, 0x144 <_l_u16StartupDelayInit>
    9c40:	7aee      	lod	Y, X
    9c42:	e020      	add	Y, #32
    9c44:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9c46:	aee6      	cmp	A, Y
    9c48:	1a04      	jule	0x9c52 <_MotorDriverStop+0xdc>
					{
						g_u16ActuatorActPos -= (l_u16StartupDelayInit + (C_MICROSTEP_PER_FULLSTEP << NVRAM_STALL_O_OFFSET));	/* MMP140428-1 */
    9c4a:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9c4c:	aaee      	sub	A, X
    9c4e:	a0e0      	add	A, #-32
    9c50:	0001      	jmp	0x9c54 <_MotorDriverStop+0xde>
					}
					else
					{
						g_u16ActuatorActPos = 0;
    9c52:	7000      	lod	A, #0
    9c54:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
				}
			}
		}																		/* MMP140331-4 - End */

		/* Set re-wind active */
		g_u8RewindFlags |= (uint8) C_REWIND_STALL_DETECT;
    9c56:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c58:	8402      	or	AL, #2
    9c5a:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
		if ( g_e8MotorDirectionCCW )
    9c5c:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9c5e:	1903      	je	0x9c66 <_MotorDriverStop+0xf0>
		{
			g_u8RewindFlags |= (uint8) C_REWIND_DIRECTION_CCW;
    9c60:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c62:	8401      	or	AL, #1
    9c64:	0002      	jmp	0x9c6a <_MotorDriverStop+0xf4>
		}
		else
		{
			g_u8RewindFlags &= (uint8) ~C_REWIND_DIRECTION_CCW;
    9c66:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9c68:	94fe      	and	AL, #-2
    9c6a:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
		}
	}

	/* First stop ADC, before stopping motor (trigger-event) */
	ADC_Stop();
    9c6c:	82db 8e44 	callf	0x8e44 <_ADC_Stop>
	g_u8MotorStartupMode = (uint8) MSM_STOP;									/* Stop mode */
    9c70:	6000      	lod	AL, #0
    9c72:	42d8 0149 	mov	0x149 <_g_u8MotorStartupMode>, AL
	g_e8MotorStatusMode = ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_DEGRADED) | (uint8) C_MOTOR_STATUS_STOP);
    9c76:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9c78:	9480      	and	AL, #-128
    9c7a:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
	if ( bistResetInfo != C_CHIP_STATE_WATCHDOG_RESET )
    9c7c:	72d8 0372 	lod	A, 0x372 <_bistResetInfo>
    9c80:	aeda 5c92 	cmp	A, #23698
    9c84:	1902      	je	0x9c8a <_MotorDriverStop+0x114>
	{
		/* make target-position same as actual position, except in case of WD-reset */
		g_u16ActuatorTgtPos = g_u16ActuatorActPos;							/* Stop: Target = Actual */
    9c86:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9c88:	51f8      	mov	dp:0xf8 <_g_u16ActuatorTgtPos>, A
	}
	g_u16ActualPosition = g_u16ActuatorActPos;
    9c8a:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9c8c:	51ee      	mov	dp:0xee <_g_u16ActualPosition>, A
	g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_STOP;							/* Stop */
    9c8e:	6000      	lod	AL, #0
    9c90:	411e      	mov	dp:0x1e <__ramfunc_size>, AL
		}
	}
#endif /* (LINPROT == LIN2J_VALVE_GM) */


	if ( (g_u8MotorHoldingCurrEna != FALSE) &&									/* Holding mode enabled */
    9c92:	61ed      	lod	AL, dp:0xed <_g_u8MotorHoldingCurrEna>
    9c94:	1922      	je	0x9cda <_MotorDriverStop+0x164>
    9c96:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9c98:	8c02      	cmp	AL, #2
    9c9a:	191f      	je	0x9cda <_MotorDriverStop+0x164>
    9c9c:	612b      	lod	AL, dp:0x2b <_g_e8ErrorVoltage>
    9c9e:	1d1d      	jne	0x9cda <_MotorDriverStop+0x164>
    9ca0:	7203      	lod	A, [S-4]
    9ca2:	ac03      	cmp	A, #3
    9ca4:	191a      	je	0x9cda <_MotorDriverStop+0x164>
		(g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM) && (g_e8ErrorVoltage == (uint8) C_ERR_VOLTAGE_IN_RANGE) && (u16Immediate != (uint16) C_STOP_SLEEP) ) /*lint !e845 */
	{
		/* Keep Motor driver active with a specified amount of current (unless permanent electric error) */
		MotorDriver_InitialPwmDutyCycle( g_u16PidHoldingThreshold, 0);
    9ca6:	54ca 0000 	pushw	#0
    9caa:	72d8 0360 	lod	A, 0x360 <_g_u16PidHoldingThreshold>
    9cae:	1611      	call	0x98d2 <_MotorDriver_InitialPwmDutyCycle>
	
		MotorDriver_4PhaseStepper();
    9cb0:	1660      	call	0x9972 <_MotorDriver_4PhaseStepper>
		DRVCFG_PWM_UVWT();														/* Enable the driver and the PWM phase W, V and U */
    9cb2:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9cb6:	b6da fe00 	and	A, #65024
    9cba:	a455      	or	A, #85
    9cbc:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		g_u8MotorHoldingCurrState = TRUE;
    9cc0:	6001      	lod	AL, #1
    9cc2:	42d8 0148 	mov	0x148 <_g_u8MotorHoldingCurrState>, AL

		g_u16MotorCurrentLPFx64 = (g_u16PidHoldingThreshold << 6);				/* Low-pass Filtered motor-current (x 64) */
    9cc6:	72d8 0360 	lod	A, 0x360 <_g_u16PidHoldingThreshold>
    9cca:	44a2      	asl	A, #2
    9ccc:	44a2      	asl	A, #2
    9cce:	44a2      	asl	A, #2
    9cd0:	5156      	mov	dp:0x56 <_g_u16MotorCurrentLPFx64>, A
#if _SUPPORT_PHASE_SHORT_DET
		ADC_Start( 0);															/* Start measuring motor current */
#else  /* _SUPPORT_PHASE_SHORT_DET */
		ADC_Start();
    9cd2:	82db 8ec2 	callf	0x8ec2 <_ADC_Start>
    9cd6:	5c01      	dec	S, #2
    9cd8:	0025      	jmp	0x9d24 <_MotorDriverStop+0x1ae>
#endif /* _SUPPORT_PHASE_SHORT_DET */
	}
	else
	{
		/* Disconnect drivers */
		if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_PERM )					/* MMP130919-1 - Begin */
    9cda:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9cdc:	8c02      	cmp	AL, #2
    9cde:	1911      	je	0x9d02 <_MotorDriverStop+0x18c>
		{
			if ( g_e8ErrorElectric != (uint8) C_ERR_ELECTRIC_YES )				/* MMP150217-1 - Begin */
    9ce0:	612d      	lod	AL, dp:0x2d <_g_e8ErrorElectric>
    9ce2:	8c01      	cmp	AL, #1
    9ce4:	1907      	je	0x9cf4 <_MotorDriverStop+0x17e>
			{
				DRVCFG_GND_UVWT();												/* Make Low-side active, for a short time (recycle current) */
    9ce6:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9cea:	b6da fe00 	and	A, #65024
    9cee:	a6da 00aa 	or	A, #170
    9cf2:	0011      	jmp	0x9d16 <_MotorDriverStop+0x1a0>
			}
			else
			{
				DRVCFG_VSUP_UVWT();												/* Make High-side active, for a short time (recycle current) */
    9cf4:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9cf8:	b6da fe00 	and	A, #65024
    9cfc:	a6da 00ff 	or	A, #255
    9d00:	000a      	jmp	0x9d16 <_MotorDriverStop+0x1a0>
			}																	/* MMP150217-1 - End */
		}
		else
		{
			/* In case of a permanent error, don't connect drivers anymore */
			DRVCFG_DIS_UVWT();
    9d02:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9d06:	b6da fe00 	and	A, #65024
    9d0a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();														/* MMP140903-1 */
    9d0e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    9d12:	a6da 0100 	or	A, #256
    9d16:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}																		/* MMP130919-1 - End */
		g_u8MotorHoldingCurrState = FALSE;
    9d1a:	6000      	lod	AL, #0
    9d1c:	42d8 0148 	mov	0x148 <_g_u8MotorHoldingCurrState>, AL

		g_u8MotorStopDelay = 200;												/* 200x 0.5ms = 100ms delay before driver is disconnected */
    9d20:	60c8      	lod	AL, #-56
    9d22:	4135      	mov	dp:0x35 <_g_u8MotorStopDelay>, AL
	}

	TMR1_CTRL &= ~TMRx_START;													/* Stop "commutation timer" */
    9d24:	72aa      	lod	A, io:0x2a <_g_e8MotorDirectionCCW>
    9d26:	b4fd      	and	A, #-3
    9d28:	52aa      	mov	io:0x2a <_g_e8MotorDirectionCCW>, A
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially pending) Timer1 second level interrupts (T1_INT4) */
    9d2a:	7040      	lod	A, #64
    9d2c:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
	PEND = CLR_EXT0_IT;															/* ... and first level interrupt */
    9d30:	72da 0100 	lod	A, #256
    9d34:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
#if USE_MULTI_PURPOSE_BUFFER
	g_MPBuf.u8Usage = (uint8) C_MP_BUF_FREE;									/* Motor-stopped: Multi-purpose buffer is free for others */
    9d38:	6000      	lod	AL, #0
    9d3a:	42d8 015f 	mov	0x15f <_g_MPBuf+0x1>, AL
#endif /* USE_MULTI_PURPOSE_BUFFER */

	/* Re-stall code */
	if ( (g_u8RewindFlags & (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND)) == (uint8) (C_REWIND_ACTIVE | C_REWIND_REWIND) )
    9d3e:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9d40:	b428      	and	A, #40
    9d42:	ac28      	cmp	A, #40
    9d44:	1d19      	jne	0x9d78 <_MotorDriverStop+0x202>
	{
		g_u8RewindFlags &= (uint8) ~C_REWIND_REWIND;							/* Rewinding of the Rewind-function is finished */
    9d46:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9d48:	94df      	and	AL, #-33
    9d4a:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
		g_u16TargetPosition = g_u16TargetPositionRewind;
    9d4c:	72d8 015c 	lod	A, 0x15c <__data_end>
    9d50:	51f0      	mov	dp:0xf0 <_g_u16TargetPosition>, A
		g_u8MotorStopDelay = 0;													/* Cancel stop delay */
    9d52:	6000      	lod	AL, #0
    9d54:	4135      	mov	dp:0x35 <_g_u8MotorStopDelay>, AL
		if ( g_e8MotorRequest == (uint8) C_MOTOR_REQUEST_CALIBRATION )
    9d56:	652e      	lod	YL, dp:0x2e <_g_e8MotorRequest>
    9d58:	62e8      	lod	AL, YL
    9d5a:	8c05      	cmp	AL, #5
    9d5c:	1d0a      	jne	0x9d72 <_MotorDriverStop+0x1fc>
		{
			if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_HI_ENDPOS )
    9d5e:	611d      	lod	AL, dp:0x1d <_g_e8CalibrationStep>
    9d60:	8c03      	cmp	AL, #3
    9d62:	1d03      	jne	0x9d6a <_MotorDriverStop+0x1f4>
				g_e8CalibrationStep = C_CALIB_SETUP_HI_ENDPOS;
    9d64:	6002      	lod	AL, #2
    9d66:	411d      	mov	dp:0x1d <_g_e8CalibrationStep>, AL
    9d68:	5405      	ret	#6
			else if ( g_e8CalibrationStep == (uint8) C_CALIB_CHECK_LO_ENDPOS )
    9d6a:	8c06      	cmp	AL, #6
    9d6c:	1d09      	jne	0x9d80 <_MotorDriverStop+0x20a>
				g_e8CalibrationStep = C_CALIB_SETUP_LO_ENDPOS;
    9d6e:	451d      	mov	dp:0x1d <_g_e8CalibrationStep>, YL
    9d70:	5405      	ret	#6
		}
		else
			g_e8MotorRequest = (uint8) C_MOTOR_REQUEST_START;
    9d72:	6003      	lod	AL, #3
    9d74:	412e      	mov	dp:0x2e <_g_e8MotorRequest>, AL
    9d76:	5405      	ret	#6
	}
	else if ( (g_u8RewindFlags & (uint8) C_REWIND_STALL_DETECT) == 0 )
    9d78:	6124      	lod	AL, dp:0x24 <_g_u8RewindFlags>
    9d7a:	b402      	and	A, #2
    9d7c:	1d01      	jne	0x9d80 <_MotorDriverStop+0x20a>
	{
		g_u8RewindFlags = 0;													/* Clear all other flags in case no STALL have been detected */
    9d7e:	4124      	mov	dp:0x24 <_g_u8RewindFlags>, AL
    9d80:	5405      	ret	#6

00009d82 <_EXT0_IT>:
 * The g_u8StallOcc flags can be set in this Commutation_ISR(), but cleared in the MotorDriverStop(),
 * before it is communicated back to the ECU/Master.
 * ****************************************************************************	*/
#define Commutation_ISR	EXT0_IT
__interrupt__ void Commutation_ISR(void)
{
    9d82:	52df      	push	A
    9d84:	5edf      	push	X
    9d86:	5adf      	push	Y
    9d88:	4c83      	push	D
    9d8a:	5811      	inc	S, #18
#if (_DEBUG_COMMUT_ISR != FALSE)
	DEBUG_SET_IO_B();
#endif /* (_DEBUG_COMMUT_ISR != FALSE) && (_DEBUG_HALLLATCH_ISR == FALSE) */

	uint16 pending = XI0_PEND & XI0_MASK;										/* Copy interrupt requests which are not masked   */
    9d8c:	7ad8 2034 	lod	Y, 0x2034 <__ep__+0x1034>
    9d90:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    9d94:	f6e2      	and	Y, A
	do
	{
		XI0_PEND = pending;														/* Clear requests which are going to be processed */
    9d96:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
	} while (XI0_PEND & pending);
    9d9a:	72d8 2034 	lod	A, 0x2034 <__ep__+0x1034>
    9d9e:	b6e6      	and	A, Y
    9da0:	1d7a      	jne	0x9d96 <_EXT0_IT+0x14>

	if ( (g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0 )
    9da2:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9da4:	b401      	and	A, #1
    9da6:	1d01      	jne	0x9daa <_EXT0_IT+0x28>
    9da8:	0107      	jmp	0x9fb8 <_EXT0_IT+0x236>
	{
		return;		/* Used for CPU wake-up */
	}

	if ( g_e8MotorDirectionCCW )
    9daa:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9dac:	1903      	je	0x9db4 <_EXT0_IT+0x32>
	{
		g_u16ActuatorActPos--;													/* Closing */
    9dae:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9db0:	a0ff      	add	A, #-1
    9db2:	0002      	jmp	0x9db8 <_EXT0_IT+0x36>
	}
	else
	{
		g_u16ActuatorActPos++;													/* Opening */
    9db4:	71f6      	lod	A, dp:0xf6 <_g_u16ActuatorActPos>
    9db6:	a001      	add	A, #1
    9db8:	51f6      	mov	dp:0xf6 <_g_u16ActuatorActPos>, A
	}

	{
		int32 i32DeltaPosition = (int32)g_u16ActuatorActPos - (int32)g_u16ActuatorTgtPos;
    9dba:	7df6      	lod	X, dp:0xf6 <_g_u16ActuatorActPos>
    9dbc:	4ceb      	movu	YA, X
    9dbe:	a9f8      	sub	A, dp:0xf8 <_g_u16ActuatorTgtPos>
    9dc0:	f800      	subc	Y, #0
    9dc2:	5211      	mov	[S-18], A
    9dc4:	5a0f      	mov	[S-16], Y
		if ( i32DeltaPosition == 0 )
    9dc6:	4cb2 0000 	cmp	YA, #0
    9dca:	0000 
    9dcc:	1d0a      	jne	0x9de2 <_EXT0_IT+0x60>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    9dce:	7001      	lod	A, #1
    9dd0:	16d2      	call	0x9b76 <_MotorDriverStop>
			return;
    9dd2:	5c11      	dec	S, #18
    9dd4:	4cc3      	pop	D
    9dd6:	7acf      	pop	Y
    9dd8:	7ecf      	pop	X
    9dda:	72cf      	pop	A
    9ddc:	4407      	mov	R, #0
    9dde:	72cb      	pop	M
    9de0:	5401      	ret
		}
		if ( i32DeltaPosition < 0 )
    9de2:	7211      	lod	A, [S-18]
    9de4:	7a0f      	lod	Y, [S-16]
    9de6:	4cb2 0000 	cmp	YA, #0
    9dea:	0000 
    9dec:	1e83      	jsge	0x9df4 <_EXT0_IT+0x72>
		{
			i32DeltaPosition = -i32DeltaPosition;
    9dee:	4cf0      	neg	YA
    9df0:	5211      	mov	[S-18], A
    9df2:	5a0f      	mov	[S-16], Y
		}
		if ( i32DeltaPosition <= (int16) l_u8VTIdx )
    9df4:	6534      	lod	YL, dp:0x34 <_l_u8VTIdx>
    9df6:	5cf6      	usex	Y
    9df8:	5a07      	mov	[S-8], Y
    9dfa:	7207      	lod	A, [S-8]
    9dfc:	7800      	lod	Y, #0
    9dfe:	5207      	mov	[S-8], A
    9e00:	5a05      	mov	[S-6], Y
    9e02:	72ef      	lod	A, S
    9e04:	a0ee      	add	A, #-18
    9e06:	4cf3      	swap	YA
    9e08:	4cc5      	mov	D, [Y]
    9e0a:	7207      	lod	A, [S-8]
    9e0c:	7a05      	lod	Y, [S-6]
    9e0e:	4c90      	cmp	D, YA
    9e10:	1f08      	jsg	0x9e22 <_EXT0_IT+0xa0>
		{
			/* Decelerate motor speed (almost at target-position) */
			g_u16StartupDelay = (uint16) i32DeltaPosition;
    9e12:	7a11      	lod	Y, [S-18]
    9e14:	5936      	mov	dp:0x36 <_g_u16StartupDelay>, Y
			g_u16TargetCommutTimerPeriod = l_u16LowSpeedPeriod;
    9e16:	7ed8 0356 	lod	X, 0x356 <_l_u16LowSpeedPeriod>
    9e1a:	5d52      	mov	dp:0x52 <_g_u16TargetCommutTimerPeriod>, X
			g_e8MotorStatusMode |= (uint8) C_MOTOR_STATUS_STOPPING;
    9e1c:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    9e1e:	8409      	or	AL, #9
    9e20:	41eb      	mov	dp:0xeb <_g_e8MotorStatusMode>, AL
		}
	}

	/* Current measurement used for Stall-detector "A" and current control (PID) */
	MotorDriverCurrentMeasure();
    9e22:	1518      	call	0x9854 <_MotorDriverCurrentMeasure>
	/* Coil current check */
	if(l_u16CoilCurrentStartDelay == 0)
    9e24:	72d8 013e 	lod	A, 0x13e <_l_u16CoilCurrentStartDelay>
    9e28:	1901      	je	0x9e2c <_EXT0_IT+0xaa>
    9e2a:	0041      	jmp	0x9eae <_EXT0_IT+0x12c>
	{
		if(g_u16CurrentMotorCoilA < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT))
    9e2c:	7ad8 0138 	lod	Y, 0x138 <_l_u16CurrentZeroOffset>
    9e30:	72e6      	lod	A, Y
    9e32:	a00a      	add	A, #10
    9e34:	5207      	mov	[S-8], A
    9e36:	7ed8 0142 	lod	X, 0x142 <_l_u16CoilZeroCurrCountA>
    9e3a:	72d8 0132 	lod	A, 0x132 <_g_u16CurrentMotorCoilB>
    9e3e:	5209      	mov	[S-10], A
    9e40:	7207      	lod	A, [S-8]
    9e42:	aed8 0134 	cmp	A, 0x134 <_g_u16CurrentMotorCoilA>
    9e46:	1a03      	jule	0x9e4e <_EXT0_IT+0xcc>
		{
			l_u16CoilZeroCurrCountA++;
    9e48:	72ee      	lod	A, X
    9e4a:	a001      	add	A, #1
    9e4c:	0004      	jmp	0x9e56 <_EXT0_IT+0xd4>
		}
		else if ( l_u16CoilZeroCurrCountA != 0 )
    9e4e:	2c00      	cmp	X, #0
    9e50:	1904      	je	0x9e5a <_EXT0_IT+0xd8>
		{
			l_u16CoilZeroCurrCountA--;
    9e52:	72ee      	lod	A, X
    9e54:	a0ff      	add	A, #-1
    9e56:	52d8 0142 	mov	0x142 <_l_u16CoilZeroCurrCountA>, A
		}

		if(g_u16CurrentMotorCoilB < (l_u16CurrentZeroOffset + C_MIN_COIL_CURRENT))
    9e5a:	e00a      	add	Y, #10
    9e5c:	5a07      	mov	[S-8], Y
    9e5e:	7ed8 0142 	lod	X, 0x142 <_l_u16CoilZeroCurrCountA>
    9e62:	7ad8 0140 	lod	Y, 0x140 <_l_u16CoilZeroCurrCountB>
    9e66:	7209      	lod	A, [S-10]
    9e68:	ae07      	cmp	A, [S-8]
    9e6a:	1c03      	jnc	0x9e72 <_EXT0_IT+0xf0>
		{
			l_u16CoilZeroCurrCountB++;
    9e6c:	72e6      	lod	A, Y
    9e6e:	a001      	add	A, #1
    9e70:	0004      	jmp	0x9e7a <_EXT0_IT+0xf8>
		}
		else if ( l_u16CoilZeroCurrCountB != 0 )
    9e72:	ec00      	cmp	Y, #0
    9e74:	1904      	je	0x9e7e <_EXT0_IT+0xfc>
		{
			l_u16CoilZeroCurrCountB--;
    9e76:	72e6      	lod	A, Y
    9e78:	a0ff      	add	A, #-1
    9e7a:	52d8 0140 	mov	0x140 <_l_u16CoilZeroCurrCountB>, A
		}

		if((l_u16CoilZeroCurrCountA >= C_COIL_ZERO_CURRENT_COUNT) || (l_u16CoilZeroCurrCountB >= C_COIL_ZERO_CURRENT_COUNT))
    9e7e:	2c1f      	cmp	X, #31
    9e80:	1e04      	jug	0x9e8a <_EXT0_IT+0x108>
    9e82:	72d8 0140 	lod	A, 0x140 <_l_u16CoilZeroCurrCountB>
    9e86:	ac1f      	cmp	A, #31
    9e88:	1a15      	jule	0x9eb4 <_EXT0_IT+0x132>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    9e8a:	7001      	lod	A, #1
    9e8c:	1674      	call	0x9b76 <_MotorDriverStop>
			g_e8ErrorElectric = (uint8) C_ERR_ELECTRIC_PERM;
    9e8e:	6002      	lod	AL, #2
    9e90:	412d      	mov	dp:0x2d <_g_e8ErrorElectric>, AL
			SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
    9e92:	72da 00e6 	lod	A, #230
    9e96:	82db 9328 	callf	0x9328 <_SetLastError>
			g_e8ErrorCoil = (uint8) C_ERR_SELFTEST_C;//coil open
    9e9a:	60ec      	lod	AL, #-20
    9e9c:	412c      	mov	dp:0x2c <_g_e8ErrorCoil>, AL
			return;
    9e9e:	5c11      	dec	S, #18
    9ea0:	4cc3      	pop	D
    9ea2:	7acf      	pop	Y
    9ea4:	7ecf      	pop	X
    9ea6:	72cf      	pop	A
    9ea8:	4407      	mov	R, #0
    9eaa:	72cb      	pop	M
    9eac:	5401      	ret
		}
	}else if(l_u16CoilCurrentStartDelay > 0){
		l_u16CoilCurrentStartDelay--;
    9eae:	a0ff      	add	A, #-1
    9eb0:	52d8 013e 	mov	0x13e <_l_u16CoilCurrentStartDelay>, A



	/* Update micro-step index */
	{
		uint16 u16MicroStepIdx = g_u16MicroStepIdx;
    9eb4:	794e      	lod	Y, dp:0x4e <_g_u16MicroStepIdx>
		if ( g_e8MotorDirectionCCW )
    9eb6:	612a      	lod	AL, dp:0x2a <_g_e8MotorDirectionCCW>
    9eb8:	1906      	je	0x9ec6 <_EXT0_IT+0x144>
		{
			/* Counter Clock-wise (Closing) */
			if ( u16MicroStepIdx == 0 )
    9eba:	ec00      	cmp	Y, #0
    9ebc:	1d02      	jne	0x9ec2 <_EXT0_IT+0x140>
			{
				u16MicroStepIdx = g_u16MotorMicroStepsPerElecRotation;
    9ebe:	7ad8 02a8 	lod	Y, 0x2a8 <_g_u16MotorMicroStepsPerElecRotation>
			}
			u16MicroStepIdx--;													/* Decrement the PWM vector pointer */
    9ec2:	e0ff      	add	Y, #-1
    9ec4:	0005      	jmp	0x9ed0 <_EXT0_IT+0x14e>
		}
		else
		{
			/* Clock-wise (Opening) */
			u16MicroStepIdx++;													/* Increment the PWM vectors pointer */
    9ec6:	e001      	add	Y, #1
			if ( u16MicroStepIdx >= g_u16MotorMicroStepsPerElecRotation )		/* Test the PWM vectors pointer: 48 usteps per electrical period */
    9ec8:	eed8 02a8 	cmp	Y, 0x2a8 <_g_u16MotorMicroStepsPerElecRotation>
    9ecc:	1801      	jc	0x9ed0 <_EXT0_IT+0x14e>
			{
				u16MicroStepIdx = 0;											/* Re-initialise the PWM vectors pointer to 0 */
    9ece:	7800      	lod	Y, #0
			}
		}
		g_u16MicroStepIdx = u16MicroStepIdx;
    9ed0:	594e      	mov	dp:0x4e <_g_u16MicroStepIdx>, Y
	}

	/* Check for speed update required */
	if ( g_u16CommutTimerPeriod == g_u16TargetCommutTimerPeriod )
    9ed2:	7d50      	lod	X, dp:0x50 <_g_u16CommutTimerPeriod>
    9ed4:	7152      	lod	A, dp:0x52 <_g_u16TargetCommutTimerPeriod>
    9ed6:	520d      	mov	[S-14], A
    9ed8:	2ee2      	cmp	X, A
    9eda:	1d04      	jne	0x9ee4 <_EXT0_IT+0x162>
	{
		g_u8MotorStartupMode = (uint8) MSM_STEPPER_C;
    9edc:	6003      	lod	AL, #3
    9ede:	42d8 0149 	mov	0x149 <_g_u8MotorStartupMode>, AL
    9ee2:	005b      	jmp	0x9f9a <_EXT0_IT+0x218>
	}
	else
	{
		/* Update speed */
		uint16 u16Compensation = l_u16SpeedRPM;							//MMP160606-1
    9ee4:	72d8 0350 	lod	A, 0x350 <_l_u16SpeedRPM>
    9ee8:	520b      	mov	[S-12], A
		if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    9eea:	2e0d      	cmp	X, [S-14]
    9eec:	1c30      	jnc	0x9f4e <_EXT0_IT+0x1cc>
		{
			/* Deceleration per micro-step */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_D;					/* Too fast, decelerate */
    9eee:	6002      	lod	AL, #2
    9ef0:	42d8 0149 	mov	0x149 <_g_u8MotorStartupMode>, AL
    9ef4:	71a0      	lod	A, dp:0xa0 <__data_size+0x3e>
    9ef6:	7800      	lod	Y, #0
    9ef8:	48e0      	asl	YA, #1
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9efa:	7e0b      	lod	X, [S-12]
    9efc:	4c63      	divu	YA, X
    9efe:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9f00:	2ae2      	sub	X, A
    9f02:	5e03      	mov	[S-4], X
    9f04:	5ed8 0350 	mov	0x350 <_l_u16SpeedRPM>, X
    9f08:	72d8 0352 	lod	A, 0x352 <_l_u32Temp>
    9f0c:	7ad8 0354 	lod	Y, 0x354 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9f10:	4c63      	divu	YA, X
    9f12:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9f14:	7ae2      	lod	Y, A
    9f16:	e0ff      	add	Y, #-1
    9f18:	5950      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM - divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;	/* MMP160606-1 */
			l_u8VTIdx--;
    9f1a:	6134      	lod	AL, dp:0x34 <_l_u8VTIdx>
    9f1c:	80ff      	add	AL, #-1
    9f1e:	4134      	mov	dp:0x34 <_l_u8VTIdx>, AL
			if ( g_u16StartupDelay < l_u8VTIdx )
    9f20:	5cf2      	usex	A
    9f22:	ad36      	cmp	A, dp:0x36 <_g_u16StartupDelay>
    9f24:	1a03      	jule	0x9f2c <_EXT0_IT+0x1aa>
			{
				g_u16StartupDelay = l_u16StartupDelayInit;						/* MMP130627-1/MMP140331-2: Speed reduction, stall detection post-poned */
    9f26:	72d8 0144 	lod	A, 0x144 <_l_u16StartupDelayInit>
    9f2a:	5136      	mov	dp:0x36 <_g_u16StartupDelay>, A
			}
			if ( g_u16CommutTimerPeriod > g_u16TargetCommutTimerPeriod )
    9f2c:	ee0d      	cmp	Y, [S-14]
    9f2e:	1a02      	jule	0x9f34 <_EXT0_IT+0x1b2>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9f30:	7a0d      	lod	Y, [S-14]
    9f32:	5950      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, Y
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    9f34:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    9f36:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f38:	72d8 035a 	lod	A, 0x35a <_g_u16PidCtrlRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9f3c:	7a03      	lod	Y, [S-4]
    9f3e:	7e0b      	lod	X, [S-12]
    9f40:	4821      	mulu	YA, A, Y
    9f42:	4c63      	divu	YA, X
    9f44:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9f46:	52d8 035a 	mov	0x35a <_g_u16PidCtrlRatio>, A
#if (_SUPPORT_PWM_DC_RAMPDOWN != FALSE)											/* MMP140903-2 - Begin */
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
    9f4a:	51c8      	mov	dp:0xc8 <_g_u16PID_I>, A
    9f4c:	0026      	jmp	0x9f9a <_EXT0_IT+0x218>
//			/* Reduce the PWM-duty cycle to avoid current increase (wrong stall detection) (254/256) */
//			g_u16PidCtrlRatio = (uint16) (mulU32_U16byU16( g_u16PidCtrlRatio, 254) >> 8);
//			g_u16PID_I = g_u16PidCtrlRatio;
//#endif /* (_SUPPORT_PWM_DC_RAMPDOWN != FALSE) */								/* MMP140903-2 - Begin */
		}
		else if ( (g_u16MicroStepIdx == 0) || ((g_u16MicroStepIdx > NVRAM_ACCELERATION_POINTS) && ((g_u16MicroStepIdx & NVRAM_ACCELERATION_POINTS) == 0)) )
    9f4e:	ec00      	cmp	Y, #0
    9f50:	1906      	je	0x9f5e <_EXT0_IT+0x1dc>
    9f52:	61a2      	lod	AL, dp:0xa2 <__data_size+0x40>
    9f54:	b43f      	and	A, #63
    9f56:	eee2      	cmp	Y, A
    9f58:	1a20      	jule	0x9f9a <_EXT0_IT+0x218>
    9f5a:	b6e6      	and	A, Y
    9f5c:	1d1e      	jne	0x9f9a <_EXT0_IT+0x218>
		{
			/* Acceleration per acceleration_points ((multiple) full-step) */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;					/* Too slow, accelerate */
    9f5e:	6001      	lod	AL, #1
    9f60:	42d8 0149 	mov	0x149 <_g_u8MotorStartupMode>, AL
    9f64:	71a0      	lod	A, dp:0xa0 <__data_size+0x3e>
    9f66:	7800      	lod	Y, #0
    9f68:	48e0      	asl	YA, #1
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9f6a:	7e0b      	lod	X, [S-12]
    9f6c:	4c63      	divu	YA, X
    9f6e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9f70:	22e2      	add	X, A
    9f72:	5ed8 0350 	mov	0x350 <_l_u16SpeedRPM>, X
    9f76:	72d8 0352 	lod	A, 0x352 <_l_u32Temp>
    9f7a:	7ad8 0354 	lod	Y, 0x354 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9f7e:	4c63      	divu	YA, X
    9f80:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9f82:	7ae2      	lod	Y, A
    9f84:	e0ff      	add	Y, #-1
    9f86:	5950      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM + divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1;	/* MMP160606-1 */
			l_u8VTIdx++;
    9f88:	6134      	lod	AL, dp:0x34 <_l_u8VTIdx>
    9f8a:	8001      	add	AL, #1
    9f8c:	4134      	mov	dp:0x34 <_l_u8VTIdx>, AL
			if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )	/* MMP150923-1 */
    9f8e:	ee0d      	cmp	Y, [S-14]
    9f90:	1c02      	jnc	0x9f96 <_EXT0_IT+0x214>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9f92:	720d      	lod	A, [S-14]
    9f94:	5150      	mov	dp:0x50 <_g_u16CommutTimerPeriod>, A
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    9f96:	7150      	lod	A, dp:0x50 <_g_u16CommutTimerPeriod>
    9f98:	52ac      	mov	io:0x2c <_g_e8ErrorCoil>, A
//			TMR1_REGB = g_u16CommutTimerPeriod;
//			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;						/* Too slow, accelerate */
		}
	}

	VoltageCorrection();
    9f9a:	1349      	call	0xa62e <_VoltageCorrection>

	MotorDriver_4PhaseStepper();
    9f9c:	14ea      	call	0x9972 <_MotorDriver_4PhaseStepper>
	if ( MotorStallCheckA() != (uint16) C_STALL_NOT_FOUND )						/* Stall-detector "A" */
    9f9e:	1018      	call	0x9fd0 <_MotorStallCheckA>
    9fa0:	ac00      	cmp	A, #0
    9fa2:	190a      	je	0x9fb8 <_EXT0_IT+0x236>
	{
		g_u8StallTypeComm |= (uint8) C_STALL_FOUND_A;
    9fa4:	611f      	lod	AL, dp:0x1f <_g_u8StallTypeComm>
    9fa6:	8440      	or	AL, #64
    9fa8:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL
		if ( g_e8StallDetectorEna & ((uint8) C_STALLDET_A | (uint8) C_STALLDET_CALIB))	/* MMP130916-1 */
    9faa:	61ec      	lod	AL, dp:0xec <_g_e8StallDetectorEna>
    9fac:	b409      	and	A, #9
    9fae:	1904      	je	0x9fb8 <_EXT0_IT+0x236>
		{
			g_u8StallOcc = TRUE;												/* Report stall and ...  */
    9fb0:	6001      	lod	AL, #1
    9fb2:	4128      	mov	dp:0x28 <_g_u8StallOcc>, AL
			MotorDriverStop( (uint16) C_STOP_EMERGENCY);						/* ... stop motor (Stall) */
    9fb4:	7002      	lod	A, #2
    9fb6:	15df      	call	0x9b76 <_MotorDriverStop>
    9fb8:	5c11      	dec	S, #18
    9fba:	4cc3      	pop	D
    9fbc:	7acf      	pop	Y
    9fbe:	7ecf      	pop	X
    9fc0:	72cf      	pop	A
    9fc2:	4407      	mov	R, #0
    9fc4:	72cb      	pop	M
    9fc6:	5401      	ret

00009fc8 <_MotorStallInitA>:
 *
 * Initialise Stall detector "A"
 * ****************************************************************************	*/
void MotorStallInitA( void)
{
	g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;								/* Used for communication */
    9fc8:	6000      	lod	AL, #0
    9fca:	411f      	mov	dp:0x1f <_g_u8StallTypeComm>, AL

	l_u8StallCountA = 0;														/* Stall-counter */
    9fcc:	4139      	mov	dp:0x39 <_l_u8StallCountA>, AL
    9fce:	5401      	ret

00009fd0 <_MotorStallCheckA>:
 * Check if motor is stalled
 * Stall detector "A" is based on fast current increase
 * Performance: 5us @ 20MHz
 * ****************************************************************************	*/
uint16 MotorStallCheckA( void)
{
    9fd0:	5805      	inc	S, #6
	uint16 u16Result = C_STALL_NOT_FOUND;
    9fd2:	7000      	lod	A, #0
    9fd4:	5205      	mov	[S-6], A
	if ( (g_u16StartupDelay == 0) && (g_u16MotorCurrentMovAvgxN > (C_MIN_MOTORCURRENT << 4)) )	/* MMP130916-1 */
    9fd6:	7136      	lod	A, dp:0x36 <_g_u16StartupDelay>
    9fd8:	1d2e      	jne	0xa036 <_MotorStallCheckA+0x66>
    9fda:	7154      	lod	A, dp:0x54 <_g_u16MotorCurrentMovAvgxN>
    9fdc:	5203      	mov	[S-4], A
    9fde:	aeda 00a0 	cmp	A, #160
    9fe2:	1a29      	jule	0xa036 <_MotorStallCheckA+0x66>
		   blocks, the BEMF drops to zero, and therefore the motor current increases.
		   This increase is monitored by calculating the difference (delta) between
		   a LPF filter (slowly increase) and the actual motor current. If this delta
		   increases above a specified threshold, stall is detected. */
		uint16 u16Threshold;
		if ( NVRAM_STALL_SPEED_DEPENDED )
    9fe4:	61c7      	lod	AL, dp:0xc7 <__bss_dp_size+0x17>
    9fe6:	65a3      	lod	YL, dp:0xa3 <__data_size+0x41>
    9fe8:	7d56      	lod	X, dp:0x56 <_g_u16MotorCurrentLPFx64>
    9fea:	8c00      	cmp	AL, #0
    9fec:	1e8a      	jsge	0xa002 <_MotorStallCheckA+0x32>
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 120) + (g_u8MotorStatusSpeed << 3);	/* Speed depended Threshold */
    9fee:	f47f      	and	Y, #127
    9ff0:	611e      	lod	AL, dp:0x1e <__ramfunc_size>
    9ff2:	44a2      	asl	A, #2
    9ff4:	4422      	asl	A
    9ff6:	b6da 07f8 	and	A, #2040
    9ffa:	e2e2      	add	Y, A
    9ffc:	72e6      	lod	A, Y
    9ffe:	a078      	add	A, #120
    a000:	0004      	jmp	0xa00a <_MotorStallCheckA+0x3a>
		}
		else
		{
			u16Threshold = (NVRAM_STALL_CURR_THRSHLD + 128);					/* Fixed Threshold */
    a002:	72e6      	lod	A, Y
    a004:	b47f      	and	A, #127
    a006:	a2da 0080 	add	A, #128
		}
		l_u16MotorCurrentStallThrshldxN = (uint16)(((uint32)g_u16MotorCurrentLPFx64 * u16Threshold) >> (13 - C_MOVAVG_SSZ));
    a00a:	4823      	mulu	YA, A, X
    a00c:	48a6      	lsr	YA, #7
    a00e:	52d8 0358 	mov	0x358 <_l_u16MotorCurrentStallThrshldxN>, A
		if ( g_u16MotorCurrentMovAvgxN > l_u16MotorCurrentStallThrshldxN )
    a012:	7ae2      	lod	Y, A
    a014:	6139      	lod	AL, dp:0x39 <_l_u8StallCountA>
    a016:	4201      	mov	[S-2], AL
    a018:	7203      	lod	A, [S-4]
    a01a:	aee6      	cmp	A, Y
    a01c:	1a08      	jule	0xa02e <_MotorStallCheckA+0x5e>
		{
			l_u8StallCountA++;
    a01e:	6201      	lod	AL, [S-2]
    a020:	8001      	add	AL, #1
    a022:	4139      	mov	dp:0x39 <_l_u8StallCountA>, AL
			if ( l_u8StallCountA >= 3 )
    a024:	8c02      	cmp	AL, #2
    a026:	1a07      	jule	0xa036 <_MotorStallCheckA+0x66>
			{
				/* Real stall */
				u16Result = C_STALL_FOUND;
    a028:	7002      	lod	A, #2
    a02a:	5205      	mov	[S-6], A
    a02c:	0004      	jmp	0xa036 <_MotorStallCheckA+0x66>
			}
		}
		else if ( l_u8StallCountA )
    a02e:	6201      	lod	AL, [S-2]
    a030:	1902      	je	0xa036 <_MotorStallCheckA+0x66>
		{
			l_u8StallCountA--;
    a032:	80ff      	add	AL, #-1
    a034:	4139      	mov	dp:0x39 <_l_u8StallCountA>, AL
		}
	}
	return ( u16Result );
} /* End of MotorStallCheckA() */
    a036:	7205      	lod	A, [S-6]
    a038:	5407      	ret	#8

0000a03a <_NVRAM_CRC8>:
 *								TRUE: Calculated CRC8
 *
 *	Calculate CRC8 on User-NVRAM
 * ****************************************************************************	*/
uint8 NVRAM_CRC8( uint8 byReplaceCRC)
{
    a03a:	5803      	inc	S, #4
    a03c:	5201      	mov	[S-2], A
	uint16 u16CRC;

	if ( byReplaceCRC != FALSE )
    a03e:	ac00      	cmp	A, #0
    a040:	1902      	je	0xa046 <_NVRAM_CRC8+0xc>
	{
		g_NvramUser.CRC8 = 0x00;
    a042:	6000      	lod	AL, #0
    a044:	4158      	mov	dp:0x58 <_g_NvramUser>, AL
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    a046:	7ada 0058 	lod	Y, #88
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    a04a:	7c38      	lod	X, #56
    a04c:	7000      	lod	A, #0
    a04e:	08a7      	clrb	ML.7
    a050:	b2d6      	adc	A, [Y++]
    a052:	1bfe      	djnz	X, 0xa050 <_NVRAM_CRC8+0x16>
    a054:	92e4      	adc	AL, AH
    a056:	9000      	adc	AL, #0
    a058:	5cf2      	usex	A
    a05a:	5203      	mov	[S-4], A
	}

	u16CRC = nvram_CalcCRC( (uint16 *) &g_NvramUser, (sizeof(g_NvramUser)/sizeof(uint16)));	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    a05c:	7a01      	lod	Y, [S-2]
    a05e:	1903      	je	0xa066 <_NVRAM_CRC8+0x2c>
	{
		g_NvramUser.CRC8 = (0xFF - u16CRC);
    a060:	60ff      	lod	AL, #-1
    a062:	8a03      	sub	AL, [S-4]
    a064:	4158      	mov	dp:0x58 <_g_NvramUser>, AL
	}

	return ( (uint8) u16CRC );
    a066:	6203      	lod	AL, [S-4]
    a068:	5cf2      	usex	A
} /* End of NVRAM_CRC8() */
    a06a:	5405      	ret	#6

0000a06c <_NVRAM_CountCRC8>:
 *								TRUE: Calculated CRC8.
 *
 *	Calculate CRC8 on Write-cycle counter.
 * ****************************************************************************	*/
uint8 NVRAM_CountCRC8( PNVRAM_ERRORLOG pNVERRLOG, uint8 byReplaceCRC)
{
    a06c:	5807      	inc	S, #8
    a06e:	5203      	mov	[S-4], A
    a070:	620b      	lod	AL, [S-12]
    a072:	5cf2      	usex	A
    a074:	5201      	mov	[S-2], A
    a076:	7c01      	lod	X, #1
    a078:	7a03      	lod	Y, [S-4]
    a07a:	7000      	lod	A, #0
    a07c:	08a7      	clrb	ML.7
    a07e:	b2d6      	adc	A, [Y++]
    a080:	1bfe      	djnz	X, 0xa07e <_NVRAM_CountCRC8+0x12>
    a082:	92e4      	adc	AL, AH
    a084:	9000      	adc	AL, #0
    a086:	5cf2      	usex	A
    a088:	5207      	mov	[S-8], A
	uint16 u16CRC = nvram_CalcCRC( (uint16 *) &pNVERRLOG->NvramProgramCycleCount, 1);	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    a08a:	7201      	lod	A, [S-2]
    a08c:	190c      	je	0xa0a6 <_NVRAM_CountCRC8+0x3a>
	{
		pNVERRLOG->ErrorLogIndex_CRC = (pNVERRLOG->ErrorLogIndex_CRC & 0x00FF) | ((0xFF - u16CRC) << 8);
    a08e:	7a03      	lod	Y, [S-4]
    a090:	72f2      	lod	A, [Y+2]
    a092:	b6da 00ff 	and	A, #255
    a096:	7ee2      	lod	X, A
    a098:	72da 00ff 	lod	A, #255
    a09c:	aa07      	sub	A, [S-8]
    a09e:	6800      	lod	AH, #0
    a0a0:	72e4      	swap	A
    a0a2:	26e2      	or	X, A
    a0a4:	5ef2      	mov	[Y+2], X
	}
	return ( (uint8) ((pNVERRLOG->ErrorLogIndex_CRC >> 8) ^ u16CRC) );
    a0a6:	7a03      	lod	Y, [S-4]
    a0a8:	62f3      	lod	AL, [Y+3]
    a0aa:	9e07      	xor	AL, [S-8]
    a0ac:	5cf2      	usex	A
} /* End of NVRAM_CountCRC8() */
    a0ae:	5409      	ret	#10

0000a0b0 <_NVRAM_PageVerify>:
 *	Post:	FALSE: NVRAM shadow-RAM page structure and RAM-structure are not the same
 *			TRUE : NVRAM shadow-RAM page structure and RAM-structure are the same
 *
 * ****************************************************************************	*/
uint16 NVRAM_PageVerify( const uint16 *pMRAM)
{
    a0b0:	7ee2      	lod	X, A
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    a0b2:	7ada 0058 	lod	Y, #88
	do
	{
		if ( *pMRAM++ != *pURAM++ )
    a0b6:	72de      	lod	A, [X++]
    a0b8:	aed6      	cmp	A, [Y++]
    a0ba:	1902      	je	0xa0c0 <_NVRAM_PageVerify+0x10>
		{
			/* Error */
			return ( FALSE );
    a0bc:	7000      	lod	A, #0
    a0be:	5401      	ret
		}
	} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    a0c0:	eeda 00c8 	cmp	Y, #200
    a0c4:	1878      	jc	0xa0b6 <_NVRAM_PageVerify+0x6>
	return ( TRUE );
    a0c6:	7001      	lod	A, #1
} /* End of NVRAM_PageVerify() */
    a0c8:	5401      	ret

0000a0ca <_NVRAM_Store>:
 *
 * C_ADDR_USERPAGE1+0x00:0x7F:	User page #1 (64x 16-bits words)
 * C_ADDR_USERPAGE2+0x00:0x7F:	User page #2 (64x 16-bits words) (Backup)
 * ****************************************************************************	*/
uint16 NVRAM_Store( uint16 u16Page)
{
    a0ca:	5803      	inc	S, #4
    a0cc:	5203      	mov	[S-4], A
	uint16 *pURAM;
	uint16 *pMRAM;
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    a0ce:	7000      	lod	A, #0
    a0d0:	5201      	mov	[S-2], A

	/* Store NVRAM */
	if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0 )
    a0d2:	6203      	lod	AL, [S-4]
    a0d4:	8c00      	cmp	AL, #0
    a0d6:	1a82      	jsl	0xa0dc <_NVRAM_Store+0x12>
	{
		(void) NVRAM_CRC8( TRUE);												/* Update CRC8 */
    a0d8:	7001      	lod	A, #1
    a0da:	17af      	call	0xa03a <_NVRAM_CRC8>
	}

	/* Copy NVRAM UserRAM-copy into NVRAM MirrorRAM */
	if ( (u16Page & C_NVRAM_USER_PAGE_1) &&
    a0dc:	7203      	lod	A, [S-4]
    a0de:	b401      	and	A, #1
    a0e0:	1d01      	jne	0xa0e4 <_NVRAM_Store+0x1a>
    a0e2:	0039      	jmp	0xa156 <_NVRAM_Store+0x8c>
    a0e4:	7203      	lod	A, [S-4]
    a0e6:	b440      	and	A, #64
    a0e8:	1d05      	jne	0xa0f4 <_NVRAM_Store+0x2a>
    a0ea:	72da 1000 	lod	A, #4096
    a0ee:	17e0      	call	0xa0b0 <_NVRAM_PageVerify>
    a0f0:	ac00      	cmp	A, #0
    a0f2:	1d31      	jne	0xa156 <_NVRAM_Store+0x8c>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */							/* MMP150219-1 - Begin */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    a0f4:	54ca 0000 	pushw	#0
    a0f8:	72da 1070 	lod	A, #4208
    a0fc:	17b7      	call	0xa06c <_NVRAM_CountCRC8>
    a0fe:	5c01      	dec	S, #2
    a100:	8cff      	cmp	AL, #-1
    a102:	1906      	je	0xa110 <_NVRAM_Store+0x46>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    a104:	7000      	lod	A, #0
    a106:	7ada 1070 	lod	Y, #4208
    a10a:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    a10c:	7802      	lod	Y, #2
    a10e:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    a110:	7ada 1070 	lod	Y, #4208
    a114:	72f0      	lod	A, [Y]
    a116:	acfd      	cmp	A, #-3
    a118:	1e02      	jug	0xa11e <_NVRAM_Store+0x54>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    a11a:	a001      	add	A, #1
    a11c:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);							/* Calculate Cycle-count CRC8 */
    a11e:	54ca 0001 	pushw	#1
    a122:	72da 1070 	lod	A, #4208
    a126:	17a2      	call	0xa06c <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 1 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    a128:	7ada 0058 	lod	Y, #88
				pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    a12c:	7eda 1000 	lod	X, #4096
				do
    a130:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    a132:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    a134:	eeda 00c8 	cmp	Y, #200
    a138:	187c      	jc	0xa132 <_NVRAM_Store+0x68>
			}																	/* MMP150219-1 - End */

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM1_PAGE1);
    a13a:	7000      	lod	A, #0
    a13c:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    a140:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE1) == FALSE )
    a144:	72da 1000 	lod	A, #4096
    a148:	17b3      	call	0xa0b0 <_NVRAM_PageVerify>
    a14a:	ac00      	cmp	A, #0
    a14c:	1d04      	jne	0xa156 <_NVRAM_Store+0x8c>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG11);
    a14e:	72da 00f4 	lod	A, #244
    a152:	82db 9328 	callf	0x9328 <_SetLastError>
		} while ( FALSE );
	}

#if _SUPPORT_NVRAM_BACKUP
	/* Duplicate NVRAM user page 1 into page 2 */
	if ( (u16Page & C_NVRAM_USER_PAGE_2) &&
    a156:	7203      	lod	A, [S-4]
    a158:	b402      	and	A, #2
    a15a:	1d01      	jne	0xa15e <_NVRAM_Store+0x94>
    a15c:	0039      	jmp	0xa1d0 <_NVRAM_Store+0x106>
    a15e:	7203      	lod	A, [S-4]
    a160:	b440      	and	A, #64
    a162:	1d05      	jne	0xa16e <_NVRAM_Store+0xa4>
    a164:	72da 1100 	lod	A, #4352
    a168:	17a3      	call	0xa0b0 <_NVRAM_PageVerify>
    a16a:	ac00      	cmp	A, #0
    a16c:	1d31      	jne	0xa1d0 <_NVRAM_Store+0x106>
		/* Forced Write, or RAM differs from NVRAM; Copy RAM to NVRAM */
		do
		{
			/* Update NVRAM program cycle counter */							/* MMP150219-1 - Begin */
			PNVRAM_ERRORLOG pNVERRLOG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
			if ( NVRAM_CountCRC8( pNVERRLOG, FALSE) != (uint8) 0xFFU )
    a16e:	54ca 0000 	pushw	#0
    a172:	72da 1170 	lod	A, #4464
    a176:	177a      	call	0xa06c <_NVRAM_CountCRC8>
    a178:	5c01      	dec	S, #2
    a17a:	8cff      	cmp	AL, #-1
    a17c:	1906      	je	0xa18a <_NVRAM_Store+0xc0>
			{
				/* Invalid NVRAM Program-counter */
				pNVERRLOG->NvramProgramCycleCount = 0U;
    a17e:	7000      	lod	A, #0
    a180:	7ada 1170 	lod	Y, #4464
    a184:	52f0      	mov	[Y], A
				u16Result = C_NVRAM_STORE_INVALID_COUNTER;
    a186:	7802      	lod	Y, #2
    a188:	5a01      	mov	[S-2], Y
			}
#if _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES
			if ( pNVERRLOG->NvramProgramCycleCount < 0xFFFEU )
    a18a:	7ada 1170 	lod	Y, #4464
    a18e:	72f0      	lod	A, [Y]
    a190:	acfd      	cmp	A, #-3
    a192:	1e02      	jug	0xa198 <_NVRAM_Store+0xce>
			{
				pNVERRLOG->NvramProgramCycleCount++;
    a194:	a001      	add	A, #1
    a196:	52f0      	mov	[Y], A
			{
				u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
				break;															/* Skip NVRAM update (reached max-write cycle count) */
			}
#endif /* _SUPPORT_UNLIMITED_NVRAM_WRITE_CYCLES */
			(void) NVRAM_CountCRC8( pNVERRLOG, TRUE);
    a198:	54ca 0001 	pushw	#1
    a19c:	72da 1170 	lod	A, #4464
    a1a0:	1765      	call	0xa06c <_NVRAM_CountCRC8>

			/* Copy System RAM version to NVRAM User-page 2 shadow-RAM */
			{
				pURAM = (uint16 *) &g_NvramUser;
    a1a2:	7ada 0058 	lod	Y, #88
				pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    a1a6:	7eda 1100 	lod	X, #4352
				do
    a1aa:	5c01      	dec	S, #2
				{
					*pMRAM++ = *pURAM++;
    a1ac:	54c6      	movsw	[X++], [Y++]
				} while ( pURAM < ((uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16))) );
    a1ae:	eeda 00c8 	cmp	Y, #200
    a1b2:	187c      	jc	0xa1ac <_NVRAM_Store+0xe2>
			}																	/* MMP150219-1 - End */

			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1);
    a1b4:	7002      	lod	A, #2
    a1b6:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

#if _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE
			/* Check (NV)RAM page */
			NVRAM_LoadAll();
    a1ba:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
			if ( NVRAM_PageVerify( (uint16 *) C_ADDR_USERPAGE2) == FALSE )
    a1be:	72da 1100 	lod	A, #4352
    a1c2:	1776      	call	0xa0b0 <_NVRAM_PageVerify>
    a1c4:	ac00      	cmp	A, #0
    a1c6:	1d04      	jne	0xa1d0 <_NVRAM_Store+0x106>
			{
				/* Error */
				SetLastError( (uint8) C_ERR_NVRAM_PG21);
    a1c8:	72da 00f6 	lod	A, #246
    a1cc:	82db 9328 	callf	0x9328 <_SetLastError>
#endif /* _SUPPORT_NVRAM_RECOVER_CYCLE_ONCE */
		} while ( FALSE );
	}
#endif /* _SUPPORT_NVRAM_BACKUP */
	return ( u16Result );														/* MMP150219-1 */
} /* NVRAM_Store() */
    a1d0:	7201      	lod	A, [S-2]
    a1d2:	5405      	ret	#6

0000a1d4 <_NVRAM_LoadUserPage>:
 * void NVRAM_LoadUserPage
 *
 * Load user NVRAM page (NVRAM to User-RAM).
 * ****************************************************************************	*/
void NVRAM_LoadUserPage( void)
{
    a1d4:	5805      	inc	S, #6
	uint16 u16ErrorFlag;
	uint16 *pURAM = (uint16 *) &g_NvramUser;
    a1d6:	7ada 0058 	lod	Y, #88
    a1da:	5a05      	mov	[S-6], Y
	if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
	else
		pMRAM = (uint16 *) C_ADDR_USERPAGE1;
#else  /* (LINPROT == LIN2J_VALVE_GM) */
	uint16 *pMRAM = (uint16 *) C_ADDR_USERPAGE1;
    a1dc:	7eda 1000 	lod	X, #4096
    a1e0:	5e03      	mov	[S-4], X
#endif /* (LINPROT == LIN2J_VALVE_GM) */

	NVRAM_LoadAll();
    a1e2:	82db 599a 	callf	0x599a <_NVRAM_LoadAll>
	u16ErrorFlag = (VARIOUS_L & EENV_DED);										/* Double-bit error state */
    a1e6:	6280      	lod	AL, io:0x0 <__dp__>
    a1e8:	b6da 0080 	and	A, #128
	/* Copy NVRAM MirrorRAM-copy into NVRAM UserRAM (to allow byte/bit access) */
	do
	{
		*pURAM++ = *pMRAM++;
    a1ec:	7e05      	lod	X, [S-6]
    a1ee:	7a03      	lod	Y, [S-4]
    a1f0:	54c6      	movsw	[X++], [Y++]
    a1f2:	5a03      	mov	[S-4], Y
    a1f4:	5e05      	mov	[S-6], X
	} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    a1f6:	2eda 00c8 	cmp	X, #200
    a1fa:	1878      	jc	0xa1ec <_NVRAM_LoadUserPage+0x18>
	/* Check Double-bit NVRAM set, User-NVRAM structure-revision and User-NVRAM Checksum */
	if ( ((u16ErrorFlag == FALSE) && (VARIOUS_L & EENV_DED)) || (g_NvramUser.Revision != C_NVRAM_USER_REV) || (NVRAM_CRC8( FALSE) != 0xFF) || (g_NvramUser.ConfigurationID != CONFIGURATION_ID) )
    a1fc:	ac00      	cmp	A, #0
    a1fe:	1d03      	jne	0xa206 <_NVRAM_LoadUserPage+0x32>
    a200:	6280      	lod	AL, io:0x0 <__dp__>
    a202:	8c00      	cmp	AL, #0
    a204:	1a8b      	jsl	0xa21c <_NVRAM_LoadUserPage+0x48>
    a206:	6159      	lod	AL, dp:0x59 <_g_NvramUser+0x1>
    a208:	8c01      	cmp	AL, #1
    a20a:	1d08      	jne	0xa21c <_NVRAM_LoadUserPage+0x48>
    a20c:	7000      	lod	A, #0
    a20e:	1715      	call	0xa03a <_NVRAM_CRC8>
    a210:	8cff      	cmp	AL, #-1
    a212:	1d04      	jne	0xa21c <_NVRAM_LoadUserPage+0x48>
    a214:	7160      	lod	A, dp:0x60 <_g_NvramUser+0x8>
    a216:	aeda 5467 	cmp	A, #21607
    a21a:	192e      	je	0xa278 <_NVRAM_LoadUserPage+0xa4>
	/* Check Double-Bit Error NVRAM, Wrong revision or Invalid Checksum */
	if ( u16ErrorFlag )
	{
		/* Double-bit error or incorrect revision or Invalid CRC; Copy NVRAM user page 2 into UserRAM */
		/* Note: EENV_DED can't be cleared !! In case of first user-page DBE, a second-page DBE can't be detected */
		u16ErrorFlag = (VARIOUS_L & EENV_DED);
    a21c:	6280      	lod	AL, io:0x0 <__dp__>
    a21e:	b6da 0080 	and	A, #128
		if ( (((NVRAM_USER *) C_ADDR_USERPAGE1)->AppStatus & 0x80) ^ (((NVRAM_USER *) C_ADDR_USERPAGE2)->AppStatus & 0x80) )
			pMRAM = (uint16 *) C_ADDR_USERPAGE1;
		else
			pMRAM = (uint16 *) C_ADDR_USERPAGE2;
#else  /* (LINPROT == LIN2J_VALVE_GM) */
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    a222:	7ada 1100 	lod	Y, #4352
    a226:	5a03      	mov	[S-4], Y
#endif /* (LINPROT == LIN2J_VALVE_GM) */
		pURAM = (uint16 *) &g_NvramUser;
    a228:	7eda 0058 	lod	X, #88
    a22c:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    a22e:	7e05      	lod	X, [S-6]
    a230:	7a03      	lod	Y, [S-4]
    a232:	54c6      	movsw	[X++], [Y++]
    a234:	5a03      	mov	[S-4], Y
    a236:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    a238:	2eda 00c8 	cmp	X, #200
    a23c:	1878      	jc	0xa22e <_NVRAM_LoadUserPage+0x5a>
		if ( ((u16ErrorFlag != FALSE) || ((VARIOUS_L & EENV_DED) == 0)) && (g_NvramUser.Revision == C_NVRAM_USER_REV) && (NVRAM_CRC8( FALSE) == 0xFF) && (g_NvramUser.ConfigurationID == CONFIGURATION_ID) )
    a23e:	ac00      	cmp	A, #0
    a240:	1d03      	jne	0xa248 <_NVRAM_LoadUserPage+0x74>
    a242:	6280      	lod	AL, io:0x0 <__dp__>
    a244:	8c00      	cmp	AL, #0
    a246:	1aab      	jsl	0xa29e <_NVRAM_LoadUserPage+0xca>
    a248:	6159      	lod	AL, dp:0x59 <_g_NvramUser+0x1>
    a24a:	8c01      	cmp	AL, #1
    a24c:	1d28      	jne	0xa29e <_NVRAM_LoadUserPage+0xca>
    a24e:	7000      	lod	A, #0
    a250:	16f4      	call	0xa03a <_NVRAM_CRC8>
    a252:	8cff      	cmp	AL, #-1
    a254:	1d24      	jne	0xa29e <_NVRAM_LoadUserPage+0xca>
    a256:	7160      	lod	A, dp:0x60 <_g_NvramUser+0x8>
    a258:	aeda 5467 	cmp	A, #21607
    a25c:	1d20      	jne	0xa29e <_NVRAM_LoadUserPage+0xca>
		{
			/* Second User Page is correct; Rewrite 1st page */
			SetLastError( (uint8) C_ERR_INV_USERPAGE_1);
    a25e:	72da 00c0 	lod	A, #192
    a262:	82db 9328 	callf	0x9328 <_SetLastError>
			(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_1 | C_NVRAM_USER_PAGE_FORCE));
    a266:	7041      	lod	A, #65
    a268:	0005      	jmp	0xa274 <_NVRAM_LoadUserPage+0xa0>
		do
		{
			if ( *pURAM++ != *pMRAM++ )
			{
				/* Not equal! Rewrite 2nd page */
				SetLastError( (uint8) C_ERR_INV_USERPAGE_2);
    a26a:	72da 00c1 	lod	A, #193
    a26e:	82db 9328 	callf	0x9328 <_SetLastError>
				(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_2 | C_NVRAM_USER_PAGE_FORCE));
    a272:	7042      	lod	A, #66
    a274:	172a      	call	0xa0ca <_NVRAM_Store>
				break;
    a276:	5407      	ret	#8
	}
#if (LINPROT != LIN2J_VALVE_GM)
	else
	{
		/* First user page is correct; Check 2nd page against first page (bit-compare) */
		pMRAM = (uint16 *) C_ADDR_USERPAGE2;
    a278:	7ada 1100 	lod	Y, #4352
    a27c:	5a03      	mov	[S-4], Y
		pURAM = (uint16 *) &g_NvramUser;
    a27e:	7eda 0058 	lod	X, #88
    a282:	5e05      	mov	[S-6], X
		do
		{
			if ( *pURAM++ != *pMRAM++ )
    a284:	7a05      	lod	Y, [S-6]
    a286:	72d6      	lod	A, [Y++]
    a288:	5a05      	mov	[S-6], Y
    a28a:	7e03      	lod	X, [S-4]
    a28c:	2002      	add	X, #2
    a28e:	5e03      	mov	[S-4], X
    a290:	20fe      	add	X, #-2
    a292:	aede      	cmp	A, [X++]
    a294:	1d6a      	jne	0xa26a <_NVRAM_LoadUserPage+0x96>
				/* Not equal! Rewrite 2nd page */
				SetLastError( (uint8) C_ERR_INV_USERPAGE_2);
				(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_2 | C_NVRAM_USER_PAGE_FORCE));
				break;
			}
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    a296:	eeda 00c8 	cmp	Y, #200
    a29a:	1874      	jc	0xa284 <_NVRAM_LoadUserPage+0xb0>
    a29c:	5407      	ret	#8
#if (MOTOR_PARAMS == MP_NVRAM)
#if (_SUPPORT_CODE_PARAMS == FALSE)
	if ( u16ErrorFlag )
	{
		/* First and/or second page is corrupt; Log error and use default data */
		SetLastError( (uint8) C_ERR_INV_USERPAGE_BOTH);
    a29e:	72da 00c2 	lod	A, #194
    a2a2:	82db 9328 	callf	0x9328 <_SetLastError>
#else  /* (_SUPPORT_CODE_PARAMS == FALSE) */
		/* Always use hard-coded NVRAM value to be re-written in RAM-structure */
#endif /* (_SUPPORT_CODE_PARAMS == FALSE) */

		/* UniROM */
		pMRAM = (uint16 *) &defNvramUser;
    a2a6:	7ada ac48 	lod	Y, #44104
    a2aa:	5a03      	mov	[S-4], Y
		pURAM = (uint16 *) &g_NvramUser;
    a2ac:	7eda 0058 	lod	X, #88
    a2b0:	5e05      	mov	[S-6], X
		do
		{
			*pURAM++ = *pMRAM++;
    a2b2:	7e05      	lod	X, [S-6]
    a2b4:	7a03      	lod	Y, [S-4]
    a2b6:	54c6      	movsw	[X++], [Y++]
    a2b8:	5a03      	mov	[S-4], Y
    a2ba:	5e05      	mov	[S-6], X
		} while ( pURAM < (uint16 *) &g_NvramUser + (sizeof(g_NvramUser)/sizeof(uint16)) );
    a2bc:	2eda 00c8 	cmp	X, #200
    a2c0:	1878      	jc	0xa2b2 <_NVRAM_LoadUserPage+0xde>

#if (_SUPPORT_CODE_PARAMS == FALSE)
		{
			PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    a2c2:	7ada 1070 	lod	Y, #4208
    a2c6:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFF )				/* Check NVRAM User Page #1 Write-cycle counter CRC */
    a2c8:	54ca 0000 	pushw	#0
    a2cc:	72da 1070 	lod	A, #4208
    a2d0:	16cd      	call	0xa06c <_NVRAM_CountCRC8>
    a2d2:	5c01      	dec	S, #2
    a2d4:	8cff      	cmp	AL, #-1
    a2d6:	1904      	je	0xa2e0 <_NVRAM_LoadUserPage+0x10c>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0;						/* Clear program cycle-counter */
    a2d8:	7000      	lod	A, #0
    a2da:	7e01      	lod	X, [S-2]
    a2dc:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0;							/* Clear Error-log index & CRC */
    a2de:	52fa      	mov	[X+2], A
			}
			pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
    a2e0:	7ada 1170 	lod	Y, #4464
    a2e4:	5a01      	mov	[S-2], Y
			if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) != 0xFF )				/* Check NVRAM User Page #2 Write-cycle counter CRC */
    a2e6:	54ca 0000 	pushw	#0
    a2ea:	72da 1170 	lod	A, #4464
    a2ee:	16be      	call	0xa06c <_NVRAM_CountCRC8>
    a2f0:	5c01      	dec	S, #2
    a2f2:	8cff      	cmp	AL, #-1
    a2f4:	1904      	je	0xa2fe <_NVRAM_LoadUserPage+0x12a>
			{
				pNVERRLOG_UPG->NvramProgramCycleCount = 0;						/* Clear program cycle-counter */
    a2f6:	7000      	lod	A, #0
    a2f8:	7e01      	lod	X, [S-2]
    a2fa:	52f8      	mov	[X], A
				pNVERRLOG_UPG->ErrorLogIndex_CRC = 0;							/* Clear Error-log index & CRC */
    a2fc:	52fa      	mov	[X+2], A
			}
		}
		(void) NVRAM_Store( (uint16) (C_NVRAM_USER_PAGE_ALL | C_NVRAM_USER_PAGE_FORCE));	/* Write (both) user page(s) with default data */
    a2fe:	7043      	lod	A, #67
    a300:	07b9      	jmp	0xa274 <_NVRAM_LoadUserPage+0xa0>

0000a302 <_PlaceError>:
 *			u8ErrorCode: Error-code
 *	Post:	-
 *	Comments: Write error-code into NVRAM (16-bits words based)
 * ****************************************************************************	*/
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode)
{
    a302:	5801      	inc	S, #2
    a304:	7ee2      	lod	X, A
    a306:	6207      	lod	AL, [S-8]
    a308:	66e0      	lod	YL, AL
    a30a:	5cf6      	usex	Y
    a30c:	72f8      	lod	A, [X]
    a30e:	5201      	mov	[S-2], A
	if ( u16OddEven )
    a310:	7205      	lod	A, [S-6]
    a312:	1905      	je	0xa31e <_PlaceError+0x1c>
	{
		/* Odd index: MSB of uint16 */
		*pu16ErrorElement = (uint8)(*pu16ErrorElement) | (((uint16) u8ErrorCode) << 8);
    a314:	6201      	lod	AL, [S-2]
    a316:	5cf2      	usex	A
    a318:	6c00      	lod	YH, #0
    a31a:	7ae8      	swap	Y
    a31c:	0003      	jmp	0xa324 <_PlaceError+0x22>
	}
	else
	{
		/* Even index: LSB of uint16 */
		*pu16ErrorElement = (*pu16ErrorElement & 0xFF00) | ((uint16) u8ErrorCode);
    a31e:	7201      	lod	A, [S-2]
    a320:	b6da ff00 	and	A, #65280
    a324:	a6e6      	or	A, Y
    a326:	52f8      	mov	[X], A
    a328:	5403      	ret	#4

0000a32a <_NVRAM_LogError>:
 *	result is either 0 or 1, indicating which page should be written next-time.
 * Index at user-page #1/#2: 0-11: Empty/over-write index, FF: Full
 * If index user-page #1 is not 0xFF (Full), write error at page #1, otherwise page #2
 * ****************************************************************************	*/
uint16 NVRAM_LogError( uint8 u8ErrorCode)
{
    a32a:	5807      	inc	S, #8
    a32c:	5207      	mov	[S-8], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    a32e:	7000      	lod	A, #0
    a330:	5205      	mov	[S-6], A
	PNVRAM_ERRORLOG pNVERRLOG_UPG1 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
	PNVRAM_ERRORLOG pNVERRLOG_UPG2 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
	uint16 u16ErrorLogIdx1 = (uint8) (pNVERRLOG_UPG1->ErrorLogIndex_CRC);
    a332:	7ada 1070 	lod	Y, #4208
    a336:	72f2      	lod	A, [Y+2]
    a338:	5cf2      	usex	A
    a33a:	5203      	mov	[S-4], A
	uint16 u16ErrorLogIdx2 = (uint8) (pNVERRLOG_UPG2->ErrorLogIndex_CRC);
    a33c:	7ada 1170 	lod	Y, #4464
    a340:	72f2      	lod	A, [Y+2]
    a342:	5cf2      	usex	A
    a344:	5201      	mov	[S-2], A
	
	if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x00 )
    a346:	7203      	lod	A, [S-4]
    a348:	be01      	xor	A, [S-2]
    a34a:	1d03      	jne	0xa352 <_NVRAM_LogError+0x28>
	{
		u16ErrorLogIdx1 = 0x00;													/* Second UserPage last time written full; Start from index 0 at User Page #1 */
    a34c:	7000      	lod	A, #0
    a34e:	5203      	mov	[S-4], A
    a350:	0004      	jmp	0xa35a <_NVRAM_LogError+0x30>
	}
	else if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x01 )
    a352:	ac01      	cmp	A, #1
    a354:	1d02      	jne	0xa35a <_NVRAM_LogError+0x30>
	{
		u16ErrorLogIdx2 = 0x00;
    a356:	7800      	lod	Y, #0
    a358:	5a01      	mov	[S-2], Y
	}
	
	if ( (u16ErrorLogIdx1 & 0x80) == 0x00 )
    a35a:	6203      	lod	AL, [S-4]
    a35c:	8c00      	cmp	AL, #0
    a35e:	1e81      	jsge	0xa362 <_NVRAM_LogError+0x38>
    a360:	0046      	jmp	0xa3ee <_NVRAM_LogError+0xc4>
	{
		/* Store error on User-Page #1 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx1 >= C_MAX_ERRORS_PER_PAGE )							/* Check against array overflow */
    a362:	7a03      	lod	Y, [S-4]
    a364:	ec0b      	cmp	Y, #11
    a366:	1a02      	jule	0xa36c <_NVRAM_LogError+0x42>
		{
			u16ErrorLogIdx1 = 0;
    a368:	7000      	lod	A, #0
    a36a:	5203      	mov	[S-4], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG1, FALSE) == 0x00 )
    a36c:	54ca 0000 	pushw	#0
    a370:	72da 1070 	lod	A, #4208
    a374:	167b      	call	0xa06c <_NVRAM_CountCRC8>
    a376:	5c01      	dec	S, #2
    a378:	8c00      	cmp	AL, #0
    a37a:	1d05      	jne	0xa386 <_NVRAM_LogError+0x5c>
		{
			pNVERRLOG_UPG1->NvramProgramCycleCount++;
    a37c:	7ada 1070 	lod	Y, #4208
    a380:	72f0      	lod	A, [Y]
    a382:	a001      	add	A, #1
    a384:	0003      	jmp	0xa38c <_NVRAM_LogError+0x62>
		}
		else
		{
			pNVERRLOG_UPG1->NvramProgramCycleCount = 1U;
    a386:	7001      	lod	A, #1
    a388:	7ada 1070 	lod	Y, #4208
    a38c:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End */
		if ( pNVERRLOG_UPG1->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000) )
    a38e:	7ada 1070 	lod	Y, #4208
    a392:	72f0      	lod	A, [Y]
    a394:	aeda f9ff 	cmp	A, #63999
    a398:	1a01      	jule	0xa39c <_NVRAM_LogError+0x72>
    a39a:	0068      	jmp	0xa46c <_NVRAM_LogError+0x142>
		{
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG1, TRUE);
    a39c:	54ca 0001 	pushw	#1
    a3a0:	72da 1070 	lod	A, #4208
    a3a4:	1663      	call	0xa06c <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG1->ErrorLog[u16ErrorLogIdx1 >> 1]), u16ErrorLogIdx1 & 0x01, u8ErrorCode);
    a3a6:	7205      	lod	A, [S-6]
    a3a8:	b4fe      	and	A, #-2
    a3aa:	a2da 1074 	add	A, #4212
    a3ae:	7a09      	lod	Y, [S-10]
    a3b0:	5adf      	push	Y
    a3b2:	7a07      	lod	Y, [S-8]
    a3b4:	f401      	and	Y, #1
    a3b6:	5adf      	push	Y
    a3b8:	17a4      	call	0xa302 <_PlaceError>
			/* Update Error-log Index */
			u16ErrorLogIdx1++;
    a3ba:	7209      	lod	A, [S-10]
    a3bc:	a001      	add	A, #1
    a3be:	5209      	mov	[S-10], A
			if ( u16ErrorLogIdx1 >= C_MAX_ERRORS_PER_PAGE )
    a3c0:	5c05      	dec	S, #6
    a3c2:	ac0b      	cmp	A, #11
    a3c4:	1a0a      	jule	0xa3da <_NVRAM_LogError+0xb0>
			{
				/* Array full; Switch to page #2 */
				if ( u16ErrorLogIdx2 & 0x80 )
    a3c6:	6201      	lod	AL, [S-2]
    a3c8:	8c00      	cmp	AL, #0
    a3ca:	1e84      	jsge	0xa3d4 <_NVRAM_LogError+0xaa>
				{
					u16ErrorLogIdx1 = (u16ErrorLogIdx2 ^ 0x01);
    a3cc:	7a01      	lod	Y, [S-2]
    a3ce:	fc01      	xor	Y, #1
    a3d0:	5a03      	mov	[S-4], Y
    a3d2:	0003      	jmp	0xa3da <_NVRAM_LogError+0xb0>
				}
				else
				{
					u16ErrorLogIdx1 = 0xFF;
    a3d4:	72da 00ff 	lod	A, #255
    a3d8:	5203      	mov	[S-4], A
				}
			}
			pNVERRLOG_UPG1->ErrorLogIndex_CRC = ((pNVERRLOG_UPG1->ErrorLogIndex_CRC) & 0xFF00) | u16ErrorLogIdx1;
    a3da:	7ada 1070 	lod	Y, #4208
    a3de:	72f2      	lod	A, [Y+2]
    a3e0:	b6da ff00 	and	A, #65280
    a3e4:	a603      	or	A, [S-4]
    a3e6:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM1_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    a3e8:	72da 8000 	lod	A, #32768
    a3ec:	003c      	jmp	0xa466 <_NVRAM_LogError+0x13c>
		}
	}
	else 
	{
		/* Store error on User-Page #2 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx2 >= C_MAX_ERRORS_PER_PAGE )							/* Check against array overflow */
    a3ee:	7a01      	lod	Y, [S-2]
    a3f0:	ec0b      	cmp	Y, #11
    a3f2:	1a02      	jule	0xa3f8 <_NVRAM_LogError+0xce>
		{
			u16ErrorLogIdx2 = 0;
    a3f4:	7000      	lod	A, #0
    a3f6:	5201      	mov	[S-2], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG2, FALSE) == 0x00 )
    a3f8:	54ca 0000 	pushw	#0
    a3fc:	72da 1170 	lod	A, #4464
    a400:	1635      	call	0xa06c <_NVRAM_CountCRC8>
    a402:	5c01      	dec	S, #2
    a404:	8c00      	cmp	AL, #0
    a406:	1d05      	jne	0xa412 <_NVRAM_LogError+0xe8>
		{
			pNVERRLOG_UPG2->NvramProgramCycleCount++;
    a408:	7ada 1170 	lod	Y, #4464
    a40c:	72f0      	lod	A, [Y]
    a40e:	a001      	add	A, #1
    a410:	0003      	jmp	0xa418 <_NVRAM_LogError+0xee>
		}
		else
		{
			pNVERRLOG_UPG2->NvramProgramCycleCount = 1U;
    a412:	7001      	lod	A, #1
    a414:	7ada 1170 	lod	Y, #4464
    a418:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End  */
		if ( pNVERRLOG_UPG2->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000) )
    a41a:	7ada 1170 	lod	Y, #4464
    a41e:	72f0      	lod	A, [Y]
    a420:	aeda f9ff 	cmp	A, #63999
    a424:	1e23      	jug	0xa46c <_NVRAM_LogError+0x142>
		{
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG2, TRUE);
    a426:	54ca 0001 	pushw	#1
    a42a:	72da 1170 	lod	A, #4464
    a42e:	161e      	call	0xa06c <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG2->ErrorLog[u16ErrorLogIdx2 >> 1]), u16ErrorLogIdx2 & 0x01, u8ErrorCode);
    a430:	7203      	lod	A, [S-4]
    a432:	b4fe      	and	A, #-2
    a434:	a2da 1174 	add	A, #4468
    a438:	7a09      	lod	Y, [S-10]
    a43a:	5adf      	push	Y
    a43c:	7a05      	lod	Y, [S-6]
    a43e:	f401      	and	Y, #1
    a440:	5adf      	push	Y
    a442:	175f      	call	0xa302 <_PlaceError>
			/* Update Error-log Index */
			u16ErrorLogIdx2++;
    a444:	7207      	lod	A, [S-8]
    a446:	a001      	add	A, #1
    a448:	5207      	mov	[S-8], A
			if ( u16ErrorLogIdx2 >= C_MAX_ERRORS_PER_PAGE )
    a44a:	5c05      	dec	S, #6
    a44c:	ac0b      	cmp	A, #11
    a44e:	1a02      	jule	0xa454 <_NVRAM_LogError+0x12a>
			{
				/* Array full; Switch to page #1  */
				u16ErrorLogIdx2 = u16ErrorLogIdx1;
    a450:	7a03      	lod	Y, [S-4]
    a452:	5a01      	mov	[S-2], Y
			}
			pNVERRLOG_UPG2->ErrorLogIndex_CRC = ((pNVERRLOG_UPG2->ErrorLogIndex_CRC) & 0xFF00) | u16ErrorLogIdx2;
    a454:	7ada 1170 	lod	Y, #4464
    a458:	72f2      	lod	A, [Y+2]
    a45a:	b6da ff00 	and	A, #65280
    a45e:	a601      	or	A, [S-2]
    a460:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    a462:	72da 8002 	lod	A, #32770
    a466:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
    a46a:	0002      	jmp	0xa470 <_NVRAM_LogError+0x146>
		}
		else
		{
			u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
    a46c:	7001      	lod	A, #1
    a46e:	5205      	mov	[S-6], A
		}
	}
	return ( u16Result );														/* MMP150219-1 */
} /* End of NVRAM_LogError() */
    a470:	7205      	lod	A, [S-6]
    a472:	5409      	ret	#10

0000a474 <_NVRAM_GetLastError>:
 *
 *	Pre:	-
 *	Post:	(uint8) Last logged error-code
 * ****************************************************************************	*/
uint8 NVRAM_GetLastError( void)
{
    a474:	5803      	inc	S, #4
	uint16 u16ErrorLogIdx1, u16ErrorLogIdx2;
	uint8 u8Result = 0x00;														/* No error's */
    a476:	7000      	lod	A, #0
    a478:	5201      	mov	[S-2], A
	PNVRAM_ERRORLOG pNVERRLOG_UPG1 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    a47a:	7ada 1070 	lod	Y, #4208
	PNVRAM_ERRORLOG pNVERRLOG_UPG2 = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
	u16ErrorLogIdx1 = (uint8) (pNVERRLOG_UPG1->ErrorLogIndex_CRC);
    a47e:	72f2      	lod	A, [Y+2]
    a480:	5cf2      	usex	A
    a482:	7ee2      	lod	X, A
	u16ErrorLogIdx2 = (uint8) (pNVERRLOG_UPG2->ErrorLogIndex_CRC);
    a484:	7ada 1170 	lod	Y, #4464
    a488:	72f2      	lod	A, [Y+2]
    a48a:	5cf2      	usex	A
    a48c:	5203      	mov	[S-4], A

	if ( (u16ErrorLogIdx1 != 0x00) || (u16ErrorLogIdx2 != 0x00) )
    a48e:	2c00      	cmp	X, #0
    a490:	1d02      	jne	0xa496 <_NVRAM_GetLastError+0x22>
    a492:	ac00      	cmp	A, #0
    a494:	192b      	je	0xa4ec <_NVRAM_GetLastError+0x78>
	{
		if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x00 )
    a496:	7203      	lod	A, [S-4]
    a498:	beee      	xor	A, X
    a49a:	1d03      	jne	0xa4a2 <_NVRAM_GetLastError+0x2e>
		{
			u16ErrorLogIdx2 = C_MAX_ERRORS_PER_PAGE;								/* Second UserPage last time written full */
    a49c:	700c      	lod	A, #12
    a49e:	5203      	mov	[S-4], A
    a4a0:	0008      	jmp	0xa4b2 <_NVRAM_GetLastError+0x3e>
		}
		else if ( (u16ErrorLogIdx1 ^ u16ErrorLogIdx2) == 0x01 )
    a4a2:	ac01      	cmp	A, #1
    a4a4:	1905      	je	0xa4b0 <_NVRAM_GetLastError+0x3c>
		{
			u16ErrorLogIdx1 = C_MAX_ERRORS_PER_PAGE;								/* First UserPage last time written full, and Second UserPage is full */
		}
		else if ( (u16ErrorLogIdx1 == 0xFF) && (u16ErrorLogIdx2 == 0) )				/* MMP140218-1 */
    a4a6:	2eda 00ff 	cmp	X, #255
    a4aa:	1d03      	jne	0xa4b2 <_NVRAM_GetLastError+0x3e>
    a4ac:	7a03      	lod	Y, [S-4]
    a4ae:	1d01      	jne	0xa4b2 <_NVRAM_GetLastError+0x3e>
		{
			u16ErrorLogIdx1 = C_MAX_ERRORS_PER_PAGE;								/* First UserPage last time written full, and Second UserPage is empty */
    a4b0:	7c0c      	lod	X, #12
		}																			/* MMP140218-1 */

		if ( (u16ErrorLogIdx1 & 0x80) == 0x00 )
    a4b2:	72ee      	lod	A, X
    a4b4:	8c00      	cmp	AL, #0
    a4b6:	1a89      	jsl	0xa4ca <_NVRAM_GetLastError+0x56>
		{
			/* Get last error from User-Page #1 */
			u16ErrorLogIdx1--;
    a4b8:	20ff      	add	X, #-1
			{
				uint16 u16ErrorCodes = pNVERRLOG_UPG1->ErrorLog[u16ErrorLogIdx1 >> 1];
    a4ba:	72ee      	lod	A, X
    a4bc:	b4fe      	and	A, #-2
    a4be:	7ae2      	lod	Y, A
    a4c0:	e2da 1074 	add	Y, #4212
    a4c4:	7af0      	lod	Y, [Y]
				if ( u16ErrorLogIdx1 & 0x01 )
    a4c6:	72ee      	lod	A, X
    a4c8:	000a      	jmp	0xa4de <_NVRAM_GetLastError+0x6a>
			}
		}
		else
		{
			/* Get last error from User-Page #2 */
			u16ErrorLogIdx2--;
    a4ca:	7a03      	lod	Y, [S-4]
    a4cc:	e0ff      	add	Y, #-1
    a4ce:	5a03      	mov	[S-4], Y
			{
				uint16 u16ErrorCodes = pNVERRLOG_UPG2->ErrorLog[u16ErrorLogIdx2 >> 1];
    a4d0:	72e6      	lod	A, Y
    a4d2:	b4fe      	and	A, #-2
    a4d4:	7ae2      	lod	Y, A
    a4d6:	e2da 1174 	add	Y, #4468
    a4da:	7af0      	lod	Y, [Y]
				if ( u16ErrorLogIdx2 & 0x01 )
    a4dc:	7203      	lod	A, [S-4]
    a4de:	b401      	and	A, #1
    a4e0:	1903      	je	0xa4e8 <_NVRAM_GetLastError+0x74>
				{
					u8Result = (uint8) (u16ErrorCodes >> 8);
    a4e2:	6400      	lod	YL, #0
    a4e4:	7ae8      	swap	Y
    a4e6:	0001      	jmp	0xa4ea <_NVRAM_GetLastError+0x76>
				}
				else
				{
					u8Result = (uint8) u16ErrorCodes;
    a4e8:	5cf6      	usex	Y
    a4ea:	5a01      	mov	[S-2], Y
			}
		}
	}
	return( u8Result );

} /* End of NVRAM_GetLastError() */
    a4ec:	7201      	lod	A, [S-2]
    a4ee:	5405      	ret	#6

0000a4f0 <_NVRAM_ClearErrorLog>:
 *	Comments: Clear Application Error logging (in both User-NVRAM pages)
 * ****************************************************************************	*/
void NVRAM_ClearErrorLog( void)
{
	uint16 i;
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE1 + sizeof(NVRAM_USER));
    a4f0:	7ada 1070 	lod	Y, #4208
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00) | 0x00;	/* Set index at 0x00 */
    a4f4:	72f2      	lod	A, [Y+2]
    a4f6:	b6da ff00 	and	A, #65280
    a4fa:	52f2      	mov	[Y+2], A
    a4fc:	7ada 1074 	lod	Y, #4212
    a500:	7c06      	lod	X, #6
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE/2); i++ )
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000;
    a502:	7000      	lod	A, #0
    a504:	52d6      	mov	[Y++], A
    a506:	1bfd      	djnz	X, 0xa502 <_NVRAM_ClearErrorLog+0x12>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    a508:	54ca 0001 	pushw	#1
    a50c:	72da 1070 	lod	A, #4208
    a510:	15ad      	call	0xa06c <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM1_PAGE1);
    a512:	7000      	lod	A, #0
    a514:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>

	pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + sizeof(NVRAM_USER));
    a518:	7ada 1170 	lod	Y, #4464
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00) | 0x00;	/* Set index at 0x00 */
    a51c:	72f2      	lod	A, [Y+2]
    a51e:	b6da ff00 	and	A, #65280
    a522:	52f2      	mov	[Y+2], A
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE/2); i++ )
    a524:	5c01      	dec	S, #2
    a526:	7ada 1174 	lod	Y, #4468
    a52a:	7c06      	lod	X, #6
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000;
    a52c:	7000      	lod	A, #0
    a52e:	52d6      	mov	[Y++], A
    a530:	1bfd      	djnz	X, 0xa52c <_NVRAM_ClearErrorLog+0x3c>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    a532:	54ca 0001 	pushw	#1
    a536:	72da 1170 	lod	A, #4464
    a53a:	1598      	call	0xa06c <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM2_PAGE1);
    a53c:	7002      	lod	A, #2
    a53e:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
    a542:	5c01      	dec	S, #2
    a544:	5401      	ret

0000a546 <_NVRAM_StorePatch>:
 * C_ADDR_PATCHPAGE+0x7A:0x7B:	PATCH3_A
 *
 * ****************************************************************************	*/
void NVRAM_StorePatch( void)
{
	NVRAM_SavePage( NVRAM1_PAGE2);
    a546:	7001      	lod	A, #1
    a548:	82db 5a00 	callf	0x5a00 <_NVRAM_SavePage>
	NVRAM_LoadUserPage();
    a54c:	1643      	call	0xa1d4 <_NVRAM_LoadUserPage>
    a54e:	5401      	ret

0000a550 <_NVRAM_MlxCalibrationAreaCheck>:
 *	Post:	-
 * Comments: Check Melexis NVRAM-page gain-factors (non-zero)
 * ****************************************************************************	*/
void NVRAM_MlxCalibrationAreaCheck( void)
{
	if ( (EE_GLAA == 0) ||														/* Auto addressing gain calibration */
    a550:	72d8 11d6 	lod	A, 0x11d6 <__ep__+0x1d6>
    a554:	1913      	je	0xa57c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    a556:	72d8 11d8 	lod	A, 0x11d8 <__ep__+0x1d8>
    a55a:	1910      	je	0xa57c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    a55c:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    a560:	b6da 00ff 	and	A, #255
    a564:	aeda ff00 	cmp	A, #65280
    a568:	1909      	je	0xa57c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    a56a:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    a56e:	6000      	lod	AL, #0
    a570:	72e4      	swap	A
    a572:	1904      	je	0xa57c <_NVRAM_MlxCalibrationAreaCheck+0x2c>
    a574:	72d8 11ca 	lod	A, 0x11ca <__ep__+0x1ca>
    a578:	8c00      	cmp	AL, #0
    a57a:	1d04      	jne	0xa584 <_NVRAM_MlxCalibrationAreaCheck+0x34>
		 (EE_GDMCMAA == 0) ||													/* Common Mode Rejection factor */
		 (EE_GMCURR == 0) ||													/* CGAINCAL_FLT (Current sensor filter gain) */
		 (EE_GVOLTAGE == 0) ||													/* VGAINCAL (supply sensor filter gain) */
		 (EE_GTEMP == 0) )														/* Temperature Gain */
	{
		SetLastError( (uint8) C_ERR_NVRAM_MLX_CAL_GN);
    a57c:	72da 00cf 	lod	A, #207
    a580:	82db 9328 	callf	0x9328 <_SetLastError>
    a584:	5401      	ret

0000a586 <_PID_Init>:

/* ***
 * PID_Init()
 * ***/
void PID_Init( void)
{
    a586:	5813      	inc	S, #20
	/* MMP141209-1: Convert [mA] to [ADC-lsb] */
	uint16 u16MCurrgain = EE_GMCURR;
    a588:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    a58c:	b6da 00ff 	and	A, #255
    a590:	7ee2      	lod	X, A
    a592:	22da 0100 	add	X, #256
	g_u16PidHoldingThreshold = NVRAM_HOLDING_CURR_LEVEL;
    a596:	61a6      	lod	AL, dp:0xa6 <__data_size+0x44>
    a598:	5cf2      	usex	A
    a59a:	52d8 0360 	mov	0x360 <_g_u16PidHoldingThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a59e:	7ada 0080 	lod	Y, #128
    a5a2:	4821      	mulu	YA, A, Y
    a5a4:	4c63      	divu	YA, X
    a5a6:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a5a8:	52d8 0364 	mov	0x364 <_g_u16PidHoldingThresholdADC>, A
	g_u16PidHoldingThresholdADC = muldivU16_U16byU16byU16( g_u16PidHoldingThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1 */
	g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL;
    a5ac:	61a7      	lod	AL, dp:0xa7 <__data_size+0x45>
    a5ae:	4422      	asl	A
    a5b0:	b6da 01fe 	and	A, #510
    a5b4:	52d8 035c 	mov	0x35c <_g_u16PidRunningThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a5b8:	7ada 0080 	lod	Y, #128
    a5bc:	4821      	mulu	YA, A, Y
    a5be:	4c63      	divu	YA, X
    a5c0:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a5c2:	52d8 035e 	mov	0x35e <_g_u16PidRunningThresholdADC>, A
	g_u16PidRunningThresholdADC = muldivU16_U16byU16byU16( g_u16PidRunningThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1/MMP131219-1 */
	g_u16MotorRefVoltage = NVRAM_VSUP_REF;
    a5c6:	6189      	lod	AL, dp:0x89 <__data_size+0x27>
    a5c8:	5cf2      	usex	A
    a5ca:	4872 0019 	muls	A, A, #25
    a5ce:	4432      	lsr	A
    a5d0:	5205      	mov	[S-6], A
    a5d2:	52d8 014c 	mov	0x14c <_g_u16MotorRefVoltage>, A
    a5d6:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    a5da:	6000      	lod	AL, #0
    a5dc:	72e4      	swap	A
    a5de:	5203      	mov	[S-4], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a5e0:	7040      	lod	A, #64
    a5e2:	7a05      	lod	Y, [S-6]
    a5e4:	7e03      	lod	X, [S-4]
    a5e6:	4821      	mulu	YA, A, Y
    a5e8:	4c63      	divu	YA, X
    a5ea:	4c63      	divu	YA, X
    a5ec:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a5ee:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    a5f2:	5ce2      	ssex	A
    a5f4:	a201      	add	A, [S-2]
    a5f6:	52d8 014a 	mov	0x14a <_l_u16MotorRefVoltageADC>, A
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GVOLTAGE) + EE_OVOLTAGE;
#else  /* _SUPPORT_VSMFILTERED */
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GADC) + EE_OADC;
#endif /* _SUPPORT_VSMFILTERED */

	l_u16MinCorrectionRatio = NVRAM_MIN_CORR_RATIO;								/* MMP150509-2 */
    a5fa:	61bc      	lod	AL, dp:0xbc <__bss_dp_size+0xc>
    a5fc:	5cf2      	usex	A
    a5fe:	4812 0576 	muls	D, A, #1398
    a602:	7aef      	lod	Y, S
    a604:	e0f2      	add	Y, #-14
    a606:	4c85      	mov	[Y], D
    a608:	720d      	lod	A, [S-14]
    a60a:	7a0b      	lod	Y, [S-12]
    a60c:	48a3      	lsr	YA, #4
    a60e:	52d8 0366 	mov	0x366 <_l_u16MinCorrectionRatio>, A
	l_u16MaxCorrectionRatio = NVRAM_MAX_CORR_RATIO;								/* MMP150509-2 */
    a612:	61bd      	lod	AL, dp:0xbd <__bss_dp_size+0xd>
    a614:	5cf2      	usex	A
    a616:	a001      	add	A, #1
    a618:	4812 0576 	muls	D, A, #1398
    a61c:	7aef      	lod	Y, S
    a61e:	e0f6      	add	Y, #-10
    a620:	4c85      	mov	[Y], D
    a622:	7209      	lod	A, [S-10]
    a624:	7a07      	lod	Y, [S-8]
    a626:	48a3      	lsr	YA, #4
    a628:	52d8 0368 	mov	0x368 <_l_u16MaxCorrectionRatio>, A
    a62c:	5415      	ret	#22

0000a62e <_VoltageCorrection>:
 *
 *	Compensate Motor PWM Duty Cycle for voltage changes
 * Performance: 7.5us @ 20Mz
 * ***/
void VoltageCorrection( void)
{
    a62e:	5801      	inc	S, #2

#define ADC_SETTING (uint16)(((2U*PLL_freq)/(1000000U*2*CYCLES_PER_INSTR)) + 1)	/* 2us: 2us*PLL-freq/(10000000us/s * #cycles/instruction) */

static INLINE uint16 GetRawVsupplyMotor( void)
{
extern T_ADC_MOTORRUN_STEPPER4 volatile g_AdcMotorRunStepper4;					/* ADC results Stepper mode */
    a630:	7ed8 0298 	lod	X, 0x298 <_g_AdcMotorRunStepper4+0x6>
	uint16 u16MotorVoltageADC = GetRawVsupplyMotor();
#if _DEBUG_VOLTAGE_COMPENSATION
	l_ai16MotorVolt[u16MotorVoltIdx] = g_i16MotorVoltage;
	u16MotorVoltIdx = (u16MotorVoltIdx + 1) & (SZ_MOTOR_VOLT_COMP - 1);
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	if ( (u16MotorVoltageADC > 0) && (l_u16MotorRefVoltageADC > 0) )
    a634:	1920      	je	0xa676 <_VoltageCorrection+0x48>
    a636:	7ad8 014a 	lod	Y, 0x14a <_l_u16MotorRefVoltageADC>
    a63a:	191d      	je	0xa676 <_VoltageCorrection+0x48>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    a63c:	72d8 035a 	lod	A, 0x35a <_g_u16PidCtrlRatio>
    uint32 result;

    __asm__ __volatile__ (
    a640:	4801      	mulu	D, A, Y
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a642:	4c80      	mov	YA, D
    a644:	4c63      	divu	YA, X
    a646:	4c63      	divu	YA, X
    a648:	7ee2      	lod	X, A
	{
		/* Correct Motor PWM duty cycle instantly based on change of supply voltage */
		uint16 u16NewCorrectionRatio = divU16_U32byU16( mulU32_U16byU16( g_u16PidCtrlRatio, l_u16MotorRefVoltageADC), u16MotorVoltageADC);
		if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a64a:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a64c:	b401      	and	A, #1
    a64e:	1909      	je	0xa662 <_VoltageCorrection+0x34>
		{
			if ( u16NewCorrectionRatio < l_u16MinCorrectionRatio )
    a650:	72d8 0366 	lod	A, 0x366 <_l_u16MinCorrectionRatio>
    a654:	2ee2      	cmp	X, A
    a656:	180c      	jc	0xa670 <_VoltageCorrection+0x42>
			{
				/* Underflow */
				u16NewCorrectionRatio = l_u16MinCorrectionRatio;
			}
			else if ( u16NewCorrectionRatio > l_u16MaxPidCtrlRatio )
    a658:	72d8 0362 	lod	A, 0x362 <_l_u16MaxPidCtrlRatio>
    a65c:	2ee2      	cmp	X, A
    a65e:	1a09      	jule	0xa672 <_VoltageCorrection+0x44>
    a660:	0007      	jmp	0xa670 <_VoltageCorrection+0x42>
			{
				/* Overflow */
				u16NewCorrectionRatio = l_u16MaxPidCtrlRatio;
			}
		}
		else if ( u16NewCorrectionRatio < NVRAM_MIN_HOLDCORR_RATIO )
    a662:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    a664:	5cf2      	usex	A
    a666:	4832 0576 	muls	YA, A, #1398
    a66a:	48a3      	lsr	YA, #4
    a66c:	2ee2      	cmp	X, A
    a66e:	1c01      	jnc	0xa672 <_VoltageCorrection+0x44>
		{
			/* Underflow */
			u16NewCorrectionRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a670:	7ee2      	lod	X, A
		}
		g_u16CorrectionRatio = u16NewCorrectionRatio;
    a672:	5d4c      	mov	dp:0x4c <_g_u16CorrectionRatio>, X
    a674:	5403      	ret	#4
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    a676:	72d8 035a 	lod	A, 0x35a <_g_u16PidCtrlRatio>
    a67a:	514c      	mov	dp:0x4c <_g_u16CorrectionRatio>, A
    a67c:	5403      	ret	#4

0000a67e <_PID_Control>:
 *	DC: Motor PWM Duty Cycle; 
 *	Stepper: current-control;
 *	BEMF: speed-control
 * ***/
void PID_Control( void)
{
    a67e:	5801      	inc	S, #2
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) ||
    a680:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a682:	b401      	and	A, #1
    a684:	1d07      	jne	0xa694 <_PID_Control+0x16>
    a686:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a688:	1901      	je	0xa68c <_PID_Control+0xe>
    a68a:	0095      	jmp	0xa7b6 <_PID_Control+0x138>
    a68c:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    a690:	1d01      	jne	0xa694 <_PID_Control+0x16>
    a692:	0091      	jmp	0xa7b6 <_PID_Control+0x138>
			 ((g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE)) ) 	/* Stop-mode & holding-current required */
	{
		/* Running-mode and NOT stall-mode "B" */
		if ( (((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) != 0) &&
    a694:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a696:	b401      	and	A, #1
    a698:	1906      	je	0xa6a6 <_PID_Control+0x28>
    a69a:	61b5      	lod	AL, dp:0xb5 <__bss_dp_size+0x5>
    a69c:	1904      	je	0xa6a6 <_PID_Control+0x28>
    a69e:	5cf2      	usex	A
    a6a0:	aed8 0150 	cmp	A, 0x150 <_g_u16PID_CtrlCounter>
    a6a4:	1a0f      	jule	0xa6c4 <_PID_Control+0x46>
    a6a6:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a6a8:	1901      	je	0xa6ac <_PID_Control+0x2e>
    a6aa:	007d      	jmp	0xa7a6 <_PID_Control+0x128>
    a6ac:	61b6      	lod	AL, dp:0xb6 <__bss_dp_size+0x6>
    a6ae:	44a2      	asl	A, #2
    a6b0:	7ae2      	lod	Y, A
    a6b2:	f6da 03fc 	and	Y, #1020
    a6b6:	1d01      	jne	0xa6ba <_PID_Control+0x3c>
    a6b8:	0076      	jmp	0xa7a6 <_PID_Control+0x128>
    a6ba:	72d8 0150 	lod	A, 0x150 <_g_u16PID_CtrlCounter>
    a6be:	aee6      	cmp	A, Y
    a6c0:	1c01      	jnc	0xa6c4 <_PID_Control+0x46>
    a6c2:	0071      	jmp	0xa7a6 <_PID_Control+0x128>
			int16 i16PID_Ipart;
			int16 i16PID_Ppart;
			uint16 u16PidCtrlRatio;

			/* Current Control */
			uint16 u16MotorCurrentLPFFraction = ((g_u16MotorCurrentLPFx64 + 32) >> 6);	/* MMP140911-1 */
    a6c4:	7156      	lod	A, dp:0x56 <_g_u16MotorCurrentLPFx64>
    a6c6:	7ae2      	lod	Y, A
    a6c8:	e020      	add	Y, #32
    a6ca:	44b6      	lsr	Y, #2
    a6cc:	44b6      	lsr	Y, #2
    a6ce:	44b6      	lsr	Y, #2
			if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a6d0:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a6d2:	b401      	and	A, #1
    a6d4:	1909      	je	0xa6e8 <_PID_Control+0x6a>
			{
				i16ControlError = (int16) (g_u16PidRunningThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    a6d6:	72d8 035e 	lod	A, 0x35e <_g_u16PidRunningThresholdADC>
    a6da:	7ee2      	lod	X, A
    a6dc:	2ae6      	sub	X, Y
				l_u16MaxPidCtrlRatio = l_u16MaxCorrectionRatio;
    a6de:	72d8 0368 	lod	A, 0x368 <_l_u16MaxCorrectionRatio>
    a6e2:	52d8 0362 	mov	0x362 <_l_u16MaxPidCtrlRatio>, A
    a6e6:	0004      	jmp	0xa6f0 <_PID_Control+0x72>
			}
			else
			{
				i16ControlError = (int16) (g_u16PidHoldingThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    a6e8:	72d8 0364 	lod	A, 0x364 <_g_u16PidHoldingThresholdADC>
    a6ec:	7ee2      	lod	X, A
    a6ee:	2ae6      	sub	X, Y
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a6f0:	7aee      	lod	Y, X
    a6f2:	ead8 0152 	sub	Y, 0x152 <_g_i16PID_E>
    a6f6:	61b9      	lod	AL, dp:0xb9 <__bss_dp_size+0x9>
    a6f8:	5cf2      	usex	A
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a6fa:	4831      	muls	YA, A, Y
    a6fc:	48b5      	asr	YA, #6
    a6fe:	b000      	adc	A, #0
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a700:	52d8 0154 	mov	0x154 <_g_i16PID_D>, A
			}

			/* Derivative-part */
			g_i16PID_D = mulI16_I16byI16RndDiv64( (i16ControlError - g_i16PID_E), NVRAM_PID_COEF_D);
			g_i16PID_E = i16ControlError;
    a704:	5ed8 0152 	mov	0x152 <_g_i16PID_E>, X
    a708:	61b8      	lod	AL, dp:0xb8 <__bss_dp_size+0x8>
    a70a:	66e0      	lod	YL, AL
    a70c:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a70e:	72e6      	lod	A, Y
    a710:	4833      	muls	YA, A, X
    a712:	48b5      	asr	YA, #6
    a714:	b000      	adc	A, #0
    a716:	5201      	mov	[S-2], A
			/* Integral-part */
			i16PID_Ipart = mulI16_I16byI16RndDiv64( i16ControlError, NVRAM_PID_COEF_I);
			if ( (i16PID_Ipart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ipart)) )
    a718:	ac00      	cmp	A, #0
    a71a:	1e86      	jsge	0xa728 <_PID_Control+0xaa>
    a71c:	7201      	lod	A, [S-2]
    a71e:	5cc2      	neg	A
    a720:	adc8      	cmp	A, dp:0xc8 <_g_u16PID_I>
    a722:	1a02      	jule	0xa728 <_PID_Control+0xaa>
			{
				g_u16PID_I = 0;
    a724:	7000      	lod	A, #0
    a726:	0002      	jmp	0xa72c <_PID_Control+0xae>
			}
			else
			{
				g_u16PID_I = (uint16) (g_u16PID_I + i16PID_Ipart);
    a728:	71c8      	lod	A, dp:0xc8 <_g_u16PID_I>
    a72a:	a201      	add	A, [S-2]
    a72c:	51c8      	mov	dp:0xc8 <_g_u16PID_I>, A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    a72e:	61b7      	lod	AL, dp:0xb7 <__bss_dp_size+0x7>
    a730:	66e0      	lod	YL, AL
    a732:	5cf6      	usex	Y
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    a734:	72e6      	lod	A, Y
    a736:	4833      	muls	YA, A, X
    a738:	48b5      	asr	YA, #6
    a73a:	b000      	adc	A, #0
    a73c:	7ee2      	lod	X, A
			}
			/* Proportional-part */
			i16PID_Ppart = mulI16_I16byI16RndDiv64( i16ControlError, (int16) NVRAM_PID_COEF_P);
			if ( (i16PID_Ppart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ppart)) )
    a73e:	ac00      	cmp	A, #0
    a740:	1e92      	jsge	0xa766 <_PID_Control+0xe8>
    a742:	5cc2      	neg	A
    a744:	adc8      	cmp	A, dp:0xc8 <_g_u16PID_I>
    a746:	1a0f      	jule	0xa766 <_PID_Control+0xe8>
			{
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a748:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a74a:	b401      	and	A, #1
    a74c:	1903      	je	0xa754 <_PID_Control+0xd6>
				{
					u16PidCtrlRatio = l_u16MinCorrectionRatio;
    a74e:	7ed8 0366 	lod	X, 0x366 <_l_u16MinCorrectionRatio>
    a752:	0006      	jmp	0xa760 <_PID_Control+0xe2>
				}
				else
				{
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a754:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    a756:	5cf2      	usex	A
    a758:	4832 0576 	muls	YA, A, #1398
    a75c:	48a3      	lsr	YA, #4
    a75e:	7ee2      	lod	X, A
				}
				g_u16PID_I = 0;
    a760:	7000      	lod	A, #0
    a762:	51c8      	mov	dp:0xc8 <_g_u16PID_I>, A
    a764:	001b      	jmp	0xa79c <_PID_Control+0x11e>
			}
			else
			{
				u16PidCtrlRatio = (uint16) (g_u16PID_I + i16PID_Ppart + g_i16PID_D);
    a766:	71c8      	lod	A, dp:0xc8 <_g_u16PID_I>
    a768:	a2ee      	add	A, X
    a76a:	7ee2      	lod	X, A
    a76c:	22d8 0154 	add	X, 0x154 <_g_i16PID_D>
				if ( g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING )
    a770:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a772:	b401      	and	A, #1
    a774:	190b      	je	0xa78c <_PID_Control+0x10e>
				{
					if ( u16PidCtrlRatio < l_u16MinCorrectionRatio )
    a776:	72d8 0366 	lod	A, 0x366 <_l_u16MinCorrectionRatio>
    a77a:	2ee2      	cmp	X, A
    a77c:	180e      	jc	0xa79a <_PID_Control+0x11c>
					{
						/* Underflow */
						u16PidCtrlRatio = l_u16MinCorrectionRatio;
					}
					else if ( u16PidCtrlRatio >= l_u16MaxPidCtrlRatio )
    a77e:	72d8 0362 	lod	A, 0x362 <_l_u16MaxPidCtrlRatio>
    a782:	2ee2      	cmp	X, A
    a784:	180b      	jc	0xa79c <_PID_Control+0x11e>
					{
						/* Overflow */
						u16PidCtrlRatio = l_u16MaxPidCtrlRatio;
    a786:	7ee2      	lod	X, A
						g_u16PID_I = u16PidCtrlRatio;								/* MMP140617-1 */
    a788:	51c8      	mov	dp:0xc8 <_g_u16PID_I>, A
    a78a:	0008      	jmp	0xa79c <_PID_Control+0x11e>
					}
				}
				else if ( u16PidCtrlRatio < NVRAM_MIN_HOLDCORR_RATIO )
    a78c:	61bb      	lod	AL, dp:0xbb <__bss_dp_size+0xb>
    a78e:	5cf2      	usex	A
    a790:	4832 0576 	muls	YA, A, #1398
    a794:	48a3      	lsr	YA, #4
    a796:	2ee2      	cmp	X, A
    a798:	1c01      	jnc	0xa79c <_PID_Control+0x11e>
				{
					/* Underflow */
					u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    a79a:	7ee2      	lod	X, A
				}
			}
			g_u16PidCtrlRatio = u16PidCtrlRatio;
    a79c:	5ed8 035a 	mov	0x35a <_g_u16PidCtrlRatio>, X
			g_u16PID_CtrlCounter = 0;
    a7a0:	7000      	lod	A, #0
    a7a2:	52d8 0150 	mov	0x150 <_g_u16PID_CtrlCounter>, A
		}
		VoltageCorrection();
    a7a6:	1743      	call	0xa62e <_VoltageCorrection>

		/* Update motor-driver PWM duty-cycle in case of holding-mode with coil-current */

		/* Stop-mode & holding-current required */
		if ( (g_e8MotorStatusMode == (uint8) C_MOTOR_STATUS_STOP) && (g_u8MotorHoldingCurrState != FALSE) )
    a7a8:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a7aa:	1d05      	jne	0xa7b6 <_PID_Control+0x138>
    a7ac:	62d8 0148 	lod	AL, 0x148 <_g_u8MotorHoldingCurrState>
    a7b0:	1902      	je	0xa7b6 <_PID_Control+0x138>
		{
			MotorDriver_4PhaseStepper();
    a7b2:	82db 9972 	callf	0x9972 <_MotorDriver_4PhaseStepper>
    a7b6:	5403      	ret	#4

0000a7b8 <_ThresholdControl>:
 *	DC-Motor: Motor Power
 *	Stepper: Current Threshold Control
 *	BEMF: Nothing
 * ***/
void ThresholdControl( void)
{
    a7b8:	583b      	inc	S, #60
	if ( ((g_e8MotorStatusMode & (uint8) C_MOTOR_STATUS_RUNNING) == 0) && (g_u16PID_ThrshldCtrlCounter >= NVRAM_PID_THRSHLDCTRL_PER) )
    a7ba:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a7bc:	66e0      	lod	YL, AL
    a7be:	f401      	and	Y, #1
    a7c0:	1901      	je	0xa7c4 <_ThresholdControl+0xc>
    a7c2:	0099      	jmp	0xa8f6 <_ThresholdControl+0x13e>
    a7c4:	69ba      	lod	AH, dp:0xba <__bss_dp_size+0xa>
    a7c6:	6000      	lod	AL, #0
    a7c8:	4472      	asr	A
    a7ca:	aed8 014e 	cmp	A, 0x14e <_g_u16PID_ThrshldCtrlCounter>
    a7ce:	1a01      	jule	0xa7d2 <_ThresholdControl+0x1a>
    a7d0:	0092      	jmp	0xa8f6 <_ThresholdControl+0x13e>
	{
		uint16 u16CurrThrshldRatio;
		int16 i16TemperatureBgn = NVRAM_CURRTHRSHLD_TEMP_1;
    a7d2:	65ac      	lod	YL, dp:0xac <__data_size+0x4a>
    a7d4:	5cf6      	usex	Y
    a7d6:	7ee6      	lod	X, Y
    a7d8:	e0c4      	add	Y, #-60
    a7da:	5a35      	mov	[S-54], Y
		uint16 u16CurrThrshldRatioBgn = NVRAM_CURRTHRSHLD_RATIO_1;
    a7dc:	61ad      	lod	AL, dp:0xad <__data_size+0x4b>
    a7de:	5cf2      	usex	A
    a7e0:	5233      	mov	[S-52], A

		g_u16PID_ThrshldCtrlCounter = 0;
    a7e2:	7800      	lod	Y, #0
    a7e4:	5ad8 014e 	mov	0x14e <_g_u16PID_ThrshldCtrlCounter>, Y

#if _SUPPORT_AMBIENT_TEMP
		if ( g_i16AmbjTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( g_i16ChipTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
    a7e8:	20c2      	add	X, #-62
    a7ea:	5e31      	mov	[S-50], X
    a7ec:	7d22      	lod	X, dp:0x22 <__data_dp_size>
    a7ee:	61b4      	lod	AL, dp:0xb4 <__bss_dp_size+0x4>
    a7f0:	4207      	mov	[S-8], AL
    a7f2:	7ad8 0360 	lod	Y, 0x360 <_g_u16PidHoldingThreshold>
    a7f6:	5a05      	mov	[S-6], Y
    a7f8:	72d8 035c 	lod	A, 0x35c <_g_u16PidRunningThreshold>
    a7fc:	5203      	mov	[S-4], A
    a7fe:	2e31      	cmp	X, [S-50]
    a800:	1e86      	jsge	0xa80e <_ThresholdControl+0x56>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( NVRAM_CURRTHRSHLD_ZONE_1 != 0 )
    a802:	6607      	lod	YL, [S-8]
    a804:	f401      	and	Y, #1
    a806:	1d01      	jne	0xa80a <_ThresholdControl+0x52>
    a808:	005f      	jmp	0xa8c8 <_ThresholdControl+0x110>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;					/* Same as point _1 */
    a80a:	7233      	lod	A, [S-52]
    a80c:	005b      	jmp	0xa8c4 <_ThresholdControl+0x10c>
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
			}
		}
		else
		{
			uint8 u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_2;				/* Get current threshold compensation-type */
    a80e:	6207      	lod	AL, [S-8]
    a810:	4430      	lsr	AL
    a812:	66e0      	lod	YL, AL
    a814:	f403      	and	Y, #3
    a816:	5a2d      	mov	[S-46], Y
			uint16 u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_2;			/* Get zone end point (_2) */
    a818:	65af      	lod	YL, dp:0xaf <__data_size+0x4d>
    a81a:	5cf6      	usex	Y
    a81c:	5a29      	mov	[S-42], Y
			int16 i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_2;						
    a81e:	65ae      	lod	YL, dp:0xae <__data_size+0x4c>
    a820:	5cf6      	usex	Y
    a822:	7ee6      	lod	X, Y
    a824:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
			if ( g_i16AmbjTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
			if ( g_i16ChipTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
    a826:	7122      	lod	A, dp:0x22 <__data_dp_size>
    a828:	aeee      	cmp	A, X
    a82a:	1b2f      	jsle	0xa88a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
			{
				i16TemperatureBgn = i16TemperatureEnd;							/* Next zone; begin point (_2) */
    a82c:	5e35      	mov	[S-54], X
				u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    a82e:	7a29      	lod	Y, [S-42]
    a830:	5a33      	mov	[S-52], Y
				u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_3;
    a832:	6207      	lod	AL, [S-8]
    a834:	44b0      	lsr	AL, #2
    a836:	4430      	lsr	AL
    a838:	66e0      	lod	YL, AL
    a83a:	f403      	and	Y, #3
    a83c:	5a2d      	mov	[S-46], Y
				u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_3;				/* Get zone end point (_3) */
    a83e:	65b1      	lod	YL, dp:0xb1 <__bss_dp_size+0x1>
    a840:	5cf6      	usex	Y
    a842:	5a29      	mov	[S-42], Y
				i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_3;
    a844:	65b0      	lod	YL, dp:0xb0 <__bss_dp_size>
    a846:	5cf6      	usex	Y
    a848:	7ee6      	lod	X, Y
    a84a:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
				if ( g_i16AmbjTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
				if ( g_i16ChipTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
    a84c:	7122      	lod	A, dp:0x22 <__data_dp_size>
    a84e:	aeee      	cmp	A, X
    a850:	1b1c      	jsle	0xa88a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
				{
					i16TemperatureBgn = i16TemperatureEnd;						/* Next zone; begin point (_3) */
    a852:	5e35      	mov	[S-54], X
					u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
    a854:	7a29      	lod	Y, [S-42]
    a856:	5a33      	mov	[S-52], Y
					u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_4;
    a858:	6207      	lod	AL, [S-8]
    a85a:	44b0      	lsr	AL, #2
    a85c:	44b0      	lsr	AL, #2
    a85e:	4430      	lsr	AL
    a860:	66e0      	lod	YL, AL
    a862:	f403      	and	Y, #3
    a864:	5a2d      	mov	[S-46], Y
					u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_4;			/* Get zone end point (_3) */
    a866:	65b3      	lod	YL, dp:0xb3 <__bss_dp_size+0x3>
    a868:	5cf6      	usex	Y
    a86a:	5a29      	mov	[S-42], Y
					i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_4;
    a86c:	65b2      	lod	YL, dp:0xb2 <__bss_dp_size+0x2>
    a86e:	5cf6      	usex	Y
    a870:	7ee6      	lod	X, Y
    a872:	20c4      	add	X, #-60
#if _SUPPORT_AMBIENT_TEMP
					if ( g_i16AmbjTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
					if ( g_i16ChipTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
    a874:	7122      	lod	A, dp:0x22 <__data_dp_size>
    a876:	aeee      	cmp	A, X
    a878:	1b08      	jsle	0xa88a <_ThresholdControl+0xd2>
#endif /* _SUPPORT_AMBIENT_TEMP */
					{
						u8CurrThrshldCtrlType = NVRAM_CURRTHRSHLD_ZONE_5;
    a87a:	6207      	lod	AL, [S-8]
    a87c:	4440      	rl	AL
    a87e:	9401      	and	AL, #1
    a880:	66e0      	lod	YL, AL
    a882:	5cf6      	usex	Y
    a884:	62e8      	lod	AL, YL
    a886:	5cf2      	usex	A
    a888:	522d      	mov	[S-46], A
					}
				}
			}
			if ( u8CurrThrshldCtrlType == 1 )
    a88a:	622d      	lod	AL, [S-46]
    a88c:	8c01      	cmp	AL, #1
    a88e:	1d02      	jne	0xa894 <_ThresholdControl+0xdc>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;
    a890:	7a33      	lod	Y, [S-52]
    a892:	001b      	jmp	0xa8ca <_ThresholdControl+0x112>
			}
			else if ( u8CurrThrshldCtrlType == 2 )
    a894:	622d      	lod	AL, [S-46]
    a896:	8c02      	cmp	AL, #2
    a898:	1d02      	jne	0xa89e <_ThresholdControl+0xe6>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioEnd;
    a89a:	7a29      	lod	Y, [S-42]
    a89c:	0016      	jmp	0xa8ca <_ThresholdControl+0x112>
			}
			else if ( u8CurrThrshldCtrlType == 3 )
    a89e:	622d      	lod	AL, [S-46]
    a8a0:	8c03      	cmp	AL, #3
    a8a2:	1d12      	jne	0xa8c8 <_ThresholdControl+0x110>
			{
				i16TemperatureEnd = i16TemperatureEnd - i16TemperatureBgn;
    a8a4:	2a35      	sub	X, [S-54]
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    a8a6:	7a29      	lod	Y, [S-42]
    a8a8:	ea33      	sub	Y, [S-52]
    a8aa:	5a13      	mov	[S-20], Y
    a8ac:	7122      	lod	A, dp:0x22 <__data_dp_size>
    a8ae:	aa35      	sub	A, [S-54]
    a8b0:	5211      	mov	[S-18], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a8b2:	7213      	lod	A, [S-20]
    a8b4:	7a11      	lod	Y, [S-18]
    a8b6:	4831      	muls	YA, A, Y
    a8b8:	4c73      	divs	YA, X
    a8ba:	4c73      	divs	YA, X
    a8bc:	4c7b      	dadjs	YA, X
    a8be:	7ee2      	lod	X, A
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    a8c0:	7233      	lod	A, [S-52]
    a8c2:	a2ee      	add	A, X
    a8c4:	5201      	mov	[S-2], A
    a8c6:	0002      	jmp	0xa8cc <_ThresholdControl+0x114>
				u16CurrThrshldRatio = (uint16) (muldivI16_I16byI16byI16( ((int16) u16CurrThrshldRatioEnd - (int16) u16CurrThrshldRatioBgn), (g_i16ChipTemperature - i16TemperatureBgn), i16TemperatureEnd) + u16CurrThrshldRatioBgn);
#endif /* _SUPPORT_AMBIENT_TEMP */
			}
			else
			{
				u16CurrThrshldRatio = 0;										/* Shutdown motor */
    a8c8:	7800      	lod	Y, #0
    a8ca:	5a01      	mov	[S-2], Y
			}
		}
		{
			uint16 u16MCurrgain = EE_GMCURR;
    a8cc:	7ed8 11d0 	lod	X, 0x11d0 <__ep__+0x1d0>
    a8d0:	36da 00ff 	and	X, #255
    a8d4:	22da 0100 	add	X, #256
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a8d8:	7205      	lod	A, [S-6]
    a8da:	7a01      	lod	Y, [S-2]
    a8dc:	4821      	mulu	YA, A, Y
    a8de:	4c63      	divu	YA, X
    a8e0:	4c63      	divu	YA, X
    a8e2:	520d      	mov	[S-14], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a8e4:	52d8 0364 	mov	0x364 <_g_u16PidHoldingThresholdADC>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a8e8:	7203      	lod	A, [S-4]
    a8ea:	7a01      	lod	Y, [S-2]
    a8ec:	4821      	mulu	YA, A, Y
    a8ee:	4c63      	divu	YA, X
    a8f0:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    a8f2:	52d8 035e 	mov	0x35e <_g_u16PidRunningThresholdADC>, A
    a8f6:	543d      	ret	#62

0000a8f8 <_Timer_Init>:
 *
 * Initialise the core timer (Mulan2-timer), at a periodic rate of 500us
 * ****************************************************************************	*/
void Timer_Init( void)
{
	TIMER = TMR_EN | CT_PERIODIC_RATE;											/* 500us timer */
    a8f8:	72da 81f4 	lod	A, #33268
    a8fc:	5286      	mov	io:0x6 <_LinMess2>, A
	PRIO = (PRIO & ~(3 << 0)) | ((6 - 3) << 0);									/* Set CoreTimer priority to 6 (3..6) */
    a8fe:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    a902:	a403      	or	A, #3
    a904:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_TIMER_IT;
    a908:	7020      	lod	A, #32
    a90a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_TIMER_IT;														/* Enable Timer interrupt */
    a90e:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    a912:	a420      	or	A, #32
    a914:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    a918:	5401      	ret

0000a91a <_Timer_SleepCompensation>:
 * Timer_SleepCompensation()
 *
 * Compensate the various timer-counters for the sleep-period
 * ****************************************************************************	*/
void Timer_SleepCompensation( uint16 u16SleepPeriod)
{
    a91a:	5805      	inc	S, #6
    a91c:	5201      	mov	[S-2], A
    a91e:	7ada 0100 	lod	Y, #256
    a922:	7eda 36b0 	lod	X, #14000
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    a926:	4821      	mulu	YA, A, Y
    a928:	4c63      	divu	YA, X
    a92a:	4c63      	divu	YA, X
    a92c:	5205      	mov	[S-6], A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    a92e:	72e3      	lod	A, M
    a930:	5203      	mov	[S-4], A
	u16SleepPeriod = muldivU16_U16byU16byU16( u16SleepPeriod, 256U, (uint16)(CT_PERIODIC_RATE*(PLL_freq/1000000U)));
	ATOMIC_CODE
    a932:	4407      	mov	R, #0
    a934:	500c      	call	fp0:0x60
    a936:	54f0      	mov	UPr, #0
    a938:	7009      	lod	A, #9
    a93a:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    a93e:	acff      	cmp	A, #-1
    a940:	190d      	je	0xa95c <_Timer_SleepCompensation+0x42>
    a942:	62d8 036a 	lod	AL, 0x36a <_LinStatus>
    a946:	b401      	and	A, #1
    a948:	1909      	je	0xa95c <_Timer_SleepCompensation+0x42>
    a94a:	7000      	lod	A, #0
    a94c:	52d8 010e 	mov	0x10e <_g_u16Mlx4StateCheckCounter>, A
    a950:	42d8 0120 	mov	0x120 <_g_u8ErrorCommBusTimeout>, AL
    a954:	7008      	lod	A, #8
    a956:	82db 5b68 	callf	0x5b68 <_ml_GetState>
    a95a:	0005      	jmp	0xa966 <_Timer_SleepCompensation+0x4c>
    a95c:	72d8 010e 	lod	A, 0x10e <_g_u16Mlx4StateCheckCounter>
    a960:	a205      	add	A, [S-6]
    a962:	52d8 010e 	mov	0x10e <_g_u16Mlx4StateCheckCounter>, A
    a966:	72d8 0150 	lod	A, 0x150 <_g_u16PID_CtrlCounter>
    a96a:	a205      	add	A, [S-6]
    a96c:	52d8 0150 	mov	0x150 <_g_u16PID_CtrlCounter>, A
    a970:	72d8 014e 	lod	A, 0x14e <_g_u16PID_ThrshldCtrlCounter>
    a974:	a205      	add	A, [S-6]
    a976:	52d8 014e 	mov	0x14e <_g_u16PID_ThrshldCtrlCounter>, A
    a97a:	66d8 010a 	lod	YL, 0x10a <_g_u8MotorStartDelay>
    a97e:	62e8      	lod	AL, YL
    a980:	5cf2      	usex	A
    a982:	ae05      	cmp	A, [S-6]
    a984:	1a03      	jule	0xa98c <_Timer_SleepCompensation+0x72>
    a986:	62e8      	lod	AL, YL
    a988:	8a05      	sub	AL, [S-6]
    a98a:	0001      	jmp	0xa98e <_Timer_SleepCompensation+0x74>
    a98c:	6000      	lod	AL, #0
    a98e:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
    a992:	72d8 012e 	lod	A, 0x12e <_g_u16DiagResponseTimeoutCount>
    a996:	ae05      	cmp	A, [S-6]
    a998:	1a04      	jule	0xa9a2 <_Timer_SleepCompensation+0x88>
    a99a:	aa05      	sub	A, [S-6]
    a99c:	52d8 012e 	mov	0x12e <_g_u16DiagResponseTimeoutCount>, A
    a9a0:	000a      	jmp	0xa9b6 <_Timer_SleepCompensation+0x9c>
    a9a2:	ac00      	cmp	A, #0
    a9a4:	1908      	je	0xa9b6 <_Timer_SleepCompensation+0x9c>
    a9a6:	7000      	lod	A, #0
    a9a8:	52d8 012e 	mov	0x12e <_g_u16DiagResponseTimeoutCount>, A
    a9ac:	6130      	lod	AL, dp:0x30 <_g_u8BufferOutID>
    a9ae:	8c07      	cmp	AL, #7
    a9b0:	1d02      	jne	0xa9b6 <_Timer_SleepCompensation+0x9c>
    a9b2:	60ff      	lod	AL, #-1
    a9b4:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
    a9b6:	72d8 0156 	lod	A, 0x156 <_g_u16LinUVTimeCounter>
    a9ba:	1903      	je	0xa9c2 <_Timer_SleepCompensation+0xa8>
    a9bc:	a205      	add	A, [S-6]
    a9be:	52d8 0156 	mov	0x156 <_g_u16LinUVTimeCounter>, A
    a9c2:	72d8 0102 	lod	A, 0x102 <_g_u16CalibPauseCounter>
    a9c6:	1907      	je	0xa9d6 <_Timer_SleepCompensation+0xbc>
    a9c8:	ae05      	cmp	A, [S-6]
    a9ca:	1a02      	jule	0xa9d0 <_Timer_SleepCompensation+0xb6>
    a9cc:	aa05      	sub	A, [S-6]
    a9ce:	0001      	jmp	0xa9d2 <_Timer_SleepCompensation+0xb8>
    a9d0:	7000      	lod	A, #0
    a9d2:	52d8 0102 	mov	0x102 <_g_u16CalibPauseCounter>, A
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    a9d6:	7203      	lod	A, [S-4]
    a9d8:	52e3      	mov	M, A
    a9da:	5407      	ret	#8

0000a9dc <_TIMER_IT>:
 * TIMER_IT()
 *
 * Periodic Timer ISR
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
    a9dc:	52df      	push	A
    a9de:	5edf      	push	X
    a9e0:	5adf      	push	Y
    a9e2:	4c83      	push	D
	{
		g_u16Mlx4StateCheckCounter++;										/* State check counter */
	}
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK && (__MLX_PLTF_VERSION_MAJOR__ == 3) */

	if ( g_u8MotorStopDelay != 0 )
    a9e4:	6135      	lod	AL, dp:0x35 <_g_u8MotorStopDelay>
    a9e6:	1912      	je	0xaa0c <_TIMER_IT+0x30>
	{
		if ( (--g_u8MotorStopDelay == 0) && ((g_e8MotorStatusMode & (uint8) ~C_MOTOR_STATUS_DEGRADED) == (uint8) C_MOTOR_STATUS_STOP) )
    a9e8:	80ff      	add	AL, #-1
    a9ea:	4135      	mov	dp:0x35 <_g_u8MotorStopDelay>, AL
    a9ec:	1d0f      	jne	0xaa0c <_TIMER_IT+0x30>
    a9ee:	61eb      	lod	AL, dp:0xeb <_g_e8MotorStatusMode>
    a9f0:	b47f      	and	A, #127
    a9f2:	1d0c      	jne	0xaa0c <_TIMER_IT+0x30>
		{
			DRVCFG_DIS_UVWT();
    a9f4:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    a9f8:	b6da fe00 	and	A, #65024
    a9fc:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();														/* MMP140903-1 */
    aa00:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    aa04:	a6da 0100 	or	A, #256
    aa08:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
		}
	}

	if ( g_u8MotorStartDelay != 0 )
    aa0c:	62d8 010a 	lod	AL, 0x10a <_g_u8MotorStartDelay>
    aa10:	1903      	je	0xaa18 <_TIMER_IT+0x3c>
	{
		g_u8MotorStartDelay--;
    aa12:	80ff      	add	AL, #-1
    aa14:	42d8 010a 	mov	0x10a <_g_u8MotorStartDelay>, AL
	}

	g_u16PID_CtrlCounter++;														/* PID Current/Speed control */
    aa18:	72d8 0150 	lod	A, 0x150 <_g_u16PID_CtrlCounter>
    aa1c:	a001      	add	A, #1
    aa1e:	52d8 0150 	mov	0x150 <_g_u16PID_CtrlCounter>, A
	g_u16PID_ThrshldCtrlCounter++;												/* PID Threshold control */
    aa22:	72d8 014e 	lod	A, 0x14e <_g_u16PID_ThrshldCtrlCounter>
    aa26:	a001      	add	A, #1
    aa28:	52d8 014e 	mov	0x14e <_g_u16PID_ThrshldCtrlCounter>, A
#if _SUPPORT_AMBIENT_TEMP
	g_u16SelfHeatingCounter++;													/* Self-heating compensation (ambjient temperature) */
#endif /* _SUPPORT_AMBIENT_TEMP */

#if ((LINPROT & LINXX) == LIN2X)												/* LIN 2.x */
	if ( g_u16LinAATicker != 0 )												/* LIN-AA on going */
    aa2c:	72d8 0128 	lod	A, 0x128 <_g_u16LinAATicker>
    aa30:	1911      	je	0xaa54 <_TIMER_IT+0x78>
	{
		if ( --g_u16LinAATicker == 0 )											/* LIN-AutoAddresing time-out counter (seconds) */
    aa32:	a0ff      	add	A, #-1
    aa34:	52d8 0128 	mov	0x128 <_g_u16LinAATicker>, A
    aa38:	1d0d      	jne	0xaa54 <_TIMER_IT+0x78>
		{
			if ( --g_u8LinAATimeout == 0 )
    aa3a:	62d8 012a 	lod	AL, 0x12a <_g_u8LinAATimeout>
    aa3e:	80ff      	add	AL, #-1
    aa40:	42d8 012a 	mov	0x12a <_g_u8LinAATimeout>, AL
    aa44:	1d03      	jne	0xaa4c <_TIMER_IT+0x70>
			{
				LinAATimeoutControl();
    aa46:	82db 8146 	callf	0x8146 <_LinAATimeoutControl>
    aa4a:	0004      	jmp	0xaa54 <_TIMER_IT+0x78>
			}
			else	
			{
				g_u16LinAATicker = PI_TICKS_PER_SECOND;
    aa4c:	72da 07d0 	lod	A, #2000
    aa50:	52d8 0128 	mov	0x128 <_g_u16LinAATicker>, A
			}
		}
	}

	if ( g_u16DiagResponseTimeoutCount != 0 )
    aa54:	72d8 012e 	lod	A, 0x12e <_g_u16DiagResponseTimeoutCount>
    aa58:	1909      	je	0xaa6c <_TIMER_IT+0x90>
	{
		--g_u16DiagResponseTimeoutCount;
    aa5a:	a0ff      	add	A, #-1
    aa5c:	52d8 012e 	mov	0x12e <_g_u16DiagResponseTimeoutCount>, A
		if ( g_u16DiagResponseTimeoutCount == 0 )								/* One second time-out */
    aa60:	1d05      	jne	0xaa6c <_TIMER_IT+0x90>
		{
			if ( g_u8BufferOutID == QR_RFR_DIAG )								/* Pending response type: Diagnostic */
    aa62:	6130      	lod	AL, dp:0x30 <_g_u8BufferOutID>
    aa64:	8c07      	cmp	AL, #7
    aa66:	1d02      	jne	0xaa6c <_TIMER_IT+0x90>
			{
				g_u8BufferOutID = (uint8) QR_INVALID;							/* Invalidate Diagnostics response */
    aa68:	60ff      	lod	AL, #-1
    aa6a:	4130      	mov	dp:0x30 <_g_u8BufferOutID>, AL
	}
#endif /* ((LINPROT & LINXX) == LIN2X) */

#if WATCHDOG == ENABLED
#if ((LIN_COMM != FALSE) && ((LINPROT & LINXX) != LIN2J))
	if ( g_u8AutoAddressingFlags & WAITINGFORBREAK )
    aa6c:	6131      	lod	AL, dp:0x31 <_g_u8AutoAddressingFlags>
    aa6e:	b402      	and	A, #2
    aa70:	1907      	je	0xaa80 <_TIMER_IT+0xa4>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    aa72:	729a      	lod	A, io:0x1a <_g_e8WarningOverTemperature>
    AWD_CTRL = temp;
    aa74:	529a      	mov	io:0x1a <_g_e8WarningOverTemperature>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    aa76:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    aa78:	b430      	and	A, #48
    aa7a:	1902      	je	0xaa80 <_TIMER_IT+0xa4>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    aa7c:	6000      	lod	AL, #0
    aa7e:	4282      	mov	io:0x2 <_LinCmnd>, AL
#if _SUPPORT_CHIP_TEMP_PROFILE
	g_u16TemperatureStabilityCounter++;
#endif /* _SUPPORT_CHIP_TEMP_PROFILE */

#if _SUPPORT_LIN_UV
	if ( g_u16LinUVTimeCounter != 0 )											/* MMP131216-1 - Begin */
    aa80:	72d8 0156 	lod	A, 0x156 <_g_u16LinUVTimeCounter>
    aa84:	1903      	je	0xaa8c <_TIMER_IT+0xb0>
	{
		g_u16LinUVTimeCounter++;
    aa86:	a001      	add	A, #1
    aa88:	52d8 0156 	mov	0x156 <_g_u16LinUVTimeCounter>, A
	{
		u16DegradeDelay--;
	}
#endif /* (_SUPPORT_DEGRADE_DELAY != FALSE) && (LINPROT == LIN2X_ACT44) */		/* MMP150128-1 - End */

	if ( g_u16CalibPauseCounter != 0 )
    aa8c:	72d8 0102 	lod	A, 0x102 <_g_u16CalibPauseCounter>
    aa90:	1903      	je	0xaa98 <_TIMER_IT+0xbc>
		g_u16CalibPauseCounter--;
    aa92:	a0ff      	add	A, #-1
    aa94:	52d8 0102 	mov	0x102 <_g_u16CalibPauseCounter>, A
    aa98:	4cc3      	pop	D
    aa9a:	7acf      	pop	Y
    aa9c:	7ecf      	pop	X
    aa9e:	72cf      	pop	A
    aaa0:	4407      	mov	R, #0
    aaa2:	72cb      	pop	M
    aaa4:	5401      	ret

0000aaa6 <_SpiDebugInit>:
 *
 *	Comments:	Initialise SPI Interface.
 * ****************************************************************************	*/
void SpiDebugInit( void)
{
	SPI1_PCR  = SPI_CKEN;													/* Set the bit SPI_CKEN to 1 */
    aaa6:	6001      	lod	AL, #1
    aaa8:	42d8 289a 	mov	0x289a <__io__+0x9a>, AL
	SPI1_BRR  = ((PLL_freq / DEBUG_SPI_BAUDRATE) + 1);						/* 100, 200, 400, 800 or 1000 kBaud */
    aaac:	701d      	lod	A, #29
    aaae:	52d8 289c 	mov	0x289c <__io__+0x9c>, A
	SPI1_CTRL = (SPI_FRSSOEN << 8) | (SPI_MSTRONLY << 8) | SPI_RFIE | SPI_TFIE | /* SPI_BYTEMOD | */ SPI_MSTR | SPI_EN | SPI_CKEN;	/* Mode 00 */
    aab2:	72da 0ad3 	lod	A, #2771
    aab6:	52d8 289a 	mov	0x289a <__io__+0x9a>, A
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
static INLINE void SpiDebugWriteFirst( uint16 u16Data)
{
	SPI1_PSCR |= SPI_FRSSOEN;													/* Toggle Slave-Select */
    aaba:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    aabe:	8408      	or	AL, #8
    aac0:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_PSCR &= ~SPI_FRSSOEN;
    aac4:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    aac8:	94f7      	and	AL, #-9
    aaca:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_DR = u16Data;															/* Send SPI-Data */
    aace:	72da a55a 	lod	A, #42330
    aad2:	52d8 289e 	mov	0x289e <__io__+0x9e>, A
    aad6:	5401      	ret

0000aad8 <_au16HaltZero>:
    aad8:	0000 0000                                   ....

0000aadc <_SBASE_LIN>:
    aadc:	0fc3 0fc3 0cc3 1cc3 0cc3 1cc3 0cc3 1cc3     ................
    aaec:	0cc3 1cc3 0cc3 1cc3 0cc3 1cc3 0cc3 1cc3     ................
    aafc:	0cc3 1cc3 ffff                              ......

0000ab02 <_tMlxDbgSupport>:
    ab02:	fffe 0007 0000 0000 0000 0000 0000 0000     ................
    ab12:	0000 0000 d0ff 0000 ff87 c0ff 0001 7d07     ...............}

0000ab22 <_au16AnaOutRegs>:
    ab22:	201c 201e 2020 204a 204c 204e 28cc 28ce     . .   J L N .(.(

0000ab32 <_tAdcSelfTest4B>:
    ab32:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    ab42:	1903 0d53 0003 ffff                         ..S.....

0000ab4a <_tAdcSelfTest4A>:
    ab4a:	0103 0953 0903 0a53 0a03 0b53 0b03 1953     ..S...S...S...S.
    ab5a:	1903 0053 0d03 ffff                         ..S.....

0000ab62 <_SBASE_INIT_4PH>:
    ab62:	0143 0053 0d63 0473 0d03 ffff               C.S.c.s.....

0000ab6e <_SBASE_CURRENT>:
    ab6e:	0d03 ffff                                   ....

0000ab72 <_SBASE_MOTORVOLT>:
    ab72:	0403 ffff                                   ....

0000ab76 <_SBASE_SUPPLYVOLT>:
    ab76:	0003 ffff                                   ....

0000ab7a <_SBASE_TEMP>:
    ab7a:	0103 ffff                                   ....

0000ab7e <_SBASE_CURROFF>:
    ab7e:	0d03 ffff                                   ....

0000ab82 <_SBASE_VREF_OFF>:
    ab82:	0100 ffff                                   ....

0000ab86 <_c_ai16MicroStepVector4PH>:
    ab86:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    ab96:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..
    aba6:	7ffe 7ec3 7c4f 78a8 73d8 6deb 66ee 5ef4     ...~O|.x.s.m.f.^
    abb6:	560f 4c56 41e1 36ca 2b2c 1f23 12cd 0649     .VVL.A.6,+#...I.
    abc6:	f9b7 ed33 e0dd d4d4 c936 be1f b3aa a9f1     ..3.....6.......
    abd6:	a10c 9912 9215 8c28 8758 83b1 813d 8002     ......(.X...=...
    abe6:	8002 813d 83b1 8758 8c28 9215 9912 a10c     ..=...X.(.......
    abf6:	a9f1 b3aa be1f c936 d4d4 e0dd ed33 f9b7     ......6.....3...
    ac06:	0649 12cd 1f23 2b2c 36ca 41e1 4c56 560f     I...#.,+.6.AVL.V
    ac16:	5ef4 66ee 6deb 73d8 78a8 7c4f 7ec3 7ffe     .^.f.m.s.xO|.~..

0000ac26 <_c_au8DrvCfgSelfTestB4>:
    ac26:	c431 8421 4c13 4812 b5f5                    1.!..L.H..

0000ac30 <_c_au16DrvAdcSelfTestA>:
    ac30:	0b03 ffff 0a03 ffff 0903 ffff 1903 ffff     ................

0000ac40 <_c_au8DrvCfgSelfTestA>:
    ac40:	3020 0c08 0302 c080                          0......

0000ac48 <_defNvramUser>:
    ac48:	0100 0116 8881 03c4 5467 0000 ffff 2dc0     ........gT.....-
    ac58:	321e 0138 0a0a 0013 0013 ffff 0000 3000     .28............0
    ac68:	0000 0000 0000 0000 0000 0000 0000 0000     ................
    ac78:	6c40 b001 0060 004b 004b 004b 004b 0000     @l..`.K.K.K.K...
    ac88:	0000 0000 0000 004b 05dc 1201 1791 963c     ......K.......<.
    ac98:	a514 9040 821a 8044 8062 8f7a 0aef 3219     ..@...D.b.z....2
    aca8:	1e1e 1a10 fa1a 0000 0000 004b 0210 5840     ..........K...@X
    acb8:	0600 00b2 7fff ffff                         ........
