mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


MLX81315A_S03_VALVE.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00004000  00004000  00000254  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00005540  00005540  00001744  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000098  0000bf68  0000bf68  00005c94  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00005bf2  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  00005c92  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  00005c8c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .protection_key 00000008  0000bf46  0000bf46  00005c72  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .flash_crc    00000002  0000bf4e  0000bf4e  00005c7a  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .product_no   00000008  0000bf50  0000bf50  00005c7c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .app_version  00000004  0000bf58  0000bf58  00005c84  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .pltf_version 00000004  0000bf5c  0000bf5c  00005c88  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .ramfunc      0000001e  00000740  000055c8  000017cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         00004380  000055e8  000055e8  000017ec  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 13 .shared_ram   00000010  00000000  00000000  00005d2c  2**0
                  CONTENTS, READONLY
 14 .ram_lin_fixed 00000006  00000010  00000010  00000254  2**1
                  ALLOC
 15 .dp.data      00000010  00000018  00009968  00005b6c  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 16 .dp           0000004a  00000028  00009978  00005b7c  2**1
                  ALLOC
 17 .data         00000076  00000072  00009978  00005b7c  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 18 .bss          000000b6  000000e8  000099ee  00005bf2  2**1
                  ALLOC
 19 .bist_stat    00000008  0000019e  000099ee  00005bf2  2**1
                  ALLOC
 20 .debug_abbrev 0000274a  00000000  00000000  00005d3c  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   000086a7  00000000  00000000  00008486  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   0000744c  00000000  00000000  00010b2d  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  0000177e  00000000  00000000  00017f7a  2**1
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_pubnames 00001d03  00000000  00000000  000196f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_aranges 000004f0  00000000  00000000  0001b3fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_str    000032e3  00000000  00000000  0001b8eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .comment      00000011  00000000  00000000  0001ebce  2**0
                  CONTENTS, READONLY

Disassembly of section .mlx4_flash:

00004000 <__mlx4_flash_start>:
    4000:	a55a      	or	A, dp:0x5a <_LIN_nad>
    4002:	5aa5      	mov	io:0x25 <_l_u8StallCountO>, Y
    4004:	0000      	nop
    4006:	0000      	nop
    4008:	2442      	or	X, #66
    400a:	2442      	or	X, #66
    400c:	243f      	or	X, #63
    400e:	243f      	or	X, #63
    4010:	0000      	nop
    4012:	0000      	nop
    4014:	0000      	nop
    4016:	0000      	nop
    4018:	4100      	mov	dp:0x0 <__dp__>, AL
    401a:	2000      	add	X, #0
    401c:	0000      	nop
    401e:	0000      	nop
    4020:	01e0      	jmp	0x43e2 <__mlx4_flash_start+0x3e2>
    4022:	0003      	jmp	0x402a <__mlx4_flash_start+0x2a>
    4024:	0005      	jmp	0x4030 <__mlx4_flash_start+0x30>
    4026:	0000      	nop
    4028:	4233      	mov	[S-52], AL
    402a:	5f50      	mov	ep:0x50 <_g_u16PID_I>, X
    402c:	7c6d      	lod	X, #109
    402e:	998a      	subc	AL, dp:0x8a <_l_u16OBDValveStatusPosition>
    4030:	140e      	call	0x384e <__io__+0x104e>
    4032:	201a      	add	X, #26
    4034:	2c26      	cmp	X, #38
    4036:	3832      	subc	X, #50
    4038:	0208      	jmp	0x444a <__mlx4_flash_start+0x44a>
    403a:	af52      	cmp	A, ep:0x52 <_LinFrameDataBuffer>
    403c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    403e:	ff35      	xor	Y, ep:0x35 <_g_DiagResponse+0x5>
    4040:	e0e0      	add	Y, #-32
    4042:	dba6      	subc	AH, ep:0xa6 <_l_e8ValveState>
    4044:	0000      	nop
    4046:	0200      	jmp	0x4448 <__mlx4_flash_start+0x448>
    4048:	7da0      	lod	X, dp:0xa0 <_l_e8GmcvInitDirection>
    404a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    404c:	39e4      	subc	X, dp:0xe4 <_LINPresc>
    404e:	934e      	adc	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4050:	d3e0      	adc	AH, ep:0xe0 <_g_i16PID_E>
    4052:	a497      	or	A, #-105
    4054:	2c1f      	cmp	X, #31
    4056:	5b68      	mov	ep:0x68 <_ml_driver_mode+0xa>, Y
    4058:	a81f      	sub	A, #31
    405a:	b47f      	and	A, #127
    405c:	00b2      	jmp	0x41c2 <__mlx4_flash_start+0x1c2>
    405e:	7c50      	lod	X, #80
    4060:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4062:	773a      	lod	PC, ep:0x3a <_g_u16MicroStepIdx>
    4064:	b78e      	and	A, ep:0x8e <_l_u8OBDValveStatusFault>
    4066:	773b      	lod	PC, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4068:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    406a:	34e9      	and	X, #-23
    406c:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    406e:	b76f      	and	A, ep:0x6f <_ml_driver_mode+0x11>
    4070:	773f      	lod	PC, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    4072:	4c02 b203 	add	D, #-1291603453
    4076:	b303 
    4078:	8684      	or	AL, io:0x4 <_LinMess>
    407a:	7203      	lod	A, [S-4]
    407c:	4c03      	add	D, ??
    407e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    4080:	380e      	subc	X, #14
    4082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    4084:	320a      	adc	X, [S-11]
    4086:	340a      	and	X, #10
    4088:	3eac      	xor	X, io:0x2c <__data_dp_end+0x4>
    408a:	3b16      	subc	X, ep:0x16 <__data_dp_size+0x6>
    408c:	3730      	and	X, ep:0x30 <_g_DiagResponse>
    408e:	6193      	lod	AL, dp:0x93 <_s_CVRequestStruct+0x1>
    4090:	b680      	and	A, io:0x0 <__dp__>
    4092:	7273      	lod	A, [S-116]
    4094:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4098:	7239      	lod	A, [S-58]
    409a:	726f      	lod	A, [S-112]
    409c:	b582      	and	A, dp:0x82 <_targetPos>
    409e:	714c      	lod	A, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    40a0:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusMove>
    40a2:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    40a4:	0000      	nop
    40a6:	0000      	nop
    40a8:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    40aa:	320a      	adc	X, [S-11]
    40ac:	580a      	inc	S, #11
    40ae:	0901      	clrb	io:0x00.1
    40b0:	2080      	add	X, #-128
    40b2:	623a      	lod	AL, [S-59]
    40b4:	7270      	lod	A, [S-113]
    40b6:	b637      	and	A, [S-56]
    40b8:	b373      	adc	A, ep:0x73 <__bss_dp_end+0x1>
    40ba:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    40bc:	e783      	or	Y, ep:0x83 <_targetPos+0x1>
    40be:	1101      	call	0x42c2 <__mlx4_flash_start+0x2c2>
    40c0:	20b7      	add	X, #-73
    40c2:	6c03      	lod	YH, #3
    40c4:	206e      	add	X, #110
    40c6:	2066      	add	X, #102
    40c8:	2073      	add	X, #115
    40ca:	2050      	add	X, #80
    40cc:	e680      	or	Y, io:0x0 <__dp__>
    40ce:	1102      	call	0x42d4 <__mlx4_flash_start+0x2d4>
    40d0:	b782      	and	A, ep:0x82 <_targetPos>
    40d2:	207a      	add	X, #122
    40d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    40d6:	110b      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40d8:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    40da:	207a      	add	X, #122
    40dc:	b270      	adc	A, [S-113]
    40de:	a688      	or	A, io:0x8 <__bist_stat_size>
    40e0:	1106      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40e2:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    40e4:	207a      	add	X, #122
    40e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    40e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    40ea:	1101      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40ec:	207c      	add	X, #124
    40ee:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    40f0:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40f2:	2050      	add	X, #80
    40f4:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40f6:	2056      	add	X, #86
    40f8:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    40fa:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40fc:	3cc3      	xor	X, #-61
    40fe:	2050      	add	X, #80
    4100:	b384      	adc	A, ep:0x84 <_l_u16RecoryPos>
    4102:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    4104:	7380      	lod	A, ep:0x80 <_CmdArr+0x6>
    4106:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    4108:	7235      	lod	A, [S-54]
    410a:	7ca7      	lod	X, #-89
    410c:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    410e:	6c03      	lod	YH, #3
    4110:	20b1      	add	X, #-79
    4112:	20ad      	add	X, #-83
    4114:	20b3      	add	X, #-77
    4116:	20b3      	add	X, #-77
    4118:	20b3      	add	X, #-77
    411a:	20a1      	add	X, #-95
    411c:	20b3      	add	X, #-77
    411e:	20b3      	add	X, #-77
    4120:	20b3      	add	X, #-77
    4122:	20b3      	add	X, #-77
    4124:	20b3      	add	X, #-77
    4126:	20b3      	add	X, #-77
    4128:	20b3      	add	X, #-77
    412a:	20b3      	add	X, #-77
    412c:	20b3      	add	X, #-77
    412e:	2098      	add	X, #-104
    4130:	a682      	or	A, io:0x2 <_LinCmnd>
    4132:	1106      	call	0x4340 <__mlx4_flash_start+0x340>
    4134:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    4136:	bf8e      	xor	A, ep:0x8e <_l_u8OBDValveStatusFault>
    4138:	a681      	or	A, io:0x1 <__dp__+0x1>
    413a:	0101      	jmp	0x433e <__mlx4_flash_start+0x33e>
    413c:	f781      	and	Y, ep:0x81 <_CmdArr+0x7>
    413e:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4140:	20b1      	add	X, #-79
    4142:	e682      	or	Y, io:0x2 <_LinCmnd>
    4144:	110d      	call	0x4360 <__mlx4_flash_start+0x360>
    4146:	b286      	adc	A, io:0x6 <_LinMess2>
    4148:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    414a:	f782      	and	Y, ep:0x82 <_targetPos>
    414c:	e681      	or	Y, io:0x1 <__dp__+0x1>
    414e:	0103      	jmp	0x4356 <__mlx4_flash_start+0x356>
    4150:	bf8d      	xor	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4152:	b680      	and	A, io:0x0 <__dp__>
    4154:	7273      	lod	A, [S-116]
    4156:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4158:	20b1      	add	X, #-79
    415a:	e681      	or	Y, io:0x1 <__dp__+0x1>
    415c:	1101      	call	0x4360 <__mlx4_flash_start+0x360>
    415e:	245d      	or	X, #93
    4160:	20b3      	add	X, #-77
    4162:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4164:	20b4      	add	X, #-76
    4166:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4168:	7381      	lod	A, ep:0x81 <_CmdArr+0x7>
    416a:	5404      	ret	#5
    416c:	2056      	add	X, #86
    416e:	a681      	or	A, io:0x1 <__dp__+0x1>
    4170:	1104      	call	0x437a <__mlx4_flash_start+0x37a>
    4172:	b270      	adc	A, [S-113]
    4174:	a688      	or	A, io:0x8 <__bist_stat_size>
    4176:	1105      	call	0x4382 <__mlx4_flash_start+0x382>
    4178:	2048      	add	X, #72
    417a:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    417c:	622e      	lod	AL, [S-47]
    417e:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4180:	0101      	jmp	0x4384 <__mlx4_flash_start+0x384>
    4182:	2056      	add	X, #86
    4184:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4186:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    4188:	1101      	call	0x438c <__mlx4_flash_start+0x38c>
    418a:	20e4      	add	X, #-28
    418c:	4592      	mov	dp:0x92 <_s_CVRequestStruct>, YL
    418e:	76e5      	jmp	MH
    4190:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4192:	77e5      	lod	PC, ep:0xe5 <_LINPresc+0x1>
    4194:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4196:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4198:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    419a:	6198      	lod	AL, dp:0x98 <_s_CVRequestStruct+0x6>
    419c:	e581      	or	Y, dp:0x81 <_CmdArr+0x7>
    419e:	110b      	call	0x43b6 <__mlx4_flash_start+0x3b6>
    41a0:	7cd5      	lod	X, #-43
    41a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    41a4:	b208      	adc	A, [S-9]
    41a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    41a8:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    41aa:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    41ac:	1105      	call	0x43b8 <__mlx4_flash_start+0x3b8>
    41ae:	bf8c      	xor	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    41b0:	f373      	adc	Y, ep:0x73 <__bss_dp_end+0x1>
    41b2:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    41b4:	724c      	lod	A, [S-77]
    41b6:	2050      	add	X, #80
    41b8:	7271      	lod	A, [S-114]
    41ba:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    41bc:	e781      	or	Y, ep:0x81 <_CmdArr+0x7>
    41be:	0102      	jmp	0x43c4 <__mlx4_flash_start+0x3c4>
    41c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    41c2:	20da      	add	X, #-38
    41c4:	b686      	and	A, io:0x6 <_LinMess2>
    41c6:	20da      	add	X, #-38
    41c8:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    41ca:	300a      	adc	X, #10
    41cc:	6198      	lod	AL, dp:0x98 <_s_CVRequestStruct+0x6>
    41ce:	ef80      	cmp	Y, ep:0x80 <_CmdArr+0x6>
    41d0:	0103      	jmp	0x43d8 <__mlx4_flash_start+0x3d8>
    41d2:	b684      	and	A, io:0x4 <_LinMess>
    41d4:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    41d6:	2030      	add	X, #48
    41d8:	b24e      	adc	A, [S-79]
    41da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    41dc:	724e      	lod	A, [S-79]
    41de:	6c02      	lod	YH, #2
    41e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    41e2:	20f4      	add	X, #-12
    41e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    41e6:	2100      	add	X, dp:0x0 <__dp__>
    41e8:	b78b      	and	A, ep:0x8b <_l_u16OBDValveStatusPosition+0x1>
    41ea:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    41ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    41ee:	61ae      	lod	AL, dp:0xae <_l_u8Mlx4ErrorStateOcc>
    41f0:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    41f2:	61b7      	lod	AL, dp:0xb7 <__bss_size+0x1>
    41f4:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    41f6:	b582      	and	A, dp:0x82 <_targetPos>
    41f8:	b681      	and	A, io:0x1 <__dp__+0x1>
    41fa:	61ae      	lod	AL, dp:0xae <_l_u8Mlx4ErrorStateOcc>
    41fc:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    41fe:	2110      	add	X, dp:0x10 <__data_dp_size>
    4200:	b682      	and	A, io:0x2 <_LinCmnd>
    4202:	724e      	lod	A, [S-79]
    4204:	b78d      	and	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4206:	b582      	and	A, dp:0x82 <_targetPos>
    4208:	b681      	and	A, io:0x1 <__dp__+0x1>
    420a:	61ae      	lod	AL, dp:0xae <_l_u8Mlx4ErrorStateOcc>
    420c:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    420e:	2110      	add	X, dp:0x10 <__data_dp_size>
    4210:	b24c      	adc	A, [S-77]
    4212:	7271      	lod	A, [S-114]
    4214:	b78b      	and	A, ep:0x8b <_l_u16OBDValveStatusPosition+0x1>
    4216:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    4218:	b681      	and	A, io:0x1 <__dp__+0x1>
    421a:	61ae      	lod	AL, dp:0xae <_l_u8Mlx4ErrorStateOcc>
    421c:	b785      	and	A, ep:0x85 <_l_u16RecoryPos+0x1>
    421e:	61b7      	lod	AL, dp:0xb7 <__bss_size+0x1>
    4220:	b24e      	adc	A, [S-79]
    4222:	b171      	adc	A, dp:0x71 <_ml_driver_mode+0x13>
    4224:	61bb      	lod	AL, dp:0xbb <_g_i16SupplyVoltage+0x1>
    4226:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    4228:	b56d      	and	A, dp:0x6d <_ml_driver_mode+0xf>
    422a:	b685      	and	A, io:0x5 <_LinMess+0x1>
    422c:	b66e      	and	A, [S-111]
    422e:	61bb      	lod	AL, dp:0xbb <_g_i16SupplyVoltage+0x1>
    4230:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4232:	b680      	and	A, io:0x0 <__dp__>
    4234:	738b      	lod	A, ep:0x8b <_l_u16OBDValveStatusPosition+0x1>
    4236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    4238:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    423a:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusMove>
    423c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    423e:	5408      	ret	#9
    4240:	b273      	adc	A, [S-116]
    4242:	a688      	or	A, io:0x8 <__bist_stat_size>
    4244:	1109      	call	0x4458 <__mlx4_flash_start+0x458>
    4246:	b24e      	adc	A, [S-79]
    4248:	e681      	or	Y, io:0x1 <__dp__+0x1>
    424a:	0103      	jmp	0x4452 <__mlx4_flash_start+0x452>
    424c:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    424e:	a582      	or	A, dp:0x82 <_targetPos>
    4250:	0102      	jmp	0x4456 <__mlx4_flash_start+0x456>
    4252:	b680      	and	A, io:0x0 <__dp__>
    4254:	204a      	add	X, #74
    4256:	2048      	add	X, #72
    4258:	3806      	subc	X, #6
    425a:	380e      	subc	X, #14
    425c:	580c      	inc	S, #13
    425e:	0807      	clrb	dp:0x00.7
    4260:	62e6      	lod	AL, Y
    4262:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4264:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4266:	1108      	call	0x4478 <__mlx4_flash_start+0x478>
    4268:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    426a:	1105      	call	0x4476 <__mlx4_flash_start+0x476>
    426c:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    426e:	623a      	lod	AL, [S-59]
    4270:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    4272:	1101      	call	0x4476 <__mlx4_flash_start+0x476>
    4274:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    4276:	2030      	add	X, #48
    4278:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    427a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    427c:	b582      	and	A, dp:0x82 <_targetPos>
    427e:	6223      	lod	AL, [S-36]
    4280:	6198      	lod	AL, dp:0x98 <_s_CVRequestStruct+0x6>
    4282:	b208      	adc	A, [S-9]
    4284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    4286:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4288:	6c03      	lod	YH, #3
    428a:	2155      	add	X, dp:0x55 <_LinFrameDataBuffer+0x3>
    428c:	214a      	add	X, dp:0x4a <__bss_dp_size>
    428e:	b688      	and	A, io:0x8 <__bist_stat_size>
    4290:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4292:	215a      	add	X, dp:0x5a <_LIN_nad>
    4294:	b586      	and	A, dp:0x86 <_l_u8SavePosFlag>
    4296:	61a8      	lod	AL, dp:0xa8 <_l_u8RamPreError>
    4298:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    429a:	b6e5      	and	A, MH
    429c:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    429e:	b7e5      	and	A, ep:0xe5 <_LINPresc+0x1>
    42a0:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    42a2:	76e5      	jmp	MH
    42a4:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    42a6:	77e5      	lod	PC, ep:0xe5 <_LINPresc+0x1>
    42a8:	b686      	and	A, io:0x6 <_LinMess2>
    42aa:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    42ac:	61a8      	lod	AL, dp:0xa8 <_l_u8RamPreError>
    42ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    42b0:	b582      	and	A, dp:0x82 <_targetPos>
    42b2:	3e10      	xor	X, [S-17]
    42b4:	724c      	lod	A, [S-77]
    42b6:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    42b8:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    42ba:	34c0      	and	X, #-64
    42bc:	623a      	lod	AL, [S-59]
    42be:	38b7      	subc	X, #-73
    42c0:	357b      	and	X, dp:0x7b <_CmdArr+0x1>
    42c2:	3663      	and	X, [S-100]
    42c4:	7cd3      	lod	X, #-45
    42c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    42c8:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    42ca:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    42cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    42ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    42d0:	b208      	adc	A, [S-9]
    42d2:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    42d4:	4616      	mov	[S-23], YL
    42d6:	3561      	and	X, dp:0x61 <_ml_driver_mode+0x3>
    42d8:	7208      	lod	A, [S-9]
    42da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    42dc:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    42de:	0103      	jmp	0x44e6 <__mlx4_flash_start+0x4e6>
    42e0:	b272      	adc	A, [S-115]
    42e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    42e4:	010a      	jmp	0x44fa <__mlx4_flash_start+0x4fa>
    42e6:	4500      	mov	dp:0x0 <__dp__>, YL
    42e8:	4584      	mov	dp:0x84 <_l_u16RecoryPos>, YL
    42ea:	8582      	or	AL, dp:0x82 <_targetPos>
    42ec:	5802      	inc	S, #3
    42ee:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    42f0:	b638      	and	A, [S-57]
    42f2:	7272      	lod	A, [S-115]
    42f4:	b737      	and	A, ep:0x37 <_g_DiagResponse+0x7>
    42f6:	0004      	jmp	0x4300 <__mlx4_flash_start+0x300>
    42f8:	2167      	add	X, dp:0x67 <_ml_driver_mode+0x9>
    42fa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    42fc:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    42fe:	2047      	add	X, #71
    4300:	6217      	lod	AL, [S-24]
    4302:	0007      	jmp	0x4312 <__mlx4_flash_start+0x312>
    4304:	1102      	call	0x450a <__mlx4_flash_start+0x50a>
    4306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    4308:	7209      	lod	A, [S-10]
    430a:	b208      	adc	A, [S-9]
    430c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    430e:	6198      	lod	AL, dp:0x98 <_s_CVRequestStruct+0x6>
    4310:	2165      	add	X, dp:0x65 <_ml_driver_mode+0x7>
    4312:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    4314:	bd83      	xor	A, dp:0x83 <_targetPos+0x1>
    4316:	716f      	lod	A, dp:0x6f <_ml_driver_mode+0x11>
    4318:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    431a:	a582      	or	A, dp:0x82 <_targetPos>
    431c:	1101      	call	0x4520 <__mlx4_flash_start+0x520>
    431e:	2030      	add	X, #48
    4320:	b785      	and	A, ep:0x85 <_l_u16RecoryPos+0x1>
    4322:	62d2      	lod	AL, [A++]
    4324:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    4326:	38b7      	subc	X, #-73
    4328:	3e18      	xor	X, [S-25]
    432a:	357b      	and	X, dp:0x7b <_CmdArr+0x1>
    432c:	367b      	and	X, [S-124]
    432e:	6800      	lod	AH, #0
    4330:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    4332:	b792      	and	A, ep:0x92 <_s_CVRequestStruct>
    4334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4336:	b20a      	adc	A, [S-11]
    4338:	d667      	and	AH, [S-104]
    433a:	720b      	lod	A, [S-12]
    433c:	b76b      	and	A, ep:0x6b <_ml_driver_mode+0xd>
    433e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    4340:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    4342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4344:	b20a      	adc	A, [S-11]
    4346:	d667      	and	AH, [S-104]
    4348:	720b      	lod	A, [S-12]
    434a:	b76b      	and	A, ep:0x6b <_ml_driver_mode+0xd>
    434c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    434e:	6800      	lod	AH, #0
    4350:	b7e5      	and	A, ep:0xe5 <_LINPresc+0x1>
    4352:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4354:	e78f      	or	Y, ep:0x8f <_l_u8ValueFaultFlag>
    4356:	b7e5      	and	A, ep:0xe5 <_LINPresc+0x1>
    4358:	ef87      	cmp	Y, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    435a:	6800      	lod	AH, #0
    435c:	7270      	lod	A, [S-113]
    435e:	b6e7      	and	A, R
    4360:	8791      	or	AL, ep:0x91 <_l_u8AliveRollingCounter+0x1>
    4362:	76e7      	jmp	R
    4364:	c791      	or	AH, ep:0x91 <_l_u8AliveRollingCounter+0x1>
    4366:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    4368:	e370      	add	Y, ep:0x70 <_ml_driver_mode+0x12>
    436a:	0109      	jmp	0x457e <__mlx4_flash_start+0x57e>
    436c:	21af      	add	X, dp:0xaf <_l_u8NMEventPending>
    436e:	b587      	and	A, dp:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4370:	b66d      	and	A, [S-110]
    4372:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4374:	b56d      	and	A, dp:0x6d <_ml_driver_mode+0xf>
    4376:	76e7      	jmp	R
    4378:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    437a:	75e7      	lod	PC, dp:0xe7 <_LINBaud+0x1>
    437c:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    437e:	6800      	lod	AH, #0
    4380:	b140      	adc	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4382:	814e      	add	AL, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4384:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4386:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4388:	894f      	sub	AL, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    438a:	7141      	lod	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    438c:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    438e:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    4390:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4392:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4394:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    4396:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4398:	b144      	adc	A, dp:0x44 <_g_e8MotorDirectionCCW>
    439a:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    439c:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    439e:	6800      	lod	AH, #0
    43a0:	b154      	adc	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    43a2:	814e      	add	AL, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    43a4:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    43a6:	b155      	adc	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    43a8:	894f      	sub	AL, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    43aa:	7155      	lod	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    43ac:	b156      	adc	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43ae:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    43b0:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43b2:	b157      	adc	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43b4:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    43b6:	7157      	lod	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43b8:	6800      	lod	AH, #0
    43ba:	b34e      	adc	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    43bc:	b24f      	adc	A, [S-80]
    43be:	b15a      	adc	A, dp:0x5a <_LIN_nad>
    43c0:	e349      	add	Y, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    43c2:	ea4a      	sub	Y, [S-75]
    43c4:	e94b      	sub	Y, dp:0x4b <__bss_dp_size+0x1>
    43c6:	1003      	call	0x43ce <__mlx4_flash_start+0x3ce>
    43c8:	7349      	lod	A, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    43ca:	724a      	lod	A, [S-75]
    43cc:	714b      	lod	A, dp:0x4b <__bss_dp_size+0x1>
    43ce:	e346      	add	Y, ep:0x46 <_g_u16ActuatorActPos>
    43d0:	ea47      	sub	Y, [S-72]
    43d2:	e948      	sub	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    43d4:	0003      	jmp	0x43dc <__mlx4_flash_start+0x3dc>
    43d6:	7346      	lod	A, ep:0x46 <_g_u16ActuatorActPos>
    43d8:	7247      	lod	A, [S-72]
    43da:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    43dc:	e684      	or	Y, io:0x4 <_LinMess>
    43de:	ed80      	cmp	Y, dp:0x80 <_CmdArr+0x6>
    43e0:	0009      	jmp	0x43f4 <__mlx4_flash_start+0x3f4>
    43e2:	8350      	add	AL, ep:0x50 <_g_u16PID_I>
    43e4:	8a51      	sub	AL, [S-82]
    43e6:	8952      	sub	AL, dp:0x52 <_LinFrameDataBuffer>
    43e8:	7350      	lod	A, ep:0x50 <_g_u16PID_I>
    43ea:	7251      	lod	A, [S-82]
    43ec:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    43ee:	b353      	adc	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    43f0:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    43f2:	7353      	lod	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    43f4:	6800      	lod	AH, #0
    43f6:	b157      	adc	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43f8:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    43fa:	7157      	lod	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43fc:	b156      	adc	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43fe:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4400:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4402:	b155      	adc	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    4404:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4406:	7155      	lod	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    4408:	b154      	adc	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    440a:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    440c:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    440e:	b144      	adc	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4410:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4412:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4414:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4416:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4418:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    441a:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    441c:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    441e:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4420:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4422:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4424:	7141      	lod	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4426:	b140      	adc	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4428:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    442a:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    442c:	6800      	lod	AH, #0
    442e:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4430:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4432:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4434:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    4436:	0006      	jmp	0x4444 <__mlx4_flash_start+0x444>
    4438:	0102      	jmp	0x463e <__mlx4_flash_start+0x63e>
    443a:	4050      	jmp	fp2:0x80
    443c:	222a      	add	X, [S-43]
    443e:	b20a      	adc	A, [S-11]
    4440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    4442:	2226      	add	X, [S-39]
    4444:	4592      	mov	dp:0x92 <_s_CVRequestStruct>, YL
    4446:	b6e5      	and	A, MH
    4448:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    444a:	b7e5      	and	A, ep:0xe5 <_LINPresc+0x1>
    444c:	7234      	lod	A, [S-53]
    444e:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    4450:	7208      	lod	A, [S-9]
    4452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    4454:	6800      	lod	AH, #0
    4456:	3e60      	xor	X, [S-97]
    4458:	3e90      	xor	X, io:0x10 <__data_dp_size>
    445a:	6800      	lod	AH, #0
    445c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    445e:	b208      	adc	A, [S-9]
    4460:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4462:	4616      	mov	[S-23], YL
    4464:	2228      	add	X, [S-41]
    4466:	820a      	add	AL, [S-11]
    4468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    446a:	8e80      	cmp	AL, io:0x0 <__dp__>
    446c:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    446e:	720a      	lod	A, [S-11]
    4470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    4472:	6800      	lod	AH, #0
    4474:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4476:	b638      	and	A, [S-57]
    4478:	6800      	lod	AH, #0
    447a:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    447c:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    447e:	753e      	lod	PC, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4480:	6800      	lod	AH, #0
    4482:	b330      	adc	A, ep:0x30 <_g_DiagResponse>
    4484:	b231      	adc	A, [S-50]
    4486:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4488:	8e80      	cmp	AL, io:0x0 <__dp__>
    448a:	7330      	lod	A, ep:0x30 <_g_DiagResponse>
    448c:	7231      	lod	A, [S-50]
    448e:	e336      	add	Y, ep:0x36 <_g_DiagResponse+0x6>
    4490:	ea37      	sub	Y, [S-56]
    4492:	6800      	lod	AH, #0
    4494:	0009      	jmp	0x44a8 <__mlx4_flash_start+0x4a8>
    4496:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    449a:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    449c:	b341      	adc	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    449e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    44a0:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    44a2:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    44a4:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    44a6:	2257      	add	X, [S-88]
    44a8:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    44aa:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    44ac:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    44ae:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    44b0:	6800      	lod	AH, #0
    44b2:	b354      	adc	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44b4:	b255      	adc	A, [S-86]
    44b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    44b8:	8a03      	sub	AL, [S-4]
    44ba:	7354      	lod	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44bc:	7255      	lod	A, [S-86]
    44be:	b356      	adc	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44c0:	b257      	adc	A, [S-88]
    44c2:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    44c4:	8e80      	cmp	AL, io:0x0 <__dp__>
    44c6:	7356      	lod	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44c8:	7257      	lod	A, [S-88]
    44ca:	6800      	lod	AH, #0
    44cc:	b354      	adc	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44ce:	b255      	adc	A, [S-86]
    44d0:	e330      	add	Y, ep:0x30 <_g_DiagResponse>
    44d2:	ea31      	sub	Y, [S-50]
    44d4:	b356      	adc	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44d6:	b257      	adc	A, [S-88]
    44d8:	eb32      	sub	Y, ep:0x32 <_g_DiagResponse+0x2>
    44da:	ea33      	sub	Y, [S-52]
    44dc:	6800      	lod	AH, #0
    44de:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    44e0:	bf8f      	xor	A, ep:0x8f <_l_u8ValueFaultFlag>
    44e2:	4040      	jmp	fp2:0x00
    44e4:	0108      	jmp	0x46f6 <__mlx4_flash_start+0x6f6>
    44e6:	3cc3      	xor	X, #-61
    44e8:	b782      	and	A, ep:0x82 <_targetPos>
    44ea:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    44ec:	833c      	add	AL, ep:0x3c <_g_u16CommutTimerPeriod>
    44ee:	733c      	lod	A, ep:0x3c <_g_u16CommutTimerPeriod>
    44f0:	b33d      	adc	A, ep:0x3d <_g_u16CommutTimerPeriod+0x1>
    44f2:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    44f4:	733d      	lod	A, ep:0x3d <_g_u16CommutTimerPeriod+0x1>
    44f6:	6800      	lod	AH, #0
    44f8:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    44fa:	a78f      	or	A, ep:0x8f <_l_u8ValueFaultFlag>
    44fc:	0101      	jmp	0x4700 <__mlx4_flash_start+0x700>
    44fe:	3cc3      	xor	X, #-61
    4500:	6800      	lod	AH, #0
    4502:	2939      	sub	X, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4504:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4506:	493c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, AH
    4508:	b681      	and	A, io:0x1 <__dp__+0x1>
    450a:	b75e      	and	A, ep:0x5e <_ml_driver_mode>
    450c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    450e:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    4510:	b680      	and	A, io:0x0 <__dp__>
    4512:	b75e      	and	A, ep:0x5e <_ml_driver_mode>
    4514:	b682      	and	A, io:0x2 <_LinCmnd>
    4516:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    4518:	3b33      	subc	X, ep:0x33 <_g_DiagResponse+0x3>
    451a:	6800      	lod	AH, #0
    451c:	3b12      	subc	X, ep:0x12 <__data_dp_size+0x2>
    451e:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    4520:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4522:	b682      	and	A, io:0x2 <_LinCmnd>
    4524:	bfbc      	xor	A, ep:0xbc <_g_u16CurrentMotorCoilB>
    4526:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    4528:	6800      	lod	AH, #0
    452a:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    452c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    452e:	1106      	call	0x473c <__mlx4_flash_start+0x73c>
    4530:	e781      	or	Y, ep:0x81 <_CmdArr+0x7>
    4532:	1108      	call	0x4744 <__mlx4_flash_start+0x744>
    4534:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4536:	7381      	lod	A, ep:0x81 <_CmdArr+0x7>
    4538:	5404      	ret	#5
    453a:	202f      	add	X, #47
    453c:	e78e      	or	Y, ep:0x8e <_l_u8OBDValveStatusFault>
    453e:	0102      	jmp	0x4744 <__mlx4_flash_start+0x744>
    4540:	a752      	or	A, ep:0x52 <_LinFrameDataBuffer>
    4542:	1104      	call	0x474c <__mlx4_flash_start+0x74c>
    4544:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4546:	7381      	lod	A, ep:0x81 <_CmdArr+0x7>
    4548:	5404      	ret	#5
    454a:	6800      	lod	AH, #0
    454c:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    454e:	7381      	lod	A, ep:0x81 <_CmdArr+0x7>
    4550:	5404      	ret	#5
    4552:	e684      	or	Y, io:0x4 <_LinMess>
    4554:	1102      	call	0x475a <__mlx4_flash_start+0x75a>
    4556:	b582      	and	A, dp:0x82 <_targetPos>
    4558:	29d4      	sub	X, dp:0xd4 <_l_u8ErrorLogIdx>
    455a:	7201      	lod	A, [S-2]
    455c:	e682      	or	Y, io:0x2 <_LinCmnd>
    455e:	1101      	call	0x4762 <__mlx4_flash_start+0x762>
    4560:	248f      	or	X, #-113
    4562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    4564:	1101      	call	0x4768 <__mlx4_flash_start+0x768>
    4566:	2967      	sub	X, dp:0x67 <_ml_driver_mode+0x9>
    4568:	2487      	or	X, #-121
    456a:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    456c:	bf8d      	xor	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    456e:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4570:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4572:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4574:	b782      	and	A, ep:0x82 <_targetPos>
    4576:	22d2      	add	X, [A++]
    4578:	0b04      	setb	io:0x00.4
    457a:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    457c:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusMove>
    457e:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4580:	22e5      	add	X, MH
    4582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    4584:	b20d      	adc	A, [S-14]
    4586:	7238      	lod	A, [S-57]
    4588:	b202      	adc	A, [S-3]
    458a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    458c:	b203      	adc	A, [S-4]
    458e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    4590:	b63e      	and	A, [S-63]
    4592:	22d7      	.word	0x22d7
    4594:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    4596:	7201      	lod	A, [S-2]
    4598:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    459a:	b365      	adc	A, ep:0x65 <_ml_driver_mode+0x7>
    459c:	bf81      	xor	A, ep:0x81 <_CmdArr+0x7>
    459e:	0101      	jmp	0x47a2 <__mlx4_flash_start+0x7a2>
    45a0:	6800      	lod	AH, #0
    45a2:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    45a4:	0b04      	setb	io:0x00.4
    45a6:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    45a8:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusMove>
    45aa:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    45ac:	22e5      	add	X, MH
    45ae:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    45b0:	7235      	lod	A, [S-54]
    45b2:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusMove>
    45b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    45b6:	718a      	lod	A, dp:0x8a <_l_u16OBDValveStatusPosition>
    45b8:	b338      	adc	A, ep:0x38 <_g_u16CorrectionRatio>
    45ba:	738b      	lod	A, ep:0x8b <_l_u16OBDValveStatusPosition+0x1>
    45bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    45be:	b20f      	adc	A, [S-16]
    45c0:	738e      	lod	A, ep:0x8e <_l_u8OBDValveStatusFault>
    45c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    45c4:	5408      	ret	#9
    45c6:	7ca6      	lod	X, #-90
    45c8:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    45ca:	6800      	lod	AH, #0
    45cc:	b384      	adc	A, ep:0x84 <_l_u16RecoryPos>
    45ce:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    45d0:	7380      	lod	A, ep:0x80 <_CmdArr+0x6>
    45d2:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    45d4:	7235      	lod	A, [S-54]
    45d6:	7ca7      	lod	X, #-89
    45d8:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    45da:	6c03      	lod	YH, #3
    45dc:	2300      	add	X, ep:0x0 <__dp__>
    45de:	2295      	add	X, io:0x15 <__data_dp_size+0x5>
    45e0:	23ee      	add	X, ep:0xee <_l_u8LinInFrameMsgID>
    45e2:	2300      	add	X, ep:0x0 <__dp__>
    45e4:	2300      	add	X, ep:0x0 <__dp__>
    45e6:	23a1      	add	X, ep:0xa1 <_l_u8ValveInitEnds>
    45e8:	240b      	or	X, #11
    45ea:	23cb      	add	X, ep:0xcb <_l_u8OverTemperatureWarnCount>
    45ec:	2300      	add	X, ep:0x0 <__dp__>
    45ee:	2300      	add	X, ep:0x0 <__dp__>
    45f0:	2304      	add	X, ep:0x4 <_LinMess>
    45f2:	23c3      	add	X, ep:0xc3 <_l_u16CurrentZeroOffset+0x1>
    45f4:	23e6      	add	X, ep:0xe6 <_LINBaud>
    45f6:	23da      	add	X, ep:0xda <_g_u8MotorHoldingCurrState>
    45f8:	2300      	add	X, ep:0x0 <__dp__>
    45fa:	23b7      	add	X, ep:0xb7 <__bss_size+0x1>
    45fc:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    45fe:	2301      	add	X, ep:0x1 <__dp__+0x1>
    4600:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4602:	7381      	lod	A, ep:0x81 <_CmdArr+0x7>
    4604:	5404      	ret	#5
    4606:	6800      	lod	AH, #0
    4608:	e682      	or	Y, io:0x2 <_LinCmnd>
    460a:	0104      	jmp	0x4814 <__mlx4_flash_start+0x814>
    460c:	b681      	and	A, io:0x1 <__dp__+0x1>
    460e:	7282      	lod	A, io:0x2 <_LinCmnd>
    4610:	b684      	and	A, io:0x4 <_LinMess>
    4612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    4614:	b680      	and	A, io:0x0 <__dp__>
    4616:	7282      	lod	A, io:0x2 <_LinCmnd>
    4618:	b680      	and	A, io:0x0 <__dp__>
    461a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    461c:	22fe      	add	X, [X+6]
    461e:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4620:	a688      	or	A, io:0x8 <__bist_stat_size>
    4622:	0102      	jmp	0x4828 <__mlx4_flash_start+0x828>
    4624:	b582      	and	A, dp:0x82 <_targetPos>
    4626:	2315      	add	X, ep:0x15 <__data_dp_size+0x5>
    4628:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    462a:	7170      	lod	A, dp:0x70 <_ml_driver_mode+0x12>
    462c:	a684      	or	A, io:0x4 <_LinMess>
    462e:	0101      	jmp	0x4832 <__mlx4_flash_start+0x832>
    4630:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    4634:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4636:	7271      	lod	A, [S-114]
    4638:	b286      	adc	A, io:0x6 <_LinMess2>
    463a:	4616      	mov	[S-23], YL
    463c:	7286      	lod	A, io:0x6 <_LinMess2>
    463e:	b271      	adc	A, [S-114]
    4640:	b5a3      	and	A, dp:0xa3 <_l_u8OBDValveElectricError>
    4642:	0009      	jmp	0x4656 <__mlx4_flash_start+0x656>
    4644:	6c02      	lod	YH, #2
    4646:	bd8e      	xor	A, dp:0x8e <_l_u8OBDValveStatusFault>
    4648:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    464a:	bd8d      	xor	A, dp:0x8d <_l_u8OBDValveStatusVolt>
    464c:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    464e:	bd8b      	xor	A, dp:0x8b <_l_u16OBDValveStatusPosition+0x1>
    4650:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4652:	bd87      	xor	A, dp:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4654:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4656:	6c02      	lod	YH, #2
    4658:	f581      	and	Y, dp:0x81 <_CmdArr+0x7>
    465a:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    465c:	f582      	and	Y, dp:0x82 <_targetPos>
    465e:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4660:	f584      	and	Y, dp:0x84 <_l_u16RecoryPos>
    4662:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4664:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusMove>
    4666:	b691      	and	A, io:0x11 <__data_dp_size+0x1>
    4668:	b170      	adc	A, dp:0x70 <_ml_driver_mode+0x12>
    466a:	76a3      	jmp	io:0x23 <_l_u8VTIdx+0x1>
    466c:	e78a      	or	Y, ep:0x8a <_l_u16OBDValveStatusPosition>
    466e:	1008      	call	0x4680 <__mlx4_flash_start+0x680>
    4670:	8782      	or	AL, ep:0x82 <_targetPos>
    4672:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4674:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    4676:	4794      	mov	ep:0x94 <_s_CVRequestStruct+0x2>, YL
    4678:	0101      	jmp	0x487c <__mlx4_flash_start+0x87c>
    467a:	231c      	add	X, ep:0x1c <_g_sMotorFault>
    467c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    467e:	231d      	add	X, ep:0x1d <_g_sMotorFault+0x1>
    4680:	e78c      	or	Y, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4682:	1003      	call	0x468a <__mlx4_flash_start+0x68a>
    4684:	8782      	or	AL, ep:0x82 <_targetPos>
    4686:	4050      	jmp	fp2:0x80
    4688:	231f      	add	X, ep:0x1f <__ramfunc_size+0x1>
    468a:	22fe      	add	X, [X+6]
    468c:	b202      	adc	A, [S-3]
    468e:	b36b      	adc	A, ep:0x6b <_ml_driver_mode+0xd>
    4690:	836a      	add	AL, ep:0x6a <_ml_driver_mode+0xc>
    4692:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    4694:	bf81      	xor	A, ep:0x81 <_CmdArr+0x7>
    4696:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4698:	6c03      	lod	YH, #3
    469a:	2375      	add	X, ep:0x75 <__bss_dp_end+0x3>
    469c:	2351      	add	X, ep:0x51 <_g_u16PID_I+0x1>
    469e:	236c      	add	X, ep:0x6c <_ml_driver_mode+0xe>
    46a0:	2375      	add	X, ep:0x75 <__bss_dp_end+0x3>
    46a2:	8681      	or	AL, io:0x1 <__dp__+0x1>
    46a4:	7202      	lod	A, [S-3]
    46a6:	b203      	adc	A, [S-4]
    46a8:	8e80      	cmp	AL, io:0x0 <__dp__>
    46aa:	f36b      	adc	Y, ep:0x6b <_ml_driver_mode+0xd>
    46ac:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    46ae:	b786      	and	A, ep:0x86 <_l_u8SavePosFlag>
    46b0:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    46b2:	0002      	jmp	0x46b8 <__mlx4_flash_start+0x6b8>
    46b4:	0106      	jmp	0x48c2 <__mlx4_flash_start+0x8c2>
    46b6:	2373      	add	X, ep:0x73 <__bss_dp_end+0x1>
    46b8:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    46ba:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    46bc:	1003      	call	0x46c4 <__mlx4_flash_start+0x6c4>
    46be:	b78f      	and	A, ep:0x8f <_l_u8ValueFaultFlag>
    46c0:	2362      	add	X, ep:0x62 <_ml_driver_mode+0x4>
    46c2:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    46c4:	0000      	nop
    46c6:	0000      	nop
    46c8:	0000      	nop
    46ca:	0000      	nop
    46cc:	0000      	nop
    46ce:	0000      	nop
    46d0:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    46d2:	e780      	or	Y, ep:0x80 <_CmdArr+0x6>
    46d4:	0108      	jmp	0x48e6 <__mlx4_flash_start+0x8e6>
    46d6:	2362      	add	X, ep:0x62 <_ml_driver_mode+0x4>
    46d8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    46da:	7202      	lod	A, [S-3]
    46dc:	b203      	adc	A, [S-4]
    46de:	ce80      	cmp	AH, io:0x0 <__dp__>
    46e0:	b78e      	and	A, ep:0x8e <_l_u8OBDValveStatusFault>
    46e2:	bb6b      	subc	A, ep:0x6b <_ml_driver_mode+0xd>
    46e4:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    46e6:	7203      	lod	A, [S-4]
    46e8:	4c02 6800 	add	D, #1920034816
    46ec:	7271 
    46ee:	b16d      	adc	A, dp:0x6d <_ml_driver_mode+0xf>
    46f0:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    46f2:	716d      	lod	A, dp:0x6d <_ml_driver_mode+0xf>
    46f4:	0b04      	setb	io:0x00.4
    46f6:	b25e      	adc	A, [S-95]
    46f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    46fa:	725e      	lod	A, [S-95]
    46fc:	2388      	add	X, ep:0x88 <_l_u8OBDValveStatusMove>
    46fe:	7189      	lod	A, dp:0x89 <_l_u8OBDValveStatusMove+0x1>
    4700:	7134      	lod	A, dp:0x34 <_g_DiagResponse+0x4>
    4702:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4704:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    4706:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4708:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusMove>
    470a:	5408      	ret	#9
    470c:	7c55      	lod	X, #85
    470e:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    4710:	b691      	and	A, io:0x11 <__data_dp_size+0x1>
    4712:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusMove>
    4714:	3beb      	subc	X, ep:0xeb <_l_u16PhysicalTargetPos+0x1>
    4716:	b5a6      	and	A, dp:0xa6 <_l_e8ValveState>
    4718:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    471a:	a58f      	or	A, dp:0x8f <_l_u8ValueFaultFlag>
    471c:	1103      	call	0x4924 <__mlx4_flash_start+0x924>
    471e:	b16c      	adc	A, dp:0x6c <_ml_driver_mode+0xe>
    4720:	bd84      	xor	A, dp:0x84 <_l_u16RecoryPos>
    4722:	716c      	lod	A, dp:0x6c <_ml_driver_mode+0xe>
    4724:	b271      	adc	A, [S-114]
    4726:	6800      	lod	AH, #0
    4728:	a688      	or	A, io:0x8 <__bist_stat_size>
    472a:	110a      	call	0x4940 <__mlx4_flash_start+0x940>
    472c:	b23b      	adc	A, [S-60]
    472e:	f684      	and	Y, io:0x4 <_LinMess>
    4730:	723b      	lod	A, [S-60]
    4732:	b35a      	adc	A, ep:0x5a <_LIN_nad>
    4734:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4736:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4738:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    473a:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    473c:	7343      	lod	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    473e:	7344      	lod	A, ep:0x44 <_g_e8MotorDirectionCCW>
    4740:	6800      	lod	AH, #0
    4742:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4744:	b286      	adc	A, io:0x6 <_LinMess2>
    4746:	010a      	jmp	0x495c <__mlx4_flash_start+0x95c>
    4748:	000e      	jmp	0x4766 <__mlx4_flash_start+0x766>
    474a:	e680      	or	Y, io:0x0 <__dp__>
    474c:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    474e:	0103      	jmp	0x4956 <__mlx4_flash_start+0x956>
    4750:	f782      	and	Y, ep:0x82 <_targetPos>
    4752:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4754:	22fe      	add	X, [X+6]
    4756:	bf8d      	xor	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4758:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    475a:	22fe      	add	X, [X+6]
    475c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    475e:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusMove>
    4760:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4762:	7200      	lod	A, [S-1]
    4764:	22fe      	add	X, [X+6]
    4766:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4768:	f784      	and	Y, ep:0x84 <_l_u16RecoryPos>
    476a:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    476c:	22fe      	add	X, [X+6]
    476e:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    4770:	bf8d      	xor	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4772:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4774:	a682      	or	A, io:0x2 <_LinCmnd>
    4776:	1106      	call	0x4984 <__mlx4_flash_start+0x984>
    4778:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    477a:	bf8e      	xor	A, ep:0x8e <_l_u8OBDValveStatusFault>
    477c:	a681      	or	A, io:0x1 <__dp__+0x1>
    477e:	0101      	jmp	0x4982 <__mlx4_flash_start+0x982>
    4780:	f781      	and	Y, ep:0x81 <_CmdArr+0x7>
    4782:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4784:	22fe      	add	X, [X+6]
    4786:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4788:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    478a:	0101      	jmp	0x498e <__mlx4_flash_start+0x98e>
    478c:	2300      	add	X, ep:0x0 <__dp__>
    478e:	7264      	lod	A, [S-101]
    4790:	b286      	adc	A, io:0x6 <_LinMess2>
    4792:	7265      	lod	A, [S-102]
    4794:	22fe      	add	X, [X+6]
    4796:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4798:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    479a:	0101      	jmp	0x499e <__mlx4_flash_start+0x99e>
    479c:	2300      	add	X, ep:0x0 <__dp__>
    479e:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    47a0:	be86      	xor	A, io:0x6 <_LinMess2>
    47a2:	6c02      	lod	YH, #2
    47a4:	3e04      	xor	X, [S-5]
    47a6:	23d9      	add	X, ep:0xd9 <_l_u16StartupDelayInit+0x1>
    47a8:	3e05      	xor	X, [S-6]
    47aa:	23d9      	add	X, ep:0xd9 <_l_u16StartupDelayInit+0x1>
    47ac:	3e06      	xor	X, [S-7]
    47ae:	23d9      	add	X, ep:0xd9 <_l_u16StartupDelayInit+0x1>
    47b0:	3e07      	xor	X, [S-8]
    47b2:	22fe      	add	X, [X+6]
    47b4:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    47b6:	e681      	or	Y, io:0x1 <__dp__+0x1>
    47b8:	0106      	jmp	0x49c6 <__mlx4_flash_start+0x9c6>
    47ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    47bc:	0102      	jmp	0x49c2 <__mlx4_flash_start+0x9c2>
    47be:	b680      	and	A, io:0x0 <__dp__>
    47c0:	23e4      	add	X, ep:0xe4 <_LINPresc>
    47c2:	b682      	and	A, io:0x2 <_LinCmnd>
    47c4:	23e4      	add	X, ep:0xe4 <_LINPresc>
    47c6:	b684      	and	A, io:0x4 <_LinMess>
    47c8:	726c      	lod	A, [S-109]
    47ca:	22fe      	add	X, [X+6]
    47cc:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    47ce:	7382      	lod	A, ep:0x82 <_targetPos>
    47d0:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    47d2:	7383      	lod	A, ep:0x83 <_targetPos+0x1>
    47d4:	f686      	and	Y, io:0x6 <_LinMess2>
    47d6:	bf92      	xor	A, ep:0x92 <_s_CVRequestStruct>
    47d8:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    47da:	22fe      	add	X, [X+6]
    47dc:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    47de:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    47e0:	0101      	jmp	0x49e4 <__mlx4_flash_start+0x9e4>
    47e2:	2300      	add	X, ep:0x0 <__dp__>
    47e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    47e6:	010e      	jmp	0x4a04 <__mlx4_flash_start+0xa04>
    47e8:	763e      	jmp	[S-63]
    47ea:	7207      	lod	A, [S-8]
    47ec:	7206      	lod	A, [S-7]
    47ee:	b286      	adc	A, io:0x6 <_LinMess2>
    47f0:	7202      	lod	A, [S-3]
    47f2:	7204      	lod	A, [S-5]
    47f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    47f6:	7203      	lod	A, [S-4]
    47f8:	7205      	lod	A, [S-6]
    47fa:	b25c      	adc	A, [S-93]
    47fc:	f684      	and	Y, io:0x4 <_LinMess>
    47fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4800:	725c      	lod	A, [S-93]
    4802:	22fe      	add	X, [X+6]
    4804:	b25c      	adc	A, [S-93]
    4806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4808:	b386      	adc	A, ep:0x86 <_l_u8SavePosFlag>
    480a:	e780      	or	Y, ep:0x80 <_CmdArr+0x6>
    480c:	0101      	jmp	0x4a10 <__mlx4_flash_start+0xa10>
    480e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    4812:	725c      	lod	A, [S-93]
    4814:	22fe      	add	X, [X+6]
    4816:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4818:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    481a:	0101      	jmp	0x4a1e <__mlx4_flash_start+0xa1e>
    481c:	2300      	add	X, ep:0x0 <__dp__>
    481e:	b387      	adc	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4820:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4822:	0001      	jmp	0x4826 <__mlx4_flash_start+0x826>
    4824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    4826:	7271      	lod	A, [S-114]
    4828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    482a:	4608      	mov	[S-9], YL
    482c:	6c02      	lod	YH, #2
    482e:	b11c      	adc	A, dp:0x1c <_g_sMotorFault>
    4830:	241e      	or	X, #30
    4832:	b11d      	adc	A, dp:0x1d <_g_sMotorFault+0x1>
    4834:	241e      	or	X, #30
    4836:	b12c      	adc	A, dp:0x2c <__data_dp_end+0x4>
    4838:	241e      	or	X, #30
    483a:	b12d      	adc	A, dp:0x2d <__data_dp_end+0x5>
    483c:	b387      	adc	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    483e:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4840:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4842:	b371      	adc	A, ep:0x71 <_ml_driver_mode+0x13>
    4844:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4846:	4788      	mov	ep:0x88 <_l_u8OBDValveStatusMove>, YL
    4848:	0009      	jmp	0x485c <__mlx4_flash_start+0x85c>
    484a:	6c03      	lod	YH, #3
    484c:	bd8e      	xor	A, dp:0x8e <_l_u8OBDValveStatusFault>
    484e:	2436      	or	X, #54
    4850:	bd8d      	xor	A, dp:0x8d <_l_u8OBDValveStatusVolt>
    4852:	2436      	or	X, #54
    4854:	bd8b      	xor	A, dp:0x8b <_l_u16OBDValveStatusPosition+0x1>
    4856:	2436      	or	X, #54
    4858:	bd87      	xor	A, dp:0x87 <_l_u8OBDValveStatusSpeedLevel>
    485a:	2436      	or	X, #54
    485c:	6c03      	lod	YH, #3
    485e:	f581      	and	Y, dp:0x81 <_CmdArr+0x7>
    4860:	2436      	or	X, #54
    4862:	f582      	and	Y, dp:0x82 <_targetPos>
    4864:	2436      	or	X, #54
    4866:	f584      	and	Y, dp:0x84 <_l_u16RecoryPos>
    4868:	2436      	or	X, #54
    486a:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusMove>
    486c:	6c02      	lod	YH, #2
    486e:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    4870:	243e      	or	X, #62
    4872:	711d      	lod	A, dp:0x1d <_g_sMotorFault+0x1>
    4874:	243e      	or	X, #62
    4876:	712c      	lod	A, dp:0x2c <__data_dp_end+0x4>
    4878:	243e      	or	X, #62
    487a:	712d      	lod	A, dp:0x2d <__data_dp_end+0x5>
    487c:	22fe      	add	X, [X+6]
    487e:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4880:	b682      	and	A, io:0x2 <_LinCmnd>
    4882:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4884:	7c01      	lod	X, #1
    4886:	5018      	call	fp0:0xC0
    4888:	54c0      	.word	0x54c0
    488a:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    488c:	733e      	lod	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    488e:	733f      	lod	A, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    4890:	5401      	ret
    4892:	3e60      	xor	X, [S-97]
    4894:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4896:	773a      	lod	PC, ep:0x3a <_g_u16MicroStepIdx>
    4898:	773b      	lod	PC, ep:0x3b <_g_u16MicroStepIdx+0x1>
    489a:	773f      	lod	PC, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    489c:	355b      	and	X, dp:0x5b <_LIN_nad+0x1>
    489e:	365b      	and	X, [S-92]
    48a0:	3730      	and	X, ep:0x30 <_g_DiagResponse>
    48a2:	7736      	lod	PC, ep:0x36 <_g_DiagResponse+0x6>
    48a4:	3ba0      	subc	X, ep:0xa0 <_l_e8GmcvInitDirection>
    48a6:	b78f      	and	A, ep:0x8f <_l_u8ValueFaultFlag>
    48a8:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    48aa:	b681      	and	A, io:0x1 <__dp__+0x1>
    48ac:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    48ae:	b78e      	and	A, ep:0x8e <_l_u8OBDValveStatusFault>
    48b0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    48b2:	b680      	and	A, io:0x0 <__dp__>
    48b4:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    48b6:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    48b8:	7301      	lod	A, ep:0x1 <__dp__+0x1>
    48ba:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    48bc:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    48be:	494e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, AH
    48c0:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    48c2:	493a      	mov	dp:0x3a <_g_u16MicroStepIdx>, AH
    48c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    48c6:	4964      	mov	dp:0x64 <_ml_driver_mode+0x6>, AH
    48c8:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    48ca:	736c      	lod	A, ep:0x6c <_ml_driver_mode+0xe>
    48cc:	735c      	lod	A, ep:0x5c <_LinMessage>
    48ce:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    48d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    48d2:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    48d4:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    48d6:	b58b      	and	A, dp:0x8b <_l_u16OBDValveStatusPosition+0x1>
    48d8:	7105      	lod	A, dp:0x5 <_LinMess+0x1>
    48da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    48dc:	b58c      	and	A, dp:0x8c <_l_u8OBDValveStatusOverTempWarn>
    48de:	7104      	lod	A, dp:0x4 <_LinMess>
    48e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    48e2:	b583      	and	A, dp:0x83 <_targetPos+0x1>
    48e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    48e6:	7106      	lod	A, dp:0x6 <_LinMess2>
    48e8:	b680      	and	A, io:0x0 <__dp__>
    48ea:	77c6      	lod	PC, ep:0xc6 <_l_u16CoilZeroCurrCountB>
    48ec:	77ca      	lod	PC, ep:0xca <_l_u8OverTemperatureShutCount>
    48ee:	8681      	or	AL, io:0x1 <__dp__+0x1>
    48f0:	0101      	jmp	0x4af4 <__mlx4_flash_start+0xaf4>
    48f2:	2475      	or	X, #117
    48f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    48f6:	7336      	lod	A, ep:0x36 <_g_DiagResponse+0x6>
    48f8:	7237      	lod	A, [S-56]
    48fa:	b788      	and	A, ep:0x88 <_l_u8OBDValveStatusMove>
    48fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    48fe:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4900:	738c      	lod	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4902:	b784      	and	A, ep:0x84 <_l_u16RecoryPos>
    4904:	738d      	lod	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4906:	7c02      	lod	X, #2
    4908:	5820      	inc	S, #33
    490a:	b681      	and	A, io:0x1 <__dp__+0x1>
    490c:	62ca      	lod	AL, [--PC]
    490e:	622b      	lod	AL, [S-44]
    4910:	3448      	and	X, #72
    4912:	5809      	inc	S, #10
    4914:	62e6      	lod	AL, Y
    4916:	2489      	or	X, #-119
    4918:	b78a      	and	A, ep:0x8a <_l_u16OBDValveStatusPosition>
    491a:	b682      	and	A, io:0x2 <_LinCmnd>
    491c:	62ca      	lod	AL, [--PC]
    491e:	5018      	call	fp0:0xC0
    4920:	54c0      	.word	0x54c0
    4922:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4924:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4926:	24a3      	or	X, #-93
    4928:	b680      	and	A, io:0x0 <__dp__>
    492a:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    492c:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    492e:	0106      	jmp	0x4b3c <__mlx4_flash_start+0xb3c>
    4930:	bf8e      	xor	A, ep:0x8e <_l_u8OBDValveStatusFault>
    4932:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4934:	b239      	adc	A, [S-58]
    4936:	7238      	lod	A, [S-57]
    4938:	b582      	and	A, dp:0x82 <_targetPos>
    493a:	b686      	and	A, io:0x6 <_LinMess2>
    493c:	e680      	or	Y, io:0x0 <__dp__>
    493e:	0101      	jmp	0x4b42 <__mlx4_flash_start+0xb42>
    4940:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4942:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4944:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4946:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    4948:	bd88      	xor	A, dp:0x88 <_l_u8OBDValveStatusMove>
    494a:	716f      	lod	A, dp:0x6f <_ml_driver_mode+0x11>
    494c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    494e:	a78d      	or	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    4950:	1101      	call	0x4b54 <__mlx4_flash_start+0xb54>
    4952:	24c2      	or	X, #-62
    4954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    4956:	494e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, AH
    4958:	b58e      	and	A, dp:0x8e <_l_u8OBDValveStatusFault>
    495a:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    495c:	e53e      	or	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    495e:	1101      	call	0x4b62 <__mlx4_flash_start+0xb62>
    4960:	24c2      	or	X, #-62
    4962:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4964:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    4966:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4968:	b341      	adc	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    496a:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    496c:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    496e:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4970:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4972:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4974:	b343      	adc	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4976:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4978:	7343      	lod	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    497a:	b344      	adc	A, ep:0x44 <_g_e8MotorDirectionCCW>
    497c:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    497e:	7344      	lod	A, ep:0x44 <_g_e8MotorDirectionCCW>
    4980:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4982:	24ae      	or	X, #-82
    4984:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4986:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    4988:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    498a:	7167      	lod	A, dp:0x67 <_ml_driver_mode+0x9>
    498c:	b58e      	and	A, dp:0x8e <_l_u8OBDValveStatusFault>
    498e:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    4990:	e106      	add	Y, dp:0x6 <_LinMess2>
    4992:	0108      	jmp	0x4ba4 <__mlx4_flash_start+0xba4>
    4994:	b266      	adc	A, [S-103]
    4996:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4998:	7266      	lod	A, [S-103]
    499a:	b267      	adc	A, [S-104]
    499c:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    499e:	7267      	lod	A, [S-104]
    49a0:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    49a2:	24c8      	or	X, #-56
    49a4:	4d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, YH
    49a6:	4968      	mov	dp:0x68 <_ml_driver_mode+0xa>, AH
    49a8:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    49aa:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    49ac:	733a      	lod	A, ep:0x3a <_g_u16MicroStepIdx>
    49ae:	623a      	lod	AL, [S-59]
    49b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    49b2:	1104      	call	0x4bbc <__mlx4_flash_start+0xbbc>
    49b4:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49b6:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    49b8:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49ba:	24f2      	or	X, #-14
    49bc:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49be:	a78d      	or	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    49c0:	0103      	jmp	0x4bc8 <__mlx4_flash_start+0xbc8>
    49c2:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    49c4:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49c6:	2494      	or	X, #-108
    49c8:	580e      	inc	S, #15
    49ca:	0803      	clrb	dp:0x00.3
    49cc:	0906      	clrb	io:0x00.6
    49ce:	62e6      	lod	AL, Y
    49d0:	24e4      	or	X, #-28
    49d2:	623a      	lod	AL, [S-59]
    49d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    49d6:	0106      	jmp	0x4be4 <__mlx4_flash_start+0xbe4>
    49d8:	24e4      	or	X, #-28
    49da:	626f      	lod	AL, [S-112]
    49dc:	0001      	jmp	0x49e0 <__mlx4_flash_start+0x9e0>
    49de:	24e9      	or	X, #-23
    49e0:	b586      	and	A, dp:0x86 <_l_u8SavePosFlag>
    49e2:	29d4      	sub	X, dp:0xd4 <_l_u8ErrorLogIdx>
    49e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    49e6:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    49e8:	380d      	subc	X, #13
    49ea:	3805      	subc	X, #5
    49ec:	3479      	and	X, #121
    49ee:	303a      	adc	X, #58
    49f0:	39f6      	subc	X, dp:0xf6 <_g_AdcMotorRunStepper4+0x6>
    49f2:	b26c      	adc	A, [S-109]
    49f4:	a686      	or	A, io:0x6 <_LinMess2>
    49f6:	0106      	jmp	0x4c04 <__mlx4_flash_start+0xc04>
    49f8:	f681      	and	Y, io:0x1 <__dp__+0x1>
    49fa:	726c      	lod	A, [S-109]
    49fc:	b26e      	adc	A, [S-111]
    49fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    4a00:	1101      	call	0x4c04 <__mlx4_flash_start+0xc04>
    4a02:	6376      	lod	AL, ep:0x76 <__data_size>
    4a04:	3cc3      	xor	X, #-61
    4a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    4a08:	be38      	xor	A, [S-57]
    4a0a:	0101      	jmp	0x4c0e <__mlx4_flash_start+0xc0e>
    4a0c:	2494      	or	X, #-108
    4a0e:	580e      	inc	S, #15
    4a10:	0905      	clrb	io:0x00.5
    4a12:	0802      	clrb	dp:0x00.2
    4a14:	62e6      	lod	AL, Y
    4a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a18:	623a      	lod	AL, [S-59]
    4a1a:	2522      	or	X, dp:0x22 <_l_u8VTIdx>
    4a1c:	623a      	lod	AL, [S-59]
    4a1e:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4a20:	bd8e      	xor	A, dp:0x8e <_l_u8OBDValveStatusFault>
    4a22:	a681      	or	A, io:0x1 <__dp__+0x1>
    4a24:	1102      	call	0x4c2a <__mlx4_flash_start+0xc2a>
    4a26:	a78c      	or	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4a28:	0101      	jmp	0x4c2c <__mlx4_flash_start+0xc2c>
    4a2a:	f581      	and	Y, dp:0x81 <_CmdArr+0x7>
    4a2c:	715c      	lod	A, dp:0x5c <_LinMessage>
    4a2e:	4050      	jmp	fp2:0x80
    4a30:	6c04      	lod	YH, #4
    4a32:	2528      	or	X, dp:0x28 <__data_dp_end>
    4a34:	2542      	or	X, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4a36:	254f      	or	X, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a3a:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4a3c:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    4a3e:	0107      	jmp	0x4c4e <__mlx4_flash_start+0xc4e>
    4a40:	bd8e      	xor	A, dp:0x8e <_l_u8OBDValveStatusFault>
    4a42:	715c      	lod	A, dp:0x5c <_LinMessage>
    4a44:	484f      	macu	D, AL, [X]
    4a46:	6c04      	lod	YH, #4
    4a48:	2557      	or	X, dp:0x57 <_LinFrameDataBuffer+0x5>
    4a4a:	2584      	or	X, dp:0x84 <_l_u16RecoryPos>
    4a4c:	25c6      	or	X, dp:0xc6 <_l_u16CoilZeroCurrCountB>
    4a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a50:	484e      	macu	D, AL, [X++]
    4a52:	61c0      	lod	AL, dp:0xc0 <_l_u8AdcPowerOff>
    4a54:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4a56:	1104      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a58:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a5a:	e585      	or	Y, dp:0x85 <_l_u16RecoryPos+0x1>
    4a5c:	1101      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a5e:	2918      	sub	X, dp:0x18 <__data_dp_start>
    4a60:	b16c      	adc	A, dp:0x6c <_ml_driver_mode+0xe>
    4a62:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    4a64:	010e      	jmp	0x4c82 <__mlx4_flash_start+0xc82>
    4a66:	b168      	adc	A, dp:0x68 <_ml_driver_mode+0xa>
    4a68:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4a6a:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    4a6c:	b169      	adc	A, dp:0x69 <_ml_driver_mode+0xb>
    4a6e:	cd80      	cmp	AH, dp:0x80 <_CmdArr+0x6>
    4a70:	7169      	lod	A, dp:0x69 <_ml_driver_mode+0xb>
    4a72:	1107      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a74:	4d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, YH
    4a76:	4968      	mov	dp:0x68 <_ml_driver_mode+0xa>, AH
    4a78:	b16e      	adc	A, dp:0x6e <_ml_driver_mode+0x10>
    4a7a:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4a7c:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    4a7e:	1101      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a80:	6376      	lod	AL, ep:0x76 <__data_size>
    4a82:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4a84:	61d6      	lod	AL, dp:0xd6 <_l_u8MotorStatus>
    4a86:	7271      	lod	A, [S-114]
    4a88:	b256      	adc	A, [S-87]
    4a8a:	c242      	add	AH, [S-67]
    4a8c:	c943      	sub	AH, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a8e:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4a90:	4616      	mov	[S-23], YL
    4a92:	e242      	add	Y, [S-67]
    4a94:	e943      	sub	Y, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a96:	1002      	call	0x4a9c <__mlx4_flash_start+0xa9c>
    4a98:	b271      	adc	A, [S-114]
    4a9a:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4a9c:	2494      	or	X, #-108
    4a9e:	b15a      	adc	A, dp:0x5a <_LIN_nad>
    4aa0:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4aa2:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4aa4:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4aa6:	1001      	call	0x4aaa <__mlx4_flash_start+0xaaa>
    4aa8:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4aaa:	6394      	lod	AL, ep:0x94 <_s_CVRequestStruct+0x2>
    4aac:	25ee      	or	X, dp:0xee <_l_u8LinInFrameMsgID>
    4aae:	61c0      	lod	AL, dp:0xc0 <_l_u8AdcPowerOff>
    4ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4ab2:	1102      	call	0x4cb8 <__mlx4_flash_start+0xcb8>
    4ab4:	7c06      	lod	X, #6
    4ab6:	2494      	or	X, #-108
    4ab8:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4aba:	e144      	add	Y, dp:0x44 <_g_e8MotorDirectionCCW>
    4abc:	0005      	jmp	0x4ac8 <__mlx4_flash_start+0xac8>
    4abe:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4ac0:	e589      	or	Y, dp:0x89 <_l_u8OBDValveStatusMove+0x1>
    4ac2:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4ac4:	ed81      	cmp	Y, dp:0x81 <_CmdArr+0x7>
    4ac6:	0003      	jmp	0x4ace <__mlx4_flash_start+0xace>
    4ac8:	623d      	lod	AL, [S-62]
    4aca:	6207      	lod	AL, [S-8]
    4acc:	255c      	or	X, dp:0x5c <_LinMessage>
    4ace:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4ad0:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4ad2:	1107      	call	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad4:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    4ad6:	0105      	jmp	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    4ada:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4adc:	1002      	call	0x4ae2 <__mlx4_flash_start+0xae2>
    4ade:	b681      	and	A, io:0x1 <__dp__+0x1>
    4ae0:	2495      	or	X, #-107
    4ae2:	b36c      	adc	A, ep:0x6c <_ml_driver_mode+0xe>
    4ae4:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    4ae6:	0105      	jmp	0x4cf2 <__mlx4_flash_start+0xcf2>
    4ae8:	bf8e      	xor	A, ep:0x8e <_l_u8OBDValveStatusFault>
    4aea:	736c      	lod	A, ep:0x6c <_ml_driver_mode+0xe>
    4aec:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4aee:	b680      	and	A, io:0x0 <__dp__>
    4af0:	62d2      	lod	AL, [A++]
    4af2:	4d40      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, YH
    4af4:	4954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AH
    4af6:	4d42      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, YH
    4af8:	4956      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AH
    4afa:	7c4a      	lod	X, #74
    4afc:	380e      	subc	X, #14
    4afe:	3806      	subc	X, #6
    4b00:	344c      	and	X, #76
    4b02:	484f      	macu	D, AL, [X]
    4b04:	5c01      	dec	S, #2
    4b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b08:	61d0      	lod	AL, dp:0xd0 <_l_u16HallSwitchState>
    4b0a:	380f      	subc	X, #15
    4b0c:	3806      	subc	X, #6
    4b0e:	300a      	adc	X, #10
    4b10:	39f0      	subc	X, dp:0xf0 <_g_AdcMotorRunStepper4>
    4b12:	348f      	and	X, #-113
    4b14:	5c02      	dec	S, #3
    4b16:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4b18:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4b1a:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4b1c:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4b1e:	4946      	mov	dp:0x46 <_g_u16ActuatorActPos>, AH
    4b20:	4948      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, AH
    4b22:	b58f      	and	A, dp:0x8f <_l_u8ValueFaultFlag>
    4b24:	714b      	lod	A, dp:0x4b <__bss_dp_size+0x1>
    4b26:	714a      	lod	A, dp:0x4a <__bss_dp_size>
    4b28:	b343      	adc	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4b2a:	b242      	adc	A, [S-67]
    4b2c:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4b2e:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4b30:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    4b32:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b34:	7241      	lod	A, [S-66]
    4b36:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b38:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4b3a:	4616      	mov	[S-23], YL
    4b3c:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b3e:	8140      	add	AL, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b40:	8a41      	sub	AL, [S-66]
    4b42:	8b42      	sub	AL, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b44:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b46:	7241      	lod	A, [S-66]
    4b48:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b4a:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    4b4c:	7251      	lod	A, [S-82]
    4b4e:	7352      	lod	A, ep:0x52 <_LinFrameDataBuffer>
    4b50:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4b52:	bf8c      	xor	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4b54:	e784      	or	Y, ep:0x84 <_l_u16RecoryPos>
    4b56:	0101      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4b58:	25c3      	or	X, dp:0xc3 <_l_u16CurrentZeroOffset+0x1>
    4b5a:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    4b5e:	100b      	call	0x4b76 <__mlx4_flash_start+0xb76>
    4b60:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4b62:	b152      	adc	A, dp:0x52 <_LinFrameDataBuffer>
    4b64:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4b66:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    4b68:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4b6a:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b6c:	7151      	lod	A, dp:0x51 <_g_u16PID_I+0x1>
    4b6e:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4b70:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b72:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    4b74:	25ae      	or	X, dp:0xae <_l_u8Mlx4ErrorStateOcc>
    4b76:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4b78:	e104      	add	Y, dp:0x4 <_LinMess>
    4b7a:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4b7c:	e905      	sub	Y, dp:0x5 <_LinMess+0x1>
    4b7e:	b152      	adc	A, dp:0x52 <_LinFrameDataBuffer>
    4b80:	ed80      	cmp	Y, dp:0x80 <_CmdArr+0x6>
    4b82:	1001      	call	0x4b86 <__mlx4_flash_start+0xb86>
    4b84:	2494      	or	X, #-108
    4b86:	4950      	mov	dp:0x50 <_g_u16PID_I>, AH
    4b88:	4952      	mov	dp:0x52 <_LinFrameDataBuffer>, AH
    4b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b8c:	61dd      	lod	AL, dp:0xdd <_l_u16MotorRefVoltageADC+0x1>
    4b8e:	1001      	call	0x4b92 <__mlx4_flash_start+0xb92>
    4b90:	25ee      	or	X, dp:0xee <_l_u8LinInFrameMsgID>
    4b92:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4b94:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4b96:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4b98:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4b9a:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4b9c:	e588      	or	Y, dp:0x88 <_l_u8OBDValveStatusMove>
    4b9e:	0101      	jmp	0x4da2 <__mlx4_flash_start+0xda2>
    4ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4ba2:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4ba4:	4592      	mov	dp:0x92 <_s_CVRequestStruct>, YL
    4ba6:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    4ba8:	b153      	adc	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4baa:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4bac:	7353      	lod	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    4bae:	b351      	adc	A, ep:0x51 <_g_u16PID_I+0x1>
    4bb0:	b252      	adc	A, [S-83]
    4bb2:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4bb4:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4bb6:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    4bb8:	7350      	lod	A, ep:0x50 <_g_u16PID_I>
    4bba:	7251      	lod	A, [S-82]
    4bbc:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    4bbe:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4bc0:	4616      	mov	[S-23], YL
    4bc2:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4bc4:	e349      	add	Y, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    4bc6:	ea4a      	sub	Y, [S-75]
    4bc8:	e94b      	sub	Y, dp:0x4b <__bss_dp_size+0x1>
    4bca:	1008      	call	0x4bdc <__mlx4_flash_start+0xbdc>
    4bcc:	8350      	add	AL, ep:0x50 <_g_u16PID_I>
    4bce:	8a51      	sub	AL, [S-82]
    4bd0:	8952      	sub	AL, dp:0x52 <_LinFrameDataBuffer>
    4bd2:	e346      	add	Y, ep:0x46 <_g_u16ActuatorActPos>
    4bd4:	ea47      	sub	Y, [S-72]
    4bd6:	e948      	sub	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    4bd8:	0001      	jmp	0x4bdc <__mlx4_flash_start+0xbdc>
    4bda:	25f6      	or	X, dp:0xf6 <_g_AdcMotorRunStepper4+0x6>
    4bdc:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4bde:	bf8c      	xor	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4be0:	e784      	or	Y, ep:0x84 <_l_u16RecoryPos>
    4be2:	1103      	call	0x4dea <__mlx4_flash_start+0xdea>
    4be4:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    4be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4be8:	2495      	or	X, #-107
    4bea:	2494      	or	X, #-108
    4bec:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4bee:	b252      	adc	A, [S-83]
    4bf0:	e680      	or	Y, io:0x0 <__dp__>
    4bf2:	b153      	adc	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4bf4:	ed80      	cmp	Y, dp:0x80 <_CmdArr+0x6>
    4bf6:	1101      	call	0x4dfa <__mlx4_flash_start+0xdfa>
    4bf8:	260e      	or	X, [S-15]
    4bfa:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4bfc:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4bfe:	7153      	lod	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4c00:	4616      	mov	[S-23], YL
    4c02:	7252      	lod	A, [S-83]
    4c04:	b251      	adc	A, [S-82]
    4c06:	4616      	mov	[S-23], YL
    4c08:	7251      	lod	A, [S-82]
    4c0a:	b250      	adc	A, [S-81]
    4c0c:	4616      	mov	[S-23], YL
    4c0e:	7250      	lod	A, [S-81]
    4c10:	b26a      	adc	A, [S-107]
    4c12:	4616      	mov	[S-23], YL
    4c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    4c16:	726a      	lod	A, [S-107]
    4c18:	61fb      	lod	AL, dp:0xfb <_l_au8FiFoErrorLog+0x1>
    4c1a:	25f7      	or	X, dp:0xf7 <_g_AdcMotorRunStepper4+0x7>
    4c1c:	b250      	adc	A, [S-81]
    4c1e:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    4c22:	ed8c      	cmp	Y, dp:0x8c <_l_u8OBDValveStatusOverTempWarn>
    4c24:	1001      	call	0x4c28 <__mlx4_flash_start+0xc28>
    4c26:	261a      	or	X, [S-27]
    4c28:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4c2a:	4616      	mov	[S-23], YL
    4c2c:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4c2e:	61fb      	lod	AL, dp:0xfb <_l_au8FiFoErrorLog+0x1>
    4c30:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4c32:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4c34:	7258      	lod	A, [S-89]
    4c36:	7159      	lod	A, dp:0x59 <_LinFrameDataBuffer+0x7>
    4c38:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4c3a:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4c3c:	623a      	lod	AL, [S-59]
    4c3e:	484f      	macu	D, AL, [X]
    4c40:	380d      	subc	X, #13
    4c42:	3806      	subc	X, #6
    4c44:	e53e      	or	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4c46:	0108      	jmp	0x4e58 <__mlx4_flash_start+0xe58>
    4c48:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4c4a:	b34f      	adc	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4c4c:	b24e      	adc	A, [S-79]
    4c4e:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4c50:	4616      	mov	[S-23], YL
    4c52:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4c54:	724e      	lod	A, [S-79]
    4c56:	2622      	or	X, [S-35]
    4c58:	580e      	inc	S, #15
    4c5a:	0903      	clrb	io:0x00.3
    4c5c:	0809      	clrb	dp:0x01.1
    4c5e:	62e6      	lod	AL, Y
    4c60:	262c      	or	X, [S-45]
    4c62:	623a      	lod	AL, [S-59]
    4c64:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4c66:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4c68:	6394      	lod	AL, ep:0x94 <_s_CVRequestStruct+0x2>
    4c6a:	b583      	and	A, dp:0x83 <_targetPos+0x1>
    4c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    4c6e:	2495      	or	X, #-107
    4c70:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4c72:	b638      	and	A, [S-57]
    4c74:	348a      	and	X, #-118
    4c76:	4c58      	dadjs	D, A
    4c78:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4c7a:	e780      	or	Y, ep:0x80 <_CmdArr+0x6>
    4c7c:	0101      	jmp	0x4e80 <__mlx4_flash_start+0xe80>
    4c7e:	2647      	or	X, [S-72]
    4c80:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4c82:	b241      	adc	A, [S-66]
    4c84:	e358      	add	Y, ep:0x58 <_LinFrameDataBuffer+0x6>
    4c86:	ea59      	sub	Y, [S-90]
    4c88:	1002      	call	0x4c8e <__mlx4_flash_start+0xc8e>
    4c8a:	7c04      	lod	X, #4
    4c8c:	2494      	or	X, #-108
    4c8e:	b34e      	adc	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c90:	b24f      	adc	A, [S-80]
    4c92:	484f      	macu	D, AL, [X]
    4c94:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c96:	8a4f      	sub	AL, [S-80]
    4c98:	1001      	call	0x4c9c <__mlx4_flash_start+0xc9c>
    4c9a:	2635      	or	X, [S-54]
    4c9c:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c9e:	724f      	lod	A, [S-80]
    4ca0:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4ca2:	b259      	adc	A, [S-90]
    4ca4:	4610      	mov	[S-17], YL
    4ca6:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4ca8:	8358      	add	AL, ep:0x58 <_LinFrameDataBuffer+0x6>
    4caa:	8a59      	sub	AL, [S-90]
    4cac:	0004      	jmp	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cae:	e34e      	add	Y, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cb0:	ea4f      	sub	Y, [S-80]
    4cb2:	1001      	call	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cb4:	2635      	or	X, [S-54]
    4cb6:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4cb8:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    4cba:	b259      	adc	A, [S-90]
    4cbc:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4cbe:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4cc0:	7130      	lod	A, dp:0x30 <_g_DiagResponse>
    4cc2:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    4cc4:	7331      	lod	A, ep:0x31 <_g_DiagResponse+0x1>
    4cc6:	7232      	lod	A, [S-51]
    4cc8:	7133      	lod	A, dp:0x33 <_g_DiagResponse+0x3>
    4cca:	e355      	add	Y, ep:0x55 <_LinFrameDataBuffer+0x3>
    4ccc:	ea56      	sub	Y, [S-87]
    4cce:	e957      	sub	Y, dp:0x57 <_LinFrameDataBuffer+0x5>
    4cd0:	1002      	call	0x4cd6 <__mlx4_flash_start+0xcd6>
    4cd2:	b585      	and	A, dp:0x85 <_l_u16RecoryPos+0x1>
    4cd4:	2636      	or	X, [S-55]
    4cd6:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4cd8:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusMove>
    4cda:	1102      	call	0x4ee0 <__mlx4_flash_start+0xee0>
    4cdc:	a584      	or	A, dp:0x84 <_l_u16RecoryPos>
    4cde:	1101      	call	0x4ee2 <__mlx4_flash_start+0xee2>
    4ce0:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4ce2:	b359      	adc	A, ep:0x59 <_LinFrameDataBuffer+0x7>
    4ce4:	b158      	adc	A, dp:0x58 <_LinFrameDataBuffer+0x6>
    4ce6:	4592      	mov	dp:0x92 <_s_CVRequestStruct>, YL
    4ce8:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4cea:	b680      	and	A, io:0x0 <__dp__>
    4cec:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cee:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4cf0:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cf2:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cf4:	b359      	adc	A, ep:0x59 <_LinFrameDataBuffer+0x7>
    4cf6:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4cf8:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cfa:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cfc:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cfe:	724f      	lod	A, [S-80]
    4d00:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4d02:	b259      	adc	A, [S-90]
    4d04:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d08:	0102      	jmp	0x4f0e <__mlx4_flash_start+0xf0e>
    4d0a:	0005      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d0c:	269c      	or	X, io:0x1c <_g_sMotorFault>
    4d0e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d10:	ea05      	sub	Y, [S-6]
    4d12:	0001      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d14:	269c      	or	X, io:0x1c <_g_sMotorFault>
    4d16:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4d18:	8a4f      	sub	AL, [S-80]
    4d1a:	e788      	or	Y, ep:0x88 <_l_u8OBDValveStatusMove>
    4d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    4d1e:	0003      	jmp	0x4d26 <__mlx4_flash_start+0xd26>
    4d20:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    4d22:	4610      	mov	[S-17], YL
    4d24:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d28:	0102      	jmp	0x4f2e <__mlx4_flash_start+0xf2e>
    4d2a:	0004      	jmp	0x4d34 <__mlx4_flash_start+0xd34>
    4d2c:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4d2e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d30:	ea05      	sub	Y, [S-6]
    4d32:	100d      	call	0x4d4e <__mlx4_flash_start+0xd4e>
    4d34:	b582      	and	A, dp:0x82 <_targetPos>
    4d36:	2636      	or	X, [S-55]
    4d38:	c34e      	add	AH, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4d3a:	ca4f      	sub	AH, [S-80]
    4d3c:	e783      	or	Y, ep:0x83 <_targetPos+0x1>
    4d3e:	ee86      	cmp	Y, io:0x6 <_LinMess2>
    4d40:	1003      	call	0x4d48 <__mlx4_flash_start+0xd48>
    4d42:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4d44:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    4d46:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d4a:	0102      	jmp	0x4f50 <__mlx4_flash_start+0xf50>
    4d4c:	1004      	call	0x4d56 <__mlx4_flash_start+0xd56>
    4d4e:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4d50:	e304      	add	Y, ep:0x4 <_LinMess>
    4d52:	ea05      	sub	Y, [S-6]
    4d54:	0002      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4d56:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4d58:	2636      	or	X, [S-55]
    4d5a:	4d58      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, YH
    4d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    4d5e:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4d60:	7306      	lod	A, ep:0x6 <_LinMess2>
    4d62:	4c02 7ccb 	add	D, #2097315019
    4d66:	7d02 
    4d68:	b25e      	adc	A, [S-95]
    4d6a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4d6c:	725e      	lod	A, [S-95]
    4d6e:	344a      	and	X, #74
    4d70:	3906      	subc	X, dp:0x6 <_LinMess2>
    4d72:	b681      	and	A, io:0x1 <__dp__+0x1>
    4d74:	724e      	lod	A, [S-79]
    4d76:	7245      	lod	A, [S-70]
    4d78:	b239      	adc	A, [S-58]
    4d7a:	7271      	lod	A, [S-114]
    4d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    4d7e:	7239      	lod	A, [S-58]
    4d80:	5c00      	dec	S
    4d82:	4d1c      	mov	dp:0x1c <_g_sMotorFault>, YH
    4d84:	4962      	mov	dp:0x62 <_ml_driver_mode+0x4>, AH
    4d86:	4d2c      	mov	dp:0x2c <__data_dp_end+0x4>, YH
    4d88:	492e      	mov	dp:0x2e <__data_dp_end+0x6>, AH
    4d8a:	b680      	and	A, io:0x0 <__dp__>
    4d8c:	720d      	lod	A, [S-14]
    4d8e:	3807      	subc	X, #7
    4d90:	380e      	subc	X, #14
    4d92:	3430      	and	X, #48
    4d94:	580e      	inc	S, #15
    4d96:	0803      	clrb	dp:0x00.3
    4d98:	0907      	clrb	io:0x00.7
    4d9a:	62e6      	lod	AL, Y
    4d9c:	26ca      	or	X, [--PC]
    4d9e:	623a      	lod	AL, [S-59]
    4da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4da2:	0101      	jmp	0x4fa6 <__mlx4_flash_start+0xfa6>
    4da4:	26ca      	or	X, [--PC]
    4da6:	26f1      	or	X, [Y+1]
    4da8:	623a      	lod	AL, [S-59]
    4daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    4dac:	1101      	call	0x4fb0 <__mlx4_flash_start+0xfb0>
    4dae:	26f1      	or	X, [Y+1]
    4db0:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    4db2:	1105      	call	0x4fbe <__mlx4_flash_start+0xfbe>
    4db4:	626f      	lod	AL, [S-112]
    4db6:	0001      	jmp	0x4dba <__mlx4_flash_start+0xdba>
    4db8:	26ca      	or	X, [--PC]
    4dba:	b586      	and	A, dp:0x86 <_l_u8SavePosFlag>
    4dbc:	29d4      	sub	X, dp:0xd4 <_l_u8ErrorLogIdx>
    4dbe:	b239      	adc	A, [S-58]
    4dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4dc2:	110e      	call	0x4fe0 <__mlx4_flash_start+0xfe0>
    4dc4:	b680      	and	A, io:0x0 <__dp__>
    4dc6:	e24e      	add	Y, [S-79]
    4dc8:	1108      	call	0x4fda <__mlx4_flash_start+0xfda>
    4dca:	6259      	lod	AL, [S-90]
    4dcc:	6266      	lod	AL, [S-103]
    4dce:	0007      	jmp	0x4dde <__mlx4_flash_start+0xdde>
    4dd0:	b585      	and	A, dp:0x85 <_l_u16RecoryPos+0x1>
    4dd2:	b271      	adc	A, [S-114]
    4dd4:	7239      	lod	A, [S-58]
    4dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4dd8:	2495      	or	X, #-107
    4dda:	724e      	lod	A, [S-79]
    4ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    4dde:	26ca      	or	X, [--PC]
    4de0:	26ca      	or	X, [--PC]
    4de2:	b33a      	adc	A, ep:0x3a <_g_u16MicroStepIdx>
    4de4:	f782      	and	Y, ep:0x82 <_targetPos>
    4de6:	733a      	lod	A, ep:0x3a <_g_u16MicroStepIdx>
    4de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    4dea:	7c4c      	lod	X, #76
    4dec:	3805      	subc	X, #5
    4dee:	3808      	subc	X, #8
    4df0:	3906      	subc	X, dp:0x6 <_LinMess2>
    4df2:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4df4:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    4df6:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    4df8:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    4dfa:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4dfc:	b589      	and	A, dp:0x89 <_l_u8OBDValveStatusMove+0x1>
    4dfe:	580a      	inc	S, #11
    4e00:	0904      	clrb	io:0x00.4
    4e02:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4e04:	62e6      	lod	AL, Y
    4e06:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4e08:	26ff      	or	X, [X+7]
    4e0a:	623a      	lod	AL, [S-59]
    4e0c:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4e0e:	4008      	jmp	fp0:0x40
    4e10:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    4e12:	a58f      	or	A, dp:0x8f <_l_u8ValueFaultFlag>
    4e14:	0101      	jmp	0x5018 <__mlx4_flash_start+0x1018>
    4e16:	2726      	or	X, ep:0x26 <_l_u8StallCountA>
    4e18:	1409      	call	0x462c <__mlx4_flash_start+0x62c>
    4e1a:	3807      	subc	X, #7
    4e1c:	380e      	subc	X, #14
    4e1e:	3430      	and	X, #48
    4e20:	27bd      	or	X, ep:0xbd <_g_u16CurrentMotorCoilB+0x1>
    4e22:	b239      	adc	A, [S-58]
    4e24:	7238      	lod	A, [S-57]
    4e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    4e28:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e2a:	24a3      	or	X, #-93
    4e2c:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    4e2e:	b239      	adc	A, [S-58]
    4e30:	7238      	lod	A, [S-57]
    4e32:	4040      	jmp	fp2:0x00
    4e34:	624a      	lod	AL, [S-75]
    4e36:	1504      	call	0x4840 <__mlx4_flash_start+0x840>
    4e38:	b23b      	adc	A, [S-60]
    4e3a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4e3c:	723b      	lod	A, [S-60]
    4e3e:	24a3      	or	X, #-93
    4e40:	b23b      	adc	A, [S-60]
    4e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4e44:	723b      	lod	A, [S-60]
    4e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    4e48:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e4a:	24a3      	or	X, #-93
    4e4c:	4060      	jmp	fp3:0x00
    4e4e:	624a      	lod	AL, [S-75]
    4e50:	e589      	or	Y, dp:0x89 <_l_u8OBDValveStatusMove+0x1>
    4e52:	1109      	call	0x5066 <__mlx4_flash_start+0x1066>
    4e54:	b339      	adc	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4e56:	e78f      	or	Y, ep:0x8f <_l_u8ValueFaultFlag>
    4e58:	010a      	jmp	0x506e <__mlx4_flash_start+0x106e>
    4e5a:	1409      	call	0x466e <__mlx4_flash_start+0x66e>
    4e5c:	b686      	and	A, io:0x6 <_LinMess2>
    4e5e:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    4e60:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4e62:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e64:	24a3      	or	X, #-93
    4e66:	4060      	jmp	fp3:0x00
    4e68:	622e      	lod	AL, [S-47]
    4e6a:	0501      	jmp	0x486e <__mlx4_flash_start+0x86e>
    4e6c:	2739      	or	X, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4e6e:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4e70:	26ff      	or	X, [X+7]
    4e72:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4e74:	1001      	call	0x4e78 <__mlx4_flash_start+0xe78>
    4e76:	274c      	or	X, ep:0x4c <_l_u16ActuatorBufferedTgtPos>
    4e78:	b791      	and	A, ep:0x91 <_l_u8AliveRollingCounter+0x1>
    4e7a:	d78f      	and	AH, ep:0x8f <_l_u8ValueFaultFlag>
    4e7c:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4e7e:	bf87      	xor	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    4e80:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    4e82:	4060      	jmp	fp3:0x00
    4e84:	4d62      	mov	dp:0x62 <_ml_driver_mode+0x4>, YH
    4e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    4e88:	b63d      	and	A, [S-62]
    4e8a:	721e      	lod	A, [S-31]
    4e8c:	4962      	mov	dp:0x62 <_ml_driver_mode+0x4>, AH
    4e8e:	4d2e      	mov	dp:0x2e <__data_dp_end+0x6>, YH
    4e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    4e92:	b63d      	and	A, [S-62]
    4e94:	721f      	lod	A, [S-32]
    4e96:	492e      	mov	dp:0x2e <__data_dp_end+0x6>, AH
    4e98:	7492      	lod	PC, #-110
    4e9a:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4e9c:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    4e9e:	1101      	call	0x50a2 <__mlx4_flash_start+0x10a2>
    4ea0:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4ea2:	d245      	adc	AH, [S-70]
    4ea4:	7245      	lod	A, [S-70]
    4ea6:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    4ea8:	6c01      	lod	YH, #1
    4eaa:	2768      	or	X, ep:0x68 <_ml_driver_mode+0xa>
    4eac:	277b      	or	X, ep:0x7b <_CmdArr+0x1>
    4eae:	278a      	or	X, ep:0x8a <_l_u16OBDValveStatusPosition>
    4eb0:	26ff      	or	X, [X+7]
    4eb2:	26ff      	or	X, [X+7]
    4eb4:	26ff      	or	X, [X+7]
    4eb6:	26ff      	or	X, [X+7]
    4eb8:	275e      	or	X, ep:0x5e <_ml_driver_mode>
    4eba:	26ff      	or	X, [X+7]
    4ebc:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ebe:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    4ec0:	0106      	jmp	0x50ce <__mlx4_flash_start+0x10ce>
    4ec2:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    4ec4:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ec6:	b271      	adc	A, [S-114]
    4ec8:	7238      	lod	A, [S-57]
    4eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    4ecc:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4ece:	26ff      	or	X, [X+7]
    4ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    4ed4:	bf82      	xor	A, ep:0x82 <_targetPos>
    4ed6:	d345      	adc	AH, ep:0x45 <_g_e8MotorDirectionCCW+0x1>
    4ed8:	b209      	adc	A, [S-10]
    4eda:	720f      	lod	A, [S-16]
    4edc:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4ede:	d792      	and	AH, ep:0x92 <_s_CVRequestStruct>
    4ee0:	1101      	call	0x50e4 <__mlx4_flash_start+0x10e4>
    4ee2:	26ff      	or	X, [X+7]
    4ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    4ee6:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4ee8:	b638      	and	A, [S-57]
    4eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    4eec:	1103      	call	0x50f4 <__mlx4_flash_start+0x10f4>
    4eee:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ef0:	f784      	and	Y, ep:0x84 <_l_u16RecoryPos>
    4ef2:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ef4:	24a3      	or	X, #-93
    4ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    4ef8:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4efa:	0102      	jmp	0x5100 <__mlx4_flash_start+0x1100>
    4efc:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4efe:	26ff      	or	X, [X+7]
    4f00:	b360      	adc	A, ep:0x60 <_ml_driver_mode+0x2>
    4f02:	b161      	adc	A, dp:0x61 <_ml_driver_mode+0x3>
    4f04:	f580      	and	Y, dp:0x80 <_CmdArr+0x6>
    4f06:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f08:	7260      	lod	A, [S-97]
    4f0a:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    4f0c:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f0e:	7261      	lod	A, [S-98]
    4f10:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    4f12:	26ff      	or	X, [X+7]
    4f14:	b209      	adc	A, [S-10]
    4f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4f18:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4f1a:	1102      	call	0x5120 <__mlx4_flash_start+0x1120>
    4f1c:	f781      	and	Y, ep:0x81 <_CmdArr+0x7>
    4f1e:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4f22:	4610      	mov	[S-17], YL
    4f24:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4f26:	4610      	mov	[S-17], YL
    4f28:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4f2a:	720d      	lod	A, [S-14]
    4f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    4f30:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4f32:	0104      	jmp	0x513c <__mlx4_flash_start+0x113c>
    4f34:	b31f      	adc	A, ep:0x1f <__ramfunc_size+0x1>
    4f36:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4f38:	1105      	call	0x5144 <__mlx4_flash_start+0x1144>
    4f3a:	8788      	or	AL, ep:0x88 <_l_u8OBDValveStatusMove>
    4f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f3e:	b680      	and	A, io:0x0 <__dp__>
    4f40:	720d      	lod	A, [S-14]
    4f42:	27b5      	or	X, ep:0xb5 <_g_i16Current+0x1>
    4f44:	3bea      	subc	X, ep:0xea <_l_u16PhysicalTargetPos>
    4f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    4f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f4a:	4050      	jmp	fp2:0x80
    4f4c:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    4f4e:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    4f50:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusMove>
    4f52:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    4f56:	0105      	jmp	0x5162 <__mlx4_flash_start+0x1162>
    4f58:	b20d      	adc	A, [S-14]
    4f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4f5c:	720d      	lod	A, [S-14]
    4f5e:	b582      	and	A, dp:0x82 <_targetPos>
    4f60:	26ff      	or	X, [X+7]
    4f62:	720d      	lod	A, [S-14]
    4f64:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    4f66:	b7a7      	and	A, ep:0xa7 <_l_u8BackgroundSchedulerTaskID>
    4f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f6c:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    4f6e:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    4f70:	3beb      	subc	X, ep:0xeb <_l_u16PhysicalTargetPos+0x1>
    4f72:	7360      	lod	A, ep:0x60 <_ml_driver_mode+0x2>
    4f74:	7161      	lod	A, dp:0x61 <_ml_driver_mode+0x3>
    4f76:	b582      	and	A, dp:0x82 <_targetPos>
    4f78:	26ff      	or	X, [X+7]
    4f7a:	1501      	call	0x497e <__mlx4_flash_start+0x97e>
    4f7c:	2800      	sub	X, #0
    4f7e:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4f80:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    4f82:	1109      	call	0x5196 <__mlx4_flash_start+0x1196>
    4f84:	f784      	and	Y, ep:0x84 <_l_u16RecoryPos>
    4f86:	735c      	lod	A, ep:0x5c <_LinMessage>
    4f88:	4804      	mulu	D, A, [Y++]
    4f8a:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    4f8e:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4f90:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    4f92:	0101      	jmp	0x5196 <__mlx4_flash_start+0x1196>
    4f94:	24a3      	or	X, #-93
    4f96:	5cc2      	neg	A
    4f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f9a:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusMove>
    4f9c:	0103      	jmp	0x51a4 <__mlx4_flash_start+0x11a4>
    4f9e:	7ca8      	lod	X, #-88
    4fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    4fa2:	24a3      	or	X, #-93
    4fa4:	b261      	adc	A, [S-98]
    4fa6:	4600      	mov	[S-1], YL
    4fa8:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4faa:	0104      	jmp	0x51b4 <__mlx4_flash_start+0x11b4>
    4fac:	0001      	jmp	0x4fb0 <__mlx4_flash_start+0xfb0>
    4fae:	24a3      	or	X, #-93
    4fb0:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    4fb2:	27e7      	or	X, ep:0xe7 <_LINBaud+0x1>
    4fb4:	5c00      	dec	S
    4fb6:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    4fb8:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    4fba:	1103      	call	0x51c2 <__mlx4_flash_start+0x11c2>
    4fbc:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4fbe:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4fc0:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4fc2:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4fc4:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    4fc6:	1102      	call	0x51cc <__mlx4_flash_start+0x11cc>
    4fc8:	b784      	and	A, ep:0x84 <_l_u16RecoryPos>
    4fca:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    4fcc:	b781      	and	A, ep:0x81 <_CmdArr+0x7>
    4fce:	b260      	adc	A, [S-97]
    4fd0:	725b      	lod	A, [S-92]
    4fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4fd4:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fd6:	724c      	lod	A, [S-77]
    4fd8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fda:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4fdc:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fde:	b556      	and	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4fe0:	7137      	lod	A, dp:0x37 <_g_DiagResponse+0x7>
    4fe2:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fe4:	b556      	and	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4fe6:	7136      	lod	A, dp:0x36 <_g_DiagResponse+0x6>
    4fe8:	b25b      	adc	A, [S-92]
    4fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    4fec:	4788      	mov	ep:0x88 <_l_u8OBDValveStatusMove>, YL
    4fee:	f693      	and	Y, io:0x13 <__data_dp_size+0x3>
    4ff0:	725b      	lod	A, [S-92]
    4ff2:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4ff4:	0002      	jmp	0x4ffa <__mlx4_flash_start+0xffa>
    4ff6:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4ff8:	27fe      	or	X, ep:0xfe <_l_au8FiFoErrorLog+0x4>
    4ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    4ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4ffe:	281f      	sub	X, #31
    5000:	b239      	adc	A, [S-58]
    5002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    5004:	0101      	jmp	0x5208 <__mlx4_flash_start+0x1208>
    5006:	2814      	sub	X, #20
    5008:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    500a:	a782      	or	A, ep:0x82 <_targetPos>
    500c:	0103      	jmp	0x5214 <__mlx4_flash_start+0x1214>
    500e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    5010:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    5012:	24a3      	or	X, #-93
    5014:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    5016:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    5018:	0107      	jmp	0x5228 <__mlx4_flash_start+0x1228>
    501a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    501c:	e580      	or	Y, dp:0x80 <_CmdArr+0x6>
    501e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    5020:	ed80      	cmp	Y, dp:0x80 <_CmdArr+0x6>
    5022:	1102      	call	0x5228 <__mlx4_flash_start+0x1228>
    5024:	f782      	and	Y, ep:0x82 <_targetPos>
    5026:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5028:	e24c      	add	Y, [S-77]
    502a:	0109      	jmp	0x523e <__mlx4_flash_start+0x123e>
    502c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    502e:	bf87      	xor	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    5030:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5032:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    5034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    5036:	77e6      	lod	PC, ep:0xe6 <_LINBaud>
    5038:	8681      	or	AL, io:0x1 <__dp__+0x1>
    503a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    503c:	77e6      	lod	PC, ep:0xe6 <_LINBaud>
    503e:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5040:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    5042:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5044:	1106      	call	0x5252 <__mlx4_flash_start+0x1252>
    5046:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    5048:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    504a:	b35b      	adc	A, ep:0x5b <_LIN_nad+0x1>
    504c:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    504e:	1107      	call	0x525e <__mlx4_flash_start+0x125e>
    5050:	2849      	sub	X, #73
    5052:	b208      	adc	A, [S-9]
    5054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    5056:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    5058:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    505a:	0105      	jmp	0x5266 <__mlx4_flash_start+0x1266>
    505c:	6233      	lod	AL, [S-52]
    505e:	7cce      	lod	X, #-50
    5060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    5062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5064:	26ca      	or	X, [--PC]
    5066:	820a      	add	AL, [S-11]
    5068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    506a:	8681      	or	AL, io:0x1 <__dp__+0x1>
    506c:	8f80      	cmp	AL, ep:0x80 <_CmdArr+0x6>
    506e:	0103      	jmp	0x5276 <__mlx4_flash_start+0x1276>
    5070:	b684      	and	A, io:0x4 <_LinMess>
    5072:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    5074:	24a3      	or	X, #-93
    5076:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    5078:	a782      	or	A, ep:0x82 <_targetPos>
    507a:	0105      	jmp	0x5286 <__mlx4_flash_start+0x1286>
    507c:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    507e:	bf8d      	xor	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    5080:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    5082:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    5084:	29d4      	sub	X, dp:0xd4 <_l_u8ErrorLogIdx>
    5086:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    5088:	f782      	and	Y, ep:0x82 <_targetPos>
    508a:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    508c:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    508e:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    5090:	24a3      	or	X, #-93
    5092:	b58f      	and	A, dp:0x8f <_l_u8ValueFaultFlag>
    5094:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5096:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    5098:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    509a:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    509c:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    509e:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    50a0:	b738      	and	A, ep:0x38 <_g_u16CorrectionRatio>
    50a2:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    50a4:	110b      	call	0x52bc <__mlx4_flash_start+0x12bc>
    50a6:	b239      	adc	A, [S-58]
    50a8:	7238      	lod	A, [S-57]
    50aa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    50ac:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    50ae:	b23b      	adc	A, [S-60]
    50b0:	f684      	and	Y, io:0x4 <_LinMess>
    50b2:	723b      	lod	A, [S-60]
    50b4:	b25e      	adc	A, [S-95]
    50b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    50b8:	725e      	lod	A, [S-95]
    50ba:	24a1      	or	X, #-95
    50bc:	3805      	subc	X, #5
    50be:	3808      	subc	X, #8
    50c0:	346b      	and	X, #107
    50c2:	34b0      	and	X, #-80
    50c4:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    50c6:	b34c      	adc	A, ep:0x4c <_l_u16ActuatorBufferedTgtPos>
    50c8:	c781      	or	AH, ep:0x81 <_CmdArr+0x7>
    50ca:	4796      	mov	ep:0x96 <_s_CVRequestStruct+0x4>, YL
    50cc:	b65b      	and	A, [S-92]
    50ce:	7236      	lod	A, [S-55]
    50d0:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    50d2:	b65b      	and	A, [S-92]
    50d4:	7237      	lod	A, [S-56]
    50d6:	b364      	adc	A, ep:0x64 <_ml_driver_mode+0x6>
    50d8:	bf84      	xor	A, ep:0x84 <_l_u16RecoryPos>
    50da:	0101      	jmp	0x52de <__mlx4_flash_start+0x12de>
    50dc:	b581      	and	A, dp:0x81 <_CmdArr+0x7>
    50de:	858a      	or	AL, dp:0x8a <_l_u16OBDValveStatusPosition>
    50e0:	715d      	lod	A, dp:0x5d <_LinMessage+0x1>
    50e2:	b164      	adc	A, dp:0x64 <_ml_driver_mode+0x6>
    50e4:	bd83      	xor	A, dp:0x83 <_targetPos+0x1>
    50e6:	8582      	or	AL, dp:0x82 <_targetPos>
    50e8:	714d      	lod	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    50ea:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    50ec:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    50ee:	5c00      	dec	S
    50f0:	0101      	jmp	0x52f4 <__mlx4_flash_start+0x12f4>
    50f2:	5c02      	dec	S, #3
    50f4:	580e      	inc	S, #15
    50f6:	0809      	clrb	dp:0x01.1
    50f8:	090c      	clrb	io:0x01.4
    50fa:	62e6      	lod	AL, Y
    50fc:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    50fe:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusMove>
    5100:	1103      	call	0x5308 <__mlx4_flash_start+0x1308>
    5102:	a584      	or	A, dp:0x84 <_l_u16RecoryPos>
    5104:	0105      	jmp	0x5310 <__mlx4_flash_start+0x1310>
    5106:	24a3      	or	X, #-93
    5108:	2892      	sub	X, #-110
    510a:	623a      	lod	AL, [S-59]
    510c:	a688      	or	A, io:0x8 <__bist_stat_size>
    510e:	0106      	jmp	0x531c <__mlx4_flash_start+0x131c>
    5110:	287a      	sub	X, #122
    5112:	623a      	lod	AL, [S-59]
    5114:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusMove>
    5116:	1102      	call	0x531c <__mlx4_flash_start+0x131c>
    5118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    511a:	1101      	call	0x531e <__mlx4_flash_start+0x131e>
    511c:	2853      	sub	X, #83
    511e:	a781      	or	A, ep:0x81 <_CmdArr+0x7>
    5120:	1107      	call	0x5330 <__mlx4_flash_start+0x1330>
    5122:	287a      	sub	X, #122
    5124:	b14d      	adc	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5126:	e580      	or	Y, dp:0x80 <_CmdArr+0x6>
    5128:	1101      	call	0x532c <__mlx4_flash_start+0x132c>
    512a:	28a6      	sub	X, #-90
    512c:	5cc2      	neg	A
    512e:	287a      	sub	X, #122
    5130:	6241      	lod	AL, [S-66]
    5132:	0001      	jmp	0x5136 <__mlx4_flash_start+0x1136>
    5134:	2711      	or	X, ep:0x11 <__data_dp_size+0x1>
    5136:	b14d      	adc	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5138:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    513a:	1101      	call	0x533e <__mlx4_flash_start+0x133e>
    513c:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    513e:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    5140:	8d80      	cmp	AL, dp:0x80 <_CmdArr+0x6>
    5142:	714d      	lod	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5144:	e580      	or	Y, dp:0x80 <_CmdArr+0x6>
    5146:	1101      	call	0x534a <__mlx4_flash_start+0x134a>
    5148:	0501      	jmp	0x4b4c <__mlx4_flash_start+0xb4c>
    514a:	287a      	sub	X, #122
    514c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    514e:	bf87      	xor	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    5150:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5152:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    5154:	3468      	and	X, #104
    5156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5158:	b203      	adc	A, [S-4]
    515a:	4610      	mov	[S-17], YL
    515c:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    515e:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    5160:	724f      	lod	A, [S-80]
    5162:	4c4f      	dadju	D, [X]
    5164:	6217      	lod	AL, [S-24]
    5166:	6233      	lod	AL, [S-52]
    5168:	b582      	and	A, dp:0x82 <_targetPos>
    516a:	7170      	lod	A, dp:0x70 <_ml_driver_mode+0x12>
    516c:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    516e:	484f      	macu	D, AL, [X]
    5170:	380a      	subc	X, #10
    5172:	3420      	and	X, #32
    5174:	3965      	subc	X, dp:0x65 <_ml_driver_mode+0x7>
    5176:	3501      	and	X, dp:0x1 <__dp__+0x1>
    5178:	37a4      	and	X, ep:0xa4 <_l_u8OBDValveMechanicalError>
    517a:	346b      	and	X, #107
    517c:	5806      	inc	S, #7
    517e:	090e      	clrb	io:0x01.6
    5180:	623a      	lod	AL, [S-59]
    5182:	484f      	macu	D, AL, [X]
    5184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5186:	b203      	adc	A, [S-4]
    5188:	4610      	mov	[S-17], YL
    518a:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    518c:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    518e:	8a4f      	sub	AL, [S-80]
    5190:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    5192:	724f      	lod	A, [S-80]
    5194:	4c4f      	dadju	D, [X]
    5196:	3409      	and	X, #9
    5198:	3808      	subc	X, #8
    519a:	28eb      	sub	X, #-21
    519c:	623a      	lod	AL, [S-59]
    519e:	a688      	or	A, io:0x8 <__bist_stat_size>
    51a0:	1101      	call	0x53a4 <__mlx4_flash_start+0x13a4>
    51a2:	28fb      	sub	X, #-5
    51a4:	351b      	and	X, dp:0x1b <_g_u8NAD>
    51a6:	b582      	and	A, dp:0x82 <_targetPos>
    51a8:	b682      	and	A, io:0x2 <_LinCmnd>
    51aa:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    51ac:	b681      	and	A, io:0x1 <__dp__+0x1>
    51ae:	7201      	lod	A, [S-2]
    51b0:	2487      	or	X, #-121
    51b2:	6217      	lod	AL, [S-24]
    51b4:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    51b6:	0007      	jmp	0x51c6 <__mlx4_flash_start+0x11c6>
    51b8:	1107      	call	0x53c8 <__mlx4_flash_start+0x13c8>
    51ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    51bc:	d78f      	and	AH, ep:0x8f <_l_u8ValueFaultFlag>
    51be:	7234      	lod	A, [S-53]
    51c0:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    51c2:	6228      	lod	AL, [S-41]
    51c4:	28e5      	sub	X, #-27
    51c6:	2906      	sub	X, dp:0x6 <_LinMess2>
    51c8:	6233      	lod	AL, [S-52]
    51ca:	4040      	jmp	fp2:0x00
    51cc:	3501      	and	X, dp:0x1 <__dp__+0x1>
    51ce:	580a      	inc	S, #11
    51d0:	0902      	clrb	io:0x00.2
    51d2:	62e6      	lod	AL, Y
    51d4:	28e7      	sub	X, #-25
    51d6:	623a      	lod	AL, [S-59]
    51d8:	a684      	or	A, io:0x4 <_LinMess>
    51da:	110d      	call	0x53f6 <__mlx4_flash_start+0x13f6>
    51dc:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    51de:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    51e0:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    51e2:	624a      	lod	AL, [S-75]
    51e4:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    51e6:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    51e8:	e15d      	add	Y, dp:0x5d <_LinMessage+0x1>
    51ea:	0109      	jmp	0x53fe <__mlx4_flash_start+0x13fe>
    51ec:	622e      	lod	AL, [S-47]
    51ee:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    51f0:	4784      	mov	ep:0x84 <_l_u16RecoryPos>, YL
    51f2:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    51f4:	28e6      	sub	X, #-26
    51f6:	4040      	jmp	fp2:0x00
    51f8:	624a      	lod	AL, [S-75]
    51fa:	351b      	and	X, dp:0x1b <_g_u8NAD>
    51fc:	2853      	sub	X, #83
    51fe:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    5200:	4040      	jmp	fp2:0x00
    5202:	4784      	mov	ep:0x84 <_l_u16RecoryPos>, YL
    5204:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    5206:	7ccf      	lod	X, #-49
    5208:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    520a:	28d9      	sub	X, #-39
    520c:	351b      	and	X, dp:0x1b <_g_u8NAD>
    520e:	580a      	inc	S, #11
    5210:	0902      	clrb	io:0x00.2
    5212:	62e6      	lod	AL, Y
    5214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    5216:	623a      	lod	AL, [S-59]
    5218:	a684      	or	A, io:0x4 <_LinMess>
    521a:	0101      	jmp	0x541e <__mlx4_flash_start+0x141e>
    521c:	28fb      	sub	X, #-5
    521e:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    5220:	a583      	or	A, dp:0x83 <_targetPos+0x1>
    5222:	1103      	call	0x542a <__mlx4_flash_start+0x142a>
    5224:	b100      	adc	A, dp:0x0 <__dp__>
    5226:	a581      	or	A, dp:0x81 <_CmdArr+0x7>
    5228:	0102      	jmp	0x542e <__mlx4_flash_start+0x142e>
    522a:	b785      	and	A, ep:0x85 <_l_u16RecoryPos+0x1>
    522c:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    522e:	24a3      	or	X, #-93
    5230:	3807      	subc	X, #7
    5232:	3809      	subc	X, #9
    5234:	3468      	and	X, #104
    5236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5238:	b638      	and	A, [S-57]
    523a:	a688      	or	A, io:0x8 <__bist_stat_size>
    523c:	0101      	jmp	0x5440 <__mlx4_flash_start+0x1440>
    523e:	2494      	or	X, #-108
    5240:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    5244:	7201      	lod	A, [S-2]
    5246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    5248:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    524a:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    524c:	580e      	inc	S, #15
    524e:	0803      	clrb	dp:0x00.3
    5250:	0906      	clrb	io:0x00.6
    5252:	62e6      	lod	AL, Y
    5254:	2926      	sub	X, dp:0x26 <_l_u8StallCountA>
    5256:	623a      	lod	AL, [S-59]
    5258:	a688      	or	A, io:0x8 <__bist_stat_size>
    525a:	010a      	jmp	0x5470 <__mlx4_flash_start+0x1470>
    525c:	248c      	or	X, #-116
    525e:	626f      	lod	AL, [S-112]
    5260:	1007      	call	0x5270 <__mlx4_flash_start+0x1270>
    5262:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    5264:	b684      	and	A, io:0x4 <_LinMess>
    5266:	62ca      	lod	AL, [--PC]
    5268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    526a:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    526c:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    526e:	2a05      	sub	X, [S-6]
    5270:	2926      	sub	X, dp:0x26 <_l_u8StallCountA>
    5272:	5c00      	dec	S
    5274:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    5276:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    5278:	4954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AH
    527a:	4956      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AH
    527c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    527e:	a78d      	or	A, ep:0x8d <_l_u8OBDValveStatusVolt>
    5280:	1103      	call	0x5488 <__mlx4_flash_start+0x1488>
    5282:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    5284:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    5286:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    5288:	b78e      	and	A, ep:0x8e <_l_u8OBDValveStatusFault>
    528a:	b763      	and	A, ep:0x63 <_ml_driver_mode+0x5>
    528c:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    528e:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    5290:	735a      	lod	A, ep:0x5a <_LIN_nad>
    5292:	736a      	lod	A, ep:0x6a <_ml_driver_mode+0xc>
    5294:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    5296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    5298:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    529a:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    529c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    529e:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    52a0:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    52a2:	4c4e      	dadju	D, [X++]
    52a4:	34ef      	and	X, #-17
    52a6:	3985      	subc	X, dp:0x85 <_l_u16RecoryPos+0x1>
    52a8:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    52aa:	4c4f      	dadju	D, [X]
    52ac:	484f      	macu	D, AL, [X]
    52ae:	3806      	subc	X, #6
    52b0:	380a      	subc	X, #10
    52b2:	3428      	and	X, #40
    52b4:	3beb      	subc	X, ep:0xeb <_l_u16PhysicalTargetPos+0x1>
    52b6:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    52b8:	736d      	lod	A, ep:0x6d <_ml_driver_mode+0xf>
    52ba:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusMove>
    52bc:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    52be:	726e      	lod	A, [S-111]
    52c0:	b23b      	adc	A, [S-60]
    52c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    52c4:	1103      	call	0x54cc <__mlx4_flash_start+0x14cc>
    52c6:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    52c8:	b78c      	and	A, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    52ca:	735b      	lod	A, ep:0x5b <_LIN_nad+0x1>
    52cc:	2282      	add	X, io:0x2 <_LinCmnd>
    52ce:	622b      	lod	AL, [S-44]
    52d0:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    52d2:	3f88      	xor	X, ep:0x88 <_l_u8OBDValveStatusMove>
    52d4:	b680      	and	A, io:0x0 <__dp__>
    52d6:	7271      	lod	A, [S-114]
    52d8:	7c54      	lod	X, #84
    52da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    52dc:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    52de:	4c04      	add	D, [Y++]
    52e0:	3805      	subc	X, #5
    52e2:	3808      	subc	X, #8
    52e4:	3449      	and	X, #73
    52e6:	3906      	subc	X, dp:0x6 <_LinMess2>
    52e8:	3512      	and	X, dp:0x12 <__data_dp_size+0x2>
    52ea:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    52ec:	623a      	lod	AL, [S-59]
    52ee:	b58c      	and	A, dp:0x8c <_l_u8OBDValveStatusOverTempWarn>
    52f0:	b55d      	and	A, dp:0x5d <_LinMessage+0x1>
    52f2:	580a      	inc	S, #11
    52f4:	0902      	clrb	io:0x00.2
    52f6:	62e6      	lod	AL, Y
    52f8:	2979      	sub	X, dp:0x79 <__data_size+0x3>
    52fa:	623a      	lod	AL, [S-59]
    52fc:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    52fe:	0102      	jmp	0x5504 <__mlx4_flash_end+0x14>
    5300:	3502      	and	X, dp:0x2 <_LinCmnd>
    5302:	2979      	sub	X, dp:0x79 <__data_size+0x3>
    5304:	351b      	and	X, dp:0x1b <_g_u8NAD>
    5306:	b271      	adc	A, [S-114]
    5308:	8681      	or	AL, io:0x1 <__dp__+0x1>
    530a:	7271      	lod	A, [S-114]
    530c:	a681      	or	A, io:0x1 <__dp__+0x1>
    530e:	1105      	call	0x551a <__mlx4_flash_end+0x2a>
    5310:	e686      	or	Y, io:0x6 <_LinMess2>
    5312:	0101      	jmp	0x5516 <__mlx4_flash_end+0x26>
    5314:	296c      	sub	X, dp:0x6c <_ml_driver_mode+0xe>
    5316:	b584      	and	A, dp:0x84 <_l_u16RecoryPos>
    5318:	29d4      	sub	X, dp:0xd4 <_l_u8ErrorLogIdx>
    531a:	3809      	subc	X, #9
    531c:	5806      	inc	S, #7
    531e:	0902      	clrb	io:0x00.2
    5320:	623a      	lod	AL, [S-59]
    5322:	29b2      	sub	X, dp:0xb2 <_l_u8LinInFrameBufState>
    5324:	623a      	lod	AL, [S-59]
    5326:	a688      	or	A, io:0x8 <__bist_stat_size>
    5328:	0101      	jmp	0x552c <__mlx4_flash_end+0x3c>
    532a:	29b2      	sub	X, dp:0xb2 <_l_u8LinInFrameBufState>
    532c:	b580      	and	A, dp:0x80 <_CmdArr+0x6>
    532e:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    5330:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    5332:	b304      	adc	A, ep:0x4 <_LinMess>
    5334:	b205      	adc	A, [S-6]
    5336:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    5338:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    533a:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    533c:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    533e:	7241      	lod	A, [S-66]
    5340:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    5342:	4792      	mov	ep:0x92 <_s_CVRequestStruct>, YL
    5344:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    5346:	4596      	mov	dp:0x96 <_s_CVRequestStruct+0x4>, YL
    5348:	8340      	add	AL, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    534a:	8a41      	sub	AL, [S-66]
    534c:	8942      	sub	AL, dp:0x42 <_g_u16MotorCurrentLPFx64>
    534e:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    5350:	7241      	lod	A, [S-66]
    5352:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    5354:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    5356:	b788      	and	A, ep:0x88 <_l_u8OBDValveStatusMove>
    5358:	b682      	and	A, io:0x2 <_LinCmnd>
    535a:	62ca      	lod	AL, [--PC]
    535c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    535e:	f784      	and	Y, ep:0x84 <_l_u16RecoryPos>
    5360:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    5362:	24a3      	or	X, #-93
    5364:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    5366:	b271      	adc	A, [S-114]
    5368:	e685      	or	Y, io:0x5 <_LinMess+0x1>
    536a:	0103      	jmp	0x5572 <_INDXtbl+0x32>
    536c:	b784      	and	A, ep:0x84 <_l_u16RecoryPos>
    536e:	b585      	and	A, dp:0x85 <_l_u16RecoryPos+0x1>
    5370:	29bb      	sub	X, dp:0xbb <_g_i16SupplyVoltage+0x1>
    5372:	b786      	and	A, ep:0x86 <_l_u8SavePosFlag>
    5374:	b587      	and	A, dp:0x87 <_l_u8OBDValveStatusSpeedLevel>
    5376:	b763      	and	A, ep:0x63 <_ml_driver_mode+0x5>
    5378:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    537a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    537c:	77bc      	lod	PC, ep:0xbc <_g_u16CurrentMotorCoilB>
    537e:	b682      	and	A, io:0x2 <_LinCmnd>
    5380:	75bc      	lod	PC, dp:0xbc <_g_u16CurrentMotorCoilB>
    5382:	3b33      	subc	X, ep:0x33 <_g_DiagResponse+0x3>
    5384:	580f      	inc	S, #16
    5386:	080b      	clrb	dp:0x01.3
    5388:	0902      	clrb	io:0x00.2
    538a:	62e6      	lod	AL, Y
    538c:	29c2      	sub	X, dp:0xc2 <_l_u16CurrentZeroOffset>
    538e:	623a      	lod	AL, [S-59]
    5390:	a688      	or	A, io:0x8 <__bist_stat_size>
    5392:	0105      	jmp	0x559e <_INDXtbl+0x5e>
    5394:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    5396:	bf8f      	xor	A, ep:0x8f <_l_u8ValueFaultFlag>
    5398:	0101      	jmp	0x559c <_INDXtbl+0x5c>
    539a:	2982      	sub	X, dp:0x82 <_targetPos>
    539c:	29c2      	sub	X, dp:0xc2 <_l_u16CurrentZeroOffset>
    539e:	623a      	lod	AL, [S-59]
    53a0:	b785      	and	A, ep:0x85 <_l_u16RecoryPos+0x1>
    53a2:	b682      	and	A, io:0x2 <_LinCmnd>
    53a4:	62ca      	lod	AL, [--PC]
    53a6:	24a3      	or	X, #-93
    53a8:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    53aa:	b738      	and	A, ep:0x38 <_g_u16CorrectionRatio>
    53ac:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    53ae:	b787      	and	A, ep:0x87 <_l_u8OBDValveStatusSpeedLevel>
    53b0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53b2:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    53b4:	b786      	and	A, ep:0x86 <_l_u8SavePosFlag>
    53b6:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53b8:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    53ba:	4c4e      	dadju	D, [X++]
    53bc:	4c4f      	dadju	D, [X]
    53be:	b784      	and	A, ep:0x84 <_l_u16RecoryPos>
    53c0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53c2:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    53c4:	3469      	and	X, #105
    53c6:	3807      	subc	X, #7
    53c8:	380a      	subc	X, #10
    53ca:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    53cc:	b585      	and	A, dp:0x85 <_l_u16RecoryPos+0x1>
    53ce:	b55d      	and	A, dp:0x5d <_LinMessage+0x1>
    53d0:	8581      	or	AL, dp:0x81 <_CmdArr+0x7>
    53d2:	580e      	inc	S, #15
    53d4:	0803      	clrb	dp:0x00.3
    53d6:	0906      	clrb	io:0x00.6
    53d8:	62e6      	lod	AL, Y
    53da:	29e9      	sub	X, dp:0xe9 <__data_end+0x1>
    53dc:	623a      	lod	AL, [S-59]
    53de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    53e0:	110c      	call	0x55fa <_start+0x12>
    53e2:	2a3c      	sub	X, [S-61]
    53e4:	627c      	lod	AL, [S-125]
    53e6:	0101      	jmp	0x55ea <_start+0x2>
    53e8:	29e9      	sub	X, dp:0xe9 <__data_end+0x1>
    53ea:	623a      	lod	AL, [S-59]
    53ec:	c581      	or	AH, dp:0x81 <_CmdArr+0x7>
    53ee:	0107      	jmp	0x55fe <_start+0x16>
    53f0:	bf84      	xor	A, ep:0x84 <_l_u16RecoryPos>
    53f2:	1104      	call	0x55fc <_start+0x14>
    53f4:	a681      	or	A, io:0x1 <__dp__+0x1>
    53f6:	1102      	call	0x55fc <_start+0x14>
    53f8:	29ef      	sub	X, dp:0xef <_l_u8LastMsgIndex>
    53fa:	29e9      	sub	X, dp:0xe9 <__data_end+0x1>
    53fc:	29ef      	sub	X, dp:0xef <_l_u8LastMsgIndex>
    53fe:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5400:	e584      	or	Y, dp:0x84 <_l_u16RecoryPos>
    5402:	0103      	jmp	0x560a <__ram_section_init>
    5404:	b372      	adc	A, ep:0x72 <__bss_dp_end>
    5406:	b684      	and	A, io:0x4 <_LinMess>
    5408:	62ca      	lod	AL, [--PC]
    540a:	b365      	adc	A, ep:0x65 <_ml_driver_mode+0x7>
    540c:	a784      	or	A, ep:0x84 <_l_u16RecoryPos>
    540e:	1101      	call	0x5612 <__ram_section_init+0x8>
    5410:	2a1b      	sub	X, [S-28]
    5412:	3448      	and	X, #72
    5414:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    5416:	3804      	subc	X, #4
    5418:	3e40      	xor	X, [S-65]
    541a:	3f8c      	xor	X, ep:0x8c <_l_u8OBDValveStatusOverTempWarn>
    541c:	b723      	and	A, ep:0x23 <_l_u8VTIdx+0x1>
    541e:	bf84      	xor	A, ep:0x84 <_l_u16RecoryPos>
    5420:	0105      	jmp	0x562c <__ram_section_init+0x22>
    5422:	623a      	lod	AL, [S-59]
    5424:	bf88      	xor	A, ep:0x88 <_l_u8OBDValveStatusMove>
    5426:	1101      	call	0x562a <__ram_section_init+0x20>
    5428:	2a0e      	sub	X, [S-15]
    542a:	2a3a      	sub	X, [S-59]
    542c:	3e98      	xor	X, io:0x18 <__data_dp_start>
    542e:	580b      	inc	S, #12
    5430:	090d      	clrb	io:0x01.5
    5432:	62e6      	lod	AL, Y
    5434:	2a17      	sub	X, [S-24]
    5436:	3468      	and	X, #104
    5438:	3790      	and	X, ep:0x90 <_l_u8AliveRollingCounter>
    543a:	3806      	subc	X, #6
    543c:	380a      	subc	X, #10
    543e:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    5440:	bf88      	xor	A, ep:0x88 <_l_u8OBDValveStatusMove>
    5442:	010d      	jmp	0x565e <_STACK_IT+0x12>
    5444:	b638      	and	A, [S-57]
    5446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5448:	110a      	call	0x565e <_STACK_IT+0x12>
    544a:	2a3c      	sub	X, [S-61]
    544c:	627c      	lod	AL, [S-125]
    544e:	0101      	jmp	0x5652 <_STACK_IT+0x6>
    5450:	2a17      	sub	X, [S-24]
    5452:	b723      	and	A, ep:0x23 <_l_u8VTIdx+0x1>
    5454:	bf84      	xor	A, ep:0x84 <_l_u16RecoryPos>
    5456:	110e      	call	0x5674 <_STACK_IT+0x28>
    5458:	623a      	lod	AL, [S-59]
    545a:	7c05      	lod	X, #5
    545c:	2a17      	sub	X, [S-24]
    545e:	580e      	inc	S, #15
    5460:	0805      	clrb	dp:0x00.5
    5462:	0902      	clrb	io:0x00.2
    5464:	62e6      	lod	AL, Y
    5466:	2a2f      	sub	X, [S-48]
    5468:	627c      	lod	AL, [S-125]
    546a:	2a2f      	sub	X, [S-48]
    546c:	623a      	lod	AL, [S-59]
    546e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5470:	0103      	jmp	0x5678 <_STACK_IT+0x2c>
    5472:	2a2f      	sub	X, [S-48]
    5474:	622b      	lod	AL, [S-44]
    5476:	2a72      	sub	X, [S-115]
    5478:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    547a:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    547c:	3449      	and	X, #73
    547e:	3809      	subc	X, #9
    5480:	3805      	subc	X, #5
    5482:	37a0      	and	X, ep:0xa0 <_l_e8GmcvInitDirection>
    5484:	3986      	subc	X, dp:0x86 <_l_u8SavePosFlag>
    5486:	580e      	inc	S, #15
    5488:	0803      	clrb	dp:0x00.3
    548a:	0903      	clrb	io:0x00.3
    548c:	62e6      	lod	AL, Y
    548e:	2a43      	sub	X, [S-68]
    5490:	2a60      	sub	X, [S-97]
    5492:	627c      	lod	AL, [S-125]
    5494:	0101      	jmp	0x5698 <__fatal+0xa>
    5496:	2a43      	sub	X, [S-68]
    5498:	623a      	lod	AL, [S-59]
    549a:	b330      	adc	A, ep:0x30 <_g_DiagResponse>
    549c:	b231      	adc	A, [S-50]
    549e:	8781      	or	AL, ep:0x81 <_CmdArr+0x7>
    54a0:	8e80      	cmp	AL, io:0x0 <__dp__>
    54a2:	7330      	lod	A, ep:0x30 <_g_DiagResponse>
    54a4:	7231      	lod	A, [S-50]
    54a6:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusMove>
    54a8:	e75d      	or	Y, ep:0x5d <_LinMessage+0x1>
    54aa:	b589      	and	A, dp:0x89 <_l_u8OBDValveStatusMove+0x1>
    54ac:	ee5d      	cmp	Y, [S-94]
    54ae:	1102      	call	0x56b4 <__fatal+0x26>
    54b0:	b782      	and	A, ep:0x82 <_targetPos>
    54b2:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54b4:	b58a      	and	A, dp:0x8a <_l_u16OBDValveStatusPosition>
    54b6:	e75d      	or	Y, ep:0x5d <_LinMessage+0x1>
    54b8:	b58b      	and	A, dp:0x8b <_l_u16OBDValveStatusPosition+0x1>
    54ba:	ee5d      	cmp	Y, [S-94]
    54bc:	0001      	jmp	0x54c0 <__mlx4_flash_start+0x14c0>
    54be:	2918      	sub	X, dp:0x18 <__data_dp_start>
    54c0:	623a      	lod	AL, [S-59]
    54c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    54c4:	1101      	call	0x56c8 <__fatal+0x3a>
    54c6:	2a43      	sub	X, [S-68]
    54c8:	b201      	adc	A, [S-2]
    54ca:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54cc:	a782      	or	A, ep:0x82 <_targetPos>
    54ce:	1105      	call	0x56da <__fatal+0x4c>
    54d0:	7c05      	lod	X, #5
    54d2:	e684      	or	Y, io:0x4 <_LinMess>
    54d4:	0101      	jmp	0x56d8 <__fatal+0x4a>
    54d6:	29e2      	sub	X, dp:0xe2 <_g_i16PID_D>
    54d8:	2a1b      	sub	X, [S-28]
    54da:	e684      	or	Y, io:0x4 <_LinMess>
    54dc:	0103      	jmp	0x56e4 <__fatal+0x56>
    54de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    54e0:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    54e2:	24a3      	or	X, #-93
    54e4:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    54e6:	b682      	and	A, io:0x2 <_LinCmnd>
    54e8:	62ca      	lod	AL, [--PC]
    54ea:	b780      	and	A, ep:0x80 <_CmdArr+0x6>
    54ec:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00005540 <_INDXtbl>:
    5540:	c0c0      	add	AH, #-64
    5542:	c0c0      	add	AH, #-64
    5544:	c0c0      	add	AH, #-64
    5546:	c0c0      	add	AH, #-64
    5548:	c0c0      	add	AH, #-64
    554a:	c0c0      	add	AH, #-64
    554c:	c0c0      	add	AH, #-64
    554e:	c0c0      	add	AH, #-64
    5550:	c0c0      	add	AH, #-64
    5552:	c0c0      	add	AH, #-64
    5554:	c0c0      	add	AH, #-64
    5556:	c0c0      	add	AH, #-64
    5558:	c0c0      	add	AH, #-64
    555a:	c0c0      	add	AH, #-64
    555c:	c0c0      	add	AH, #-64
    555e:	c0c0      	add	AH, #-64
    5560:	c0c0      	add	AH, #-64
    5562:	c0c0      	add	AH, #-64
    5564:	c0c0      	add	AH, #-64
    5566:	c0c0      	add	AH, #-64
    5568:	c0c0      	add	AH, #-64
    556a:	c0c0      	add	AH, #-64
    556c:	c0c0      	add	AH, #-64
    556e:	c0c0      	add	AH, #-64
    5570:	c0c0      	add	AH, #-64
    5572:	c0c0      	add	AH, #-64
    5574:	c0c0      	add	AH, #-64
    5576:	c0c0      	add	AH, #-64
    5578:	c0c0      	add	AH, #-64
    557a:	c0c0      	add	AH, #-64
    557c:	1110      	call	0x579e <__prestart+0x84>
    557e:	c0c0      	add	AH, #-64
    5580:	0f2f      	lod	C, io:0x05.7
    5582:	a0a0      	add	A, #-96
    5584:	a0a0      	add	A, #-96
    5586:	a0a0      	add	A, #-96
    5588:	a0a0      	add	A, #-96
    558a:	a0a0      	add	A, #-96
    558c:	a0a0      	add	A, #-96
    558e:	a0a0      	add	A, #-96
    5590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    5592:	a0a0      	add	A, #-96
    5594:	a0a0      	add	A, #-96
    5596:	a0a0      	add	A, #-96
    5598:	a0a0      	add	A, #-96
    559a:	a0a0      	add	A, #-96
    559c:	a0a0      	add	A, #-96
    559e:	a0a0      	add	A, #-96
    55a0:	a0a0      	add	A, #-96
    55a2:	a0a0      	add	A, #-96
    55a4:	a0a0      	add	A, #-96
    55a6:	a0a0      	add	A, #-96
    55a8:	a0a0      	add	A, #-96
    55aa:	a0a0      	add	A, #-96
    55ac:	a0a0      	add	A, #-96
    55ae:	a0a0      	add	A, #-96
    55b0:	a0a0      	add	A, #-96
    55b2:	a0a0      	add	A, #-96
    55b4:	a0a0      	add	A, #-96
    55b6:	a0a0      	add	A, #-96
    55b8:	a0a0      	add	A, #-96
    55ba:	a0a0      	add	A, #-96
    55bc:	a0a0      	add	A, #-96
    55be:	a0a0      	add	A, #-96

000055c0 <_AUTOADDtbl>:
    55c0:	2610      	or	X, [S-17]
    55c2:	1626      	call	0x5210 <__mlx4_flash_start+0x1210>
    55c4:	0000      	nop
    55c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 571a 	jmpf	0x571a <__prestart>
    bf6e:	a55a      	or	A, dp:0x5a <_LIN_nad>
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da 564c 	jmpf	0x564c <_STACK_IT>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	6402      	lod	YL, #2
    bf7c:	76da 568e 	jmpf	0x568e <__fatal>
    bf80:	54f8      	mov	UPr, #8
    bf82:	6403      	lod	YL, #3
    bf84:	76da 568e 	jmpf	0x568e <__fatal>
    bf88:	54f8      	mov	UPr, #8
    bf8a:	6404      	lod	YL, #4
    bf8c:	76da 568e 	jmpf	0x568e <__fatal>
    bf90:	54f0      	mov	UPr, #0
    bf92:	6405      	lod	YL, #5
    bf94:	76da 568e 	jmpf	0x568e <__fatal>
    bf98:	54f0      	mov	UPr, #0
    bf9a:	6406      	lod	YL, #6
    bf9c:	76da 568e 	jmpf	0x568e <__fatal>
    bfa0:	54f0      	mov	UPr, #0
    bfa2:	6407      	lod	YL, #7
    bfa4:	76da 568e 	jmpf	0x568e <__fatal>
    bfa8:	54f0      	mov	UPr, #0
    bfaa:	6408      	lod	YL, #8
    bfac:	76da 568e 	jmpf	0x568e <__fatal>
    bfb0:	54d4      	psup	#4
    bfb2:	76da 5db4 	jmpf	0x5db4 <_linit>
    bfb6:	0000      	nop
    bfb8:	54d5      	psup	#5
    bfba:	76da 9862 	jmpf	0x9862 <_TIMER_IT>
    bfbe:	0000      	nop
    bfc0:	54d4      	psup	#4
    bfc2:	76da 82bc 	jmpf	0x82bc <_ADC_IT>
    bfc6:	0000      	nop
    bfc8:	54f0      	mov	UPr, #0
    bfca:	640c      	lod	YL, #12
    bfcc:	76da 568e 	jmpf	0x568e <__fatal>
    bfd0:	54d3      	psup	#3
    bfd2:	76da 9000 	jmpf	0x9000 <_EXT0_IT>
    bfd6:	0000      	nop
    bfd8:	54f0      	mov	UPr, #0
    bfda:	640e      	lod	YL, #14
    bfdc:	76da 568e 	jmpf	0x568e <__fatal>
    bfe0:	54f0      	mov	UPr, #0
    bfe2:	640f      	lod	YL, #15
    bfe4:	76da 568e 	jmpf	0x568e <__fatal>
    bfe8:	54f0      	mov	UPr, #0
    bfea:	6410      	lod	YL, #16
    bfec:	76da 568e 	jmpf	0x568e <__fatal>
    bff0:	54d2      	psup	#2
    bff2:	76da 8572 	jmpf	0x8572 <_EXT4_IT>
    bff6:	0000      	nop
    bff8:	54f0      	mov	UPr, #0
    bffa:	6412      	lod	YL, #18
    bffc:	76da 568e 	jmpf	0x568e <__fatal>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000055e8 <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    55e8:	7000      	lod	A, #0
    55ea:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    55ec:	70ff      	lod	A, #-1
    55ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    55f2:	72da 01a6 	lod	A, #422
    55f6:	52ef      	mov	S, A

    _low_level_init();
    55f8:	82db 68fa 	callf	0x68fa <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    55fc:	1006      	call	0x560a <__ram_section_init>
    _premain();
    55fe:	82db 6a4c 	callf	0x6a4c <__premain>
    (void)main();
    5602:	82db 6c26 	callf	0x6c26 <_main>
    _fatal();
    5606:	1043      	call	0x568e <__fatal>
    5608:	5401      	ret

0000560a <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    560a:	7ada 0028 	lod	Y, #40
    560e:	eeda 0072 	cmp	Y, #114
    5612:	1c03      	jnc	0x561a <__ram_section_init+0x10>
        *w++ = 0;
    5614:	7000      	lod	A, #0
    5616:	52d6      	mov	[Y++], A
    5618:	07fa      	jmp	0x560e <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    561a:	7ada 00e8 	lod	Y, #232
    561e:	eeda 019e 	cmp	Y, #414
    5622:	1c03      	jnc	0x562a <__ram_section_init+0x20>
        *w++ = 0;
    5624:	7000      	lod	A, #0
    5626:	52d6      	mov	[Y++], A
    5628:	07fa      	jmp	0x561e <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    562a:	7eda 9968 	lod	X, #39272

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    562e:	7ada 0018 	lod	Y, #24
    5632:	eeda 0028 	cmp	Y, #40
    5636:	1c02      	jnc	0x563c <__ram_section_init+0x32>
        *w++ = *r++;
    5638:	54ce      	movsw	[Y++], [X++]
    563a:	07fb      	jmp	0x5632 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    563c:	7ada 0072 	lod	Y, #114
    5640:	eeda 00e8 	cmp	Y, #232
    5644:	1c02      	jnc	0x564a <__ram_section_init+0x40>
        *w++ = *r++;
    5646:	54ce      	movsw	[Y++], [X++]
    5648:	07fb      	jmp	0x5640 <__ram_section_init+0x36>
    564a:	5401      	ret

0000564c <_STACK_IT>:
 */
__MLX_TEXT__ void STACK_IT(void)
{
	/* SET_STACK( &stack); */
	/* Chip header is valid and chip successfully initialised; LIN Command Reset use AWD to reset chip */
	if ( (bistHeader == C_CHIP_HEADER) && ((bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET) || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)) )
    564c:	72d8 019e 	lod	A, 0x19e <__bss_end>
    5650:	aeda b598 	cmp	A, #46488
    5654:	1d19      	jne	0x5688 <_STACK_IT+0x3c>
    5656:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    565a:	aeda 3072 	cmp	A, #12402
    565e:	1905      	je	0x566a <_STACK_IT+0x1e>
    5660:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    5664:	aeda 3212 	cmp	A, #12818
    5668:	1d0f      	jne	0x5688 <_STACK_IT+0x3c>
	{
		/* INLINE MLX16_RESET (Don't use stack) */
		do
		{
			if ( (PLL_CTRL & PLL_EN) != 0u )								/* Only delay in case of PLL is active */
    566a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    566e:	b401      	and	A, #1
    5670:	1903      	je	0x5678 <_STACK_IT+0x2c>
			{
				DELAY_US( 250);											/* Should be called with period > 200us, otherwise bit AWD_WRITE_FAIL will be set and further acknowledgment will fail during next 200 us */
    5672:	7eda 06d6 	lod	X, #1750
    5676:	1bff      	djnz	X, 0x5676 <_STACK_IT+0x2a>
			}
			AWD_CTRL = (AWD_ATT | AWD_WRITE_FAIL | ((uint16)3u << 8u) | 1u);		/* Set 1:1 pre-scaler and minimal period; AWD timeout will be 100 us */
    5678:	72da 6301 	lod	A, #25345
    567c:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
		} while ( (AWD_CTRL & (AWD_ATT | AWD_WRITE_FAIL)) != 0u );
    567e:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5680:	b6da 6000 	and	A, #24576
    5684:	1d72      	jne	0x566a <_STACK_IT+0x1e>
		for ( ; ; ) {
    5686:	07ff      	jmp	0x5686 <_STACK_IT+0x3a>
			/* wait for reset */
		}
	}
	__asm__( "mov yl, #01");
    5688:	6401      	lod	YL, #1
	__asm__( "jmp __fatal");
    568a:	0001      	jmp	0x568e <__fatal>
    568c:	5401      	ret

0000568e <__fatal>:
 * 0x079C: Address of failure (from stack)
 */
__MLX_TEXT__ void _fatal (void)
{
	/* YL = Error-reason; Don't use stack (MMP151125-1) */
	__asm__("lod X, 0x2026");													/* X = [FL_CTRL0] */
    568e:	7ed8 2026 	lod	X, 0x2026 <__ep__+0x1026>
	__asm__("and X, #0x07");													/* X[2:0] = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) */
    5692:	3407      	and	X, #7
	__asm__("lod A, 0x2040");													/* A = [PLL_STAT] */
    5694:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
	__asm__("and A, #0x03");													/* A[1:0] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) */
    5698:	b403      	and	A, #3
	__asm__("asl A, #2");
    569a:	44a2      	asl	A, #2
	__asm__("asl A, #2");														/* A[5:4] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569c:	44a2      	asl	A, #2
	__asm__("or  A, X");														/* A(L) = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569e:	a6ee      	or	A, X
	__asm__("lod YH, AL");														/* YH = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    56a0:	6ee0      	lod	YH, AL
	__asm__("mov _bistError, Y");
    56a2:	5ad8 01a2 	mov	0x1a2 <_bistError>, Y
	__asm__("lod A, [S-2]");													/* Save address of failed instruction */
    56a6:	7201      	lod	A, [S-2]
	__asm__("mov _bistErrorInfo, A");											/* Failure address */
    56a8:	52d8 01a4 	mov	0x1a4 <_bistErrorInfo>, A

#if _SUPPORT_CRASH_RECOVERY
	/* Crash recovery */
	if ( (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) && ((uint8)(bistError & 0xFFu) < 0x05u) )	/* MMP151125-1 */
    56ac:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    56b0:	aeda 1a45 	cmp	A, #6725
    56b4:	1d20      	jne	0x56f6 <__fatal+0x68>
    56b6:	72d8 01a2 	lod	A, 0x1a2 <_bistError>
    56ba:	8c04      	cmp	AL, #4
    56bc:	1e1c      	jug	0x56f6 <__fatal+0x68>
	{
		/* Crash recovery is enabled, and type of IRQ is between 0x01 and 0x04 */
		bistResetInfo = C_CHIP_STATE_FATAL_CRASH_RECOVERY;						/* Start recovery (on-going) */
    56be:	72da 1872 	lod	A, #6258
    56c2:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
		SET_STACK( &stack);														/* Re-initialise stack */
    56c6:	72da 01a6 	lod	A, #422
    56ca:	52ef      	mov	S, A
		ENTER_SYSTEM_MODE();													/* Protected mode, highest priority (0) (MMP141023-1) */
    56cc:	4407      	mov	R, #0
    56ce:	500c      	call	fp0:0x60
    56d0:	54f0      	mov	UPr, #0
		XI0_PEND = CLR_T1_INT4;
    56d2:	7040      	lod	A, #64
    56d4:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI2_PEND = 0xFFFFu;														/* Clear all XI2_PEND flags */
    56d8:	70ff      	lod	A, #-1
    56da:	52d8 2038 	mov	0x2038 <__ep__+0x1038>, A
		XI4_PEND = (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV);
    56de:	72da e100 	lod	A, #57600
    56e2:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		PEND = CLR_TIMER_IT;													/* Core-Timer */
    56e6:	7020      	lod	A, #32
    56e8:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		SET_PRIORITY( 7);														/* Protected mode, low priority (7) */
    56ec:	54f7      	mov	UPr, #7
				NVRAM_SavePage( NVRAM1_PAGE2 | NVRAM_PAGE_WR_SKIP_WAIT);
			}
		}
#endif /* (_DEBUG_FATAL != FALSE) */

		(void) main();
    56ee:	82db 6c26 	callf	0x6c26 <_main>

		/* Should never come here, as main should not be left */
		__asm__( "mov YL, #0x19");												/* C_MLX16_MAIN_FATAL */
    56f2:	6419      	lod	YL, #25
		/* lint -e{974} */ _fatal();
    56f4:	17cc      	call	0x568e <__fatal>
	}
#endif /* _SUPPORT_CRASH_RECOVERY */

	SET_STACK( &stack);															/* Re-initialise stack (MMP141023-1) */
    56f6:	72da 01a6 	lod	A, #422
    56fa:	52ef      	mov	S, A
	ENTER_SYSTEM_MODE();														/* Protected mode, highest priority (0) (MMP141023-1) */
    56fc:	4407      	mov	R, #0
    56fe:	500c      	call	fp0:0x60
    5700:	54f0      	mov	UPr, #0
	FL_CTRL0 &= (uint16)~(FL_DBE | FL_SBE);										/* Clear DBE and SBE errors (MMP141023-1) */
    5702:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5706:	b4f9      	and	A, #-7
    5708:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
		}
	}
#endif /* (_DEBUG_FATAL != FALSE) */

	/* Disable motor driver first, before waiting for watchdog */
	DRVCFG_DIS_UVWT();															/* Tri-state (disconnect) the phase U, V, W and T (MMP130919-1) */
    570c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    5710:	b6da fe00 	and	A, #65024
    5714:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	for (;;) {
    5718:	07ff      	jmp	0x5718 <__fatal+0x8a>

0000571a <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    571a:	5801      	inc	S, #2
    571c:	7000      	lod	A, #0
    571e:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    5720:	70ff      	lod	A, #-1
    5722:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    5726:	72da 01a6 	lod	A, #422
    572a:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    572c:	1130      	call	0x598e <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    572e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5732:	b401      	and	A, #1
    5734:	1d27      	jne	0x5784 <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5736:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    573a:	5cf2      	usex	A
    573c:	4422      	asl	A
    573e:	7ada 10e8 	lod	Y, #4328
    5742:	eae2      	sub	Y, A
    5744:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5748:	5cf2      	usex	A
    574a:	7ee2      	lod	X, A
    574c:	7014      	lod	A, #20
    574e:	aaee      	sub	A, X
    5750:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    5752:	7ee2      	lod	X, A
    5754:	7000      	lod	A, #0
    5756:	08a7      	clrb	ML.7
    5758:	b2d6      	adc	A, [Y++]
    575a:	1bfe      	djnz	X, 0x5758 <__prestart+0x3e>
    575c:	92e4      	adc	AL, AH
    575e:	9000      	adc	AL, #0
    5760:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    5762:	aeda 00ff 	cmp	A, #255
    5766:	1d0e      	jne	0x5784 <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    5768:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    576c:	b4f8      	and	A, #-8
    576e:	aeda 04b8 	cmp	A, #1208
    5772:	1d08      	jne	0x5784 <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    5774:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    5778:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    577c:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    577e:	eeda 201a 	cmp	Y, #8218
    5782:	1a7c      	jule	0x577c <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    5784:	72d8 019e 	lod	A, 0x19e <__bss_end>
    5788:	aeda b598 	cmp	A, #46488
    578c:	1901      	je	0x5790 <__prestart+0x76>
    578e:	0037      	jmp	0x57fe <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    5790:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5792:	ac00      	cmp	A, #0
    5794:	1a84      	jsl	0x579e <__prestart+0x84>
    5796:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    579a:	8c00      	cmp	AL, #0
    579c:	1e98      	jsge	0x57ce <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    579e:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57a2:	aeda 3072 	cmp	A, #12402
    57a6:	1d01      	jne	0x57aa <__prestart+0x90>
    57a8:	0031      	jmp	0x580c <__prestart+0xf2>
    57aa:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57ae:	aeda 3212 	cmp	A, #12818
    57b2:	192c      	je	0x580c <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    57b4:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57b8:	1905      	je	0x57c4 <__prestart+0xaa>
    57ba:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57be:	aeda 1a45 	cmp	A, #6725
    57c2:	1d03      	jne	0x57ca <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    57c4:	72da 5c92 	lod	A, #23698
    57c8:	000d      	jmp	0x57e4 <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    57ca:	7c00      	lod	X, #0
    57cc:	0015      	jmp	0x57f8 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    57ce:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57d2:	aeda 3072 	cmp	A, #12402
    57d6:	1909      	je	0x57ea <__prestart+0xd0>
    57d8:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57dc:	aeda 3212 	cmp	A, #12818
    57e0:	1904      	je	0x57ea <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    57e2:	7000      	lod	A, #0
    57e4:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
    57e8:	0011      	jmp	0x580c <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    57ea:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    57ee:	aeda 1a45 	cmp	A, #6725
    57f2:	1d0c      	jne	0x580c <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    57f4:	7eda 56d2 	lod	X, #22226
    57f8:	5ed8 01a0 	mov	0x1a0 <_bistResetInfo>, X
    57fc:	0007      	jmp	0x580c <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    57fe:	7000      	lod	A, #0
    5800:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    5804:	7eda b598 	lod	X, #46488
    5808:	5ed8 019e 	mov	0x19e <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    580c:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    5810:	aeda 3072 	cmp	A, #12402
    5814:	1919      	je	0x5848 <__prestart+0x12e>
    5816:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    581a:	aeda 3212 	cmp	A, #12818
    581e:	1914      	je	0x5848 <__prestart+0x12e>
    5820:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    5824:	aeda 5c92 	cmp	A, #23698
    5828:	190f      	je	0x5848 <__prestart+0x12e>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    582a:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    582e:	7c20      	lod	X, #32
    5830:	7000      	lod	A, #0
    5832:	08a7      	clrb	ML.7
    5834:	b2d6      	adc	A, [Y++]
    5836:	1bfe      	djnz	X, 0x5834 <__prestart+0x11a>
    5838:	92e4      	adc	AL, AH
    583a:	9000      	adc	AL, #0
    583c:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    583e:	aeda 00ff 	cmp	A, #255
    5842:	1902      	je	0x5848 <__prestart+0x12e>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    5844:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    5846:	0723      	jmp	0x568e <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    5848:	6030      	lod	AL, #48
    584a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    584e:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    5852:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    5856:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    585a:	a6da 8000 	or	A, #32768
    585e:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    5862:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    5866:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    586a:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    586e:	b6da 00ff 	and	A, #255
    5872:	a6da c000 	or	A, #49152
    5876:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    587a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    587e:	94cf      	and	AL, #-49
    5880:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    5884:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    5888:	b4f9      	and	A, #-7
    588a:	a402      	or	A, #2
    588c:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    5890:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5894:	b401      	and	A, #1
    5896:	1914      	je	0x58c0 <__prestart+0x1a6>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    5898:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    589c:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    58a0:	a6e6      	or	A, Y
    58a2:	190e      	je	0x58c0 <__prestart+0x1a6>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    58a4:	7eda 55c8 	lod	X, #21960

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    58a8:	7ada 0740 	lod	Y, #1856
    58ac:	eeda 075e 	cmp	Y, #1886
    58b0:	1c05      	jnc	0x58bc <__prestart+0x1a2>
        *w++ = *r++;
    58b2:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b4:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b6:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b8:	54ce      	movsw	[Y++], [X++]
    58ba:	07f8      	jmp	0x58ac <__prestart+0x192>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    58bc:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    58c0:	72da 6fd1 	lod	A, #28625
    58c4:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58c8:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    58ca:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    58ce:	b401      	and	A, #1
    58d0:	1d03      	jne	0x58d8 <__prestart+0x1be>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58d2:	e001      	add	Y, #1
    58d4:	ec63      	cmp	Y, #99
    58d6:	1a79      	jule	0x58ca <__prestart+0x1b0>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    58d8:	ec64      	cmp	Y, #100
    58da:	1d01      	jne	0x58de <__prestart+0x1c4>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    58dc:	07ff      	jmp	0x58dc <__prestart+0x1c2>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    58de:	6024      	lod	AL, #36
    58e0:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    58e4:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    58e8:	aeda 3072 	cmp	A, #12402
    58ec:	190e      	je	0x590a <__prestart+0x1f0>
    58ee:	82db 6606 	callf	0x6606 <_LDR_GetState>
    58f2:	8c00      	cmp	AL, #0
    58f4:	1d0a      	jne	0x590a <__prestart+0x1f0>
    58f6:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    58fa:	aeda 3212 	cmp	A, #12818
    58fe:	1905      	je	0x590a <__prestart+0x1f0>
    5900:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    5904:	aeda 5c92 	cmp	A, #23698
    5908:	1d02      	jne	0x590e <__prestart+0x1f4>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    590a:	066e      	jmp	0x55e8 <_start>
    590c:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    590e:	76da 68aa 	jmpf	0x68aa <_RAM_Test>
    5912:	5403      	ret	#4

00005914 <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    5914:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    5916:	4407      	mov	R, #0
    5918:	500c      	call	fp0:0x60
    591a:	54f0      	mov	UPr, #0
    591c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    591e:	b430      	and	A, #48
    5920:	ac10      	cmp	A, #16
    5922:	1914      	je	0x594c <_MLX16_RESET+0x38>
    5924:	1e03      	jug	0x592c <_MLX16_RESET+0x18>
    5926:	ac00      	cmp	A, #0
    5928:	190c      	je	0x5942 <_MLX16_RESET+0x2e>
    592a:	002f      	jmp	0x598a <_MLX16_RESET+0x76>
    592c:	ac20      	cmp	A, #32
    592e:	1903      	je	0x5936 <_MLX16_RESET+0x22>
    5930:	ac30      	cmp	A, #48
    5932:	1904      	je	0x593c <_MLX16_RESET+0x28>
    5934:	002a      	jmp	0x598a <_MLX16_RESET+0x76>
    5936:	6000      	lod	AL, #0
    5938:	4282      	mov	io:0x2 <_LinCmnd>, AL
    593a:	07fd      	jmp	0x5936 <_MLX16_RESET+0x22>
    593c:	6000      	lod	AL, #0
    593e:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5940:	07ff      	jmp	0x5940 <_MLX16_RESET+0x2c>
    5942:	6001      	lod	AL, #1
    5944:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5946:	6010      	lod	AL, #16
    5948:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    594a:	07ff      	jmp	0x594a <_MLX16_RESET+0x36>
    594c:	6282      	lod	AL, io:0x2 <_LinCmnd>
    594e:	66e0      	lod	YL, AL
    5950:	5cf6      	usex	Y
    5952:	44a6      	asl	Y, #2
    5954:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5956:	b403      	and	A, #3
    5958:	4422      	asl	A
    595a:	ac00      	cmp	A, #0
    595c:	1b03      	jsle	0x5964 <_MLX16_RESET+0x50>
    595e:	42e9      	mov	Cx, AL
    5960:	4426      	asl	Y
    5962:	1ffe      	djnz	Cx, 0x5960 <_MLX16_RESET+0x4c>
    5964:	ec7d      	cmp	Y, #125
    5966:	1c01      	jnc	0x596a <_MLX16_RESET+0x56>
    5968:	07ff      	jmp	0x5968 <_MLX16_RESET+0x54>
    596a:	7eda 06d6 	lod	X, #1750
    596e:	1bff      	djnz	X, 0x596e <_MLX16_RESET+0x5a>
    5970:	72da 6301 	lod	A, #25345
    5974:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
    5976:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5978:	b6da 6000 	and	A, #24576
    597c:	1d76      	jne	0x596a <_MLX16_RESET+0x56>
    597e:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    5982:	b4fe      	and	A, #-2
    5984:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    5988:	07ff      	jmp	0x5988 <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    598a:	5ae3      	mov	M, Y
    598c:	5401      	ret

0000598e <_NVRAM_LoadAll>:
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
        WD_T = 0;                       /* .. acknowledge the watchdog */
    598e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5992:	b401      	and	A, #1
    5994:	1908      	je	0x59a6 <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5996:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5998:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    599a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    599c:	b430      	and	A, #48
    599e:	1977      	je	0x598e <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59a0:	6000      	lod	AL, #0
    59a2:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59a4:	07f4      	jmp	0x598e <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    59a6:	72da 8000 	lod	A, #32768
    59aa:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    59ae:	72da 8001 	lod	A, #32769
    59b2:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59b6:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59ba:	b401      	and	A, #1
    59bc:	1908      	je	0x59ce <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59be:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    59c0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59c2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59c4:	b430      	and	A, #48
    59c6:	1977      	je	0x59b6 <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59c8:	6000      	lod	AL, #0
    59ca:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59cc:	07f4      	jmp	0x59b6 <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    59ce:	7000      	lod	A, #0
    59d0:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    59d4:	7001      	lod	A, #1
    59d6:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59da:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59de:	b401      	and	A, #1
    59e0:	1908      	je	0x59f2 <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59e2:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    59e4:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59e6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59e8:	b430      	and	A, #48
    59ea:	1977      	je	0x59da <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59ec:	6000      	lod	AL, #0
    59ee:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59f0:	07f4      	jmp	0x59da <_NVRAM_LoadAll+0x4c>
    59f2:	5401      	ret

000059f4 <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    59f4:	7ee2      	lod	X, A
    59f6:	b6da 7fff 	and	A, #32767
    59fa:	ac01      	cmp	A, #1
    59fc:	1906      	je	0x5a0a <_NVRAM_SavePage+0x16>
    59fe:	1803      	jc	0x5a06 <_NVRAM_SavePage+0x12>
    5a00:	ac02      	cmp	A, #2
    5a02:	1905      	je	0x5a0e <_NVRAM_SavePage+0x1a>
    5a04:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    5a06:	7810      	lod	Y, #16
            break;
    5a08:	0004      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    5a0a:	7818      	lod	Y, #24
            break;
    5a0c:	0002      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    5a0e:	7ada 8400 	lod	Y, #33792
    5a12:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a16:	b401      	and	A, #1
    5a18:	1908      	je	0x5a2a <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a1a:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5a1c:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a1e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a20:	b430      	and	A, #48
    5a22:	1977      	je	0x5a12 <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a24:	6000      	lod	AL, #0
    5a26:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a28:	07f4      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    5a2a:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    5a2e:	e403      	or	Y, #3
    5a30:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    5a34:	2c00      	cmp	X, #0
    5a36:	1a8c      	jsl	0x5a50 <_NVRAM_SavePage+0x5c>
    5a38:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a3c:	b401      	and	A, #1
    5a3e:	1908      	je	0x5a50 <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a40:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5a42:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a44:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a46:	b430      	and	A, #48
    5a48:	1977      	je	0x5a38 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a4a:	6000      	lod	AL, #0
    5a4c:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a4e:	07f4      	jmp	0x5a38 <_NVRAM_SavePage+0x44>
    5a50:	5401      	ret

00005a52 <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    5a52:	7ae2      	lod	Y, A
    5a54:	6203      	lod	AL, [S-4]
    5a56:	5cf2      	usex	A
    5a58:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    5a5a:	72e6      	lod	A, Y
    5a5c:	b401      	and	A, #1
    5a5e:	1908      	je	0x5a70 <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    5a60:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a62:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    5a64:	b6da 00ff 	and	A, #255
    5a68:	36da 00ff 	and	X, #255
    5a6c:	7eec      	swap	X
    5a6e:	0003      	jmp	0x5a76 <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a70:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    5a72:	b6da ff00 	and	A, #65280
    5a76:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    5a78:	52f0      	mov	[Y], A
    5a7a:	5401      	ret

00005a7c <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    5a7c:	7000      	lod	A, #0
    5a7e:	17ba      	call	0x59f4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    5a80:	7001      	lod	A, #1
    5a82:	17b8      	call	0x59f4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    5a84:	7002      	lod	A, #2
    5a86:	17b6      	call	0x59f4 <_NVRAM_SavePage>
    5a88:	5401      	ret

00005a8a <_ml_ReleaseBuffer>:
    5a8a:	602f      	lod	AL, #47
    5a8c:	0033      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005a8e <_ml_ReleaseBufferProg>:
    5a8e:	9401      	and	AL, #1
    5a90:	44a0      	asl	AL, #2
    5a92:	44a0      	asl	AL, #2
    5a94:	840f      	or	AL, #15
    5a96:	002e      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005a98 <_ml_DataReady>:
    5a98:	6ae0      	lod	AH, AL
    5a9a:	6015      	lod	AL, #21
    5a9c:	7eda 0008 	lod	X, #8
    5aa0:	7ada 0052 	lod	Y, #82
    5aa4:	54c6      	movsw	[X++], [Y++]
    5aa6:	54c6      	movsw	[X++], [Y++]
    5aa8:	54c6      	movsw	[X++], [Y++]
    5aaa:	54c6      	movsw	[X++], [Y++]
    5aac:	0023      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aae <_ml_AssignFrameToMessageID>:
    5aae:	6a03      	lod	AH, [S-4]
    5ab0:	d43f      	and	AH, #63
    5ab2:	0004      	jmp	0x5abc <_ml_EnableMessage+0x4>

00005ab4 <_ml_DisableMessage>:
    5ab4:	6802      	lod	AH, #2
    5ab6:	0001      	jmp	0x5aba <_ml_EnableMessage+0x2>

00005ab8 <_ml_EnableMessage>:
    5ab8:	6803      	lod	AH, #3
    5aba:	44d4      	rr	AH, #2
    5abc:	44a0      	asl	AL, #2
    5abe:	44a0      	asl	AL, #2
    5ac0:	8406      	or	AL, #6
    5ac2:	0018      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005ac4 <_ml_AutoAddressingConfig>:
    5ac4:	44a0      	asl	AL, #2
    5ac6:	44a0      	asl	AL, #2
    5ac8:	840d      	or	AL, #13
    5aca:	0014      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005acc <_ml_SetSlewRate>:
    5acc:	44a2      	asl	A, #2
    5ace:	44a2      	asl	A, #2
    5ad0:	a407      	or	A, #7
    5ad2:	0010      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005ad4 <_ml_SetOptions>:
    5ad4:	6a03      	lod	AH, [S-4]
    5ad6:	44a4      	asl	AH, #2
    5ad8:	86e4      	or	AL, AH
    5ada:	44a0      	asl	AL, #2
    5adc:	44a0      	asl	AL, #2
    5ade:	840b      	or	AL, #11
    5ae0:	c607      	or	AH, [S-8]
    5ae2:	44a4      	asl	AH, #2
    5ae4:	c605      	or	AH, [S-6]
    5ae6:	dc01      	xor	AH, #1
    5ae8:	0005      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aea <_ml_DiscardFrame>:
    5aea:	6005      	lod	AL, #5
    5aec:	0003      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aee <_ml_ContFrame>:
    5aee:	6ae0      	lod	AH, AL
    5af0:	6025      	lod	AL, #37
    5af2:	0000      	nop
    5af4:	54e2      	mov	Cx, #2
    5af6:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    5afa:	7ae2      	lod	Y, A
    5afc:	6041      	lod	AL, #65
    5afe:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5b02:	7eda 03e8 	lod	X, #1000
    5b06:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5b0a:	9402      	and	AL, #2
    5b0c:	1d03      	jne	0x5b14 <_ml_ContFrame+0x26>
    5b0e:	1bfb      	djnz	X, 0x5b06 <_ml_ContFrame+0x18>
    5b10:	7002      	lod	A, #2
    5b12:	5401      	ret
    5b14:	7ee6      	lod	X, Y
    5b16:	340f      	and	X, #15
    5b18:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b1c:	6800      	lod	AH, #0
    5b1e:	aeee      	cmp	A, X
    5b20:	1d02      	jne	0x5b26 <_ml_ContFrame+0x38>
    5b22:	7000      	lod	A, #0
    5b24:	5401      	ret
    5b26:	72e6      	lod	A, Y
    5b28:	1fe6      	djnz	Cx, 0x5af6 <_ml_ContFrame+0x8>
    5b2a:	7001      	lod	A, #1
    5b2c:	5401      	ret

00005b2e <_ml_LinModuleVersion>:
    5b2e:	602a      	lod	AL, #42
    5b30:	17e1      	call	0x5af4 <_ml_ContFrame+0x6>
    5b32:	ac00      	cmp	A, #0
    5b34:	1d11      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b36:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b3a:	940f      	and	AL, #15
    5b3c:	8c0a      	cmp	AL, #10
    5b3e:	1d0c      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b40:	66e4      	lod	YL, AH
    5b42:	601a      	lod	AL, #26
    5b44:	17d7      	call	0x5af4 <_ml_ContFrame+0x6>
    5b46:	ac00      	cmp	A, #0
    5b48:	1d07      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b4a:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b4e:	940f      	and	AL, #15
    5b50:	8c0a      	cmp	AL, #10
    5b52:	1d02      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b54:	62e8      	lod	AL, YL
    5b56:	5401      	ret
    5b58:	7000      	lod	A, #0
    5b5a:	5401      	ret

00005b5c <_ml_GetState>:
    5b5c:	44a2      	asl	A, #2
    5b5e:	44a2      	asl	A, #2
    5b60:	a40c      	or	A, #12
    5b62:	17c8      	call	0x5af4 <_ml_ContFrame+0x6>
    5b64:	ac00      	cmp	A, #0
    5b66:	1d0b      	jne	0x5b7e <_ml_GetState+0x22>
    5b68:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b6c:	8c0c      	cmp	AL, #12
    5b6e:	1d07      	jne	0x5b7e <_ml_GetState+0x22>
    5b70:	62e4      	lod	AL, AH
    5b72:	44f4      	asr	AH, #2
    5b74:	44f4      	asr	AH, #2
    5b76:	4ad8 9801 	mov	0x198 <_LinStatus>, AH
    5b7a:	b40f      	and	A, #15
    5b7c:	5401      	ret
    5b7e:	70ff      	lod	A, #-1
    5b80:	5401      	ret

00005b82 <_ml_SetBaudRate>:
    5b82:	44a0      	asl	AL, #2
    5b84:	44a0      	asl	AL, #2
    5b86:	8402      	or	AL, #2
    5b88:	7a03      	lod	Y, [S-4]
    5b8a:	6ae8      	lod	AH, YL
    5b8c:	07b3      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005b8e <_ml_SetAutoBaudRateMode>:
    5b8e:	6ae0      	lod	AH, AL
    5b90:	6002      	lod	AL, #2
    5b92:	84e0      	or	AL, #-32
    5b94:	07af      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005b96 <_ml_Connect>:
    5b96:	6002      	lod	AL, #2
    5b98:	0008      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005b9a <_ml_Disconnect>:
    5b9a:	6001      	lod	AL, #1
    5b9c:	0006      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005b9e <_ml_SwitchToFast>:
    5b9e:	600f      	lod	AL, #15
    5ba0:	0004      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005ba2 <_ml_WakeUp>:
    5ba2:	6008      	lod	AL, #8
    5ba4:	0002      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005ba6 <_ml_GotoSleep>:
    5ba6:	6004      	lod	AL, #4
    5ba8:	0000      	nop
    5baa:	44a0      	asl	AL, #2
    5bac:	44a0      	asl	AL, #2
    5bae:	8401      	or	AL, #1
    5bb0:	07a1      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005bb2 <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    5bb2:	60aa      	lod	AL, #-86
    5bb4:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    5bb8:	7104      	lod	A, dp:0x4 <_LinMess>
    5bba:	515c      	mov	dp:0x5c <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    5bbc:	7810      	lod	Y, #16
    5bbe:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bc2:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    5bc4:	ac03      	cmp	A, #3
    5bc6:	1d09      	jne	0x5bda <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    5bc8:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    5bca:	5152      	mov	dp:0x52 <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    5bcc:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    5bce:	5954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    5bd0:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    5bd2:	5156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    5bd4:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    5bd6:	5958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    5bd8:	1758      	call	0x5a8a <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    5bda:	6042      	lod	AL, #66
    5bdc:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5be0:	5401      	ret

00005be2 <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    5be2:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5be4:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5be6:	72e6      	lod	A, Y
    5be8:	b40f      	and	A, #15
    5bea:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    5bec:	ac07      	cmp	A, #7
    5bee:	1d07      	jne	0x5bfe <_ml_ProccessLinEvent+0x1c>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    5bf0:	44b6      	lsr	Y, #2
    5bf2:	44b6      	lsr	Y, #2
    5bf4:	72e6      	lod	A, Y
    5bf6:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    5bf8:	82db 7a40 	callf	0x7a40 <_mlu_AutoAddressingStep>
    5bfc:	00c7      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    5bfe:	72e6      	lod	A, Y
    5c00:	6000      	lod	AL, #0
    5c02:	72e4      	swap	A
    5c04:	b43f      	and	A, #63
    5c06:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    5c08:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    5c0c:	8c55      	cmp	AL, #85
    5c0e:	1d01      	jne	0x5c12 <_ml_ProccessLinEvent+0x30>
    5c10:	009d      	jmp	0x5d4c <_ml_ProccessLinEvent+0x16a>
        if (LDR_GetState() == 0) {
    5c12:	82db 6606 	callf	0x6606 <_LDR_GetState>
    5c16:	8c00      	cmp	AL, #0
    5c18:	1901      	je	0x5c1c <_ml_ProccessLinEvent+0x3a>
    5c1a:	006a      	jmp	0x5cf0 <_ml_ProccessLinEvent+0x10e>
#endif
            switch(LinCommand) {
    5c1c:	7203      	lod	A, [S-4]
    5c1e:	a0ff      	add	A, #-1
    5c20:	ac04      	cmp	A, #4
    5c22:	1a01      	jule	0x5c26 <_ml_ProccessLinEvent+0x44>
    5c24:	00b3      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5c26:	4422      	asl	A
    5c28:	7ae2      	lod	Y, A
    5c2a:	e2da 6ba0 	add	Y, #27552
    5c2e:	72f0      	lod	A, [Y]
    5c30:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    5c32:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5c34:	72e6      	lod	A, Y
    5c36:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    5c3a:	ac40      	cmp	A, #64
    5c3c:	1901      	je	0x5c40 <_ml_ProccessLinEvent+0x5e>
    5c3e:	00a6      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    5c40:	44c6      	rl	Y, #2
    5c42:	44c6      	rl	Y, #2
    5c44:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    5c46:	72e6      	lod	A, Y
    5c48:	82db 791e 	callf	0x791e <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    5c4c:	009f      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    5c4e:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5c50:	72e6      	lod	A, Y
    5c52:	44b2      	lsr	A, #2
    5c54:	44b2      	lsr	A, #2
    5c56:	b40f      	and	A, #15
    5c58:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    5c5a:	ac05      	cmp	A, #5
    5c5c:	1d0e      	jne	0x5c7a <_ml_ProccessLinEvent+0x98>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    5c5e:	6400      	lod	YL, #0
    5c60:	7ae8      	swap	Y
    5c62:	72e6      	lod	A, Y
    5c64:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    5c66:	44b6      	lsr	Y, #2
    5c68:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    5c6a:	80ff      	add	AL, #-1
    5c6c:	8c08      	cmp	AL, #8
    5c6e:	1a17      	jule	0x5c9e <_ml_ProccessLinEvent+0xbc>
    5c70:	62e8      	lod	AL, YL
    5c72:	8c0f      	cmp	AL, #15
    5c74:	1914      	je	0x5c9e <_ml_ProccessLinEvent+0xbc>
                            Error = ml_erStopBitTX;
    5c76:	7c10      	lod	X, #16
    5c78:	0012      	jmp	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    5c7a:	ac0c      	cmp	A, #12
    5c7c:	1d05      	jne	0x5c88 <_ml_ProccessLinEvent+0xa6>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    5c7e:	44c6      	rl	Y, #2
    5c80:	44c6      	rl	Y, #2
    5c82:	f40f      	and	Y, #15
                        if(nbytes == 0)
    5c84:	1d0c      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    5c86:	0082      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    5c88:	ac02      	cmp	A, #2
    5c8a:	1d09      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    5c8c:	6400      	lod	YL, #0
    5c8e:	7ae8      	swap	Y
    5c90:	72e6      	lod	A, Y
    5c92:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    5c94:	8c02      	cmp	AL, #2
    5c96:	1d03      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    5c98:	1780      	call	0x5b9a <_ml_Disconnect>
                            (void)ml_Connect();
    5c9a:	177d      	call	0x5b96 <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    5c9c:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    5c9e:	72ee      	lod	A, X
    5ca0:	82db 7908 	callf	0x7908 <_mlu_ErrorDetected>
                    break;
    5ca4:	0073      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5ca6:	7104      	lod	A, dp:0x4 <_LinMess>
    5ca8:	52d8 00e4 	mov	0xe4 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cac:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cae:	42d8 00e6 	mov	0xe6 <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    5cb2:	6201      	lod	AL, [S-2]
    5cb4:	8c10      	cmp	AL, #16
    5cb6:	1902      	je	0x5cbc <_ml_ProccessLinEvent+0xda>
                        mlu_MessageReceived(LinID); /* notify application */
    5cb8:	7201      	lod	A, [S-2]
    5cba:	000a      	jmp	0x5cd0 <_ml_ProccessLinEvent+0xee>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    5cbc:	54ca 0000 	pushw	#0
    5cc0:	72da 0052 	lod	A, #82
    5cc4:	10b5      	call	0x5e30 <_ldr_isReadByIdMessage>
    5cc6:	5c01      	dec	S, #2
    5cc8:	8c00      	cmp	AL, #0
    5cca:	1901      	je	0x5cce <_ml_ProccessLinEvent+0xec>
    5ccc:	0034      	jmp	0x5d36 <_ml_ProccessLinEvent+0x154>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    5cce:	7010      	lod	A, #16
    5cd0:	82db 7944 	callf	0x7944 <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    5cd4:	005b      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5cd6:	7104      	lod	A, dp:0x4 <_LinMess>
    5cd8:	52d8 00e4 	mov	0xe4 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cdc:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cde:	42d8 00e6 	mov	0xe6 <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    5ce2:	7201      	lod	A, [S-2]
    5ce4:	82db 783c 	callf	0x783c <_mlu_DataRequest>
                    break;
    5ce8:	0051      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    5cea:	82db 78a0 	callf	0x78a0 <_mlu_DataTransmitted>
                    break;
    5cee:	004e      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    5cf0:	7203      	lod	A, [S-4]
    5cf2:	ac03      	cmp	A, #3
    5cf4:	190d      	je	0x5d10 <_ml_ProccessLinEvent+0x12e>
    5cf6:	1e03      	jug	0x5cfe <_ml_ProccessLinEvent+0x11c>
    5cf8:	ac02      	cmp	A, #2
    5cfa:	1905      	je	0x5d06 <_ml_ProccessLinEvent+0x124>
    5cfc:	0047      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5cfe:	7203      	lod	A, [S-4]
    5d00:	ac04      	cmp	A, #4
    5d02:	191d      	je	0x5d3e <_ml_ProccessLinEvent+0x15c>
    5d04:	0043      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d06:	615c      	lod	AL, dp:0x5c <_LinMessage>
    5d08:	44b2      	lsr	A, #2
    5d0a:	44b2      	lsr	A, #2
    5d0c:	b40f      	and	A, #15
    5d0e:	002f      	jmp	0x5d6e <_ml_ProccessLinEvent+0x18c>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d10:	7104      	lod	A, dp:0x4 <_LinMess>
    5d12:	52d8 00e4 	mov	0xe4 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d16:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d18:	42d8 00e6 	mov	0xe6 <_LINBaud>, AL

                    if (LinID == D_DIA) {
    5d1c:	6201      	lod	AL, [S-2]
    5d1e:	8c10      	cmp	AL, #16
    5d20:	1901      	je	0x5d24 <_ml_ProccessLinEvent+0x142>
    5d22:	0034      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    5d24:	54ca 0001 	pushw	#1
    5d28:	72da 0052 	lod	A, #82
    5d2c:	1081      	call	0x5e30 <_ldr_isReadByIdMessage>
    5d2e:	5c01      	dec	S, #2
    5d30:	8c00      	cmp	AL, #0
    5d32:	1d01      	jne	0x5d36 <_ml_ProccessLinEvent+0x154>
    5d34:	002b      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    5d36:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    5d38:	5cf2      	usex	A
    5d3a:	11ed      	call	0x6116 <_ml_ldr_ReadByIdMessage>
    5d3c:	0027      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d3e:	7104      	lod	A, dp:0x4 <_LinMess>
    5d40:	52d8 00e4 	mov	0xe4 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d44:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d46:	42d8 00e6 	mov	0xe6 <_LINBaud>, AL
    5d4a:	001d      	jmp	0x5d86 <_ml_ProccessLinEvent+0x1a4>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    5d4c:	7203      	lod	A, [S-4]
    5d4e:	ac03      	cmp	A, #3
    5d50:	1910      	je	0x5d72 <_ml_ProccessLinEvent+0x190>
    5d52:	1e03      	jug	0x5d5a <_ml_ProccessLinEvent+0x178>
    5d54:	ac02      	cmp	A, #2
    5d56:	1907      	je	0x5d66 <_ml_ProccessLinEvent+0x184>
    5d58:	0019      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5d5a:	7203      	lod	A, [S-4]
    5d5c:	ac04      	cmp	A, #4
    5d5e:	1913      	je	0x5d86 <_ml_ProccessLinEvent+0x1a4>
    5d60:	ac05      	cmp	A, #5
    5d62:	1913      	je	0x5d8a <_ml_ProccessLinEvent+0x1a8>
    5d64:	0013      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d66:	44b6      	lsr	Y, #2
    5d68:	44b6      	lsr	Y, #2
    5d6a:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    5d6c:	72e6      	lod	A, Y
    5d6e:	113c      	call	0x5fe8 <_ml_ldr_ErrorDetected>
                 break;
    5d70:	000d      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    5d72:	6201      	lod	AL, [S-2]
    5d74:	8c10      	cmp	AL, #16
    5d76:	1d0a      	jne	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5d78:	6152      	lod	AL, dp:0x52 <_LinFrameDataBuffer>
    5d7a:	8d5a      	cmp	AL, dp:0x5a <_LIN_nad>
    5d7c:	1902      	je	0x5d82 <_ml_ProccessLinEvent+0x1a0>
    5d7e:	8c7f      	cmp	AL, #127
    5d80:	1d05      	jne	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    5d82:	1217      	call	0x61b2 <_ml_DiagReceived>
    5d84:	0003      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    5d86:	16b1      	call	0x5aea <_ml_DiscardFrame>
                 break;
    5d88:	0001      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    5d8a:	11e1      	call	0x614e <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    5d8c:	60ab      	lod	AL, #-85
    5d8e:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    5d92:	5405      	ret	#6

00005d94 <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    5d94:	42d8 0014 	mov	0x14 <__data_dp_size+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5d98:	7ada 0010 	lod	Y, #16
    5d9c:	7eda 72ef 	lod	X, #29423
    5da0:	5ef0      	mov	[Y], X
    5da2:	7eda e861 	lod	X, #59489
    5da6:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    5da8:	415a      	mov	dp:0x5a <_LIN_nad>, AL
    return ML_SUCCESS;
}
    5daa:	7000      	lod	A, #0
    5dac:	5401      	ret

00005dae <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    5dae:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5db0:	5cf2      	usex	A
}
    5db2:	5401      	ret

00005db4 <_linit>:
 * This function is called whenever an EVENT interrupt from the LIN task (Mlx4)
 * occurs
 */
void __interrupt__ ml_LinInterruptHandler(void);
__MLX_TEXT__  void ml_LinInterruptHandler(void)
{
    5db4:	52df      	push	A
    5db6:	5edf      	push	X
    5db8:	5adf      	push	Y
    5dba:	4c83      	push	D
    ml_GetLinEventData();
    5dbc:	16fa      	call	0x5bb2 <_ml_GetLinEventData>
    ml_ProccessLinEvent();
    5dbe:	1711      	call	0x5be2 <_ml_ProccessLinEvent>
    5dc0:	4cc3      	pop	D
    5dc2:	7acf      	pop	Y
    5dc4:	7ecf      	pop	X
    5dc6:	72cf      	pop	A
    5dc8:	4407      	mov	R, #0
    5dca:	72cb      	pop	M
    5dcc:	5401      	ret

00005dce <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    5dce:	82db 6606 	callf	0x6606 <_LDR_GetState>
    5dd2:	8c00      	cmp	AL, #0
    5dd4:	1d0a      	jne	0x5dea <_ml_InitLinModule+0x1c>
    5dd6:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    5dda:	aeda 3212 	cmp	A, #12818
    5dde:	1905      	je	0x5dea <_ml_InitLinModule+0x1c>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    5de0:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    5de4:	a410      	or	A, #16
    5de6:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5dea:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5dec:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5dee:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5df0:	b430      	and	A, #48
    5df2:	1902      	je	0x5df8 <_ml_InitLinModule+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5df4:	6000      	lod	AL, #0
    5df6:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    5df8:	6084      	lod	AL, #-124
    5dfa:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    5dfe:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5e02:	b404      	and	A, #4
    5e04:	197c      	je	0x5dfe <_ml_InitLinModule+0x30>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    5e06:	60ab      	lod	AL, #-85
    5e08:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    5e0c:	6000      	lod	AL, #0
    5e0e:	42d8 005e 	mov	0x5e <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    5e12:	72d8 0010 	lod	A, 0x10 <__data_dp_size>
    5e16:	7ad8 0012 	lod	Y, 0x12 <__data_dp_size+0x2>
    5e1a:	4cb2 72ef 	cmp	YA, #-396266769
    5e1e:	e861 
    5e20:	1d03      	jne	0x5e28 <_ml_InitLinModule+0x5a>
    {
        LIN_nad = stFixedRamNAD.nad;
    5e22:	62d8 0014 	lod	AL, 0x14 <__data_dp_size+0x4>
    5e26:	0001      	jmp	0x5e2a <_ml_InitLinModule+0x5c>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    5e28:	6001      	lod	AL, #1
    5e2a:	415a      	mov	dp:0x5a <_LIN_nad>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    5e2c:	7000      	lod	A, #0
    5e2e:	5401      	ret

00005e30 <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    5e30:	5801      	inc	S, #2
    5e32:	7ae2      	lod	Y, A
    5e34:	6205      	lod	AL, [S-6]
    5e36:	5cf2      	usex	A
    5e38:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    5e3a:	7ef0      	lod	X, [Y]
    5e3c:	2eda 067f 	cmp	X, #1663
    5e40:	1907      	je	0x5e50 <_ldr_isReadByIdMessage+0x20>
    5e42:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5e44:	b6da 06ff 	and	A, #1791
    5e48:	a6da 0600 	or	A, #1536
    5e4c:	2ee2      	cmp	X, A
    5e4e:	1d15      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e50:	72f2      	lod	A, [Y+2]
    5e52:	8cb2      	cmp	AL, #-78
    5e54:	1d12      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e56:	7ef4      	lod	X, [Y+4]
    5e58:	2c13      	cmp	X, #19
    5e5a:	1d04      	jne	0x5e64 <_ldr_isReadByIdMessage+0x34>
    5e5c:	72f6      	lod	A, [Y+6]
    5e5e:	aeda cafe 	cmp	A, #51966
    5e62:	1909      	je	0x5e76 <_ldr_isReadByIdMessage+0x46>
    5e64:	6201      	lod	AL, [S-2]
    5e66:	8c01      	cmp	AL, #1
    5e68:	1d08      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e6a:	2eda 7fff 	cmp	X, #32767
    5e6e:	1d05      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e70:	72f6      	lod	A, [Y+6]
    5e72:	acff      	cmp	A, #-1
    5e74:	1d02      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    5e76:	7001      	lod	A, #1
    5e78:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    5e7a:	7000      	lod	A, #0
    }
}
    5e7c:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    5e7e:	5801      	inc	S, #2
    5e80:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    5e82:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5e84:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    5e86:	6003      	lod	AL, #3
    5e88:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    5e8a:	607f      	lod	AL, #127
    5e8c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    5e8e:	13bb      	call	0x6606 <_LDR_GetState>
    5e90:	8480      	or	AL, #-128
    5e92:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    5e94:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5e96:	8601      	or	AL, [S-2]
    5e98:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    5e9a:	60ff      	lod	AL, #-1
    5e9c:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    5e9e:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
    LinFrameDataBuffer[7] = 0xFF;
    5ea0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    5ea2:	6000      	lod	AL, #0
    5ea4:	415f      	mov	dp:0x5f <_ml_driver_mode+0x1>, AL
    5ea6:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    5ea8:	5801      	inc	S, #2
    5eaa:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    5eac:	aeda 00f0 	cmp	A, #240
    5eb0:	1d02      	jne	0x5eb6 <_ldr_isReadByIdMessage+0x86>
    5eb2:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5eb4:	1904      	je	0x5ebe <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    5eb6:	72e6      	lod	A, Y
    5eb8:	17e2      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    5eba:	7000      	lod	A, #0
    5ebc:	000e      	jmp	0x5eda <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    5ebe:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5ec0:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    5ec2:	6002      	lod	AL, #2
    5ec4:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    5ec6:	60f4      	lod	AL, #-12
    5ec8:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    5eca:	139d      	call	0x6606 <_LDR_GetState>
    5ecc:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    5ece:	60ff      	lod	AL, #-1
    5ed0:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    5ed2:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    5ed4:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
        LinFrameDataBuffer[7] = 0xFF;
    5ed6:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
        blReturn = ML_TRUE;
    5ed8:	7001      	lod	A, #1
    5eda:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    5edc:	7000      	lod	A, #0
    5ede:	15dc      	call	0x5a98 <_ml_DataReady>

    return ( blReturn );
}
    5ee0:	7201      	lod	A, [S-2]
    5ee2:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    5ee4:	5807      	inc	S, #8
    5ee6:	660b      	lod	YL, [S-12]
    5ee8:	5cf6      	usex	Y
    5eea:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    5eec:	7966      	lod	Y, dp:0x66 <_ml_driver_mode+0x8>
    5eee:	e16e      	add	Y, dp:0x6e <_ml_driver_mode+0x10>
    5ef0:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    5ef2:	7ae2      	lod	Y, A
    5ef4:	e2da 0052 	add	Y, #82


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    5ef8:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    5efa:	5205      	mov	[S-6], A
    5efc:	72e6      	lod	A, Y
    5efe:	a001      	add	A, #1
    5f00:	5203      	mov	[S-4], A
    5f02:	20ff      	add	X, #-1
    5f04:	5e01      	mov	[S-2], X
    5f06:	7e05      	lod	X, [S-6]
    5f08:	2d6a      	cmp	X, dp:0x6a <_ml_driver_mode+0xc>
    5f0a:	1c04      	jnc	0x5f14 <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    5f0c:	7e07      	lod	X, [S-8]
    5f0e:	62de      	lod	AL, [X++]
    5f10:	5e07      	mov	[S-8], X
    5f12:	0001      	jmp	0x5f16 <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    5f14:	60ff      	lod	AL, #-1
    5f16:	42f0      	mov	[Y], AL
    5f18:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    5f1a:	7205      	lod	A, [S-6]
    5f1c:	a001      	add	A, #1
    5f1e:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    5f20:	7e01      	lod	X, [S-2]
    5f22:	1d6a      	jne	0x5ef8 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    5f24:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    5f26:	1802      	jc	0x5f2c <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    5f28:	7000      	lod	A, #0
    5f2a:	15e1      	call	0x5aee <_ml_ContFrame>
    5f2c:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    5f2e:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    5f30:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5f32:	1904      	je	0x5f3c <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5f34:	72da 00f0 	lod	A, #240
    5f38:	17a2      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5f3a:	0039      	jmp	0x5fae <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    5f3c:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    5f3e:	7ae2      	lod	Y, A
    5f40:	e002      	add	Y, #2
    5f42:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    5f44:	ac04      	cmp	A, #4
    5f46:	1a17      	jule	0x5f76 <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    5f48:	7001      	lod	A, #1
    5f4a:	15d1      	call	0x5aee <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    5f4c:	6000      	lod	AL, #0
    5f4e:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    5f50:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5f52:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    5f54:	7201      	lod	A, [S-2]
    5f56:	b6da 0f00 	and	A, #3840
    5f5a:	6000      	lod	AL, #0
    5f5c:	72e4      	swap	A
    5f5e:	8410      	or	AL, #16
    5f60:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    5f62:	6601      	lod	YL, [S-2]
    5f64:	4554      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    5f66:	60f4      	lod	AL, #-12
    5f68:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    5f6a:	134d      	call	0x6606 <_LDR_GetState>
    5f6c:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    5f6e:	54ca 0003 	pushw	#3
    5f72:	7005      	lod	A, #5
    5f74:	001a      	jmp	0x5faa <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    5f76:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5f78:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    5f7a:	6201      	lod	AL, [S-2]
    5f7c:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    5f7e:	60f4      	lod	AL, #-12
    5f80:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    5f82:	1341      	call	0x6606 <_LDR_GetState>
    5f84:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    5f86:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    5f88:	aeda bf66 	cmp	A, #48998
    5f8c:	1d0b      	jne	0x5fa4 <_ldr_isReadByIdMessage+0x174>
    5f8e:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    5f90:	ac02      	cmp	A, #2
    5f92:	1d08      	jne	0x5fa4 <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    5f94:	1338      	call	0x6606 <_LDR_GetState>
    5f96:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    5f98:	6400      	lod	YL, #0
    5f9a:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    5f9c:	60ff      	lod	AL, #-1
    5f9e:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    5fa0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    5fa2:	0005      	jmp	0x5fae <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    5fa4:	54ca 0004 	pushw	#4
    5fa8:	7004      	lod	A, #4
    5faa:	179c      	call	0x5ee4 <_ldr_isReadByIdMessage+0xb4>
    5fac:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    5fae:	7000      	lod	A, #0
    5fb0:	1573      	call	0x5a98 <_ml_DataReady>
    5fb2:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    5fb4:	5801      	inc	S, #2
    5fb6:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    5fb8:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5fba:	1904      	je	0x5fc4 <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5fbc:	72da 00f0 	lod	A, #240
    5fc0:	175e      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5fc2:	000f      	jmp	0x5fe2 <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    5fc4:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5fc6:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    5fc8:	6006      	lod	AL, #6
    5fca:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    5fcc:	60f4      	lod	AL, #-12
    5fce:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    5fd0:	131a      	call	0x6606 <_LDR_GetState>
    5fd2:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    5fd4:	796a      	lod	Y, dp:0x6a <_ml_driver_mode+0xc>
    5fd6:	4d56      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    5fd8:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    5fda:	7201      	lod	A, [S-2]
    5fdc:	4958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    5fde:	6201      	lod	AL, [S-2]
    5fe0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    5fe2:	7000      	lod	A, #0
    5fe4:	1559      	call	0x5a98 <_ml_DataReady>
    5fe6:	5403      	ret	#4

00005fe8 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    5fe8:	ac0a      	cmp	A, #10
    5fea:	1901      	je	0x5fee <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    5fec:	415f      	mov	dp:0x5f <_ml_driver_mode+0x1>, AL
    5fee:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    5ff0:	5807      	inc	S, #8
    5ff2:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    5ff4:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5ff6:	1904      	je	0x6000 <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5ff8:	72da 00f0 	lod	A, #240
    5ffc:	1740      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5ffe:	0040      	jmp	0x6080 <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    6000:	15cc      	call	0x5b9a <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    6002:	7966      	lod	Y, dp:0x66 <_ml_driver_mode+0x8>
    6004:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    6006:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    6008:	7000      	lod	A, #0
    600a:	5201      	mov	[S-2], A
    600c:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    600e:	5203      	mov	[S-4], A
    6010:	7000      	lod	A, #0
    6012:	ae03      	cmp	A, [S-4]
    6014:	1c26      	jnc	0x6062 <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    6016:	7ae8      	swap	Y
        crc ^= *data;
    6018:	7e05      	lod	X, [S-6]
    601a:	62de      	lod	AL, [X++]
    601c:	5e05      	mov	[S-6], X
    601e:	5cf2      	usex	A
    6020:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    6022:	62e8      	lod	AL, YL
    6024:	44b0      	lsr	AL, #2
    6026:	44b0      	lsr	AL, #2
    6028:	5cf2      	usex	A
    602a:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    602c:	72e6      	lod	A, Y
    602e:	b40f      	and	A, #15
    6030:	44d2      	rr	A, #2
    6032:	44d2      	rr	A, #2
    6034:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    6036:	72e6      	lod	A, Y
    6038:	b6da 00ff 	and	A, #255
    603c:	44a2      	asl	A, #2
    603e:	44a2      	asl	A, #2
    6040:	4422      	asl	A
    6042:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    6044:	7201      	lod	A, [S-2]
    6046:	b6da 0fff 	and	A, #4095
    604a:	1d07      	jne	0x605a <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    604c:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    604e:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6050:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6052:	b430      	and	A, #48
    6054:	1902      	je	0x605a <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6056:	6000      	lod	AL, #0
    6058:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    605a:	7201      	lod	A, [S-2]
    605c:	a001      	add	A, #1
    605e:	5201      	mov	[S-2], A
    6060:	07d8      	jmp	0x6012 <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    6062:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6064:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    6066:	6006      	lod	AL, #6
    6068:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    606a:	60f4      	lod	AL, #-12
    606c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    606e:	60ff      	lod	AL, #-1
    6070:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    6072:	4d56      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    6074:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    6076:	7207      	lod	A, [S-8]
    6078:	4958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    607a:	6607      	lod	YL, [S-8]
    607c:	4559      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    607e:	158b      	call	0x5b96 <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    6080:	7000      	lod	A, #0
    6082:	150a      	call	0x5a98 <_ml_DataReady>
    6084:	5409      	ret	#10

00006086 <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    6086:	5801      	inc	S, #2
    6088:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    608a:	12bd      	call	0x6606 <_LDR_GetState>
    608c:	8c00      	cmp	AL, #0
    608e:	1d09      	jne	0x60a2 <_ml_ldr_SwitchToProgMode+0x1c>
    6090:	82db 781c 	callf	0x781c <_mlu_ApplicationStop>
    6094:	8c00      	cmp	AL, #0
    6096:	1905      	je	0x60a2 <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    6098:	6000      	lod	AL, #0
    609a:	415e      	mov	dp:0x5e <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    609c:	7000      	lod	A, #0
    609e:	14f7      	call	0x5a8e <_ml_ReleaseBufferProg>
    60a0:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    60a2:	7000      	lod	A, #0
    60a4:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    60a8:	12ae      	call	0x6606 <_LDR_GetState>
    60aa:	8c00      	cmp	AL, #0
    60ac:	1d0b      	jne	0x60c4 <_ml_ldr_SwitchToProgMode+0x3e>
    60ae:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    60b2:	aeda 3212 	cmp	A, #12818
    60b6:	1906      	je	0x60c4 <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    60b8:	14e1      	call	0x5a7c <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    60ba:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    60be:	a410      	or	A, #16
    60c0:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    60c4:	6055      	lod	AL, #85
    60c6:	415e      	mov	dp:0x5e <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    60c8:	6000      	lod	AL, #0
    60ca:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    60cc:	12a7      	call	0x661c <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    60ce:	7001      	lod	A, #1
    60d0:	14de      	call	0x5a8e <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    60d2:	6201      	lod	AL, [S-2]
    60d4:	8c01      	cmp	AL, #1
    60d6:	1d0b      	jne	0x60ee <_ml_ldr_SwitchToProgMode+0x68>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    60d8:	72da 3212 	lod	A, #12818
    60dc:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    60e0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    60e4:	94fe      	and	AL, #-2
    60e6:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    60ea:	1414      	call	0x5914 <_MLX16_RESET>
            for (;;) {
    60ec:	07ff      	jmp	0x60ec <_ml_ldr_SwitchToProgMode+0x66>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    60ee:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    60f0:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    60f2:	6006      	lod	AL, #6
    60f4:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    60f6:	60f2      	lod	AL, #-14
    60f8:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    60fa:	4cea 0004 	movu	YA, #4
    60fe:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    6100:	4cea 0401 	movu	YA, #1025
    6104:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    6106:	6000      	lod	AL, #0
    6108:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    610a:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    610c:	127c      	call	0x6606 <_LDR_GetState>
    610e:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6110:	7000      	lod	A, #0
    6112:	14c2      	call	0x5a98 <_ml_DataReady>
    6114:	5403      	ret	#4

00006116 <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    6116:	8c33      	cmp	AL, #51
    6118:	1d03      	jne	0x6120 <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    611a:	7001      	lod	A, #1
    611c:	17b4      	call	0x6086 <_ml_ldr_SwitchToProgMode>
    611e:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    6120:	ac00      	cmp	A, #0
    6122:	1d14      	jne	0x614c <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    6124:	7001      	lod	A, #1
    6126:	14b3      	call	0x5a8e <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    6128:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    612a:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    612c:	6006      	lod	AL, #6
    612e:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6130:	60f2      	lod	AL, #-14
    6132:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    6134:	6013      	lod	AL, #19
    6136:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    6138:	6000      	lod	AL, #0
    613a:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    613c:	60fe      	lod	AL, #-2
    613e:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    6140:	60ca      	lod	AL, #-54
    6142:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    6144:	6001      	lod	AL, #1
    6146:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6148:	7000      	lod	A, #0
    614a:	14a6      	call	0x5a98 <_ml_DataReady>
    614c:	5401      	ret

0000614e <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    614e:	6171      	lod	AL, dp:0x71 <_ml_driver_mode+0x13>
    6150:	8c03      	cmp	AL, #3
    6152:	1d15      	jne	0x617e <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    6154:	7000      	lod	A, #0
    6156:	14cb      	call	0x5aee <_ml_ContFrame>
            (void)ml_Disconnect();
    6158:	1520      	call	0x5b9a <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    615a:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    615c:	5cf2      	usex	A
    615e:	1377      	call	0x684e <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6160:	54ca 0000 	pushw	#0
    6164:	54ca 0001 	pushw	#1
    6168:	54ca 0000 	pushw	#0
    616c:	7001      	lod	A, #1
    616e:	14b2      	call	0x5ad4 <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    6170:	7001      	lod	A, #1
    6172:	14ac      	call	0x5acc <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    6174:	1514      	call	0x5b9e <_ml_SwitchToFast>
            pendingAction = 0;
    6176:	6000      	lod	AL, #0
    6178:	4171      	mov	dp:0x71 <_ml_driver_mode+0x13>, AL
            break;
    617a:	5c05      	dec	S, #6
    617c:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    617e:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    6180:	8c06      	cmp	AL, #6
    6182:	1902      	je	0x6188 <_ml_DiagRequest+0x3a>
    6184:	8c08      	cmp	AL, #8
    6186:	1d14      	jne	0x61b0 <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    6188:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    618a:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    618c:	1c11      	jnc	0x61b0 <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    618e:	6170      	lod	AL, dp:0x70 <_ml_driver_mode+0x12>
    6190:	8001      	add	AL, #1
    6192:	66e0      	lod	YL, AL
    6194:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    6196:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6198:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    619a:	62e8      	lod	AL, YL
    619c:	940f      	and	AL, #15
    619e:	8420      	or	AL, #32
    61a0:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    61a2:	54ca 0006 	pushw	#6
    61a6:	7002      	lod	A, #2
    61a8:	169d      	call	0x5ee4 <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    61aa:	7000      	lod	A, #0
    61ac:	1475      	call	0x5a98 <_ml_DataReady>
    61ae:	5c01      	dec	S, #2
    61b0:	5401      	ret

000061b2 <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    61b2:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    61b4:	6153      	lod	AL, dp:0x53 <_LinFrameDataBuffer+0x1>
    61b6:	5cf2      	usex	A
    61b8:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    61ba:	b6da 00f0 	and	A, #240
    61be:	ac20      	cmp	A, #32
    61c0:	1901      	je	0x61c4 <_ml_DiagReceived+0x12>
    61c2:	0073      	jmp	0x62aa <_ml_DiagReceived+0xf8>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    61c4:	7a0b      	lod	Y, [S-12]
    61c6:	f40f      	and	Y, #15
    61c8:	6170      	lod	AL, dp:0x70 <_ml_driver_mode+0x12>
    61ca:	4209      	mov	[S-10], AL
    61cc:	b40f      	and	A, #15
    61ce:	eee2      	cmp	Y, A
    61d0:	1901      	je	0x61d4 <_ml_DiagReceived+0x22>
    61d2:	0067      	jmp	0x62a2 <_ml_DiagReceived+0xf0>
                ddFrameCounter += 1;
    61d4:	6209      	lod	AL, [S-10]
    61d6:	8001      	add	AL, #1
    61d8:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    61da:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    61dc:	8c85      	cmp	AL, #-123
    61de:	1901      	je	0x61e2 <_ml_DiagReceived+0x30>
    61e0:	003d      	jmp	0x625c <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    61e2:	7800      	lod	Y, #0
    61e4:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    61e6:	796e      	lod	Y, dp:0x6e <_ml_driver_mode+0x10>
    61e8:	ed6a      	cmp	Y, dp:0x6a <_ml_driver_mode+0xc>
    61ea:	1c0a      	jnc	0x6200 <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    61ec:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    61ee:	a2e6      	add	A, Y
    61f0:	7a0d      	lod	Y, [S-14]
    61f2:	e2da 0054 	add	Y, #84
    61f6:	66f0      	lod	YL, [Y]
    61f8:	5cf6      	usex	Y
    61fa:	5adf      	push	Y
    61fc:	1246      	call	0x668a <_Flash_PageBufferFill>
    61fe:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6200:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6202:	a001      	add	A, #1
    6204:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6206:	7a0d      	lod	Y, [S-14]
    6208:	e001      	add	Y, #1
    620a:	5a0d      	mov	[S-14], Y
    620c:	ec05      	cmp	Y, #5
    620e:	1a6b      	jule	0x61e6 <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6210:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    6212:	1c01      	jnc	0x6216 <_ml_DiagReceived+0x64>
    6214:	01f7      	jmp	0x6604 <_ml_DiagReceived+0x452>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    6216:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6218:	1308      	call	0x682a <_Flash_PageWriteFiltered>
    621a:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    621c:	ac00      	cmp	A, #0
    621e:	1901      	je	0x6222 <_ml_DiagReceived+0x70>
    6220:	0042      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    6222:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6224:	796c      	lod	Y, dp:0x6c <_ml_driver_mode+0xe>
    6226:	aee6      	cmp	A, Y
    6228:	1c15      	jnc	0x6254 <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    622a:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    622c:	7ee2      	lod	X, A
    622e:	22da 0080 	add	X, #128
    6232:	5d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    6234:	7000      	lod	A, #0
    6236:	5168      	mov	dp:0x68 <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    6238:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    623a:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    623c:	eeda 0080 	cmp	Y, #128
    6240:	1a03      	jule	0x6248 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    6242:	72da 0080 	lod	A, #128
    6246:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    6248:	72e6      	lod	A, Y
    624a:	a96a      	sub	A, dp:0x6a <_ml_driver_mode+0xc>
    624c:	516c      	mov	dp:0x6c <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    624e:	72ee      	lod	A, X
    6250:	120d      	call	0x666c <_Flash_PageRead>
    6252:	0029      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    6254:	7800      	lod	Y, #0
    6256:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    6258:	596c      	mov	dp:0x6c <_ml_driver_mode+0xe>, Y
    625a:	0025      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    625c:	8c47      	cmp	AL, #71
    625e:	1d23      	jne	0x62a6 <_ml_DiagReceived+0xf4>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6260:	7000      	lod	A, #0
    6262:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    6264:	796e      	lod	Y, dp:0x6e <_ml_driver_mode+0x10>
    6266:	ed6a      	cmp	Y, dp:0x6a <_ml_driver_mode+0xc>
    6268:	1c0b      	jnc	0x6280 <_ml_DiagReceived+0xce>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    626a:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    626c:	a2e6      	add	A, Y
    626e:	7a0d      	lod	Y, [S-14]
    6270:	e2da 0054 	add	Y, #84
    6274:	66f0      	lod	YL, [Y]
    6276:	5cf6      	usex	Y
    6278:	5adf      	push	Y
    627a:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
    627e:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6280:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6282:	a001      	add	A, #1
    6284:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6286:	7a0d      	lod	Y, [S-14]
    6288:	e001      	add	Y, #1
    628a:	5a0d      	mov	[S-14], Y
    628c:	ec05      	cmp	Y, #5
    628e:	1a6a      	jule	0x6264 <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6290:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    6292:	1c01      	jnc	0x6296 <_ml_DiagReceived+0xe4>
    6294:	01b7      	jmp	0x6604 <_ml_DiagReceived+0x452>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    6296:	82db 5a7c 	callf	0x5a7c <_NVRAM_SaveAll>
                        ddDataSize = 0;
    629a:	7000      	lod	A, #0
    629c:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    629e:	1427      	call	0x5aee <_ml_ContFrame>
    62a0:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    62a2:	6400      	lod	YL, #0
    62a4:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    62a6:	7000      	lod	A, #0
    62a8:	07fa      	jmp	0x629e <_ml_DiagReceived+0xec>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    62aa:	ac10      	cmp	A, #16
    62ac:	1901      	je	0x62b0 <_ml_DiagReceived+0xfe>
    62ae:	0041      	jmp	0x6332 <_ml_DiagReceived+0x180>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    62b0:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    62b2:	8cb4      	cmp	AL, #-76
    62b4:	1901      	je	0x62b8 <_ml_DiagReceived+0x106>
    62b6:	01a0      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    62b8:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    62ba:	8cd3      	cmp	AL, #-45
    62bc:	1901      	je	0x62c0 <_ml_DiagReceived+0x10e>
    62be:	019c      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    62c0:	6001      	lod	AL, #1
    62c2:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    62c4:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    62c6:	8c85      	cmp	AL, #-123
    62c8:	1d14      	jne	0x62f2 <_ml_DiagReceived+0x140>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    62ca:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    62cc:	5cf2      	usex	A
    62ce:	52df      	push	A
    62d0:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62d2:	11db      	call	0x668a <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    62d4:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62d6:	a001      	add	A, #1
    62d8:	6558      	lod	YL, dp:0x58 <_LinFrameDataBuffer+0x6>
    62da:	5cf6      	usex	Y
    62dc:	5adf      	push	Y
    62de:	11d5      	call	0x668a <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    62e0:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62e2:	a002      	add	A, #2
    62e4:	6559      	lod	YL, dp:0x59 <_LinFrameDataBuffer+0x7>
    62e6:	5cf6      	usex	Y
    62e8:	5adf      	push	Y
    62ea:	11cf      	call	0x668a <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    62ec:	7003      	lod	A, #3
    62ee:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    62f0:	0018      	jmp	0x6322 <_ml_DiagReceived+0x170>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    62f2:	8c47      	cmp	AL, #71
    62f4:	1d1b      	jne	0x632c <_ml_DiagReceived+0x17a>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    62f6:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    62f8:	5cf2      	usex	A
    62fa:	52df      	push	A
    62fc:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    62fe:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    6302:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6304:	a001      	add	A, #1
    6306:	6558      	lod	YL, dp:0x58 <_LinFrameDataBuffer+0x6>
    6308:	5cf6      	usex	Y
    630a:	5adf      	push	Y
    630c:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    6310:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6312:	a002      	add	A, #2
    6314:	6559      	lod	YL, dp:0x59 <_LinFrameDataBuffer+0x7>
    6316:	5cf6      	usex	Y
    6318:	5adf      	push	Y
    631a:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    631e:	7803      	lod	Y, #3
    6320:	596e      	mov	dp:0x6e <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    6322:	7001      	lod	A, #1
    6324:	82db 5aee 	callf	0x5aee <_ml_ContFrame>
    6328:	5c05      	dec	S, #6
    632a:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    632c:	7020      	lod	A, #32
    632e:	15bc      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
    6330:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    6332:	620b      	lod	AL, [S-12]
    6334:	94f0      	and	AL, #-16
    6336:	1901      	je	0x633a <_ml_DiagReceived+0x188>
    6338:	0162      	jmp	0x65fe <_ml_DiagReceived+0x44c>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    633a:	7000      	lod	A, #0
    633c:	82db 5aee 	callf	0x5aee <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    6340:	720b      	lod	A, [S-12]
    6342:	b40f      	and	A, #15
    6344:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    6346:	6154      	lod	AL, dp:0x54 <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    6348:	8cb4      	cmp	AL, #-76
    634a:	190d      	je	0x6366 <_ml_DiagReceived+0x1b4>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    634c:	54ca 0001 	pushw	#1
    6350:	72da 0052 	lod	A, #82
    6354:	156d      	call	0x5e30 <_ldr_isReadByIdMessage>
    6356:	5c01      	dec	S, #2
    6358:	8c00      	cmp	AL, #0
    635a:	1d01      	jne	0x635e <_ml_DiagReceived+0x1ac>
    635c:	014d      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                ml_ldr_ReadByIdMessage(Data[0]);
    635e:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    6360:	5cf2      	usex	A
    6362:	16d9      	call	0x6116 <_ml_ldr_ReadByIdMessage>
    6364:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    6366:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    6368:	4207      	mov	[S-8], AL
    636a:	8cd3      	cmp	AL, #-45
    636c:	190a      	je	0x6382 <_ml_DiagReceived+0x1d0>
    636e:	8c80      	cmp	AL, #-128
    6370:	1908      	je	0x6382 <_ml_DiagReceived+0x1d0>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    6372:	6956      	lod	AH, dp:0x56 <_LinFrameDataBuffer+0x4>
    6374:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    6376:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    6378:	6958      	lod	AH, dp:0x58 <_LinFrameDataBuffer+0x6>
    637a:	6159      	lod	AL, dp:0x59 <_LinFrameDataBuffer+0x7>
    637c:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    637e:	7800      	lod	Y, #0
    6380:	596e      	mov	dp:0x6e <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    6382:	6607      	lod	YL, [S-8]
    6384:	5cf6      	usex	Y
    6386:	72e6      	lod	A, Y
    6388:	b420      	and	A, #32
    638a:	1929      	je	0x63de <_ml_DiagReceived+0x22c>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    638c:	72e6      	lod	A, Y
    638e:	b430      	and	A, #48
    6390:	ac20      	cmp	A, #32
    6392:	1d18      	jne	0x63c4 <_ml_DiagReceived+0x212>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    6394:	6085      	lod	AL, #-123
    6396:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    6398:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    639a:	7ae2      	lod	Y, A
    639c:	f47f      	and	Y, #127
    639e:	5968      	mov	dp:0x68 <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    63a0:	b480      	and	A, #-128
    63a2:	5205      	mov	[S-6], A
    63a4:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    63a6:	7d6a      	lod	X, dp:0x6a <_ml_driver_mode+0xc>
    63a8:	5d6c      	mov	dp:0x6c <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    63aa:	72da 0080 	lod	A, #128
    63ae:	aae6      	sub	A, Y
    63b0:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    63b2:	aeee      	cmp	A, X
    63b4:	1a01      	jule	0x63b8 <_ml_DiagReceived+0x206>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    63b6:	5d6a      	mov	dp:0x6a <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    63b8:	7205      	lod	A, [S-6]
    63ba:	1148      	call	0x664c <_Flash_GetWriteTime>
    63bc:	15fb      	call	0x5fb4 <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    63be:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    63c0:	1155      	call	0x666c <_Flash_PageRead>
    63c2:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    63c4:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    63c6:	8cd6      	cmp	AL, #-42
    63c8:	1901      	je	0x63cc <_ml_DiagReceived+0x21a>
    63ca:	0087      	jmp	0x64da <_ml_DiagReceived+0x328>
    63cc:	6161      	lod	AL, dp:0x61 <_ml_driver_mode+0x3>
    63ce:	1901      	je	0x63d2 <_ml_DiagReceived+0x220>
    63d0:	0084      	jmp	0x64da <_ml_DiagReceived+0x328>
    63d2:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    63d4:	8c01      	cmp	AL, #1
    63d6:	1901      	je	0x63da <_ml_DiagReceived+0x228>
    63d8:	0080      	jmp	0x64da <_ml_DiagReceived+0x328>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    63da:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    63dc:	0106      	jmp	0x65ea <_ml_DiagReceived+0x438>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    63de:	eeda 0080 	cmp	Y, #128
    63e2:	1d01      	jne	0x63e6 <_ml_DiagReceived+0x234>
    63e4:	002d      	jmp	0x6440 <_ml_DiagReceived+0x28e>
    63e6:	1f0c      	jsg	0x6400 <_ml_DiagReceived+0x24e>
    63e8:	ec08      	cmp	Y, #8
    63ea:	1d01      	jne	0x63ee <_ml_DiagReceived+0x23c>
    63ec:	0065      	jmp	0x64b8 <_ml_DiagReceived+0x306>
    63ee:	1f04      	jsg	0x63f8 <_ml_DiagReceived+0x246>
    63f0:	ec03      	cmp	Y, #3
    63f2:	1d01      	jne	0x63f6 <_ml_DiagReceived+0x244>
    63f4:	0039      	jmp	0x6468 <_ml_DiagReceived+0x2b6>
    63f6:	0100      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    63f8:	ec47      	cmp	Y, #71
    63fa:	1d01      	jne	0x63fe <_ml_DiagReceived+0x24c>
    63fc:	0059      	jmp	0x64b0 <_ml_DiagReceived+0x2fe>
    63fe:	00fc      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    6400:	eeda 00c1 	cmp	Y, #193
    6404:	190f      	je	0x6424 <_ml_DiagReceived+0x272>
    6406:	1f05      	jsg	0x6412 <_ml_DiagReceived+0x260>
    6408:	eeda 0092 	cmp	Y, #146
    640c:	1d01      	jne	0x6410 <_ml_DiagReceived+0x25e>
    640e:	0059      	jmp	0x64c2 <_ml_DiagReceived+0x310>
    6410:	00f3      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    6412:	eeda 00d3 	cmp	Y, #211
    6416:	1d01      	jne	0x641a <_ml_DiagReceived+0x268>
    6418:	0063      	jmp	0x64e0 <_ml_DiagReceived+0x32e>
    641a:	eeda 00d6 	cmp	Y, #214
    641e:	1d01      	jne	0x6422 <_ml_DiagReceived+0x270>
    6420:	00c6      	jmp	0x65ae <_ml_DiagReceived+0x3fc>
    6422:	00ea      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    6424:	10f0      	call	0x6606 <_LDR_GetState>
    6426:	66e0      	lod	YL, AL
    6428:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    642a:	8ee8      	cmp	AL, YL
    642c:	1d01      	jne	0x6430 <_ml_DiagReceived+0x27e>
    642e:	00ea      	jmp	0x6604 <_ml_DiagReceived+0x452>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    6430:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6434:	94fe      	and	AL, #-2
    6436:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    643a:	82db 5914 	callf	0x5914 <_MLX16_RESET>
                            }
                            break;
    643e:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    6440:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    6442:	8c85      	cmp	AL, #-123
    6444:	1d09      	jne	0x6458 <_ml_DiagReceived+0x2a6>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    6446:	7164      	lod	A, dp:0x64 <_ml_driver_mode+0x6>
    6448:	1d05      	jne	0x6454 <_ml_DiagReceived+0x2a2>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    644a:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    644c:	1901      	je	0x6450 <_ml_DiagReceived+0x29e>
    644e:	076e      	jmp	0x632c <_ml_DiagReceived+0x17a>
                                        ddCurrentOp = 0;            /* operation done */
    6450:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    6452:	0007      	jmp	0x6462 <_ml_DiagReceived+0x2b0>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    6454:	7050      	lod	A, #80
    6456:	076b      	jmp	0x632e <_ml_DiagReceived+0x17c>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6458:	8c47      	cmp	AL, #71
    645a:	1901      	je	0x645e <_ml_DiagReceived+0x2ac>
    645c:	00b6      	jmp	0x65ca <_ml_DiagReceived+0x418>
                                ddCurrentOp = 0;                /* operation done */
    645e:	6400      	lod	YL, #0
    6460:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    6462:	7000      	lod	A, #0
    6464:	15a7      	call	0x5fb4 <_ldr_isReadByIdMessage+0x184>
    6466:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    6468:	620b      	lod	AL, [S-12]
    646a:	8c03      	cmp	AL, #3
    646c:	1d08      	jne	0x647e <_ml_DiagReceived+0x2cc>
                                peCurrentValue = Data[1];
    646e:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    6470:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    6472:	8c64      	cmp	AL, #100
    6474:	1e04      	jug	0x647e <_ml_DiagReceived+0x2cc>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    6476:	8c12      	cmp	AL, #18
    6478:	1e04      	jug	0x6482 <_ml_DiagReceived+0x2d0>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    647a:	6013      	lod	AL, #19
    647c:	0001      	jmp	0x6480 <_ml_DiagReceived+0x2ce>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    647e:	6064      	lod	AL, #100
    6480:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    6482:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6484:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    6486:	6403      	lod	YL, #3
    6488:	4553      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    648a:	60f4      	lod	AL, #-12
    648c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    648e:	10bb      	call	0x6606 <_LDR_GetState>
    6490:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    6492:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    6494:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    6496:	60ff      	lod	AL, #-1
    6498:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    649a:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    649c:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    649e:	7000      	lod	A, #0
    64a0:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    64a4:	7001      	lod	A, #1
    64a6:	82db 5aee 	callf	0x5aee <_ml_ContFrame>
                            pendingAction = ddFastProt;
    64aa:	6003      	lod	AL, #3
    64ac:	4171      	mov	dp:0x71 <_ml_driver_mode+0x13>, AL
                            break;
    64ae:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    64b0:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64b2:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
    64b6:	07d5      	jmp	0x6462 <_ml_DiagReceived+0x2b0>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    64b8:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64ba:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    64be:	1537      	call	0x5f2e <_ldr_isReadByIdMessage+0xfe>
                            break;
    64c0:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    64c2:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    64c4:	6000      	lod	AL, #0
    64c6:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    64c8:	ac08      	cmp	A, #8
    64ca:	1902      	je	0x64d0 <_ml_DiagReceived+0x31e>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    64cc:	7010      	lod	A, #16
    64ce:	072f      	jmp	0x632e <_ml_DiagReceived+0x17c>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    64d0:	7801      	lod	Y, #1
    64d2:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    64d4:	72da 6bac 	lod	A, #27564
    64d8:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    64da:	6006      	lod	AL, #6
    64dc:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    64de:	07ef      	jmp	0x64be <_ml_DiagReceived+0x30c>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    64e0:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    64e2:	8c85      	cmp	AL, #-123
    64e4:	1901      	je	0x64e8 <_ml_DiagReceived+0x336>
    64e6:	0042      	jmp	0x656c <_ml_DiagReceived+0x3ba>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    64e8:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    64ea:	a168      	add	A, dp:0x68 <_ml_driver_mode+0xa>
    64ec:	aeda bf66 	cmp	A, #48998
    64f0:	1d24      	jne	0x653a <_ml_DiagReceived+0x388>
    64f2:	716c      	lod	A, dp:0x6c <_ml_driver_mode+0xe>
    64f4:	ac02      	cmp	A, #2
    64f6:	1d21      	jne	0x653a <_ml_DiagReceived+0x388>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    64f8:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    64fa:	5cf2      	usex	A

                                    switch (new_state) {
    64fc:	1903      	je	0x6504 <_ml_DiagReceived+0x352>
    64fe:	ac01      	cmp	A, #1
    6500:	190d      	je	0x651c <_ml_DiagReceived+0x36a>
    6502:	0051      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    6504:	72da be84 	lod	A, #48772
    6508:	10b1      	call	0x666c <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    650a:	72da be84 	lod	A, #48772
    650e:	b47f      	and	A, #127
    6510:	54ca 0001 	pushw	#1
    6514:	10ba      	call	0x668a <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    6516:	72da be84 	lod	A, #48772
    651a:	000b      	jmp	0x6532 <_ml_DiagReceived+0x380>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    651c:	72da be80 	lod	A, #48768
    6520:	10a5      	call	0x666c <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    6522:	72da be80 	lod	A, #48768
    6526:	b47f      	and	A, #127
    6528:	54ca 0001 	pushw	#1
    652c:	10ae      	call	0x668a <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    652e:	72da be80 	lod	A, #48768
    6532:	10c3      	call	0x66ba <_Flash_PageWrite>
    6534:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    6536:	5c01      	dec	S, #2
    6538:	0036      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    653a:	7800      	lod	Y, #0
    653c:	5a0d      	mov	[S-14], Y
    653e:	20fe      	add	X, #-2
    6540:	5e03      	mov	[S-4], X
    6542:	eeee      	cmp	Y, X
    6544:	1c0f      	jnc	0x6564 <_ml_DiagReceived+0x3b2>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    6546:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    6548:	a20d      	add	A, [S-14]
    654a:	7a0d      	lod	Y, [S-14]
    654c:	e2da 0056 	add	Y, #86
    6550:	66f0      	lod	YL, [Y]
    6552:	5cf6      	usex	Y
    6554:	5adf      	push	Y
    6556:	1099      	call	0x668a <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6558:	5c01      	dec	S, #2
    655a:	720d      	lod	A, [S-14]
    655c:	a001      	add	A, #1
    655e:	520d      	mov	[S-14], A
    6560:	ae03      	cmp	A, [S-4]
    6562:	1871      	jc	0x6546 <_ml_DiagReceived+0x394>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    6564:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6566:	1161      	call	0x682a <_Flash_PageWriteFiltered>
    6568:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
    656a:	001d      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    656c:	8c47      	cmp	AL, #71
    656e:	1d19      	jne	0x65a2 <_ml_DiagReceived+0x3f0>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6570:	7800      	lod	Y, #0
    6572:	5a0d      	mov	[S-14], Y
    6574:	20fe      	add	X, #-2
    6576:	5e01      	mov	[S-2], X
    6578:	eeee      	cmp	Y, X
    657a:	1c10      	jnc	0x659c <_ml_DiagReceived+0x3ea>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    657c:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    657e:	a20d      	add	A, [S-14]
    6580:	7a0d      	lod	Y, [S-14]
    6582:	e2da 0056 	add	Y, #86
    6586:	66f0      	lod	YL, [Y]
    6588:	5cf6      	usex	Y
    658a:	5adf      	push	Y
    658c:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6590:	5c01      	dec	S, #2
    6592:	720d      	lod	A, [S-14]
    6594:	a001      	add	A, #1
    6596:	520d      	mov	[S-14], A
    6598:	ae01      	cmp	A, [S-2]
    659a:	1870      	jc	0x657c <_ml_DiagReceived+0x3ca>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    659c:	82db 5a7c 	callf	0x5a7c <_NVRAM_SaveAll>
    65a0:	0002      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    65a2:	7020      	lod	A, #32
    65a4:	1481      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    65a6:	7800      	lod	Y, #0
    65a8:	596c      	mov	dp:0x6c <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    65aa:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    65ac:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    65ae:	60d6      	lod	AL, #-42
    65b0:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    65b2:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    65b4:	4161      	mov	dp:0x61 <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    65b6:	1d0c      	jne	0x65d0 <_ml_DiagReceived+0x41e>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65b8:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    65ba:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65bc:	5cf2      	usex	A
    65be:	1903      	je	0x65c6 <_ml_DiagReceived+0x414>
    65c0:	ac01      	cmp	A, #1
    65c2:	1903      	je	0x65ca <_ml_DiagReceived+0x418>
    65c4:	0017      	jmp	0x65f4 <_ml_DiagReceived+0x442>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    65c6:	6000      	lod	AL, #0
    65c8:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    65ca:	72da 00f0 	lod	A, #240
    65ce:	06af      	jmp	0x632e <_ml_DiagReceived+0x17c>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    65d0:	8c01      	cmp	AL, #1
    65d2:	1d10      	jne	0x65f4 <_ml_DiagReceived+0x442>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65d4:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    65d6:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65d8:	1d0a      	jne	0x65ee <_ml_DiagReceived+0x43c>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    65da:	6158      	lod	AL, dp:0x58 <_LinFrameDataBuffer+0x6>
    65dc:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    65de:	1101      	call	0x67e2 <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    65e0:	7ada 4000 	lod	Y, #16384
    65e4:	5966      	mov	dp:0x66 <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    65e6:	7800      	lod	Y, #0
    65e8:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    65ea:	1502      	call	0x5ff0 <_ml_ldr_ErrorDetected+0x8>
                                    break;
    65ec:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    65ee:	6000      	lod	AL, #0
    65f0:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    65f2:	0002      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    65f4:	6400      	lod	YL, #0
    65f6:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    65f8:	72da 00d0 	lod	A, #208
    65fc:	0698      	jmp	0x632e <_ml_DiagReceived+0x17c>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    65fe:	72da 00b0 	lod	A, #176
    6602:	1452      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
    6604:	540f      	ret	#16

00006606 <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    6606:	7ada be80 	lod	Y, #48768
    660a:	62f0      	lod	AL, [Y]
    660c:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    6610:	66e0      	lod	YL, AL
    6612:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    6616:	a2e6      	add	A, Y
    6618:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    661a:	5401      	ret

0000661c <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    661c:	17f4      	call	0x6606 <_LDR_GetState>
    661e:	8c03      	cmp	AL, #3
    6620:	1d03      	jne	0x6628 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    6622:	72da 8000 	lod	A, #32768
    6626:	0001      	jmp	0x662a <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    6628:	7000      	lod	A, #0
    662a:	52d8 019c 	mov	0x19c <_page_buffer+0x2>, A
    662e:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    6630:	a2da c000 	add	A, #49152
    6634:	72e4      	swap	A
    6636:	b6da 00ff 	and	A, #255
    663a:	44b2      	lsr	A, #2
    663c:	4432      	lsr	A
}
    663e:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    6640:	44e2      	sfb	A
    6642:	b6d8 019c 	and	A, 0x19c <_page_buffer+0x2>
    6646:	1901      	je	0x664a <_Flash_InitDriver+0x2e>
    6648:	7001      	lod	A, #1
}
    664a:	5401      	ret

0000664c <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    664c:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    664e:	17f0      	call	0x6630 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    6650:	17f7      	call	0x6640 <_Flash_InitDriver+0x24>
    6652:	8c00      	cmp	AL, #0
    6654:	1d09      	jne	0x6668 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6656:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    665a:	8c01      	cmp	AL, #1
    665c:	1a02      	jule	0x6662 <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    665e:	7030      	lod	A, #48
    6660:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    6662:	72da 02a6 	lod	A, #678
    6666:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    6668:	7006      	lod	A, #6
    }

    return wr_time;
}
    666a:	5401      	ret

0000666c <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    666c:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    666e:	b480      	and	A, #-128
    6670:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    6672:	7ed8 019a 	lod	X, 0x19a <_page_buffer>
    6676:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    6678:	7a03      	lod	Y, [S-4]
    667a:	54c6      	movsw	[X++], [Y++]
    667c:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    667e:	7201      	lod	A, [S-2]
    6680:	a2da 0080 	add	A, #128
    6684:	2ee2      	cmp	X, A
    6686:	1878      	jc	0x6678 <_Flash_PageRead+0xc>
    6688:	5405      	ret	#6

0000668a <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    668a:	b47f      	and	A, #127
    668c:	7ae2      	lod	Y, A
    668e:	e2d8 019a 	add	Y, 0x19a <_page_buffer>
    6692:	6203      	lod	AL, [S-4]
    6694:	42f0      	mov	[Y], AL
    6696:	5401      	ret

00006698 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    6698:	b480      	and	A, #-128
    669a:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    669c:	7ad8 019a 	lod	Y, 0x19a <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    66a0:	72d6      	lod	A, [Y++]
    66a2:	aede      	cmp	A, [X++]
    66a4:	1902      	je	0x66aa <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    66a6:	7001      	lod	A, #1
    66a8:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66aa:	72d8 019a 	lod	A, 0x19a <_page_buffer>
    66ae:	a2da 0080 	add	A, #128
    66b2:	eee2      	cmp	Y, A
    66b4:	1875      	jc	0x66a0 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    66b6:	7000      	lod	A, #0
}
    66b8:	5401      	ret

000066ba <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    66ba:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    66bc:	b480      	and	A, #-128
    66be:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    66c0:	17a2      	call	0x6606 <_LDR_GetState>
    66c2:	8c01      	cmp	AL, #1
    66c4:	1d0b      	jne	0x66dc <_Flash_PageWrite+0x22>
    66c6:	72da bf66 	lod	A, #48998
    66ca:	b480      	and	A, #-128
    66cc:	7a09      	lod	Y, [S-10]
    66ce:	eee2      	cmp	Y, A
    66d0:	1d05      	jne	0x66dc <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    66d2:	7ad8 019a 	lod	Y, 0x19a <_page_buffer>
    66d6:	e076      	add	Y, #118
    66d8:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    66da:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    66dc:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    66de:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    66e0:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    66e2:	b430      	and	A, #48
    66e4:	1902      	je	0x66ea <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    66e6:	6000      	lod	AL, #0
    66e8:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    66ea:	11fc      	call	0x6ae4 <_mlx_isPowerOk>
    66ec:	8c00      	cmp	AL, #0
    66ee:	1d02      	jne	0x66f4 <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    66f0:	7001      	lod	A, #1
    66f2:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    66f4:	7a09      	lod	Y, [S-10]
    66f6:	eeda be80 	cmp	Y, #48768
    66fa:	1d01      	jne	0x66fe <_Flash_PageWrite+0x44>
    66fc:	0045      	jmp	0x6788 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    66fe:	72e6      	lod	A, Y
    6700:	1797      	call	0x6630 <_Flash_InitDriver+0x14>
    6702:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    6704:	179d      	call	0x6640 <_Flash_InitDriver+0x24>
    6706:	8c00      	cmp	AL, #0
    6708:	1901      	je	0x670c <_Flash_PageWrite+0x52>
    670a:	003e      	jmp	0x6788 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    670c:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    670e:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6710:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6712:	b430      	and	A, #48
    6714:	1902      	je	0x671a <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6716:	6000      	lod	AL, #0
    6718:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    671a:	7207      	lod	A, [S-8]
    671c:	487a 0800 	muls	Y, A, #2048
    6720:	e2da 4000 	add	Y, #16384
    6724:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6726:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    672a:	8c01      	cmp	AL, #1
    672c:	1a03      	jule	0x6734 <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    672e:	7801      	lod	Y, #1
    6730:	5a03      	mov	[S-4], Y
    6732:	0002      	jmp	0x6738 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    6734:	7010      	lod	A, #16
    6736:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    6738:	7800      	lod	Y, #0
    673a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    673e:	7a05      	lod	Y, [S-6]
    6740:	7000      	lod	A, #0
    6742:	52d6      	mov	[Y++], A
        *dst++ = 0;
    6744:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6746:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    6748:	72da 00c8 	lod	A, #200
    674c:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    6750:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    6754:	8c55      	cmp	AL, #85
    6756:	1903      	je	0x675e <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    6758:	7000      	lod	A, #0
    675a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    675e:	7000      	lod	A, #0
    6760:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6762:	72ee      	lod	A, X
    6764:	80ff      	add	AL, #-1
    6766:	5cf2      	usex	A
    6768:	7ee2      	lod	X, A
    676a:	1d6e      	jne	0x6748 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    676c:	7a05      	lod	Y, [S-6]
    676e:	e2da 0080 	add	Y, #128
    6772:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    6774:	7203      	lod	A, [S-4]
    6776:	a0ff      	add	A, #-1
    6778:	5203      	mov	[S-4], A
    677a:	1d5e      	jne	0x6738 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    677c:	7207      	lod	A, [S-8]
    677e:	44e2      	sfb	A
    6780:	a6d8 019c 	or	A, 0x19c <_page_buffer+0x2>
    6784:	52d8 019c 	mov	0x19c <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6788:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    678a:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    678c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    678e:	b430      	and	A, #48
    6790:	1902      	je	0x6796 <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6792:	6400      	lod	YL, #0
    6794:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    6796:	7000      	lod	A, #0
    6798:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    679c:	7ad8 019a 	lod	Y, 0x19a <_page_buffer>
    dst = (uint16_t *)addr;
    67a0:	7e09      	lod	X, [S-10]
    67a2:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    67a4:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    67a6:	7201      	lod	A, [S-2]
    67a8:	a2da 0080 	add	A, #128
    67ac:	eee2      	cmp	Y, A
    67ae:	187a      	jc	0x67a4 <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    67b0:	7818      	lod	Y, #24
    67b2:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    67b6:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    67ba:	8c55      	cmp	AL, #85
    67bc:	1903      	je	0x67c4 <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    67be:	7000      	lod	A, #0
    67c0:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    67c4:	7a09      	lod	Y, [S-10]
    67c6:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    67c8:	7000      	lod	A, #0
    67ca:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67ce:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    67d0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67d2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67d4:	b430      	and	A, #48
    67d6:	1902      	je	0x67dc <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67d8:	6400      	lod	YL, #0
    67da:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    67dc:	7209      	lod	A, [S-10]
    67de:	175c      	call	0x6698 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    67e0:	540b      	ret	#12

000067e2 <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    67e2:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    67e4:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    67e8:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    67ea:	7ae8      	swap	Y
    67ec:	f6da 00ff 	and	Y, #255
    67f0:	4436      	lsr	Y
    67f2:	7ee6      	lod	X, Y
    67f4:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    67f6:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    67f8:	ac3f      	cmp	A, #63
    67fa:	1b02      	jsle	0x6800 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    67fc:	703f      	lod	A, #63
    67fe:	0003      	jmp	0x6806 <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    6800:	ac00      	cmp	A, #0
    6802:	1e81      	jsge	0x6806 <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    6804:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    6806:	7ae2      	lod	Y, A
    6808:	f43f      	and	Y, #63
    680a:	f6da 00ff 	and	Y, #255
    680e:	7ae8      	swap	Y
    6810:	4426      	asl	Y
    6812:	7201      	lod	A, [S-2]
    6814:	b6da 81ff 	and	A, #33279
    6818:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    681a:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    681e:	4432      	lsr	A
    6820:	b6da 3f00 	and	A, #16128
    6824:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    6826:	72ee      	lod	A, X
    6828:	5403      	ret	#4

0000682a <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    682a:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    682c:	b480      	and	A, #-128
    682e:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    6830:	aeda be80 	cmp	A, #48768
    6834:	1907      	je	0x6844 <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    6836:	7201      	lod	A, [S-2]
    6838:	aeda bf00 	cmp	A, #48896
    683c:	1d05      	jne	0x6848 <_Flash_PageWriteFiltered+0x1e>
    683e:	16e3      	call	0x6606 <_LDR_GetState>
    6840:	8c03      	cmp	AL, #3
    6842:	1d02      	jne	0x6848 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    6844:	7000      	lod	A, #0
    6846:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    6848:	7201      	lod	A, [S-2]
    684a:	1737      	call	0x66ba <_Flash_PageWrite>
}
    684c:	5403      	ret	#4

0000684e <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    684e:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6850:	4cc2 45c0 	mov	D, #280000
    6854:	0004 
    6856:	4872 0006 	muls	A, A, #6
    685a:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    685c:	4c80      	mov	YA, D
    685e:	7e03      	lod	X, [S-4]
    6860:	4c63      	divu	YA, X
    6862:	4c63      	divu	YA, X
    6864:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6866:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    6868:	7000      	lod	A, #0
    686a:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    686c:	eeda 027a 	cmp	Y, #634
    6870:	1e04      	jug	0x687a <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    6872:	80ff      	add	AL, #-1
    6874:	b40f      	and	A, #15
    6876:	5205      	mov	[S-6], A
            break;
    6878:	0005      	jmp	0x6884 <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    687a:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    687c:	8001      	add	AL, #1
    687e:	5cf2      	usex	A
    6880:	8c02      	cmp	AL, #2
    6882:	1a74      	jule	0x686c <_ml_SetFastBaudRate+0x1e>
    6884:	72e6      	lod	A, Y
    6886:	a005      	add	A, #5
    6888:	4cf2      	usex	YA
    688a:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    688c:	4c63      	divu	YA, X
    688e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6890:	8080      	add	AL, #-128
    6892:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    6894:	52df      	push	A
    6896:	7207      	lod	A, [S-8]
    6898:	82db 5b82 	callf	0x5b82 <_ml_SetBaudRate>
    689c:	5c01      	dec	S, #2
    689e:	5407      	ret	#8
    68a0:	b66d      	and	A, [S-110]
    68a2:	6ddb      	lod	YH, dp:0xdb <_g_u8MotorStartupMode>
    68a4:	dbb6      	subc	AH, ep:0xb6 <__bss_size>
    68a6:	b66d      	and	A, [S-110]
    68a8:	6ddb      	lod	YH, dp:0xdb <_g_u8MotorStartupMode>

000068aa <_RAM_Test>:
    68aa:	7ada 68a0 	lod	Y, #26784
    68ae:	4cc0      	mov	D, YA
    68b0:	7c00      	lod	X, #0
    68b2:	54c6      	movsw	[X++], [Y++]
    68b4:	54c6      	movsw	[X++], [Y++]
    68b6:	54c6      	movsw	[X++], [Y++]
    68b8:	7800      	lod	Y, #0
    68ba:	54c6      	movsw	[X++], [Y++]
    68bc:	2eda 07fe 	cmp	X, #2046
    68c0:	1a7c      	jule	0x68ba <_RAM_Test+0x10>
    68c2:	4c80      	mov	YA, D
    68c4:	7c00      	lod	X, #0
    68c6:	72de      	lod	A, [X++]
    68c8:	aed6      	cmp	A, [Y++]
    68ca:	1d0a      	jne	0x68e0 <_RAM_Test+0x36>
    68cc:	72de      	lod	A, [X++]
    68ce:	aed6      	cmp	A, [Y++]
    68d0:	1d07      	jne	0x68e0 <_RAM_Test+0x36>
    68d2:	72de      	lod	A, [X++]
    68d4:	aed6      	cmp	A, [Y++]
    68d6:	1d04      	jne	0x68e0 <_RAM_Test+0x36>
    68d8:	7800      	lod	Y, #0
    68da:	72de      	lod	A, [X++]
    68dc:	aed6      	cmp	A, [Y++]
    68de:	1903      	je	0x68e6 <_RAM_Test+0x3c>
    68e0:	64f3      	lod	YL, #-13
    68e2:	76da 568e 	jmpf	0x568e <__fatal>
    68e6:	2eda 07fe 	cmp	X, #2046
    68ea:	1a77      	jule	0x68da <_RAM_Test+0x30>
    68ec:	4c80      	mov	YA, D
    68ee:	e002      	add	Y, #2
    68f0:	eeda 68a6 	cmp	Y, #26790
    68f4:	1d5c      	jne	0x68ae <_RAM_Test+0x4>
    68f6:	76da 55e8 	jmpf	0x55e8 <_start>

000068fa <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    68fa:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    68fc:	72d8 019e 	lod	A, 0x19e <__bss_end>
    6900:	aeda b598 	cmp	A, #46488
    6904:	1907      	je	0x6914 <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    6906:	72da b598 	lod	A, #46488
    690a:	52d8 019e 	mov	0x19e <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    690e:	7800      	lod	Y, #0
    6910:	5ad8 01a0 	mov	0x1a0 <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if (   (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    6914:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    6918:	aeda 3072 	cmp	A, #12402
    691c:	1d01      	jne	0x6920 <__low_level_init+0x26>
    691e:	0071      	jmp	0x6a02 <__low_level_init+0x108>
    6920:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    6924:	aeda 3212 	cmp	A, #12818
    6928:	1d01      	jne	0x692c <__low_level_init+0x32>
    692a:	006b      	jmp	0x6a02 <__low_level_init+0x108>
    692c:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    6930:	aeda 5c92 	cmp	A, #23698
    6934:	1d01      	jne	0x6938 <__low_level_init+0x3e>
    6936:	0065      	jmp	0x6a02 <__low_level_init+0x108>
    6938:	7c0f      	lod	X, #15
    693a:	7ada 11c0 	lod	Y, #4544
    693e:	7000      	lod	A, #0
    6940:	08a7      	clrb	ML.7
    6942:	b2d6      	adc	A, [Y++]
    6944:	1bfe      	djnz	X, 0x6942 <__low_level_init+0x48>
    6946:	92e4      	adc	AL, AH
    6948:	9000      	adc	AL, #0
    694a:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    694c:	aeda 00ff 	cmp	A, #255
    6950:	1903      	je	0x6958 <__low_level_init+0x5e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    6952:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    6954:	76da 568e 	jmpf	0x568e <__fatal>
    6958:	7c0c      	lod	X, #12
    695a:	7ada 11de 	lod	Y, #4574
    695e:	7000      	lod	A, #0
    6960:	08a7      	clrb	ML.7
    6962:	b2d6      	adc	A, [Y++]
    6964:	1bfe      	djnz	X, 0x6962 <__low_level_init+0x68>
    6966:	92e4      	adc	AL, AH
    6968:	9000      	adc	AL, #0
    696a:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    696c:	aeda 00ff 	cmp	A, #255
    6970:	1903      	je	0x6978 <__low_level_init+0x7e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    6972:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    6974:	76da 568e 	jmpf	0x568e <__fatal>
    6978:	7c05      	lod	X, #5
    697a:	7ada 11f6 	lod	Y, #4598
    697e:	7000      	lod	A, #0
    6980:	08a7      	clrb	ML.7
    6982:	b2d6      	adc	A, [Y++]
    6984:	1bfe      	djnz	X, 0x6982 <__low_level_init+0x88>
    6986:	92e4      	adc	AL, AH
    6988:	9000      	adc	AL, #0
    698a:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    698c:	aeda 00ff 	cmp	A, #255
    6990:	1903      	je	0x6998 <__low_level_init+0x9e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    6992:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    6994:	76da 568e 	jmpf	0x568e <__fatal>
    6998:	7ada 10fc 	lod	Y, #4348
    699c:	7c02      	lod	X, #2
    699e:	7000      	lod	A, #0
    69a0:	08a7      	clrb	ML.7
    69a2:	b2d6      	adc	A, [Y++]
    69a4:	1bfe      	djnz	X, 0x69a2 <__low_level_init+0xa8>
    69a6:	92e4      	adc	AL, AH
    69a8:	9000      	adc	AL, #0
    69aa:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    69ac:	aeda 00ff 	cmp	A, #255
    69b0:	1d07      	jne	0x69c0 <__low_level_init+0xc6>
    69b2:	7eda 11f8 	lod	X, #4600
    69b6:	7ada 10fe 	lod	Y, #4350
    69ba:	72f0      	lod	A, [Y]
    69bc:	aef8      	cmp	A, [X]
    69be:	1921      	je	0x6a02 <__low_level_init+0x108>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    69c0:	7000      	lod	A, #0
    69c2:	7eda 10fc 	lod	X, #4348
    69c6:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    69c8:	7eda 10fe 	lod	X, #4350
    69cc:	7ada 11f8 	lod	Y, #4600
    69d0:	7af0      	lod	Y, [Y]
    69d2:	5af8      	mov	[X], Y
    69d4:	7ada 10fc 	lod	Y, #4348
    69d8:	7c02      	lod	X, #2
    69da:	7000      	lod	A, #0
    69dc:	08a7      	clrb	ML.7
    69de:	b2d6      	adc	A, [Y++]
    69e0:	1bfe      	djnz	X, 0x69de <__low_level_init+0xe4>
    69e2:	92e4      	adc	AL, AH
    69e4:	9000      	adc	AL, #0
    69e6:	5cf2      	usex	A
    69e8:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    69ea:	72da 00ff 	lod	A, #255
    69ee:	aa05      	sub	A, [S-6]
    69f0:	7ada 10fc 	lod	Y, #4348
    69f4:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    69f6:	7001      	lod	A, #1
    69f8:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    69fc:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    69fe:	76da 568e 	jmpf	0x568e <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    6a02:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a06:	8408      	or	AL, #8
    6a08:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    6a0c:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    6a10:	b6da ff7f 	and	A, #65407
    6a14:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    6a18:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a1c:	94f7      	and	AL, #-9
    6a1e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    6a22:	7c04      	lod	X, #4
    6a24:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    6a28:	72da 7c50 	lod	A, #31824
    6a2c:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    6a30:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a34:	94fe      	and	AL, #-2
    6a36:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    6a3a:	0000      	nop
    NOP();
    6a3c:	0000      	nop
    NOP();
    6a3e:	0000      	nop
    MLX4_START();
    6a40:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a44:	8401      	or	AL, #1
    6a46:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    6a4a:	540f      	ret	#16

00006a4c <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    6a4c:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    6a4e:	72ef      	lod	A, S
    6a50:	a080      	add	A, #-128
    6a52:	52d8 019a 	mov	0x19a <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    6a56:	15d7      	call	0x6606 <_LDR_GetState>
    6a58:	8c00      	cmp	AL, #0
    6a5a:	1d06      	jne	0x6a68 <__premain+0x1c>
    6a5c:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    6a60:	aeda 3212 	cmp	A, #12818
    6a64:	1901      	je	0x6a68 <__premain+0x1c>
    6a66:	003b      	jmp	0x6ade <__premain+0x92>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
	    if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    6a68:	72d8 0010 	lod	A, 0x10 <__data_dp_size>
    6a6c:	7ad8 0012 	lod	Y, 0x12 <__data_dp_size+0x2>
    6a70:	4cb2 72ef 	cmp	YA, #-396266769
    6a74:	e861 
    6a76:	1913      	je	0x6a9e <__premain+0x52>
		{
			uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76);					/* Get NAD from Flash at STACK_IT Segment */
    6a78:	7ada bf76 	lod	Y, #49014
    6a7c:	72f0      	lod	A, [Y]
    6a7e:	5cf2      	usex	A
			if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    6a80:	8c00      	cmp	AL, #0
    6a82:	1a82      	jsl	0x6a88 <__premain+0x3c>
    6a84:	ac00      	cmp	A, #0
    6a86:	1d01      	jne	0x6a8a <__premain+0x3e>
			{
				u8NAD = 0x7F;													/* Invalid NAD; Use default NAD */
    6a88:	707f      	lod	A, #127
			}
			stFixedRamNAD.nad = u8NAD;
    6a8a:	42d8 0014 	mov	0x14 <__data_dp_size+0x4>, AL
			stFixedRamNAD.key = _mlx_NAD_Security_Key;
    6a8e:	72da 72ef 	lod	A, #29423
    6a92:	52d8 0010 	mov	0x10 <__data_dp_size>, A
    6a96:	72da e861 	lod	A, #59489
    6a9a:	52d8 0012 	mov	0x12 <__data_dp_size+0x2>, A
		}
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    6a9e:	54f7      	mov	UPr, #7

        ml_LinInit();
    6aa0:	106e      	call	0x6b7e <_ml_LinInit>
        (void)ml_Connect();
    6aa2:	82db 5b96 	callf	0x5b96 <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    6aa6:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    6aaa:	aeda 3212 	cmp	A, #12818
    6aae:	1d07      	jne	0x6abe <__premain+0x72>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    6ab0:	7000      	lod	A, #0
    6ab2:	82db 6086 	callf	0x6086 <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    6ab6:	72da 5c92 	lod	A, #23698
    6aba:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6abe:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6ac0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6ac2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6ac4:	b430      	and	A, #48
    6ac6:	1902      	je	0x6acc <__premain+0x80>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6ac8:	6000      	lod	AL, #0
    6aca:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    6acc:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6ad0:	b410      	and	A, #16
    6ad2:	1975      	je	0x6abe <__premain+0x72>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    6ad4:	82db 5bb2 	callf	0x5bb2 <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    6ad8:	82db 5be2 	callf	0x5be2 <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    6adc:	07f0      	jmp	0x6abe <__premain+0x72>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    6ade:	54f7      	mov	UPr, #7
    6ae0:	5c7f      	dec	S, #128
    6ae2:	5401      	ret

00006ae4 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    6ae4:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    6ae6:	7003      	lod	A, #3
    6ae8:	5205      	mov	[S-6], A
    6aea:	70ff      	lod	A, #-1
    6aec:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    6aee:	7000      	lod	A, #0
    6af0:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    6af2:	7290      	lod	A, io:0x10 <__data_dp_size>
    6af4:	b401      	and	A, #1
    6af6:	1917      	je	0x6b26 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6af8:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6afa:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6afc:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6afe:	b430      	and	A, #48
    6b00:	1902      	je	0x6b06 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b02:	6000      	lod	AL, #0
    6b04:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    6b06:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b08:	b4fb      	and	A, #-5
    6b0a:	5290      	mov	io:0x10 <__data_dp_size>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b0c:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b0e:	b401      	and	A, #1
    6b10:	190a      	je	0x6b26 <_mlx_isPowerOk+0x42>
    6b12:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    6b14:	7eda 15e0 	lod	X, #5600
    6b18:	1bff      	djnz	X, 0x6b18 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b1a:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b1c:	b401      	and	A, #1
    6b1e:	1903      	je	0x6b26 <_mlx_isPowerOk+0x42>
    6b20:	e0ff      	add	Y, #-1
    6b22:	ecff      	cmp	Y, #-1
    6b24:	1d77      	jne	0x6b14 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    6b26:	7000      	lod	A, #0
    6b28:	5290      	mov	io:0x10 <__data_dp_size>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    6b2a:	72ef      	lod	A, S
    6b2c:	a0fe      	add	A, #-2
    6b2e:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
    6b30:	72ef      	lod	A, S
    6b32:	a0fa      	add	A, #-6
    6b34:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
    6b36:	72da 0080 	lod	A, #128
    6b3a:	5290      	mov	io:0x10 <__data_dp_size>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    6b3c:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b3e:	a401      	or	A, #1
    6b40:	5290      	mov	io:0x10 <__data_dp_size>, A
    DELAY(500);                     /* some delay for sample and hold */
    6b42:	7eda 01f4 	lod	X, #500
    6b46:	1bff      	djnz	X, 0x6b46 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    6b48:	7040      	lod	A, #64
    6b4a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    6b4e:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b50:	a6da 0100 	or	A, #256
    6b54:	5290      	mov	io:0x10 <__data_dp_size>, A
    6b56:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b5a:	b440      	and	A, #64
    6b5c:	1d08      	jne	0x6b6e <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b5e:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6b60:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b62:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b64:	b430      	and	A, #48
    6b66:	1977      	je	0x6b56 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b68:	6000      	lod	AL, #0
    6b6a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    6b6c:	07f4      	jmp	0x6b56 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    6b6e:	7201      	lod	A, [S-2]
    6b70:	aeda 0158 	cmp	A, #344
    6b74:	1e02      	jug	0x6b7a <_mlx_isPowerOk+0x96>
        return false;
    6b76:	7000      	lod	A, #0
    6b78:	5407      	ret	#8
    }
    else {
        return true;
    6b7a:	7001      	lod	A, #1
    }
}
    6b7c:	5407      	ret	#8

00006b7e <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    6b7e:	82db 5dce 	callf	0x5dce <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6b82:	54ca 0000 	pushw	#0
    6b86:	54ca 0001 	pushw	#1
    6b8a:	54ca 0000 	pushw	#0
    6b8e:	7001      	lod	A, #1
    6b90:	82db 5ad4 	callf	0x5ad4 <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    6b94:	7000      	lod	A, #0
    6b96:	82db 5acc 	callf	0x5acc <_ml_SetSlewRate>
    6b9a:	5c05      	dec	S, #6
    6b9c:	5401      	ret
    6b9e:	0000      	nop
    6ba0:	5c32      	dec	S, #51
    6ba2:	5c4e      	dec	S, #79
    6ba4:	5ca6      	sne	Y
    6ba6:	5cd6      	.word	0x5cd6
    6ba8:	5cea      	ssex	
    6baa:	0000      	nop
    6bac:	0001      	jmp	0x6bb0 <_muldivI16_I16byI16byI16+0x2>

00006bae <_muldivI16_I16byI16byI16>:
    6bae:	7a03      	lod	Y, [S-4]
    6bb0:	4831      	muls	YA, A, Y
    6bb2:	7e05      	lod	X, [S-6]
    6bb4:	4c73      	divs	YA, X
    6bb6:	4c73      	divs	YA, X
    6bb8:	4c7b      	dadjs	YA, X
    6bba:	5401      	ret

00006bbc <_muldivU16_U16byU16byU16>:
    6bbc:	7a03      	lod	Y, [S-4]
    6bbe:	4821      	mulu	YA, A, Y
    6bc0:	7e05      	lod	X, [S-6]
    6bc2:	4c63      	divu	YA, X
    6bc4:	4c63      	divu	YA, X
    6bc6:	5401      	ret

00006bc8 <_divI32_I32byI16>:
    6bc8:	7e03      	lod	X, [S-4]
    6bca:	1d87      	jnn	0x6bda <_divI32_I32byU16+0x2>
    6bcc:	5cce      	neg	X
    6bce:	5e03      	mov	[S-4], X
    6bd0:	e000      	add	Y, #0
    6bd2:	1d86      	jnn	0x6be0 <_divI32_I32byU16+0x8>
    6bd4:	4cf0      	neg	YA
    6bd6:	0011      	jmp	0x6bfa <_divU32_U32byU16>

00006bd8 <_divI32_I32byU16>:
    6bd8:	7e03      	lod	X, [S-4]
    6bda:	e000      	add	Y, #0
    6bdc:	1d8e      	jnn	0x6bfa <_divU32_U32byU16>
    6bde:	4cf0      	neg	YA
    6be0:	4ca3      	push	YA
    6be2:	72e6      	lod	A, Y
    6be4:	7800      	lod	Y, #0
    6be6:	7e07      	lod	X, [S-8]
    6be8:	4c63      	divu	YA, X
    6bea:	4c63      	divu	YA, X
    6bec:	5201      	mov	[S-2], A
    6bee:	7203      	lod	A, [S-4]
    6bf0:	4c63      	divu	YA, X
    6bf2:	4c63      	divu	YA, X
    6bf4:	7a01      	lod	Y, [S-2]
    6bf6:	4cf0      	neg	YA
    6bf8:	5405      	ret	#6

00006bfa <_divU32_U32byU16>:
    6bfa:	4ca3      	push	YA
    6bfc:	72e6      	lod	A, Y
    6bfe:	7800      	lod	Y, #0
    6c00:	7e07      	lod	X, [S-8]
    6c02:	4c63      	divu	YA, X
    6c04:	4c63      	divu	YA, X
    6c06:	5201      	mov	[S-2], A
    6c08:	7203      	lod	A, [S-4]
    6c0a:	4c63      	divu	YA, X
    6c0c:	4c63      	divu	YA, X
    6c0e:	7a01      	lod	Y, [S-2]
    6c10:	5405      	ret	#6

00006c12 <_mulI32_I16byU16>:
    6c12:	a000      	add	A, #0
    6c14:	1d85      	jnn	0x6c20 <_mulU32_U16byU16>
    6c16:	5cc2      	neg	A
    6c18:	7a03      	lod	Y, [S-4]
    6c1a:	4821      	mulu	YA, A, Y
    6c1c:	4cf0      	neg	YA
    6c1e:	5401      	ret

00006c20 <_mulU32_U16byU16>:
    6c20:	7a03      	lod	Y, [S-4]
    6c22:	4821      	mulu	YA, A, Y
    6c24:	5401      	ret

00006c26 <_main>:

#pragma space none

int16 main( void)
{
	MLX315_SystemInit();                               	/* initialize MLX315 hardware */
    6c26:	137a      	call	0x731c <_MLX315_SystemInit>
	
	SET_PRIORITY(0);							       	/* Enter application mode */
    6c28:	54f0      	mov	UPr, #0

	/* driver initialize area */
	NVRAM_Init();                              			/* Load User NVRAM storage parameters */
    6c2a:	82db 9196 	callf	0x9196 <_NVRAM_Init>
	ADC_Init();									       	/* Initialize ADC */
    6c2e:	82db 8228 	callf	0x8228 <_ADC_Init>
	DiagnosticsInit();							       	/* Initialize Diagnostic */
    6c32:	82db 8502 	callf	0x8502 <_DiagnosticsInit>
	MotorDriverInit();							       	/*  Initialize Motor-driver */
    6c36:	82db 89f4 	callf	0x89f4 <_MotorDriverInit>
	PID_Init();										   	/* PID Control initialization */
    6c3a:	82db 95d4 	callf	0x95d4 <_PID_Init>
	LIN_Init();											/* initialize LIN interface */
    6c3e:	82db 76d0 	callf	0x76d0 <_LIN_Init>
	
	SET_PRIORITY(7);									/* Enable interrupts:MASK LEVEL lowest */
    6c42:	54f7      	mov	UPr, #7
	
	/* system service */
	ErrorLogInit();								       	/* Initialize Error-logging management */	
    6c44:	82db 8812 	callf	0x8812 <_ErrorLogInit>
	Timer_Init();								       	/* Initialize (Core) Timer */
    6c48:	82db 97ec 	callf	0x97ec <_Timer_Init>

#if _SUPPORT_MOTOR_SELFTEST
	MotorDiagnosticSelfTest();							/* Self-test Motor-Driver */
#endif
	/* Application initialize area */
	App_CoolantValveSMInit();
    6c4c:	1012      	call	0x6c72 <_App_CoolantValveSMInit>
	System_BackgroundTaskInit();
    6c4e:	13f0      	call	0x7430 <_System_BackgroundTaskInit>
	
	for(;;)
	{
		/* user application */
		App_CoolantValveSM();
    6c50:	12ae      	call	0x71ae <_App_CoolantValveSM>

		/* driver and service */
		MotorDriver_MainFunction();
    6c52:	82db 8dd0 	callf	0x8dd0 <_MotorDriver_MainFunction>
		LIN_MainFunction();
    6c56:	82db 7a14 	callf	0x7a14 <_LIN_MainFunction>
		
		/* system background application */
		System_BackgroundMemoryTest();
    6c5a:	82db 7500 	callf	0x7500 <_System_BackgroundMemoryTest>
		System_BackgroundIORegTest();
    6c5e:	82db 7548 	callf	0x7548 <_System_BackgroundIORegTest>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6c62:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6c64:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6c66:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6c68:	b430      	and	A, #48
    6c6a:	1972      	je	0x6c50 <_main+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6c6c:	6000      	lod	AL, #0
    6c6e:	4282      	mov	io:0x2 <_LinCmnd>, AL
#endif
	/* Application initialize area */
	App_CoolantValveSMInit();
	System_BackgroundTaskInit();
	
	for(;;)
    6c70:	07ef      	jmp	0x6c50 <_main+0x2a>

00006c72 <_App_CoolantValveSMInit>:

void SaveLastPosition(void);
uint16 RecoryLastPosition(void);

void App_CoolantValveSMInit(void)
{
    6c72:	581f      	inc	S, #32
		}
	}
	else
	{
		/* unnitialized,use default value */
		l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6c74:	72da 0190 	lod	A, #400
    6c78:	52d8 00e8 	mov	0xe8 <__data_end>, A
		l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;	
    6c7c:	52d8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, A
		l_u16PhysicalCalibTravel = C_VALVE_DEF_TRAVEL;
    6c80:	7ada 0900 	lod	Y, #2304
    6c84:	5ad8 00ec 	mov	0xec <_l_u16PhysicalCalibTravel>, Y
		l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6c88:	6000      	lod	AL, #0
    6c8a:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
		l_e8CalibrationStep = (uint8)C_CALIB_NONE;
    6c8e:	42d8 00a2 	mov	0xa2 <_l_e8CalibrationStep>, AL
	}

	/* configure motor control params */
	motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6c92:	7800      	lod	Y, #0
    6c94:	5a19      	mov	[S-26], Y
	motor_params.ActPos = l_u16PhysicalActualPos;
    6c96:	7eda 0190 	lod	X, #400
    6c9a:	5e15      	mov	[S-22], X
	motor_params.TgtPos = l_u16PhysicalTargetPos;
    6c9c:	5e17      	mov	[S-24], X
	motor_params.SpdRPM = NVRAM_SPEED1;
    6c9e:	72da 00c8 	lod	A, #200
    6ca2:	520f      	mov	[S-16], A
	MotorDriverSetParams(motor_params);
    6ca4:	7aef      	lod	Y, S
    6ca6:	e0f4      	add	Y, #-12
    6ca8:	5a0d      	mov	[S-14], Y
    6caa:	7ee6      	lod	X, Y
    6cac:	7aef      	lod	Y, S
    6cae:	e0e6      	add	Y, #-26
    6cb0:	54e6      	mov	Cx, #6
    6cb2:	54c6      	movsw	[X++], [Y++]
    6cb4:	1ffe      	djnz	Cx, 0x6cb2 <_App_CoolantValveSMInit+0x40>
    6cb6:	82db 88ce 	callf	0x88ce <_MotorDriverSetParams>
	
#if _SUPPORT_ENDSTOP_DETECTION
	l_u8EndstopCheckLock = 0u; 		/* unlock endstop check when wake-up or power up  */
#endif

	l_u8OBDValveElectricError = (uint8)OBD_VALVE_ELECTRIC_INDET;
    6cba:	6080      	lod	AL, #-128
    6cbc:	42d8 00a3 	mov	0xa3 <_l_u8OBDValveElectricError>, AL
    6cc0:	5c0b      	dec	S, #12
    6cc2:	5415      	ret	#22

00006cc4 <_handleInitiliazeProcess>:
		}
	}
}

void handleInitiliazeProcess(void)
{
    6cc4:	580b      	inc	S, #12
	Motor_ControlParams motor_params;
	uint16 range_temp;	/* range travelled from end to end,with hall sensor detection steps */

	if(l_e8CalibrationStep == (uint8)C_CALIB_START)
    6cc6:	62d8 00a2 	lod	AL, 0xa2 <_l_e8CalibrationStep>
    6cca:	8c01      	cmp	AL, #1
    6ccc:	1d06      	jne	0x6cda <_handleInitiliazeProcess+0x16>
	{
		if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6cce:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6cd2:	ac05      	cmp	A, #5
    6cd4:	1d02      	jne	0x6cda <_handleInitiliazeProcess+0x16>
        {
			l_e8CalibrationStep = (uint8)C_CALIB_SETUP_LO_ENDPOS;
    6cd6:	42d8 00a2 	mov	0xa2 <_l_e8CalibrationStep>, AL
			}
#endif
		}
	}
	
	if(l_e8CalibrationStep == (uint8)C_CALIB_SETUP_HI_ENDPOS)
    6cda:	62d8 00a2 	lod	AL, 0xa2 <_l_e8CalibrationStep>
    6cde:	8c02      	cmp	AL, #2
    6ce0:	1d14      	jne	0x6d0a <_handleInitiliazeProcess+0x46>
	{
		/* setup high endstop */
		if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6ce2:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6ce6:	ac05      	cmp	A, #5
    6ce8:	1901      	je	0x6cec <_handleInitiliazeProcess+0x28>
    6cea:	004d      	jmp	0x6d86 <_handleInitiliazeProcess+0xc2>
		{
            s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6cec:	7000      	lod	A, #0
    6cee:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
            /* eg.setup motor parameters and start motor */
			l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6cf2:	72da 0190 	lod	A, #400
    6cf6:	52d8 00e8 	mov	0xe8 <__data_end>, A
			l_u16PhysicalTargetPos = C_VALVE_RANGE_MAX + C_VALVE_ZERO_POS;
    6cfa:	72da 0a90 	lod	A, #2704
    6cfe:	52d8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, A
			/* client-server:post message */
			l_u8MotorControl = C_MOTOR_START;
    6d02:	6003      	lod	AL, #3
    6d04:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
    6d08:	003c      	jmp	0x6d82 <_handleInitiliazeProcess+0xbe>

		    l_e8CalibrationStep = (uint8)C_CALIB_CHECK_HI_ENDPOS;		/* check for high end-stop */
        }
	}
	else if( l_e8CalibrationStep == (uint8)C_CALIB_SETUP_LO_ENDPOS )
    6d0a:	8c05      	cmp	AL, #5
    6d0c:	1d17      	jne	0x6d3c <_handleInitiliazeProcess+0x78>
	{
		/* setup low endstop */
		if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6d0e:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6d12:	ac05      	cmp	A, #5
    6d14:	1901      	je	0x6d18 <_handleInitiliazeProcess+0x54>
    6d16:	0037      	jmp	0x6d86 <_handleInitiliazeProcess+0xc2>
		{
            s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6d18:	7000      	lod	A, #0
    6d1a:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
            /* setup motor parameters and start motor */
			l_u16PhysicalActualPos = l_u16RecoryPos + C_VALVE_ZERO_POS + C_VALVE_FAR_POS;
    6d1e:	72d8 0084 	lod	A, 0x84 <_l_u16RecoryPos>
    6d22:	a2da 0230 	add	A, #560
    6d26:	52d8 00e8 	mov	0xe8 <__data_end>, A
			l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;
    6d2a:	72da 0190 	lod	A, #400
    6d2e:	52d8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, A
			/* client-server:post message */
			l_u8MotorControl = C_MOTOR_START;
    6d32:	6003      	lod	AL, #3
    6d34:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL

		    l_e8CalibrationStep = (uint8) C_CALIB_CHECK_LO_ENDPOS;
    6d38:	6006      	lod	AL, #6
    6d3a:	0023      	jmp	0x6d82 <_handleInitiliazeProcess+0xbe>
        }
	}
	else if(l_e8CalibrationStep == (uint8)C_CALIB_CHECK_HI_ENDPOS)
    6d3c:	8c03      	cmp	AL, #3
    6d3e:	1d10      	jne	0x6d60 <_handleInitiliazeProcess+0x9c>
					
				}
			}
		}
#else	/* _SUPPORT_STALLDET */
		if(l_u16PhysicalActualPos == C_VALVE_RANGE_MAX + C_VALVE_ZERO_POS)
    6d40:	72d8 00e8 	lod	A, 0xe8 <__data_end>
    6d44:	aeda 0a90 	cmp	A, #2704
    6d48:	1d1e      	jne	0x6d86 <_handleInitiliazeProcess+0xc2>
		{
			if((l_u8ValveInitEnds & (uint8)C_VALVE_INIT_END_LO) == 0u)
    6d4a:	66d8 00a1 	lod	YL, 0xa1 <_l_u8ValveInitEnds>
    6d4e:	72e6      	lod	A, Y
    6d50:	b402      	and	A, #2
    6d52:	1d0d      	jne	0x6d6e <_handleInitiliazeProcess+0xaa>
            {
			   l_u8ValveInitEnds |= (uint8)C_VALVE_INIT_END_HI;
    6d54:	62e8      	lod	AL, YL
    6d56:	8401      	or	AL, #1
    6d58:	42d8 00a1 	mov	0xa1 <_l_u8ValveInitEnds>, AL
			   l_e8CalibrationStep = (uint8)C_CALIB_SETUP_LO_ENDPOS;
    6d5c:	6005      	lod	AL, #5
    6d5e:	0011      	jmp	0x6d82 <_handleInitiliazeProcess+0xbe>
				l_e8CalibrationStep = (uint8)C_CALIB_END;
			}
		}
#endif /* _SUPPORT_STALLDET */
	}
	else if(l_e8CalibrationStep == (uint8)C_CALIB_CHECK_LO_ENDPOS)
    6d60:	8c06      	cmp	AL, #6
    6d62:	1d11      	jne	0x6d86 <_handleInitiliazeProcess+0xc2>
					
				}
			}
		}
#else
		if(l_u16PhysicalActualPos == C_VALVE_ZERO_POS)
    6d64:	72d8 00e8 	lod	A, 0xe8 <__data_end>
    6d68:	aeda 0190 	cmp	A, #400
    6d6c:	1d02      	jne	0x6d72 <_handleInitiliazeProcess+0xae>
//				l_e8CalibrationStep = (uint8)C_CALIB_SETUP_HI_ENDPOS;
//            }
//			else
			{
				/* initialize finish */
				l_e8CalibrationStep = (uint8)C_CALIB_END;
    6d6e:	6009      	lod	AL, #9
    6d70:	0008      	jmp	0x6d82 <_handleInitiliazeProcess+0xbe>
			}
		}
		else if(l_u16PhysicalActualPos < (C_VALVE_ZERO_POS - C_VALVE_TOLERANCE_UP))
    6d72:	ac4f      	cmp	A, #79
    6d74:	1e08      	jug	0x6d86 <_handleInitiliazeProcess+0xc2>
		{
			l_u8OBDValveMechanicalError = OBD_VALVE_RANGE_BROKEN;
    6d76:	6002      	lod	AL, #2
    6d78:	42d8 00a4 	mov	0xa4 <_l_u8OBDValveMechanicalError>, AL
			l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BROKEN;
    6d7c:	42d8 008f 	mov	0x8f <_l_u8ValueFaultFlag>, AL
			l_e8CalibrationStep = (uint8)C_CALIB_NONE;
    6d80:	6000      	lod	AL, #0
    6d82:	42d8 00a2 	mov	0xa2 <_l_e8CalibrationStep>, AL
	else
	{
		/* unsupported state,should never enter */
	}
	/* calibration end */
	if(l_e8CalibrationStep == (uint8)C_CALIB_END)
    6d86:	62d8 00a2 	lod	AL, 0xa2 <_l_e8CalibrationStep>
    6d8a:	8c09      	cmp	AL, #9
    6d8c:	1d06      	jne	0x6d9a <_handleInitiliazeProcess+0xd6>
			l_u8MotorControl = C_MOTOR_STOP_ONLY;
			l_e8CalibrationStep = (uint8)C_CALIB_NONE;
		    s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
		}
#else
        l_u8MotorControl = C_MOTOR_STOP;
    6d8e:	6001      	lod	AL, #1
    6d90:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
		l_e8CalibrationStep = (uint8)C_CALIB_DONE;
    6d94:	600a      	lod	AL, #10
    6d96:	42d8 00a2 	mov	0xa2 <_l_e8CalibrationStep>, AL
    6d9a:	540d      	ret	#14

00006d9c <_handleOpeningPosition>:
	}
	
}

void handleOpeningPosition(void)
{
    6d9c:	580b      	inc	S, #12
	Motor_ControlParams motor_params;
	
	/* handle master normal start motor request */
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_START)
    6d9e:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6da2:	ac03      	cmp	A, #3
    6da4:	1d0d      	jne	0x6dc0 <_handleOpeningPosition+0x24>
	{
		s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6da6:	7000      	lod	A, #0
    6da8:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A

		}
#else  /* _SUPPORT_ENDSTOP_DETECTION */
//		l_u16PhysicalTargetPos = divU16_U32byU16( mulU32_U16byU16( s_CVRequestStruct.m_opening, l_u16PhysicalCalibTravel) + C_VALVE_OPENING_100_PERCENT / 2, C_VALVE_OPENING_100_PERCENT) + C_VALVE_ZERO_POS;

		l_u16PhysicalTargetPos = s_CVRequestStruct.m_opening + C_VALVE_ZERO_POS;
    6dac:	72d8 0094 	lod	A, 0x94 <_s_CVRequestStruct+0x2>
    6db0:	a2da 0190 	add	A, #400
    6db4:	52d8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, A

		/* only update target position */
		l_u8MotorControl = C_MOTOR_START_ONLY;
    6db8:	6004      	lod	AL, #4
    6dba:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
    6dbe:	540d      	ret	#14
#endif /* _SUPPORT_ENDSTOP_DETECTION */

	}
	else if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_STOP)
    6dc0:	ac01      	cmp	A, #1
    6dc2:	1d03      	jne	0x6dca <_handleOpeningPosition+0x2e>
#if _SUPPORT_ENDSTOP_DETECTION
		/* endstop check unlock process[1]:1)stop request;2)need moving request */
		l_u8EndstopCheckLock = 0u;	
#endif
		/* only stop motor:immediate */
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6dc4:	6002      	lod	AL, #2
    6dc6:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
    6dca:	540d      	ret	#14

00006dcc <_handleStateTransition>:
}

void handleStateTransition(void)
{
	/* unnitialized -> initializing */
	if(l_e8ValveState == (uint8)C_STATE_UNINITIALIZED)
    6dcc:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    6dd0:	1d06      	jne	0x6dde <_handleStateTransition+0x12>
	{
		if(l_e8CalibrationStep == (uint8)C_CALIB_START)
    6dd2:	62d8 00a2 	lod	AL, 0xa2 <_l_e8CalibrationStep>
    6dd6:	8c01      	cmp	AL, #1
    6dd8:	1d02      	jne	0x6dde <_handleStateTransition+0x12>
		{
			l_e8ValveState = (uint8)C_STATE_INITIALIZING;
    6dda:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
		}
	}
	/* initializing -> unnitialize,initializing -> initialized */
	/* permanent electric error,temperory electric error,mechanical error */
	if(l_e8ValveState == (uint8)C_STATE_INITIALIZING)
    6dde:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    6de2:	8c01      	cmp	AL, #1
    6de4:	1d13      	jne	0x6e0c <_handleStateTransition+0x40>
	{
		/* error block/hall sensor,or error meichanical valve broken */
		if(((l_u8OBDValveElectricError & OBD_VALVE_ELECTRIC_PERM) != 0u) || 
    6de6:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    6dea:	b401      	and	A, #1
    6dec:	1d04      	jne	0x6df6 <_handleStateTransition+0x2a>
    6dee:	62d8 00a4 	lod	AL, 0xa4 <_l_u8OBDValveMechanicalError>
    6df2:	b407      	and	A, #7
    6df4:	1903      	je	0x6dfc <_handleStateTransition+0x30>
			((l_u8OBDValveMechanicalError & OBD_VALVE_MECHANICAL_MASK) != 0u))
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6df6:	6000      	lod	AL, #0
    6df8:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
			/* start calibration pause timer,prevent from contiuous calibration */
//			Timer_Start(CALIB_PAUSE_TIMER,C_PI_TICKS_500MS);
		}
		/* range error */
		if(l_e8CalibrationStep == (uint8)C_CALIB_NONE)
    6dfc:	62d8 00a2 	lod	AL, 0xa2 <_l_e8CalibrationStep>
    6e00:	1903      	je	0x6e08 <_handleStateTransition+0x3c>
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
			/* start calibration pause timer,prevent from contiuous calibration */
//			Timer_Start(CALIB_PAUSE_TIMER,C_PI_TICKS_500MS);
		}
		else if(l_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6e02:	8c0a      	cmp	AL, #10
    6e04:	1d03      	jne	0x6e0c <_handleStateTransition+0x40>
		{
			l_e8ValveState = (uint8)C_STATE_INITIALIZED;
    6e06:	6002      	lod	AL, #2
    6e08:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
		{
		}
	}
	/* initialized -> uninitialized */
	/* permanent electric error,valve block or broken(endstop check) */
	if(l_e8ValveState == (uint8)C_STATE_INITIALIZED)
    6e0c:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    6e10:	8c02      	cmp	AL, #2
    6e12:	1d0b      	jne	0x6e2a <_handleStateTransition+0x5e>
	{
		/* degrade mode caused by non auto-recovery error,motor should be reset to stop state:
		  * 1) mechanical stall(expected/unexpected), 
		  * 2) permanent electric error(coil open/short) 
		  */
		if(((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) != 0u) || 
    6e14:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    6e18:	b401      	and	A, #1
    6e1a:	1d04      	jne	0x6e24 <_handleStateTransition+0x58>
    6e1c:	62d8 00a4 	lod	AL, 0xa4 <_l_u8OBDValveMechanicalError>
    6e20:	b407      	and	A, #7
    6e22:	1903      	je	0x6e2a <_handleStateTransition+0x5e>
			((l_u8OBDValveMechanicalError & (uint8)OBD_VALVE_MECHANICAL_MASK) != 0u))
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6e24:	6000      	lod	AL, #0
    6e26:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
    6e2a:	5401      	ret

00006e2c <_RecoryLastPosition>:
	(void)NVRAM_Write( C_NVRAM_AREA2_ADDR, cv_nvm, 1 );
}

/* read the valve last position when response initialize command */
uint16 RecoryLastPosition(void)
{
    6e2c:	5801      	inc	S, #2
	uint16 cv_nvm[1];

	(void)NVRAM_Read(C_NVRAM_AREA2_ADDR, cv_nvm, 1);
    6e2e:	54ca 0001 	pushw	#1
    6e32:	72ef      	lod	A, S
    6e34:	a0fc      	add	A, #-4
    6e36:	52df      	push	A
    6e38:	72da 103e 	lod	A, #4158
    6e3c:	82db 9214 	callf	0x9214 <_NVRAM_Read>

	return cv_nvm[0];
    6e40:	7205      	lod	A, [S-6]
    6e42:	5c03      	dec	S, #4
}
    6e44:	5403      	ret	#4

00006e46 <_handleStartInitialize>:

void handleStartInitialize(void)
{
//	uint8 ret = Timer_IsExpired(CALIB_PAUSE_TIMER);
	
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6e46:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6e4a:	ac05      	cmp	A, #5
    6e4c:	1d21      	jne	0x6e90 <_handleStartInitialize+0x4a>
	{
		if(l_e8ValveState == (uint8)C_STATE_UNINITIALIZED)
    6e4e:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    6e52:	1d03      	jne	0x6e5a <_handleStartInitialize+0x14>
		{
			l_u16RecoryPos = RecoryLastPosition();
    6e54:	17eb      	call	0x6e2c <_RecoryLastPosition>
    6e56:	52d8 0084 	mov	0x84 <_l_u16RecoryPos>, A
		}

		if(s_CVRequestStruct.m_opening <= C_VALVE_DEF_TRAVEL)
    6e5a:	72d8 0094 	lod	A, 0x94 <_s_CVRequestStruct+0x2>
    6e5e:	aeda 0900 	cmp	A, #2304
    6e62:	1e16      	jug	0x6e90 <_handleStartInitialize+0x4a>
		{
			Timer_Start(FAULT_HOLD_TIMER,C_PI_TICKS_500MS);
    6e64:	54ca 03e8 	pushw	#1000
    6e68:	7008      	lod	A, #8
    6e6a:	82db 9800 	callf	0x9800 <_Timer_Start>
			l_e8CalibrationStep = (uint8)C_CALIB_START;
    6e6e:	6001      	lod	AL, #1
    6e70:	42d8 00a2 	mov	0xa2 <_l_e8CalibrationStep>, AL
			l_u8ValveInitEnds = (uint8)C_VALVE_INIT_END_NONE;
    6e74:	6000      	lod	AL, #0
    6e76:	42d8 00a1 	mov	0xa1 <_l_u8ValveInitEnds>, AL
			/* reset OBD status */
			l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_INDET;
    6e7a:	6080      	lod	AL, #-128
    6e7c:	42d8 00a4 	mov	0xa4 <_l_u8OBDValveMechanicalError>, AL
			l_u8OBDValveElectricError = (uint8)OBD_VALVE_ELECTRIC_INDET;
    6e80:	42d8 00a3 	mov	0xa3 <_l_u8OBDValveElectricError>, AL
			/* reset motor status */
			MotorDriverClearFaultStatus();
    6e84:	82db 890e 	callf	0x890e <_MotorDriverClearFaultStatus>
			l_u8ValueFaultFlag = 0;
    6e88:	6000      	lod	AL, #0
    6e8a:	42d8 008f 	mov	0x8f <_l_u8ValueFaultFlag>, AL
    6e8e:	5c01      	dec	S, #2
    6e90:	5401      	ret

00006e92 <_handleEndstopCheck>:

}

/* stall detection and endstop check */
void handleEndstopCheck(void)
{
    6e92:	5817      	inc	S, #24
	Motor_ControlParams motor_params;
	Motor_RuntimeStatus motor_status;
	
	MotorDriverGetStatus(&motor_status);
    6e94:	72ef      	lod	A, S
    6e96:	a0f4      	add	A, #-12
    6e98:	82db 88f2 	callf	0x88f2 <_MotorDriverGetStatus>

  	if(motor_status.Fault.ST != 0u)	/* stall found? */
    6e9c:	7209      	lod	A, [S-10]
    6e9e:	b6da 03c0 	and	A, #960
    6ea2:	1d01      	jne	0x6ea6 <_handleEndstopCheck+0x14>
    6ea4:	0054      	jmp	0x6f4e <_handleEndstopCheck+0xbc>
  	{
		MotorDriverClearFaultStatus();		/* clear motor stall and stop motor */
    6ea6:	82db 890e 	callf	0x890e <_MotorDriverClearFaultStatus>
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6eaa:	6002      	lod	AL, #2
    6eac:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL

		/* give low endstop check a tolerance:minimum valve range shall be guaranteed */
		if(motor_status.Direction == C_MOTOR_DIR_CCW)
    6eb0:	6203      	lod	AL, [S-4]
    6eb2:	4201      	mov	[S-2], AL
    6eb4:	8c01      	cmp	AL, #1
    6eb6:	1d24      	jne	0x6f00 <_handleEndstopCheck+0x6e>
		{
			if(l_u16PhysicalActualPos > (C_VALVE_ZERO_POS + l_u16PhysicalCalibTravel - C_VALVE_RANGE_MIN))
    6eb8:	72d8 00ec 	lod	A, 0xec <_l_u16PhysicalCalibTravel>
    6ebc:	a2da f890 	add	A, #63632
    6ec0:	7ad8 00e8 	lod	Y, 0xe8 <__data_end>
    6ec4:	eee2      	cmp	Y, A
    6ec6:	1a02      	jule	0x6ecc <_handleEndstopCheck+0x3a>
			{
				/* stall detect within normal valve range */
				l_u8OBDValveMechanicalError = OBD_VALVE_RANGE_BLOCK;
    6ec8:	6201      	lod	AL, [S-2]
    6eca:	0022      	jmp	0x6f10 <_handleEndstopCheck+0x7e>
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BLOCK;
			}
			else if(l_u16PhysicalActualPos < C_VALVE_ZERO_POS)
    6ecc:	eeda 018f 	cmp	Y, #399
    6ed0:	1e0e      	jug	0x6eee <_handleEndstopCheck+0x5c>
			{
				/* GM spec. to report real position,to prevent from overflow */
				l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6ed2:	72da 0190 	lod	A, #400
    6ed6:	52d8 00e8 	mov	0xe8 <__data_end>, A
				l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;
    6eda:	52d8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, A
				/* client-server:post message */
				l_u8MotorControl = C_MOTOR_STOP;
    6ede:	6201      	lod	AL, [S-2]
    6ee0:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
				l_u16PhysicalEndstopPos = C_VALVE_ZERO_POS;
    6ee4:	72da 0190 	lod	A, #400
    6ee8:	52d8 009e 	mov	0x9e <_l_u16PhysicalEndstopPos>, A
    6eec:	0002      	jmp	0x6ef2 <_handleEndstopCheck+0x60>
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
			}
			else
			{
				/* record endstop check position */
				l_u16PhysicalEndstopPos = l_u16PhysicalActualPos;
    6eee:	5ad8 009e 	mov	0x9e <_l_u16PhysicalEndstopPos>, Y
				l_u8EndstopCheckLock = (uint8)C_ENDSTOP_CHECK_LOCK_LO;
    6ef2:	6201      	lod	AL, [S-2]
    6ef4:	42d8 009c 	mov	0x9c <_l_u8EndstopCheckLock>, AL
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
    6ef8:	6000      	lod	AL, #0
    6efa:	42d8 00a4 	mov	0xa4 <_l_u8OBDValveMechanicalError>, AL
    6efe:	5419      	ret	#26
			}
		}
		else if(motor_status.Direction == C_MOTOR_DIR_CW)
    6f00:	6201      	lod	AL, [S-2]
    6f02:	1d25      	jne	0x6f4e <_handleEndstopCheck+0xbc>
		{
			if(l_u16PhysicalActualPos < (C_VALVE_ZERO_POS + C_VALVE_RANGE_MIN))
    6f04:	7ed8 00e8 	lod	X, 0xe8 <__data_end>
    6f08:	2eda 0a8f 	cmp	X, #2703
    6f0c:	1e06      	jug	0x6f1a <_handleEndstopCheck+0x88>
			{
				/* stall detect within normal valve range */
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_RANGE_BLOCK;	
    6f0e:	6001      	lod	AL, #1
    6f10:	42d8 00a4 	mov	0xa4 <_l_u8OBDValveMechanicalError>, AL
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BLOCK;
    6f14:	42d8 008f 	mov	0x8f <_l_u8ValueFaultFlag>, AL
    6f18:	5419      	ret	#26
			}
			else if(l_u16PhysicalActualPos > (C_VALVE_ZERO_POS + l_u16PhysicalCalibTravel))
    6f1a:	72d8 00ec 	lod	A, 0xec <_l_u16PhysicalCalibTravel>
    6f1e:	7ae2      	lod	Y, A
    6f20:	e2da 0190 	add	Y, #400
    6f24:	2ee6      	cmp	X, Y
    6f26:	1a0b      	jule	0x6f3e <_handleEndstopCheck+0xac>
			{
				/* GM spec. to report real position,to prevent from overflow */
				l_u16PhysicalActualPos = C_VALVE_ZERO_POS + l_u16PhysicalCalibTravel;
    6f28:	5ad8 00e8 	mov	0xe8 <__data_end>, Y
				l_u16PhysicalTargetPos = C_VALVE_ZERO_POS + l_u16PhysicalCalibTravel;
    6f2c:	5ad8 00ea 	mov	0xea <_l_u16PhysicalTargetPos>, Y
				/* client-server:post message */
				l_u8MotorControl = C_MOTOR_STOP;
    6f30:	6001      	lod	AL, #1
    6f32:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
				l_u16PhysicalEndstopPos = C_VALVE_ZERO_POS + l_u16PhysicalCalibTravel;
    6f36:	5ad8 009e 	mov	0x9e <_l_u16PhysicalEndstopPos>, Y
				l_u8EndstopCheckLock = (uint8)C_ENDSTOP_CHECK_LOCK_HI;
    6f3a:	6002      	lod	AL, #2
    6f3c:	07db      	jmp	0x6ef4 <_handleEndstopCheck+0x62>
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
			}
			else
			{
				/* record endstop check position */
				l_u16PhysicalEndstopPos = l_u16PhysicalActualPos;
    6f3e:	5ed8 009e 	mov	0x9e <_l_u16PhysicalEndstopPos>, X
				l_u8EndstopCheckLock = C_ENDSTOP_CHECK_LOCK_HI;
    6f42:	6002      	lod	AL, #2
    6f44:	42d8 009c 	mov	0x9c <_l_u8EndstopCheckLock>, AL
				l_u8OBDValveMechanicalError = OBD_VALVE_MECHANICAL_OK;
    6f48:	6000      	lod	AL, #0
    6f4a:	42d8 00a4 	mov	0xa4 <_l_u8OBDValveMechanicalError>, AL
    6f4e:	5419      	ret	#26

00006f50 <_Valve_GotoSleep>:

	}
}

void Valve_GotoSleep(void)
{
    6f50:	5805      	inc	S, #6
		cv_nvm[2] = C_VALVE_DEF_TRAVEL;
		(void)NVRAM_Write( C_NVRAM_AREA2_ADDR, cv_nvm, 3 );
	}
#endif
	/* stop MCU */
	MLX315_GotoSleep();
    6f52:	1252      	call	0x73f8 <_MLX315_GotoSleep>
    6f54:	5407      	ret	#8

00006f56 <_handleSleepEvent>:
		l_u8EmrunStatus = 0u;
	}
}

void handleSleepEvent(void)
{
    6f56:	5809      	inc	S, #10
	Motor_RuntimeStatus motor_status;
	
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_SLEEP)
    6f58:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6f5c:	ac06      	cmp	A, #6
    6f5e:	1d0b      	jne	0x6f76 <_handleSleepEvent+0x20>
	{
		MotorDriverGetStatus(&motor_status);
    6f60:	72ef      	lod	A, S
    6f62:	a0f6      	add	A, #-10
    6f64:	82db 88f2 	callf	0x88f2 <_MotorDriverGetStatus>
		/* conditions:
		  * 1) target position equals current position(motor stop/degrade) 
		  * 2) sleep request
		  */
		if(motor_status.Mode != (uint8)MSM_STOP)
    6f68:	6209      	lod	AL, [S-10]
    6f6a:	1904      	je	0x6f74 <_handleSleepEvent+0x1e>
		{
			/* stop motor first before entering sleep:immediate */
			l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6f6c:	6002      	lod	AL, #2
    6f6e:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
    6f72:	540b      	ret	#12
		}
		else
		{
			Valve_GotoSleep();
    6f74:	17ed      	call	0x6f50 <_Valve_GotoSleep>
    6f76:	540b      	ret	#12

00006f78 <_handleEmergencyRunEvent>:
		}
	}
}

void handleEmergencyRunEvent(void)
{
    6f78:	5815      	inc	S, #22
	Motor_RuntimeStatus motor_status;
	Motor_ControlParams motor_params;
	
	if(s_CVRequestStruct.m_request == C_MOTOR_REQUEST_EMRUN)
    6f7a:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct>
    6f7e:	ac07      	cmp	A, #7
    6f80:	1d0b      	jne	0x6f98 <_handleEmergencyRunEvent+0x20>
			/* stop motor first if not initialized in case the motor is  running:immediate */
//			l_u8MotorControl = C_MOTOR_STOP_ONLY;
//		}
#if _SUPPORT_BUSTIMEOUT_SLEEP
		/* query motor state */
		MotorDriverGetStatus(&motor_status);
    6f82:	72ef      	lod	A, S
    6f84:	a0ea      	add	A, #-22
    6f86:	82db 88f2 	callf	0x88f2 <_MotorDriverGetStatus>
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6f8a:	6002      	lod	AL, #2
    6f8c:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
		if(motor_status.Mode == (uint8)MSM_STOP)
    6f90:	6215      	lod	AL, [S-22]
    6f92:	1d05      	jne	0x6f9e <_handleEmergencyRunEvent+0x26>
		{
			Valve_GotoSleep();
    6f94:	17dd      	call	0x6f50 <_Valve_GotoSleep>
    6f96:	5417      	ret	#24
#endif
	}
	else
	{
		/* emergency run should be triggered only once */
		l_u8EmrunStatus = 0u;
    6f98:	6000      	lod	AL, #0
    6f9a:	42d8 009b 	mov	0x9b <_l_u8EmrunStatus>, AL
    6f9e:	5417      	ret	#24

00006fa0 <_SaveLastPosition>:
	MLX315_GotoSleep();
}

/* save the last position when valve don't move */
void SaveLastPosition(void)
{
    6fa0:	5801      	inc	S, #2
	uint16 cv_nvm[1];

	cv_nvm[0] = l_u16PhysicalActualPos - C_VALVE_ZERO_POS;
    6fa2:	72d8 00e8 	lod	A, 0xe8 <__data_end>
    6fa6:	a2da fe70 	add	A, #65136
    6faa:	5201      	mov	[S-2], A
	(void)NVRAM_Write( C_NVRAM_AREA2_ADDR, cv_nvm, 1 );
    6fac:	54ca 0001 	pushw	#1
    6fb0:	72ef      	lod	A, S
    6fb2:	a0fc      	add	A, #-4
    6fb4:	52df      	push	A
    6fb6:	72da 103e 	lod	A, #4158
    6fba:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    6fbe:	5c03      	dec	S, #4
    6fc0:	5403      	ret	#4

00006fc2 <_handleSynchronizePosition>:
	}
}


void handleSynchronizePosition(void)
{
    6fc2:	581b      	inc	S, #28
	Motor_RuntimeStatus motor_status;
	Motor_ControlParams motor_params;

	/* motor control type,signal to Motor Driver only once */
	if(l_u8MotorControl == C_MOTOR_STOP_ONLY)
    6fc4:	62d8 009a 	lod	AL, 0x9a <_l_u8MotorControl>
    6fc8:	8c02      	cmp	AL, #2
    6fca:	1d0b      	jne	0x6fe2 <_handleSynchronizePosition+0x20>
	{
		/* stop stepper motor:immediate */
		motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6fcc:	7000      	lod	A, #0
    6fce:	5211      	mov	[S-18], A
		motor_params.TgtPos = 0xFFFFu;
    6fd0:	78ff      	lod	Y, #-1
    6fd2:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = 0xFFFFu;
    6fd4:	5a0d      	mov	[S-14], Y
		motor_params.SpdRPM = 0xFFFFu;
    6fd6:	5a07      	mov	[S-8], Y
		MotorDriverSetParams(motor_params);
    6fd8:	580b      	inc	S, #12
    6fda:	7eef      	lod	X, S
    6fdc:	20f4      	add	X, #-12
    6fde:	5e0d      	mov	[S-14], X
    6fe0:	001f      	jmp	0x7020 <_handleSynchronizePosition+0x5e>
	}
	else if(l_u8MotorControl == C_MOTOR_STOP)
    6fe2:	8c01      	cmp	AL, #1
    6fe4:	1d02      	jne	0x6fea <_handleSynchronizePosition+0x28>
	{
		motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6fe6:	7000      	lod	A, #0
    6fe8:	0003      	jmp	0x6ff0 <_handleSynchronizePosition+0x2e>
		motor_params.TgtPos = l_u16PhysicalTargetPos;
		motor_params.ActPos = l_u16PhysicalActualPos;
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
		MotorDriverSetParams(motor_params);
	}
	else if(l_u8MotorControl == C_MOTOR_START)
    6fea:	8c03      	cmp	AL, #3
    6fec:	1d08      	jne	0x6ffe <_handleSynchronizePosition+0x3c>
	{
		/* stop stepper motor:start with new parameters */
		motor_params.MotorCtrl = C_MOTOR_CTRL_START;
    6fee:	7001      	lod	A, #1
    6ff0:	5211      	mov	[S-18], A
		motor_params.TgtPos = l_u16PhysicalTargetPos;
    6ff2:	7ad8 00ea 	lod	Y, 0xea <_l_u16PhysicalTargetPos>
    6ff6:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = l_u16PhysicalActualPos;
    6ff8:	7ed8 00e8 	lod	X, 0xe8 <__data_end>
    6ffc:	0008      	jmp	0x700e <_handleSynchronizePosition+0x4c>
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
		MotorDriverSetParams(motor_params);
	}
	else if(l_u8MotorControl == C_MOTOR_START_ONLY)
    6ffe:	8c04      	cmp	AL, #4
    7000:	1d17      	jne	0x7030 <_handleSynchronizePosition+0x6e>
	{
		/* only update target position */
		motor_params.MotorCtrl = C_MOTOR_CTRL_START;
    7002:	7001      	lod	A, #1
    7004:	5211      	mov	[S-18], A
		motor_params.TgtPos = l_u16PhysicalTargetPos;
    7006:	7ad8 00ea 	lod	Y, 0xea <_l_u16PhysicalTargetPos>
    700a:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = 0xFFFF;
    700c:	7cff      	lod	X, #-1
    700e:	5e0d      	mov	[S-14], X
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
    7010:	72d8 0098 	lod	A, 0x98 <_s_CVRequestStruct+0x6>
    7014:	5207      	mov	[S-8], A
		MotorDriverSetParams(motor_params);
    7016:	580b      	inc	S, #12
    7018:	7aef      	lod	Y, S
    701a:	e0f4      	add	Y, #-12
    701c:	5a0d      	mov	[S-14], Y
    701e:	7ee6      	lod	X, Y
    7020:	7aef      	lod	Y, S
    7022:	e0e2      	add	Y, #-30
    7024:	54e6      	mov	Cx, #6
    7026:	54c6      	movsw	[X++], [Y++]
    7028:	1ffe      	djnz	Cx, 0x7026 <_handleSynchronizePosition+0x64>
    702a:	82db 88ce 	callf	0x88ce <_MotorDriverSetParams>
    702e:	5c0b      	dec	S, #12
	}
	else
	{

	}
	l_u8MotorControl = C_MOTOR_NONE;
    7030:	6000      	lod	AL, #0
    7032:	42d8 009a 	mov	0x9a <_l_u8MotorControl>, AL
	
		/* Motor Driver Status */
	MotorDriverGetStatus(&motor_status);
    7036:	72ef      	lod	A, S
    7038:	a0e4      	add	A, #-28
    703a:	82db 88f2 	callf	0x88f2 <_MotorDriverGetStatus>

	/* position */
	l_u16PhysicalActualPos = motor_status.ActPos;
    703e:	7a17      	lod	Y, [S-24]
    7040:	5ad8 00e8 	mov	0xe8 <__data_end>, Y
	l_u8OBDValveElectricError &= (uint8)(~OBD_VALVE_ELECTRIC_INDET);			/* diagnostic has been done */
    7044:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    7048:	4205      	mov	[S-6], AL
    704a:	947f      	and	AL, #127
    704c:	66e0      	lod	YL, AL
    704e:	42d8 00a3 	mov	0xa3 <_l_u8OBDValveElectricError>, AL
	/* temporary electric error is recoverable */
	if((motor_status.Fault.UV != 0u) || (motor_status.Fault.OV != 0u) ||
    7052:	6219      	lod	AL, [S-26]
    7054:	4204      	mov	[S-5], AL
    7056:	9423      	and	AL, #35
    7058:	1903      	je	0x7060 <_handleSynchronizePosition+0x9e>
		(motor_status.Fault.TS != 0u))
	{
		l_u8OBDValveElectricError |= (uint8)OBD_VALVE_ELECTRIC_TEMP;
    705a:	62e8      	lod	AL, YL
    705c:	8402      	or	AL, #2
    705e:	0002      	jmp	0x7064 <_handleSynchronizePosition+0xa2>
	}
	else
	{
		l_u8OBDValveElectricError &= (uint8)(~OBD_VALVE_ELECTRIC_TEMP);
    7060:	6205      	lod	AL, [S-6]
    7062:	947d      	and	AL, #125
    7064:	42d8 00a3 	mov	0xa3 <_l_u8OBDValveElectricError>, AL
	}
	/* permenant electric error is cleared only by a starting a new initialization */
	if((motor_status.Fault.OPEN != 0u) || (motor_status.Fault.SHORT != 0u))
    7068:	6204      	lod	AL, [S-5]
    706a:	940c      	and	AL, #12
    706c:	1905      	je	0x7078 <_handleSynchronizePosition+0xb6>
	{
		l_u8OBDValveElectricError |= (uint8)OBD_VALVE_ELECTRIC_PERM;
    706e:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    7072:	8401      	or	AL, #1
    7074:	42d8 00a3 	mov	0xa3 <_l_u8OBDValveElectricError>, AL
	}
	/* stall occurence detected,dealing by valve application */
	if(motor_status.Fault.ST != 0u)
    7078:	7219      	lod	A, [S-26]
    707a:	b6da 03c0 	and	A, #960
    707e:	1904      	je	0x7088 <_handleSynchronizePosition+0xc6>
	{
		l_u8StallOcc = TRUE;
    7080:	6001      	lod	AL, #1
    7082:	42d8 00a5 	mov	0xa5 <_l_u8StallOcc>, AL
    7086:	0003      	jmp	0x708e <_handleSynchronizePosition+0xcc>
	}
	else
	{
		l_u8StallOcc = FALSE;
    7088:	6400      	lod	YL, #0
    708a:	46d8 00a5 	mov	0xa5 <_l_u8StallOcc>, YL
	{
		l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_GEAR_DRIFT;
	}
*/
	uint16 temp;
	uint8 wait = Timer_IsExpired(FAULT_HOLD_TIMER);
    708e:	7008      	lod	A, #8
    7090:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    7094:	66e0      	lod	YL, AL
    7096:	5cf6      	usex	Y
	/* fault signal */
	/* NEXT:fault state logic,use indeterminate */
	if( (((l_u8OBDValveMechanicalError != OBD_VALVE_MECHANICAL_OK) && (l_u8OBDValveMechanicalError != OBD_VALVE_MECHANICAL_INDET)) ||
    7098:	62d8 00a4 	lod	AL, 0xa4 <_l_u8OBDValveMechanicalError>
    709c:	1902      	je	0x70a2 <_handleSynchronizePosition+0xe0>
    709e:	8c80      	cmp	AL, #-128
    70a0:	1d08      	jne	0x70b2 <_handleSynchronizePosition+0xf0>
    70a2:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    70a6:	1902      	je	0x70ac <_handleSynchronizePosition+0xea>
    70a8:	8c80      	cmp	AL, #-128
    70aa:	1d03      	jne	0x70b2 <_handleSynchronizePosition+0xf0>
    70ac:	62e8      	lod	AL, YL
    70ae:	8c01      	cmp	AL, #1
    70b0:	1d26      	jne	0x70fe <_handleSynchronizePosition+0x13c>
			((l_u8OBDValveElectricError != OBD_VALVE_ELECTRIC_OK) && (l_u8OBDValveElectricError != OBD_VALVE_ELECTRIC_INDET))) || (wait ==TRUE) )
	{
		if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) == 0x01)
    70b2:	66d8 00a3 	lod	YL, 0xa3 <_l_u8OBDValveElectricError>
    70b6:	72e6      	lod	A, Y
    70b8:	b401      	and	A, #1
    70ba:	190e      	je	0x70d8 <_handleSynchronizePosition+0x116>
		{
			if(motor_status.Fault.SHORT != 0u)
    70bc:	6219      	lod	AL, [S-26]
    70be:	4203      	mov	[S-4], AL
    70c0:	9408      	and	AL, #8
    70c2:	1902      	je	0x70c8 <_handleSynchronizePosition+0x106>
			{
				l_u8OBDValveStatusFault = C_STATUS_FAULT_COIL_SHORT;
    70c4:	6001      	lod	AL, #1
    70c6:	0006      	jmp	0x70d4 <_handleSynchronizePosition+0x112>
			}
			else if(motor_status.Fault.OPEN != 0u)
    70c8:	6203      	lod	AL, [S-4]
    70ca:	9404      	and	AL, #4
    70cc:	1902      	je	0x70d2 <_handleSynchronizePosition+0x110>
			{
				l_u8OBDValveStatusFault = C_STATUS_FAULT_COIL_OPEN;
    70ce:	6002      	lod	AL, #2
    70d0:	0001      	jmp	0x70d4 <_handleSynchronizePosition+0x112>
			}
			else
			{
				l_u8OBDValveStatusFault = C_STATUS_NO_FAULT;
    70d2:	6000      	lod	AL, #0
    70d4:	42d8 008e 	mov	0x8e <_l_u8OBDValveStatusFault>, AL
		else
		{

		}

		if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) != 0x01)
    70d8:	72e6      	lod	A, Y
    70da:	b401      	and	A, #1
    70dc:	1d10      	jne	0x70fe <_handleSynchronizePosition+0x13c>
		{
			if(motor_status.Fault.TS != 0u)
    70de:	6219      	lod	AL, [S-26]
    70e0:	9420      	and	AL, #32
    70e2:	1902      	je	0x70e8 <_handleSynchronizePosition+0x126>
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_OVTEMP_SHUTDOWN;
    70e4:	6003      	lod	AL, #3
    70e6:	0005      	jmp	0x70f2 <_handleSynchronizePosition+0x130>
			else if(l_u8ValueFaultFlag == OBD_VALVE_RANGE_BLOCK)
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_STALL;
			}
#endif
			else if(l_u8ValueFaultFlag == OBD_VALVE_RANGE_BROKEN)
    70e8:	62d8 008f 	lod	AL, 0x8f <_l_u8ValueFaultFlag>
    70ec:	8c02      	cmp	AL, #2
    70ee:	1d04      	jne	0x70f8 <_handleSynchronizePosition+0x136>
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_BROKEN;
    70f0:	6004      	lod	AL, #4
    70f2:	42d8 008e 	mov	0x8e <_l_u8OBDValveStatusFault>, AL
    70f6:	0003      	jmp	0x70fe <_handleSynchronizePosition+0x13c>
			}
			else
			{
				l_u8OBDValveStatusFault = C_STATUS_NO_FAULT;
    70f8:	6400      	lod	YL, #0
    70fa:	46d8 008e 	mov	0x8e <_l_u8OBDValveStatusFault>, YL
		{

		}
	}

	if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_TEMP) == 0x02)
    70fe:	62d8 00a3 	lod	AL, 0xa3 <_l_u8OBDValveElectricError>
    7102:	b402      	and	A, #2
    7104:	190f      	je	0x7124 <_handleSynchronizePosition+0x162>
	{
		if(motor_status.Fault.OV != 0u)
    7106:	6219      	lod	AL, [S-26]
    7108:	4202      	mov	[S-3], AL
    710a:	9402      	and	AL, #2
    710c:	1902      	je	0x7112 <_handleSynchronizePosition+0x150>
		{
			l_u8OBDValveStatusVolt = C_VOLT_OVER;
    710e:	6001      	lod	AL, #1
    7110:	000a      	jmp	0x7126 <_handleSynchronizePosition+0x164>
		}
		else if(motor_status.Fault.UV != 0u)
    7112:	6202      	lod	AL, [S-3]
    7114:	9401      	and	AL, #1
    7116:	1902      	je	0x711c <_handleSynchronizePosition+0x15a>
		{
			l_u8OBDValveStatusVolt = C_VOLT_UNDER;
    7118:	6002      	lod	AL, #2
    711a:	0005      	jmp	0x7126 <_handleSynchronizePosition+0x164>
		}
		else
		{
			l_u8OBDValveStatusVolt = C_VOLT_OK;
    711c:	6400      	lod	YL, #0
    711e:	46d8 008d 	mov	0x8d <_l_u8OBDValveStatusVolt>, YL
    7122:	0003      	jmp	0x712a <_handleSynchronizePosition+0x168>
		}
	}
	else
	{
		l_u8OBDValveStatusVolt = C_VOLT_OK;
    7124:	6000      	lod	AL, #0
    7126:	42d8 008d 	mov	0x8d <_l_u8OBDValveStatusVolt>, AL
	}

	if(motor_status.Fault.TW != 0u)
    712a:	6219      	lod	AL, [S-26]
    712c:	9410      	and	AL, #16
    712e:	1904      	je	0x7138 <_handleSynchronizePosition+0x176>
	{
		l_u8OBDValveStatusOverTempWarn = C_TEMPERATURE_HIGH_WARNING;
    7130:	6001      	lod	AL, #1
    7132:	42d8 008c 	mov	0x8c <_l_u8OBDValveStatusOverTempWarn>, AL
    7136:	0003      	jmp	0x713e <_handleSynchronizePosition+0x17c>
	}
	else
	{
		l_u8OBDValveStatusOverTempWarn = C_TEMPERATURE_OK;
    7138:	6400      	lod	YL, #0
    713a:	46d8 008c 	mov	0x8c <_l_u8OBDValveStatusOverTempWarn>, YL
	}

	/* opening signal */
		/* GM spec. report real position valve opening */
		if(l_e8ValveState == C_STATE_INITIALIZED)
    713e:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    7142:	8c02      	cmp	AL, #2
    7144:	1d0e      	jne	0x7162 <_handleSynchronizePosition+0x1a0>
		{
			if(l_u16PhysicalActualPos <= C_VALVE_ZERO_POS)
    7146:	72d8 00e8 	lod	A, 0xe8 <__data_end>
    714a:	aeda 0190 	cmp	A, #400
    714e:	1a09      	jule	0x7162 <_handleSynchronizePosition+0x1a0>
				{
					temp = C_VALVE_FULL_CLOSE_LIN;
				}
				else if(l_u16PhysicalActualPos >= (C_VALVE_DEF_TRAVEL + C_VALVE_ZERO_POS))
    7150:	aeda 0a8f 	cmp	A, #2703
    7154:	1a03      	jule	0x715c <_handleSynchronizePosition+0x19a>
				{
//					temp = C_VALVE_FULL_OPEN_LIN;
					temp = C_VALVE_DEF_TRAVEL;
    7156:	72da 0900 	lod	A, #2304
    715a:	0004      	jmp	0x7164 <_handleSynchronizePosition+0x1a2>
				}
				else
				{
//					temp = divU16_U32byU16(mulU32_U16byU16(l_u16PhysicalActualPos - C_VALVE_ZERO_POS, C_VALVE_FULL_OPEN_LIN) + ((uint32)l_u16PhysicalCalibTravel / 2U), l_u16PhysicalCalibTravel);
					temp = l_u16PhysicalActualPos - C_VALVE_ZERO_POS;
    715c:	a2da fe70 	add	A, #65136
    7160:	0001      	jmp	0x7164 <_handleSynchronizePosition+0x1a2>
				}
		}
		else
		{
			temp = C_VALVE_RESPONSE_UNKONWNPOS;
    7162:	7000      	lod	A, #0
		}
		l_u16OBDValveStatusPosition = (uint16)temp;
    7164:	52d8 008a 	mov	0x8a <_l_u16OBDValveStatusPosition>, A

	/* motor status */
	/* application provider-consumer interface */
	MotorDriverGetStatus(&motor_status);
    7168:	72ef      	lod	A, S
    716a:	a0e4      	add	A, #-28
    716c:	82db 88f2 	callf	0x88f2 <_MotorDriverGetStatus>
	/* move in process signal */
	if(motor_status.Mode != (uint8)MSM_STOP)
    7170:	621b      	lod	AL, [S-28]
    7172:	1911      	je	0x7196 <_handleSynchronizePosition+0x1d4>
	{
		l_u8OBDValveStatusMove = C_STATUS_MOVE_ACTIVE;
    7174:	6001      	lod	AL, #1
    7176:	42d8 0088 	mov	0x88 <_l_u8OBDValveStatusMove>, AL
		/* torque signal */
		l_u8OBDValveStatusSpeedLevel = (uint8)((s_CVRequestStruct.m_torque / 10u) + 1u);	/* convert physical value to signal */
    717a:	72d8 0096 	lod	A, 0x96 <_s_CVRequestStruct+0x4>
    717e:	4822 cccd 	mulu	YA, A, #52429
    7182:	72e6      	lod	A, Y
    7184:	44b2      	lsr	A, #2
    7186:	4432      	lsr	A
    7188:	8001      	add	AL, #1
    718a:	42d8 0087 	mov	0x87 <_l_u8OBDValveStatusSpeedLevel>, AL

		l_u8SavePosFlag = 1;
    718e:	6401      	lod	YL, #1
    7190:	46d8 0086 	mov	0x86 <_l_u8SavePosFlag>, YL
    7194:	541d      	ret	#30
	}
	else
	{
		l_u8OBDValveStatusMove = C_STATUS_MOVE_IDLE;
    7196:	6000      	lod	AL, #0
    7198:	42d8 0088 	mov	0x88 <_l_u8OBDValveStatusMove>, AL
//		l_u8OBDValveStatusSpeedLevel = C_CTRL_TORQUE_NO;

		if(l_u8SavePosFlag == 1)
    719c:	62d8 0086 	lod	AL, 0x86 <_l_u8SavePosFlag>
    71a0:	8c01      	cmp	AL, #1
    71a2:	1d04      	jne	0x71ac <_handleSynchronizePosition+0x1ea>
		{
			l_u8SavePosFlag = 0;
    71a4:	6400      	lod	YL, #0
    71a6:	46d8 0086 	mov	0x86 <_l_u8SavePosFlag>, YL
			SaveLastPosition();
    71aa:	16fa      	call	0x6fa0 <_SaveLastPosition>
    71ac:	541d      	ret	#30

000071ae <_App_CoolantValveSM>:
	
}

void App_CoolantValveSM(void)
{
	switch(l_e8ValveState)
    71ae:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    71b2:	5cf2      	usex	A
    71b4:	ac01      	cmp	A, #1
    71b6:	1909      	je	0x71ca <_App_CoolantValveSM+0x1c>
    71b8:	1f03      	jsg	0x71c0 <_App_CoolantValveSM+0x12>
    71ba:	ac00      	cmp	A, #0
    71bc:	1904      	je	0x71c6 <_App_CoolantValveSM+0x18>
    71be:	0009      	jmp	0x71d2 <_App_CoolantValveSM+0x24>
    71c0:	ac02      	cmp	A, #2
    71c2:	1905      	je	0x71ce <_App_CoolantValveSM+0x20>
    71c4:	0006      	jmp	0x71d2 <_App_CoolantValveSM+0x24>
    {
    case C_STATE_UNINITIALIZED:
		/* 1)request calibration;2)Motor not in degrade mode? */
		handleStartInitialize();
    71c6:	163f      	call	0x6e46 <_handleStartInitialize>
		break;
    71c8:	0007      	jmp	0x71d8 <_App_CoolantValveSM+0x2a>
	case C_STATE_INITIALIZING:
		handleInitiliazeProcess();
    71ca:	157c      	call	0x6cc4 <_handleInitiliazeProcess>
		break;
    71cc:	0005      	jmp	0x71d8 <_App_CoolantValveSM+0x2a>
	case C_STATE_INITIALIZED:
		/* handle master normal start motor request */
		handleOpeningPosition();
    71ce:	15e6      	call	0x6d9c <_handleOpeningPosition>
		/* 1)endstop broken or valve over range; 
	  	  * 2)endstop unreachable or stall(valve)  
	  	  */
		handleEndstopCheck();
#endif
		break;
    71d0:	0003      	jmp	0x71d8 <_App_CoolantValveSM+0x2a>
	default:
		l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    71d2:	6000      	lod	AL, #0
    71d4:	42d8 00a6 	mov	0xa6 <_l_e8ValveState>, AL
		break;
    }
	/* synchronize motor position to valve physical position */
	handleSynchronizePosition();
    71d8:	16f4      	call	0x6fc2 <_handleSynchronizePosition>
	/* state transition */
	handleStateTransition();
    71da:	15f8      	call	0x6dcc <_handleStateTransition>
	/* handle event */
	/* bus time out:emergency run */
	handleEmergencyRunEvent();
    71dc:	16cd      	call	0x6f78 <_handleEmergencyRunEvent>
	/* goto sleep command */
	handleSleepEvent();
    71de:	16bb      	call	0x6f56 <_handleSleepEvent>
    71e0:	5401      	ret

000071e2 <_HandleActCfrCtrl>:
	return cv_nvm[0];
}

/* Event handler */
void HandleActCfrCtrl(const ACT_CFR_CTRL *pCfrCtrl)
{	
    71e2:	5803      	inc	S, #4
    71e4:	7ee2      	lod	X, A
	uint16 u16TempPos;

	/* move enable and torque defined transmit */
//	if((pCfrCtrl->byMovEn == C_CTRL_MOVE_ENA) && (pCfrCtrl->byTorqueLevel >= C_CTRL_TORQUE_NOMINAL)
//		&& (pCfrCtrl->byTorqueLevel <= C_CTRL_TORQUE_BOOST_100PCT))
	u16TempPos = (uint16)((uint8)pCfrCtrl->PositionRequest_H * 256 + (uint8)pCfrCtrl->PositionRequest_L);
    71e6:	66f9      	lod	YL, [X+1]
    71e8:	72e6      	lod	A, Y
    71ea:	6800      	lod	AH, #0
    71ec:	72e4      	swap	A
    71ee:	66f8      	lod	YL, [X]
    71f0:	5cf6      	usex	Y
    71f2:	e2e2      	add	Y, A
	targetPos = u16TempPos;
    71f4:	5ad8 0082 	mov	0x82 <_targetPos>, Y

	CmdArr[0] = pCfrCtrl->PositionRequest_H;
    71f8:	62f9      	lod	AL, [X+1]
    71fa:	42d8 007a 	mov	0x7a <_CmdArr>, AL
	CmdArr[1] = pCfrCtrl->PositionRequest_L;
    71fe:	62f8      	lod	AL, [X]
    7200:	42d8 007b 	mov	0x7b <_CmdArr+0x1>, AL
	CmdArr[2] = pCfrCtrl->EnableRequest;
    7204:	62fa      	lod	AL, [X+2]
    7206:	9401      	and	AL, #1
    7208:	42d8 007c 	mov	0x7c <_CmdArr+0x2>, AL
	CmdArr[3] = pCfrCtrl->InitRequest;
    720c:	62fa      	lod	AL, [X+2]
    720e:	4432      	lsr	A
    7210:	b407      	and	A, #7
    7212:	42d8 007d 	mov	0x7d <_CmdArr+0x3>, AL

	if((pCfrCtrl->EnableRequest == C_CTRL_MOVE_ENA))	//torque is valid no matter which value qiang
    7216:	62fa      	lod	AL, [X+2]
    7218:	4203      	mov	[S-4], AL
    721a:	9401      	and	AL, #1
    721c:	1925      	je	0x7268 <_HandleActCfrCtrl+0x86>
	{
		if(u16TempPos <= C_VALVE_DEF_TRAVEL)	//position commend is valid;
    721e:	eeda 0900 	cmp	Y, #2304
    7222:	1e2b      	jug	0x727a <_HandleActCfrCtrl+0x98>
		{
			if(pCfrCtrl->InitRequest == C_CTRL_INIT_ENA)
    7224:	6203      	lod	AL, [S-4]
    7226:	940e      	and	AL, #14
    7228:	4201      	mov	[S-2], AL
    722a:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    722e:	4202      	mov	[S-3], AL
    7230:	6201      	lod	AL, [S-2]
    7232:	8c02      	cmp	AL, #2
    7234:	1d14      	jne	0x725e <_HandleActCfrCtrl+0x7c>
			{
				if((l_e8ValveState == C_STATE_UNINITIALIZED) || (l_e8ValveState == C_STATE_INITIALIZING))
    7236:	6202      	lod	AL, [S-3]
    7238:	8c01      	cmp	AL, #1
    723a:	1e07      	jug	0x724a <_HandleActCfrCtrl+0x68>
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_CALIBRATION;
    723c:	7805      	lod	Y, #5
    723e:	5ad8 0092 	mov	0x92 <_s_CVRequestStruct>, Y
					s_CVRequestStruct.m_opening = 0;
    7242:	7000      	lod	A, #0
    7244:	52d8 0094 	mov	0x94 <_s_CVRequestStruct+0x2>, A
    7248:	0005      	jmp	0x7254 <_HandleActCfrCtrl+0x72>
					s_CVRequestStruct.m_speed = NVRAM_SPEED1;		//speed is fixed
				}
				else
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_START;
    724a:	7003      	lod	A, #3
    724c:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
					s_CVRequestStruct.m_opening = u16TempPos;
    7250:	5ad8 0094 	mov	0x94 <_s_CVRequestStruct+0x2>, Y
					s_CVRequestStruct.m_speed = NVRAM_SPEED1;
    7254:	7ada 00c8 	lod	Y, #200
    7258:	5ad8 0098 	mov	0x98 <_s_CVRequestStruct+0x6>, Y
    725c:	5405      	ret	#6
				}
			}
			else
			{
				if((l_e8ValveState == C_STATE_UNINITIALIZED) || (l_e8ValveState == C_STATE_INITIALIZING))
    725e:	6202      	lod	AL, [S-3]
    7260:	8c01      	cmp	AL, #1
    7262:	1e73      	jug	0x724a <_HandleActCfrCtrl+0x68>
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    7264:	7001      	lod	A, #1
    7266:	07f2      	jmp	0x724c <_HandleActCfrCtrl+0x6a>
	}
	else
	{
		/* The actuator shall treat torque values of Not defined and Not used (0xC-0xF) the same way as No Torque Value Requested */
		/* motor request stop */
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    7268:	7001      	lod	A, #1
    726a:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
		s_CVRequestStruct.m_opening = u16TempPos;
    726e:	5ad8 0094 	mov	0x94 <_s_CVRequestStruct+0x2>, Y
//		s_CVRequestStruct.m_torque = C_CTRL_TORQUE_NO;
		s_CVRequestStruct.m_speed = NVRAM_SPEED1;
    7272:	7ada 00c8 	lod	Y, #200
    7276:	5ad8 0098 	mov	0x98 <_s_CVRequestStruct+0x6>, Y
    727a:	5405      	ret	#6

0000727c <_HandleActRfrSta>:
	}
}


void HandleActRfrSta(ACT_RFR_STA *pRfrSta)
{
    727c:	5805      	inc	S, #6
    727e:	7ee2      	lod	X, A

	/* NEXT  fault signal  */
	pRfrSta->CurrentInitState = l_e8ValveState;
    7280:	62d8 00a6 	lod	AL, 0xa6 <_l_e8ValveState>
    7284:	9403      	and	AL, #3
    7286:	4420      	asl	AL
    7288:	4205      	mov	[S-6], AL
    728a:	62f8      	lod	AL, [X]
    728c:	94f9      	and	AL, #-7
    728e:	66e0      	lod	YL, AL
    7290:	6205      	lod	AL, [S-6]
    7292:	86e8      	or	AL, YL
    7294:	66e0      	lod	YL, AL
    7296:	42f8      	mov	[X], AL
	pRfrSta->RunState = l_u8OBDValveStatusMove;
    7298:	62d8 0088 	lod	AL, 0x88 <_l_u8OBDValveStatusMove>
    729c:	9401      	and	AL, #1
    729e:	44a0      	asl	AL, #2
    72a0:	4420      	asl	AL
    72a2:	4204      	mov	[S-5], AL
    72a4:	62e8      	lod	AL, YL
    72a6:	94f7      	and	AL, #-9
    72a8:	66e0      	lod	YL, AL
    72aa:	6204      	lod	AL, [S-5]
    72ac:	86e8      	or	AL, YL
    72ae:	66e0      	lod	YL, AL
    72b0:	42f8      	mov	[X], AL
	pRfrSta->FaultState = l_u8OBDValveStatusFault;
    72b2:	62d8 008e 	lod	AL, 0x8e <_l_u8OBDValveStatusFault>
    72b6:	44a0      	asl	AL, #2
    72b8:	44a0      	asl	AL, #2
    72ba:	4202      	mov	[S-3], AL
    72bc:	62e8      	lod	AL, YL
    72be:	940f      	and	AL, #15
    72c0:	8602      	or	AL, [S-3]
    72c2:	42f8      	mov	[X], AL
	pRfrSta->byVoltStat = l_u8OBDValveStatusVolt;
    72c4:	62d8 008d 	lod	AL, 0x8d <_l_u8OBDValveStatusVolt>
    72c8:	9403      	and	AL, #3
    72ca:	4201      	mov	[S-2], AL
    72cc:	62f9      	lod	AL, [X+1]
    72ce:	94fc      	and	AL, #-4
    72d0:	66e0      	lod	YL, AL
    72d2:	6201      	lod	AL, [S-2]
    72d4:	86e8      	or	AL, YL
    72d6:	66e0      	lod	YL, AL
    72d8:	42f9      	mov	[X+1], AL
	pRfrSta->OverTempWarning = l_u8OBDValveStatusOverTempWarn;
    72da:	62d8 008c 	lod	AL, 0x8c <_l_u8OBDValveStatusOverTempWarn>
    72de:	9403      	and	AL, #3
    72e0:	44a0      	asl	AL, #2
    72e2:	4200      	mov	[S-1], AL
    72e4:	62e8      	lod	AL, YL
    72e6:	94f3      	and	AL, #-13
    72e8:	8600      	or	AL, [S-1]
    72ea:	42f9      	mov	[X+1], AL
	pRfrSta->PositionFbk_L = (uint8)(l_u16OBDValveStatusPosition & 0x00FF);
    72ec:	72d8 008a 	lod	A, 0x8a <_l_u16OBDValveStatusPosition>
    72f0:	42fa      	mov	[X+2], AL
	pRfrSta->PositionFbk_H = (uint8)((l_u16OBDValveStatusPosition & 0xFF00) >> 8);
    72f2:	4afb      	mov	[X+3], AH

	pRfrSta->byReserved4 = (uint8)g_i16ChipTemperature;
    72f4:	72d8 00b6 	lod	A, 0xb6 <__bss_size>
    72f8:	42fc      	mov	[X+4], AL
    72fa:	5407      	ret	#8

000072fc <_HandleNMReq>:
}

/* handle network management event:callback */
void HandleNMReq(uint8 reason)
{
	if(reason == C_ML_REASON_CMD)
    72fc:	8c01      	cmp	AL, #1
    72fe:	1d02      	jne	0x7304 <_HandleNMReq+0x8>
    {
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_SLEEP;
    7300:	7006      	lod	A, #6
    7302:	0003      	jmp	0x730a <_HandleNMReq+0xe>
    }
	else if(reason == C_ML_REASON_TIMEOUT)
    7304:	8c02      	cmp	AL, #2
    7306:	1d04      	jne	0x7310 <_HandleNMReq+0x14>
	{
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_EMRUN;
    7308:	7007      	lod	A, #7
    730a:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
    730e:	5401      	ret
	}
	else if(reason == C_ML_REASON_WAKEUP)
    7310:	8c04      	cmp	AL, #4
    7312:	1d03      	jne	0x731a <_HandleNMReq+0x1e>
	{
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    7314:	7001      	lod	A, #1
    7316:	52d8 0092 	mov	0x92 <_s_CVRequestStruct>, A
    731a:	5401      	ret

0000731c <_MLX315_SystemInit>:
#if WATCHDOG == DISABLED
	WD_CTRL = 0u;															/* Disable digital Watch-dog */
	AWD_CTRL = 0x8000u;														/* Disable analogue Watch-dog */
#endif /* WATCHDOG == DISABLED */
#if WATCHDOG == ENABLED
	WD_T = WatchDog_PeriodOf100ms;											/* Initialise the (Digital) watch-dog comparator to 100ms */
    731c:	60c3      	lod	AL, #-61
    731e:	4282      	mov	io:0x2 <_LinCmnd>, AL
	WD_CTRL = WatchDog_ModeTimer;											/* Define the mode and start the watchdog */
    7320:	6012      	lod	AL, #18
    7322:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
 *
 *****************************************************************************
 */
__MLX_TEXT__  static INLINE void awdg_init (uint8 prescaler, uint8 timer)
{
    AWD_CTRL = ((uint16)(prescaler & 3) << 8) | timer;
    7324:	72da 019c 	lod	A, #412
    7328:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
#endif /* WATCHDOG == ENABLED */

	/* I/O ports  */
#if MCU_ASSP_MODE
	/* IO[5]:HALL, IO[4]:GND-HW connected, IO[3:0]:debug purpose,PMOS not disabled */
	ANA_OUTL |= ASSP;														/* ASSP-mode */
    732a:	72d8 28d4 	lod	A, 0x28d4 <__io__+0xd4>
    732e:	a401      	or	A, #1
    7330:	52d8 28d4 	mov	0x28d4 <__io__+0xd4>, A
	
	ANA_OUTM = (IO5_OUTCFG_SOFT | IO4_OUTCFG_SOFT | IO3_OUTCFG_SOFT | 
    7334:	70ff      	lod	A, #-1
    7336:	52d8 28d6 	mov	0x28d6 <__io__+0xd6>, A
				IO2_OUTCFG_SOFT | IO1_OUTCFG_SOFT | IO0_OUTCFG_SOFT);
	ANA_OUTN = ((uint16)0u << 5u) | ((uint16)0u << 4u) | ((uint16)0u << 3u) | 
    733a:	7000      	lod	A, #0
    733c:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
				((uint16)0u << 2u) | ((uint16)0u << 1u) | ((uint16)0u << 0u);
	IO_DEB = ( IO5_DEBOUNCE_OFF | IO4_DEBOUNCE_OFF | IO3_DEBOUNCE_OFF | 
    7340:	52d8 28c0 	mov	0x28c0 <__io__+0xc0>, A
				IO2_DEBOUNCE_OFF | IO1_DEBOUNCE_OFF | IO0_DEBOUNCE_OFF);
	ANA_OUTF = ( IO3_ENA | IO2_ENA | IO1_ENA | IO0_ENA | 
    7344:	72da 300f 	lod	A, #12303
    7348:	52d8 204e 	mov	0x204e <__ep__+0x104e>, A

#if _SUPPORT_TESTMODE_OFF
	/* ******************************************** */
	/* *** D. (Optional) Chip test-mode disable *** */
	/* ******************************************** */
	CONTROL |= OUTA_WE;														/* Grant access to ANA_OUTx registers */
    734c:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7350:	8408      	or	AL, #8
    7352:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	ANA_OUTA |= TEST_MODE_DIS;												/* Disable test-mode */
    7356:	72d8 201c 	lod	A, 0x201c <__ep__+0x101c>
    735a:	a6da 0080 	or	A, #128
    735e:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
	CONTROL &= ~OUTA_WE;
    7362:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7366:	94f7      	and	AL, #-9
    7368:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
#endif /* MCU_ASSP_MODE */
#endif /* _DEBUG_SPI */
#endif /* _DEBUG */

	/* Disable Driver */
	DRVCFG_DIS_UVWT();
    736c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7370:	b6da fe00 	and	A, #65024
    7374:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	/* Interrupts */
	/* System Tick Timer - Core Timer  */
	PRIO &= ~((uint16)3u << 0u) ;												/* Set CoreTimer priority to 6 (3..6) */
    7378:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    737c:	b4fc      	and	A, #-4
    737e:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(6u - 3u) << 0u);
    7382:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7386:	a403      	or	A, #3
    7388:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_TIMER_IT;
    738c:	7020      	lod	A, #32
    738e:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_TIMER_IT;														/* Enable Timer interrupt */
    7392:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7396:	a420      	or	A, #32
    7398:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	
	/* BLDC motor Commutation/Stepper timer */
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    739c:	7040      	lod	A, #64
    739e:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
	XI0_MASK |= EN_T1_INT4;														/* Enable Timer1, CompareB (T1_INT4) */
    73a2:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    73a6:	a440      	or	A, #64
    73a8:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	PRIO &= ~((uint16)3u << 6u);												/* Set Timer1 priority to 4 (3..6) */
    73ac:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    73b0:	b6da ff3f 	and	A, #65343
    73b4:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(4u - 3u) << 6u);									
    73b8:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    73bc:	a440      	or	A, #64
    73be:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT0_IT;
    73c2:	72da 0100 	lod	A, #256
    73c6:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT0_IT;	
    73ca:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    73ce:	a6da 0100 	or	A, #256
    73d2:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

	/* HALL,diagnostic(OVT,OVC,UV,OV) interrupt */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */							/* EXT4_IT Priority: 3 (3..6) */
	PRIO &= ~((uint16)3u << 14u);												/* EXT4_IT Priority: 3 (3..6) */
    73d6:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    73da:	b6da 3fff 	and	A, #16383
    73de:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(3u - 3u) << 14u);
	PEND = CLR_EXT4_IT;
    73e2:	72da 1000 	lod	A, #4096
    73e6:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    73ea:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    73ee:	a6da 1000 	or	A, #4096
    73f2:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    73f6:	5401      	ret

000073f8 <_MLX315_GotoSleep>:
	 * Wake up is done by resetting the chip. The source of the wake up can be found in ANA_INB.
	 * Note: In case between MLX4_HALT and MLX16_HALT a LIN-bus event happens, the chip will not
	 * enter SLEEP but HALT-mode. To allow a LIN-wakeup, the Analogue Watchdog is set to minimum
	 * period of 100us to allow a chip reset.
	 */
	IO_WU = 0;														/* Disable IO3 wake up */
    73f8:	7000      	lod	A, #0
    73fa:	52d8 28c8 	mov	0x28c8 <__io__+0xc8>, A
	ANA_OUTG &= 0xFF9Eu;											/* Clear Internal WU delay and DIS_GTSM */
    73fe:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    7402:	b49e      	and	A, #-98
    7404:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
	MASK = 0;
    7408:	7000      	lod	A, #0
    740a:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* Go into sleep/halt */
	AWD_CTRL = ((uint16)3u << 8u) | 1u;								/* Set 1:1 prescaler and minimal period; AWD timeout will be 100 us (MMP140813-2) */
    740e:	72da 0301 	lod	A, #769
    7412:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
	MLX4_RESET();
    7414:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7418:	94fe      	and	AL, #-2
    741a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	MLX16_HALT();													/* See MELEXIS doc */
    741e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7422:	8402      	or	AL, #2
    7424:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    7428:	0000      	nop
	/* Chip should reset upon LIN bus changes */
	/* We should never make it to here, as a backup we add a chip reset */
	MLX16_RESET();
    742a:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    742e:	5401      	ret

00007430 <_System_BackgroundTaskInit>:
void System_BackgroundTaskInit(void)
{
  /* *************************************************** */
	/* *** A. Initialise background schedule (Task-ID) *** */
	/* *************************************************** */
	l_u8BackgroundSchedulerTaskID = 0u;
    7430:	6000      	lod	AL, #0
    7432:	42d8 00a7 	mov	0xa7 <_l_u8BackgroundSchedulerTaskID>, AL
    7436:	5401      	ret

00007438 <_FlashBackgroundTest>:
 *				To avoid huge delay, the calculation is split into segments of u16Size
 *				16-bits words. When reaching the Flash-end, the checksum is compared
 *				against first calculated Flash CRC.
 * ****************************************************************************	*/
uint16 FlashBackgroundTest( uint16 u16Size)
{
    7438:	5807      	inc	S, #8
    743a:	7ee2      	lod	X, A
	uint16 u16Result = C_FLASH_CRC_CALCULATING;
    743c:	4cd3      	swap	D
    743e:	48cf      	asl	D, #16
    7440:	4c0a 0002 	addu	D, #2
	static uint16 *pu16Segment = (uint16 *) FLASH_START_ADDR;
	static uint16 u16FlashCRC = 0u;

	if ( u16Size == 0u )
    7444:	ac00      	cmp	A, #0
    7446:	1d06      	jne	0x7454 <_FlashBackgroundTest+0x1c>
	{
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    7448:	72da 4000 	lod	A, #16384
    744c:	52d8 00aa 	mov	0xaa <_l_u8RamPreError+0x2>, A
		return ( u16Result );
    7450:	7002      	lod	A, #2
    7452:	5409      	ret	#10
	}
	if ( pu16Segment == (uint16 *) FLASH_START_ADDR )
    7454:	7ad8 00aa 	lod	Y, 0xaa <_l_u8RamPreError+0x2>
    7458:	eeda 4000 	cmp	Y, #16384
    745c:	1d03      	jne	0x7464 <_FlashBackgroundTest+0x2c>
	{
		u16FlashCRC = 0xFFFFu;													/* Initialise the CRC preset with 0xFFFF */
    745e:	70ff      	lod	A, #-1
    7460:	52d8 00ac 	mov	0xac <_l_u8RamPreError+0x4>, A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
    7464:	72e6      	lod	A, Y
    7466:	a2ee      	add	A, X
    7468:	aeda c000 	cmp	A, #49152
    746c:	1a04      	jule	0x7476 <_FlashBackgroundTest+0x3e>
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
    746e:	72da c000 	lod	A, #49152
    7472:	7ee2      	lod	X, A
    7474:	2ae6      	sub	X, Y
	}
	for ( ; u16Size > 0u; u16Size-- )
    7476:	2c00      	cmp	X, #0
    7478:	1928      	je	0x74ca <_FlashBackgroundTest+0x92>
    747a:	5a03      	mov	[S-4], Y
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
    747c:	7a03      	lod	Y, [S-4]
    747e:	eeda bf4e 	cmp	Y, #48974
    7482:	191d      	je	0x74be <_FlashBackgroundTest+0x86>
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
    7484:	72f0      	lod	A, [Y]
    7486:	5205      	mov	[S-6], A
			for ( u8Count = 16u; u8Count > 0u; u8Count-- )
    7488:	7810      	lod	Y, #16
    748a:	5a07      	mov	[S-8], Y
    748c:	7ad8 00ac 	lod	Y, 0xac <_l_u8RamPreError+0x4>
			{
				uint16 u16XorFlag = u16FlashCRC & 0x8000U;
    7490:	72e6      	lod	A, Y
    7492:	b6da 8000 	and	A, #32768
    7496:	5201      	mov	[S-2], A
				u16FlashCRC = (u16FlashCRC << 1u);
    7498:	4426      	asl	Y
				if ( (u16Data & 0x8000u) != 0u )
    749a:	7205      	lod	A, [S-6]
    749c:	ac00      	cmp	A, #0
    749e:	1e81      	jsge	0x74a2 <_FlashBackgroundTest+0x6a>
				{
					u16FlashCRC++;
    74a0:	e001      	add	Y, #1
				}
				if ( u16XorFlag != 0u)
    74a2:	7201      	lod	A, [S-2]
    74a4:	1902      	je	0x74aa <_FlashBackgroundTest+0x72>
				{
					u16FlashCRC ^= POLY;
    74a6:	feda 1021 	xor	Y, #4129
				}
				u16Data <<= 1u;
    74aa:	7205      	lod	A, [S-6]
    74ac:	4422      	asl	A
    74ae:	5205      	mov	[S-6], A
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
			for ( u8Count = 16u; u8Count > 0u; u8Count-- )
    74b0:	6207      	lod	AL, [S-8]
    74b2:	80ff      	add	AL, #-1
    74b4:	5cf2      	usex	A
    74b6:	5207      	mov	[S-8], A
    74b8:	1d6b      	jne	0x7490 <_FlashBackgroundTest+0x58>
    74ba:	5ad8 00ac 	mov	0xac <_l_u8RamPreError+0x4>, Y
					u16FlashCRC ^= POLY;
				}
				u16Data <<= 1u;
			}
		}
		pu16Segment++;
    74be:	7203      	lod	A, [S-4]
    74c0:	a002      	add	A, #2
    74c2:	5203      	mov	[S-4], A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
	}
	for ( ; u16Size > 0u; u16Size-- )
    74c4:	1bdb      	djnz	X, 0x747c <_FlashBackgroundTest+0x44>
    74c6:	52d8 00aa 	mov	0xaa <_l_u8RamPreError+0x2>, A
			}
		}
		pu16Segment++;
	}

	if ( (uint16) pu16Segment >= FLASH_END_ADDR )
    74ca:	72d8 00aa 	lod	A, 0xaa <_l_u8RamPreError+0x2>
    74ce:	aeda bfff 	cmp	A, #49151
    74d2:	1a14      	jule	0x74fc <_FlashBackgroundTest+0xc4>
	{
		/* CRC fully calculated, check values */
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    74d4:	7ada 4000 	lod	Y, #16384
    74d8:	5ad8 00aa 	mov	0xaa <_l_u8RamPreError+0x2>, Y
		if ( *(uint16 *) FLASH_CRC_ADDR != 0u )									/* Flash/ROM Checksum programmed? */
    74dc:	7ada bf4e 	lod	Y, #48974
    74e0:	72f0      	lod	A, [Y]
    74e2:	190c      	je	0x74fc <_FlashBackgroundTest+0xc4>
		{
			if ( *(uint16 *) FLASH_CRC_ADDR != u16FlashCRC )
    74e4:	aed8 00ac 	cmp	A, 0xac <_l_u8RamPreError+0x4>
    74e8:	1905      	je	0x74f4 <_FlashBackgroundTest+0xbc>
			{
				u16Result = C_FLASH_CRC_FAILED;
    74ea:	4cd3      	swap	D
    74ec:	48cf      	asl	D, #16
    74ee:	4c0a 0000 	addu	D, #0
    74f2:	0004      	jmp	0x74fc <_FlashBackgroundTest+0xc4>
			}
			else
			{
				u16Result = C_FLASH_CRC_OK;
    74f4:	4cd3      	swap	D
    74f6:	48cf      	asl	D, #16
    74f8:	4c0a 0001 	addu	D, #1
			}
		}
	}

	return ( u16Result );
    74fc:	4c88      	mov	A, DL

} /* End of FlashBackgroundTest() */
    74fe:	5409      	ret	#10

00007500 <_System_BackgroundMemoryTest>:
			l_u8RamPreError = FALSE;										/* Error is gone (caused by wrong NVRAM shadow-RAM) */
		}
	}
#endif	/* (MOTOR_PARAMS == MP_NVRAM) || (VALVE_PARAMS == VP_NVRAM) */
	/* Flash CRC runtime check,schedule ID:[1-127],[129-255] */
	if((l_u8BackgroundSchedulerTaskID != 0u) && (l_u8BackgroundSchedulerTaskID != 128u))
    7500:	62d8 00a7 	lod	AL, 0xa7 <_l_u8BackgroundSchedulerTaskID>
    7504:	1919      	je	0x7538 <_System_BackgroundMemoryTest+0x38>
    7506:	8c80      	cmp	AL, #-128
    7508:	1917      	je	0x7538 <_System_BackgroundMemoryTest+0x38>
	{
		if ( (FL_CTRL0 & FL_DETECT) != 0u )									/* MMP150603-2 */
    750a:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    750e:	b401      	and	A, #1
    7510:	1913      	je	0x7538 <_System_BackgroundMemoryTest+0x38>
		{
			if ( FlashBackgroundTest( C_FLASH_SEGMENT_SZ) == (uint16)C_FLASH_CRC_FAILED )	/* Check Flash/ROM Memory Checksum (max. 250us) */
    7512:	7004      	lod	A, #4
    7514:	1791      	call	0x7438 <_FlashBackgroundTest>
    7516:	ac00      	cmp	A, #0
    7518:	1d0f      	jne	0x7538 <_System_BackgroundMemoryTest+0x38>
			{
				SetLastError( (uint8) C_ERR_FLASH_BG);
    751a:	72da 00f9 	lod	A, #249
    751e:	82db 883a 	callf	0x883a <_SetLastError>
				MLX4_RESET();													/* Reset the Mlx4   */
    7522:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7526:	94fe      	and	AL, #-2
    7528:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    752c:	72da 3072 	lod	A, #12402
    7530:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
				MLX16_RESET();													/* Reset the Mlx16  */
    7534:	82db 5914 	callf	0x5914 <_MLX16_RESET>
			}
		}
	}
	l_u8BackgroundSchedulerTaskID++; 
    7538:	62d8 00a7 	lod	AL, 0xa7 <_l_u8BackgroundSchedulerTaskID>
    753c:	8001      	add	AL, #1
    753e:	42d8 00a7 	mov	0xa7 <_l_u8BackgroundSchedulerTaskID>, AL
    7542:	5401      	ret

00007544 <_RamBackgroundTest>:
	/* Use compare instead of CRC-check !! */
	u16Page = u16Page;
	
	return TRUE;

} /* End of RamBackgroundTest() */
    7544:	7001      	lod	A, #1
    7546:	5401      	ret

00007548 <_System_BackgroundIORegTest>:
{
	/* ************************************ */
	/* *** s. Critical peripheral check *** */
	/* ************************************ */
	/* Check: Motor commutation timer disabled */
	if ( (TMR1_CTRL & TMRx_T_EBLK) == 0u )
    7548:	72aa      	lod	A, io:0x2a <__data_dp_end+0x2>
    754a:	b401      	and	A, #1
    754c:	1d0d      	jne	0x7568 <_System_BackgroundIORegTest+0x20>
	{
		/* Communication timer is disabled; Motor is stopped too */
		if ( g_u8MotorStartupMode != (uint8)MSM_STOP )
    754e:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    7552:	1903      	je	0x755a <_System_BackgroundIORegTest+0x12>
		{
			TMR1_CTRL = ((1u * TMRx_DIV0) | (0u * TMRx_MODE0) | TMRx_T_EBLK) | TMRx_START; 				/* Start timer mode 0 */
    7554:	72da 4003 	lod	A, #16387
    7558:	0002      	jmp	0x755e <_System_BackgroundIORegTest+0x16>
		}
		else
		{
			TMR1_CTRL = (1u * TMRx_DIV0) | (0u * TMRx_MODE0) | TMRx_T_EBLK;	/* Timer mode 0, Divider 16 */;								/* Timer mode 0 */
    755a:	72da 4001 	lod	A, #16385
    755e:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
		}
		SetLastError( (uint8) C_ERR_IOREG);
    7560:	72da 00fc 	lod	A, #252
    7564:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check: Administrative timer disabled */
	if ( (TIMER & TMR_EN) == 0u )							
    7568:	7286      	lod	A, io:0x6 <_LinMess2>
    756a:	ac00      	cmp	A, #0
    756c:	1a87      	jsl	0x757c <_System_BackgroundIORegTest+0x34>
	{
		TIMER = TMR_EN | CT_PERIODIC_RATE;
    756e:	72da 81f4 	lod	A, #33268
    7572:	5286      	mov	io:0x6 <_LinMess2>, A
		SetLastError( (uint8) C_ERR_IOREG);
    7574:	72da 00fc 	lod	A, #252
    7578:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check: IRQ-Mask (Respectively: Diagnostics, Timer1, CoreTimer and LIN-Communication */
	if ( (MASK & (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT)) != (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT) )
    757c:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7580:	b6da 1130 	and	A, #4400
    7584:	aeda 1130 	cmp	A, #4400
    7588:	190e      	je	0x75a6 <_System_BackgroundIORegTest+0x5e>
	{
		PEND = (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    758a:	72da 1130 	lod	A, #4400
    758e:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		MASK |= (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7592:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7596:	a6da 1130 	or	A, #4400
    759a:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
		SetLastError( (uint8) C_ERR_IOREG);
    759e:	72da 00fc 	lod	A, #252
    75a2:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check: IRQ-priority (Respectively: Diagnostics, Timer1, CoreTimer) */
	if ( (PRIO & (((uint16)3u << 14u) | ((uint16)3u << 6u) | ((uint16)3u << 0u))) != 
    75a6:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    75aa:	b6da c0c3 	and	A, #49347
    75ae:	ac43      	cmp	A, #67
    75b0:	190f      	je	0x75d0 <_System_BackgroundIORegTest+0x88>
		(/*((uint16)(3-3) << 14) |*/ ((uint16)(4u - 3u) << 6u) | ((uint16)(6u - 3u) << 0u)) )
	{
		PRIO &= ~(((uint16)3u << 14u) | ((uint16)3u << 6u) | ((uint16)3u << 0u));
    75b2:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    75b6:	b6da 3f3c 	and	A, #16188
    75ba:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
		PRIO |=  (/*((uint16)(3u - 3u) << 14u) |*/ ((uint16)(4u - 3u) << 6u) | ((uint16)(6u - 3u) << 0u));
    75be:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    75c2:	a443      	or	A, #67
    75c4:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
		SetLastError( (uint8) C_ERR_IOREG);
    75c8:	72da 00fc 	lod	A, #252
    75cc:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check: 2nd level IRQ Timer1 */
	if ( (XI0_MASK & EN_T1_INT4) == 0u )
    75d0:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    75d4:	b440      	and	A, #64
    75d6:	1d09      	jne	0x75ea <_System_BackgroundIORegTest+0xa2>
	{
		XI0_PEND = EN_T1_INT4;
    75d8:	7040      	lod	A, #64
    75da:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI0_MASK = EN_T1_INT4;
    75de:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
		SetLastError( (uint8) C_ERR_IOREG);
    75e2:	72da 00fc 	lod	A, #252
    75e6:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check: 2nd level IRQ Diagnostics */
	if ( (XI4_MASK & (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV)) != C_DIAG_MASK )
    75ea:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    75ee:	b6da e100 	and	A, #57600
    75f2:	aeda e100 	cmp	A, #57600
    75f6:	190a      	je	0x760c <_System_BackgroundIORegTest+0xc4>
	{
		XI4_PEND = C_DIAG_MASK; 										/* MMP150409-1 */
    75f8:	72da e100 	lod	A, #57600
    75fc:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		XI4_MASK = C_DIAG_MASK; 										/* MMP150409-1 */
    7600:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
		SetLastError( (uint8) C_ERR_IOREG);
    7604:	72da 00fc 	lod	A, #252
    7608:	82db 883a 	callf	0x883a <_SetLastError>
	}
	/* Check:driver check */
	if ( (g_u8MotorStartupMode != (uint8)MSM_STOP) && ((DRVCFG & (DRV_CFG_T|DRV_CFG_W|DRV_CFG_V|DRV_CFG_U)) == 0u) )
    760c:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    7610:	1908      	je	0x7622 <_System_BackgroundIORegTest+0xda>
    7612:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    7616:	8c00      	cmp	AL, #0
    7618:	1d04      	jne	0x7622 <_System_BackgroundIORegTest+0xda>
	{
		/* Driver have been disabled */
		SetLastError( (uint8) C_ERR_IOREG);
    761a:	72da 00fc 	lod	A, #252
    761e:	82db 883a 	callf	0x883a <_SetLastError>
    7622:	5401      	ret

00007624 <_handleNetworkManagement>:
}

/* network management handler */
void handleNetworkManagement(void)
{
	if(l_e8CommState == COMM_STATE_OPERATIONAL)
    7624:	62d8 00b0 	lod	AL, 0xb0 <_l_e8CommState>
    7628:	8c01      	cmp	AL, #1
    762a:	1d0c      	jne	0x7644 <_handleNetworkManagement+0x20>
	{
		if(l_u8NMEventPending != C_ML_REASON_NO)
    762c:	62d8 00af 	lod	AL, 0xaf <_l_u8NMEventPending>
    7630:	191c      	je	0x766a <_handleNetworkManagement+0x46>
		{
			HandleNMReq(l_u8NMEventPending);
    7632:	5cf2      	usex	A
    7634:	1663      	call	0x72fc <_HandleNMReq>
			l_u8NMEventPending = C_ML_REASON_NO;
    7636:	6000      	lod	AL, #0
    7638:	42d8 00af 	mov	0xaf <_l_u8NMEventPending>, AL
			l_e8CommState = COMM_STATE_STOPPED;
    763c:	6002      	lod	AL, #2
    763e:	42d8 00b0 	mov	0xb0 <_l_e8CommState>, AL
    7642:	5401      	ret
		}
	}
	else if(l_e8CommState == COMM_STATE_STOPPED)
    7644:	8c02      	cmp	AL, #2
    7646:	1d11      	jne	0x766a <_handleNetworkManagement+0x46>
	{
		
		if((ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0u))
    7648:	7009      	lod	A, #9
    764a:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    764e:	acff      	cmp	A, #-1
    7650:	190c      	je	0x766a <_handleNetworkManagement+0x46>
    7652:	62d8 0198 	lod	AL, 0x198 <_LinStatus>
    7656:	b401      	and	A, #1
    7658:	1908      	je	0x766a <_handleNetworkManagement+0x46>
		{
			/* MLX4 has detected a SYNC field */
			(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    765a:	7008      	lod	A, #8
    765c:	82db 5b5c 	callf	0x5b5c <_ml_GetState>

			l_e8CommState = COMM_STATE_OPERATIONAL;
    7660:	6001      	lod	AL, #1
    7662:	42d8 00b0 	mov	0xb0 <_l_e8CommState>, AL
			HandleNMReq(C_ML_REASON_WAKEUP);
    7666:	7004      	lod	A, #4
    7668:	1649      	call	0x72fc <_HandleNMReq>
    766a:	5401      	ret

0000766c <_CalcProtectionBits>:
/* **************************************************************************** *
 * CalcProtectionBits
 *
 * **************************************************************************** */
uint8 CalcProtectionBits( uint8 byFrameID)
{
    766c:	5807      	inc	S, #8
	uint8 u8Temp;
	
	u8Temp = ((byFrameID & 0x01u) ^ ((byFrameID & 0x02u) >> 1u) ^ ((byFrameID & 0x04u) >> 2u) ^ ((byFrameID & 0x10u) >> 4u));
    766e:	7ee2      	lod	X, A
    7670:	9401      	and	AL, #1
    7672:	7aee      	lod	Y, X
    7674:	f402      	and	Y, #2
    7676:	4436      	lsr	Y
    7678:	9ee8      	xor	AL, YL
    767a:	7aee      	lod	Y, X
    767c:	f404      	and	Y, #4
    767e:	44b6      	lsr	Y, #2
    7680:	9ee8      	xor	AL, YL
    7682:	7aee      	lod	Y, X
    7684:	f410      	and	Y, #16
    7686:	44b6      	lsr	Y, #2
    7688:	44b6      	lsr	Y, #2
	byFrameID |= (u8Temp > 0u) ? 0x40u : 0x00u;
    768a:	8ee8      	cmp	AL, YL
    768c:	1902      	je	0x7692 <_CalcProtectionBits+0x26>
    768e:	2440      	or	X, #64
    7690:	0003      	jmp	0x7698 <_CalcProtectionBits+0x2c>
    7692:	72ee      	lod	A, X
    7694:	5cf2      	usex	A
    7696:	7ee2      	lod	X, A
	u8Temp = (((byFrameID & 0x02u) >> 1u) ^ ((byFrameID & 0x08u) >> 3u) ^ ((byFrameID & 0x10u) >> 4u) ^ ((byFrameID & 0x20u) >> 5u));
    7698:	7aee      	lod	Y, X
    769a:	f402      	and	Y, #2
    769c:	4436      	lsr	Y
    769e:	72ee      	lod	A, X
    76a0:	b408      	and	A, #8
    76a2:	44b2      	lsr	A, #2
    76a4:	4432      	lsr	A
    76a6:	9ee8      	xor	AL, YL
    76a8:	7aee      	lod	Y, X
    76aa:	f410      	and	Y, #16
    76ac:	44b6      	lsr	Y, #2
    76ae:	44b6      	lsr	Y, #2
    76b0:	9ee8      	xor	AL, YL
    76b2:	7aee      	lod	Y, X
    76b4:	f420      	and	Y, #32
    76b6:	44b6      	lsr	Y, #2
    76b8:	44b6      	lsr	Y, #2
    76ba:	4436      	lsr	Y
	byFrameID |= (u8Temp > 0u) ? 0x00u : 0x80u;
    76bc:	8ee8      	cmp	AL, YL
    76be:	1904      	je	0x76c8 <_CalcProtectionBits+0x5c>
    76c0:	72ee      	lod	A, X
    76c2:	5cf2      	usex	A
    76c4:	7ee2      	lod	X, A
    76c6:	0002      	jmp	0x76cc <_CalcProtectionBits+0x60>
    76c8:	26da 0080 	or	X, #128
	
	return ( byFrameID );
} /* End of CalcProtectionBits() */
    76cc:	72ee      	lod	A, X
    76ce:	5409      	ret	#10

000076d0 <_LIN_Init>:
 *
 * Initialise LIN communication interface.
 * Default start-up, at 9600 Baud
 * ****************************************************************************	*/
void LIN_Init(void)
{
    76d0:	5803      	inc	S, #4
	uint16 buf[2];
	uint8 temp;
	
	/* Initialise LIN Communication */
	LIN_XCFG &= ~DISTERM;														/* Enable LIN pull-up resistor (MMP150811-2) */
    76d2:	72a0      	lod	A, io:0x20 <_g_u16StartupDelay>
    76d4:	b4fb      	and	A, #-5
    76d6:	52a0      	mov	io:0x20 <_g_u16StartupDelay>, A
	(void) ml_InitLinModule();													/* Initialise the LIN module */
    76d8:	82db 5dce 	callf	0x5dce <_ml_InitLinModule>
#if _SUPPORT_AUTO_BAUDRATE == FALSE
	/* Fixed baudrate */
	(void) ml_SetBaudRate( (ml_uint8) LIN_BR_PRESCALER, (ml_uint8)LIN_BR_DIV);	/* Program the baudrate : default startup : 9600baud @ 20.0 Mhz	*/
#else
	/* Auto baudrate only on first LIN frame */
	(void) ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);						/* MMP141215-1 */
    76dc:	7000      	lod	A, #0
    76de:	82db 5b8e 	callf	0x5b8e <_ml_SetAutoBaudRateMode>
#endif

	/* Setup LIN options, including slew-rate */
	(void) ml_SetOptions( 1U,													/* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    76e2:	54ca 0000 	pushw	#0
    76e6:	54ca 0001 	pushw	#1
    76ea:	54ca 0000 	pushw	#0
    76ee:	7001      	lod	A, #1
    76f0:	82db 5ad4 	callf	0x5ad4 <_ml_SetOptions>
						  ML_LIGHTSLEEP);										/* SleepMode: light-sleep mode */

#if (LIN_BR < 12000)
	(void) ml_SetSlewRate( ML_SLEWLOW);
#else /* (LIN_BR < 10000) */
	(void) ml_SetSlewRate( ML_SLEWHIGH);
    76f4:	7000      	lod	A, #0
    76f6:	82db 5acc 	callf	0x5acc <_ml_SetSlewRate>

#if defined (HAS_LIN_NEXT_FRAME_ID)
	(void) ml_EnableFilter( 0);													/* Enable filter */
#endif

	(void)NVRAM_Read(0x1000,buf,2);
    76fa:	54ca 0002 	pushw	#2
    76fe:	72ef      	lod	A, S
    7700:	a0f4      	add	A, #-12
    7702:	52df      	push	A
    7704:	72da 1000 	lod	A, #4096
    7708:	82db 9214 	callf	0x9214 <_NVRAM_Read>
		(void) ml_AssignFrameToMessageID( MSG_STATUS, byFrameID);
	}
#endif

#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
	temp = (uint8)(buf[0] & 0x00FFu);
    770c:	7e0d      	lod	X, [S-14]
    770e:	7aee      	lod	Y, X
    7710:	5cf6      	usex	Y
    if ( (temp & 0x80u) == 0x00u )
    7712:	5c09      	dec	S, #10
    7714:	62e8      	lod	AL, YL
    7716:	8c00      	cmp	AL, #0
    7718:	1a89      	jsl	0x772c <_LIN_Init+0x5c>
	{
		g_u8NAD = temp;
    771a:	451b      	mov	dp:0x1b <_g_u8NAD>, YL
		g_u8ControlFrameID = (uint8)(buf[0] >> 8u);
    771c:	7eec      	swap	X
    771e:	36da 00ff 	and	X, #255
    7722:	72ee      	lod	A, X
    7724:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
		g_u8StatusFrameID = (uint8)(buf[1] & 0x00FFu);
    7726:	7201      	lod	A, [S-2]
    7728:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
    772a:	0015      	jmp	0x7756 <_LIN_Init+0x86>
	}
	else
	{
        g_u8NAD = C_DEFAULT_NAD;
    772c:	6016      	lod	AL, #22
    772e:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
		g_u8ControlFrameID = mlxACT_CTRL;
    7730:	60c4      	lod	AL, #-60
    7732:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
		g_u8StatusFrameID  = mlxACT_STATUS;
    7734:	6085      	lod	AL, #-123
    7736:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL

		/* store to NVM */
		buf[0] = (uint8)C_DEFAULT_NAD;
		buf[0] |= ((uint16)mlxACT_CTRL << 8u);
    7738:	72da c416 	lod	A, #50198
    773c:	5203      	mov	[S-4], A
		buf[1] = (uint8)mlxACT_STATUS;
		buf[1] |= ((uint16)C_VARIANT << 8u);
    773e:	7085      	lod	A, #-123
    7740:	5201      	mov	[S-2], A
		(void)NVRAM_Write(0x1000, buf, 2);
    7742:	54ca 0002 	pushw	#2
    7746:	72ef      	lod	A, S
    7748:	a0fa      	add	A, #-6
    774a:	52df      	push	A
    774c:	72da 1000 	lod	A, #4096
    7750:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    7754:	5c03      	dec	S, #4
	}
	/* dynamic bound message id to frame id */
	(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7756:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7758:	5cf2      	usex	A
    775a:	52df      	push	A
    775c:	7001      	lod	A, #1
    775e:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
	(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7762:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7764:	5cf2      	usex	A
    7766:	52df      	push	A
    7768:	7000      	lod	A, #0
    776a:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
#endif

    (void) ml_SetLoaderNAD( g_u8NAD);											/* Setup NAD at power-up */
    776e:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7770:	5cf2      	usex	A
    7772:	82db 5d94 	callf	0x5d94 <_ml_SetLoaderNAD>

	(void) ml_Connect();
    7776:	82db 5b96 	callf	0x5b96 <_ml_Connect>

	/* Check chip-state for LIN-command RESET, to setup diagnostic-response */
	if ( bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET )
    777a:	72d8 01a0 	lod	A, 0x1a0 <_bistResetInfo>
    777e:	5c03      	dec	S, #4
    7780:	aeda 3072 	cmp	A, #12402
    7784:	1d03      	jne	0x778c <_LIN_Init+0xbc>
	{
#if ((LINPROT & LINXX) == LIN2J)
		RfrDiagReset();														/* Prepare a diagnostics response reply */
#endif
		bistResetInfo = C_CHIP_STATE_COLD_START;
    7786:	7000      	lod	A, #0
    7788:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
    778c:	5405      	ret	#6

0000778e <_handleMLX4StatusSupervisor>:
{
	/* ********************** */
	/* *** n. MLX4 status *** */
	/* ********************** */
	/* MLX4 LIN-Bus activity check  */
	if ( (ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0u) )
    778e:	7009      	lod	A, #9
    7790:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    7794:	acff      	cmp	A, #-1
    7796:	190d      	je	0x77b2 <_handleMLX4StatusSupervisor+0x24>
    7798:	62d8 0198 	lod	AL, 0x198 <_LinStatus>
    779c:	b401      	and	A, #1
    779e:	1909      	je	0x77b2 <_handleMLX4StatusSupervisor+0x24>
	{
		/* MLX4 has detected a SYNC field */
		Timer_Start(MLX4_STATUS_CHECK_TIMER, C_MLX4_STATE_TIMEOUT);
    77a0:	54ca 03e8 	pushw	#1000
    77a4:	7000      	lod	A, #0
    77a6:	82db 9800 	callf	0x9800 <_Timer_Start>
		(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    77aa:	7008      	lod	A, #8
    77ac:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    77b0:	5c01      	dec	S, #2
	}

	if ( Timer_IsExpired(MLX4_STATUS_CHECK_TIMER) == TRUE ) /* MMP130905-4 - End */
    77b2:	7000      	lod	A, #0
    77b4:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    77b8:	8c01      	cmp	AL, #1
    77ba:	1d2f      	jne	0x781a <_handleMLX4StatusSupervisor+0x8c>
	{
		/* Didn't receive MLX4 LIN command and/or data-request in the last period, or need immediate reset */
		Timer_Start(MLX4_STATUS_CHECK_TIMER, C_MLX4_STATE_TIMEOUT);						/* MLX4 State check counter reset; MLX4 still active */
    77bc:	54ca 03e8 	pushw	#1000
    77c0:	7000      	lod	A, #0
    77c2:	82db 9800 	callf	0x9800 <_Timer_Start>
		if ( ml_GetState( ML_NOT_CLEAR) == ml_stINVALID )		/* MMP130811-1 */
    77c6:	7009      	lod	A, #9
    77c8:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    77cc:	5c01      	dec	S, #2
    77ce:	acff      	cmp	A, #-1
    77d0:	1d21      	jne	0x7814 <_handleMLX4StatusSupervisor+0x86>
		{
			l_u8Mlx4ErrorStateOcc++;
    77d2:	62d8 00ae 	lod	AL, 0xae <_l_u8Mlx4ErrorStateOcc>
    77d6:	8001      	add	AL, #1
    77d8:	42d8 00ae 	mov	0xae <_l_u8Mlx4ErrorStateOcc>, AL
			if ( l_u8Mlx4ErrorStateOcc >= (uint8) C_MLX4_STATE_ERROR_THRSHLD )
    77dc:	8c03      	cmp	AL, #3
    77de:	1a1d      	jule	0x781a <_handleMLX4StatusSupervisor+0x8c>
			{
				/* Signal Error; Reset MLX4 */
				MLX4_RESET();
    77e0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77e4:	94fe      	and	AL, #-2
    77e6:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				NOP();
    77ea:	0000      	nop
				NOP();
    77ec:	0000      	nop
				NOP();
    77ee:	0000      	nop
				MLX4_START();
    77f0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77f4:	8401      	or	AL, #1
    77f6:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				if ( (l_u8Mlx4ErrorStateOcc & (uint8)C_MLX4_STATE_NOT_LOGGED) == 0u )	/* MMP131126-1 */
    77fa:	62d8 00ae 	lod	AL, 0xae <_l_u8Mlx4ErrorStateOcc>
    77fe:	b440      	and	A, #64
    7800:	1d04      	jne	0x780a <_handleMLX4StatusSupervisor+0x7c>
				{
					SetLastError( (uint8) C_ERR_MLX4_RESTART);
    7802:	72da 00fa 	lod	A, #250
    7806:	82db 883a 	callf	0x883a <_SetLastError>
				}
				LIN_Init();										/* Re-initialise LIN interface w/o changing position */
    780a:	1762      	call	0x76d0 <_LIN_Init>
				l_u8Mlx4ErrorStateOcc = 0;
    780c:	6000      	lod	AL, #0
    780e:	42d8 00ae 	mov	0xae <_l_u8Mlx4ErrorStateOcc>, AL
    7812:	5401      	ret
			}
		}
		else
		{
			l_u8Mlx4ErrorStateOcc = 0;
    7814:	6000      	lod	AL, #0
    7816:	42d8 00ae 	mov	0xae <_l_u8Mlx4ErrorStateOcc>, AL
    781a:	5401      	ret

0000781c <_mlu_ApplicationStop>:
 *  LIN API event: mlu_ApplicationStop
 * ****************************************************************************	*/
ml_Status mlu_ApplicationStop(void)
{
	/* Disable all IRQ's, except LIN */
	XI0_MASK = 0;
    781c:	7000      	lod	A, #0
    781e:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	XI1_MASK = 0;
    7822:	52d8 202c 	mov	0x202c <__ep__+0x102c>, A
	XI2_MASK = 0;
    7826:	52d8 202e 	mov	0x202e <__ep__+0x102e>, A
	XI3_MASK = 0;
    782a:	52d8 2030 	mov	0x2030 <__ep__+0x1030>, A
	XI4_MASK = 0;
    782e:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	MASK = EN_M4_SHE_IT;														/* Disable all interrupts, except LIN M4_SHE_IT */
    7832:	7010      	lod	A, #16
    7834:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

	return ( ML_SUCCESS );														/* Return that the application has stopped */
} /* End of mlu_ApplicationStop */
    7838:	7000      	lod	A, #0
    783a:	5401      	ret

0000783c <_mlu_DataRequest>:

/* ****************************************************************************	*
 *  LIN API event: Data Request (slave TX)
 * ****************************************************************************	*/
void mlu_DataRequest( ml_MessageID MessageIndex) 
{
    783c:	5801      	inc	S, #2
	/* Data requested; No longer Bus time-out */

	if ( MessageIndex == (uint8) mlxRFR_DIAG )
    783e:	8c11      	cmp	AL, #17
    7840:	1d1e      	jne	0x787e <_mlu_DataRequest+0x42>
	{
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
		if(Timer_IsExpired(DIAG_RESPONSE_TIMER) == TRUE)
    7842:	7006      	lod	A, #6
    7844:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    7848:	8c01      	cmp	AL, #1
    784a:	1d05      	jne	0x7856 <_mlu_DataRequest+0x1a>
		{
			if ( g_u8BufferOutID == QR_RFR_DIAG )								/* Pending response type: Diagnostic */
    784c:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    784e:	8c07      	cmp	AL, #7
    7850:	1d02      	jne	0x7856 <_mlu_DataRequest+0x1a>
			{
				g_u8BufferOutID = (uint8) QR_INVALID;							/* Invalidate Diagnostics response */
    7852:	60ff      	lod	AL, #-1
    7854:	4118      	mov	dp:0x18 <__data_dp_start>, AL
			}
		}
#endif	

		/* Diagnostic */
		if ( g_u8BufferOutID == (uint8) QR_RFR_DIAG ) /* diagnostic buffer ready? */
    7856:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    7858:	8c07      	cmp	AL, #7
    785a:	1d0e      	jne	0x7878 <_mlu_DataRequest+0x3c>
			/* Copy g_DiagResponse to LinFrameDataBuffer */
			RFR_DIAG *pDiag = &g_DiagResponse;
			uint16 *src = (uint16 *) pDiag;
			uint16 *dst = (uint16 *) LinFrameDataBuffer;
			
			dst[0] = src[0];
    785c:	7130      	lod	A, dp:0x30 <_g_DiagResponse>
    785e:	5152      	mov	dp:0x52 <_LinFrameDataBuffer>, A
			dst[1] = src[1];
    7860:	7132      	lod	A, dp:0x32 <_g_DiagResponse+0x2>
    7862:	5154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, A
			dst[2] = src[2];
    7864:	7134      	lod	A, dp:0x34 <_g_DiagResponse+0x4>
    7866:	5156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, A
			dst[3] = src[3];
    7868:	7136      	lod	A, dp:0x36 <_g_DiagResponse+0x6>
    786a:	5158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, A

			(void) ml_DataReady( ML_END_OF_TX_DISABLED);
    786c:	7000      	lod	A, #0
    786e:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
			g_u8BufferOutID = (uint8) QR_INVALID;								/* Invalidate LIN output buffer */
    7872:	60ff      	lod	AL, #-1
    7874:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7876:	5403      	ret	#4
		}
		else
		{
			(void) ml_DiscardFrame();											/* Output buffer response doesn't match requested response */
    7878:	82db 5aea 	callf	0x5aea <_ml_DiscardFrame>
    787c:	5403      	ret	#4
		}
	}
	else if ( MessageIndex == (uint8) MSG_STATUS )
    787e:	ac00      	cmp	A, #0
    7880:	1d0e      	jne	0x789e <_mlu_DataRequest+0x62>
	{
		ACT_RFR_STA *pRfrSta = (ACT_RFR_STA *)LinFrameDataBuffer;
		/* Status AGS */
		HandleActRfrSta(pRfrSta);
    7882:	72da 0052 	lod	A, #82
    7886:	14fa      	call	0x727c <_HandleActRfrSta>
		/* LIN communication error */
		pRfrSta->ResponseError = l_u8ErrorCommunication;
    7888:	62d8 00b1 	lod	AL, 0xb1 <_l_u8ErrorCommunication>
    788c:	9401      	and	AL, #1
    788e:	4201      	mov	[S-2], AL
    7890:	6152      	lod	AL, dp:0x52 <_LinFrameDataBuffer>
    7892:	94fe      	and	AL, #-2
    7894:	8601      	or	AL, [S-2]
    7896:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
		(void) ml_DataReady( ML_END_OF_TX_ENABLED);
    7898:	7001      	lod	A, #1
    789a:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
    789e:	5403      	ret	#4

000078a0 <_mlu_DataTransmitted>:
/* ****************************************************************************	*
 *  LIN API event: mlu_DataTransmitted
 * ****************************************************************************	*/
void mlu_DataTransmitted(void) 
{
    l_u8ErrorCommunication = FALSE;
    78a0:	6000      	lod	AL, #0
    78a2:	42d8 00b1 	mov	0xb1 <_l_u8ErrorCommunication>, AL
    78a6:	5401      	ret

000078a8 <_LIN2x_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The 
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2x_ErrorHandling( ml_LinError Error)
{
    78a8:	5803      	inc	S, #4
    78aa:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) LinProtectedID & 0x3Fu;							/* Get Frame-ID without parity bits */
    78ac:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    78ae:	b43f      	and	A, #63
    78b0:	5203      	mov	[S-4], A
	
	if ( (u8FrameID == (uint8) ML_MRF_ID) && 
    78b2:	8c3c      	cmp	AL, #60
    78b4:	1d06      	jne	0x78c2 <_LIN2x_ErrorHandling+0x1a>
    78b6:	ec06      	cmp	Y, #6
    78b8:	1902      	je	0x78be <_LIN2x_ErrorHandling+0x16>
    78ba:	ec04      	cmp	Y, #4
    78bc:	1d02      	jne	0x78c2 <_LIN2x_ErrorHandling+0x1a>
	{
		/*
		 * Abort Diagnostic communication with corrupted Diagnostic request
		 * Checked by LIN2.1 CT test case 13.2.2
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    78be:	60ff      	lod	AL, #-1
    78c0:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	{
		/* Do NOT set response_error bit, because error occurred in a header */
	}
	
	/* Checksum error:checksum error in message received */
	if( Error == ml_erCheckSum )
    78c2:	ec04      	cmp	Y, #4
    78c4:	1904      	je	0x78ce <_LIN2x_ErrorHandling+0x26>
			l_u8ErrorCommunication = TRUE;
		}
	}

	/* Transmit cycle data collision:data collision during transmit cycle */
	if( Error == ml_erBit )
    78c6:	ec05      	cmp	Y, #5
    78c8:	190d      	je	0x78e4 <_LIN2x_ErrorHandling+0x3c>
	{
		l_u8ErrorCommunication = TRUE;
	}
	
	/* Error data framing:start or stop bit error while receiving data */
	if( Error == ml_erDataFraming )
    78ca:	ec06      	cmp	Y, #6
    78cc:	1d09      	jne	0x78e0 <_LIN2x_ErrorHandling+0x38>
	{
		if( (u8FrameID == (uint8) ML_MRF_ID) || (u8FrameID == (g_u8ControlFrameID & 0x3Fu)) )
    78ce:	6203      	lod	AL, [S-4]
    78d0:	8c3c      	cmp	AL, #60
    78d2:	1908      	je	0x78e4 <_LIN2x_ErrorHandling+0x3c>
    78d4:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    78d6:	b43f      	and	A, #63
    78d8:	7a03      	lod	Y, [S-4]
    78da:	eee2      	cmp	Y, A
    78dc:	1d14      	jne	0x7906 <_LIN2x_ErrorHandling+0x5e>
    78de:	0002      	jmp	0x78e4 <_LIN2x_ErrorHandling+0x3c>
			l_u8ErrorCommunication = TRUE;
		}
	}

	/* Error during STOP bit transmission */
	if( Error == ml_erStopBitTX )
    78e0:	ec10      	cmp	Y, #16
    78e2:	1d04      	jne	0x78ec <_LIN2x_ErrorHandling+0x44>
	{
		l_u8ErrorCommunication = TRUE;
    78e4:	6001      	lod	AL, #1
    78e6:	42d8 00b1 	mov	0xb1 <_l_u8ErrorCommunication>, AL
    78ea:	5405      	ret	#6
	{
	
	}
	
	/* Unexpectable break:A header has been detected inside a frame */
	if(Error == ml_erBreakDetected)
    78ec:	ec0c      	cmp	Y, #12
    78ee:	1d0b      	jne	0x7906 <_LIN2x_ErrorHandling+0x5e>
	{
		/* LCT3.8:INCOMPLETE FRAME RECEPTION */
		if( (u8FrameID == (uint8) ML_MRF_ID) || (u8FrameID == (g_u8ControlFrameID & 0x3Fu)) )
    78f0:	6203      	lod	AL, [S-4]
    78f2:	8c3c      	cmp	AL, #60
    78f4:	1905      	je	0x7900 <_LIN2x_ErrorHandling+0x58>
    78f6:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    78f8:	b43f      	and	A, #63
    78fa:	7a03      	lod	Y, [S-4]
    78fc:	eee2      	cmp	Y, A
    78fe:	1d03      	jne	0x7906 <_LIN2x_ErrorHandling+0x5e>
		{
			l_u8ErrorCommunication = TRUE;
    7900:	6001      	lod	AL, #1
    7902:	42d8 00b1 	mov	0xb1 <_l_u8ErrorCommunication>, AL
    7906:	5405      	ret	#6

00007908 <_mlu_ErrorDetected>:

/* ****************************************************************************	*
 *  LIN API event: mlu_ErrorDetected
 * ****************************************************************************	*/
void mlu_ErrorDetected( ml_LinError Error)
{
    7908:	5801      	inc	S, #2
    790a:	5201      	mov	[S-2], A
	SetLastError( (uint8) C_ERR_LIN_COMM | ((uint8)Error & 0x1Fu));
    790c:	a6da 0080 	or	A, #128
    7910:	b6da 009f 	and	A, #159
    7914:	82db 883a 	callf	0x883a <_SetLastError>
#if ((LINPROT & LINXX) == LIN2J)
     LIN2J_ErrorHandling(Error);
#endif
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
    LIN2x_ErrorHandling(Error);
    7918:	7201      	lod	A, [S-2]
    791a:	17c6      	call	0x78a8 <_LIN2x_ErrorHandling>
    791c:	5403      	ret	#4

0000791e <_mlu_LinSleepMode>:
{
	/*
	 * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
	 * and does not report it via mlu_MessageReceived event.
	 */
	if ( (Reason == ml_reasonMaster) || (Reason == ml_reasonCommand) )			/* MMP130918-1 */
    791e:	7ae2      	lod	Y, A
    7920:	a0ff      	add	A, #-1
    7922:	ac01      	cmp	A, #1
    7924:	1e03      	jug	0x792c <_mlu_LinSleepMode+0xe>
	{
		l_u8NMEventPending = C_ML_REASON_CMD;       
    7926:	6001      	lod	AL, #1
    7928:	42d8 00af 	mov	0xaf <_l_u8NMEventPending>, AL
	}

	if ( (Reason == ml_reasonTimeOut) || (Reason == ml_reasonTimeOutDominant) )
    792c:	72e6      	lod	A, Y
    792e:	a0fa      	add	A, #-6
    7930:	ac01      	cmp	A, #1
    7932:	1e07      	jug	0x7942 <_mlu_LinSleepMode+0x24>
		/*
		 * LIN bus was inactive for 4 seconds without receiving an explicit
		 * "Go-to-Sleep frame". This can be considered as a failure of the Master or
		 * PHY layer. Slave can enter limp-home mode.
		 */
		l_u8NMEventPending = C_ML_REASON_TIMEOUT; 
    7934:	6002      	lod	AL, #2
    7936:	42d8 00af 	mov	0xaf <_l_u8NMEventPending>, AL
        SetLastError( (uint8) C_ERR_LIN_BUS_TIMEOUT);
    793a:	72da 00bf 	lod	A, #191
    793e:	82db 883a 	callf	0x883a <_SetLastError>
    7942:	5401      	ret

00007944 <_mlu_MessageReceived>:

/* ****************************************************************************	*
 *  LIN API event: MessageReceived (slave RX)
 * ****************************************************************************	*/
void mlu_MessageReceived( ml_MessageID MessageIndex)
{
    7944:	7ae2      	lod	Y, A
    if ( l_u8LinInFrameBufState != (uint8) C_LIN_IN_FULL )
    7946:	62d8 00b2 	lod	AL, 0xb2 <_l_u8LinInFrameBufState>
    794a:	8c01      	cmp	AL, #1
    794c:	190f      	je	0x796c <_mlu_MessageReceived+0x28>
	{
		/* Buffer is either empty or message is postpone (overwrite allowed) */
		l_u8LinInFrameMsgID = MessageIndex;
    794e:	46d8 00ee 	mov	0xee <_l_u8LinInFrameMsgID>, YL

		/* LIN In-frame buffer to a Copy LIN In-frame buffer */
		{
			uint16 *pu16Source = (uint16 *) LinFrameDataBuffer;
			uint16 *pu16Target = (uint16 *) &g_LinCmdFrameBuffer;
			*pu16Target = *pu16Source;
    7952:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    7954:	5128      	mov	dp:0x28 <__data_dp_end>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7956:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    7958:	512a      	mov	dp:0x2a <__data_dp_end+0x2>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    795a:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    795c:	512c      	mov	dp:0x2c <__data_dp_end+0x4>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    795e:	7158      	lod	A, dp:0x58 <_LinFrameDataBuffer+0x6>
    7960:	512e      	mov	dp:0x2e <__data_dp_end+0x6>, A
		}
		l_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7962:	6001      	lod	AL, #1
    7964:	42d8 00b2 	mov	0xb2 <_l_u8LinInFrameBufState>, AL
	
		LinFrame[0] = 0x00;														/* Clear NAD address */
    7968:	6000      	lod	AL, #0
    796a:	4108      	mov	dp:0x8 <__bist_stat_size>, AL
    796c:	5401      	ret

0000796e <_LIN2J_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2J_ErrorHandling( ml_LinError Error)
{
    796e:	5803      	inc	S, #4
    7970:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) (LinProtectedID & 0x3Fu);							/* Get Frame-ID without parity bits */
    7972:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    7974:	b43f      	and	A, #63
    7976:	5203      	mov	[S-4], A
	
	if ( (u8FrameID == (uint8) ML_MRF_ID) && ((Error == ml_erDataFraming) || (Error == ml_erCheckSum)) )
    7978:	8c3c      	cmp	AL, #60
    797a:	1d06      	jne	0x7988 <_LIN2J_ErrorHandling+0x1a>
    797c:	ec06      	cmp	Y, #6
    797e:	1902      	je	0x7984 <_LIN2J_ErrorHandling+0x16>
    7980:	ec04      	cmp	Y, #4
    7982:	1d02      	jne	0x7988 <_LIN2J_ErrorHandling+0x1a>
	{
		/*
		 * LCT13.2.2:Abort Diagnostic communication with corrupted Diagnostic request
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    7984:	60ff      	lod	AL, #-1
    7986:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	}

	/* ---- ml_erLinModuleReset -------------------------------------------- */
	if ( Error == ml_erLinModuleReset )
    7988:	ec02      	cmp	Y, #2
    798a:	1921      	je	0x79ce <_LIN2J_ErrorHandling+0x60>
	{
		/* Non-recoverable failure has occurred in the LIN Module */
		/* switch to System Mode and reinitialise LIN module */
	}
	/* ---- ml_erIdParity -------------------------------------------------- */
	else if ( (Error == ml_erIdParity) || (Error == ml_erIdFraming ) )
    798c:	ec03      	cmp	Y, #3
    798e:	1916      	je	0x79bc <_LIN2J_ErrorHandling+0x4e>
    7990:	ec07      	cmp	Y, #7
    7992:	1914      	je	0x79bc <_LIN2J_ErrorHandling+0x4e>
		/* Parity error in ID field received -or- Stop bit error of the ID field (SAE_J2602-2: 5.4.1.1) */
		{
			l_u8ErrorCommunication = TRUE;
		}
	}
	else if ( (Error == ml_erCheckSum) || (Error == ml_erDataFraming) )
    7994:	ec04      	cmp	Y, #4
    7996:	1902      	je	0x799c <_LIN2J_ErrorHandling+0x2e>
    7998:	ec06      	cmp	Y, #6
    799a:	1d0e      	jne	0x79b8 <_LIN2J_ErrorHandling+0x4a>
	{
		/* Checksum error in message received -OR- Stop or Start bit error while receiving data (SAE_J2602-2: 5.4.1.2 & 5.4.1.3) */
		if ( (u8FrameID == (((g_u8NAD & 0x0Fu) << 2u) + 0x00u)) ||				/* CONTROL_MSG */
    799c:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
    799e:	72e6      	lod	A, Y
    79a0:	b40f      	and	A, #15
    79a2:	44a2      	asl	A, #2
    79a4:	7e03      	lod	X, [S-4]
    79a6:	2ee2      	cmp	X, A
    79a8:	1909      	je	0x79bc <_LIN2J_ErrorHandling+0x4e>
    79aa:	6203      	lod	AL, [S-4]
    79ac:	8c3c      	cmp	AL, #60
    79ae:	1d0f      	jne	0x79ce <_LIN2J_ErrorHandling+0x60>
    79b0:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
    79b2:	8ee8      	cmp	AL, YL
    79b4:	1d0c      	jne	0x79ce <_LIN2J_ErrorHandling+0x60>
    79b6:	0002      	jmp	0x79bc <_LIN2J_ErrorHandling+0x4e>
			 ((u8FrameID == (uint8)ML_MRF_ID) && (LinFrame[0] == g_u8NAD)) )	/* DIAG_3C_MSG */
		{
			l_u8ErrorCommunication = TRUE;
		}
	}
	else if ( Error == ml_erSynchField )
    79b8:	ec08      	cmp	Y, #8
    79ba:	1d04      	jne	0x79c4 <_LIN2J_ErrorHandling+0x56>
	{
		/* Sync field timing error;
		 * In case: BufferOutID is QR_RFR_DIAG, and NAD is real-NAD (SAE_J2602-2: 5.4.1.4) 
		 * 5.4.1.4 if auto baudrate , status byte is ignored 
		 */
		l_u8ErrorCommunication = TRUE;
    79bc:	6001      	lod	AL, #1
    79be:	42d8 00b1 	mov	0xb1 <_l_u8ErrorCommunication>, AL
    79c2:	5405      	ret	#6
	}
	else if ( Error == ml_erBit )
    79c4:	ec05      	cmp	Y, #5
    79c6:	1d03      	jne	0x79ce <_LIN2J_ErrorHandling+0x60>
	{
		/* Data collision during the transmit cycle (SAE_J2602-2: 5.4.1.5) */
		l_u8ErrorCommunication = TRUE;
    79c8:	6001      	lod	AL, #1
    79ca:	42d8 00b1 	mov	0xb1 <_l_u8ErrorCommunication>, AL
    79ce:	5405      	ret	#6

000079d0 <_handleLinInMsg>:
/* ****************************************************************************	*
 *  LIN API: HandleLinInMsg 
 * ****************************************************************************	*/
void handleLinInMsg( void)
{
	if(l_u8LinInFrameBufState != C_LIN_IN_FREE)
    79d0:	62d8 00b2 	lod	AL, 0xb2 <_l_u8LinInFrameBufState>
    79d4:	191e      	je	0x7a12 <_handleLinInMsg+0x42>
    {
		if ( l_u8LinInFrameBufState == (uint8) C_LIN_IN_POSTPONE )
    79d6:	8c02      	cmp	AL, #2
    79d8:	1d03      	jne	0x79e0 <_handleLinInMsg+0x10>
		{
			/* Last message postponed; Try again (without overwritten by LIN message ISR */
			l_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    79da:	6001      	lod	AL, #1
    79dc:	42d8 00b2 	mov	0xb2 <_l_u8LinInFrameBufState>, AL
		}

	    /* LIN 2.x,LIN 2.x_J2602 */
		if ( l_u8LinInFrameMsgID == (uint8) mlxDFR_DIAG )
    79e0:	62d8 00ee 	lod	AL, 0xee <_l_u8LinInFrameMsgID>
    79e4:	8c10      	cmp	AL, #16
    79e6:	1d08      	jne	0x79f8 <_handleLinInMsg+0x28>
		{
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
       		Timer_Start(DIAG_RESPONSE_TIMER, (uint16)PI_TICKS_PER_SECOND);
    79e8:	54ca 07d0 	pushw	#2000
    79ec:	7006      	lod	A, #6
    79ee:	82db 9800 	callf	0x9800 <_Timer_Start>
#endif
			/* Diagnostic request frame */
			HandleDfrDiag();
    79f2:	135f      	call	0x80b2 <_HandleDfrDiag>
    79f4:	5c01      	dec	S, #2
    79f6:	0006      	jmp	0x7a04 <_handleLinInMsg+0x34>
		}
		else if ( l_u8LinInFrameMsgID == (uint8) MSG_CONTROL )
    79f8:	8c01      	cmp	AL, #1
    79fa:	1d04      	jne	0x7a04 <_handleLinInMsg+0x34>
		{
			/* Control */
			HandleActCfrCtrl((ACT_CFR_CTRL *)&g_LinCmdFrameBuffer);
    79fc:	72da 0028 	lod	A, #40
    7a00:	82db 71e2 	callf	0x71e2 <_HandleActCfrCtrl>
		else
		{
			
		}

		if ( l_u8LinInFrameBufState != (uint8) C_LIN_IN_POSTPONE )
    7a04:	62d8 00b2 	lod	AL, 0xb2 <_l_u8LinInFrameBufState>
    7a08:	8c02      	cmp	AL, #2
    7a0a:	1903      	je	0x7a12 <_handleLinInMsg+0x42>
		{
			/* LIN Message is handled; Release LIN message buffer */
			l_u8LinInFrameBufState = (uint8) C_LIN_IN_FREE;
    7a0c:	6000      	lod	AL, #0
    7a0e:	42d8 00b2 	mov	0xb2 <_l_u8LinInFrameBufState>, AL
    7a12:	5401      	ret

00007a14 <_LIN_MainFunction>:
/* public function implementation */

/* LIN communication software component */
void LIN_MainFunction(void)
{
	switch(l_e8CommState)
    7a14:	62d8 00b0 	lod	AL, 0xb0 <_l_e8CommState>
    7a18:	5cf2      	usex	A
    7a1a:	ac01      	cmp	A, #1
    7a1c:	1909      	je	0x7a30 <_LIN_MainFunction+0x1c>
    7a1e:	1f03      	jsg	0x7a26 <_LIN_MainFunction+0x12>
    7a20:	ac00      	cmp	A, #0
    7a22:	1904      	je	0x7a2c <_LIN_MainFunction+0x18>
    7a24:	0008      	jmp	0x7a36 <_LIN_MainFunction+0x22>
    7a26:	ac02      	cmp	A, #2
    7a28:	1909      	je	0x7a3c <_LIN_MainFunction+0x28>
    7a2a:	0005      	jmp	0x7a36 <_LIN_MainFunction+0x22>
	{
	case COMM_STATE_PREOPERATIONAL:     /* Pre-operational */
		l_e8CommState = COMM_STATE_OPERATIONAL;
    7a2c:	6001      	lod	AL, #1
    7a2e:	0004      	jmp	0x7a38 <_LIN_MainFunction+0x24>
		break;
	case COMM_STATE_OPERATIONAL:    	/* operational */
		handleLinInMsg();
    7a30:	17cf      	call	0x79d0 <_handleLinInMsg>
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK
		handleMLX4StatusSupervisor();
    7a32:	16ad      	call	0x778e <_handleMLX4StatusSupervisor>
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK */
		break;
    7a34:	0003      	jmp	0x7a3c <_LIN_MainFunction+0x28>
	case COMM_STATE_STOPPED:    		/* sleep/timeout */
		
		break;
	default:
		l_e8CommState = COMM_STATE_PREOPERATIONAL;
    7a36:	6000      	lod	AL, #0
    7a38:	42d8 00b0 	mov	0xb0 <_l_e8CommState>, AL
		break;
	}

	handleNetworkManagement();
    7a3c:	15f3      	call	0x7624 <_handleNetworkManagement>
    7a3e:	5401      	ret

00007a40 <_mlu_AutoAddressingStep>:
/* ****************************************************************************	*
 *  LIN API event: mlu_AutoAddressingStep
 * ****************************************************************************	*/
void mlu_AutoAddressingStep( ml_uint8 StepNumber)
{
	(void) StepNumber; 
    7a40:	5401      	ret

00007a42 <_SetupDiagResponse>:

/* ****************************************************************************	*
 * SetupDiagResponse
 * ****************************************************************************	*/
void SetupDiagResponse( uint8 u8NAD, uint8 u8SID, uint8 u8ResponseCode)
{
    7a42:	5801      	inc	S, #2
    7a44:	6605      	lod	YL, [S-6]
    7a46:	5cf6      	usex	Y
    7a48:	5a01      	mov	[S-2], Y
    7a4a:	6607      	lod	YL, [S-8]
    7a4c:	5cf6      	usex	Y
	g_DiagResponse.byNAD = u8NAD;
    7a4e:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
	if ( u8ResponseCode == (uint8) C_ERRCODE_POSITIVE_RESPONSE )
    7a50:	1d09      	jne	0x7a64 <_SetupDiagResponse+0x22>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x01|  SID | Reserved | Reserved | Reserved | Reserved | Reserved |
		 *	|  NAD  |     | |0x40|   0xFF   |   0xFF   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_REASSIGN_NAD;
    7a52:	6001      	lod	AL, #1
    7a54:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (u8SID | C_RSID_OK);
    7a56:	6201      	lod	AL, [S-2]
    7a58:	8440      	or	AL, #64
    7a5a:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    7a5c:	60ff      	lod	AL, #-1
    7a5e:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    7a60:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    7a62:	0007      	jmp	0x7a72 <_SetupDiagResponse+0x30>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x03| 0x7F | Requested| Response | Reserved | Reserved | Reserved |
		 *	|  NAD  |     |      |    SID   |   Code   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_NOK;
    7a64:	6003      	lod	AL, #3
    7a66:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_RSID_NOK;
    7a68:	607f      	lod	AL, #127
    7a6a:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = u8SID;
    7a6c:	6201      	lod	AL, [S-2]
    7a6e:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = u8ResponseCode;
    7a70:	4534      	mov	dp:0x34 <_g_DiagResponse+0x4>, YL
	}

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    7a72:	6007      	lod	AL, #7
    7a74:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7a76:	5403      	ret	#4

00007a78 <_CheckSupplier>:
/* ****************************************************************************	*
 * CheckSupplier
 * ****************************************************************************	*/
uint16 CheckSupplier( uint16 const u16SupplierID)
{
	uint16 u16Result = FALSE;
    7a78:	7800      	lod	Y, #0
	if ( (u16SupplierID == (uint16) C_WILDCARD_SUPPLIER_ID)
    7a7a:	aeda 7fff 	cmp	A, #32767
    7a7e:	1902      	je	0x7a84 <_CheckSupplier+0xc>
    7a80:	ac13      	cmp	A, #19
    7a82:	1d01      	jne	0x7a86 <_CheckSupplier+0xe>
		|| (u16SupplierID == (uint16)C_SUPPLIER_ID) )
	{
		u16Result = TRUE;
    7a84:	7801      	lod	Y, #1
	}
	return ( u16Result );
} /* End of CheckSupplier() */
    7a86:	72e6      	lod	A, Y
    7a88:	5401      	ret

00007a8a <_ValidSupplierFunctionID>:
 * Pre:		Pointer to address of supplier and function ID
 * Post:	FALSE: Incorrect supplier and/or function ID
 *			TRUE: Correct supplier and function ID
 * ****************************************************************************	*/
uint16 ValidSupplierFunctionID( uint16 const u16SupplierID, uint16 const u16FunctionID )
{
    7a8a:	7a03      	lod	Y, [S-4]
	uint16 u16Result = FALSE;
    7a8c:	7c00      	lod	X, #0
	if ( ((u16SupplierID == C_SUPPLIER_ID)
    7a8e:	ac13      	cmp	A, #19
    7a90:	1903      	je	0x7a98 <_ValidSupplierFunctionID+0xe>
    7a92:	aeda 7fff 	cmp	A, #32767
    7a96:	1d05      	jne	0x7aa2 <_ValidSupplierFunctionID+0x18>
    7a98:	ec16      	cmp	Y, #22
    7a9a:	1902      	je	0x7aa0 <_ValidSupplierFunctionID+0x16>
    7a9c:	ecff      	cmp	Y, #-1
    7a9e:	1d01      	jne	0x7aa2 <_ValidSupplierFunctionID+0x18>
		|| (u16SupplierID == C_WILDCARD_SUPPLIER_ID)) &&
		((u16FunctionID == C_FUNCTION_ID)
		|| (u16FunctionID == C_WILDCARD_FUNCTION_ID)) )
	{
		u16Result = TRUE;
    7aa0:	7c01      	lod	X, #1
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */
    7aa2:	72ee      	lod	A, X
    7aa4:	5401      	ret

00007aa6 <_handleReassignNAD>:
} /* End of StoreD2to5() */



void handleReassignNAD(const DFR_DIAG *pDiag)
{
    7aa6:	5803      	inc	S, #4
    7aa8:	5203      	mov	[S-4], A
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xB0 | Supplier | Supplier | Function | Function |  New NAD |
	 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |          |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 */
	if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8u)) != FALSE)
    7aaa:	7a03      	lod	Y, [S-4]
    7aac:	62f5      	lod	AL, [Y+5]
    7aae:	5cf2      	usex	A
    7ab0:	7ee2      	lod	X, A
    7ab2:	6af6      	lod	AH, [Y+6]
    7ab4:	6000      	lod	AL, #0
    7ab6:	26e2      	or	X, A
    7ab8:	6af4      	lod	AH, [Y+4]
    7aba:	62f3      	lod	AL, [Y+3]
    7abc:	5edf      	push	X
    7abe:	17e5      	call	0x7a8a <_ValidSupplierFunctionID>
    7ac0:	5c01      	dec	S, #2
    7ac2:	ac00      	cmp	A, #0
    7ac4:	190b      	je	0x7adc <_handleReassignNAD+0x36>
		buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
		(void)NVRAM_Write(0x1000, buf, 2);
#endif
			/* J2602,LIN2.0:automatic save confifuration */
#if ( (LINPROT & LINXX) == LIN21 )
		g_u8NAD = pDiag->byD5;
    7ac6:	7a03      	lod	Y, [S-4]
    7ac8:	62f7      	lod	AL, [Y+7]
    7aca:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
		SetupDiagResponse( C_DEFAULT_NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
    7acc:	54ca 0000 	pushw	#0
    7ad0:	62f2      	lod	AL, [Y+2]
    7ad2:	5cf2      	usex	A
    7ad4:	52df      	push	A
    7ad6:	7016      	lod	A, #22
    7ad8:	17b4      	call	0x7a42 <_SetupDiagResponse>
    7ada:	5c03      	dec	S, #4
    7adc:	5405      	ret	#6

00007ade <_handleAssignFrameID>:

	}
}

void handleAssignFrameID(const DFR_DIAG *pDiag)
{
    7ade:	5805      	inc	S, #6
    7ae0:	5201      	mov	[S-2], A
	 *	| NAD | 0x06| 0xB1| Supplier | Supplier |  Message |  Message |   Frame  |
	 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 * Only LIN 2.0 (Obsolete in LIN 2.1)
	 */
	if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u)) != FALSE )
    7ae2:	7a01      	lod	Y, [S-2]
    7ae4:	6af4      	lod	AH, [Y+4]
    7ae6:	62f3      	lod	AL, [Y+3]
    7ae8:	17c7      	call	0x7a78 <_CheckSupplier>
    7aea:	ac00      	cmp	A, #0
    7aec:	1d01      	jne	0x7af0 <_handleAssignFrameID+0x12>
    7aee:	0042      	jmp	0x7b74 <_handleAssignFrameID+0x96>
	{
		wMessageID = ((uint16) pDiag->byD4 << 8u) | ((uint16) pDiag->byD3);
    7af0:	7e01      	lod	X, [S-2]
    7af2:	6efe      	lod	YH, [X+6]
    7af4:	66fd      	lod	YL, [X+5]
		if ( wMessageID == MSG_CONTROL )
    7af6:	ec01      	cmp	Y, #1
    7af8:	1d09      	jne	0x7b0c <_handleAssignFrameID+0x2e>
		{
			g_u8ControlFrameID = pDiag->byD5;
    7afa:	62ff      	lod	AL, [X+7]
    7afc:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
			(void) ml_Disconnect();
    7afe:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7b02:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7b04:	5cf2      	usex	A
    7b06:	52df      	push	A
    7b08:	7001      	lod	A, #1
    7b0a:	000b      	jmp	0x7b22 <_handleAssignFrameID+0x44>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
			(void)NVRAM_Write(0x1000, buf, 2);
		}
		else if ( wMessageID == MSG_STATUS )
    7b0c:	ec00      	cmp	Y, #0
    7b0e:	1d28      	jne	0x7b60 <_handleAssignFrameID+0x82>
		{
			g_u8StatusFrameID = pDiag->byD5;
    7b10:	7a01      	lod	Y, [S-2]
    7b12:	62f7      	lod	AL, [Y+7]
    7b14:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
			(void) ml_Disconnect();
    7b16:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7b1a:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7b1c:	5cf2      	usex	A
    7b1e:	52df      	push	A
    7b20:	7000      	lod	A, #0
    7b22:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
			(void) ml_Connect();
    7b26:	82db 5b96 	callf	0x5b96 <_ml_Connect>
			/* Status Frame-ID changed */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
    7b2a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b2c:	5cf2      	usex	A
    7b2e:	54ca 0000 	pushw	#0
    7b32:	7e05      	lod	X, [S-6]
    7b34:	66fa      	lod	YL, [X+2]
    7b36:	5cf6      	usex	Y
    7b38:	5adf      	push	Y
    7b3a:	1783      	call	0x7a42 <_SetupDiagResponse>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7b3c:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7b3e:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b40:	520b      	mov	[S-12], A
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7b42:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7b44:	a6da ff00 	or	A, #65280
    7b48:	5209      	mov	[S-10], A
			(void)NVRAM_Write(0x1000, buf, 2);
    7b4a:	54ca 0002 	pushw	#2
    7b4e:	72ef      	lod	A, S
    7b50:	a0f2      	add	A, #-14
    7b52:	52df      	push	A
    7b54:	72da 1000 	lod	A, #4096
    7b58:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    7b5c:	5c09      	dec	S, #10
    7b5e:	5407      	ret	#8
		}
		else
		{
			/* Wrong Message-ID */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    7b60:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b62:	5cf2      	usex	A
    7b64:	54ca 0012 	pushw	#18
    7b68:	7e03      	lod	X, [S-4]
    7b6a:	66fa      	lod	YL, [X+2]
    7b6c:	5cf6      	usex	Y
    7b6e:	5adf      	push	Y
    7b70:	1768      	call	0x7a42 <_SetupDiagResponse>
    7b72:	5c03      	dec	S, #4
    7b74:	5407      	ret	#8

00007b76 <_handleReadByIdentifier>:
		}
	}
}

void handleReadByIdentifier(const DFR_DIAG *pDiag)
{
    7b76:	5803      	inc	S, #4
    7b78:	5203      	mov	[S-4], A
	 * (0x40-0xFF: Reserved)
	 * (M) = Mandatory
	 * (O) = Optional
	 * (U) = User defined
	 */
	if ( ValidSupplierFunctionID( (pDiag->byD2) | ((uint16)(pDiag->byD3) << 8u), (pDiag->byD4) | ((uint16)(pDiag->byD5) << 8u)) != FALSE )
    7b7a:	7a03      	lod	Y, [S-4]
    7b7c:	62f6      	lod	AL, [Y+6]
    7b7e:	5cf2      	usex	A
    7b80:	7ee2      	lod	X, A
    7b82:	6af7      	lod	AH, [Y+7]
    7b84:	6000      	lod	AL, #0
    7b86:	26e2      	or	X, A
    7b88:	6af5      	lod	AH, [Y+5]
    7b8a:	62f4      	lod	AL, [Y+4]
    7b8c:	5edf      	push	X
    7b8e:	177d      	call	0x7a8a <_ValidSupplierFunctionID>
    7b90:	5c01      	dec	S, #2
    7b92:	ac00      	cmp	A, #0
    7b94:	1d01      	jne	0x7b98 <_handleReadByIdentifier+0x22>
    7b96:	0082      	jmp	0x7c9c <_handleReadByIdentifier+0x126>
	{
		if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    7b98:	7e03      	lod	X, [S-4]
    7b9a:	62fb      	lod	AL, [X+3]
    7b9c:	1d0b      	jne	0x7bb4 <_handleReadByIdentifier+0x3e>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xF2 | Supplier | Supplier | Function | Function |  Variant |
			 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7b9e:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ba0:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
    7ba2:	6006      	lod	AL, #6
    7ba4:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7ba6:	60f2      	lod	AL, #-14
    7ba8:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* (MMP160613-3) */
    7baa:	60ff      	lod	AL, #-1
    7bac:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7bae:	7013      	lod	A, #19
    7bb0:	7816      	lod	Y, #22
    7bb2:	0026      	jmp	0x7c00 <_handleReadByIdentifier+0x8a>
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* (MMP160613-3) */
			StoreD1to4( C_SUPPLIER_ID, C_FUNCTION_ID);					/* Supplier & Function-ID */
		}
		else if ( pDiag->byD1 == C_SERIAL_NR_ID )
    7bb4:	8c01      	cmp	AL, #1
    7bb6:	1d0e      	jne	0x7bd4 <_handleReadByIdentifier+0x5e>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x05| 0xF2 | SerialNr | SerialNr | SerialNr | SerialNr | Reserved |
			 *	|     |     |      |   (LSB)  |		     |          |   (MSB)  |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7bb8:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7bba:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
    7bbc:	6005      	lod	AL, #5
    7bbe:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7bc0:	60f2      	lod	AL, #-14
    7bc2:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7bc4:	7800      	lod	Y, #0
	__asm__ __volatile__
    7bc6:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7bc8:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7bca:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    7bcc:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    7bce:	6007      	lod	AL, #7
    7bd0:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7bd2:	5405      	ret	#6
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SERIAL_NO_LSW, C_SERIAL_NO_MSW);	/* Serial-number */
		}
		else if ( pDiag->byD1 == (uint8) C_SVN_ID )
    7bd4:	8c30      	cmp	AL, #48
    7bd6:	1d09      	jne	0x7bea <_handleReadByIdentifier+0x74>
		{
			g_DiagResponse.byNAD = g_u8NAD;
    7bd8:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7bda:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
    7bdc:	6005      	lod	AL, #5
    7bde:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7be0:	60f2      	lod	AL, #-14
    7be2:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7be4:	72da 0304 	lod	A, #772
    7be8:	000a      	jmp	0x7bfe <_handleReadByIdentifier+0x88>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SVN, 0xFFFFU);											/* Firmware SVN */
		}
		else if( pDiag->byD1 == (uint8) C_SW_VER_ID )
    7bea:	8c32      	cmp	AL, #50
    7bec:	1d0e      	jne	0x7c0a <_handleReadByIdentifier+0x94>
		{
			g_DiagResponse.byNAD = g_u8NAD;
    7bee:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7bf0:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_32;
    7bf2:	6005      	lod	AL, #5
    7bf4:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7bf6:	60f2      	lod	AL, #-14
    7bf8:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7bfa:	72da 0c04 	lod	A, #3076
    7bfe:	78ff      	lod	Y, #-1
	__asm__ __volatile__
    7c00:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7c02:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7c04:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    7c06:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
    7c08:	07e2      	jmp	0x7bce <_handleReadByIdentifier+0x58>
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_32;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SW_VER, 0xFFFFU);											/* Firmware Software version */
		}
#if ((LINPROT & LINXX) == LIN21)
		else if ( pDiag->byD1 == (uint8) C_VERIFY_NAD )
    7c0a:	8c21      	cmp	AL, #33
    7c0c:	1d0c      	jne	0x7c26 <_handleReadByIdentifier+0xb0>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x04| 0xF2 |    NAD   |  Control |  Status  | Reserved | Reserved |
			 *	|     |     |      |   NVRAM  | Frame ID | Frame ID |		   |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c0e:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
    7c10:	4530      	mov	dp:0x30 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_21;
    7c12:	6004      	lod	AL, #4
    7c14:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c16:	60f2      	lod	AL, #-14
    7c18:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = (uint8) g_u8NAD;						/* Stored NAD (NVRAM) */
    7c1a:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
			g_DiagResponse.byD2 = (uint8) g_u8ControlFrameID;	/* Frame-ID for Control-message */
    7c1c:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7c1e:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
			g_DiagResponse.byD3 = (uint8) g_u8StatusFrameID;	/* Frame-ID for Status-message */
    7c20:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7c22:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
    7c24:	07d4      	jmp	0x7bce <_handleReadByIdentifier+0x58>
			g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( pDiag->byD1 == (uint8) C_SW_HW_REF )
    7c26:	8c2a      	cmp	AL, #42
    7c28:	1d0b      	jne	0x7c40 <_handleReadByIdentifier+0xca>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 | Software | Hardware | Reserved | Reserved | Reserved |
			 *	|     |     |      |  Ref. ID |  Ref. ID |          |	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c2a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7c2c:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_2A;
    7c2e:	6003      	lod	AL, #3
    7c30:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c32:	60f2      	lod	AL, #-14
    7c34:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = (uint8) C_SW_REF;					/* SW-reference */
    7c36:	6089      	lod	AL, #-119
    7c38:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
			g_DiagResponse.byD2 = (uint8) C_HW_REF;					/* HW-reference */
    7c3a:	6010      	lod	AL, #16
    7c3c:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    7c3e:	07c7      	jmp	0x7bce <_handleReadByIdentifier+0x58>
			g_u8BufferOutID = (uint8) QR_RFR_DIAG;					/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( pDiag->byD1 == (uint8) C_MLX_HW_SW_REF )
    7c40:	8c3c      	cmp	AL, #60
    7c42:	1d0a      	jne	0x7c58 <_handleReadByIdentifier+0xe2>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 |  Chip HW |  Chip SW | Reserved | Reserved | Reserved |
			 *	|     |     |      |    ID    |    ID    |          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c44:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7c46:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3C;
    7c48:	6003      	lod	AL, #3
    7c4a:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c4c:	60f2      	lod	AL, #-14
    7c4e:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7c50:	7ada 1182 	lod	Y, #4482
    7c54:	72f0      	lod	A, [Y]
    7c56:	0015      	jmp	0x7c82 <_handleReadByIdentifier+0x10c>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3C;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to2( *((uint16 *) C_ADDR_MLX_HWSWID));				/* Chip HW/SW-ID */
		}
		else if ( pDiag->byD1 == (uint8) C_LIN_CUST_ID )
    7c58:	8c3d      	cmp	AL, #61
    7c5a:	1d09      	jne	0x7c6e <_handleReadByIdentifier+0xf8>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 | Customer | Customer | Reserved | Reserved | Reserved |
			 *	|     |     |      | ID (LSB) | ID (MSB) |          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c5c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7c5e:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3D;
    7c60:	6003      	lod	AL, #3
    7c62:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c64:	60f2      	lod	AL, #-14
    7c66:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7c68:	72da 1000 	lod	A, #4096
    7c6c:	000a      	jmp	0x7c82 <_handleReadByIdentifier+0x10c>
    7c6e:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3D;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to2( C_CUSTOMER_ID );						/* Customer-ID */
		}
		else if ( pDiag->byD1 == (uint8) C_PROD_DATE )
    7c70:	8c3e      	cmp	AL, #62
    7c72:	1d0a      	jne	0x7c88 <_handleReadByIdentifier+0x112>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 |Production|Production| Reserved | Reserved | Reserved |
			 *	|     |     |      |Date (LSB)|Date (MSB)|          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c74:	4530      	mov	dp:0x30 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3E;
    7c76:	6003      	lod	AL, #3
    7c78:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c7a:	60f2      	lod	AL, #-14
    7c7c:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7c7e:	72da 100c 	lod	A, #4108
	__asm__ __volatile__
    7c82:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7c84:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7c86:	07a3      	jmp	0x7bce <_handleReadByIdentifier+0x58>
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else
		{
			/* Identifier not supported */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    7c88:	62e8      	lod	AL, YL
    7c8a:	5cf2      	usex	A
    7c8c:	54ca 0012 	pushw	#18
    7c90:	7e05      	lod	X, [S-6]
    7c92:	66fa      	lod	YL, [X+2]
    7c94:	5cf6      	usex	Y
    7c96:	5adf      	push	Y
    7c98:	16d4      	call	0x7a42 <_SetupDiagResponse>
    7c9a:	5c03      	dec	S, #4
    7c9c:	5405      	ret	#6

00007c9e <_handleConditionalChangeNAD>:
			
}

/* not supported */
void handleConditionalChangeNAD(const DFR_DIAG *pDiag)
{
    7c9e:	5807      	inc	S, #8
    7ca0:	7ee2      	lod	X, A
	 */
	/* Get the identifier of possible read by ID response and selected by Id */
	/* Extract the data byte selected by Byte */
	uint16 buf[2];
	uint8 u8SerialNo[4];
	uint8 u8DataByte = 0x00;
    7ca2:	7800      	lod	Y, #0
	uint8 u8Error = (uint8) C_ERR_NONE;
	
	if ( pDiag->byD1 == 0x00u ) /* Requested Id = LIN Product Identification */
    7ca4:	62fb      	lod	AL, [X+3]
    7ca6:	1d13      	jne	0x7cce <_handleConditionalChangeNAD+0x30>
	{
		if ( pDiag->byD2 == 1u )
    7ca8:	62fc      	lod	AL, [X+4]
    7caa:	8c01      	cmp	AL, #1
    7cac:	1d02      	jne	0x7cb2 <_handleConditionalChangeNAD+0x14>
		{
			u8DataByte = (uint8) ((uint16)C_SUPPLIER_ID & 0xFFu);				/* LSB of Supplier-ID */
    7cae:	7813      	lod	Y, #19
    7cb0:	0037      	jmp	0x7d20 <_handleConditionalChangeNAD+0x82>
		}
		else if ( pDiag->byD2 == 2u )
    7cb2:	8c02      	cmp	AL, #2
    7cb4:	1d01      	jne	0x7cb8 <_handleConditionalChangeNAD+0x1a>
    7cb6:	0034      	jmp	0x7d20 <_handleConditionalChangeNAD+0x82>
		{
			u8DataByte = (uint8) ((uint16)C_SUPPLIER_ID >> 8u);					/* MSB of Supplier-ID */
		}
		else if ( pDiag->byD2 == 3u )
    7cb8:	8c03      	cmp	AL, #3
    7cba:	1d02      	jne	0x7cc0 <_handleConditionalChangeNAD+0x22>
		{
			u8DataByte = (uint8) ((uint16)C_FUNCTION_ID & 0xFFu);				/* LSB of Function-ID */
    7cbc:	7816      	lod	Y, #22
    7cbe:	0030      	jmp	0x7d20 <_handleConditionalChangeNAD+0x82>
		}
		else if ( pDiag->byD2 == 4u )
    7cc0:	8c04      	cmp	AL, #4
    7cc2:	192e      	je	0x7d20 <_handleConditionalChangeNAD+0x82>
		{
			u8DataByte = (uint8) ((uint16)C_FUNCTION_ID >> 8u); 					/*lint !e572 */	/* MSB of Function-ID */
		}
		else if ( pDiag->byD2 == 5u )
    7cc4:	8c05      	cmp	AL, #5
    7cc6:	1d0a      	jne	0x7cdc <_handleConditionalChangeNAD+0x3e>
		{
			u8DataByte = C_VARIANT;
    7cc8:	7ada 00ff 	lod	Y, #255
    7ccc:	0029      	jmp	0x7d20 <_handleConditionalChangeNAD+0x82>
		else
		{
			u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ; 				/* Selected byte not in range, not valid => no response */
		}
	}
	else if ( pDiag->byD1 == 0x01u ) 									/* Requested Id = Serial number (optional) */
    7cce:	8c01      	cmp	AL, #1
    7cd0:	1d1a      	jne	0x7d06 <_handleConditionalChangeNAD+0x68>
	{
		if ( (pDiag->byD2 == 0u) || (pDiag->byD2 > 4u) )
    7cd2:	66fc      	lod	YL, [X+4]
    7cd4:	62e8      	lod	AL, YL
    7cd6:	80ff      	add	AL, #-1
    7cd8:	8c03      	cmp	AL, #3
    7cda:	1a05      	jule	0x7ce6 <_handleConditionalChangeNAD+0x48>
		{
			/* Selected byte not in range, not valid => no response */
			u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ; 				/* Status = Invalid Format */
    7cdc:	4cd3      	swap	D
    7cde:	48cf      	asl	D, #16
    7ce0:	4c0a 0013 	addu	D, #19
    7ce4:	0014      	jmp	0x7d0e <_handleConditionalChangeNAD+0x70>
		}
		else
		{
			u8SerialNo[0] = (uint8)C_SERIAL_NO_LSW;
    7ce6:	6000      	lod	AL, #0
    7ce8:	4207      	mov	[S-8], AL
			u8SerialNo[1] = (uint8)((uint16)C_SERIAL_NO_LSW >> 8u);
    7cea:	4206      	mov	[S-7], AL
			u8SerialNo[2] = (uint8)C_SERIAL_NO_MSW;
    7cec:	4205      	mov	[S-6], AL
			u8SerialNo[3] = (uint8)((uint16)C_SERIAL_NO_MSW >> 8u);
    7cee:	4204      	mov	[S-5], AL
			
			u8DataByte = u8SerialNo[pDiag->byD2 - 1u]; 					/* Serial-number[n] */
    7cf0:	62e8      	lod	AL, YL
    7cf2:	5cf2      	usex	A
    7cf4:	7aef      	lod	Y, S
    7cf6:	e0f8      	add	Y, #-8
    7cf8:	a2e6      	add	A, Y
    7cfa:	7ae2      	lod	Y, A
    7cfc:	e0ff      	add	Y, #-1
    7cfe:	62f0      	lod	AL, [Y]
    7d00:	66e0      	lod	YL, AL
    7d02:	5cf6      	usex	Y
    7d04:	000d      	jmp	0x7d20 <_handleConditionalChangeNAD+0x82>
		}
	}
	else
	{
		/* Identifier not supported */
		u8Error = (uint8) C_ERRCODE_SFUNC_NOSUP;						/* Status = Negative feedback */
    7d06:	4cd3      	swap	D
    7d08:	48cf      	asl	D, #16
    7d0a:	4c0a 0012 	addu	D, #18
	}

	if ( u8Error != (uint8) C_ERR_NONE )
	{
		SetupDiagResponse( g_u8NAD, pDiag->bySID, u8Error);
    7d0e:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7d10:	5cf2      	usex	A
    7d12:	4c8b      	push	DL
    7d14:	66fa      	lod	YL, [X+2]
    7d16:	5cf6      	usex	Y
    7d18:	5adf      	push	Y
    7d1a:	1693      	call	0x7a42 <_SetupDiagResponse>
    7d1c:	5c03      	dec	S, #4
    7d1e:	5409      	ret	#10
	}
	else
	{
		/* Do a bitwise XOR with Invert */
		u8DataByte ^= pDiag->byD4;
    7d20:	62fe      	lod	AL, [X+6]
    7d22:	9ee8      	xor	AL, YL

		/* Do a bitwise AND with Mask */
		u8DataByte &= pDiag->byD3;
    7d24:	96fd      	and	AL, [X+5]

		if ( u8DataByte == 0u )												/* Condition PASSED */
    7d26:	1d1a      	jne	0x7d5c <_handleConditionalChangeNAD+0xbe>
		{
			uint8 byInitialNAD = g_u8NAD;
			g_u8NAD = pDiag->byD5;
    7d28:	62ff      	lod	AL, [X+7]
    7d2a:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
			/* NAD changed */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE); /* Status = Positive feedback */
    7d2c:	5cf2      	usex	A
    7d2e:	54ca 0000 	pushw	#0
    7d32:	66fa      	lod	YL, [X+2]
    7d34:	5cf6      	usex	Y
    7d36:	5adf      	push	Y
    7d38:	1684      	call	0x7a42 <_SetupDiagResponse>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7d3a:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7d3c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7d3e:	5207      	mov	[S-8], A
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7d40:	7aef      	lod	Y, S
    7d42:	e0f8      	add	Y, #-8
    7d44:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7d46:	a6da ff00 	or	A, #65280
    7d4a:	5205      	mov	[S-6], A
			(void)NVRAM_Write(0x1000, buf, 2);
    7d4c:	54ca 0002 	pushw	#2
    7d50:	5adf      	push	Y
    7d52:	72da 1000 	lod	A, #4096
    7d56:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    7d5a:	5c07      	dec	S, #8
    7d5c:	5409      	ret	#10

00007d5e <_handleDataDump>:

}

/* not supported */
void handleDataDump(const DFR_DIAG *pDiag)
{
    7d5e:	5805      	inc	S, #6
    7d60:	5201      	mov	[S-2], A
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xB4| Supplier | Supplier |  Variant |  HW-Ref  |  SW-Ref  |
	 *	|	  | 	|	  | ID (LSB) | ID (MSB) |	 ID    |	ID	  |    ID	 |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 */
	if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u)) != FALSE)
    7d62:	7a01      	lod	Y, [S-2]
    7d64:	6af4      	lod	AH, [Y+4]
    7d66:	62f3      	lod	AL, [Y+3]
    7d68:	1687      	call	0x7a78 <_CheckSupplier>
    7d6a:	ac00      	cmp	A, #0
    7d6c:	1d01      	jne	0x7d70 <_handleDataDump+0x12>
    7d6e:	003e      	jmp	0x7dec <_handleDataDump+0x8e>
	{
		(void)NVRAM_Read(0x1001,buf,2);										/* little endian or big endian */
    7d70:	54ca 0002 	pushw	#2
    7d74:	7eef      	lod	X, S
    7d76:	20f8      	add	X, #-8
    7d78:	5edf      	push	X
    7d7a:	72da 1001 	lod	A, #4097
    7d7e:	82db 9214 	callf	0x9214 <_NVRAM_Read>
		if ( pDiag->byD3 != 0xFFu )
    7d82:	7e05      	lod	X, [S-6]
    7d84:	66fd      	lod	YL, [X+5]
    7d86:	5c03      	dec	S, #4
    7d88:	62e8      	lod	AL, YL
    7d8a:	8cff      	cmp	AL, #-1
    7d8c:	1906      	je	0x7d9a <_handleDataDump+0x3c>
		{
			buf[0] = (buf[0] & 0xFF00u) | (pDiag->byD3);					/* Set new Variant-ID */
    7d8e:	7205      	lod	A, [S-6]
    7d90:	b6da ff00 	and	A, #65280
    7d94:	5cf6      	usex	Y
    7d96:	a6e6      	or	A, Y
    7d98:	5205      	mov	[S-6], A
		}
		
		if ( pDiag->byD4 != 0xFFu )
    7d9a:	7a01      	lod	Y, [S-2]
    7d9c:	62f6      	lod	AL, [Y+6]
    7d9e:	8cff      	cmp	AL, #-1
    7da0:	1907      	je	0x7db0 <_handleDataDump+0x52>
		{
			buf[1] = (buf[1] & 0x00FFu) | ((uint16)pDiag->byD4 << 8u);										/* Set new HW-Reference */
    7da2:	7a03      	lod	Y, [S-4]
    7da4:	f6da 00ff 	and	Y, #255
    7da8:	6800      	lod	AH, #0
    7daa:	72e4      	swap	A
    7dac:	e6e2      	or	Y, A
    7dae:	5a03      	mov	[S-4], Y
		}

		if ( pDiag->byD5 != 0xFFu )
    7db0:	7e01      	lod	X, [S-2]
    7db2:	66ff      	lod	YL, [X+7]
    7db4:	62e8      	lod	AL, YL
    7db6:	8cff      	cmp	AL, #-1
    7db8:	1906      	je	0x7dc6 <_handleDataDump+0x68>
		{
			/* -=#=- Note: SW-Ref should not be changed by this function, but be reprogramming the flash */
			 buf[2] = (buf[1] & 0xFF00u) | (pDiag->byD5); 										/* Set new SW-Reference */
    7dba:	7203      	lod	A, [S-4]
    7dbc:	b6da ff00 	and	A, #65280
    7dc0:	5cf6      	usex	Y
    7dc2:	a6e6      	or	A, Y
    7dc4:	5201      	mov	[S-2], A
		}
		/* Variant-ID and/or HW-reference and/or SW-reference changed */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE); /* Status = Positive feedback */
    7dc6:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7dc8:	5cf2      	usex	A
    7dca:	54ca 0000 	pushw	#0
    7dce:	7e03      	lod	X, [S-4]
    7dd0:	66fa      	lod	YL, [X+2]
    7dd2:	5cf6      	usex	Y
    7dd4:	5adf      	push	Y
    7dd6:	1635      	call	0x7a42 <_SetupDiagResponse>
		/* Store NVRAM */
		(void)NVRAM_Write(0x1000, buf, 2);
    7dd8:	54ca 0002 	pushw	#2
    7ddc:	72ef      	lod	A, S
    7dde:	a0f4      	add	A, #-12
    7de0:	52df      	push	A
    7de2:	72da 1000 	lod	A, #4096
    7de6:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    7dea:	5c07      	dec	S, #8
    7dec:	5407      	ret	#8

00007dee <_handleTargetReset>:
}

void handleTargetReset(const DFR_DIAG *pDiag)
{
	/* Reset Target */
	MLX4_RESET();														/* Reset the Mlx4	*/
    7dee:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7df2:	94fe      	and	AL, #-2
    7df4:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    7df8:	72da 3072 	lod	A, #12402
    7dfc:	52d8 01a0 	mov	0x1a0 <_bistResetInfo>, A
	MLX16_RESET();														/* Reset the Mlx16	*/
    7e00:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    7e04:	5401      	ret

00007e06 <_handleSaveConfig>:
	/* This reset restart the chip as POR, and doesn't come back (no answer) */

}

void handleSaveConfig(const DFR_DIAG *pDiag)
{
    7e06:	5803      	inc	S, #4
    7e08:	7ae2      	lod	Y, A
	 *	| NAD | 0x01| 0xB6| 0xFF | 0xFF |  0xFF |  0xFF  |  0xFF |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 *	Only LIN 2.1
	 */
	/* LIN2.1:After reception of the service and the NAD is correct the slave node shall response(not wait until the configuration is saved) */
	SetupDiagResponse( C_DEFAULT_NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    7e0a:	54ca 0000 	pushw	#0
    7e0e:	62f2      	lod	AL, [Y+2]
    7e10:	5cf2      	usex	A
    7e12:	52df      	push	A
    7e14:	7016      	lod	A, #22
    7e16:	1615      	call	0x7a42 <_SetupDiagResponse>
	/* store to NVRAM */
	buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7e18:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7e1a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7e1c:	5207      	mov	[S-8], A
	buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7e1e:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7e20:	a6da ff00 	or	A, #65280
    7e24:	5205      	mov	[S-6], A
	(void)NVRAM_Write(0x1000, buf, 2);
    7e26:	54ca 0002 	pushw	#2
    7e2a:	72ef      	lod	A, S
    7e2c:	a0f6      	add	A, #-10
    7e2e:	52df      	push	A
    7e30:	72da 1000 	lod	A, #4096
    7e34:	82db 92a0 	callf	0x92a0 <_NVRAM_Write>
    7e38:	5c07      	dec	S, #8
    7e3a:	5405      	ret	#6

00007e3c <_handleAssignFrameIDRange>:
}

void handleAssignFrameIDRange(const DFR_DIAG *pDiag)
{
    7e3c:	5801      	inc	S, #2
    7e3e:	5201      	mov	[S-2], A
	 * correct PIDs.
	 *
	 * A response shall only be sent if the NAD match.
	 */
	/* Since the slave node has only two frames the last two must be set to do not care (0xFF), otherwise the request will fail. */
	if ( (pDiag->byD4 != 0xFFu) || (pDiag->byD5 != 0xFFu) || (pDiag->byD1 > 1u) || ((pDiag->byD1 == 1u) && (pDiag->byD3 != 0xFFu)) )
    7e40:	7a01      	lod	Y, [S-2]
    7e42:	72f6      	lod	A, [Y+6]
    7e44:	acff      	cmp	A, #-1
    7e46:	1901      	je	0x7e4a <_handleAssignFrameIDRange+0xe>
    7e48:	0053      	jmp	0x7ef0 <_handleAssignFrameIDRange+0xb4>
    7e4a:	62f3      	lod	AL, [Y+3]
    7e4c:	8c01      	cmp	AL, #1
    7e4e:	1a01      	jule	0x7e52 <_handleAssignFrameIDRange+0x16>
    7e50:	004f      	jmp	0x7ef0 <_handleAssignFrameIDRange+0xb4>
    7e52:	1d04      	jne	0x7e5c <_handleAssignFrameIDRange+0x20>
    7e54:	62f5      	lod	AL, [Y+5]
    7e56:	8cff      	cmp	AL, #-1
    7e58:	1901      	je	0x7e5c <_handleAssignFrameIDRange+0x20>
    7e5a:	004a      	jmp	0x7ef0 <_handleAssignFrameIDRange+0xb4>
		/* Negative feedback */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
	}
	else
	{
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);		/* Status = Pending */
    7e5c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7e5e:	5cf2      	usex	A
    7e60:	54ca 0078 	pushw	#120
    7e64:	7e03      	lod	X, [S-4]
    7e66:	66fa      	lod	YL, [X+2]
    7e68:	5cf6      	usex	Y
    7e6a:	5adf      	push	Y
    7e6c:	15ea      	call	0x7a42 <_SetupDiagResponse>

		u16NvramStoreResult = (uint8)~C_NVRAM_STORE_OKAY;
    7e6e:	7ada 00ff 	lod	Y, #255
		if ( pDiag->byD1 == 0u )
    7e72:	5c03      	dec	S, #4
    7e74:	7e01      	lod	X, [S-2]
    7e76:	62fb      	lod	AL, [X+3]
    7e78:	1d18      	jne	0x7eaa <_handleAssignFrameIDRange+0x6e>
		{
			/* Starting with first message-index */
			if ( pDiag->byD2 != 0xFFu )
    7e7a:	62fc      	lod	AL, [X+4]
    7e7c:	8cff      	cmp	AL, #-1
    7e7e:	1910      	je	0x7ea0 <_handleAssignFrameIDRange+0x64>
			{
				/* First Frame-ID is Status-message Frame-ID */
				g_u8StatusFrameID = pDiag->byD2;
    7e80:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
				(void) ml_Disconnect();
    7e82:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
				if ( g_u8StatusFrameID != 0x00u )				/* MMP130913-1 - Begin */
    7e86:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7e88:	1907      	je	0x7e98 <_handleAssignFrameIDRange+0x5c>
				{
					(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7e8a:	5cf2      	usex	A
    7e8c:	52df      	push	A
    7e8e:	7000      	lod	A, #0
    7e90:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
    7e94:	5c01      	dec	S, #2
    7e96:	0003      	jmp	0x7e9e <_handleAssignFrameIDRange+0x62>
				}
				else
				{
					(void) ml_DisableMessage( MSG_STATUS);
    7e98:	7000      	lod	A, #0
    7e9a:	82db 5ab4 	callf	0x5ab4 <_ml_DisableMessage>
				}														/* MMP130913-1 - End */
				u16NvramStoreResult = C_NVRAM_STORE_OKAY;
    7e9e:	7800      	lod	Y, #0
			}
			
			if ( pDiag->byD3 != 0xFFu )
    7ea0:	7e01      	lod	X, [S-2]
    7ea2:	62fd      	lod	AL, [X+5]
    7ea4:	8cff      	cmp	AL, #-1
    7ea6:	1915      	je	0x7ed2 <_handleAssignFrameIDRange+0x96>
    7ea8:	0004      	jmp	0x7eb2 <_handleAssignFrameIDRange+0x76>
					(void) ml_DisableMessage( MSG_CONTROL);
				}														/* MMP130913-1 - End */
				u16NvramStoreResult = C_NVRAM_STORE_OKAY;
			}
		}
		else if ( pDiag->byD1 == 1u )
    7eaa:	8c01      	cmp	AL, #1
    7eac:	1d21      	jne	0x7ef0 <_handleAssignFrameIDRange+0xb4>
		{
			/* Second Frame-ID is Control-message Frame-ID */
			g_u8ControlFrameID = pDiag->byD2;
    7eae:	7a01      	lod	Y, [S-2]
    7eb0:	62f4      	lod	AL, [Y+4]
    7eb2:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
			(void) ml_Disconnect();
    7eb4:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			if ( g_u8ControlFrameID != 0x00u )				/* MMP130913-1 - Begin */
    7eb8:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7eba:	1907      	je	0x7eca <_handleAssignFrameIDRange+0x8e>
			{
				(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7ebc:	5cf2      	usex	A
    7ebe:	52df      	push	A
    7ec0:	7001      	lod	A, #1
    7ec2:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
    7ec6:	5c01      	dec	S, #2
    7ec8:	0006      	jmp	0x7ed6 <_handleAssignFrameIDRange+0x9a>
			}
			else
			{
				(void) ml_DisableMessage( MSG_CONTROL);
    7eca:	7001      	lod	A, #1
    7ecc:	82db 5ab4 	callf	0x5ab4 <_ml_DisableMessage>
    7ed0:	0002      	jmp	0x7ed6 <_handleAssignFrameIDRange+0x9a>
		else
		{
			
		}
		/* Assign frame ID range success */
		if ( u16NvramStoreResult == C_NVRAM_STORE_OKAY )
    7ed2:	ec00      	cmp	Y, #0
    7ed4:	1d0d      	jne	0x7ef0 <_handleAssignFrameIDRange+0xb4>
		{
			(void) ml_Connect();
    7ed6:	82db 5b96 	callf	0x5b96 <_ml_Connect>
			/* save configuration is implemented by save configuration service */
			/* Positive feedback */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    7eda:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7edc:	5cf2      	usex	A
    7ede:	54ca 0000 	pushw	#0
    7ee2:	7e03      	lod	X, [S-4]
    7ee4:	66fa      	lod	YL, [X+2]
    7ee6:	5cf6      	usex	Y
    7ee8:	5adf      	push	Y
    7eea:	15ab      	call	0x7a42 <_SetupDiagResponse>
    7eec:	5c03      	dec	S, #4
    7eee:	5403      	ret	#4
		}
		else
		{
			/* Negative feedback */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    7ef0:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ef2:	5cf2      	usex	A
    7ef4:	54ca 0012 	pushw	#18
    7ef8:	07f4      	jmp	0x7ee2 <_handleAssignFrameIDRange+0xa6>

00007efa <_handleWriteByIdentifier>:
		}
	}
}

void handleWriteByIdentifier(const DFR_DIAG *pDiag)
{
    7efa:	5803      	inc	S, #4
    7efc:	7ae2      	lod	Y, A
	 *	| NAD | 0x06| 0x0B |Identifier| ID Data1 | ID Data2 | ID Data3 | ID Data4 |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 * Identifier: 00
	 * ID data 1-4
	 */
	uint16 u16SupplierID = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    7efe:	6af5      	lod	AH, [Y+5]
    7f00:	6000      	lod	AL, #0
    7f02:	5203      	mov	[S-4], A
    7f04:	62f4      	lod	AL, [Y+4]
    7f06:	5cf2      	usex	A
    7f08:	a603      	or	A, [S-4]
    7f0a:	5203      	mov	[S-4], A
	uint16 u16ParamID = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    7f0c:	6af7      	lod	AH, [Y+7]
    7f0e:	6000      	lod	AL, #0
    7f10:	7ee2      	lod	X, A
    7f12:	62f6      	lod	AL, [Y+6]
    7f14:	5cf2      	usex	A
    7f16:	26e2      	or	X, A
	
	if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    7f18:	62f3      	lod	AL, [Y+3]
    7f1a:	1d09      	jne	0x7f2e <_handleWriteByIdentifier+0x34>
	{
		/* Write Function ID */
		if ( (u16SupplierID == C_SUPPLIER_ID) && (u16ParamID == C_FUNCTION_ID) )			/* MMP130626-1 */
    7f1c:	7203      	lod	A, [S-4]
    7f1e:	ac13      	cmp	A, #19
    7f20:	1d04      	jne	0x7f2a <_handleWriteByIdentifier+0x30>
    7f22:	2c16      	cmp	X, #22
    7f24:	1d02      	jne	0x7f2a <_handleWriteByIdentifier+0x30>
			/* Correct Supplier ID; Change Function ID allowed */
			/* Store NVRAM */
		
			{
				/* Function-ID changed:set up response */
				g_DiagResponse.byNAD = g_u8NAD;
    7f26:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f28:	000a      	jmp	0x7f3e <_handleWriteByIdentifier+0x44>
			}
		}
		else
		{
			/* Wrong Supplier ID (Wild-card not allowed) */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);	/* Status = Negative feedback */
    7f2a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f2c:	001b      	jmp	0x7f64 <_handleWriteByIdentifier+0x6a>
		}
	}
	else if ( pDiag->byD1 == (uint8) C_LIN_CUST_ID )
    7f2e:	8c3d      	cmp	AL, #61
    7f30:	1d22      	jne	0x7f76 <_handleWriteByIdentifier+0x7c>
    7f32:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f34:	4201      	mov	[S-2], AL
	{
		/* Write Customer ID */
		if ( u16SupplierID == C_SUPPLIER_ID )
    7f36:	7203      	lod	A, [S-4]
    7f38:	ac13      	cmp	A, #19
    7f3a:	1d13      	jne	0x7f62 <_handleWriteByIdentifier+0x68>
		{
			/* Correct Supplier ID; Change Function ID allowed */
			/* Store NVRAM */
			{
				/* Customer-ID changed:set up response */
				g_DiagResponse.byNAD = g_u8NAD;
    7f3c:	6201      	lod	AL, [S-2]
    7f3e:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = (uint8) C_RSID_WRITE_BY_ID;							/* Positive feedback */
    7f40:	6006      	lod	AL, #6
    7f42:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_RPCI_WRITE_BY_ID;
    7f44:	600b      	lod	AL, #11
    7f46:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = pDiag->byD1;
    7f48:	62f3      	lod	AL, [Y+3]
    7f4a:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
				g_DiagResponse.byD2 = pDiag->byD2;
    7f4c:	62f4      	lod	AL, [Y+4]
    7f4e:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
				g_DiagResponse.byD3 = pDiag->byD3;
    7f50:	62f5      	lod	AL, [Y+5]
    7f52:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
				g_DiagResponse.byD4 = pDiag->byD4;
    7f54:	62f6      	lod	AL, [Y+6]
    7f56:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
				g_DiagResponse.byD5 = pDiag->byD5;
    7f58:	62f7      	lod	AL, [Y+7]
    7f5a:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

				g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    7f5c:	6007      	lod	AL, #7
    7f5e:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7f60:	5405      	ret	#6
			}
		}
		else
		{
			/* Wrong Supplier ID (Wild-card not allowed) */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);	/* Status = Negative feedback */
    7f62:	6201      	lod	AL, [S-2]
    7f64:	5cf2      	usex	A
    7f66:	54ca 0013 	pushw	#19
    7f6a:	66f2      	lod	YL, [Y+2]
    7f6c:	5cf6      	usex	Y
    7f6e:	5adf      	push	Y
    7f70:	1568      	call	0x7a42 <_SetupDiagResponse>
    7f72:	5c03      	dec	S, #4
    7f74:	5405      	ret	#6
		}
	}
	else if ( pDiag->byD1 == (uint8) C_PROD_DATE )
    7f76:	8c3e      	cmp	AL, #62
    7f78:	195c      	je	0x7f32 <_handleWriteByIdentifier+0x38>
		}
	}
	else
	{
		/* Identifier not supported */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    7f7a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f7c:	5cf2      	usex	A
    7f7e:	54ca 0012 	pushw	#18
    7f82:	07f3      	jmp	0x7f6a <_handleWriteByIdentifier+0x70>

00007f84 <_handleReadErrorCodes>:
	 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xEC | Error[0] | Error[1] | Error[2] | Error[3] | Error[4] |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 */
	g_DiagResponse.byNAD = g_u8NAD;
    7f84:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f86:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
	g_DiagResponse.byPCI = 0x06;
    7f88:	6006      	lod	AL, #6
    7f8a:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
	g_DiagResponse.byRSID = (uint8) C_SID_MLX_ERROR_CODES;
    7f8c:	60ec      	lod	AL, #-20
    7f8e:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_DiagResponse.byD1 = GetLastError();													/* Oldest Error-code */
    7f90:	82db 8870 	callf	0x8870 <_GetLastError>
    7f94:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
	g_DiagResponse.byD2 = GetLastError();
    7f96:	82db 8870 	callf	0x8870 <_GetLastError>
    7f9a:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
	g_DiagResponse.byD3 = GetLastError();
    7f9c:	82db 8870 	callf	0x8870 <_GetLastError>
    7fa0:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
	g_DiagResponse.byD4 = GetLastError();
    7fa2:	82db 8870 	callf	0x8870 <_GetLastError>
    7fa6:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
	g_DiagResponse.byD5 = GetLastError();
    7fa8:	82db 8870 	callf	0x8870 <_GetLastError>
    7fac:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;													/* LIN Output buffer is valid (RFR_DIAG) */
    7fae:	6007      	lod	AL, #7
    7fb0:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7fb2:	5401      	ret

00007fb4 <_handleMLXEEPatch>:
}

void handleMLXEEPatch(const DFR_DIAG *pDiag)
{
    7fb4:	5805      	inc	S, #6
    7fb6:	7ee2      	lod	X, A
	/* EEPROM/NVRAM Patch support
	 * D1.bit 7 = 0 : Read Patch area
	 *			  1 : Write Patch area
	 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3D.
	 */
	uint16 u16Index = (uint16) (pDiag->byD1 & 0x3Fu);
    7fb8:	62fb      	lod	AL, [X+3]
    7fba:	4201      	mov	[S-2], AL
    7fbc:	66e0      	lod	YL, AL
    7fbe:	f43f      	and	Y, #63
    7fc0:	72e6      	lod	A, Y
    7fc2:	4422      	asl	A
    7fc4:	5203      	mov	[S-4], A
	if ( (pDiag->byD1 & 0x80u) != 0u )
    7fc6:	6201      	lod	AL, [S-2]
    7fc8:	8c00      	cmp	AL, #0
    7fca:	1e91      	jsge	0x7fee <_handleMLXEEPatch+0x3a>
		 *	| NAD | 0x06| 0xED |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
		 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
	     * No Response
		 */
		uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    7fcc:	7a03      	lod	Y, [S-4]
    7fce:	e2da 1080 	add	Y, #4224
    7fd2:	5a05      	mov	[S-6], Y
		*pu16NvramData = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    7fd4:	6afd      	lod	AH, [X+5]
    7fd6:	62fc      	lod	AL, [X+4]
    7fd8:	7a05      	lod	Y, [S-6]
    7fda:	52f0      	mov	[Y], A
		pu16NvramData++;
    7fdc:	7a03      	lod	Y, [S-4]
    7fde:	e2da 1082 	add	Y, #4226
    7fe2:	5a05      	mov	[S-6], Y
		*pu16NvramData = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    7fe4:	6aff      	lod	AH, [X+7]
    7fe6:	62fe      	lod	AL, [X+6]
    7fe8:	7a05      	lod	Y, [S-6]
    7fea:	52f0      	mov	[Y], A
    7fec:	5407      	ret	#8
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 *	| NAD | 0x06| 0xED |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
		 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byNAD = g_u8NAD;
    7fee:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ff0:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    7ff2:	6006      	lod	AL, #6
    7ff4:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_PATCH;
    7ff6:	60ed      	lod	AL, #-19
    7ff8:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) u16Index;
    7ffa:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
		{
			uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    7ffc:	7a03      	lod	Y, [S-4]
    7ffe:	e2da 1080 	add	Y, #4224
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8002:	72f0      	lod	A, [Y]
    8004:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    8006:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    8008:	4935      	mov	dp:0x35 <_g_DiagResponse+0x5>, AH
    800a:	4536      	mov	dp:0x36 <_g_DiagResponse+0x6>, YL
    800c:	4d37      	mov	dp:0x37 <_g_DiagResponse+0x7>, YH
		"mov dp:_g_DiagResponse+6, YL\n\t"
		"mov dp:_g_DiagResponse+7, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    800e:	6007      	lod	AL, #7
    8010:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    8012:	5407      	ret	#8

00008014 <_handleMLXEEUserPage>:
		}
	}
}

void handleMLXEEUserPage(const DFR_DIAG *pDiag)
{
    8014:	5805      	inc	S, #6
    8016:	7ee2      	lod	X, A
	/* EEPROM/NVRAM User-page #1 support
	 * D1.bit 7 = 0 : Read User-page #1
	 *			  1 : Write User-page #1
	 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3F.
	 */
	uint16 u16Index = (uint16) (pDiag->byD1 & 0x3Fu);
    8018:	62fb      	lod	AL, [X+3]
    801a:	4201      	mov	[S-2], AL
    801c:	66e0      	lod	YL, AL
    801e:	f43f      	and	Y, #63
    8020:	72e6      	lod	A, Y
    8022:	4422      	asl	A
    8024:	5203      	mov	[S-4], A
	if ( (pDiag->byD1 & 0x80u) != 0x00u )
    8026:	6201      	lod	AL, [S-2]
    8028:	8c00      	cmp	AL, #0
    802a:	1e8d      	jsge	0x8046 <_handleMLXEEUserPage+0x32>
		 *	| NAD | 0x06| 0xEE |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
		 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
	     * No Response
		 */
		uint16 *pu16NvramData = ((uint16 *) C_ADDR_USERPAGE1) + u16Index;	/* NVRAM 16-bit pointer */
    802c:	7a03      	lod	Y, [S-4]
    802e:	e2da 1000 	add	Y, #4096
    8032:	5a05      	mov	[S-6], Y
		pu16NvramData[0] = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    8034:	6afd      	lod	AH, [X+5]
    8036:	62fc      	lod	AL, [X+4]
    8038:	7a05      	lod	Y, [S-6]
    803a:	52f0      	mov	[Y], A
		pu16NvramData[1] = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    803c:	6aff      	lod	AH, [X+7]
    803e:	62fe      	lod	AL, [X+6]
    8040:	7a05      	lod	Y, [S-6]
    8042:	52f2      	mov	[Y+2], A
    8044:	5407      	ret	#8
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 *	| NAD | 0x06| 0xEE |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
		 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byNAD = g_u8NAD;
    8046:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    8048:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    804a:	6006      	lod	AL, #6
    804c:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_USERPG1;
    804e:	60ee      	lod	AL, #-18
    8050:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) u16Index;
    8052:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
		{
			uint16 *pu16NvramData = ((uint16 *) C_ADDR_USERPAGE1) + u16Index;	/* NVRAM 16-bit pointer */
    8054:	7a03      	lod	Y, [S-4]
    8056:	e2da 1000 	add	Y, #4096
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    805a:	72f0      	lod	A, [Y]
    805c:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    805e:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    8060:	4935      	mov	dp:0x35 <_g_DiagResponse+0x5>, AH
    8062:	4536      	mov	dp:0x36 <_g_DiagResponse+0x6>, YL
    8064:	4d37      	mov	dp:0x37 <_g_DiagResponse+0x7>, YH
		"mov dp:_g_DiagResponse+6, YL\n\t"
		"mov dp:_g_DiagResponse+7, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    8066:	6007      	lod	AL, #7
    8068:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    806a:	5407      	ret	#8

0000806c <_handleMLXEEStore>:
		}
	}
}

void handleMLXEEStore(const DFR_DIAG *pDiag)
{
    806c:	5801      	inc	S, #2
    806e:	5201      	mov	[S-2], A
	if ( pDiag->byD1 == (uint8) C_EE_STORE_USERPG1 )
    8070:	7a01      	lod	Y, [S-2]
    8072:	62f3      	lod	AL, [Y+3]
    8074:	8cee      	cmp	AL, #-18
    8076:	1d14      	jne	0x80a0 <_handleMLXEEStore+0x34>
		 *	| NAD | 0x06| 0xEF |   0xEE   | Pages &  |          |          |          |
		 *	|     |     |      |          | ResetFlg |          |          |          |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 * No Response
		 */
		(void) NVRAM_Store( pDiag->byD2);
    8078:	62f4      	lod	AL, [Y+4]
    807a:	5cf2      	usex	A
    807c:	82db 93f6 	callf	0x93f6 <_NVRAM_Store>
		if ( (pDiag->byD2 != 0xFFu) && ((pDiag->byD2 & C_NVRAM_USER_PAGE_RESET) != 0u) )
    8080:	7a01      	lod	Y, [S-2]
    8082:	62f4      	lod	AL, [Y+4]
    8084:	8cff      	cmp	AL, #-1
    8086:	1914      	je	0x80b0 <_handleMLXEEStore+0x44>
    8088:	b420      	and	A, #32
    808a:	1912      	je	0x80b0 <_handleMLXEEStore+0x44>
		{
			(void) mlu_ApplicationStop();
    808c:	82db 781c 	callf	0x781c <_mlu_ApplicationStop>
			MLX4_RESET();												/* Reset the Mlx4   */
    8090:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8094:	94fe      	and	AL, #-2
    8096:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			MLX16_RESET();												/* Reset the Mlx16  */
    809a:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    809e:	5403      	ret	#4
		}
	}
	else if ( (pDiag->byD1 == (uint8) C_EE_STORE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0u) )	/* MMP150603-2 */
    80a0:	8ced      	cmp	AL, #-19
    80a2:	1d06      	jne	0x80b0 <_handleMLXEEStore+0x44>
    80a4:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    80a8:	b401      	and	A, #1
    80aa:	1d02      	jne	0x80b0 <_handleMLXEEStore+0x44>
		 *	| NAD | 0x06| 0xEF |   0xED   |          |          |          |          |
		 *	|     |     |      |          |          |          |          |          |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 * No Response
		 */
		NVRAM_StorePatch();
    80ac:	82db 9470 	callf	0x9470 <_NVRAM_StorePatch>
    80b0:	5403      	ret	#4

000080b2 <_HandleDfrDiag>:

/* ****************************************************************************	*
 * Diagnostic
 * ****************************************************************************	*/
void HandleDfrDiag( void)
{
    80b2:	5801      	inc	S, #2
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	uint16 u16DiagPCI_SID;

#if ((LINPROT & LINXX) == LIN21) || ((LINPROT & LINXX) == LIN22) 			/* LIN 2.1, LIN 2.2 */
	if ( pDiag->byNAD != 0x7Eu )
    80b4:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    80b6:	4201      	mov	[S-2], AL
    80b8:	8c7e      	cmp	AL, #126
    80ba:	1902      	je	0x80c0 <_HandleDfrDiag+0xe>
	{
		g_u8BufferOutID = (uint8) QR_INVALID;
    80bc:	60ff      	lod	AL, #-1
    80be:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	if ( pDiag->byNAD == 0x00u )	/* Other bytes should be 0xFF, and are ignored */
	{
		/* ACT_DFR_DIAG_SLEEP: Sleep request (Optional) */
	}
	/* assign NAD service shall be used with initial NAD */
	if((pDiag->byNAD == (uint8)C_DEFAULT_NAD) || (pDiag->byNAD == (uint8)C_BROADCAST_NAD))
    80c0:	6201      	lod	AL, [S-2]
    80c2:	8c16      	cmp	AL, #22
    80c4:	1902      	je	0x80ca <_HandleDfrDiag+0x18>
    80c6:	8c7f      	cmp	AL, #127
    80c8:	1d0e      	jne	0x80e6 <_HandleDfrDiag+0x34>
	{
		u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8u) | ((uint16)pDiag->bySID);
    80ca:	6d29      	lod	YH, dp:0x29 <__data_dp_end+0x1>
    80cc:	652a      	lod	YL, dp:0x2a <__data_dp_end+0x2>
		/* support padding */
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    80ce:	60ff      	lod	AL, #-1
    80d0:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    80d2:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    80d4:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    80d6:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    80d8:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
		if(u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD)
    80da:	eeda 06b0 	cmp	Y, #1712
    80de:	1d03      	jne	0x80e6 <_HandleDfrDiag+0x34>
		{
			handleReassignNAD(pDiag);
    80e0:	72da 0028 	lod	A, #40
    80e4:	14e0      	call	0x7aa6 <_handleReassignNAD>
		}
	}
	/* other service shall use configure NAD */	
	if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == (uint8) C_BROADCAST_NAD) )
    80e6:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    80e8:	8d1b      	cmp	AL, dp:0x1b <_g_u8NAD>
    80ea:	1903      	je	0x80f2 <_HandleDfrDiag+0x40>
    80ec:	8c7f      	cmp	AL, #127
    80ee:	1901      	je	0x80f2 <_HandleDfrDiag+0x40>
    80f0:	004e      	jmp	0x818e <_HandleDfrDiag+0xdc>
	{
		u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8u) | ((uint16)pDiag->bySID);
    80f2:	6d29      	lod	YH, dp:0x29 <__data_dp_end+0x1>
    80f4:	6400      	lod	YL, #0
    80f6:	612a      	lod	AL, dp:0x2a <__data_dp_end+0x2>
    80f8:	4200      	mov	[S-1], AL
    80fa:	5cf2      	usex	A
    80fc:	e6e2      	or	Y, A

		/* support padding */
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    80fe:	60ff      	lod	AL, #-1
    8100:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    8102:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    8104:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    8106:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    8108:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

		if ( (u16DiagPCI_SID == C_PCI_SID_STOP_ACTUATOR) && (pDiag->byD5 == 0xFEu) )
    810a:	eeda 06b5 	cmp	Y, #1717
    810e:	1d04      	jne	0x8118 <_HandleDfrDiag+0x66>
    8110:	612f      	lod	AL, dp:0x2f <__data_dp_end+0x7>
    8112:	8cfe      	cmp	AL, #-2
    8114:	1d1d      	jne	0x8150 <_HandleDfrDiag+0x9e>
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB5| Supplier | Supplier | Function | Function |  "Stop"  |
			 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xFE   |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u), ((uint16)pDiag->byD3) | ((uint16)(pDiag->byD4) << 8u)) != FALSE )
    8116:	5403      	ret	#4
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID )
		{
			handleAssignFrameID(pDiag);
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else if ( u16DiagPCI_SID == C_PCI_SID_READ_BY_ID )
    8118:	eeda 06b2 	cmp	Y, #1714
    811c:	1d04      	jne	0x8126 <_HandleDfrDiag+0x74>
		{
			handleReadByIdentifier(pDiag);
    811e:	72da 0028 	lod	A, #40
    8122:	1529      	call	0x7b76 <_handleReadByIdentifier>
    8124:	5403      	ret	#4
		{
			handleDataDump(pDiag);
		}
#endif
#if ((LINPROT & LINXX) == LIN21)
		else if ( u16DiagPCI_SID == C_PCI_SID_SAVE_CONFIG)
    8126:	eeda 01b6 	cmp	Y, #438
    812a:	1d04      	jne	0x8134 <_HandleDfrDiag+0x82>
		{
			handleSaveConfig(pDiag);
    812c:	72da 0028 	lod	A, #40
    8130:	166a      	call	0x7e06 <_handleSaveConfig>
    8132:	5403      	ret	#4
		}
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID_RNG )
    8134:	eeda 06b7 	cmp	Y, #1719
    8138:	1d04      	jne	0x8142 <_HandleDfrDiag+0x90>
		{
			handleAssignFrameIDRange(pDiag);
    813a:	72da 0028 	lod	A, #40
    813e:	167e      	call	0x7e3c <_handleAssignFrameIDRange>
    8140:	5403      	ret	#4
		}
#endif
		else if ( u16DiagPCI_SID == C_PCI_SID_WRITE_BY_ID )
    8142:	eeda 06cb 	cmp	Y, #1739
    8146:	1d04      	jne	0x8150 <_HandleDfrDiag+0x9e>
		{
			handleWriteByIdentifier(pDiag);
    8148:	72da 0028 	lod	A, #40
    814c:	16d6      	call	0x7efa <_handleWriteByIdentifier>
    814e:	5403      	ret	#4
		{
			handleMLXDebug(pDiag);
		}
#endif /* _SUPPORT_MLX_DEBUG_MODE */

		else if ( pDiag->bySID == (uint8) C_SID_MLX_ERROR_CODES )
    8150:	6200      	lod	AL, [S-1]
    8152:	8cec      	cmp	AL, #-20
    8154:	1d04      	jne	0x815e <_HandleDfrDiag+0xac>
		{
			handleReadErrorCodes(pDiag);
    8156:	72da 0028 	lod	A, #40
    815a:	1714      	call	0x7f84 <_handleReadErrorCodes>
    815c:	5403      	ret	#4
		}
		else if ( (pDiag->bySID == (uint8) C_SID_MLX_EE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0u) )	/* MMP150603-2 */
    815e:	6200      	lod	AL, [S-1]
    8160:	8ced      	cmp	AL, #-19
    8162:	1d08      	jne	0x8174 <_HandleDfrDiag+0xc2>
    8164:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    8168:	b401      	and	A, #1
    816a:	1d11      	jne	0x818e <_HandleDfrDiag+0xdc>
		{
			handleMLXEEPatch(pDiag);
    816c:	72da 0028 	lod	A, #40
    8170:	1721      	call	0x7fb4 <_handleMLXEEPatch>
    8172:	5403      	ret	#4
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_USERPG1 )
    8174:	6200      	lod	AL, [S-1]
    8176:	8cee      	cmp	AL, #-18
    8178:	1d04      	jne	0x8182 <_HandleDfrDiag+0xd0>
		{
			handleMLXEEUserPage(pDiag);
    817a:	72da 0028 	lod	A, #40
    817e:	174a      	call	0x8014 <_handleMLXEEUserPage>
    8180:	5403      	ret	#4
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_STORE )
    8182:	6200      	lod	AL, [S-1]
    8184:	8cef      	cmp	AL, #-17
    8186:	1d03      	jne	0x818e <_HandleDfrDiag+0xdc>
		{
			handleMLXEEStore(pDiag);
    8188:	72da 0028 	lod	A, #40
    818c:	176f      	call	0x806c <_handleMLXEEStore>
    818e:	5403      	ret	#4

00008190 <_RfrDiagReset>:
 * ****************************************************************************	*/
void RfrDiagReset(void)
{
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	
	if ( pDiag->byNAD != C_BROADCAST_NAD )
    8190:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    8192:	8c7f      	cmp	AL, #127
    8194:	1910      	je	0x81b6 <_RfrDiagReset+0x26>
	{
		/* Positive Response */
		g_DiagResponse.byNAD = g_u8NAD;
    8196:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    8198:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    819a:	6006      	lod	AL, #6
    819c:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (C_SID_RESET | C_RSID_OK);
    819e:	60f5      	lod	AL, #-11
    81a0:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD5 = (uint8) C_VARIANT;
    81a2:	60ff      	lod	AL, #-1
    81a4:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    81a6:	7013      	lod	A, #19
    81a8:	7816      	lod	Y, #22
	__asm__ __volatile__
    81aa:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    81ac:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    81ae:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    81b0:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    81b2:	6007      	lod	AL, #7
    81b4:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    81b6:	5401      	ret

000081b8 <_ADC_StartSoftTrig>:
 *
 * Start ADC measurement using Software trigger.
 * ****************************************************************************	*/
void ADC_StartSoftTrig( void)													/* MMP140709-1 - Begin */
{
	PEND = CLR_ADC_IT;
    81b8:	7040      	lod	A, #64
    81ba:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    81be:	7001      	lod	A, #1
    81c0:	5290      	mov	io:0x10 <__data_dp_size>, A
	if ( l_u8AdcPowerOff != 0u )
    81c2:	62d8 00c0 	lod	AL, 0xc0 <_l_u8AdcPowerOff>
    81c6:	1904      	je	0x81d0 <_ADC_StartSoftTrig+0x18>
    81c8:	7eda 008b 	lod	X, #139

static __inline__ void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0u; u16DelayCount-- )
	{
		NOP();
    81cc:	0000      	nop
    81ce:	1bfe      	djnz	X, 0x81cc <_ADC_StartSoftTrig+0x14>
	{
		NopDelay( DELAY_50us); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    81d0:	6000      	lod	AL, #0
    81d2:	42d8 00c0 	mov	0xc0 <_l_u8AdcPowerOff>, AL
    81d6:	7c06      	lod	X, #6
    81d8:	0000      	nop
    81da:	1bfe      	djnz	X, 0x81d8 <_ADC_StartSoftTrig+0x20>
	NopDelay( ADC_SETTING); /*lint !e522 */
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    81dc:	72da 0101 	lod	A, #257
    81e0:	5290      	mov	io:0x10 <__data_dp_size>, A
	while ((ADC_CTRL & ADC_START) != 0u) 			/* lint -e{722} */ 			/* Wait for ADC result */
    81e2:	7290      	lod	A, io:0x10 <__data_dp_size>
    81e4:	b401      	and	A, #1
    81e6:	1d7d      	jne	0x81e2 <_ADC_StartSoftTrig+0x2a>
    81e8:	5401      	ret

000081ea <_ADC_Stop>:
 *
 * Stop ADC (with waiting for pending ADC conversions to be finished)
 * ****************************************************************************	*/
void ADC_Stop(void)
{	
	if ( (ADC_CTRL & ADC_START) != 0u )											/* In case ADC is active, wait to finish it */
    81ea:	7290      	lod	A, io:0x10 <__data_dp_size>
    81ec:	b401      	and	A, #1
    81ee:	190f      	je	0x820e <_ADC_Stop+0x24>
	{
		ADC_CTRL &= ~(uint16)(ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);			/* Stop looping and HW-triggers */
    81f0:	7290      	lod	A, io:0x10 <__data_dp_size>
    81f2:	b6da ff79 	and	A, #65401
    81f6:	5290      	mov	io:0x10 <__data_dp_size>, A
extern void Timer_Start(TIMER_ID id,uint16 TimerPeriod);						/* Set timer by timer ID*/
extern uint8 Timer_IsExpired(TIMER_ID id);									/* Get the status of timer*/

static __inline__ void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0u; u16DelayCount-- )
    81f8:	7290      	lod	A, io:0x10 <__data_dp_size>
    81fa:	b401      	and	A, #1
    81fc:	1908      	je	0x820e <_ADC_Stop+0x24>
		while ( (ADC_CTRL & ADC_START) != 0u )									/* As long as the ADC is active ... */
		{
			ADC_CTRL |= ADC_SOFT_TRIG;											/* ... Set S/W trigger */
    81fe:	7290      	lod	A, io:0x10 <__data_dp_size>
    8200:	a6da 0100 	or	A, #256
    8204:	5290      	mov	io:0x10 <__data_dp_size>, A
    8206:	7c12      	lod	X, #18
	{
		NOP();
    8208:	0000      	nop
    820a:	1bfe      	djnz	X, 0x8208 <_ADC_Stop+0x1e>
    820c:	07f5      	jmp	0x81f8 <_ADC_Stop+0xe>
			NopDelay( DELAY_7us); /*lint !e522 */
		}
	}
	ADC_CTRL = 0u;																/* Clear the ADC control register */
    820e:	7000      	lod	A, #0
    8210:	5290      	mov	io:0x10 <__data_dp_size>, A
	BEGIN_CRITICAL_SECTION();
    8212:	54d0      	psup	#0
	MASK &= ~EN_ADC_IT;															/* Disable ADC Interrupt */
    8214:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    8218:	b4bf      	and	A, #-65
    821a:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	END_CRITICAL_SECTION();
    821e:	72cb      	pop	M
#if ((LINPROT & LINXX) != LIN2J)
	g_u8AdcIsrMode = C_ADC_ISR_NONE;
    8220:	6000      	lod	AL, #0
    8222:	42d8 00c1 	mov	0xc1 <_g_u8AdcIsrMode>, AL
    8226:	5401      	ret

00008228 <_ADC_Init>:
 *
 * Measure Zero-current offset
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Init( void)
{
    8228:	5801      	inc	S, #2
	uint16 volatile u16ZCO;
	ADC_Stop();																	/* clear the ADC control register */
    822a:	17df      	call	0x81ea <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURROFF;
    822c:	72da 98e2 	lod	A, #39138
    8230:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &u16ZCO;
    8232:	72ef      	lod	A, S
    8234:	a0fe      	add	A, #-2
    8236:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    8238:	17bf      	call	0x81b8 <_ADC_StartSoftTrig>
	l_u16CurrentZeroOffset = /* lint -e{530} */ u16ZCO;
    823a:	7201      	lod	A, [S-2]
    823c:	52d8 00c2 	mov	0xc2 <_l_u16CurrentZeroOffset>, A
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    8240:	72da 0101 	lod	A, #257
    8244:	5290      	mov	io:0x10 <__data_dp_size>, A
	while ((ADC_CTRL & ADC_START) != 0u) /* lint -e{722} */ 						/* Wait for ADC result */
    8246:	7290      	lod	A, io:0x10 <__data_dp_size>
    8248:	b401      	and	A, #1
    824a:	1d7d      	jne	0x8246 <_ADC_Init+0x1e>
	{
		
	}
	l_u16CurrentZeroOffset = (l_u16CurrentZeroOffset + u16ZCO) >> 1u;
    824c:	72d8 00c2 	lod	A, 0xc2 <_l_u16CurrentZeroOffset>
    8250:	7a01      	lod	Y, [S-2]
    8252:	a2e6      	add	A, Y
    8254:	4432      	lsr	A
    8256:	52d8 00c2 	mov	0xc2 <_l_u16CurrentZeroOffset>, A
	if ( u16Delta > 6 )															/* Need to define this value: 6 LSB's is approx. 5mA */
		l_u16CurrentZeroOffset = EE_OMCURR;										/* Take calibrated current offset, insetad of measured offset */
#endif /* SUPPORT_CALIBRATED_ZERO_CURRENT */


	PRIO &= ~((uint16)3u << 2u);												/* ADC IRQ Priority: 5 (3..6) (MMP150106-1) */
    825a:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    825e:	b4f3      	and	A, #-13
    8260:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(5u - 3u) << 2u);
    8264:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8268:	a408      	or	A, #8
    826a:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
    826e:	5403      	ret	#4

00008270 <_ADC_Start>:
 *
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Start( void)
{
	ADC_Stop();																	/* clear the ADC control register */
    8270:	17bc      	call	0x81ea <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_INIT_4PH;
    8272:	72da 98c6 	lod	A, #39110
    8276:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4;
    8278:	72da 00f0 	lod	A, #240
    827c:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_CTRL  = (ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);						/* Loop cycle of conversion is done */
    827e:	72da 0086 	lod	A, #134
    8282:	5290      	mov	io:0x10 <__data_dp_size>, A
	ADC_CTRL |= ADC_START;														/* Start ADC */
    8284:	7290      	lod	A, io:0x10 <__data_dp_size>
    8286:	a401      	or	A, #1
    8288:	5290      	mov	io:0x10 <__data_dp_size>, A
	if ( l_u8AdcPowerOff != 0u)													/* MMP140618-1: Add delay */
    828a:	62d8 00c0 	lod	AL, 0xc0 <_l_u8AdcPowerOff>
    828e:	1904      	je	0x8298 <_ADC_Start+0x28>
    8290:	7eda 008b 	lod	X, #139
    8294:	0000      	nop
    8296:	1bfe      	djnz	X, 0x8294 <_ADC_Start+0x24>
	{
		NopDelay( DELAY_mPWM); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    8298:	6000      	lod	AL, #0
    829a:	42d8 00c0 	mov	0xc0 <_l_u8AdcPowerOff>, AL
    829e:	5401      	ret

000082a0 <_ADC_PowerOff>:
 *
 * Power-off ADC, by disabling reference voltage
 * ****************************************************************************	*/
void ADC_PowerOff( void)
{
	ADC_Stop();																	/* Stop ADC conversion, and disable ADC-IRQ */
    82a0:	17a4      	call	0x81ea <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_VREF_OFF;
    82a2:	72da 98e6 	lod	A, #39142
    82a6:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	PEND = CLR_ADC_IT;
    82a8:	7040      	lod	A, #64
    82aa:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    82ae:	7001      	lod	A, #1
    82b0:	5290      	mov	io:0x10 <__data_dp_size>, A
	ADC_Stop();
    82b2:	179b      	call	0x81ea <_ADC_Stop>
	l_u8AdcPowerOff = TRUE;
    82b4:	6001      	lod	AL, #1
    82b6:	42d8 00c0 	mov	0xc0 <_l_u8AdcPowerOff>, AL
    82ba:	5401      	ret

000082bc <_ADC_IT>:
 * (push/pop + check for LIN-AA + Check BEMF ZC)
 * ****************************************************************************	*/
__interrupt__ void ADC_IT(void) 
{
#if ((LINPROT & LINXX) != LIN2J)
	if ( g_u8AdcIsrMode == C_ADC_ISR_LIN_AA ) 									/* LIN-AutoAddressing sequence */
    82bc:	4407      	mov	R, #0
    82be:	72cb      	pop	M
    82c0:	5401      	ret

000082c2 <_GetVsupply>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    82c2:	7ad8 00f2 	lod	Y, 0xf2 <_g_AdcMotorRunStepper4+0x2>
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    82c6:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    82ca:	5ce2      	ssex	A
    82cc:	eae2      	sub	Y, A
    82ce:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    82d2:	6000      	lod	AL, #0
    82d4:	72e4      	swap	A
    int32 result;

    __asm__ __volatile__ (
    82d6:	4811      	muls	D, A, Y
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    82d8:	4c80      	mov	YA, D
    82da:	4c22 0020 	add	YA, #32
    82de:	0000 
    82e0:	4cb2 0000 	cmp	YA, #0
    82e4:	0000 
    82e6:	1e84      	jsge	0x82f0 <_GetVsupply+0x2e>
    82e8:	4c80      	mov	YA, D
    82ea:	4c22 005f 	add	YA, #95
    82ee:	0000 
    82f0:	48b5      	asr	YA, #6
    82f2:	52d8 00ba 	mov	0xba <_g_i16SupplyVoltage>, A
    82f6:	5401      	ret

000082f8 <_GetVsupplyMotor>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupplyMotor( void)
{
	uint16 u16FilteredDriverVoltage = g_AdcMotorRunStepper4.FilteredDriverVoltage;
    82f8:	72d8 00f6 	lod	A, 0xf6 <_g_AdcMotorRunStepper4+0x6>
#if _SUPPORT_VSMFILTERED
	g_i16MotorVoltage = (int16) ((mulI32_I16byU16( (int16)(u16FilteredDriverVoltage - EE_OVOLTAGE), EE_GVOLTAGE) + (C_GVOLTAGE_DIV/2)) / C_GVOLTAGE_DIV);
    82fc:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    8300:	5ce6      	ssex	Y
    8302:	aae6      	sub	A, Y
    8304:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    8308:	6400      	lod	YL, #0
    830a:	7ae8      	swap	Y
    830c:	5adf      	push	Y
    830e:	82db 6c12 	callf	0x6c12 <_mulI32_I16byU16>
    8312:	4cc0      	mov	D, YA
    8314:	4c22 0020 	add	YA, #32
    8318:	0000 
    831a:	4cb2 0000 	cmp	YA, #0
    831e:	0000 
    8320:	1e84      	jsge	0x832a <_GetVsupplyMotor+0x32>
    8322:	4c80      	mov	YA, D
    8324:	4c22 005f 	add	YA, #95
    8328:	0000 
    832a:	48b5      	asr	YA, #6
    832c:	52d8 00b8 	mov	0xb8 <_g_i16MotorVoltage>, A
    8330:	5c01      	dec	S, #2
    8332:	5401      	ret

00008334 <_ResetChipTemperature>:
 *
 * Reset Chip temperature
 * ****************************************************************************	*/
void ResetChipTemperature( void)
{
	g_AdcMotorRunStepper4.IntTemperatureSensor = 0u;
    8334:	7ada 00f0 	lod	Y, #240
    8338:	7000      	lod	A, #0
    833a:	52f0      	mov	[Y], A
    833c:	5401      	ret

0000833e <_GetChipTemperature>:
 * GetChipTemperature()
 *
 * Get Chip temperature [C]
 * ****************************************************************************	*/
void GetChipTemperature( uint16 u16Init)										/* MMP131020-1 */
{
    833e:	580b      	inc	S, #12
    8340:	520b      	mov	[S-12], A
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    8342:	7ad8 00f0 	lod	Y, 0xf0 <_g_AdcMotorRunStepper4>
	int16 i16ChipTemperature, i16ChipTempDelta;

#if _SUPPORT_TWO_LINE_TEMP_INTERPOLATION
	if ( u16ChipTemperatureSensor < EE_OTEMP )
    8346:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    834a:	eee2      	cmp	Y, A
    834c:	1c11      	jnc	0x8370 <_GetChipTemperature+0x32>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    834e:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8352:	aae6      	sub	A, Y
    8354:	5203      	mov	[S-4], A
    8356:	785a      	lod	Y, #90
    8358:	7ed8 11ba 	lod	X, 0x11ba <__ep__+0x1ba>
    835c:	72d8 11bc 	lod	A, 0x11bc <__ep__+0x1bc>
    8360:	2ae2      	sub	X, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8362:	7203      	lod	A, [S-4]
    8364:	4821      	mulu	YA, A, Y
    8366:	4c63      	divu	YA, X
    8368:	4c63      	divu	YA, X
    836a:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    836c:	2023      	add	X, #35
    836e:	0012      	jmp	0x8394 <_GetChipTemperature+0x56>
    8370:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8374:	eae2      	sub	Y, A
    8376:	5a01      	mov	[S-2], Y
    8378:	7ed8 11b8 	lod	X, 0x11b8 <__ep__+0x1b8>
    837c:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    8380:	2ae6      	sub	X, Y
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8382:	704b      	lod	A, #75
    8384:	7a01      	lod	Y, [S-2]
    8386:	4821      	mulu	YA, A, Y
    8388:	4c63      	divu	YA, X
    838a:	4c63      	divu	YA, X
    838c:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    838e:	7023      	lod	A, #35
    8390:	aaee      	sub	A, X
    8392:	7ee2      	lod	X, A
	}
#else  /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */
	i16ChipTemperature = (mulI32_I16byI16( (EE_OTEMP - u16ChipTemperatureSensor), EE_GTEMP) / C_GTEMP_DIV) + EE_MIDTEMP;
#endif /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */

	if ( u16Init == FALSE )														/* MMP131020-1 */
    8394:	720b      	lod	A, [S-12]
    8396:	1d10      	jne	0x83b8 <_GetChipTemperature+0x7a>
	{
		i16ChipTempDelta = i16ChipTemperature - g_i16ChipTemperature;			/* Delta-temp = new-temp - previous-temp */
    8398:	7ad8 00b6 	lod	Y, 0xb6 <__bss_size>
    839c:	72ee      	lod	A, X
    839e:	aae6      	sub	A, Y
		if ( i16ChipTempDelta < 0 )
		{
			i16ChipTempDelta = -i16ChipTempDelta;								/* Absolute temperature change */
    83a0:	ac00      	cmp	A, #0
    83a2:	1e81      	jsge	0x83a6 <_GetChipTemperature+0x68>
    83a4:	5cc2      	neg	A
		}
		if ( (uint16) i16ChipTempDelta > C_TEMPERATURE_JUMP )					/* Temperature change small, then accept new temperature */
    83a6:	ac0a      	cmp	A, #10
    83a8:	1a07      	jule	0x83b8 <_GetChipTemperature+0x7a>
		{
			if ( i16ChipTemperature > g_i16ChipTemperature )					/* To great temperature change; Check temperature change "direction" */
    83aa:	2ee6      	cmp	X, Y
    83ac:	1b03      	jsle	0x83b4 <_GetChipTemperature+0x76>
			{
				i16ChipTemperature = g_i16ChipTemperature + 1;					/* Increase by one degree */
    83ae:	7ee6      	lod	X, Y
    83b0:	2001      	add	X, #1
    83b2:	0002      	jmp	0x83b8 <_GetChipTemperature+0x7a>
			}
			else
			{
				i16ChipTemperature = g_i16ChipTemperature - 1;					/* Decrease by one degree */
    83b4:	7ee6      	lod	X, Y
    83b6:	20ff      	add	X, #-1
			}
		}
	}																			/* MMP131020-1 */
	g_i16ChipTemperature = i16ChipTemperature;
    83b8:	5ed8 00b6 	mov	0xb6 <__bss_size>, X
    83bc:	540d      	ret	#14

000083be <_GetRawMotorDriverCurrent>:
 * ****************************************************************************	*/
uint16 GetRawMotorDriverCurrent( void)
{
	uint16 u16Current = 0;
#if ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL))
	u16Current = g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    83be:	72d8 00f8 	lod	A, 0xf8 <_g_AdcMotorRunStepper4+0x8>
	if ( u16Current > l_u16CurrentZeroOffset )
    83c2:	7ad8 00c2 	lod	Y, 0xc2 <_l_u16CurrentZeroOffset>
    83c6:	aee6      	cmp	A, Y
    83c8:	1a02      	jule	0x83ce <_GetRawMotorDriverCurrent+0x10>
	{
		g_u16CurrentMotorCoilA = u16Current -  l_u16CurrentZeroOffset;
    83ca:	aae6      	sub	A, Y
    83cc:	0001      	jmp	0x83d0 <_GetRawMotorDriverCurrent+0x12>
	}
	else
	{
		g_u16CurrentMotorCoilA = 0u;
    83ce:	7000      	lod	A, #0
    83d0:	52d8 00be 	mov	0xbe <_g_u16CurrentMotorCoilA>, A
	}
	
	u16Current = g_AdcMotorRunStepper4.UnfilteredDriverCurrent2;
    83d4:	72d8 00f4 	lod	A, 0xf4 <_g_AdcMotorRunStepper4+0x4>
	if ( u16Current > l_u16CurrentZeroOffset )
    83d8:	7ad8 00c2 	lod	Y, 0xc2 <_l_u16CurrentZeroOffset>
    83dc:	aee6      	cmp	A, Y
    83de:	1a02      	jule	0x83e4 <_GetRawMotorDriverCurrent+0x26>
	{
		g_u16CurrentMotorCoilB = u16Current - l_u16CurrentZeroOffset;
    83e0:	aae6      	sub	A, Y
    83e2:	0001      	jmp	0x83e6 <_GetRawMotorDriverCurrent+0x28>
	}
	else
	{
		g_u16CurrentMotorCoilB = 0u;
    83e4:	7000      	lod	A, #0
    83e6:	52d8 00bc 	mov	0xbc <_g_u16CurrentMotorCoilB>, A
	}
	u16Current = g_u16CurrentMotorCoilA + g_u16CurrentMotorCoilB;
    83ea:	72d8 00be 	lod	A, 0xbe <_g_u16CurrentMotorCoilA>
    83ee:	a2d8 00bc 	add	A, 0xbc <_g_u16CurrentMotorCoilB>
		u16Current = u16Current - l_u16CurrentZeroOffset;
	}
#endif /* ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)) */

	return ( u16Current );
} /* End of GetRawMotorDriverCurrent() */
    83f2:	5401      	ret

000083f4 <_GetMotorDriverCurrent>:
 *
 * Get Motor Driver Current [mA]
 * ****************************************************************************	*/
int16 GetMotorDriverCurrent( void)
{
	uint16 u16Current = GetRawMotorDriverCurrent();
    83f4:	17e4      	call	0x83be <_GetRawMotorDriverCurrent>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    83f6:	7ad8 11d0 	lod	Y, 0x11d0 <__ep__+0x1d0>
    83fa:	f6da 00ff 	and	Y, #255
    83fe:	e2da 0100 	add	Y, #256
    uint32 result;

    __asm__ __volatile__ (
    8402:	4801      	mulu	D, A, Y
    8404:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8406:	4c22 0040 	add	YA, #64
    840a:	0000 
    840c:	48a6      	lsr	YA, #7
	u16Current = (uint16) ((mulU32_U16byU16( u16Current, EE_GMCURR) + (C_GMCURR_DIV/2u)) / C_GMCURR_DIV);	/* MMP131117-1 */
	return ( (int16) u16Current);
} /* End of GetMotorDriverCurrent() */
    840e:	5401      	ret

00008410 <_MeasureVsupplyAndTemperature>:
 *
 * Measure Vbat and Temperature (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureVsupplyAndTemperature( void)
{	
	ADC_Stop();
    8410:	16ec      	call	0x81ea <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_MOTORVOLT;										/* switch ADC input source to Voltage */
    8412:	72da 98d6 	lod	A, #39126
    8416:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredDriverVoltage;
    8418:	72da 00f6 	lod	A, #246
    841c:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    841e:	16cc      	call	0x81b8 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_SUPPLYVOLT;										/* switch ADC input source to Voltage */
    8420:	72da 98da 	lod	A, #39130
    8424:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    8426:	72da 00f2 	lod	A, #242
    842a:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    842c:	16c5      	call	0x81b8 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_TEMP;											/* switch ADC input source to Temperature */
    842e:	72da 98de 	lod	A, #39134
    8432:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.IntTemperatureSensor;
    8434:	72da 00f0 	lod	A, #240
    8438:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    843a:	16be      	call	0x81b8 <_ADC_StartSoftTrig>
    843c:	5401      	ret

0000843e <_MeasureMotorCurrent>:
 *
 * Measure Motor-current (filtered) (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureMotorCurrent( void)
{
	ADC_Stop();
    843e:	16d5      	call	0x81ea <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURRENT;											/* switch ADC input source to Motor-driver current */
    8440:	72da 98d2 	lod	A, #39122
    8444:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    8446:	72da 00f8 	lod	A, #248
    844a:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    844c:	16b5      	call	0x81b8 <_ADC_StartSoftTrig>
    844e:	5401      	ret

00008450 <_MotorDiagnosticDrift>:
void HandleDiagnosticEvent( uint16 u16Event);


void MotorDiagnosticDrift(void)
{
	if ( g_u8MotorStartupMode == (uint8) MSM_STOP ) 
    8450:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8454:	1d0e      	jne	0x8472 <_MotorDiagnosticDrift+0x22>
	{
		l_u8DriftCheckCount++;
    8456:	62d8 00ce 	lod	AL, 0xce <_l_u8DriftCheckCount>
    845a:	8001      	add	AL, #1
    845c:	42d8 00ce 	mov	0xce <_l_u8DriftCheckCount>, AL
		if (l_u8DriftCheckCount >= C_DRIFT_DEBOUNCE_THR)
    8460:	8c04      	cmp	AL, #4
    8462:	1a0a      	jule	0x8478 <_MotorDiagnosticDrift+0x28>
		{
			l_u8DriftCheckCount = 0u;
    8464:	6000      	lod	AL, #0
    8466:	42d8 00ce 	mov	0xce <_l_u8DriftCheckCount>, AL
			g_sMotorFault.DRIFT = 1u;
    846a:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    846c:	8404      	or	AL, #4
    846e:	411d      	mov	dp:0x1d <_g_sMotorFault+0x1>, AL
    8470:	5401      	ret
		}
	}
    else
    {
		l_u8DriftCheckCount = 0u;
    8472:	6000      	lod	AL, #0
    8474:	42d8 00ce 	mov	0xce <_l_u8DriftCheckCount>, AL
    8478:	5401      	ret

0000847a <_HandleDiagnosticEvent>:
 * HandleDiagnosticEvent()
 *
 * Handle Diagnostic Events
 * ****************************************************************************	*/
void HandleDiagnosticEvent( uint16 u16Event)
{
    847a:	5801      	inc	S, #2
    847c:	5201      	mov	[S-2], A
	if ( (u16Event & (uint16)(XI4_OC_DRV | XI4_OVT)) != 0u )
    847e:	b6da 8100 	and	A, #33024
    8482:	1d01      	jne	0x8486 <_HandleDiagnosticEvent+0xc>
    8484:	003d      	jmp	0x8500 <_HandleDiagnosticEvent+0x86>
	{
		/* In case over-current or over-temperature, switch off motor */
#if _SUPPORT_DIAG_OC
		if ( (u16Event & (uint16)XI4_OC_DRV) != 0u )
    8486:	7201      	lod	A, [S-2]
    8488:	b6da 0100 	and	A, #256
    848c:	191f      	je	0x84cc <_HandleDiagnosticEvent+0x52>
			/* Chip over-current */
			/* The over-current may occur then chips has entered test-mode. The test-mode freezes the
			 * complete digital part of the chip, including the Motor PWM and driver. This may result
			 * in a phase H and a phase L, having a DC-current flow!!
			 */
			if (g_u8MotorStartupMode != (uint8) MSM_STOP)
    848e:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8492:	190a      	je	0x84a8 <_HandleDiagnosticEvent+0x2e>
    8494:	7eda 008b 	lod	X, #139
    8498:	0000      	nop
    849a:	1bfe      	djnz	X, 0x8498 <_HandleDiagnosticEvent+0x1e>
			{
				/* Average between two driver-current measurements */
				NopDelay( DELAY_mPWM); /*lint !e522 */								/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
				g_i16Current = GetMotorDriverCurrent();
    849c:	17ab      	call	0x83f4 <_GetMotorDriverCurrent>
    849e:	52d8 00b4 	mov	0xb4 <_g_i16Current>, A
				if ( g_i16Current > 1400 )
    84a2:	aeda 0578 	cmp	A, #1400
    84a6:	1b12      	jsle	0x84cc <_HandleDiagnosticEvent+0x52>
					SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
				}
			}
			else
			{
				DRVCFG_DIS_UVWT();												/* Over-current,holding current mode? */
    84a8:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    84ac:	b6da fe00 	and	A, #65024
    84b0:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
				DRVCFG_DIS();	
    84b4:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    84b8:	a6da 0100 	or	A, #256
    84bc:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
				g_sMotorFault.SHORT = 1u;
    84c0:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    84c2:	8408      	or	AL, #8
    84c4:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    84c6:	72da 00d0 	lod	A, #208
    84ca:	11b7      	call	0x883a <_SetLastError>
			}
		}
#endif /* _SUPPORT_DIAG_OC */
		if ( (u16Event & (uint16)XI4_OVT) != 0u )
    84cc:	7201      	lod	A, [S-2]
    84ce:	ac00      	cmp	A, #0
    84d0:	1e97      	jsge	0x8500 <_HandleDiagnosticEvent+0x86>
		{
			DRVCFG_DIS_UVWT();													/* Over-temperature shutdown,170+-15 */
    84d2:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    84d6:	b6da fe00 	and	A, #65024
    84da:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();
    84de:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    84e2:	a6da 0100 	or	A, #256
    84e6:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			g_sMotorFault.TS = 1u;
    84ea:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    84ec:	8420      	or	AL, #32
    84ee:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
			SetLastError( (uint8) C_ERR_DIAG_OVER_TEMP);
    84f0:	72da 00d1 	lod	A, #209
    84f4:	11a2      	call	0x883a <_SetLastError>

			ResetChipTemperature();
    84f6:	171e      	call	0x8334 <_ResetChipTemperature>
    84f8:	7eda 008b 	lod	X, #139
    84fc:	0000      	nop
    84fe:	1bfe      	djnz	X, 0x84fc <_HandleDiagnosticEvent+0x82>
    8500:	5403      	ret	#4

00008502 <_DiagnosticsInit>:
 * Don't automatically shut-off motor-driver on over- or under-voltage, or over-temperature.
 * Diagnostic ISR priority: 3 
 * ****************************************************************************	*/
void DiagnosticsInit( void)
{
	DRVCFG |= (DIS_OC | DIS_OT | DIS_OV | DIS_UV);					/* Disable over-current, over-temperature, over-voltage, under-voltage */
    8502:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8506:	a6da f000 	or	A, #61440
    850a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	ANA_OUTI &= ~SEL_UV_VS;											/* Enable UV & OV debounce circuitry */
    850e:	72d8 28d0 	lod	A, 0x28d0 <__io__+0xd0>
    8512:	b6da efff 	and	A, #61439
    8516:	52d8 28d0 	mov	0x28d0 <__io__+0xd0>, A
	ANA_OUTG &= 0xFCFFu;												/* Brown-out UV-level = 6V + n * 1V; */
    851a:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    851e:	b6da fcff 	and	A, #64767
    8522:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
	ANA_OUTG |= (NVRAM_BROWNOUT_LEVEL << 8u);				
    8526:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    852a:	a6da 0100 	or	A, #256
    852e:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
	{
		/* IO[0] is low; Set IRQ-event on rising-edge */
		IO_CFG &= ~FRB_IO5;
	}
#else  /* (_SUPPORT_HALL_SENSOR) */
	XI4_PEND = C_DIAG_MASK;
    8532:	72da e100 	lod	A, #57600
    8536:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	XI4_MASK |= C_DIAG_MASK;
    853a:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    853e:	a6da e100 	or	A, #57600
    8542:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
#endif /* (_SUPPORT_HALL_SENSOR) */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */							/* EXT4_IT Priority: 3 (3..6) */
	PRIO &= ~((uint16)3u << 14u);												/* EXT4_IT Priority: 3 (3..6) */
    8546:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    854a:	b6da 3fff 	and	A, #16383
    854e:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(3u - 3u) << 14u);
	PEND = CLR_EXT4_IT;
    8552:	72da 1000 	lod	A, #4096
    8556:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    855a:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    855e:	a6da 1000 	or	A, #4096
    8562:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* MMP141212-1: Check for OVT and OV. Perform Diagnostics handling if required */
	{
#if (_SUPPORT_DIAG_OVT == FALSE)
		uint16 u16DiagnosticEvent = (ANA_INA & XI4_OV);
#else  /* (_SUPPORT_DIAG_OVT == FALSE) */
		uint16 u16DiagnosticEvent = (ANA_INA & (XI4_OVT | XI4_OV));
    8566:	729c      	lod	A, io:0x1c <_g_sMotorFault>
    8568:	b6da a000 	and	A, #40960
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */
		if ( u16DiagnosticEvent != 0u )
    856c:	1901      	je	0x8570 <_DiagnosticsInit+0x6e>
		{
			HandleDiagnosticEvent( u16DiagnosticEvent);
    856e:	1785      	call	0x847a <_HandleDiagnosticEvent>
    8570:	5401      	ret

00008572 <_EXT4_IT>:
 * EXT4_IT()
 *
 * Diagnostic & IO Interrupt Service Routine.
 * ****************************************************************************	*/
__interrupt__ void EXT4_IT(void)
{
    8572:	52df      	push	A
    8574:	5edf      	push	X
    8576:	5adf      	push	Y
    8578:	4c83      	push	D
    857a:	5801      	inc	S, #2
	uint16 u16Pending = (XI4_PEND & XI4_MASK);									/* Copy interrupt requests which are not masked   */
    857c:	7ad8 203c 	lod	Y, 0x203c <__ep__+0x103c>
    8580:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    8584:	f6e2      	and	Y, A
    8586:	5a01      	mov	[S-2], Y
	do
	{
		XI4_PEND = u16Pending;													/* Clear requests which are going to be processed */
    8588:	7201      	lod	A, [S-2]
    858a:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	} while ((XI4_PEND & u16Pending) != 0u);
    858e:	72d8 203c 	lod	A, 0x203c <__ep__+0x103c>
    8592:	b601      	and	A, [S-2]
    8594:	1d79      	jne	0x8588 <_EXT4_IT+0x16>

	/* Multiple diagnostics events is most likely caused by Rinnen/ESD-pulse */
	if ( ((u16Pending & XI4_UV) != 0u) && ((u16Pending & (XI4_OC_DRV | XI4_OVT | XI4_OV)) != 0u) )
    8596:	7201      	lod	A, [S-2]
    8598:	b6da 4000 	and	A, #16384
    859c:	1904      	je	0x85a6 <_EXT4_IT+0x34>
    859e:	7201      	lod	A, [S-2]
    85a0:	b6da a100 	and	A, #41216
    85a4:	1d18      	jne	0x85d6 <_EXT4_IT+0x64>
	{
		/* Under-voltage together with any other diagnostic event is strange */
	}
	else
	{
		HandleDiagnosticEvent( u16Pending);
    85a6:	7201      	lod	A, [S-2]
    85a8:	1768      	call	0x847a <_HandleDiagnosticEvent>

		if ( (u16Pending & XI4_IO5) != 0u )
    85aa:	7201      	lod	A, [S-2]
    85ac:	b420      	and	A, #32
    85ae:	1913      	je	0x85d6 <_EXT4_IT+0x64>
		{
			l_u16HallSwitchState = (IO_IN & XI4_IO5);
    85b0:	72d8 28ca 	lod	A, 0x28ca <__io__+0xca>
    85b4:	b420      	and	A, #32
    85b6:	52d8 00d0 	mov	0xd0 <_l_u16HallSwitchState>, A
			if ( l_u16HallSwitchState != 0u )
    85ba:	1904      	je	0x85c4 <_EXT4_IT+0x52>
			{
				/* IO[0] is high; Set IRQ-event on falling-edge */
				IO_CFG |= FRB_IO5;
    85bc:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    85c0:	a420      	or	A, #32
    85c2:	0003      	jmp	0x85ca <_EXT4_IT+0x58>
			}
			else
			{
				/* IO[0] is low; Set IRQ-event on rising-edge */
				IO_CFG &= ~FRB_IO5;
    85c4:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    85c8:	b4df      	and	A, #-33
    85ca:	52d8 28be 	mov	0x28be <__io__+0xbe>, A
			}

#if _SUPPORT_DRIFT_CHECK
			MotorDiagnosticDrift();	
    85ce:	1740      	call	0x8450 <_MotorDiagnosticDrift>
#endif	/* _SUPPORT_DRIFT_CHECK */

			g_u16HallMicroStepIdx = g_u16ActuatorActPos;
    85d0:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    85d2:	52d8 00d2 	mov	0xd2 <_g_u16HallMicroStepIdx>, A
    85d6:	5c01      	dec	S, #2
    85d8:	4cc3      	pop	D
    85da:	7acf      	pop	Y
    85dc:	7ecf      	pop	X
    85de:	72cf      	pop	A
    85e0:	4407      	mov	R, #0
    85e2:	72cb      	pop	M
    85e4:	5401      	ret

000085e6 <_MotorDiagnosticCheckInit>:
	}
} /* EXT4_IT() */

void MotorDiagnosticCheckInit(void)
{
	l_u16CoilCurrentStartDelay = 2u * C_MOVAVG_SZ;
    85e6:	7040      	lod	A, #64
    85e8:	52d8 00c4 	mov	0xc4 <_l_u16CoilCurrentStartDelay>, A
	l_u16CoilZeroCurrCountA = 0u;
    85ec:	7000      	lod	A, #0
    85ee:	52d8 00c8 	mov	0xc8 <_l_u16CoilZeroCurrCountA>, A
	l_u16CoilZeroCurrCountB = 0u;
    85f2:	52d8 00c6 	mov	0xc6 <_l_u16CoilZeroCurrCountB>, A
    85f6:	5401      	ret

000085f8 <_MotorDiagnosticOpenCheck>:
}

uint8  MotorDiagnosticOpenCheck(void)
{
	
	if(l_u16CoilCurrentStartDelay == 0u)
    85f8:	72d8 00c4 	lod	A, 0xc4 <_l_u16CoilCurrentStartDelay>
    85fc:	1d2c      	jne	0x8656 <_MotorDiagnosticOpenCheck+0x5e>
	{
		if( g_u16CurrentMotorCoilA <  C_MIN_COIL_CURRENT )
    85fe:	72d8 00be 	lod	A, 0xbe <_g_u16CurrentMotorCoilA>
    8602:	7ad8 00c8 	lod	Y, 0xc8 <_l_u16CoilZeroCurrCountA>
    8606:	7ed8 00bc 	lod	X, 0xbc <_g_u16CurrentMotorCoilB>
    860a:	ac09      	cmp	A, #9
    860c:	1e03      	jug	0x8614 <_MotorDiagnosticOpenCheck+0x1c>
		{
			l_u16CoilZeroCurrCountA++;
    860e:	72e6      	lod	A, Y
    8610:	a001      	add	A, #1
    8612:	0004      	jmp	0x861c <_MotorDiagnosticOpenCheck+0x24>
		}
		else
		{
			if ( l_u16CoilZeroCurrCountA > 0u )
    8614:	ec00      	cmp	Y, #0
    8616:	1904      	je	0x8620 <_MotorDiagnosticOpenCheck+0x28>
			{
				l_u16CoilZeroCurrCountA--;
    8618:	72e6      	lod	A, Y
    861a:	a0ff      	add	A, #-1
    861c:	52d8 00c8 	mov	0xc8 <_l_u16CoilZeroCurrCountA>, A
    8620:	7ad8 00c8 	lod	Y, 0xc8 <_l_u16CoilZeroCurrCountA>
    8624:	72d8 00c6 	lod	A, 0xc6 <_l_u16CoilZeroCurrCountB>
			}
		}

		if( g_u16CurrentMotorCoilB < C_MIN_COIL_CURRENT  )
    8628:	2c09      	cmp	X, #9
    862a:	1e02      	jug	0x8630 <_MotorDiagnosticOpenCheck+0x38>
		{
			l_u16CoilZeroCurrCountB++;
    862c:	a001      	add	A, #1
    862e:	0003      	jmp	0x8636 <_MotorDiagnosticOpenCheck+0x3e>
		}
		else
		{
			if ( l_u16CoilZeroCurrCountB > 0u )
    8630:	ac00      	cmp	A, #0
    8632:	1903      	je	0x863a <_MotorDiagnosticOpenCheck+0x42>
			{
				l_u16CoilZeroCurrCountB--;
    8634:	a0ff      	add	A, #-1
    8636:	52d8 00c6 	mov	0xc6 <_l_u16CoilZeroCurrCountB>, A
			}
		}

		if((l_u16CoilZeroCurrCountA >= C_COIL_ZERO_CURRENT_COUNT) || (l_u16CoilZeroCurrCountB >= C_COIL_ZERO_CURRENT_COUNT))
    863a:	ec1f      	cmp	Y, #31
    863c:	1e04      	jug	0x8646 <_MotorDiagnosticOpenCheck+0x4e>
    863e:	72d8 00c6 	lod	A, 0xc6 <_l_u16CoilZeroCurrCountB>
    8642:	ac1f      	cmp	A, #31
    8644:	1a0b      	jule	0x865c <_MotorDiagnosticOpenCheck+0x64>
		{
			g_sMotorFault.OPEN = 1u;
    8646:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8648:	8404      	or	AL, #4
    864a:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
			SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
    864c:	72da 00e6 	lod	A, #230
    8650:	10f4      	call	0x883a <_SetLastError>
			return 1;
    8652:	7001      	lod	A, #1
    8654:	5401      	ret
	}
	else
	{
		if(l_u16CoilCurrentStartDelay > 0u)
		{
			l_u16CoilCurrentStartDelay--;
    8656:	a0ff      	add	A, #-1
    8658:	52d8 00c4 	mov	0xc4 <_l_u16CoilCurrentStartDelay>, A
		}
	}

	return 0;
    865c:	7000      	lod	A, #0
}
    865e:	5401      	ret

00008660 <_MotorDiagnosticVsupplyAndTemperature>:
{
	
	int16 voltage_raw;

	/* Perform Vbat/Temperature measurement incase motor is stopped */
	if(g_u8MotorStartupMode == (uint8) MSM_STOP)	
    8660:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8664:	1d01      	jne	0x8668 <_MotorDiagnosticVsupplyAndTemperature+0x8>
	{
		MeasureVsupplyAndTemperature();
    8666:	16d4      	call	0x8410 <_MeasureVsupplyAndTemperature>
	}
	/***************************************************
	 * p. Motor over/under temperature
	***************************************************/
	/* Calculate Voltage (100LSB/V) [10mV] */
	GetVsupply();
    8668:	162c      	call	0x82c2 <_GetVsupply>
	GetVsupplyMotor();
    866a:	1646      	call	0x82f8 <_GetVsupplyMotor>
	/* supply voltage is compensated with the shorty diode voltage drop and inductor voltage drop 
		 * in motor run(current peak) and motor stop(current valley) conditions.
	  */
	if (g_u8MotorStartupMode  != (uint8) MSM_STOP )
    866c:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8670:	7ad8 00b8 	lod	Y, 0xb8 <_g_i16MotorVoltage>
    8674:	8c00      	cmp	AL, #0
    8676:	1903      	je	0x867e <_MotorDiagnosticVsupplyAndTemperature+0x1e>
	{
		voltage_raw = g_i16MotorVoltage + C_VDS_RUN;
    8678:	72e6      	lod	A, Y
    867a:	a041      	add	A, #65
    867c:	0002      	jmp	0x8682 <_MotorDiagnosticVsupplyAndTemperature+0x22>
	}
	else
	{
		voltage_raw = g_i16MotorVoltage + C_VDS_STOP;
    867e:	72e6      	lod	A, Y
    8680:	a023      	add	A, #35
	}

	if ( voltage_raw < (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS) )
    8682:	aeda 0351 	cmp	A, #849
    8686:	1f16      	jsg	0x86b4 <_MotorDiagnosticVsupplyAndTemperature+0x54>
	{
		voltage_raw = (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS);
		/* First time application under-voltage error */					/* MMP150128-1 - Begin */
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_UV) == 0x00u )
    8688:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    868c:	72e6      	lod	A, Y
    868e:	b404      	and	A, #4
    8690:	1d03      	jne	0x8698 <_MotorDiagnosticVsupplyAndTemperature+0x38>
		{
			/* Need twice a under-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_UV;
    8692:	62e8      	lod	AL, YL
    8694:	8404      	or	AL, #4
    8696:	0032      	jmp	0x86fc <_MotorDiagnosticVsupplyAndTemperature+0x9c>
			l_u8UOVoltageCount = 0u;
		}
		else
		{
			l_u8UOVoltageCount++;
    8698:	62d8 00cc 	lod	AL, 0xcc <_l_u8UOVoltageCount>
    869c:	8001      	add	AL, #1
    869e:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    86a2:	8c05      	cmp	AL, #5
    86a4:	1e01      	jug	0x86a8 <_MotorDiagnosticVsupplyAndTemperature+0x48>
    86a6:	0040      	jmp	0x8728 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    86a8:	6006      	lod	AL, #6
    86aa:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
				g_sMotorFault.UV = 1u; 								/* 9.5.3.4 */
    86ae:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    86b0:	8401      	or	AL, #1
    86b2:	0039      	jmp	0x8726 <_MotorDiagnosticVsupplyAndTemperature+0xc6>
			}
		}
	}
	else if ( voltage_raw > (NVRAM_APPL_OVOLT + C_VOLTAGE_HYS) )
    86b4:	aeda 079e 	cmp	A, #1950
    86b8:	1b15      	jsle	0x86e4 <_MotorDiagnosticVsupplyAndTemperature+0x84>
	{
		/* First time application over-voltage error */
		if ( (l_e8ErrorDebounceFilter & C_DEBFLT_ERR_OV) == 0x00u )
    86ba:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    86be:	72e6      	lod	A, Y
    86c0:	b408      	and	A, #8
    86c2:	1d03      	jne	0x86ca <_MotorDiagnosticVsupplyAndTemperature+0x6a>
		{
			/* Need twice a over-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OV;
    86c4:	62e8      	lod	AL, YL
    86c6:	8408      	or	AL, #8
    86c8:	0019      	jmp	0x86fc <_MotorDiagnosticVsupplyAndTemperature+0x9c>
			l_u8UOVoltageCount = 0u;
		}
		else
		{
			l_u8UOVoltageCount++;
    86ca:	62d8 00cc 	lod	AL, 0xcc <_l_u8UOVoltageCount>
    86ce:	8001      	add	AL, #1
    86d0:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    86d4:	8c05      	cmp	AL, #5
    86d6:	1a28      	jule	0x8728 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    86d8:	6006      	lod	AL, #6
    86da:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
				g_sMotorFault.OV = 1u;									/* 9.5.3.4 */
    86de:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    86e0:	8402      	or	AL, #2
    86e2:	0021      	jmp	0x8726 <_MotorDiagnosticVsupplyAndTemperature+0xc6>
			}
		}
	}
	else if ( (voltage_raw >= NVRAM_APPL_UVOLT) && (voltage_raw <= NVRAM_APPL_OVOLT) )
    86e4:	a2da fc7c 	add	A, #64636
    86e8:	aeda 03e8 	cmp	A, #1000
    86ec:	1e1d      	jug	0x8728 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
	{
		if((l_e8ErrorDebounceFilter & (C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV)) != 0u)
    86ee:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    86f2:	72e6      	lod	A, Y
    86f4:	b40c      	and	A, #12
    86f6:	1908      	je	0x8708 <_MotorDiagnosticVsupplyAndTemperature+0xa8>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
    86f8:	62e8      	lod	AL, YL
    86fa:	94f3      	and	AL, #-13
    86fc:	42d8 00cd 	mov	0xcd <_l_e8ErrorDebounceFilter>, AL
			l_u8UOVoltageCount = 0u;
    8700:	6000      	lod	AL, #0
    8702:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
    8706:	0010      	jmp	0x8728 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
		}
		else
		{
			l_u8UOVoltageCount++;
    8708:	62d8 00cc 	lod	AL, 0xcc <_l_u8UOVoltageCount>
    870c:	8001      	add	AL, #1
    870e:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    8712:	8c05      	cmp	AL, #5
    8714:	1a09      	jule	0x8728 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    8716:	6006      	lod	AL, #6
    8718:	42d8 00cc 	mov	0xcc <_l_u8UOVoltageCount>, AL
				g_sMotorFault.UV = 0u;
    871c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    871e:	94fe      	and	AL, #-2
    8720:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				g_sMotorFault.OV = 0u;
    8722:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8724:	94fd      	and	AL, #-3
    8726:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
	
	/***************************************************
	 * p. Motor over temperature check 
	***************************************************/
	/* Calculate Chip internal temperature (1LSB/C) [C] */
	GetChipTemperature( FALSE)												/* MMP131020-1 */;
    8728:	7000      	lod	A, #0
    872a:	1609      	call	0x833e <_GetChipTemperature>
	/* Thermal Shutdown */
	
	if ( g_i16ChipTemperature > NVRAM_APPL_OTEMP_SHUT )
    872c:	72d8 00b6 	lod	A, 0xb6 <__bss_size>
    8730:	aeda 008c 	cmp	A, #140
    8734:	1b19      	jsle	0x8768 <_MotorDiagnosticVsupplyAndTemperature+0x108>
    {
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVTS) == 0x00u )
    8736:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    873a:	72e6      	lod	A, Y
    873c:	b420      	and	A, #32
    873e:	1d03      	jne	0x8746 <_MotorDiagnosticVsupplyAndTemperature+0xe6>
		{
			/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVTS;
    8740:	62e8      	lod	AL, YL
    8742:	8420      	or	AL, #32
    8744:	001b      	jmp	0x877c <_MotorDiagnosticVsupplyAndTemperature+0x11c>
			l_u8OverTemperatureShutCount = 0u;
		}
		else
		{
			l_u8OverTemperatureShutCount++;
    8746:	62d8 00ca 	lod	AL, 0xca <_l_u8OverTemperatureShutCount>
    874a:	8001      	add	AL, #1
    874c:	42d8 00ca 	mov	0xca <_l_u8OverTemperatureShutCount>, AL
			if ( l_u8OverTemperatureShutCount >= (uint8) C_OVT_DEBOUNCE_THR )
    8750:	8c05      	cmp	AL, #5
    8752:	1a27      	jule	0x87a2 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			{
				l_u8OverTemperatureShutCount = C_OVT_DEBOUNCE_THR;
    8754:	6006      	lod	AL, #6
    8756:	42d8 00ca 	mov	0xca <_l_u8OverTemperatureShutCount>, AL
				g_sMotorFault.TS = 0x01u;
    875a:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    875c:	8420      	or	AL, #32
    875e:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				SetLastError( (uint8) C_ERR_APPL_OVER_TEMP);
    8760:	72da 00a1 	lod	A, #161
    8764:	106a      	call	0x883a <_SetLastError>
    8766:	001d      	jmp	0x87a2 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			}
		}
	}
	else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP_SHUT - C_TEMPERATURE_HYS) )
    8768:	aeda 0086 	cmp	A, #134
    876c:	1f1a      	jsg	0x87a2 <_MotorDiagnosticVsupplyAndTemperature+0x142>
	{
		if(l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVTS)
    876e:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    8772:	72e6      	lod	A, Y
    8774:	b420      	and	A, #32
    8776:	1908      	je	0x8788 <_MotorDiagnosticVsupplyAndTemperature+0x128>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVTS;
    8778:	62e8      	lod	AL, YL
    877a:	94df      	and	AL, #-33
    877c:	42d8 00cd 	mov	0xcd <_l_e8ErrorDebounceFilter>, AL
			l_u8OverTemperatureShutCount = 0u;
    8780:	6000      	lod	AL, #0
    8782:	42d8 00ca 	mov	0xca <_l_u8OverTemperatureShutCount>, AL
    8786:	000d      	jmp	0x87a2 <_MotorDiagnosticVsupplyAndTemperature+0x142>
		}
		else
		{
			l_u8OverTemperatureShutCount++;
    8788:	62d8 00ca 	lod	AL, 0xca <_l_u8OverTemperatureShutCount>
    878c:	8001      	add	AL, #1
    878e:	42d8 00ca 	mov	0xca <_l_u8OverTemperatureShutCount>, AL
			if(l_u8OverTemperatureShutCount >= C_OVT_DEBOUNCE_THR)
    8792:	8c05      	cmp	AL, #5
    8794:	1a06      	jule	0x87a2 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			{
				l_u8OverTemperatureShutCount = C_OVT_DEBOUNCE_THR;
    8796:	6006      	lod	AL, #6
    8798:	42d8 00ca 	mov	0xca <_l_u8OverTemperatureShutCount>, AL
				g_sMotorFault.TS = 0u;	
    879c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    879e:	94df      	and	AL, #-33
    87a0:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
	}

	
	
	/* Thermal Warning */
	if ( g_i16ChipTemperature > NVRAM_APPL_OTEMP_WARN )
    87a2:	72d8 00b6 	lod	A, 0xb6 <__bss_size>
    87a6:	aeda 0082 	cmp	A, #130
    87aa:	1b16      	jsle	0x87d8 <_MotorDiagnosticVsupplyAndTemperature+0x178>
    {
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT) == 0x00 )
    87ac:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    87b0:	72e6      	lod	A, Y
    87b2:	b402      	and	A, #2
    87b4:	1d03      	jne	0x87bc <_MotorDiagnosticVsupplyAndTemperature+0x15c>
		{
			/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVT;
    87b6:	62e8      	lod	AL, YL
    87b8:	8402      	or	AL, #2
    87ba:	0017      	jmp	0x87ea <_MotorDiagnosticVsupplyAndTemperature+0x18a>
			l_u8OverTemperatureWarnCount = 0u;
		}
		else
		{
			l_u8OverTemperatureWarnCount++;
    87bc:	62d8 00cb 	lod	AL, 0xcb <_l_u8OverTemperatureWarnCount>
    87c0:	8001      	add	AL, #1
    87c2:	42d8 00cb 	mov	0xcb <_l_u8OverTemperatureWarnCount>, AL
			if ( l_u8OverTemperatureWarnCount >= (uint8) C_OVT_DEBOUNCE_THR )
    87c6:	8c05      	cmp	AL, #5
    87c8:	1a23      	jule	0x8810 <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
			{
				l_u8OverTemperatureWarnCount = C_OVT_DEBOUNCE_THR;
    87ca:	6006      	lod	AL, #6
    87cc:	42d8 00cb 	mov	0xcb <_l_u8OverTemperatureWarnCount>, AL
				g_sMotorFault.TW = 0x01u;
    87d0:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    87d2:	8410      	or	AL, #16
    87d4:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
    87d6:	5401      	ret
			}
		}
	}
	else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP_WARN - C_TEMPERATURE_HYS) )
    87d8:	ac7c      	cmp	A, #124
    87da:	1f1a      	jsg	0x8810 <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
	{
		if(l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT)
    87dc:	66d8 00cd 	lod	YL, 0xcd <_l_e8ErrorDebounceFilter>
    87e0:	72e6      	lod	A, Y
    87e2:	b402      	and	A, #2
    87e4:	1908      	je	0x87f6 <_MotorDiagnosticVsupplyAndTemperature+0x196>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVT;
    87e6:	62e8      	lod	AL, YL
    87e8:	94fd      	and	AL, #-3
    87ea:	42d8 00cd 	mov	0xcd <_l_e8ErrorDebounceFilter>, AL
			l_u8OverTemperatureWarnCount = 0u;
    87ee:	6000      	lod	AL, #0
    87f0:	42d8 00cb 	mov	0xcb <_l_u8OverTemperatureWarnCount>, AL
    87f4:	5401      	ret
		}
		else
		{
			l_u8OverTemperatureWarnCount++;
    87f6:	62d8 00cb 	lod	AL, 0xcb <_l_u8OverTemperatureWarnCount>
    87fa:	8001      	add	AL, #1
    87fc:	42d8 00cb 	mov	0xcb <_l_u8OverTemperatureWarnCount>, AL
			if(l_u8OverTemperatureWarnCount >= C_OVT_DEBOUNCE_THR)
    8800:	8c05      	cmp	AL, #5
    8802:	1a06      	jule	0x8810 <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
			{
				l_u8OverTemperatureWarnCount = C_OVT_DEBOUNCE_THR;
    8804:	6006      	lod	AL, #6
    8806:	42d8 00cb 	mov	0xcb <_l_u8OverTemperatureWarnCount>, AL
				g_sMotorFault.TW = 0u;
    880a:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    880c:	94ef      	and	AL, #-17
    880e:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
    8810:	5401      	ret

00008812 <_ErrorLogInit>:
 *
 *	Comments:	Clear Error-FiFo-buffer, in case watchdog reset occurred, 
 *				otherwise leave untouched.
 * ****************************************************************************	*/
void ErrorLogInit( void)
{
    8812:	5803      	inc	S, #4
	if ( (AWD_CTRL & AWD_RST) != 0u )
    8814:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    8816:	ac00      	cmp	A, #0
    8818:	1e8f      	jsge	0x8838 <_ErrorLogInit+0x26>
	{
		uint16 i;
		for ( i = 0u; i < C_ERR_LOG_SZ; i++ )
    881a:	7000      	lod	A, #0
    881c:	780a      	lod	Y, #10
    881e:	5a01      	mov	[S-2], Y
		{
			l_au8FiFoErrorLog[i] = (uint8)C_ERR_NONE;
    8820:	7ee2      	lod	X, A
    8822:	22da 00fa 	add	X, #250
    8826:	6400      	lod	YL, #0
    8828:	46f8      	mov	[X], YL
void ErrorLogInit( void)
{
	if ( (AWD_CTRL & AWD_RST) != 0u )
	{
		uint16 i;
		for ( i = 0u; i < C_ERR_LOG_SZ; i++ )
    882a:	a001      	add	A, #1
    882c:	7e01      	lod	X, [S-2]
    882e:	20ff      	add	X, #-1
    8830:	5e01      	mov	[S-2], X
    8832:	1d76      	jne	0x8820 <_ErrorLogInit+0xe>
		{
			l_au8FiFoErrorLog[i] = (uint8)C_ERR_NONE;
		}
		l_u8ErrorLogIdx = 0u;
    8834:	46d8 00d4 	mov	0xd4 <_l_u8ErrorLogIdx>, YL
    8838:	5405      	ret	#6

0000883a <_SetLastError>:
 *
 *	Comments:	Save error-code in Error-FiFo-buffer, unless last error is the 
 *				same as error posted.
 * ****************************************************************************	*/
void SetLastError( uint8 u8ErrorCode)
{
    883a:	5803      	inc	S, #4
    883c:	5203      	mov	[S-4], A
	if ( (l_u8ErrorLogIdx == 0u) || (l_au8FiFoErrorLog[l_u8ErrorLogIdx - 1u] != u8ErrorCode) )
    883e:	62d8 00d4 	lod	AL, 0xd4 <_l_u8ErrorLogIdx>
    8842:	4201      	mov	[S-2], AL
    8844:	1907      	je	0x8854 <_SetLastError+0x1a>
    8846:	5cf2      	usex	A
    8848:	7ae2      	lod	Y, A
    884a:	e2da 00f9 	add	Y, #249
    884e:	62f0      	lod	AL, [Y]
    8850:	8e03      	cmp	AL, [S-4]
    8852:	190d      	je	0x886e <_SetLastError+0x34>
	{
		/* Don't log the same error over and over again */
		l_au8FiFoErrorLog[l_u8ErrorLogIdx] = u8ErrorCode;
    8854:	6201      	lod	AL, [S-2]
    8856:	5cf2      	usex	A
    8858:	7ae2      	lod	Y, A
    885a:	e2da 00fa 	add	Y, #250
    885e:	6203      	lod	AL, [S-4]
    8860:	42f0      	mov	[Y], AL
		if ( l_u8ErrorLogIdx < (C_ERR_LOG_SZ - 1u) )
    8862:	6201      	lod	AL, [S-2]
    8864:	8c08      	cmp	AL, #8
    8866:	1e03      	jug	0x886e <_SetLastError+0x34>
		{
			l_u8ErrorLogIdx++;
    8868:	8001      	add	AL, #1
    886a:	42d8 00d4 	mov	0xd4 <_l_u8ErrorLogIdx>, AL
    886e:	5405      	ret	#6

00008870 <_GetLastError>:
#endif
	}
} /* End of SetLastError() */

uint8 GetLastError( void)
{
    8870:	5809      	inc	S, #10
	uint8 u8Reply = l_au8FiFoErrorLog[0];
    8872:	62d8 00fa 	lod	AL, 0xfa <_l_au8FiFoErrorLog>
    8876:	5cf2      	usex	A
    8878:	5209      	mov	[S-10], A
	if ( l_u8ErrorLogIdx != 0u )
    887a:	62d8 00d4 	lod	AL, 0xd4 <_l_u8ErrorLogIdx>
    887e:	4207      	mov	[S-8], AL
    8880:	1924      	je	0x88ca <_GetLastError+0x5a>
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8882:	72e3      	lod	A, M
    8884:	5203      	mov	[S-4], A
	{
		uint16 i;
		ATOMIC_CODE
    8886:	4407      	mov	R, #0
    8888:	500c      	call	fp0:0x60
    888a:	54f0      	mov	UPr, #0
    888c:	7001      	lod	A, #1
    888e:	5205      	mov	[S-6], A
    8890:	6207      	lod	AL, [S-8]
    8892:	5cf2      	usex	A
    8894:	5201      	mov	[S-2], A
    8896:	7001      	lod	A, #1
    8898:	ae01      	cmp	A, [S-2]
    889a:	1c0b      	jnc	0x88b2 <_GetLastError+0x42>
    889c:	7a05      	lod	Y, [S-6]
    889e:	e2da 00fa 	add	Y, #250
    88a2:	7ee6      	lod	X, Y
    88a4:	20ff      	add	X, #-1
    88a6:	62f0      	lod	AL, [Y]
    88a8:	42f8      	mov	[X], AL
    88aa:	7205      	lod	A, [S-6]
    88ac:	a001      	add	A, #1
    88ae:	5205      	mov	[S-6], A
    88b0:	07f3      	jmp	0x8898 <_GetLastError+0x28>
    88b2:	6207      	lod	AL, [S-8]
    88b4:	80ff      	add	AL, #-1
    88b6:	42d8 00d4 	mov	0xd4 <_l_u8ErrorLogIdx>, AL
    88ba:	5cf2      	usex	A
    88bc:	7ae2      	lod	Y, A
    88be:	e2da 00fa 	add	Y, #250
    88c2:	6000      	lod	AL, #0
    88c4:	42f0      	mov	[Y], AL
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    88c6:	7203      	lod	A, [S-4]
    88c8:	52e3      	mov	M, A
			l_u8ErrorLogIdx--;
			l_au8FiFoErrorLog[l_u8ErrorLogIdx] = C_ERR_NONE;
		);
	}
	return ( u8Reply );
} /* End of GetLastError() */
    88ca:	7209      	lod	A, [S-10]
    88cc:	540b      	ret	#12

000088ce <_MotorDriverSetParams>:

/* public functions implementation */

void MotorDriverSetParams(Motor_ControlParams params)
{
	l_u8MotorRequest = params.MotorCtrl;
    88ce:	7aef      	lod	Y, S
    88d0:	e0f2      	add	Y, #-14
    88d2:	72f0      	lod	A, [Y]
    88d4:	42d8 00d5 	mov	0xd5 <_l_u8MotorRequest>, AL
	if( params.TgtPos != 0xFFFFu )
    88d8:	72f2      	lod	A, [Y+2]
    88da:	acff      	cmp	A, #-1
    88dc:	1901      	je	0x88e0 <_MotorDriverSetParams+0x12>
	{
		l_u16ActuatorBufferedTgtPos = params.TgtPos;
    88de:	514c      	mov	dp:0x4c <_l_u16ActuatorBufferedTgtPos>, A
	}
	/* argument check:actuator actual position should not be invalid  */
	if( params.ActPos != 0xFFFFu )
    88e0:	72f4      	lod	A, [Y+4]
    88e2:	acff      	cmp	A, #-1
    88e4:	1901      	je	0x88e8 <_MotorDriverSetParams+0x1a>
	{
		g_u16ActuatorActPos = params.ActPos;
    88e6:	5146      	mov	dp:0x46 <_g_u16ActuatorActPos>, A
	}

	/* update target speed */
	if( params.SpdRPM != 0xFFFFu )
    88e8:	7203      	lod	A, [S-4]
    88ea:	acff      	cmp	A, #-1
    88ec:	1901      	je	0x88f0 <_MotorDriverSetParams+0x22>
	{
		l_u16ActuatorBufferedSpdRPM = params.SpdRPM;
    88ee:	514e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, A
    88f0:	5401      	ret

000088f2 <_MotorDriverGetStatus>:
	}
}

void MotorDriverGetStatus(Motor_RuntimeStatus *pstatus)
{
    88f2:	7ae2      	lod	Y, A
	pstatus->Mode = g_u8MotorStartupMode;
    88f4:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    88f8:	42f0      	mov	[Y], AL
	pstatus->ActPos = g_u16ActuatorActPos;
    88fa:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    88fc:	52f4      	mov	[Y+4], A
	pstatus->TgtPos = g_u16ActuatorTgtPos;
    88fe:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8900:	52f6      	mov	[Y+6], A
	pstatus->Fault = g_sMotorFault;
    8902:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8904:	52f2      	mov	[Y+2], A
	pstatus->Direction = g_e8MotorDirectionCCW;
    8906:	e008      	add	Y, #8
    8908:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    890a:	42f0      	mov	[Y], AL
    890c:	5401      	ret

0000890e <_MotorDriverClearFaultStatus>:
}

void MotorDriverClearFaultStatus(void)
{
	/* clear permanent mechanical or eletric error,latched */
	g_sMotorFault.DRIFT = 0;
    890e:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    8910:	94fb      	and	AL, #-5
    8912:	411d      	mov	dp:0x1d <_g_sMotorFault+0x1>, AL
	g_sMotorFault.ST = 0;
    8914:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8916:	b6da fc3f 	and	A, #64575
    891a:	511c      	mov	dp:0x1c <_g_sMotorFault>, A
	g_sMotorFault.SHORT = 0;
    891c:	7ada 001c 	lod	Y, #28
    8920:	62f0      	lod	AL, [Y]
    8922:	94f7      	and	AL, #-9
    8924:	42f0      	mov	[Y], AL
	g_sMotorFault.OPEN = 0;
    8926:	62f0      	lod	AL, [Y]
    8928:	94fb      	and	AL, #-5
    892a:	42f0      	mov	[Y], AL
    892c:	5401      	ret

0000892e <_MotorDriver_4PhaseStepper>:
 * Performance: 13.5us @ 28MHz (BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
 *
 * Based on a 32-step c_ai16MicroStepVector4PH-table!!
 * ****************************************************************************	*/
void MotorDriver_4PhaseStepper( void)
{
    892e:	5805      	inc	S, #6
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) */

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND)					/* MMP150515-1 */
	/* EMC CE/RE reduction */
	int16 iPwm1, iPwm2;
	const int16 *pi16Vector = &c_ai16MicroStepVector4PH[g_u16MicroStepIdx];
    8930:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    8932:	5203      	mov	[S-4], A
    8934:	487a 0002 	muls	Y, A, #2
    8938:	7ee6      	lod	X, Y
    893a:	22da 98ea 	add	X, #39146
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    893e:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8940:	7af8      	lod	Y, [X]
    8942:	4831      	muls	YA, A, Y
    8944:	48b3      	asr	YA, #4
    8946:	5a01      	mov	[S-2], Y
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    8948:	5a05      	mov	[S-6], Y
	iPwm1 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	iPwm2 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
#elif (PWM_PRESCALER_N == 0U)
	iPwm1 = mulI16_I16byI16Shft4( *pi16Vector, (int16) g_u16CorrectionRatio);	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
    894a:	2010      	add	X, #16
    894c:	7af8      	lod	Y, [X]
    894e:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8950:	4831      	muls	YA, A, Y
    8952:	48b3      	asr	YA, #4
#else
	i16PwmU = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	i16PwmV = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* V */
#endif
	if ( (g_u16MicroStepIdx & (2u*C_MICROSTEP_PER_FULLSTEP)) != 0u )
    8954:	7203      	lod	A, [S-4]
    8956:	b410      	and	A, #16
    8958:	1913      	je	0x8980 <_MotorDriver_4PhaseStepper+0x52>
	{
		/* 3rd and 4th Quadrant (Pwm1) */
		iPwm1 = (int16)PWM_SCALE_OFFSET + iPwm1;
    895a:	7205      	lod	A, [S-6]
    895c:	a2da 02bb 	add	A, #699
    8960:	5205      	mov	[S-6], A
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = PWM */
		PWM4_LT =  (uint16)iPwm1;
    8962:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM4_HT =  (uint16)PWM_REG_PERIOD - (uint16)iPwm1;
    8966:	72da 0576 	lod	A, #1398
    896a:	aa05      	sub	A, [S-6]
    896c:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM3_LT = (uint16) iPwm1;
		PWM3_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */

		/* W = LOW */
		PWM2_HT = 0U;
    8970:	7000      	lod	A, #0
    8972:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM2_LT = (uint16)PWM_REG_PERIOD + 1U;											/* MMP150603-1 */;
    8976:	72da 0577 	lod	A, #1399
    897a:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
    897e:	0012      	jmp	0x89a4 <_MotorDriver_4PhaseStepper+0x76>
	}
	else
	{
		/* 1st and 2nd Quadrant (Pwm1)*/
		/* W = PWM */
		iPwm1 = ((int16) PWM_SCALE_OFFSET - iPwm1);
    8980:	72da 02bb 	lod	A, #699
    8984:	aa01      	sub	A, [S-2]
    8986:	5205      	mov	[S-6], A
		PWM2_LT = (uint16) iPwm1;
    8988:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
		PWM2_HT = (uint16)PWM_REG_PERIOD - (uint16)iPwm1;
    898c:	72da 0576 	lod	A, #1398
    8990:	aa05      	sub	A, [S-6]
    8992:	52d8 285a 	mov	0x285a <__io__+0x5a>, A

#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = LOW */
		PWM4_HT = 0U;
    8996:	7000      	lod	A, #0
    8998:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM4_LT = (uint16)PWM_REG_PERIOD + 1U;											/* MMP150603-1 */
    899c:	72da 0577 	lod	A, #1399
    89a0:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM3_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}

	{
		uint16 u16Quad = g_u16MicroStepIdx & (3u * C_MICROSTEP_PER_FULLSTEP);
    89a4:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    89a6:	b418      	and	A, #24
		if ( (u16Quad == 0u) || (u16Quad == (3u * C_MICROSTEP_PER_FULLSTEP)) )
    89a8:	1902      	je	0x89ae <_MotorDriver_4PhaseStepper+0x80>
    89aa:	ac18      	cmp	A, #24
    89ac:	1d0f      	jne	0x89cc <_MotorDriver_4PhaseStepper+0x9e>
		{
			/* 1st and 4th Quadrant (Pwm2) */
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* T = PWM */
			PWM5_HT = (uint16) iPwm2;
    89ae:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16)PWM_REG_PERIOD - (uint16)iPwm2;
    89b2:	72da 0576 	lod	A, #1398
    89b6:	aae6      	sub	A, Y
    89b8:	52d8 2876 	mov	0x2876 <__io__+0x76>, A

			/* V = LOW */
			PWM3_HT = 0U;
    89bc:	7800      	lod	Y, #0
    89be:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16)PWM_REG_PERIOD + 1U;										/* MMP150603-1 */
    89c2:	72da 0577 	lod	A, #1399
    89c6:	52d8 2862 	mov	0x2862 <__io__+0x62>, A
    89ca:	000f      	jmp	0x89ea <_MotorDriver_4PhaseStepper+0xbc>
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
		}
		else
		{
			/* 3rd Quadrant (Pwm2) */
			iPwm2 = (0 - iPwm2);
    89cc:	5cc6      	neg	Y
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* V = PWM */
			PWM3_HT = (uint16) iPwm2;
    89ce:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16)PWM_REG_PERIOD - (uint16)iPwm2;
    89d2:	72da 0576 	lod	A, #1398
    89d6:	aae6      	sub	A, Y
    89d8:	52d8 2862 	mov	0x2862 <__io__+0x62>, A

			/* T = LOW */
			PWM5_HT = 0U;
    89dc:	7800      	lod	Y, #0
    89de:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16)PWM_REG_PERIOD + 1U;										/* MMP150603-1 */
    89e2:	72da 0577 	lod	A, #1399
    89e6:	52d8 2876 	mov	0x2876 <__io__+0x76>, A
		PWM4_LT = (uint16) (0 - iPwm);						/* U = PWM */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */

	PWM1_LT = (uint16)PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    89ea:	7ada 02bb 	lod	Y, #699
    89ee:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
    89f2:	5407      	ret	#8

000089f4 <_MotorDriverInit>:
 * MotorDriverInit()
 *
 * Initialise Motor Driver
 * ****************************************************************************	*/
void MotorDriverInit( void)
{
    89f4:	5815      	inc	S, #22
    89f6:	7808      	lod	Y, #8
    89f8:	7004      	lod	A, #4
    uint32 result;

    __asm__ __volatile__ (
    89fa:	4801      	mulu	D, A, Y
    89fc:	7eef      	lod	X, S
    89fe:	20f8      	add	X, #-8
    8a00:	4c87      	mov	[X], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8a02:	7207      	lod	A, [S-8]
    8a04:	52d8 0106 	mov	0x106 <_g_u16MotorMicroStepsPerElecRotation>, A
    uint32 result;

    __asm__ __volatile__ (
    8a08:	700c      	lod	A, #12
    8a0a:	7a07      	lod	Y, [S-8]
    8a0c:	4801      	mulu	D, A, Y
    8a0e:	72ee      	lod	A, X
    8a10:	4cf3      	swap	YA
    8a12:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    8a14:	7a07      	lod	Y, [S-8]
    8a16:	5ad8 0108 	mov	0x108 <_g_u16MotorMicroStepsPerMechRotation>, Y
	g_u16MotorMicroStepsPerMechRotation = (uint16) mulU32_U16byU16( NVRAM_POLE_PAIRS, g_u16MotorMicroStepsPerElecRotation);
	{
		uint16 u16ConstAccelaration = NVRAM_ACCELERATION_CONST;
		if ( u16ConstAccelaration != 0u )
		{
			u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60u), g_u16MotorMicroStepsPerMechRotation);
    8a1a:	5adf      	push	Y
    8a1c:	4ce2 2c40 	mov	YA, #105000000
    8a20:	0642 
    8a22:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    8a26:	4cc0      	mov	D, YA
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a28:	5c01      	dec	S, #2
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a2a:	7c3c      	lod	X, #60
    8a2c:	4c63      	divu	YA, X
    8a2e:	4c63      	divu	YA, X
    8a30:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a32:	a0ff      	add	A, #-1
    8a34:	52d8 0118 	mov	0x118 <_g_au16MotorSpeedCommutTimerPeriod+0xe>, A
    8a38:	52d8 010a 	mov	0x10a <_g_au16MotorSpeedCommutTimerPeriod>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a3c:	4c80      	mov	YA, D
    8a3e:	7eda 04e2 	lod	X, #1250
    8a42:	4c63      	divu	YA, X
    8a44:	4c63      	divu	YA, X
    8a46:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a48:	a0ff      	add	A, #-1
    8a4a:	52d8 0116 	mov	0x116 <_g_au16MotorSpeedCommutTimerPeriod+0xc>, A
    8a4e:	52d8 010c 	mov	0x10c <_g_au16MotorSpeedCommutTimerPeriod+0x2>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a52:	4c80      	mov	YA, D
    8a54:	7c5a      	lod	X, #90
    8a56:	4c63      	divu	YA, X
    8a58:	4c63      	divu	YA, X
    8a5a:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a5c:	a0ff      	add	A, #-1
    8a5e:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
    8a60:	52d8 010e 	mov	0x10e <_g_au16MotorSpeedCommutTimerPeriod+0x4>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a64:	4c80      	mov	YA, D
    8a66:	7eda 00c8 	lod	X, #200
    8a6a:	4c63      	divu	YA, X
    8a6c:	4c63      	divu	YA, X
    8a6e:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a70:	7ee2      	lod	X, A
    8a72:	20ff      	add	X, #-1
    8a74:	5ed8 0110 	mov	0x110 <_g_au16MotorSpeedCommutTimerPeriod+0x6>, X
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a78:	4c80      	mov	YA, D
    8a7a:	7eda 04e2 	lod	X, #1250
    8a7e:	4c63      	divu	YA, X
    8a80:	4c63      	divu	YA, X
    8a82:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a84:	7ee2      	lod	X, A
    8a86:	20ff      	add	X, #-1
    8a88:	5ed8 0112 	mov	0x112 <_g_au16MotorSpeedCommutTimerPeriod+0x8>, X
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a8c:	4c80      	mov	YA, D
    8a8e:	7eda 04e2 	lod	X, #1250
    8a92:	4c63      	divu	YA, X
    8a94:	4c63      	divu	YA, X
    8a96:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a98:	a0ff      	add	A, #-1
    8a9a:	52d8 0114 	mov	0x114 <_g_au16MotorSpeedCommutTimerPeriod+0xa>, A
			g_au16MotorSpeedCommutTimerPeriod[3] = divU16_U32byU16( u32Temp, NVRAM_SPEED1) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[4] = divU16_U32byU16( u32Temp, NVRAM_SPEED2) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[5] = divU16_U32byU16( u32Temp, NVRAM_SPEED3) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[6] = g_au16MotorSpeedCommutTimerPeriod[1];
			g_au16MotorSpeedCommutTimerPeriod[7] = g_au16MotorSpeedCommutTimerPeriod[0];
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[2];	/* Target commutation timer period (target speed) */
    8a9e:	793c      	lod	Y, dp:0x3c <_g_u16CommutTimerPeriod>
    8aa0:	593e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, Y
    8aa2:	4cca 005a 	movu	D, #90
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8aa6:	4c80      	mov	YA, D
    8aa8:	7c3c      	lod	X, #60
    8aaa:	4c63      	divu	YA, X
    8aac:	4c63      	divu	YA, X
    8aae:	520b      	mov	[S-12], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8ab0:	52d8 011a 	mov	0x11a <_g_au16MotorSpeedRPS>, A
    8ab4:	4cca 0500 	movu	D, #1280
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8ab8:	4c80      	mov	YA, D
    8aba:	4c63      	divu	YA, X
    8abc:	4c63      	divu	YA, X
    8abe:	5209      	mov	[S-10], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8ac0:	52d8 011c 	mov	0x11c <_g_au16MotorSpeedRPS+0x2>, A
    8ac4:	4cea 0078 	movu	YA, #120
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8ac8:	4c63      	divu	YA, X
    8aca:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8acc:	52d8 011e 	mov	0x11e <_g_au16MotorSpeedRPS+0x4>, A
    8ad0:	4cea 00e6 	movu	YA, #230
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8ad4:	4c63      	divu	YA, X
    8ad6:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8ad8:	52d8 0120 	mov	0x120 <_g_au16MotorSpeedRPS+0x6>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8adc:	4c80      	mov	YA, D
    8ade:	4c63      	divu	YA, X
    8ae0:	4c63      	divu	YA, X
    8ae2:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8ae4:	52d8 0122 	mov	0x122 <_g_au16MotorSpeedRPS+0x8>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8ae8:	4c80      	mov	YA, D
    8aea:	4c63      	divu	YA, X
    8aec:	4c63      	divu	YA, X
    8aee:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8af0:	52d8 0124 	mov	0x124 <_g_au16MotorSpeedRPS+0xa>, A
			g_au16MotorSpeedRPS[1] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60U);
			g_au16MotorSpeedRPS[2] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED0 + 30U), 60U);
			g_au16MotorSpeedRPS[3] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED1 + 30U), 60U);
			g_au16MotorSpeedRPS[4] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED2 + 30U), 60U);
			g_au16MotorSpeedRPS[5] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60U);
			g_au16MotorSpeedRPS[6] = g_au16MotorSpeedRPS[1];
    8af4:	7a09      	lod	Y, [S-10]
    8af6:	5ad8 0126 	mov	0x126 <_g_au16MotorSpeedRPS+0xc>, Y
			g_au16MotorSpeedRPS[7] = g_au16MotorSpeedRPS[0];
    8afa:	7e0b      	lod	X, [S-12]
    8afc:	5ed8 0128 	mov	0x128 <_g_au16MotorSpeedRPS+0xe>, X
		}
	}

	g_u16CorrectionRatio = NVRAM_MIN_CORR_RATIO;
    8b00:	72da 08df 	lod	A, #2271
    8b04:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A

	/* BLDC motor Commutation/Stepper timer */
	g_u16MicroStepIdx = 0u;
    8b06:	7800      	lod	Y, #0
    8b08:	593a      	mov	dp:0x3a <_g_u16MicroStepIdx>, Y

	TMR1_CTRL = C_TMRx_CTRL_MODE0;												/* Timer mode 0 */
    8b0a:	7eda 4001 	lod	X, #16385
    8b0e:	5eaa      	mov	io:0x2a <__data_dp_end+0x2>, X
	TMR1_REGB = 0u;																/* Will be overwritten by MotorDriverStart() */
    8b10:	5aac      	mov	io:0x2c <__data_dp_end+0x4>, Y

	/* Setup Motor PWM */	
	PWM1_CTRL = 0u;																/* Disable master */
    8b12:	6000      	lod	AL, #0
    8b14:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = 0u;																/* Disable Slave 1 */
    8b18:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = 0u;																/* Disable Slave 2 */
    8b1c:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = 0u;																/* Disable Slave 3 */
    8b20:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = 0u;																/* Disable Slave 4 */
    8b24:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
	PWM1_PSCL = (uint8)PWM_PRESCALER;											/* Initialise the master pre-scaler ratio (Fck/8) */
    8b28:	42d8 284b 	mov	0x284b <__io__+0x4b>, AL
	PWM1_PER = (uint16)PWM_REG_PERIOD;
    8b2c:	7ada 0576 	lod	Y, #1398
    8b30:	5ad8 284c 	mov	0x284c <__io__+0x4c>, Y
	PWM2_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8b34:	5ad8 2856 	mov	0x2856 <__io__+0x56>, Y
	PWM3_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8b38:	5ad8 2860 	mov	0x2860 <__io__+0x60>, Y
	PWM4_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8b3c:	5ad8 286a 	mov	0x286a <__io__+0x6a>, Y
	PWM5_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8b40:	5ad8 2874 	mov	0x2874 <__io__+0x74>, Y
	PWM5_CMP = (((83L * PWM_REG_PERIOD) + 50)/100); 	/*	7.0us */			/* 83% of period */
#else  /* _SUPPORT_PHASE_SHORT_DET */
	/* (Single PWM) 17% 		33% 		50% 		75% 		100%		(7.0us/ADC-conversion)
	 * MF_STEPPER:	Temperature Vs-filt 	Imotor1 	Vsm-unfilt	Imotor2
	 */
	PWM1_CMP = (uint16)(((17UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	7.0us */			/* 17% of period */
    8b44:	7eda 00ee 	lod	X, #238
    8b48:	5ed8 2852 	mov	0x2852 <__io__+0x52>, X
	PWM2_CMP = (uint16)(((33UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	7.0us */			/* 33% of period */
    8b4c:	72da 01cd 	lod	A, #461
    8b50:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
	PWM3_CMP = (uint16)(((50UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	10.5us */			/* 50% of period */
    8b54:	7ada 02bb 	lod	Y, #699
    8b58:	5ad8 2866 	mov	0x2866 <__io__+0x66>, Y
	PWM4_CMP = (uint16)(((75UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	10.5us */			/* 75% of period */
    8b5c:	7eda 0419 	lod	X, #1049
    8b60:	5ed8 2870 	mov	0x2870 <__io__+0x70>, X
	PWM3_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 2 control register - CMPI enabled */
	PWM4_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 3 control register - CMPI enabled */
	PWM5_CTRL = (MODE | EXT | EBLK);											/* Initialise the slave 4 control register - CMPI disabled */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	/* In-depended mode */
	PWM1_CTRL = (EBLK | ECI | EPI); 											/* Initialise the master control register - CMPI and PWMI enabled */
    8b64:	6019      	lod	AL, #25
    8b66:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 1 control register - CMPI enabled */
    8b6a:	6013      	lod	AL, #19
    8b6c:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 2 control register - CMPI enabled */
    8b70:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 3 control register - CMPI enabled */
    8b74:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 4 control register - CMPI enabled */
    8b78:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	PWM1_CTRL |= EBLK;															/* Start PWM in application mode */
    8b7c:	62d8 284a 	lod	AL, 0x284a <__io__+0x4a>
    8b80:	8401      	or	AL, #1
    8b82:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
    8b86:	5417      	ret	#24

00008b88 <_MotorDriverCurrentMeasureInit>:
 * Performance: <10us
 * ****************************************************************************	*/
void MotorDriverCurrentMeasureInit( void)
{
	uint16 u16Count;															/* MMP140331-2 - Begin */
	l_u16StartupDelayInit = 64u * NVRAM_ACCELERATION_POINTS;					/* Calculate the startup-delay, based on acceleration steps */
    8b88:	7040      	lod	A, #64
    8b8a:	52d8 00d8 	mov	0xd8 <_l_u16StartupDelayInit>, A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8b8e:	72e3      	lod	A, M
	}																			/* MMP140331-2 - End */
	else
	{
		
	}
	ATOMIC_CODE
    8b90:	4407      	mov	R, #0
    8b92:	500c      	call	fp0:0x60
    8b94:	54f0      	mov	UPr, #0
    8b96:	7ad8 00d8 	lod	Y, 0xd8 <_l_u16StartupDelayInit>
    8b9a:	5920      	mov	dp:0x20 <_g_u16StartupDelay>, Y
    8b9c:	7800      	lod	Y, #0
    8b9e:	5942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, Y
    8ba0:	5ad8 012a 	mov	0x12a <_l_u16MotorCurrentRawIdx>, Y
    8ba4:	5940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, Y
    8ba6:	5ad8 012c 	mov	0x12c <_l_au16MotorCurrentRaw>, Y
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8baa:	52e3      	mov	M, A
		l_u16MotorCurrentRawIdx = 0u;											/* Raw current moving average index */
		g_u16MotorCurrentMovAvgxN = 0u;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0u;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
    8bac:	7ada 012e 	lod	Y, #302
    8bb0:	7c1f      	lod	X, #31
		for ( u16Count = 1u; u16Count < (uint16)C_MOVAVG_SZ; u16Count++ )
		{
			*pStallCurrentRaw = 0u;
    8bb2:	7000      	lod	A, #0
    8bb4:	52d6      	mov	[Y++], A
    8bb6:	1bfd      	djnz	X, 0x8bb2 <_MotorDriverCurrentMeasureInit+0x2a>
		g_u16MotorCurrentMovAvgxN = 0u;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0u;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
		for ( u16Count = 1u; u16Count < (uint16)C_MOVAVG_SZ; u16Count++ )
    8bb8:	5401      	ret

00008bba <_MotorDriver_InitialPwmDutyCycle>:
 * MotorDriver_InitialPwmDutyCycle()
 *
 * Calculate Motor PWM (initial) Duty-cycle, based on current threshold level and speed
 * ****************************************************************************	*/
void MotorDriver_InitialPwmDutyCycle( uint16 u16CurrentLevel, uint16 u16MotorSpeed)
{
    8bba:	5803      	inc	S, #4
    8bbc:	7e07      	lod	X, [S-8]
    8bbe:	4872 0019 	muls	A, A, #25
    8bc2:	7ad8 00b8 	lod	Y, 0xb8 <_g_i16MotorVoltage>
    8bc6:	5a03      	mov	[S-4], Y
	if ( u16MotorSpeed == 0u )														/* MMP140228-1 - Begin */
    8bc8:	2c00      	cmp	X, #0
    8bca:	1d04      	jne	0x8bd4 <_MotorDriver_InitialPwmDutyCycle+0x1a>
	{
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2u * C_FETS_RTOT)) * u16CurrentLevel);
    8bcc:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 4u;
    8bce:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8bd0:	44b2      	lsr	A, #2
    8bd2:	000d      	jmp	0x8bee <_MotorDriver_InitialPwmDutyCycle+0x34>
	}																				/* MMP140228-1 - End */
	else
	{
		/* Ohmic losses: Ur-losses = (0.5 * R[ohm] * I[mA])/10 [10mV] = (R[ohm] * I[mA])/20 [10mV]
		 * FET losses: Ufet-losses = (Rfet * I[mA])/10 [10mV] = (2 * Rfet * I[mA])/20 [10mV]*/
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2u * C_FETS_RTOT)) * u16CurrentLevel);
    8bd4:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 20u;													/* Divided by 20 */
    8bd6:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8bd8:	4822 cccd 	mulu	YA, A, #52429
    8bdc:	72e6      	lod	A, Y
    8bde:	44b2      	lsr	A, #2
    8be0:	44b2      	lsr	A, #2
    8be2:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio += (NVRAM_MOTOR_CONSTANT * u16MotorSpeed);				/* BEMF = Kmotor[10mV/RPS] * Speed[RPS] */
    8be4:	72ee      	lod	A, X
    8be6:	487a 0091 	muls	Y, A, #145
    8bea:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8bec:	a2e6      	add	A, Y
    8bee:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8bf0:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8bf2:	44a2      	asl	A, #2
    8bf4:	4422      	asl	A
    8bf6:	7eda 0546 	lod	X, #1350
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8bfa:	7ada 0aec 	lod	Y, #2796
    8bfe:	4821      	mulu	YA, A, Y
    8c00:	4c63      	divu	YA, X
    8c02:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8c04:	52d8 0176 	mov	0x176 <_g_u16PidCtrlRatio>, A
	}
	g_u16PidCtrlRatio =  muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3u, (uint16)PWM_REG_PERIOD << (1u + PWM_PRESCALER_N), NVRAM_VSUP_REF);
	g_u16PID_I = g_u16PidCtrlRatio;
    8c08:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
	if ( g_i16MotorVoltage > 0 )
    8c0a:	7e03      	lod	X, [S-4]
    8c0c:	2c00      	cmp	X, #0
    8c0e:	1b08      	jsle	0x8c20 <_MotorDriver_InitialPwmDutyCycle+0x66>
    8c10:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8c12:	44a2      	asl	A, #2
    8c14:	4422      	asl	A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8c16:	7ada 0aec 	lod	Y, #2796
    8c1a:	4821      	mulu	YA, A, Y
    8c1c:	4c63      	divu	YA, X
    8c1e:	4c63      	divu	YA, X
	{
		g_u16CorrectionRatio = muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3u, (uint16)PWM_REG_PERIOD << (1u + PWM_PRESCALER_N), (uint16) g_i16MotorVoltage);
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    8c20:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
	}
	g_i16PID_D = 0;
    8c22:	7c00      	lod	X, #0
    8c24:	5ed8 00e2 	mov	0xe2 <_g_i16PID_D>, X
	g_i16PID_E = 0;
    8c28:	5ed8 00e0 	mov	0xe0 <_g_i16PID_E>, X
    8c2c:	5405      	ret	#6

00008c2e <_MotorDriverStart>:
 * MotorDriverStart()
 *
 * Start Motor Driver
 * ****************************************************************************	*/
void MotorDriverStart( void)
{
    8c2e:	5801      	inc	S, #2
	/* 1)stop, 2)no error,3)target position not equals actual position */
	if( g_u8MotorStartupMode == (uint8)MSM_STOP )
    8c30:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8c34:	1901      	je	0x8c38 <_MotorDriverStart+0xa>
    8c36:	0054      	jmp	0x8ce0 <_MotorDriverStart+0xb2>
	{
#if USE_MULTI_PURPOSE_BUFFER
		/* Fill multi-purpose buffer with acceleration-data */
		{
			l_u16SpeedRPM = NVRAM_MIN_SPEED;
    8c38:	703c      	lod	A, #60
    8c3a:	52d8 016c 	mov	0x16c <_l_u16SpeedRPM>, A
			l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    8c3e:	72d8 0108 	lod	A, 0x108 <_g_u16MotorMicroStepsPerMechRotation>
    8c42:	52df      	push	A
    8c44:	4ce2 2c40 	mov	YA, #105000000
    8c48:	0642 
    8c4a:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    8c4e:	52d8 016e 	mov	0x16e <_l_u32Temp>, A
    8c52:	5ad8 0170 	mov	0x170 <_l_u32Temp+0x2>, Y
    8c56:	5c01      	dec	S, #2
    8c58:	7ed8 016c 	lod	X, 0x16c <_l_u16SpeedRPM>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8c5c:	4c63      	divu	YA, X
    8c5e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8c60:	a0ff      	add	A, #-1
    8c62:	52d8 0172 	mov	0x172 <_l_u16LowSpeedPeriod>, A
			l_u16LowSpeedPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1U;
		}
#endif /* USE_MULTI_PURPOSE_BUFFER */

		/* Clear motor-driver current measurement */
		MotorDriverCurrentMeasureInit();
    8c66:	1790      	call	0x8b88 <_MotorDriverCurrentMeasureInit>
#endif /* _SUPPORT_STALLDET_O */
#if _SUPPORT_STALLDET_H
		MotorStallInitH();
#endif /* _SUPPORT_STALLDET_H */

		MotorDiagnosticCheckInit();													/* initialize diagnostic */
    8c68:	14be      	call	0x85e6 <_MotorDiagnosticCheckInit>
#endif /* _DEBUG_VOLTAGE_COMPENSATION */

		/* Connect drivers */
		/* Stepper 4-phase/32-steps */
		{
			MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_au16MotorSpeedRPS[1]);	/* MMP140822-1 - Begin */
    8c6a:	72d8 011c 	lod	A, 0x11c <_g_au16MotorSpeedRPS+0x2>
    8c6e:	52df      	push	A
    8c70:	72d8 0178 	lod	A, 0x178 <_g_u16PidRunningThreshold>
    8c74:	17a2      	call	0x8bba <_MotorDriver_InitialPwmDutyCycle>
		}
		MotorDriver_4PhaseStepper();
    8c76:	165b      	call	0x892e <_MotorDriver_4PhaseStepper>

#if (_SUPPORT_PWM_DC_RAMPUP == FALSE)												/* MMP140903-2 - Begin */
		if ( g_u16MotorSpeedRPS > g_au16MotorSpeedRPS[1] )
    8c78:	72d8 0104 	lod	A, 0x104 <_g_u16MotorSpeedRPS>
    8c7c:	5c01      	dec	S, #2
    8c7e:	aed8 011c 	cmp	A, 0x11c <_g_au16MotorSpeedRPS+0x2>
    8c82:	1a05      	jule	0x8c8e <_MotorDriverStart+0x60>
		{
			MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_u16MotorSpeedRPS);
    8c84:	52df      	push	A
    8c86:	72d8 0178 	lod	A, 0x178 <_g_u16PidRunningThreshold>
    8c8a:	1797      	call	0x8bba <_MotorDriver_InitialPwmDutyCycle>
    8c8c:	5c01      	dec	S, #2
		}																			/* MMP140822-1 - End */
#endif /* (_SUPPORT_PWM_DC_RAMPUP == FALSE) */										/* MMP140903-2 - End */
		DRVCFG_PWM_UVWT();															/* Enable the driver and the PWM phase W, V, U and T */
    8c8e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8c92:	b6da fe00 	and	A, #65024
    8c96:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8c9a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8c9e:	a455      	or	A, #85
    8ca0:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		/* Setup ADC for Motor Temperature/Current/Voltage measurements */
		ADC_Start();
    8ca4:	82db 8270 	callf	0x8270 <_ADC_Start>

		g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;								/* Start-up in Acceleration stepper mode */
    8ca8:	6001      	lod	AL, #1
    8caa:	42d8 00db 	mov	0xdb <_g_u8MotorStartupMode>, AL
		l_u8VTIdx = 0;
    8cae:	6000      	lod	AL, #0
    8cb0:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
		if ( g_u8MotorStartupMode == (uint8) MSM_STEPPER_A )
		{
			if ( g_u16TargetCommutTimerPeriod < l_u16LowSpeedPeriod )
    8cb2:	793e      	lod	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    8cb4:	72d8 0172 	lod	A, 0x172 <_l_u16LowSpeedPeriod>
    8cb8:	eee2      	cmp	Y, A
    8cba:	1c02      	jnc	0x8cc0 <_MotorDriverStart+0x92>
			{
				/* Target speed too fast for motor to start-up with */
				g_u16CommutTimerPeriod = l_u16LowSpeedPeriod;						/* Initial start-up speed */
    8cbc:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
    8cbe:	0001      	jmp	0x8cc2 <_MotorDriverStart+0x94>
			}
			else
			{
				/* Target speed is slower than maximum motor start-up speed */
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    8cc0:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			}
		}
		/* motor running direction */
		g_e8MotorDirectionCCW = (g_u16ActuatorTgtPos < g_u16ActuatorActPos) ? C_MOTOR_DIR_CCW : C_MOTOR_DIR_CW;
    8cc2:	6000      	lod	AL, #0
    8cc4:	4201      	mov	[S-2], AL
    8cc6:	7948      	lod	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    8cc8:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8cca:	eee2      	cmp	Y, A
    8ccc:	1c02      	jnc	0x8cd2 <_MotorDriverStart+0xa4>
    8cce:	6001      	lod	AL, #1
    8cd0:	4201      	mov	[S-2], AL
    8cd2:	6201      	lod	AL, [S-2]
    8cd4:	4144      	mov	dp:0x44 <_g_e8MotorDirectionCCW>, AL
		/* start commutation timer */
		TMR1_REGB = g_u16CommutTimerPeriod;
    8cd6:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    8cd8:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
		TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;									/* Start Timer mode 0 */
    8cda:	72da 4003 	lod	A, #16387
    8cde:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
    8ce0:	5403      	ret	#4

00008ce2 <_MotorDriverStop>:
 *						C_STOP_EMERGENCY : Immediate stop (without ramp-down) + delay
 *
 * Stop Motor Driver
 * ****************************************************************************	*/
void MotorDriverStop( uint16 u16Immediate )
{
    8ce2:	5805      	inc	S, #6
    8ce4:	5205      	mov	[S-6], A
	if(g_u8MotorStartupMode != (uint8) MSM_STOP)
    8ce6:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8cea:	1d01      	jne	0x8cee <_MotorDriverStop+0xc>
    8cec:	0070      	jmp	0x8dce <_MotorDriverStop+0xec>
	{
		if(u16Immediate == (uint16) C_STOP_RAMPDOWN) /*lint !e845 */	/* MMP150922-1 */
    8cee:	7205      	lod	A, [S-6]
    8cf0:	1d22      	jne	0x8d36 <_MotorDriverStop+0x54>
		{
			if(l_u8VTIdx > 1u)
    8cf2:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    8cf4:	4203      	mov	[S-4], AL
    8cf6:	8c01      	cmp	AL, #1
    8cf8:	1a1e      	jule	0x8d36 <_MotorDriverStop+0x54>
			{
				TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;							/* Start timer mode 0 */
    8cfa:	72da 4003 	lod	A, #16387
    8cfe:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
				
				/* Set TargetPos near CurrentPos, including ramp-down */
				if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    8d00:	7946      	lod	Y, dp:0x46 <_g_u16ActuatorActPos>
    8d02:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8d04:	5201      	mov	[S-2], A
    8d06:	6203      	lod	AL, [S-4]
    8d08:	5cf2      	usex	A
    8d0a:	7ee2      	lod	X, A
    8d0c:	ee01      	cmp	Y, [S-2]
    8d0e:	1a09      	jule	0x8d22 <_MotorDriverStop+0x40>
				{
					uint16 u16DeltaPos = g_u16ActuatorActPos - g_u16ActuatorTgtPos;
    8d10:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8d12:	7948      	lod	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    8d14:	aae6      	sub	A, Y
					if ( u16DeltaPos > l_u8VTIdx )
    8d16:	aeee      	cmp	A, X
    8d18:	1e01      	jug	0x8d1c <_MotorDriverStop+0x3a>
    8d1a:	0059      	jmp	0x8dce <_MotorDriverStop+0xec>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos - l_u8VTIdx;
    8d1c:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8d1e:	aaee      	sub	A, X
    8d20:	0008      	jmp	0x8d32 <_MotorDriverStop+0x50>
					}
				}
				else
				{
					uint16 u16DeltaPos = g_u16ActuatorTgtPos - g_u16ActuatorActPos;
    8d22:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8d24:	7946      	lod	Y, dp:0x46 <_g_u16ActuatorActPos>
    8d26:	aae6      	sub	A, Y
					if ( u16DeltaPos > l_u8VTIdx )
    8d28:	aeee      	cmp	A, X
    8d2a:	1e01      	jug	0x8d2e <_MotorDriverStop+0x4c>
    8d2c:	0050      	jmp	0x8dce <_MotorDriverStop+0xec>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos + l_u8VTIdx;
    8d2e:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8d30:	a2ee      	add	A, X
    8d32:	5148      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, A
					}
				}
				
				return;
    8d34:	5407      	ret	#8
			}
		}
		/* 1.First stop ADC, before stopping motor (trigger-event) */
		ADC_Stop();
    8d36:	82db 81ea 	callf	0x81ea <_ADC_Stop>
		g_u8MotorStartupMode = (uint8) MSM_STOP;								/* Stop mode */
    8d3a:	6000      	lod	AL, #0
    8d3c:	42d8 00db 	mov	0xdb <_g_u8MotorStartupMode>, AL
		g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_STOP;						/* Stop */
    8d40:	42d8 00d7 	mov	0xd7 <_g_u8MotorStatusSpeed>, AL
		/* 3.deal with specific stop request */
		/* in case stop with holding current:not supported yet */
		if(u16Immediate == (uint16) C_STOP_HOLD)
    8d44:	7205      	lod	A, [S-6]
    8d46:	ac01      	cmp	A, #1
    8d48:	1d1b      	jne	0x8d80 <_MotorDriverStop+0x9e>
		{
			/* Keep Motor driver active with a specified amount of current (unless permanent electric error) */
			MotorDriver_InitialPwmDutyCycle( g_u16PidHoldingThreshold, 0);
    8d4a:	54ca 0000 	pushw	#0
    8d4e:	72d8 017c 	lod	A, 0x17c <_g_u16PidHoldingThreshold>
    8d52:	1733      	call	0x8bba <_MotorDriver_InitialPwmDutyCycle>
	
			MotorDriver_4PhaseStepper();
    8d54:	15ec      	call	0x892e <_MotorDriver_4PhaseStepper>
			DRVCFG_PWM_UVWT();	
    8d56:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d5a:	b6da fe00 	and	A, #65024
    8d5e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8d62:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d66:	a455      	or	A, #85
    8d68:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			g_u16MotorCurrentLPFx64 = (g_u16PidHoldingThreshold << 6u);				/* Low-pass Filtered motor-current (x 64) */
    8d6c:	72d8 017c 	lod	A, 0x17c <_g_u16PidHoldingThreshold>
    8d70:	44a2      	asl	A, #2
    8d72:	44a2      	asl	A, #2
    8d74:	44a2      	asl	A, #2
    8d76:	5142      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, A

			ADC_Start();															/* Start measuring motor current */
    8d78:	82db 8270 	callf	0x8270 <_ADC_Start>
    8d7c:	5c01      	dec	S, #2
    8d7e:	001d      	jmp	0x8dba <_MotorDriverStop+0xd8>

		}
		/* in case stop with immediately */
		if(u16Immediate == (uint16) C_STOP_IMMEDIATE)
    8d80:	7205      	lod	A, [S-6]
    8d82:	ac02      	cmp	A, #2
    8d84:	1d0b      	jne	0x8d9c <_MotorDriverStop+0xba>
		{
			DRVCFG_GND_UVWT();														/* Make Low-side active, for a short time (recycle current) */
    8d86:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d8a:	b6da fe00 	and	A, #65024
    8d8e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8d92:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d96:	a6da 00aa 	or	A, #170
    8d9a:	000d      	jmp	0x8db6 <_MotorDriverStop+0xd4>
		}
		/* In case of a permanent error, don't connect drivers anymore */
		if(u16Immediate == (uint16)C_STOP_EMERGENCY)
    8d9c:	7205      	lod	A, [S-6]
    8d9e:	ac03      	cmp	A, #3
    8da0:	1d0c      	jne	0x8dba <_MotorDriverStop+0xd8>
		{
			DRVCFG_DIS_UVWT();
    8da2:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8da6:	b6da fe00 	and	A, #65024
    8daa:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();															/* MMP140903-1 */		
    8dae:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8db2:	a6da 0100 	or	A, #256
    8db6:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
																					/* MMP130919-1 - End */
		}
		/* 4.stop commutation timer */
		TMR1_CTRL &= ~TMRx_START;													/* Stop "commutation timer" */
    8dba:	72aa      	lod	A, io:0x2a <__data_dp_end+0x2>
    8dbc:	b4fd      	and	A, #-3
    8dbe:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
		XI0_PEND = CLR_T1_INT4;														/* Clear (potentially pending) Timer1 second level interrupts (T1_INT4) */
    8dc0:	7040      	lod	A, #64
    8dc2:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		PEND = CLR_EXT0_IT;															/* ... and first level interrupt */
    8dc6:	72da 0100 	lod	A, #256
    8dca:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    8dce:	5407      	ret	#8

00008dd0 <_MotorDriver_MainFunction>:
	g_sMotorFault.SHORT = 0;
	g_sMotorFault.OPEN = 0;
}

void MotorDriver_MainFunction(void)
{
    8dd0:	5807      	inc	S, #8
	/* Diagnostic */
	MotorDiagnosticVsupplyAndTemperature();
    8dd2:	1446      	call	0x8660 <_MotorDiagnosticVsupplyAndTemperature>

	/* Diagnostic protection:motor transfer to degrade mode */
	if((g_sMotorFault.UV != 0u) || (g_sMotorFault.OV != 0u) || 
    8dd4:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8dd6:	9401      	and	AL, #1
    8dd8:	1d13      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8dda:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8ddc:	9402      	and	AL, #2
    8dde:	1d10      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8de0:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8de2:	9404      	and	AL, #4
    8de4:	1d0d      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8de6:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8de8:	9408      	and	AL, #8
    8dea:	1d0a      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8dec:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8dee:	b6da 03c0 	and	A, #960
    8df2:	1d06      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8df4:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    8df6:	9404      	and	AL, #4
    8df8:	1d03      	jne	0x8e00 <_MotorDriver_MainFunction+0x30>
    8dfa:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8dfc:	9420      	and	AL, #32
    8dfe:	1905      	je	0x8e0a <_MotorDriver_MainFunction+0x3a>
		(g_sMotorFault.OPEN != 0u) || (g_sMotorFault.SHORT != 0u) ||
		(g_sMotorFault.ST != 0u) || (g_sMotorFault.DRIFT != 0u) || (g_sMotorFault.TS != 0u))
	{
		l_u8MotorStatus = C_MOTOR_STATUS_DEGRADED;
    8e00:	6080      	lod	AL, #-128
    8e02:	42d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, AL
		MotorDriverStop(C_STOP_EMERGENCY);
    8e06:	7003      	lod	A, #3
    8e08:	176c      	call	0x8ce2 <_MotorDriverStop>
	}

	/* Stepper Motor State Machine */
	switch( l_u8MotorStatus )
    8e0a:	62d8 00d6 	lod	AL, 0xd6 <_l_u8MotorStatus>
    8e0e:	5cf2      	usex	A
    8e10:	ac01      	cmp	A, #1
    8e12:	190e      	je	0x8e30 <_MotorDriver_MainFunction+0x60>
    8e14:	1f04      	jsg	0x8e1e <_MotorDriver_MainFunction+0x4e>
    8e16:	ac00      	cmp	A, #0
    8e18:	1d01      	jne	0x8e1c <_MotorDriver_MainFunction+0x4c>
    8e1a:	0055      	jmp	0x8ec6 <_MotorDriver_MainFunction+0xf6>
    8e1c:	00ac      	jmp	0x8f76 <_MotorDriver_MainFunction+0x1a6>
    8e1e:	ac04      	cmp	A, #4
    8e20:	1905      	je	0x8e2c <_MotorDriver_MainFunction+0x5c>
    8e22:	aeda 0080 	cmp	A, #128
    8e26:	1d01      	jne	0x8e2a <_MotorDriver_MainFunction+0x5a>
    8e28:	0083      	jmp	0x8f30 <_MotorDriver_MainFunction+0x160>
    8e2a:	00a5      	jmp	0x8f76 <_MotorDriver_MainFunction+0x1a6>
	{
		case C_MOTOR_STATUS_SELFTEST:
			l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8e2c:	6000      	lod	AL, #0
    8e2e:	007b      	jmp	0x8f26 <_MotorDriver_MainFunction+0x156>
			break;
		case C_MOTOR_STATUS_RUNNING:
			/* runtime current PID control  */
			if( Timer_IsExpired(PID_CTRL_TIMER) == TRUE )
    8e30:	7004      	lod	A, #4
    8e32:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    8e36:	8c01      	cmp	AL, #1
    8e38:	1d08      	jne	0x8e4a <_MotorDriver_MainFunction+0x7a>
			{
				PID_Control();													/* PID-control (Current) */
    8e3a:	82db 96a6 	callf	0x96a6 <_PID_Control>
				Timer_Start(PID_CTRL_TIMER,(uint16)NVRAM_PID_RUNNINGCTRL_PER);
    8e3e:	54ca 000a 	pushw	#10
    8e42:	7004      	lod	A, #4
    8e44:	82db 9800 	callf	0x9800 <_Timer_Start>
    8e48:	5c01      	dec	S, #2
			}
			/* update target speed,may be overwitten by ISR */
			{
				uint32 u32Temp;
				
				u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    8e4a:	7ad8 0108 	lod	Y, 0x108 <_g_u16MotorMicroStepsPerMechRotation>
    8e4e:	5adf      	push	Y
    8e50:	4ce2 2c40 	mov	YA, #105000000
    8e54:	0642 
    8e56:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    8e5a:	4cc0      	mov	D, YA
    8e5c:	5c01      	dec	S, #2
    8e5e:	714e      	lod	A, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    8e60:	5207      	mov	[S-8], A
    8e62:	a01e      	add	A, #30
    8e64:	4cf2      	usex	YA
    8e66:	7c3c      	lod	X, #60
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e68:	4c63      	divu	YA, X
    8e6a:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e6c:	52d8 0104 	mov	0x104 <_g_u16MotorSpeedRPS>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e70:	4c80      	mov	YA, D
    8e72:	7e07      	lod	X, [S-8]
    8e74:	4c63      	divu	YA, X
    8e76:	4c63      	divu	YA, X
    8e78:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e7a:	a0ff      	add	A, #-1
    8e7c:	513e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, A
				g_u16MotorSpeedRPS = divU16_U32byU16( (uint32)(uint16)(l_u16ActuatorBufferedSpdRPM + 30U), 60U);
				g_u16TargetCommutTimerPeriod = divU16_U32byU16( u32Temp, l_u16ActuatorBufferedSpdRPM) - 1U;	
			}
			/* need change new direction? */
			if(l_u8MotorRequest == C_MOTOR_CTRL_START)
    8e7e:	62d8 00d5 	lod	AL, 0xd5 <_l_u8MotorRequest>
    8e82:	8c01      	cmp	AL, #1
    8e84:	1d10      	jne	0x8ea6 <_MotorDriver_MainFunction+0xd6>
			{
				uint8 u8NewMotorDirectionCCW;
				
				u8NewMotorDirectionCCW = (l_u16ActuatorBufferedTgtPos < g_u16ActuatorActPos) ? C_MOTOR_DIR_CCW : C_MOTOR_DIR_CW;
    8e86:	7c00      	lod	X, #0
    8e88:	794c      	lod	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    8e8a:	5a01      	mov	[S-2], Y
    8e8c:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8e8e:	eee2      	cmp	Y, A
    8e90:	1c01      	jnc	0x8e94 <_MotorDriver_MainFunction+0xc4>
    8e92:	7c01      	lod	X, #1
				/* update new target position:commutation if direction inversed with current direction */
				if ( u8NewMotorDirectionCCW != g_e8MotorDirectionCCW )
    8e94:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    8e96:	7aee      	lod	Y, X
    8e98:	8ee8      	cmp	AL, YL
    8e9a:	1903      	je	0x8ea2 <_MotorDriver_MainFunction+0xd2>
		     	{
		        	/* Changing direction; Stop motor first before starting in opposite direction */
		        	MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Change of direction */
    8e9c:	7000      	lod	A, #0
    8e9e:	1721      	call	0x8ce2 <_MotorDriverStop>
    8ea0:	0002      	jmp	0x8ea6 <_MotorDriver_MainFunction+0xd6>
		       	}
				else
				{
					/* only update target position */
					g_u16ActuatorTgtPos = l_u16ActuatorBufferedTgtPos;
    8ea2:	7e01      	lod	X, [S-2]
    8ea4:	5d48      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, X
				}
			}
			/* Motor request stop */
			if(l_u8MotorRequest == C_MOTOR_CTRL_STOP)
    8ea6:	62d8 00d5 	lod	AL, 0xd5 <_l_u8MotorRequest>
    8eaa:	1d05      	jne	0x8eb6 <_MotorDriver_MainFunction+0xe6>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    8eac:	7002      	lod	A, #2
    8eae:	1719      	call	0x8ce2 <_MotorDriverStop>
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8eb0:	6000      	lod	AL, #0
    8eb2:	42d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, AL
			}
			/* Motor reach target position,stop by commutation ISR */
			if(g_u8MotorStartupMode == (uint8)MSM_STOP)
    8eb6:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8eba:	1901      	je	0x8ebe <_MotorDriver_MainFunction+0xee>
    8ebc:	005f      	jmp	0x8f7c <_MotorDriver_MainFunction+0x1ac>
			{
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8ebe:	6400      	lod	YL, #0
    8ec0:	46d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, YL
			}
			break;
    8ec4:	5409      	ret	#10
		case C_MOTOR_STATUS_STOP:
			/* ********************************************************** */
			/* *** l. Threshold control (Stepper: Current-threshold) 			   *** */
			/* ********************************************************** */
			if(Timer_IsExpired(PID_THRSHLD_CTRL_TIMER) == TRUE)
    8ec6:	7005      	lod	A, #5
    8ec8:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    8ecc:	8c01      	cmp	AL, #1
    8ece:	1d08      	jne	0x8ee0 <_MotorDriver_MainFunction+0x110>
			{
				ThresholdControl();
    8ed0:	82db 9774 	callf	0x9774 <_ThresholdControl>
				Timer_Start(PID_THRSHLD_CTRL_TIMER,(uint16)NVRAM_PID_THRSHLDCTRL_PER);
    8ed4:	54ca 0800 	pushw	#2048
    8ed8:	7005      	lod	A, #5
    8eda:	82db 9800 	callf	0x9800 <_Timer_Start>
    8ede:	5c01      	dec	S, #2
			}

			/* Stop-mode & holding-current required:not support */
			if(g_u8MotorHoldingCurrState == TRUE)
    8ee0:	62d8 00da 	lod	AL, 0xda <_g_u8MotorHoldingCurrState>
    8ee4:	8c01      	cmp	AL, #1
    8ee6:	1d0d      	jne	0x8f02 <_MotorDriver_MainFunction+0x132>
			{
				/* holding current */
				if( Timer_IsExpired(PID_CTRL_TIMER) == TRUE)
    8ee8:	7004      	lod	A, #4
    8eea:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    8eee:	8c01      	cmp	AL, #1
    8ef0:	1d08      	jne	0x8f02 <_MotorDriver_MainFunction+0x132>
				{
					Timer_Start(PID_CTRL_TIMER,(uint16)NVRAM_PID_HOLDINGCTRL_PER);
    8ef2:	54ca 0064 	pushw	#100
    8ef6:	7004      	lod	A, #4
    8ef8:	82db 9800 	callf	0x9800 <_Timer_Start>
					PID_Control();
    8efc:	13d4      	call	0x96a6 <_PID_Control>
					MotorDriver_4PhaseStepper();
    8efe:	1517      	call	0x892e <_MotorDriver_4PhaseStepper>
    8f00:	5c01      	dec	S, #2
				}
			}
			/* start request and motor target position not equals actual position */
			if( (l_u8MotorRequest == C_MOTOR_CTRL_START) && (l_u16ActuatorBufferedTgtPos != g_u16ActuatorActPos) )
    8f02:	62d8 00d5 	lod	AL, 0xd5 <_l_u8MotorRequest>
    8f06:	8c01      	cmp	AL, #1
    8f08:	1d11      	jne	0x8f2c <_MotorDriver_MainFunction+0x15c>
    8f0a:	794c      	lod	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    8f0c:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8f0e:	eee2      	cmp	Y, A
    8f10:	190d      	je	0x8f2c <_MotorDriver_MainFunction+0x15c>
			{
				g_u16ActuatorTgtPos = l_u16ActuatorBufferedTgtPos;
    8f12:	5948      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, Y
				
				if(Timer_IsExpired(MOTOR_START_DELAY_TIMER) == TRUE)
    8f14:	7002      	lod	A, #2
    8f16:	82db 9812 	callf	0x9812 <_Timer_IsExpired>
    8f1a:	4205      	mov	[S-6], AL
    8f1c:	8c01      	cmp	AL, #1
    8f1e:	1901      	je	0x8f22 <_MotorDriver_MainFunction+0x152>
    8f20:	002d      	jmp	0x8f7c <_MotorDriver_MainFunction+0x1ac>
				{			
					MotorDriverStart();
    8f22:	1685      	call	0x8c2e <_MotorDriverStart>
					l_u8MotorStatus = C_MOTOR_STATUS_RUNNING;
    8f24:	6205      	lod	AL, [S-6]
    8f26:	42d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, AL
    8f2a:	5409      	ret	#10
				}
			}
			else
			{
				MotorDriverStop(C_STOP_IMMEDIATE);
    8f2c:	7002      	lod	A, #2
    8f2e:	0017      	jmp	0x8f5e <_MotorDriver_MainFunction+0x18e>
			}
			break;
		case C_MOTOR_STATUS_DEGRADED:
			/* Diagnostic shutdown protection */
			if((g_sMotorFault.UV != 0u) || (g_sMotorFault.OV != 0u) || 
    8f30:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8f32:	9401      	and	AL, #1
    8f34:	1d13      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f36:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8f38:	9402      	and	AL, #2
    8f3a:	1d10      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f3c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8f3e:	9404      	and	AL, #4
    8f40:	1d0d      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f42:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8f44:	9408      	and	AL, #8
    8f46:	1d0a      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f48:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8f4a:	b6da 03c0 	and	A, #960
    8f4e:	1d06      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f50:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    8f52:	9404      	and	AL, #4
    8f54:	1d03      	jne	0x8f5c <_MotorDriver_MainFunction+0x18c>
    8f56:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8f58:	9420      	and	AL, #32
    8f5a:	1903      	je	0x8f62 <_MotorDriver_MainFunction+0x192>
				(g_sMotorFault.OPEN != 0u) || (g_sMotorFault.SHORT != 0u) ||
				(g_sMotorFault.ST != 0u) || (g_sMotorFault.DRIFT != 0u) || (g_sMotorFault.TS != 0u))
			{
				MotorDriverStop(C_STOP_EMERGENCY);
    8f5c:	7003      	lod	A, #3
    8f5e:	16c1      	call	0x8ce2 <_MotorDriverStop>
    8f60:	5409      	ret	#10
			}
			else
			{
				/* degrade mode removed,delay before motor re-start */
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8f62:	6400      	lod	YL, #0
    8f64:	46d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, YL
				Timer_Start(MOTOR_START_DELAY_TIMER,C_PI_TICKS_20MS);
    8f68:	54ca 0028 	pushw	#40
    8f6c:	7002      	lod	A, #2
    8f6e:	82db 9800 	callf	0x9800 <_Timer_Start>
    8f72:	5c01      	dec	S, #2
			}
			break;
    8f74:	5409      	ret	#10
		default:
			l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8f76:	6000      	lod	AL, #0
    8f78:	42d8 00d6 	mov	0xd6 <_l_u8MotorStatus>, AL
    8f7c:	5409      	ret	#10

00008f7e <_MotorDriverCurrentMeasure>:
 *
 * Measure a average motor current, based on ADC current's
 * Performance: Approximate: 10us at 20MHz
 * ****************************************************************************	*/
void MotorDriverCurrentMeasure( void)
{
    8f7e:	5803      	inc	S, #4
	uint16 u16MotorCurrentAcc;
	uint16 u16MicroStepMotorCurrent = GetRawMotorDriverCurrent();
    8f80:	82db 83be 	callf	0x83be <_GetRawMotorDriverCurrent>
    8f84:	7ee2      	lod	X, A
	SpiDebugWriteFirst(g_u16PidRunningThreshold|0x8000u);
	SpiDebugWriteNext(g_u16MotorCurrentMovAvgxN);
#endif /* _DEBUG_SPI */

	/* Moving average (sum) of motor-driver current */
	uint16 *pu16MotorCurrentElement = &l_au16MotorCurrentRaw[l_u16MotorCurrentRawIdx];
    8f86:	72d8 012a 	lod	A, 0x12a <_l_u16MotorCurrentRawIdx>
    8f8a:	487a 0002 	muls	Y, A, #2
    8f8e:	e2da 012c 	add	Y, #300
    8f92:	5a03      	mov	[S-4], Y
	uint16 u16PrevMotorCurrent = *pu16MotorCurrentElement;
    8f94:	7af0      	lod	Y, [Y]
    8f96:	5a01      	mov	[S-2], Y

	l_u16MotorCurrentRawIdx = (l_u16MotorCurrentRawIdx + 1u) & (C_MOVAVG_SZ - 1u);
    8f98:	a001      	add	A, #1
    8f9a:	b41f      	and	A, #31
    8f9c:	52d8 012a 	mov	0x12a <_l_u16MotorCurrentRawIdx>, A
	if ( (g_u16StartupDelay != 0u) || (u16MicroStepMotorCurrent < (u16PrevMotorCurrent << 1u)) )	/* Check for valid motor-driver current (at least smaller than 2x previous current)  */
    8fa0:	7120      	lod	A, dp:0x20 <_g_u16StartupDelay>
    8fa2:	1d04      	jne	0x8fac <_MotorDriverCurrentMeasure+0x2e>
    8fa4:	72e6      	lod	A, Y
    8fa6:	4422      	asl	A
    8fa8:	2ee2      	cmp	X, A
    8faa:	1c06      	jnc	0x8fb8 <_MotorDriverCurrentMeasure+0x3a>
	{
		g_u16MotorCurrentMovAvgxN -= u16PrevMotorCurrent;						/* Subtract oldest raw motor-driver current */
    8fac:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    8fae:	aa01      	sub	A, [S-2]
		g_u16MotorCurrentMovAvgxN += u16MicroStepMotorCurrent;					/* Add newest raw motor-driver current */
    8fb0:	a2ee      	add	A, X
    8fb2:	5140      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, A
		*pu16MotorCurrentElement = u16MicroStepMotorCurrent;					/* Overwrite oldest with newest motor-driver current */
    8fb4:	7a03      	lod	Y, [S-4]
    8fb6:	5ef0      	mov	[Y], X
	}

	/* During twice the moving-average-buffer size and during acceleration of the motor, LPF should follow
	   lowest value of LPF or Motor-current. As the speed is increasing so also is the BEMF also increasing,
	   which causes the current to decrease. Otherwise a first order (IIR-1) LPF is used. */
	u16MotorCurrentAcc = (g_u16MotorCurrentMovAvgxN << (6u - C_MOVAVG_SSZ));
    8fb8:	7d40      	lod	X, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    8fba:	442e      	asl	X
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2u * C_MOVAVG_SZ))) || 
    8fbc:	72d8 00d8 	lod	A, 0xd8 <_l_u16StartupDelayInit>
    8fc0:	a0c0      	add	A, #-64
    8fc2:	ad20      	cmp	A, dp:0x20 <_g_u16StartupDelay>
    8fc4:	1808      	jc	0x8fd6 <_MotorDriverCurrentMeasure+0x58>
    8fc6:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    8fca:	8c02      	cmp	AL, #2
    8fcc:	1904      	je	0x8fd6 <_MotorDriverCurrentMeasure+0x58>
    8fce:	8c01      	cmp	AL, #1
    8fd0:	1d04      	jne	0x8fda <_MotorDriverCurrentMeasure+0x5c>
    8fd2:	2d42      	cmp	X, dp:0x42 <_g_u16MotorCurrentLPFx64>
    8fd4:	1c02      	jnc	0x8fda <_MotorDriverCurrentMeasure+0x5c>
		(g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || 
		((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (u16MotorCurrentAcc < g_u16MotorCurrentLPFx64)) )
	{
		g_u16MotorCurrentLPFx64 = u16MotorCurrentAcc;
    8fd6:	5d42      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, X
    8fd8:	000e      	jmp	0x8ff6 <_MotorDriverCurrentMeasure+0x78>
#if (MOTOR_MICROSTEPS < 3)
		/* LPF_B: IIR of 0.9921875 (127/128) & 0.0078125 (1/128) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63u) >> 7u)) + ((u16MotorCurrentAcc + 63u) >> 7u);
#else  /* (MOTOR_MICROSTEPS < 3) */
		/* LPF_B: IIR of 0.99609375 (255/256) & 0.00390625 (1/256) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 128u) >> 8u)) + ((u16MotorCurrentAcc + 128u) >> 8u);
    8fda:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    8fdc:	7ae2      	lod	Y, A
    8fde:	e2da 0080 	add	Y, #128
    8fe2:	6400      	lod	YL, #0
    8fe4:	7ae8      	swap	Y
    8fe6:	aae6      	sub	A, Y
    8fe8:	7aee      	lod	Y, X
    8fea:	e2da 0080 	add	Y, #128
    8fee:	6400      	lod	YL, #0
    8ff0:	7ae8      	swap	Y
    8ff2:	a2e6      	add	A, Y
    8ff4:	5142      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, A
#endif /* (MOTOR_MICROSTEPS < 3) */
	}

	/* startup delay decrement every current meassure(msp) */
	if ( g_u16StartupDelay > 0u )
    8ff6:	7120      	lod	A, dp:0x20 <_g_u16StartupDelay>
    8ff8:	1902      	je	0x8ffe <_MotorDriverCurrentMeasure+0x80>
	{
		g_u16StartupDelay--;
    8ffa:	a0ff      	add	A, #-1
    8ffc:	5120      	mov	dp:0x20 <_g_u16StartupDelay>, A
    8ffe:	5405      	ret	#6

00009000 <_EXT0_IT>:
 * Note: The Commutation_ISR() not be interrupted by LIN communication, also not by LIN status request.
 * The g_u8StallOcc flags can be set in this Commutation_ISR(), but cleared in the MotorDriverStop(),
 * before it is communicated back to the ECU/Master.
 * ****************************************************************************	*/
__interrupt__ void EXT0_IT(void)
{
    9000:	52df      	push	A
    9002:	5edf      	push	X
    9004:	5adf      	push	Y
    9006:	4c83      	push	D
    9008:	580b      	inc	S, #12
#if (_DEBUG_COMMUT_ISR != FALSE)
	DEBUG_SET_IO_B();
#endif /* (_DEBUG_COMMUT_ISR != FALSE) && (_DEBUG_HALLLATCH_ISR == FALSE) */

	uint16 pending = XI0_PEND & XI0_MASK;										/* Copy interrupt requests which are not masked   */
    900a:	7ad8 2034 	lod	Y, 0x2034 <__ep__+0x1034>
    900e:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    9012:	f6e2      	and	Y, A
	do
	{
		XI0_PEND = pending;														/* Clear requests which are going to be processed */
    9014:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
	} while ((XI0_PEND & pending) != 0u);
    9018:	72d8 2034 	lod	A, 0x2034 <__ep__+0x1034>
    901c:	b6e6      	and	A, Y
    901e:	1d7a      	jne	0x9014 <_EXT0_IT+0x14>

	if ( g_u8MotorStartupMode == (uint8) MSM_STOP )
    9020:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    9024:	1d01      	jne	0x9028 <_EXT0_IT+0x28>
    9026:	00a4      	jmp	0x9170 <_EXT0_IT+0x170>
	{
		return;		/* Used for CPU wake-up */
	}

	if ( g_e8MotorDirectionCCW == C_MOTOR_DIR_CCW)												/* Motor direction counter clockwise is true? */
    9028:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    902a:	8c01      	cmp	AL, #1
    902c:	1d03      	jne	0x9034 <_EXT0_IT+0x34>
	{
		g_u16ActuatorActPos--;													/* Closing */
    902e:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    9030:	a0ff      	add	A, #-1
    9032:	0002      	jmp	0x9038 <_EXT0_IT+0x38>
	}
	else
	{
		g_u16ActuatorActPos++;													/* Opening */
    9034:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    9036:	a001      	add	A, #1
    9038:	5146      	mov	dp:0x46 <_g_u16ActuatorActPos>, A
	}

	{
		int32 i32DeltaPosition = (int32)g_u16ActuatorActPos - (int32)g_u16ActuatorTgtPos;
    903a:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    903c:	4cc8      	movu	D, A
    903e:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    9040:	4cf2      	usex	YA
    9042:	4c10      	sub	D, YA
		if ( i32DeltaPosition == 0 )
    9044:	4cba 0000 	cmps	D, #0
    9048:	1d0a      	jne	0x905e <_EXT0_IT+0x5e>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    904a:	7002      	lod	A, #2
    904c:	164a      	call	0x8ce2 <_MotorDriverStop>
			return;
    904e:	5c0b      	dec	S, #12
    9050:	4cc3      	pop	D
    9052:	7acf      	pop	Y
    9054:	7ecf      	pop	X
    9056:	72cf      	pop	A
    9058:	4407      	mov	R, #0
    905a:	72cb      	pop	M
    905c:	5401      	ret
		}
		if ( i32DeltaPosition < 0 )
    905e:	4cba 0000 	cmps	D, #0
    9062:	1e81      	jsge	0x9066 <_EXT0_IT+0x66>
		{
			i32DeltaPosition = -i32DeltaPosition;
    9064:	4cd0      	neg	D
		}
		if ( i32DeltaPosition <= (int16) l_u8VTIdx )
    9066:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    9068:	5cf2      	usex	A
    906a:	5207      	mov	[S-8], A
    906c:	7800      	lod	Y, #0
    906e:	4c90      	cmp	D, YA
    9070:	1f05      	jsg	0x907c <_EXT0_IT+0x7c>
		{
			/* Decelerate motor speed (almost at target-position) */
			g_u16StartupDelay = (uint16) i32DeltaPosition;
    9072:	4c89      	mov	Y, DL
    9074:	5920      	mov	dp:0x20 <_g_u16StartupDelay>, Y
			g_u16TargetCommutTimerPeriod = l_u16LowSpeedPeriod;
    9076:	7ed8 0172 	lod	X, 0x172 <_l_u16LowSpeedPeriod>
    907a:	5d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, X
		}
	}

	/* Current measurement used for Stall-detector "A" and current control (PID) */
	MotorDriverCurrentMeasure();
    907c:	1780      	call	0x8f7e <_MotorDriverCurrentMeasure>

	/* open coil detection */
	(void)MotorDiagnosticOpenCheck();
    907e:	82db 85f8 	callf	0x85f8 <_MotorDiagnosticOpenCheck>
				}	
			}
		}
		else
		{
			if ( g_e8MotorDirectionCCW == C_MOTOR_DIR_CCW )
    9082:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    9084:	793e      	lod	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    9086:	5a09      	mov	[S-10], Y
    9088:	793a      	lod	Y, dp:0x3a <_g_u16MicroStepIdx>
    908a:	7d3c      	lod	X, dp:0x3c <_g_u16CommutTimerPeriod>
    908c:	8c01      	cmp	AL, #1
    908e:	1d08      	jne	0x90a0 <_EXT0_IT+0xa0>
			{
				/* Clock-wise (Opening) */
				g_u16MicroStepIdx++;													/* Increment the PWM vectors pointer */
    9090:	72e6      	lod	A, Y
    9092:	a001      	add	A, #1
    9094:	513a      	mov	dp:0x3a <_g_u16MicroStepIdx>, A
				if ( g_u16MicroStepIdx >= g_u16MotorMicroStepsPerElecRotation )			/* Test the PWM vectors pointer: 48 usteps per electrical period */
    9096:	aed8 0106 	cmp	A, 0x106 <_g_u16MotorMicroStepsPerElecRotation>
    909a:	180a      	jc	0x90b0 <_EXT0_IT+0xb0>
				{
					g_u16MicroStepIdx = 0u;												/* Re-initialise the PWM vectors pointer to 0 */
    909c:	7000      	lod	A, #0
    909e:	0007      	jmp	0x90ae <_EXT0_IT+0xae>
				}	
			}
			else
			{
				/* Counter Clock-wise (Closing) */
				if ( g_u16MicroStepIdx == 0u )
    90a0:	ec00      	cmp	Y, #0
    90a2:	1d03      	jne	0x90aa <_EXT0_IT+0xaa>
				{
					g_u16MicroStepIdx = g_u16MotorMicroStepsPerElecRotation;
    90a4:	7ad8 0106 	lod	Y, 0x106 <_g_u16MotorMicroStepsPerElecRotation>
    90a8:	593a      	mov	dp:0x3a <_g_u16MicroStepIdx>, Y
				}
				g_u16MicroStepIdx--;													/* Decrement the PWM vector pointer */
    90aa:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    90ac:	a0ff      	add	A, #-1
    90ae:	513a      	mov	dp:0x3a <_g_u16MicroStepIdx>, A
			}
		}
	}

	/* Check for speed update required */
	if ( g_u16CommutTimerPeriod == g_u16TargetCommutTimerPeriod )
    90b0:	2e09      	cmp	X, [S-10]
    90b2:	1d04      	jne	0x90bc <_EXT0_IT+0xbc>
	{
		g_u8MotorStartupMode = (uint8) MSM_STEPPER_C;
    90b4:	6003      	lod	AL, #3
    90b6:	42d8 00db 	mov	0xdb <_g_u8MotorStartupMode>, AL
    90ba:	0057      	jmp	0x916a <_EXT0_IT+0x16a>
	}
	else
	{
		/* Update speed */
		uint16 u16Compensation = l_u16SpeedRPM;							/* MMP160606-1 */
    90bc:	72d8 016c 	lod	A, 0x16c <_l_u16SpeedRPM>
    90c0:	520b      	mov	[S-12], A
		if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    90c2:	2e09      	cmp	X, [S-10]
    90c4:	1c2f      	jnc	0x9124 <_EXT0_IT+0x124>
		{
			/* Deceleration per micro-step */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_D;					/* Too fast, decelerate */
    90c6:	6002      	lod	AL, #2
    90c8:	42d8 00db 	mov	0xdb <_g_u8MotorStartupMode>, AL
    90cc:	4cea 0bb8 	movu	YA, #3000
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    90d0:	7e0b      	lod	X, [S-12]
    90d2:	4c63      	divu	YA, X
    90d4:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    90d6:	2ae2      	sub	X, A
    90d8:	5e03      	mov	[S-4], X
    90da:	5ed8 016c 	mov	0x16c <_l_u16SpeedRPM>, X
    90de:	72d8 016e 	lod	A, 0x16e <_l_u32Temp>
    90e2:	7ad8 0170 	lod	Y, 0x170 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    90e6:	4c63      	divu	YA, X
    90e8:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    90ea:	7ae2      	lod	Y, A
    90ec:	e0ff      	add	Y, #-1
    90ee:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM - divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1u;	/* MMP160606-1 */
			l_u8VTIdx--;
    90f0:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    90f2:	80ff      	add	AL, #-1
    90f4:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
			if ( g_u16StartupDelay < l_u8VTIdx )
    90f6:	5cf2      	usex	A
    90f8:	ad20      	cmp	A, dp:0x20 <_g_u16StartupDelay>
    90fa:	1a03      	jule	0x9102 <_EXT0_IT+0x102>
			{
				g_u16StartupDelay = l_u16StartupDelayInit;						/* MMP130627-1/MMP140331-2: Speed reduction, stall detection post-poned */
    90fc:	72d8 00d8 	lod	A, 0xd8 <_l_u16StartupDelayInit>
    9100:	5120      	mov	dp:0x20 <_g_u16StartupDelay>, A
			}
			if ( g_u16CommutTimerPeriod > g_u16TargetCommutTimerPeriod )
    9102:	ee09      	cmp	Y, [S-10]
    9104:	1a02      	jule	0x910a <_EXT0_IT+0x10a>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9106:	7a09      	lod	Y, [S-10]
    9108:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    910a:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    910c:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    910e:	72d8 0176 	lod	A, 0x176 <_g_u16PidCtrlRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9112:	7a03      	lod	Y, [S-4]
    9114:	7e0b      	lod	X, [S-12]
    9116:	4821      	mulu	YA, A, Y
    9118:	4c63      	divu	YA, X
    911a:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    911c:	52d8 0176 	mov	0x176 <_g_u16PidCtrlRatio>, A
#if (_SUPPORT_PWM_DC_RAMPDOWN != FALSE)											/* MMP140903-2 - Begin */
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
    9120:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
    9122:	0023      	jmp	0x916a <_EXT0_IT+0x16a>
#endif /* (_SUPPORT_PWM_DC_RAMPDOWN != FALSE) */								/* MMP140903-2 - Begin */

		}
		else if ( (g_u16MicroStepIdx == 0u) || ((g_u16MicroStepIdx > NVRAM_ACCELERATION_POINTS) && ((g_u16MicroStepIdx & NVRAM_ACCELERATION_POINTS) == 0u)) )
    9124:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    9126:	1904      	je	0x9130 <_EXT0_IT+0x130>
    9128:	ac01      	cmp	A, #1
    912a:	1a1f      	jule	0x916a <_EXT0_IT+0x16a>
    912c:	b401      	and	A, #1
    912e:	1d1d      	jne	0x916a <_EXT0_IT+0x16a>
		{
			/* Acceleration per acceleration_points ((multiple) full-step) */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;						/* Too slow, accelerate */
    9130:	6001      	lod	AL, #1
    9132:	42d8 00db 	mov	0xdb <_g_u8MotorStartupMode>, AL
    9136:	4cea 0bb8 	movu	YA, #3000
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    913a:	7e0b      	lod	X, [S-12]
    913c:	4c63      	divu	YA, X
    913e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9140:	22e2      	add	X, A
    9142:	5ed8 016c 	mov	0x16c <_l_u16SpeedRPM>, X
    9146:	72d8 016e 	lod	A, 0x16e <_l_u32Temp>
    914a:	7ad8 0170 	lod	Y, 0x170 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    914e:	4c63      	divu	YA, X
    9150:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9152:	7ae2      	lod	Y, A
    9154:	e0ff      	add	Y, #-1
    9156:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM + divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1u;	/* MMP160606-1 */
			l_u8VTIdx++;
    9158:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    915a:	8001      	add	AL, #1
    915c:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
			if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )		/* MMP150923-1 */
    915e:	ee09      	cmp	Y, [S-10]
    9160:	1c02      	jnc	0x9166 <_EXT0_IT+0x166>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9162:	7209      	lod	A, [S-10]
    9164:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    9166:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    9168:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
		{
			/* MISRA C:2012 Rule-15.7:All if ... else if constructs shall be terminated with an else statement */
		}
	}

	VoltageCorrection();
    916a:	1276      	call	0x9658 <_VoltageCorrection>

	MotorDriver_4PhaseStepper();
    916c:	82db 892e 	callf	0x892e <_MotorDriver_4PhaseStepper>
    9170:	5c0b      	dec	S, #12
    9172:	4cc3      	pop	D
    9174:	7acf      	pop	Y
    9176:	7ecf      	pop	X
    9178:	72cf      	pop	A
    917a:	4407      	mov	R, #0
    917c:	72cb      	pop	M
    917e:	5401      	ret

00009180 <_NVRAM_CRC8>:
	NVRAM_SavePage( NVRAM1_PAGE2);
} /* End of NVRAM_StorePatch() */


uint8 NVRAM_CRC8( const uint16 *pRAM, uint16 size)
{
    9180:	7ae2      	lod	Y, A
    9182:	7e03      	lod	X, [S-4]
    9184:	7000      	lod	A, #0
    9186:	08a7      	clrb	ML.7
    9188:	b2d6      	adc	A, [Y++]
    918a:	1bfe      	djnz	X, 0x9188 <_NVRAM_CRC8+0x8>
    918c:	92e4      	adc	AL, AH
    918e:	9000      	adc	AL, #0
    9190:	5cf2      	usex	A
	uint16 u16CRC;

	u16CRC = nvram_CalcCRC(pRAM, size);	/* MMP151202-1 */

	return ( (uint8) u16CRC );
    9192:	5cf2      	usex	A
} /* End of NVRAM_CRC8() */
    9194:	5401      	ret

00009196 <_NVRAM_Init>:
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode);


/***********************public functions ***************************/
void NVRAM_Init(void)
{
    9196:	5801      	inc	S, #2
	uint16 i;
	uint16 u16ErrorFlag; 
	uint8  u8CRC;
	
	/* dump to memory */
	NVRAM_LoadAll();
    9198:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
	u16ErrorFlag = (VARIOUS_L & EENV_DED);										/* Double-bit error state */
    919c:	6280      	lod	AL, io:0x0 <__dp__>
	/* Check Double-bit NVRAM set, User-NVRAM structure-revision and User-NVRAM Checksum */
	/* 1.check user page 1,if fail use default */
	pMRAM = (uint16 *)C_ADDR_USERPAGE1;
    919e:	7ada 1000 	lod	Y, #4096
    91a2:	5a01      	mov	[S-2], Y
	pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
	u8CRC = (uint8)NVRAM_CRC8(pMRAM,C_SIZE_USERPAGE1 / 2u);
    91a4:	54ca 0040 	pushw	#64
    91a8:	72da 1000 	lod	A, #4096
    91ac:	17e9      	call	0x9180 <_NVRAM_CRC8>
    91ae:	66e0      	lod	YL, AL
    91b0:	5cf6      	usex	Y
	if(((uint8)pIntegrity->CRC8_Revision != C_NVRAM_USER_REV) || (u8CRC != 0xFFu))
    91b2:	7e03      	lod	X, [S-4]
    91b4:	72f8      	lod	A, [X]
    91b6:	5c01      	dec	S, #2
    91b8:	8c02      	cmp	AL, #2
    91ba:	1d03      	jne	0x91c2 <_NVRAM_Init+0x2c>
    91bc:	62e8      	lod	AL, YL
    91be:	8cff      	cmp	AL, #-1
    91c0:	190b      	je	0x91d8 <_NVRAM_Init+0x42>
	{
		/* UniROM */
		pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;		/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    91c2:	7c02      	lod	X, #2
    91c4:	7a01      	lod	Y, [S-2]
    91c6:	5ef0      	mov	[Y], X
		pIntegrity->ProgramCount = 0u;
    91c8:	7000      	lod	A, #0
    91ca:	52f2      	mov	[Y+2], A
    91cc:	7ada 1000 	lod	Y, #4096
    91d0:	7c40      	lod	X, #64

		/* nvram may be corrupted,filled with default  */
		for(i = 0;i < (C_SIZE_USERPAGE2 / 2u);i++)
		{
			pMRAM[i] = 0xFFFFu;
    91d2:	70ff      	lod	A, #-1
    91d4:	52d6      	mov	[Y++], A
    91d6:	1bfd      	djnz	X, 0x91d2 <_NVRAM_Init+0x3c>
		}
	}
	/* 2.check user page 2:if fail padding with 0xFF */
	pMRAM = (uint16 *)C_ADDR_USERPAGE2;
    91d8:	7ada 1100 	lod	Y, #4352
    91dc:	5a01      	mov	[S-2], Y
	pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
	u8CRC = NVRAM_CRC8(pMRAM,C_SIZE_USERPAGE2 / 2u);
    91de:	54ca 0040 	pushw	#64
    91e2:	72da 1100 	lod	A, #4352
    91e6:	17cc      	call	0x9180 <_NVRAM_CRC8>
    91e8:	66e0      	lod	YL, AL
    91ea:	5cf6      	usex	Y
	if(((uint8)pIntegrity->CRC8_Revision != C_NVRAM_USER_REV) || (u8CRC != 0xFFu))
    91ec:	7e03      	lod	X, [S-4]
    91ee:	72f8      	lod	A, [X]
    91f0:	5c01      	dec	S, #2
    91f2:	8c02      	cmp	AL, #2
    91f4:	1d03      	jne	0x91fc <_NVRAM_Init+0x66>
    91f6:	62e8      	lod	AL, YL
    91f8:	8cff      	cmp	AL, #-1
    91fa:	190b      	je	0x9212 <_NVRAM_Init+0x7c>
	{
		/* UniROM */
		pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;		/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    91fc:	7c02      	lod	X, #2
    91fe:	7a01      	lod	Y, [S-2]
    9200:	5ef0      	mov	[Y], X
		pIntegrity->ProgramCount = 0u;
    9202:	7000      	lod	A, #0
    9204:	52f2      	mov	[Y+2], A
    9206:	7ada 1100 	lod	Y, #4352
    920a:	7c40      	lod	X, #64
		
		/* nvram may be corrupted,filled with padding  */
		for(i = 0;i < (C_SIZE_USERPAGE2 / 2u);i++)
		{
			pMRAM[i] = 0xFFFFu;
    920c:	70ff      	lod	A, #-1
    920e:	52d6      	mov	[Y++], A
    9210:	1bfd      	djnz	X, 0x920c <_NVRAM_Init+0x76>
    9212:	5403      	ret	#4

00009214 <_NVRAM_Read>:

}


uint8 NVRAM_Read(uint16 addr,uint16 buf[],uint16 size)
{
    9214:	5809      	inc	S, #10
    9216:	7ae2      	lod	Y, A
    9218:	720d      	lod	A, [S-14]
    921a:	5209      	mov	[S-10], A
    921c:	720f      	lod	A, [S-16]
    921e:	5207      	mov	[S-8], A
	uint16 *pMRAM;
	uint16 i;
	uint8 ret = NVRAM_E_OK;
    9220:	7000      	lod	A, #0
    9222:	5201      	mov	[S-2], A
	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE) ))
    9224:	eeda 0fff 	cmp	Y, #4095
    9228:	1a1a      	jule	0x925e <_NVRAM_Read+0x4a>
    922a:	7207      	lod	A, [S-8]
    922c:	a2e6      	add	A, Y
    922e:	aeda 103d 	cmp	A, #4157
    9232:	1e15      	jug	0x925e <_NVRAM_Read+0x4a>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA1_ADDR;
    9234:	72e6      	lod	A, Y
    9236:	487a 0002 	muls	Y, A, #2
    923a:	e2da f004 	add	Y, #61444
    923e:	5a05      	mov	[S-6], Y
		for(i = 0;i < size;i++)
    9240:	7000      	lod	A, #0
    9242:	5203      	mov	[S-4], A
    9244:	ae07      	cmp	A, [S-8]
    9246:	1c2a      	jnc	0x929c <_NVRAM_Read+0x88>
		{
			buf[i] = pMRAM[i];
    9248:	7203      	lod	A, [S-4]
    924a:	487a 0002 	muls	Y, A, #2
    924e:	7e09      	lod	X, [S-10]
    9250:	22e6      	add	X, Y
    9252:	e205      	add	Y, [S-6]
    9254:	72f0      	lod	A, [Y]
    9256:	52f8      	mov	[X], A
	uint8 ret = NVRAM_E_OK;
	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE) ))
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA1_ADDR;
		for(i = 0;i < size;i++)
    9258:	7203      	lod	A, [S-4]
    925a:	a001      	add	A, #1
    925c:	07f2      	jmp	0x9242 <_NVRAM_Read+0x2e>
		{
			buf[i] = pMRAM[i];
		}
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
    925e:	eeda 103d 	cmp	Y, #4157
    9262:	1a1a      	jule	0x9298 <_NVRAM_Read+0x84>
    9264:	7207      	lod	A, [S-8]
    9266:	a2e6      	add	A, Y
    9268:	aeda 107b 	cmp	A, #4219
    926c:	1e15      	jug	0x9298 <_NVRAM_Read+0x84>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA2_ADDR;
    926e:	72e6      	lod	A, Y
    9270:	487a 0002 	muls	Y, A, #2
    9274:	e2da f088 	add	Y, #61576
    9278:	5a05      	mov	[S-6], Y
		for(i = 0;i < size;i++)
    927a:	7000      	lod	A, #0
    927c:	5203      	mov	[S-4], A
    927e:	ae07      	cmp	A, [S-8]
    9280:	1c0d      	jnc	0x929c <_NVRAM_Read+0x88>
		{
			buf[i] = pMRAM[i];
    9282:	7203      	lod	A, [S-4]
    9284:	487a 0002 	muls	Y, A, #2
    9288:	7e09      	lod	X, [S-10]
    928a:	22e6      	add	X, Y
    928c:	e205      	add	Y, [S-6]
    928e:	72f0      	lod	A, [Y]
    9290:	52f8      	mov	[X], A
		}
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA2_ADDR;
		for(i = 0;i < size;i++)
    9292:	7203      	lod	A, [S-4]
    9294:	a001      	add	A, #1
    9296:	07f2      	jmp	0x927c <_NVRAM_Read+0x68>
			buf[i] = pMRAM[i];
		}
	}
	else
	{
		ret = NVRAM_E_INVALID_DATA;
    9298:	7001      	lod	A, #1
    929a:	5201      	mov	[S-2], A
	}

	return ret;
}
    929c:	7201      	lod	A, [S-2]
    929e:	540b      	ret	#12

000092a0 <_NVRAM_Write>:


uint8 NVRAM_Write(uint16 addr,const uint16 buf[],uint16 size)
{
    92a0:	5813      	inc	S, #20
    92a2:	7ae2      	lod	Y, A
    92a4:	7217      	lod	A, [S-24]
    92a6:	5213      	mov	[S-20], A
    92a8:	7219      	lod	A, [S-26]
    92aa:	5211      	mov	[S-18], A
	uint16  *pMRAM;
	uint8  u8VerifyRes,u8CRC8;
	PNVRAM_PAGEINTEGRITY pIntegrity;
	uint16  i;
	uint8  ret = NVRAM_E_OK;
    92ac:	7000      	lod	A, #0
    92ae:	5209      	mov	[S-10], A

	/* address should be even */	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE)))
    92b0:	eeda 0fff 	cmp	Y, #4095
    92b4:	1e01      	jug	0x92b8 <_NVRAM_Write+0x18>
    92b6:	004b      	jmp	0x934e <_NVRAM_Write+0xae>
    92b8:	7211      	lod	A, [S-18]
    92ba:	a2e6      	add	A, Y
    92bc:	aeda 103d 	cmp	A, #4157
    92c0:	1a01      	jule	0x92c4 <_NVRAM_Write+0x24>
    92c2:	0045      	jmp	0x934e <_NVRAM_Write+0xae>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA1_ADDR);
    92c4:	72e6      	lod	A, Y
    92c6:	487a 0002 	muls	Y, A, #2
    92ca:	e2da f004 	add	Y, #61444
    92ce:	5a0f      	mov	[S-16], Y

		/* copy with verifing */
		u8VerifyRes = 0u;
    92d0:	7800      	lod	Y, #0
    92d2:	5a0d      	mov	[S-14], Y
		for(i = 0;i < size;i++)
    92d4:	7c00      	lod	X, #0
    92d6:	7000      	lod	A, #0
    92d8:	ae11      	cmp	A, [S-18]
    92da:	1801      	jc	0x92de <_NVRAM_Write+0x3e>
    92dc:	008a      	jmp	0x93f2 <_NVRAM_Write+0x152>
		{
			if(buf[i] != pMRAM[i])
    92de:	72ee      	lod	A, X
    92e0:	4422      	asl	A
    92e2:	7a13      	lod	Y, [S-20]
    92e4:	e2e2      	add	Y, A
    92e6:	5a01      	mov	[S-2], Y
    92e8:	7a0f      	lod	Y, [S-16]
    92ea:	e2e2      	add	Y, A
    92ec:	5a07      	mov	[S-8], Y
    92ee:	7a01      	lod	Y, [S-2]
    92f0:	72f0      	lod	A, [Y]
    92f2:	7a07      	lod	Y, [S-8]
    92f4:	aef0      	cmp	A, [Y]
    92f6:	1904      	je	0x9300 <_NVRAM_Write+0x60>
			{
				u8VerifyRes = 1u;
    92f8:	7801      	lod	Y, #1
    92fa:	5a0d      	mov	[S-14], Y
				pMRAM[i] = buf[i];
    92fc:	7a07      	lod	Y, [S-8]
    92fe:	52f0      	mov	[Y], A
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA1_ADDR);

		/* copy with verifing */
		u8VerifyRes = 0u;
		for(i = 0;i < size;i++)
    9300:	2001      	add	X, #1
    9302:	2e11      	cmp	X, [S-18]
    9304:	186c      	jc	0x92de <_NVRAM_Write+0x3e>
				pMRAM[i] = buf[i];
			}
		}

		/* page verify result need saving  */
		if(u8VerifyRes == 1u)
    9306:	620d      	lod	AL, [S-14]
    9308:	8c01      	cmp	AL, #1
    930a:	1901      	je	0x930e <_NVRAM_Write+0x6e>
    930c:	0072      	jmp	0x93f2 <_NVRAM_Write+0x152>
		{
			/* program count and nvram user version */
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
    930e:	7ada 1000 	lod	Y, #4096
    9312:	5a0b      	mov	[S-12], Y
			pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;					/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    9314:	7c02      	lod	X, #2
    9316:	5ef0      	mov	[Y], X
			pIntegrity->ProgramCount++;
    9318:	72f2      	lod	A, [Y+2]
    931a:	a001      	add	A, #1
    931c:	52f2      	mov	[Y+2], A
			if(pIntegrity->ProgramCount >= C_MAX_NVRAM_PROGRAM_COUNT)
    931e:	aeda fde7 	cmp	A, #64999
    9322:	1a03      	jule	0x932a <_NVRAM_Write+0x8a>
			{
				pIntegrity->ProgramCount = C_MAX_NVRAM_PROGRAM_COUNT;
    9324:	72da fde8 	lod	A, #65000
    9328:	52f2      	mov	[Y+2], A
			}
			
			/* page intergrity */
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE1, C_SIZE_USERPAGE1 / 2u);	/* MMP151202-1 */
    932a:	54ca 0040 	pushw	#64
    932e:	72da 1000 	lod	A, #4096
    9332:	1726      	call	0x9180 <_NVRAM_CRC8>
    9334:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    9336:	60ff      	lod	AL, #-1
    9338:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    933a:	7e0d      	lod	X, [S-14]
    933c:	7af8      	lod	Y, [X]
    933e:	f6da 00ff 	and	Y, #255
    9342:	6800      	lod	AH, #0
    9344:	72e4      	swap	A
    9346:	e6e2      	or	Y, A
    9348:	5af8      	mov	[X], Y
			
			NVRAM_SavePage( NVRAM1_PAGE1);
    934a:	7000      	lod	A, #0
    934c:	004c      	jmp	0x93e6 <_NVRAM_Write+0x146>
		}
		
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
    934e:	eeda 103d 	cmp	Y, #4157
    9352:	1e01      	jug	0x9356 <_NVRAM_Write+0xb6>
    9354:	004c      	jmp	0x93ee <_NVRAM_Write+0x14e>
    9356:	7211      	lod	A, [S-18]
    9358:	a2e6      	add	A, Y
    935a:	aeda 107b 	cmp	A, #4219
    935e:	1a01      	jule	0x9362 <_NVRAM_Write+0xc2>
    9360:	0046      	jmp	0x93ee <_NVRAM_Write+0x14e>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA2_ADDR);
    9362:	72e6      	lod	A, Y
    9364:	487a 0002 	muls	Y, A, #2
    9368:	e2da f088 	add	Y, #61576
    936c:	5a0f      	mov	[S-16], Y

		/* copy and verify */
		u8VerifyRes = 0u;
    936e:	7800      	lod	Y, #0
    9370:	5a0d      	mov	[S-14], Y

		for(i = 0;i < size;i++)
    9372:	7c00      	lod	X, #0
    9374:	ee11      	cmp	Y, [S-18]
    9376:	1801      	jc	0x937a <_NVRAM_Write+0xda>
    9378:	003c      	jmp	0x93f2 <_NVRAM_Write+0x152>
		{
			if(buf[i] != pMRAM[i])
    937a:	72ee      	lod	A, X
    937c:	4422      	asl	A
    937e:	7a13      	lod	Y, [S-20]
    9380:	e2e2      	add	Y, A
    9382:	5a01      	mov	[S-2], Y
    9384:	7a0f      	lod	Y, [S-16]
    9386:	e2e2      	add	Y, A
    9388:	5a05      	mov	[S-6], Y
    938a:	7a01      	lod	Y, [S-2]
    938c:	72f0      	lod	A, [Y]
    938e:	7a05      	lod	Y, [S-6]
    9390:	aef0      	cmp	A, [Y]
    9392:	1904      	je	0x939c <_NVRAM_Write+0xfc>
			{
				u8VerifyRes = 1u;
    9394:	7801      	lod	Y, #1
    9396:	5a0d      	mov	[S-14], Y
				pMRAM[i] = buf[i];
    9398:	7a05      	lod	Y, [S-6]
    939a:	52f0      	mov	[Y], A
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA2_ADDR);

		/* copy and verify */
		u8VerifyRes = 0u;

		for(i = 0;i < size;i++)
    939c:	2001      	add	X, #1
    939e:	2e11      	cmp	X, [S-18]
    93a0:	186c      	jc	0x937a <_NVRAM_Write+0xda>
				pMRAM[i] = buf[i];
			}
		}

		/* page verify result need saving,then start save process  */
		if(u8VerifyRes == 1u)
    93a2:	620d      	lod	AL, [S-14]
    93a4:	8c01      	cmp	AL, #1
    93a6:	1d25      	jne	0x93f2 <_NVRAM_Write+0x152>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
    93a8:	7ada 1100 	lod	Y, #4352
    93ac:	5a0b      	mov	[S-12], Y
			pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;					/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    93ae:	7c02      	lod	X, #2
    93b0:	5ef0      	mov	[Y], X
			pIntegrity->ProgramCount++;
    93b2:	72f2      	lod	A, [Y+2]
    93b4:	a001      	add	A, #1
    93b6:	52f2      	mov	[Y+2], A
			if(pIntegrity->ProgramCount >= C_MAX_NVRAM_PROGRAM_COUNT)
    93b8:	aeda fde7 	cmp	A, #64999
    93bc:	1a03      	jule	0x93c4 <_NVRAM_Write+0x124>
			{
				pIntegrity->ProgramCount = C_MAX_NVRAM_PROGRAM_COUNT;
    93be:	72da fde8 	lod	A, #65000
    93c2:	52f2      	mov	[Y+2], A
			}
			/* page intergrity */
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE2, C_SIZE_USERPAGE2 / 2u);	/* MMP151202-1 */
    93c4:	54ca 0040 	pushw	#64
    93c8:	72da 1100 	lod	A, #4352
    93cc:	16d9      	call	0x9180 <_NVRAM_CRC8>
    93ce:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    93d0:	60ff      	lod	AL, #-1
    93d2:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    93d4:	7e0d      	lod	X, [S-14]
    93d6:	7af8      	lod	Y, [X]
    93d8:	f6da 00ff 	and	Y, #255
    93dc:	6800      	lod	AH, #0
    93de:	72e4      	swap	A
    93e0:	e6e2      	or	Y, A
    93e2:	5af8      	mov	[X], Y
			
			NVRAM_SavePage( NVRAM2_PAGE1);
    93e4:	7002      	lod	A, #2
    93e6:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    93ea:	5c01      	dec	S, #2
    93ec:	0002      	jmp	0x93f2 <_NVRAM_Write+0x152>
		}
	}
	else
	{
		ret = NVRAM_E_INVALID_DATA;
    93ee:	7001      	lod	A, #1
    93f0:	5209      	mov	[S-10], A
	}

	return ret;
	
}
    93f2:	7209      	lod	A, [S-10]
    93f4:	5415      	ret	#22

000093f6 <_NVRAM_Store>:

/* LIN diagnostic compatiable interface:for system configuration page */
uint16 NVRAM_Store( uint16 u16Page)
{
    93f6:	5803      	inc	S, #4
    93f8:	5203      	mov	[S-4], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;
	uint8 u8CRC8;
	PNVRAM_PAGEINTEGRITY pIntegrity;

	if((u16Page & C_NVRAM_USER_PAGE_1) != 0u)
    93fa:	b401      	and	A, #1
    93fc:	191a      	je	0x9432 <_NVRAM_Store+0x3c>
	{
		if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0u )
    93fe:	6203      	lod	AL, [S-4]
    9400:	8c00      	cmp	AL, #0
    9402:	1a94      	jsl	0x942c <_NVRAM_Store+0x36>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
    9404:	7ada 1000 	lod	Y, #4096
    9408:	5a01      	mov	[S-2], Y
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE1, C_SIZE_USERPAGE1 / 2u);	/* MMP151202-1 */
    940a:	54ca 0040 	pushw	#64
    940e:	72da 1000 	lod	A, #4096
    9412:	16b6      	call	0x9180 <_NVRAM_CRC8>
    9414:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    9416:	60ff      	lod	AL, #-1
    9418:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    941a:	7e03      	lod	X, [S-4]
    941c:	7af8      	lod	Y, [X]
    941e:	f6da 00ff 	and	Y, #255
    9422:	6800      	lod	AH, #0
    9424:	72e4      	swap	A
    9426:	e6e2      	or	Y, A
    9428:	5af8      	mov	[X], Y
    942a:	5c01      	dec	S, #2
			
		}
		NVRAM_SavePage( NVRAM1_PAGE1);
    942c:	7000      	lod	A, #0
    942e:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
	}

	if((u16Page & C_NVRAM_USER_PAGE_2) != 0u)
    9432:	7203      	lod	A, [S-4]
    9434:	b402      	and	A, #2
    9436:	191a      	je	0x946c <_NVRAM_Store+0x76>
	{
		if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0u )
    9438:	6203      	lod	AL, [S-4]
    943a:	8c00      	cmp	AL, #0
    943c:	1a94      	jsl	0x9466 <_NVRAM_Store+0x70>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
    943e:	7ada 1100 	lod	Y, #4352
    9442:	5a01      	mov	[S-2], Y
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE2, C_SIZE_USERPAGE2 / 2u);	/* MMP151202-1 */
    9444:	54ca 0040 	pushw	#64
    9448:	72da 1100 	lod	A, #4352
    944c:	1699      	call	0x9180 <_NVRAM_CRC8>
    944e:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    9450:	60ff      	lod	AL, #-1
    9452:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    9454:	7e03      	lod	X, [S-4]
    9456:	7af8      	lod	Y, [X]
    9458:	f6da 00ff 	and	Y, #255
    945c:	6800      	lod	AH, #0
    945e:	72e4      	swap	A
    9460:	e6e2      	or	Y, A
    9462:	5af8      	mov	[X], Y
    9464:	5c01      	dec	S, #2
		}
		NVRAM_SavePage( NVRAM2_PAGE1);
    9466:	7002      	lod	A, #2
    9468:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
	}

	return u16Result;
}
    946c:	7000      	lod	A, #0
    946e:	5405      	ret	#6

00009470 <_NVRAM_StorePatch>:
 * C_ADDR_PATCHPAGE+0x7A:0x7B:	PATCH3_A
 *
 * ****************************************************************************	*/
void NVRAM_StorePatch( void)
{
	NVRAM_SavePage( NVRAM1_PAGE2);
    9470:	7001      	lod	A, #1
    9472:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    9476:	5401      	ret

00009478 <_NVRAM_CountCRC8>:
 *								TRUE: Calculated CRC8.
 *
 *	Calculate CRC8 on Write-cycle counter.
 * ****************************************************************************	*/
uint8 NVRAM_CountCRC8( PNVRAM_ERRORLOG pNVERRLOG, uint8 byReplaceCRC)
{
    9478:	5807      	inc	S, #8
    947a:	5203      	mov	[S-4], A
    947c:	620b      	lod	AL, [S-12]
    947e:	5cf2      	usex	A
    9480:	5201      	mov	[S-2], A
    9482:	7c01      	lod	X, #1
    9484:	7a03      	lod	Y, [S-4]
    9486:	7000      	lod	A, #0
    9488:	08a7      	clrb	ML.7
    948a:	b2d6      	adc	A, [Y++]
    948c:	1bfe      	djnz	X, 0x948a <_NVRAM_CountCRC8+0x12>
    948e:	92e4      	adc	AL, AH
    9490:	9000      	adc	AL, #0
    9492:	5cf2      	usex	A
    9494:	5207      	mov	[S-8], A
	uint16 u16CRC = nvram_CalcCRC( (uint16 *) &pNVERRLOG->NvramProgramCycleCount, 1);	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    9496:	7201      	lod	A, [S-2]
    9498:	190c      	je	0x94b2 <_NVRAM_CountCRC8+0x3a>
	{
		pNVERRLOG->ErrorLogIndex_CRC = (pNVERRLOG->ErrorLogIndex_CRC & 0x00FFu) | ((0xFFu - u16CRC) << 8u);
    949a:	7a03      	lod	Y, [S-4]
    949c:	72f2      	lod	A, [Y+2]
    949e:	b6da 00ff 	and	A, #255
    94a2:	7ee2      	lod	X, A
    94a4:	72da 00ff 	lod	A, #255
    94a8:	aa07      	sub	A, [S-8]
    94aa:	6800      	lod	AH, #0
    94ac:	72e4      	swap	A
    94ae:	26e2      	or	X, A
    94b0:	5ef2      	mov	[Y+2], X
	}
	return ( (uint8) ((pNVERRLOG->ErrorLogIndex_CRC >> 8u) ^ u16CRC) );
    94b2:	7a03      	lod	Y, [S-4]
    94b4:	62f3      	lod	AL, [Y+3]
    94b6:	9e07      	xor	AL, [S-8]
    94b8:	5cf2      	usex	A
} /* End of NVRAM_CountCRC8() */
    94ba:	5409      	ret	#10

000094bc <_PlaceError>:
 *			u8ErrorCode: Error-code
 *	Post:	-
 *	Comments: Write error-code into NVRAM (16-bits words based)
 * ****************************************************************************	*/
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode)
{
    94bc:	5801      	inc	S, #2
    94be:	7ee2      	lod	X, A
    94c0:	6207      	lod	AL, [S-8]
    94c2:	66e0      	lod	YL, AL
    94c4:	5cf6      	usex	Y
    94c6:	72f8      	lod	A, [X]
    94c8:	5201      	mov	[S-2], A
	if ( u16OddEven != 0u )
    94ca:	7205      	lod	A, [S-6]
    94cc:	1905      	je	0x94d8 <_PlaceError+0x1c>
	{
		/* Odd index: MSB of uint16 */
		*pu16ErrorElement = (uint8)(*pu16ErrorElement) | (((uint16) u8ErrorCode) << 8u);
    94ce:	6201      	lod	AL, [S-2]
    94d0:	5cf2      	usex	A
    94d2:	6c00      	lod	YH, #0
    94d4:	7ae8      	swap	Y
    94d6:	0003      	jmp	0x94de <_PlaceError+0x22>
	}
	else
	{
		/* Even index: LSB of uint16 */
		*pu16ErrorElement = (*pu16ErrorElement & 0xFF00u) | ((uint16) u8ErrorCode);
    94d8:	7201      	lod	A, [S-2]
    94da:	b6da ff00 	and	A, #65280
    94de:	a6e6      	or	A, Y
    94e0:	52f8      	mov	[X], A
    94e2:	5403      	ret	#4

000094e4 <_NVRAM_LogError>:
 *	result is either 0 or 1, indicating which page should be written next-time.
 * Index at user-page #1/#2: 0-11: Empty/over-write index, FF: Full
 * If index user-page #1 is not 0xFF (Full), write error at page #1, otherwise page #2
 * ****************************************************************************	*/
uint16 NVRAM_LogError( uint8 u8ErrorCode)
{
    94e4:	5805      	inc	S, #6
    94e6:	5205      	mov	[S-6], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    94e8:	7000      	lod	A, #0
    94ea:	5203      	mov	[S-4], A
	
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
	uint16 u16ErrorLogIdx = (uint8) (pNVERRLOG_UPG->ErrorLogIndex_CRC);
    94ec:	7ada 1170 	lod	Y, #4464
    94f0:	72f2      	lod	A, [Y+2]
    94f2:	5cf2      	usex	A
    94f4:	5201      	mov	[S-2], A
	
	
	if ( (u16ErrorLogIdx & 0x80u) == 0x00u )
    94f6:	8c00      	cmp	AL, #0
    94f8:	1e81      	jsge	0x94fc <_NVRAM_LogError+0x18>
    94fa:	003a      	jmp	0x9570 <_NVRAM_LogError+0x8c>
	{
		/* Store error on User-Page #1 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx >= C_MAX_ERRORS_PER_PAGE )						/* Check against array overflow */
    94fc:	ac0b      	cmp	A, #11
    94fe:	1a02      	jule	0x9504 <_NVRAM_LogError+0x20>
		{
			u16ErrorLogIdx = 0u;
    9500:	7000      	lod	A, #0
    9502:	5201      	mov	[S-2], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) == 0x00u )
    9504:	54ca 0000 	pushw	#0
    9508:	72da 1170 	lod	A, #4464
    950c:	17b5      	call	0x9478 <_NVRAM_CountCRC8>
    950e:	5c01      	dec	S, #2
    9510:	8c00      	cmp	AL, #0
    9512:	1d05      	jne	0x951e <_NVRAM_LogError+0x3a>
		{
			pNVERRLOG_UPG->NvramProgramCycleCount++;
    9514:	7ada 1170 	lod	Y, #4464
    9518:	72f0      	lod	A, [Y]
    951a:	a001      	add	A, #1
    951c:	0003      	jmp	0x9524 <_NVRAM_LogError+0x40>
		}
		else
		{
			pNVERRLOG_UPG->NvramProgramCycleCount = 1U;
    951e:	7001      	lod	A, #1
    9520:	7ada 1170 	lod	Y, #4464
    9524:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End */
		/* store error log */
		if ( pNVERRLOG_UPG->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000u) )
    9526:	7ada 1170 	lod	Y, #4464
    952a:	72f0      	lod	A, [Y]
    952c:	aeda f9ff 	cmp	A, #63999
    9530:	1e1d      	jug	0x956c <_NVRAM_LogError+0x88>
        {
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    9532:	54ca 0001 	pushw	#1
    9536:	72da 1170 	lod	A, #4464
    953a:	179e      	call	0x9478 <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG->ErrorLog[u16ErrorLogIdx >> 1u]), u16ErrorLogIdx & 0x01u, u8ErrorCode);
    953c:	7203      	lod	A, [S-4]
    953e:	b6da 00fe 	and	A, #254
    9542:	a2da 1174 	add	A, #4468
    9546:	7a07      	lod	Y, [S-8]
    9548:	5adf      	push	Y
    954a:	7a05      	lod	Y, [S-6]
    954c:	f401      	and	Y, #1
    954e:	5adf      	push	Y
    9550:	17b5      	call	0x94bc <_PlaceError>
			pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00u) | u16ErrorLogIdx;
    9552:	7ada 1170 	lod	Y, #4464
    9556:	72f2      	lod	A, [Y+2]
    9558:	b6da ff00 	and	A, #65280
    955c:	a607      	or	A, [S-8]
    955e:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    9560:	72da 8002 	lod	A, #32770
    9564:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    9568:	5c05      	dec	S, #6
    956a:	0002      	jmp	0x9570 <_NVRAM_LogError+0x8c>
		}
		else
		{
			u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
    956c:	7001      	lod	A, #1
    956e:	5203      	mov	[S-4], A
		}
		
	}
	return ( u16Result );														/* MMP150219-1 */
} /* End of NVRAM_LogError() */
    9570:	7203      	lod	A, [S-4]
    9572:	5407      	ret	#8

00009574 <_NVRAM_GetLastError>:
 *
 *	Pre:	-
 *	Post:	(uint8) Last logged error-code
 * ****************************************************************************	*/
uint8 NVRAM_GetLastError( void)
{
    9574:	5801      	inc	S, #2
	uint16 u16ErrorLogIdx;
	uint8 u8Result = 0x00u;														/* No error's */
    9576:	7000      	lod	A, #0
    9578:	5201      	mov	[S-2], A

	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
    957a:	7ada 1170 	lod	Y, #4464
	u16ErrorLogIdx = (uint8) (pNVERRLOG_UPG->ErrorLogIndex_CRC);
    957e:	72f2      	lod	A, [Y+2]
    9580:	5cf2      	usex	A
    9582:	7ee2      	lod	X, A

	if ( u16ErrorLogIdx != 0x00u )
    9584:	190f      	je	0x95a4 <_NVRAM_GetLastError+0x30>
	{																			/* MMP140218-1 */
		/* Get last error from User-Page #2 */
		u16ErrorLogIdx--;
    9586:	20ff      	add	X, #-1
		{
			uint16 u16ErrorCodes = pNVERRLOG_UPG->ErrorLog[u16ErrorLogIdx >> 1u];
    9588:	72ee      	lod	A, X
    958a:	b4fe      	and	A, #-2
    958c:	7ae2      	lod	Y, A
    958e:	e2da 1174 	add	Y, #4468
    9592:	7af0      	lod	Y, [Y]
			if ( (u16ErrorLogIdx & 0x01u) != 0u )
    9594:	72ee      	lod	A, X
    9596:	b401      	and	A, #1
    9598:	1903      	je	0x95a0 <_NVRAM_GetLastError+0x2c>
			{
				u8Result = (uint8) (u16ErrorCodes >> 8u);
    959a:	6400      	lod	YL, #0
    959c:	7ae8      	swap	Y
    959e:	0001      	jmp	0x95a2 <_NVRAM_GetLastError+0x2e>
			}
			else
			{
				u8Result = (uint8) u16ErrorCodes;
    95a0:	5cf6      	usex	Y
    95a2:	5a01      	mov	[S-2], Y
			}
		}
	}
	return( u8Result );

} /* End of NVRAM_GetLastError() */
    95a4:	7201      	lod	A, [S-2]
    95a6:	5403      	ret	#4

000095a8 <_NVRAM_ClearErrorLog>:
 *	Comments: Clear Application Error logging (in both User-NVRAM pages)
 * ****************************************************************************	*/
void NVRAM_ClearErrorLog( void)
{
	uint16 i;
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
    95a8:	7ada 1170 	lod	Y, #4464
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00u) | 0x00u;	/* Set index at 0x00 */
    95ac:	72f2      	lod	A, [Y+2]
    95ae:	b6da ff00 	and	A, #65280
    95b2:	52f2      	mov	[Y+2], A
    95b4:	7ada 1174 	lod	Y, #4468
    95b8:	7c06      	lod	X, #6
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE / 2u); i++ )
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000u;
    95ba:	7000      	lod	A, #0
    95bc:	52d6      	mov	[Y++], A
    95be:	1bfd      	djnz	X, 0x95ba <_NVRAM_ClearErrorLog+0x12>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    95c0:	54ca 0001 	pushw	#1
    95c4:	72da 1170 	lod	A, #4464
    95c8:	1757      	call	0x9478 <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM2_PAGE1);
    95ca:	7002      	lod	A, #2
    95cc:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    95d0:	5c01      	dec	S, #2
    95d2:	5401      	ret

000095d4 <_PID_Init>:

/* ***
 * PID_Init()
 * ***/
void PID_Init( void)
{
    95d4:	580d      	inc	S, #14
	/* MMP141209-1: Convert [mA] to [ADC-lsb] */
	uint16 u16MCurrgain = EE_GMCURR;
    95d6:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    95da:	b6da 00ff 	and	A, #255
    95de:	7ee2      	lod	X, A
    95e0:	22da 0100 	add	X, #256
	g_u16PidHoldingThreshold = NVRAM_HOLDING_CURR_LEVEL;
    95e4:	7032      	lod	A, #50
    95e6:	52d8 017c 	mov	0x17c <_g_u16PidHoldingThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    95ea:	72da 0080 	lod	A, #128
    95ee:	7832      	lod	Y, #50
    95f0:	4821      	mulu	YA, A, Y
    95f2:	4c63      	divu	YA, X
    95f4:	4c63      	divu	YA, X
    95f6:	520d      	mov	[S-14], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    95f8:	52d8 0180 	mov	0x180 <_g_u16PidHoldingThresholdADC>, A
	g_u16PidHoldingThresholdADC = muldivU16_U16byU16byU16( g_u16PidHoldingThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1 */
	g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL;
    95fc:	72da 012c 	lod	A, #300
    9600:	52d8 0178 	mov	0x178 <_g_u16PidRunningThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9604:	72da 0080 	lod	A, #128
    9608:	7ada 012c 	lod	Y, #300
    960c:	4821      	mulu	YA, A, Y
    960e:	4c63      	divu	YA, X
    9610:	4c63      	divu	YA, X
    9612:	520b      	mov	[S-12], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9614:	52d8 017a 	mov	0x17a <_g_u16PidRunningThresholdADC>, A
	g_u16PidRunningThresholdADC = muldivU16_U16byU16byU16( g_u16PidRunningThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1/MMP131219-1 */
	g_u16MotorRefVoltage = NVRAM_VSUP_REF;
    9618:	7eda 0546 	lod	X, #1350
    961c:	5ed8 00de 	mov	0xde <_g_u16MotorRefVoltage>, X
    9620:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    9624:	6000      	lod	AL, #0
    9626:	72e4      	swap	A
    9628:	5203      	mov	[S-4], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    962a:	72da 0546 	lod	A, #1350
    962e:	7840      	lod	Y, #64
    9630:	7e03      	lod	X, [S-4]
    9632:	4821      	mulu	YA, A, Y
    9634:	4c63      	divu	YA, X
    9636:	4c63      	divu	YA, X
    9638:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    963a:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    963e:	5ce2      	ssex	A
    9640:	a201      	add	A, [S-2]
    9642:	52d8 00dc 	mov	0xdc <_l_u16MotorRefVoltageADC>, A
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GVOLTAGE) + EE_OVOLTAGE;
#else  /* _SUPPORT_VSMFILTERED */
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GADC) + EE_OADC;
#endif /* _SUPPORT_VSMFILTERED */

	l_u16MinCorrectionRatio = NVRAM_MIN_CORR_RATIO;								/* MMP150509-2 */
    9646:	72da 08df 	lod	A, #2271
    964a:	52d8 0182 	mov	0x182 <_l_u16MinCorrectionRatio>, A
	l_u16MaxCorrectionRatio = NVRAM_MAX_CORR_RATIO;								/* MMP150509-2 */
    964e:	7ada 55ab 	lod	Y, #21931
    9652:	5ad8 0184 	mov	0x184 <_l_u16MaxCorrectionRatio>, Y
    9656:	540f      	ret	#16

00009658 <_VoltageCorrection>:
 *
 *	Compensate Motor PWM Duty Cycle for voltage changes
 * Performance: 7.5us @ 20Mz
 * ***/
void VoltageCorrection( void)
{
    9658:	5801      	inc	S, #2

#define ADC_SETTING (uint16)(((2U*PLL_freq)/(1000000U*2*CYCLES_PER_INSTR)) + 1)	/* 2us: 2us*PLL-freq/(10000000us/s * #cycles/instruction) */

static INLINE uint16 GetRawVsupplyMotor( void)
{
extern T_ADC_MOTORRUN_STEPPER4 volatile g_AdcMotorRunStepper4;					/* ADC results Stepper mode */
    965a:	7ed8 00f6 	lod	X, 0xf6 <_g_AdcMotorRunStepper4+0x6>
	uint16 u16MotorVoltageADC = GetRawVsupplyMotor();
#if _DEBUG_VOLTAGE_COMPENSATION
	l_ai16MotorVolt[u16MotorVoltIdx] = g_i16MotorVoltage;
	u16MotorVoltIdx = (u16MotorVoltIdx + 1u) & (SZ_MOTOR_VOLT_COMP - 1u);
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	if ( (u16MotorVoltageADC > 0u) && (l_u16MotorRefVoltageADC > 0u) )
    965e:	191f      	je	0x969e <_VoltageCorrection+0x46>
    9660:	7ad8 00dc 	lod	Y, 0xdc <_l_u16MotorRefVoltageADC>
    9664:	191c      	je	0x969e <_VoltageCorrection+0x46>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    9666:	72d8 0176 	lod	A, 0x176 <_g_u16PidCtrlRatio>
    uint32 result;

    __asm__ __volatile__ (
    966a:	4801      	mulu	D, A, Y
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    966c:	4c80      	mov	YA, D
    966e:	4c63      	divu	YA, X
    9670:	4c63      	divu	YA, X
    9672:	7ee2      	lod	X, A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    9674:	7ae2      	lod	Y, A
	{
		/* Correct Motor PWM duty cycle instantly based on change of supply voltage */
		uint16 u16NewCorrectionRatio = divU16_U32byU16( mulU32_U16byU16( g_u16PidCtrlRatio, l_u16MotorRefVoltageADC), u16MotorVoltageADC);
		if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP  )
    9676:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    967a:	190a      	je	0x9690 <_VoltageCorrection+0x38>
		{
			if ( u16NewCorrectionRatio < l_u16MinCorrectionRatio )
    967c:	72d8 0182 	lod	A, 0x182 <_l_u16MinCorrectionRatio>
    9680:	2ee2      	cmp	X, A
    9682:	1804      	jc	0x968c <_VoltageCorrection+0x34>
			{
				/* Underflow */
				u16NewCorrectionRatio = l_u16MinCorrectionRatio;
			}
			else if ( u16NewCorrectionRatio > l_u16MaxCorrectionRatio )
    9684:	72d8 0184 	lod	A, 0x184 <_l_u16MaxCorrectionRatio>
    9688:	2ee2      	cmp	X, A
    968a:	1a07      	jule	0x969a <_VoltageCorrection+0x42>
			{
				/* Overflow */
				u16NewCorrectionRatio = l_u16MaxCorrectionRatio;
    968c:	7ae2      	lod	Y, A
    968e:	0005      	jmp	0x969a <_VoltageCorrection+0x42>
			else
			{
				
			}
		}
		else if ( u16NewCorrectionRatio < NVRAM_MIN_HOLDCORR_RATIO )
    9690:	2eda 08de 	cmp	X, #2270
    9694:	1e02      	jug	0x969a <_VoltageCorrection+0x42>
		{
			/* Underflow */
			u16NewCorrectionRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9696:	7ada 08df 	lod	Y, #2271
		}
		else
		{
			
		}
		g_u16CorrectionRatio = u16NewCorrectionRatio;
    969a:	5938      	mov	dp:0x38 <_g_u16CorrectionRatio>, Y
    969c:	5403      	ret	#4
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    969e:	72d8 0176 	lod	A, 0x176 <_g_u16PidCtrlRatio>
    96a2:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
    96a4:	5403      	ret	#4

000096a6 <_PID_Control>:
 *	DC: Motor PWM Duty Cycle; 
 *	Stepper: current-control;
 *	BEMF: speed-control
 * ***/
void PID_Control( void)
{
    96a6:	5805      	inc	S, #6
		int16 i16PID_Ipart;
		int16 i16PID_Ppart;
		uint16 u16PidCtrlRatio;

		/* Current Control */
		uint16 u16MotorCurrentLPFFraction = ((g_u16MotorCurrentLPFx64 + 32u) >> 6u);	/* MMP140911-1 */
    96a8:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    96aa:	7ae2      	lod	Y, A
    96ac:	e020      	add	Y, #32
    96ae:	44b6      	lsr	Y, #2
    96b0:	44b6      	lsr	Y, #2
    96b2:	44b6      	lsr	Y, #2
		
		if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    96b4:	62d8 00db 	lod	AL, 0xdb <_g_u8MotorStartupMode>
    96b8:	4205      	mov	[S-6], AL
    96ba:	1909      	je	0x96ce <_PID_Control+0x28>
		{
			i16ControlError = (int16) (g_u16PidRunningThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    96bc:	72d8 017a 	lod	A, 0x17a <_g_u16PidRunningThresholdADC>
    96c0:	7ee2      	lod	X, A
    96c2:	2ae6      	sub	X, Y
			l_u16MaxPidCtrlRatio = l_u16MaxCorrectionRatio;
    96c4:	7ad8 0184 	lod	Y, 0x184 <_l_u16MaxCorrectionRatio>
    96c8:	5ad8 017e 	mov	0x17e <_l_u16MaxPidCtrlRatio>, Y
    96cc:	0004      	jmp	0x96d6 <_PID_Control+0x30>
		}
		else
		{
			i16ControlError = (int16) (g_u16PidHoldingThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    96ce:	72d8 0180 	lod	A, 0x180 <_g_u16PidHoldingThresholdADC>
    96d2:	7ee2      	lod	X, A
    96d4:	2ae6      	sub	X, Y
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    96d6:	7aee      	lod	Y, X
    96d8:	ead8 00e0 	sub	Y, 0xe0 <_g_i16PID_E>
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    96dc:	701e      	lod	A, #30
    96de:	4831      	muls	YA, A, Y
    96e0:	48b5      	asr	YA, #6
    96e2:	b000      	adc	A, #0
    96e4:	5203      	mov	[S-4], A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    96e6:	52d8 00e2 	mov	0xe2 <_g_i16PID_D>, A
		}

		/* Derivative-part */
		g_i16PID_D = mulI16_I16byI16RndDiv64( (i16ControlError - g_i16PID_E), (int16)NVRAM_PID_COEF_D);
		g_i16PID_E = i16ControlError;
    96ea:	5ed8 00e0 	mov	0xe0 <_g_i16PID_E>, X
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    96ee:	701e      	lod	A, #30
    96f0:	4833      	muls	YA, A, X
    96f2:	48b5      	asr	YA, #6
    96f4:	b000      	adc	A, #0
    96f6:	5201      	mov	[S-2], A
		/* Integral-part */
		i16PID_Ipart = mulI16_I16byI16RndDiv64( i16ControlError, (int16)NVRAM_PID_COEF_I);
		if ( (i16PID_Ipart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ipart)) )
    96f8:	ac00      	cmp	A, #0
    96fa:	1e87      	jsge	0x970a <_PID_Control+0x64>
    96fc:	7201      	lod	A, [S-2]
    96fe:	5cc2      	neg	A
    9700:	ad50      	cmp	A, dp:0x50 <_g_u16PID_I>
    9702:	1a03      	jule	0x970a <_PID_Control+0x64>
		{
			g_u16PID_I = 0u;
    9704:	7800      	lod	Y, #0
    9706:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    9708:	0003      	jmp	0x9710 <_PID_Control+0x6a>
		}
		else
		{
			g_u16PID_I = (uint16) ((int16)g_u16PID_I + i16PID_Ipart);
    970a:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    970c:	a201      	add	A, [S-2]
    970e:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9710:	7832      	lod	Y, #50
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9712:	72e6      	lod	A, Y
    9714:	4833      	muls	YA, A, X
    9716:	48b5      	asr	YA, #6
    9718:	b000      	adc	A, #0
    971a:	7ee2      	lod	X, A
		}
		/* Proportional-part */
		i16PID_Ppart = mulI16_I16byI16RndDiv64( i16ControlError, (int16) NVRAM_PID_COEF_P);
		if ( (i16PID_Ppart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ppart)) )
    971c:	ac00      	cmp	A, #0
    971e:	1e8d      	jsge	0x973a <_PID_Control+0x94>
    9720:	5cc2      	neg	A
    9722:	ad50      	cmp	A, dp:0x50 <_g_u16PID_I>
    9724:	1a0a      	jule	0x973a <_PID_Control+0x94>
		{
			if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    9726:	6205      	lod	AL, [S-6]
    9728:	1903      	je	0x9730 <_PID_Control+0x8a>
			{
				u16PidCtrlRatio = l_u16MinCorrectionRatio;
    972a:	7ed8 0182 	lod	X, 0x182 <_l_u16MinCorrectionRatio>
    972e:	0002      	jmp	0x9734 <_PID_Control+0x8e>
			}
			else
			{
				u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9730:	7eda 08df 	lod	X, #2271
			}
			g_u16PID_I = 0u;
    9734:	7800      	lod	Y, #0
    9736:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    9738:	0019      	jmp	0x976c <_PID_Control+0xc6>
		}
		else
		{
			u16PidCtrlRatio = (uint16) ((int16)g_u16PID_I + i16PID_Ppart + g_i16PID_D);
    973a:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    973c:	a2ee      	add	A, X
    973e:	7ee2      	lod	X, A
    9740:	22d8 00e2 	add	X, 0xe2 <_g_i16PID_D>
			if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    9744:	6205      	lod	AL, [S-6]
    9746:	190d      	je	0x9762 <_PID_Control+0xbc>
			{
				if ( u16PidCtrlRatio < l_u16MinCorrectionRatio )
    9748:	7ad8 0182 	lod	Y, 0x182 <_l_u16MinCorrectionRatio>
    974c:	2ee6      	cmp	X, Y
    974e:	1c02      	jnc	0x9754 <_PID_Control+0xae>
				{
					/* Underflow */
					u16PidCtrlRatio = l_u16MinCorrectionRatio;
    9750:	7ee6      	lod	X, Y
    9752:	000c      	jmp	0x976c <_PID_Control+0xc6>
				}
				else if ( u16PidCtrlRatio >= l_u16MaxPidCtrlRatio )
    9754:	7ad8 017e 	lod	Y, 0x17e <_l_u16MaxPidCtrlRatio>
    9758:	2ee6      	cmp	X, Y
    975a:	1808      	jc	0x976c <_PID_Control+0xc6>
				{
					/* Overflow */
					u16PidCtrlRatio = l_u16MaxPidCtrlRatio;
    975c:	7ee6      	lod	X, Y
					g_u16PID_I = u16PidCtrlRatio;								/* MMP140617-1 */
    975e:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    9760:	0005      	jmp	0x976c <_PID_Control+0xc6>
				else
				{
				
				}
			}
			else if ( u16PidCtrlRatio < NVRAM_MIN_HOLDCORR_RATIO )
    9762:	2eda 08de 	cmp	X, #2270
    9766:	1e02      	jug	0x976c <_PID_Control+0xc6>
			{
				/* Underflow */
				u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9768:	7eda 08df 	lod	X, #2271
			else
			{
				
			}
		}
		g_u16PidCtrlRatio = u16PidCtrlRatio;
    976c:	5ed8 0176 	mov	0x176 <_g_u16PidCtrlRatio>, X
	}
	VoltageCorrection();
    9770:	1773      	call	0x9658 <_VoltageCorrection>
    9772:	5407      	ret	#8

00009774 <_ThresholdControl>:
 *	DC-Motor: Motor Power
 *	Stepper: Current Threshold Control
 *	BEMF: Nothing
 * ***/
void ThresholdControl( void)
{
    9774:	5805      	inc	S, #6
		uint16 u16CurrThrshldRatio;
		int16 i16TemperatureBgn = NVRAM_CURRTHRSHLD_TEMP_1;
    9776:	70de      	lod	A, #-34
    9778:	5203      	mov	[S-4], A


#if _SUPPORT_AMBIENT_TEMP
		if ( g_i16AmbjTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( g_i16ChipTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
    977a:	72d8 00b6 	lod	A, 0xb6 <__bss_size>
    977e:	acdc      	cmp	A, #-36
    9780:	1e84      	jsge	0x978a <_ThresholdControl+0x16>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( NVRAM_CURRTHRSHLD_ZONE_1 != 0u )
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;					/* Same as point _1 */
    9782:	7ada 0080 	lod	Y, #128
    9786:	5a05      	mov	[S-6], Y
    9788:	0019      	jmp	0x97bc <_ThresholdControl+0x48>
		}
		else
		{
			uint8 u8CurrThrshldCtrlType = (uint8)NVRAM_CURRTHRSHLD_ZONE_2;				/* Get current threshold compensation-type */
			uint16 u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_2;			/* Get zone end point (_2) */
			int16 i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_2;						
    978a:	7c08      	lod	X, #8
#if _SUPPORT_AMBIENT_TEMP
			if ( g_i16AmbjTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
			if ( g_i16ChipTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
    978c:	ac08      	cmp	A, #8
    978e:	1b0a      	jsle	0x97a4 <_ThresholdControl+0x30>
				u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_3;				/* Get zone end point (_3) */
				i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_3;
#if _SUPPORT_AMBIENT_TEMP
				if ( g_i16AmbjTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
				if ( g_i16ChipTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
    9790:	ac26      	cmp	A, #38
    9792:	1b05      	jsle	0x979e <_ThresholdControl+0x2a>
#endif /* _SUPPORT_AMBIENT_TEMP */
				{
					i16TemperatureBgn = i16TemperatureEnd;						/* Next zone; begin point (_3) */
    9794:	7826      	lod	Y, #38
    9796:	5a03      	mov	[S-4], Y
					u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
					u8CurrThrshldCtrlType = (uint8)NVRAM_CURRTHRSHLD_ZONE_4;
					u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_4;			/* Get zone end point (_3) */
					i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_4;
    9798:	7c3e      	lod	X, #62
#if _SUPPORT_AMBIENT_TEMP
					if ( g_i16AmbjTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
					if ( g_i16ChipTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
    979a:	ac3e      	cmp	A, #62
    979c:	1b03      	jsle	0x97a4 <_ThresholdControl+0x30>
					}
				}
			}
			if ( u8CurrThrshldCtrlType == 1u )
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;
    979e:	72da 0080 	lod	A, #128
    97a2:	000b      	jmp	0x97ba <_ThresholdControl+0x46>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioEnd;
			}
			else if ( u8CurrThrshldCtrlType == 3u )
			{
				i16TemperatureEnd = i16TemperatureEnd - i16TemperatureBgn;
    97a4:	2a03      	sub	X, [S-4]
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    97a6:	7000      	lod	A, #0
    97a8:	7ad8 00b6 	lod	Y, 0xb6 <__bss_size>
    97ac:	ea03      	sub	Y, [S-4]
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    97ae:	4831      	muls	YA, A, Y
    97b0:	4c73      	divs	YA, X
    97b2:	4c73      	divs	YA, X
    97b4:	4c7b      	dadjs	YA, X
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    97b6:	a2da 0080 	add	A, #128
    97ba:	5205      	mov	[S-6], A
			{
				u16CurrThrshldRatio = 0u;										/* Shutdown motor */
			}
		}
		{
			uint16 u16MCurrgain = EE_GMCURR;
    97bc:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    97c0:	b6da 00ff 	and	A, #255
    97c4:	7ee2      	lod	X, A
    97c6:	22da 0100 	add	X, #256
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    97ca:	72d8 017c 	lod	A, 0x17c <_g_u16PidHoldingThreshold>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    97ce:	7a05      	lod	Y, [S-6]
    97d0:	4821      	mulu	YA, A, Y
    97d2:	4c63      	divu	YA, X
    97d4:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    97d6:	52d8 0180 	mov	0x180 <_g_u16PidHoldingThresholdADC>, A
    97da:	72d8 0178 	lod	A, 0x178 <_g_u16PidRunningThreshold>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    97de:	7a05      	lod	Y, [S-6]
    97e0:	4821      	mulu	YA, A, Y
    97e2:	4c63      	divu	YA, X
    97e4:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    97e6:	52d8 017a 	mov	0x17a <_g_u16PidRunningThresholdADC>, A
    97ea:	5407      	ret	#8

000097ec <_Timer_Init>:
 * Timer_Init()
 *
 * Initialise the core timer (Mulan2-timer), at a periodic rate of 500us
 * ****************************************************************************	*/
void Timer_Init( void)
{
    97ec:	7ada 0186 	lod	Y, #390
    97f0:	7c09      	lod	X, #9
	uint16 i;
	for(i = 0; i < (uint16)MAX_TIMER; i++)
	{
		l_u16Timer[i] = 0;
    97f2:	7000      	lod	A, #0
    97f4:	52d6      	mov	[Y++], A
    97f6:	1bfd      	djnz	X, 0x97f2 <_Timer_Init+0x6>
	}
	/* System Tick Timer - Core Timer  */
	TIMER =  TMR_EN | CT_PERIODIC_RATE;											/* 500us timer */
    97f8:	72da 81f4 	lod	A, #33268
    97fc:	5286      	mov	io:0x6 <_LinMess2>, A
    97fe:	5401      	ret

00009800 <_Timer_Start>:
 * Timer_Start()
 *
 * Set the timer by timer period and timer id
 * ****************************************************************************	*/
void Timer_Start(TIMER_ID id,uint16 TimerPeriod)
{
    9800:	7e03      	lod	X, [S-4]
	if(id < MAX_TIMER)
    9802:	ac08      	cmp	A, #8
    9804:	1e05      	jug	0x9810 <_Timer_Start+0x10>
	{
		l_u16Timer[id] = TimerPeriod;
    9806:	4422      	asl	A
    9808:	7ae2      	lod	Y, A
    980a:	e2da 0186 	add	Y, #390
    980e:	5ef0      	mov	[Y], X
    9810:	5401      	ret

00009812 <_Timer_IsExpired>:
 *
 * Get the timer status by timer id
 * ****************************************************************************	*/
uint8 Timer_IsExpired(TIMER_ID id)
{
	if(l_u16Timer[id] == 0u)
    9812:	4422      	asl	A
    9814:	7ae2      	lod	Y, A
    9816:	e2da 0186 	add	Y, #390
    981a:	72f0      	lod	A, [Y]
    981c:	1d02      	jne	0x9822 <_Timer_IsExpired+0x10>
	{
		return TRUE;
    981e:	7001      	lod	A, #1
    9820:	5401      	ret
	}
	else
	{
		return FALSE;
    9822:	7000      	lod	A, #0
	}
}
    9824:	5401      	ret

00009826 <_Timer_SleepCompensation>:
 * Timer_SleepCompensation()
 *
 * Compensate the various timer-counters for the sleep-period
 * ****************************************************************************	*/
void Timer_SleepCompensation( uint16 u16SleepPeriod)
{
    9826:	5805      	inc	S, #6
    9828:	5201      	mov	[S-2], A
    982a:	7ada 0100 	lod	Y, #256
    982e:	7eda 36b0 	lod	X, #14000
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9832:	4821      	mulu	YA, A, Y
    9834:	4c63      	divu	YA, X
    9836:	4c63      	divu	YA, X
    9838:	5205      	mov	[S-6], A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    983a:	72e3      	lod	A, M
    983c:	5203      	mov	[S-4], A
	uint16 i;
	
	u16SleepPeriod = muldivU16_U16byU16byU16( u16SleepPeriod, 256U, (uint16)(CT_PERIODIC_RATE*(PLL_freq/1000000U)));
	ATOMIC_CODE
    983e:	4407      	mov	R, #0
    9840:	500c      	call	fp0:0x60
    9842:	54f0      	mov	UPr, #0
    9844:	7ada 0186 	lod	Y, #390
    9848:	7c09      	lod	X, #9
    984a:	72f0      	lod	A, [Y]
    984c:	ae05      	cmp	A, [S-6]
    984e:	1a02      	jule	0x9854 <_Timer_SleepCompensation+0x2e>
    9850:	aa05      	sub	A, [S-6]
    9852:	0001      	jmp	0x9856 <_Timer_SleepCompensation+0x30>
    9854:	7000      	lod	A, #0
    9856:	52f0      	mov	[Y], A
    9858:	e002      	add	Y, #2
    985a:	1bf7      	djnz	X, 0x984a <_Timer_SleepCompensation+0x24>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    985c:	7203      	lod	A, [S-4]
    985e:	52e3      	mov	M, A
    9860:	5407      	ret	#8

00009862 <_TIMER_IT>:
 * TIMER_IT()
 *
 * Periodic Timer ISR
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
    9862:	52df      	push	A
    9864:	5edf      	push	X
    9866:	5adf      	push	Y
    9868:	7ada 0186 	lod	Y, #390
    986c:	7c09      	lod	X, #9
	uint16 i;
	
	for(i = 0; i < (uint16)MAX_TIMER; i++)
	{	
		if(l_u16Timer[i] > 0u)
    986e:	72f0      	lod	A, [Y]
    9870:	1902      	je	0x9876 <_TIMER_IT+0x14>
		{
			l_u16Timer[i]--;
    9872:	a0ff      	add	A, #-1
    9874:	52f0      	mov	[Y], A
    9876:	e002      	add	Y, #2
    9878:	1bfa      	djnz	X, 0x986e <_TIMER_IT+0xc>
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
	uint16 i;
	
	for(i = 0; i < (uint16)MAX_TIMER; i++)
    987a:	7acf      	pop	Y
    987c:	7ecf      	pop	X
    987e:	72cf      	pop	A
    9880:	4407      	mov	R, #0
    9882:	72cb      	pop	M
    9884:	5401      	ret

00009886 <_SpiDebugWriteFirst>:
 *	Post:		Nothing
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
void SpiDebugWriteFirst( uint16 u16Data)
{
    9886:	5801      	inc	S, #2
    9888:	7ee2      	lod	X, A
	SPI1_PSCR |= SPI_FRSSOEN;													/* Toggle Slave-Select */
    988a:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    988e:	8408      	or	AL, #8
    9890:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_PSCR &= ~SPI_FRSSOEN;
    9894:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    9898:	94f7      	and	AL, #-9
    989a:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_DR = u16Data;															/* Send SPI-Data */
    989e:	5ed8 289e 	mov	0x289e <__io__+0x9e>, X
    98a2:	5403      	ret	#4

000098a4 <_SpiDebugInit>:
 *
 *	Comments:	Initialise SPI Interface.
 * ****************************************************************************	*/
void SpiDebugInit( void)
{
	SPI1_PCR  = SPI_CKEN;													/* Set the bit SPI_CKEN to 1 */
    98a4:	6001      	lod	AL, #1
    98a6:	42d8 289a 	mov	0x289a <__io__+0x9a>, AL
	SPI1_BRR  = (uint16)((PLL_freq / DEBUG_SPI_BAUDRATE) + 1u);						/* 100, 200, 400, 800 or 1000 kBaud */
    98aa:	701d      	lod	A, #29
    98ac:	52d8 289c 	mov	0x289c <__io__+0x9c>, A
	SPI1_CTRL = (SPI_FRSSOEN << 8u) | (SPI_MSTRONLY << 8u) | SPI_RFIE | SPI_TFIE | /* SPI_BYTEMOD | */ SPI_MSTR | SPI_EN | SPI_CKEN;	/* Mode 00 */
    98b0:	72da 0ad3 	lod	A, #2771
    98b4:	52d8 289a 	mov	0x289a <__io__+0x9a>, A

	SpiDebugWriteFirst( C_DBG_INIT);
    98b8:	72da a55a 	lod	A, #42330
    98bc:	17e4      	call	0x9886 <_SpiDebugWriteFirst>
    98be:	5401      	ret

000098c0 <_SpiDebugWriteNext>:
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
void SpiDebugWriteNext( uint16 u16Data)
{
	SPI1_DR = u16Data;															/* Send SPI-Data */
    98c0:	52d8 289e 	mov	0x289e <__io__+0x9e>, A
    98c4:	5401      	ret

000098c6 <_SBASE_INIT_4PH>:
    98c6:	0143 0053 0d63 0473 0d03 ffff               C.S.c.s.....

000098d2 <_SBASE_CURRENT>:
    98d2:	0d03 ffff                                   ....

000098d6 <_SBASE_MOTORVOLT>:
    98d6:	0403 ffff                                   ....

000098da <_SBASE_SUPPLYVOLT>:
    98da:	0003 ffff                                   ....

000098de <_SBASE_TEMP>:
    98de:	0103 ffff                                   ....

000098e2 <_SBASE_CURROFF>:
    98e2:	0d03 ffff                                   ....

000098e6 <_SBASE_VREF_OFF>:
    98e6:	0100 ffff                                   ....

000098ea <_c_ai16MicroStepVector4PH>:
    98ea:	0c8b 2528 3c56 5133 62f1 70e2 7a7d 7f62     ..(%V<3Q.b.p}zb.
    98fa:	7f62 7a7d 70e2 62f1 5133 3c56 2528 0c8b     b.}z.p.b3QV<(%..
    990a:	f375 dad8 c3aa aecd 9d0f 8f1e 8583 809e     u...............
    991a:	809e 8583 8f1e 9d0f aecd c3aa dad8 f375     ..............u.
    992a:	0c8b 2528 3c56 5133 62f1 70e2 7a7d 7f62     ..(%V<3Q.b.p}zb.

0000993a <_c_au8DrvCfgSelfTestB4>:
    993a:	c431 8421 4c13 4812 b5f5                    1.!..L.H..

00009944 <_c_au16DrvAdcSelfTestA>:
    9944:	0b03 ffff 0a03 ffff 0903 ffff 1903 ffff     ................

00009954 <_c_au8DrvCfgSelfTestA>:
    9954:	3020 0c08 0302 c080                          0......

0000995c <_PageIntegerityDefault>:
    995c:	0002 0000 0600 00b2 7fff ffff               ............
