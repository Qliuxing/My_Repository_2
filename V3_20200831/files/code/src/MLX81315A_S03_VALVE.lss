mlx16-gcc (GCC) 3.4.3 / Melexis Mlx16-GCC v1.12.3
Copyright (C) 2004 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.


MLX81315A_S03_VALVE.elf:     file format elf32-mlx16-x8

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .mlx4_flash   000014f0  00004000  00004000  00000254  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .mlx4_table   00000088  00005540  00005540  00001744  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .mlx16_vectors 00000098  0000bf68  0000bf68  00005d32  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .loader_flags 00000080  0000be80  0000be80  00005c90  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  4 .loader_rst_state 00000002  0000bf66  0000bf66  00005d30  2**1
                  CONTENTS, ALLOC, LOAD, DATA
  5 .system_services 00000006  0000bf60  0000bf60  00005d2a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .protection_key 00000008  0000bf46  0000bf46  00005d10  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .flash_crc    00000002  0000bf4e  0000bf4e  00005d18  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .product_no   00000008  0000bf50  0000bf50  00005d1a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .app_version  00000004  0000bf58  0000bf58  00005d22  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 10 .pltf_version 00000004  0000bf5c  0000bf5c  00005d26  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 11 .ramfunc      0000001e  00000740  000055c8  000017cc  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text         0000441a  000055e8  000055e8  000017ec  2**2
                  CONTENTS, ALLOC, LOAD, CODE
 13 .shared_ram   00000010  00000000  00000000  00005dca  2**0
                  CONTENTS, READONLY
 14 .ram_lin_fixed 00000006  00000010  00000010  00000254  2**1
                  ALLOC
 15 .dp.data      00000010  00000018  00009a02  00005c06  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 16 .dp           0000004a  00000028  00009a12  00005c16  2**1
                  ALLOC
 17 .data         0000007a  00000072  00009a12  00005c16  2**1
                  CONTENTS, ALLOC, LOAD, DATA
 18 .bss          000000ba  000000ec  00009a8c  00005c90  2**1
                  ALLOC
 19 .bist_stat    00000008  000001a6  00009a8c  00005c90  2**1
                  ALLOC
 20 .debug_abbrev 0000275e  00000000  00000000  00005dda  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   0000872f  00000000  00000000  00008538  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_line   000074ea  00000000  00000000  00010c67  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_frame  00001730  00000000  00000000  00018152  2**1
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_pubnames 00001d60  00000000  00000000  00019882  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_aranges 00000500  00000000  00000000  0001b5e2  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_str    00003341  00000000  00000000  0001bae2  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .comment      00000011  00000000  00000000  0001ee23  2**0
                  CONTENTS, READONLY

Disassembly of section .mlx4_flash:

00004000 <__mlx4_flash_start>:
    4000:	a55a      	or	A, dp:0x5a <_LIN_nad>
    4002:	5aa5      	mov	io:0x25 <_l_u8StallCountO>, Y
    4004:	0000      	nop
    4006:	0000      	nop
    4008:	2442      	or	X, #66
    400a:	2442      	or	X, #66
    400c:	243f      	or	X, #63
    400e:	243f      	or	X, #63
    4010:	0000      	nop
    4012:	0000      	nop
    4014:	0000      	nop
    4016:	0000      	nop
    4018:	4100      	mov	dp:0x0 <__dp__>, AL
    401a:	2000      	add	X, #0
    401c:	0000      	nop
    401e:	0000      	nop
    4020:	01e0      	jmp	0x43e2 <__mlx4_flash_start+0x3e2>
    4022:	0003      	jmp	0x402a <__mlx4_flash_start+0x2a>
    4024:	0005      	jmp	0x4030 <__mlx4_flash_start+0x30>
    4026:	0000      	nop
    4028:	4233      	mov	[S-52], AL
    402a:	5f50      	mov	ep:0x50 <_g_u16PID_I>, X
    402c:	7c6d      	lod	X, #109
    402e:	998a      	subc	AL, dp:0x8a <_l_u8OBDValveStatusFault>
    4030:	140e      	call	0x384e <__io__+0x104e>
    4032:	201a      	add	X, #26
    4034:	2c26      	cmp	X, #38
    4036:	3832      	subc	X, #50
    4038:	0208      	jmp	0x444a <__mlx4_flash_start+0x44a>
    403a:	af52      	cmp	A, ep:0x52 <_LinFrameDataBuffer>
    403c:	6f03      	lod	YH, ep:0x3 <_LinCmnd+0x1>
    403e:	ff35      	xor	Y, ep:0x35 <_g_DiagResponse+0x5>
    4040:	e0e0      	add	Y, #-32
    4042:	dba6      	subc	AH, ep:0xa6 <_l_u8RamPreError+0x2>
    4044:	0000      	nop
    4046:	0200      	jmp	0x4448 <__mlx4_flash_start+0x448>
    4048:	7da0      	lod	X, dp:0xa0 <_l_u8OBDValveMechanicalError>
    404a:	d70a      	and	AH, ep:0xa <__bist_stat_size+0x2>
    404c:	39e4      	subc	X, dp:0xe4 <_g_i16PID_E>
    404e:	934e      	adc	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4050:	d3e0      	adc	AH, ep:0xe0 <_l_u16MotorRefVoltageADC>
    4052:	a497      	or	A, #-105
    4054:	2c1f      	cmp	X, #31
    4056:	5b68      	mov	ep:0x68 <_ml_driver_mode+0xa>, Y
    4058:	a81f      	sub	A, #31
    405a:	b47f      	and	A, #127
    405c:	00b2      	jmp	0x41c2 <__mlx4_flash_start+0x1c2>
    405e:	7c50      	lod	X, #80
    4060:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4062:	773a      	lod	PC, ep:0x3a <_g_u16MicroStepIdx>
    4064:	b78e      	and	A, ep:0x8e <_s_CVRequestStruct>
    4066:	773b      	lod	PC, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4068:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    406a:	34e9      	and	X, #-23
    406c:	b781      	and	A, ep:0x81 <__data_size+0x7>
    406e:	b76f      	and	A, ep:0x6f <_ml_driver_mode+0x11>
    4070:	773f      	lod	PC, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    4072:	4c02 b203 	add	D, #-1291603453
    4076:	b303 
    4078:	8684      	or	AL, io:0x4 <_LinMess>
    407a:	7203      	lod	A, [S-4]
    407c:	4c03      	add	D, ??
    407e:	7303      	lod	A, ep:0x3 <_LinCmnd+0x1>
    4080:	380e      	subc	X, #14
    4082:	3907      	subc	X, dp:0x7 <_LinProtectedID>
    4084:	320a      	adc	X, [S-11]
    4086:	340a      	and	X, #10
    4088:	3eac      	xor	X, io:0x2c <__data_dp_end+0x4>
    408a:	3b16      	subc	X, ep:0x16 <__data_dp_size+0x6>
    408c:	3730      	and	X, ep:0x30 <_g_DiagResponse>
    408e:	6193      	lod	AL, dp:0x93 <_s_CVRequestStruct+0x5>
    4090:	b680      	and	A, io:0x0 <__dp__>
    4092:	7273      	lod	A, [S-116]
    4094:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4096:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4098:	7239      	lod	A, [S-58]
    409a:	726f      	lod	A, [S-112]
    409c:	b582      	and	A, dp:0x82 <_targetPos>
    409e:	714c      	lod	A, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    40a0:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    40a2:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    40a4:	0000      	nop
    40a6:	0000      	nop
    40a8:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    40aa:	320a      	adc	X, [S-11]
    40ac:	580a      	inc	S, #11
    40ae:	0901      	clrb	io:0x00.1
    40b0:	2080      	add	X, #-128
    40b2:	623a      	lod	AL, [S-59]
    40b4:	7270      	lod	A, [S-113]
    40b6:	b637      	and	A, [S-56]
    40b8:	b373      	adc	A, ep:0x73 <__bss_dp_end+0x1>
    40ba:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    40bc:	e783      	or	Y, ep:0x83 <_targetPos+0x1>
    40be:	1101      	call	0x42c2 <__mlx4_flash_start+0x2c2>
    40c0:	20b7      	add	X, #-73
    40c2:	6c03      	lod	YH, #3
    40c4:	206e      	add	X, #110
    40c6:	2066      	add	X, #102
    40c8:	2073      	add	X, #115
    40ca:	2050      	add	X, #80
    40cc:	e680      	or	Y, io:0x0 <__dp__>
    40ce:	1102      	call	0x42d4 <__mlx4_flash_start+0x2d4>
    40d0:	b782      	and	A, ep:0x82 <_targetPos>
    40d2:	207a      	add	X, #122
    40d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    40d6:	110b      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40d8:	b781      	and	A, ep:0x81 <__data_size+0x7>
    40da:	207a      	add	X, #122
    40dc:	b270      	adc	A, [S-113]
    40de:	a688      	or	A, io:0x8 <__bist_stat_size>
    40e0:	1106      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40e2:	b781      	and	A, ep:0x81 <__data_size+0x7>
    40e4:	207a      	add	X, #122
    40e6:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    40e8:	e68c      	or	Y, io:0xc <__bist_stat_size+0x4>
    40ea:	1101      	call	0x42ee <__mlx4_flash_start+0x2ee>
    40ec:	207c      	add	X, #124
    40ee:	b780      	and	A, ep:0x80 <__data_size+0x6>
    40f0:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40f2:	2050      	add	X, #80
    40f4:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40f6:	2056      	add	X, #86
    40f8:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    40fa:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    40fc:	3cc3      	xor	X, #-61
    40fe:	2050      	add	X, #80
    4100:	b384      	adc	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4102:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    4104:	7380      	lod	A, ep:0x80 <__data_size+0x6>
    4106:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    4108:	7235      	lod	A, [S-54]
    410a:	7ca7      	lod	X, #-89
    410c:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    410e:	6c03      	lod	YH, #3
    4110:	20b1      	add	X, #-79
    4112:	20ad      	add	X, #-83
    4114:	20b3      	add	X, #-77
    4116:	20b3      	add	X, #-77
    4118:	20b3      	add	X, #-77
    411a:	20a1      	add	X, #-95
    411c:	20b3      	add	X, #-77
    411e:	20b3      	add	X, #-77
    4120:	20b3      	add	X, #-77
    4122:	20b3      	add	X, #-77
    4124:	20b3      	add	X, #-77
    4126:	20b3      	add	X, #-77
    4128:	20b3      	add	X, #-77
    412a:	20b3      	add	X, #-77
    412c:	20b3      	add	X, #-77
    412e:	2098      	add	X, #-104
    4130:	a682      	or	A, io:0x2 <_LinCmnd>
    4132:	1106      	call	0x4340 <__mlx4_flash_start+0x340>
    4134:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    4136:	bf8e      	xor	A, ep:0x8e <_s_CVRequestStruct>
    4138:	a681      	or	A, io:0x1 <__dp__+0x1>
    413a:	0101      	jmp	0x433e <__mlx4_flash_start+0x33e>
    413c:	f781      	and	Y, ep:0x81 <__data_size+0x7>
    413e:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4140:	20b1      	add	X, #-79
    4142:	e682      	or	Y, io:0x2 <_LinCmnd>
    4144:	110d      	call	0x4360 <__mlx4_flash_start+0x360>
    4146:	b286      	adc	A, io:0x6 <_LinMess2>
    4148:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    414a:	f782      	and	Y, ep:0x82 <_targetPos>
    414c:	e681      	or	Y, io:0x1 <__dp__+0x1>
    414e:	0103      	jmp	0x4356 <__mlx4_flash_start+0x356>
    4150:	bf8d      	xor	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4152:	b680      	and	A, io:0x0 <__dp__>
    4154:	7273      	lod	A, [S-116]
    4156:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4158:	20b1      	add	X, #-79
    415a:	e681      	or	Y, io:0x1 <__dp__+0x1>
    415c:	1101      	call	0x4360 <__mlx4_flash_start+0x360>
    415e:	245d      	or	X, #93
    4160:	20b3      	add	X, #-77
    4162:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4164:	20b4      	add	X, #-76
    4166:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4168:	7381      	lod	A, ep:0x81 <__data_size+0x7>
    416a:	5404      	ret	#5
    416c:	2056      	add	X, #86
    416e:	a681      	or	A, io:0x1 <__dp__+0x1>
    4170:	1104      	call	0x437a <__mlx4_flash_start+0x37a>
    4172:	b270      	adc	A, [S-113]
    4174:	a688      	or	A, io:0x8 <__bist_stat_size>
    4176:	1105      	call	0x4382 <__mlx4_flash_start+0x382>
    4178:	2048      	add	X, #72
    417a:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    417c:	622e      	lod	AL, [S-47]
    417e:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4180:	0101      	jmp	0x4384 <__mlx4_flash_start+0x384>
    4182:	2056      	add	X, #86
    4184:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4186:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    4188:	1101      	call	0x438c <__mlx4_flash_start+0x38c>
    418a:	20e4      	add	X, #-28
    418c:	4592      	mov	dp:0x92 <_s_CVRequestStruct+0x4>, YL
    418e:	76e5      	jmp	MH
    4190:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4192:	77e5      	lod	PC, ep:0xe5 <_g_i16PID_E+0x1>
    4194:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4196:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4198:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    419a:	6198      	lod	AL, dp:0x98 <_l_u8EndstopCheckLock>
    419c:	e581      	or	Y, dp:0x81 <__data_size+0x7>
    419e:	110b      	call	0x43b6 <__mlx4_flash_start+0x3b6>
    41a0:	7cd5      	lod	X, #-43
    41a2:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    41a4:	b208      	adc	A, [S-9]
    41a6:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    41a8:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    41aa:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    41ac:	1105      	call	0x43b8 <__mlx4_flash_start+0x3b8>
    41ae:	bf8c      	xor	A, ep:0x8c <_l_u8AliveRollingCounter>
    41b0:	f373      	adc	Y, ep:0x73 <__bss_dp_end+0x1>
    41b2:	7373      	lod	A, ep:0x73 <__bss_dp_end+0x1>
    41b4:	724c      	lod	A, [S-77]
    41b6:	2050      	add	X, #80
    41b8:	7271      	lod	A, [S-114]
    41ba:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    41bc:	e781      	or	Y, ep:0x81 <__data_size+0x7>
    41be:	0102      	jmp	0x43c4 <__mlx4_flash_start+0x3c4>
    41c0:	b687      	and	A, io:0x7 <_LinProtectedID>
    41c2:	20da      	add	X, #-38
    41c4:	b686      	and	A, io:0x6 <_LinMess2>
    41c6:	20da      	add	X, #-38
    41c8:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    41ca:	300a      	adc	X, #10
    41cc:	6198      	lod	AL, dp:0x98 <_l_u8EndstopCheckLock>
    41ce:	ef80      	cmp	Y, ep:0x80 <__data_size+0x6>
    41d0:	0103      	jmp	0x43d8 <__mlx4_flash_start+0x3d8>
    41d2:	b684      	and	A, io:0x4 <_LinMess>
    41d4:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    41d6:	2030      	add	X, #48
    41d8:	b24e      	adc	A, [S-79]
    41da:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    41dc:	724e      	lod	A, [S-79]
    41de:	6c02      	lod	YH, #2
    41e0:	2108      	add	X, dp:0x8 <__bist_stat_size>
    41e2:	20f4      	add	X, #-12
    41e4:	2102      	add	X, dp:0x2 <_LinCmnd>
    41e6:	2100      	add	X, dp:0x0 <__dp__>
    41e8:	b78b      	and	A, ep:0x8b <_l_u8ValueFaultFlag>
    41ea:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    41ec:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    41ee:	61ae      	lod	AL, dp:0xae <_l_u8LinInFrameBufState>
    41f0:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    41f2:	61b7      	lod	AL, dp:0xb7 <_g_i16SupplyVoltage+0x1>
    41f4:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    41f6:	b582      	and	A, dp:0x82 <_targetPos>
    41f8:	b681      	and	A, io:0x1 <__dp__+0x1>
    41fa:	61ae      	lod	AL, dp:0xae <_l_u8LinInFrameBufState>
    41fc:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    41fe:	2110      	add	X, dp:0x10 <__data_dp_size>
    4200:	b682      	and	A, io:0x2 <_LinCmnd>
    4202:	724e      	lod	A, [S-79]
    4204:	b78d      	and	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4206:	b582      	and	A, dp:0x82 <_targetPos>
    4208:	b681      	and	A, io:0x1 <__dp__+0x1>
    420a:	61ae      	lod	AL, dp:0xae <_l_u8LinInFrameBufState>
    420c:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    420e:	2110      	add	X, dp:0x10 <__data_dp_size>
    4210:	b24c      	adc	A, [S-77]
    4212:	7271      	lod	A, [S-114]
    4214:	b78b      	and	A, ep:0x8b <_l_u8ValueFaultFlag>
    4216:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4218:	b681      	and	A, io:0x1 <__dp__+0x1>
    421a:	61ae      	lod	AL, dp:0xae <_l_u8LinInFrameBufState>
    421c:	b785      	and	A, ep:0x85 <_l_u8OBDValveStatusMove>
    421e:	61b7      	lod	AL, dp:0xb7 <_g_i16SupplyVoltage+0x1>
    4220:	b24e      	adc	A, [S-79]
    4222:	b171      	adc	A, dp:0x71 <_ml_driver_mode+0x13>
    4224:	61bb      	lod	AL, dp:0xbb <__bss_size+0x1>
    4226:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4228:	b56d      	and	A, dp:0x6d <_ml_driver_mode+0xf>
    422a:	b685      	and	A, io:0x5 <_LinMess+0x1>
    422c:	b66e      	and	A, [S-111]
    422e:	61bb      	lod	AL, dp:0xbb <__bss_size+0x1>
    4230:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4232:	b680      	and	A, io:0x0 <__dp__>
    4234:	738b      	lod	A, ep:0x8b <_l_u8ValueFaultFlag>
    4236:	728a      	lod	A, io:0xa <__bist_stat_size+0x2>
    4238:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    423a:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    423c:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    423e:	5408      	ret	#9
    4240:	b273      	adc	A, [S-116]
    4242:	a688      	or	A, io:0x8 <__bist_stat_size>
    4244:	1109      	call	0x4458 <__mlx4_flash_start+0x458>
    4246:	b24e      	adc	A, [S-79]
    4248:	e681      	or	Y, io:0x1 <__dp__+0x1>
    424a:	0103      	jmp	0x4452 <__mlx4_flash_start+0x452>
    424c:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    424e:	a582      	or	A, dp:0x82 <_targetPos>
    4250:	0102      	jmp	0x4456 <__mlx4_flash_start+0x456>
    4252:	b680      	and	A, io:0x0 <__dp__>
    4254:	204a      	add	X, #74
    4256:	2048      	add	X, #72
    4258:	3806      	subc	X, #6
    425a:	380e      	subc	X, #14
    425c:	580c      	inc	S, #13
    425e:	0807      	clrb	dp:0x00.7
    4260:	62e6      	lod	AL, Y
    4262:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4264:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4266:	1108      	call	0x4478 <__mlx4_flash_start+0x478>
    4268:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    426a:	1105      	call	0x4476 <__mlx4_flash_start+0x476>
    426c:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    426e:	623a      	lod	AL, [S-59]
    4270:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4272:	1101      	call	0x4476 <__mlx4_flash_start+0x476>
    4274:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    4276:	2030      	add	X, #48
    4278:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    427a:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    427c:	b582      	and	A, dp:0x82 <_targetPos>
    427e:	6223      	lod	AL, [S-36]
    4280:	6198      	lod	AL, dp:0x98 <_l_u8EndstopCheckLock>
    4282:	b208      	adc	A, [S-9]
    4284:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    4286:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4288:	6c03      	lod	YH, #3
    428a:	2155      	add	X, dp:0x55 <_LinFrameDataBuffer+0x3>
    428c:	214a      	add	X, dp:0x4a <__bss_dp_size>
    428e:	b688      	and	A, io:0x8 <__bist_stat_size>
    4290:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4292:	215a      	add	X, dp:0x5a <_LIN_nad>
    4294:	b586      	and	A, dp:0x86 <_l_u16OBDValveStatusPosition>
    4296:	61a8      	lod	AL, dp:0xa8 <_l_u8RamPreError+0x4>
    4298:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    429a:	b6e5      	and	A, MH
    429c:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    429e:	b7e5      	and	A, ep:0xe5 <_g_i16PID_E+0x1>
    42a0:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    42a2:	76e5      	jmp	MH
    42a4:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    42a6:	77e5      	lod	PC, ep:0xe5 <_g_i16PID_E+0x1>
    42a8:	b686      	and	A, io:0x6 <_LinMess2>
    42aa:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    42ac:	61a8      	lod	AL, dp:0xa8 <_l_u8RamPreError+0x4>
    42ae:	8682      	or	AL, io:0x2 <_LinCmnd>
    42b0:	b582      	and	A, dp:0x82 <_targetPos>
    42b2:	3e10      	xor	X, [S-17]
    42b4:	724c      	lod	A, [S-77]
    42b6:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    42b8:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    42ba:	34c0      	and	X, #-64
    42bc:	623a      	lod	AL, [S-59]
    42be:	38b7      	subc	X, #-73
    42c0:	357b      	and	X, dp:0x7b <__data_size+0x1>
    42c2:	3663      	and	X, [S-100]
    42c4:	7cd3      	lod	X, #-45
    42c6:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    42c8:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    42ca:	b580      	and	A, dp:0x80 <__data_size+0x6>
    42cc:	330a      	adc	X, ep:0xa <__bist_stat_size+0x2>
    42ce:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    42d0:	b208      	adc	A, [S-9]
    42d2:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    42d4:	4616      	mov	[S-23], YL
    42d6:	3561      	and	X, dp:0x61 <_ml_driver_mode+0x3>
    42d8:	7208      	lod	A, [S-9]
    42da:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    42dc:	a581      	or	A, dp:0x81 <__data_size+0x7>
    42de:	0103      	jmp	0x44e6 <__mlx4_flash_start+0x4e6>
    42e0:	b272      	adc	A, [S-115]
    42e2:	a688      	or	A, io:0x8 <__bist_stat_size>
    42e4:	010a      	jmp	0x44fa <__mlx4_flash_start+0x4fa>
    42e6:	4500      	mov	dp:0x0 <__dp__>, YL
    42e8:	4584      	mov	dp:0x84 <_l_u8OBDValveStatusSpeedLevel>, YL
    42ea:	8582      	or	AL, dp:0x82 <_targetPos>
    42ec:	5802      	inc	S, #3
    42ee:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    42f0:	b638      	and	A, [S-57]
    42f2:	7272      	lod	A, [S-115]
    42f4:	b737      	and	A, ep:0x37 <_g_DiagResponse+0x7>
    42f6:	0004      	jmp	0x4300 <__mlx4_flash_start+0x300>
    42f8:	2167      	add	X, dp:0x67 <_ml_driver_mode+0x9>
    42fa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    42fc:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    42fe:	2047      	add	X, #71
    4300:	6217      	lod	AL, [S-24]
    4302:	0007      	jmp	0x4312 <__mlx4_flash_start+0x312>
    4304:	1102      	call	0x450a <__mlx4_flash_start+0x50a>
    4306:	7308      	lod	A, ep:0x8 <__bist_stat_size>
    4308:	7209      	lod	A, [S-10]
    430a:	b208      	adc	A, [S-9]
    430c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    430e:	6198      	lod	AL, dp:0x98 <_l_u8EndstopCheckLock>
    4310:	2165      	add	X, dp:0x65 <_ml_driver_mode+0x7>
    4312:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    4314:	bd83      	xor	A, dp:0x83 <_targetPos+0x1>
    4316:	716f      	lod	A, dp:0x6f <_ml_driver_mode+0x11>
    4318:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    431a:	a582      	or	A, dp:0x82 <_targetPos>
    431c:	1101      	call	0x4520 <__mlx4_flash_start+0x520>
    431e:	2030      	add	X, #48
    4320:	b785      	and	A, ep:0x85 <_l_u8OBDValveStatusMove>
    4322:	62d2      	lod	AL, [A++]
    4324:	212e      	add	X, dp:0x2e <__data_dp_end+0x6>
    4326:	38b7      	subc	X, #-73
    4328:	3e18      	xor	X, [S-25]
    432a:	357b      	and	X, dp:0x7b <__data_size+0x1>
    432c:	367b      	and	X, [S-124]
    432e:	6800      	lod	AH, #0
    4330:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    4332:	b792      	and	A, ep:0x92 <_s_CVRequestStruct+0x4>
    4334:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4336:	b20a      	adc	A, [S-11]
    4338:	d667      	and	AH, [S-104]
    433a:	720b      	lod	A, [S-12]
    433c:	b76b      	and	A, ep:0x6b <_ml_driver_mode+0xd>
    433e:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    4340:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    4342:	d30b      	adc	AH, ep:0xb <__bist_stat_size+0x3>
    4344:	b20a      	adc	A, [S-11]
    4346:	d667      	and	AH, [S-104]
    4348:	720b      	lod	A, [S-12]
    434a:	b76b      	and	A, ep:0x6b <_ml_driver_mode+0xd>
    434c:	730a      	lod	A, ep:0xa <__bist_stat_size+0x2>
    434e:	6800      	lod	AH, #0
    4350:	b7e5      	and	A, ep:0xe5 <_g_i16PID_E+0x1>
    4352:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4354:	e78f      	or	Y, ep:0x8f <_s_CVRequestStruct+0x1>
    4356:	b7e5      	and	A, ep:0xe5 <_g_i16PID_E+0x1>
    4358:	ef87      	cmp	Y, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    435a:	6800      	lod	AH, #0
    435c:	7270      	lod	A, [S-113]
    435e:	b6e7      	and	A, R
    4360:	8791      	or	AL, ep:0x91 <_s_CVRequestStruct+0x3>
    4362:	76e7      	jmp	R
    4364:	c791      	or	AH, ep:0x91 <_s_CVRequestStruct+0x3>
    4366:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    4368:	e370      	add	Y, ep:0x70 <_ml_driver_mode+0x12>
    436a:	0109      	jmp	0x457e <__mlx4_flash_start+0x57e>
    436c:	21af      	add	X, dp:0xaf <_l_u8SNPD_CycleCountComm>
    436e:	b587      	and	A, dp:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4370:	b66d      	and	A, [S-110]
    4372:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4374:	b56d      	and	A, dp:0x6d <_ml_driver_mode+0xf>
    4376:	76e7      	jmp	R
    4378:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    437a:	75e7      	lod	PC, dp:0xe7 <_g_i16PID_D+0x1>
    437c:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    437e:	6800      	lod	AH, #0
    4380:	b140      	adc	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4382:	814e      	add	AL, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4384:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4386:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4388:	894f      	sub	AL, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    438a:	7141      	lod	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    438c:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    438e:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    4390:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4392:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4394:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    4396:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4398:	b144      	adc	A, dp:0x44 <_g_e8MotorDirectionCCW>
    439a:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    439c:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    439e:	6800      	lod	AH, #0
    43a0:	b154      	adc	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    43a2:	814e      	add	AL, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    43a4:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    43a6:	b155      	adc	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    43a8:	894f      	sub	AL, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    43aa:	7155      	lod	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    43ac:	b156      	adc	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43ae:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    43b0:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43b2:	b157      	adc	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43b4:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    43b6:	7157      	lod	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43b8:	6800      	lod	AH, #0
    43ba:	b34e      	adc	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    43bc:	b24f      	adc	A, [S-80]
    43be:	b15a      	adc	A, dp:0x5a <_LIN_nad>
    43c0:	e349      	add	Y, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    43c2:	ea4a      	sub	Y, [S-75]
    43c4:	e94b      	sub	Y, dp:0x4b <__bss_dp_size+0x1>
    43c6:	1003      	call	0x43ce <__mlx4_flash_start+0x3ce>
    43c8:	7349      	lod	A, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    43ca:	724a      	lod	A, [S-75]
    43cc:	714b      	lod	A, dp:0x4b <__bss_dp_size+0x1>
    43ce:	e346      	add	Y, ep:0x46 <_g_u16ActuatorActPos>
    43d0:	ea47      	sub	Y, [S-72]
    43d2:	e948      	sub	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    43d4:	0003      	jmp	0x43dc <__mlx4_flash_start+0x3dc>
    43d6:	7346      	lod	A, ep:0x46 <_g_u16ActuatorActPos>
    43d8:	7247      	lod	A, [S-72]
    43da:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    43dc:	e684      	or	Y, io:0x4 <_LinMess>
    43de:	ed80      	cmp	Y, dp:0x80 <__data_size+0x6>
    43e0:	0009      	jmp	0x43f4 <__mlx4_flash_start+0x3f4>
    43e2:	8350      	add	AL, ep:0x50 <_g_u16PID_I>
    43e4:	8a51      	sub	AL, [S-82]
    43e6:	8952      	sub	AL, dp:0x52 <_LinFrameDataBuffer>
    43e8:	7350      	lod	A, ep:0x50 <_g_u16PID_I>
    43ea:	7251      	lod	A, [S-82]
    43ec:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    43ee:	b353      	adc	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    43f0:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    43f2:	7353      	lod	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    43f4:	6800      	lod	AH, #0
    43f6:	b157      	adc	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43f8:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    43fa:	7157      	lod	A, dp:0x57 <_LinFrameDataBuffer+0x5>
    43fc:	b156      	adc	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    43fe:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4400:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4402:	b155      	adc	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    4404:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4406:	7155      	lod	A, dp:0x55 <_LinFrameDataBuffer+0x3>
    4408:	b154      	adc	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    440a:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    440c:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    440e:	b144      	adc	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4410:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4412:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4414:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4416:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4418:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    441a:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    441c:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    441e:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4420:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4422:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4424:	7141      	lod	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4426:	b140      	adc	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4428:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    442a:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    442c:	6800      	lod	AH, #0
    442e:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4430:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4432:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4434:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    4436:	0006      	jmp	0x4444 <__mlx4_flash_start+0x444>
    4438:	0102      	jmp	0x463e <__mlx4_flash_start+0x63e>
    443a:	4050      	jmp	fp2:0x80
    443c:	222a      	add	X, [S-43]
    443e:	b20a      	adc	A, [S-11]
    4440:	b30b      	adc	A, ep:0xb <__bist_stat_size+0x3>
    4442:	2226      	add	X, [S-39]
    4444:	4592      	mov	dp:0x92 <_s_CVRequestStruct+0x4>, YL
    4446:	b6e5      	and	A, MH
    4448:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    444a:	b7e5      	and	A, ep:0xe5 <_g_i16PID_E+0x1>
    444c:	7234      	lod	A, [S-53]
    444e:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    4450:	7208      	lod	A, [S-9]
    4452:	7309      	lod	A, ep:0x9 <__bist_stat_size+0x1>
    4454:	6800      	lod	AH, #0
    4456:	3e60      	xor	X, [S-97]
    4458:	3e90      	xor	X, io:0x10 <__data_dp_size>
    445a:	6800      	lod	AH, #0
    445c:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    445e:	b208      	adc	A, [S-9]
    4460:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4462:	4616      	mov	[S-23], YL
    4464:	2228      	add	X, [S-41]
    4466:	820a      	add	AL, [S-11]
    4468:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    446a:	8e80      	cmp	AL, io:0x0 <__dp__>
    446c:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    446e:	720a      	lod	A, [S-11]
    4470:	730b      	lod	A, ep:0xb <__bist_stat_size+0x3>
    4472:	6800      	lod	AH, #0
    4474:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4476:	b638      	and	A, [S-57]
    4478:	6800      	lod	AH, #0
    447a:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    447c:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    447e:	753e      	lod	PC, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4480:	6800      	lod	AH, #0
    4482:	b330      	adc	A, ep:0x30 <_g_DiagResponse>
    4484:	b231      	adc	A, [S-50]
    4486:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4488:	8e80      	cmp	AL, io:0x0 <__dp__>
    448a:	7330      	lod	A, ep:0x30 <_g_DiagResponse>
    448c:	7231      	lod	A, [S-50]
    448e:	e336      	add	Y, ep:0x36 <_g_DiagResponse+0x6>
    4490:	ea37      	sub	Y, [S-56]
    4492:	6800      	lod	AH, #0
    4494:	0009      	jmp	0x44a8 <__mlx4_flash_start+0x4a8>
    4496:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4498:	8302      	add	AL, ep:0x2 <_LinCmnd>
    449a:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    449c:	b341      	adc	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    449e:	8b03      	sub	AL, ep:0x3 <_LinCmnd+0x1>
    44a0:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    44a2:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    44a4:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    44a6:	2257      	add	X, [S-88]
    44a8:	b780      	and	A, ep:0x80 <__data_size+0x6>
    44aa:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    44ac:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    44ae:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    44b0:	6800      	lod	AH, #0
    44b2:	b354      	adc	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44b4:	b255      	adc	A, [S-86]
    44b6:	8302      	add	AL, ep:0x2 <_LinCmnd>
    44b8:	8a03      	sub	AL, [S-4]
    44ba:	7354      	lod	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44bc:	7255      	lod	A, [S-86]
    44be:	b356      	adc	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44c0:	b257      	adc	A, [S-88]
    44c2:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    44c4:	8e80      	cmp	AL, io:0x0 <__dp__>
    44c6:	7356      	lod	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44c8:	7257      	lod	A, [S-88]
    44ca:	6800      	lod	AH, #0
    44cc:	b354      	adc	A, ep:0x54 <_LinFrameDataBuffer+0x2>
    44ce:	b255      	adc	A, [S-86]
    44d0:	e330      	add	Y, ep:0x30 <_g_DiagResponse>
    44d2:	ea31      	sub	Y, [S-50]
    44d4:	b356      	adc	A, ep:0x56 <_LinFrameDataBuffer+0x4>
    44d6:	b257      	adc	A, [S-88]
    44d8:	eb32      	sub	Y, ep:0x32 <_g_DiagResponse+0x2>
    44da:	ea33      	sub	Y, [S-52]
    44dc:	6800      	lod	AH, #0
    44de:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    44e0:	bf8f      	xor	A, ep:0x8f <_s_CVRequestStruct+0x1>
    44e2:	4040      	jmp	fp2:0x00
    44e4:	0108      	jmp	0x46f6 <__mlx4_flash_start+0x6f6>
    44e6:	3cc3      	xor	X, #-61
    44e8:	b782      	and	A, ep:0x82 <_targetPos>
    44ea:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    44ec:	833c      	add	AL, ep:0x3c <_g_u16CommutTimerPeriod>
    44ee:	733c      	lod	A, ep:0x3c <_g_u16CommutTimerPeriod>
    44f0:	b33d      	adc	A, ep:0x3d <_g_u16CommutTimerPeriod+0x1>
    44f2:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    44f4:	733d      	lod	A, ep:0x3d <_g_u16CommutTimerPeriod+0x1>
    44f6:	6800      	lod	AH, #0
    44f8:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    44fa:	a78f      	or	A, ep:0x8f <_s_CVRequestStruct+0x1>
    44fc:	0101      	jmp	0x4700 <__mlx4_flash_start+0x700>
    44fe:	3cc3      	xor	X, #-61
    4500:	6800      	lod	AH, #0
    4502:	2939      	sub	X, dp:0x39 <_g_u16CorrectionRatio+0x1>
    4504:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4506:	493c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, AH
    4508:	b681      	and	A, io:0x1 <__dp__+0x1>
    450a:	b75e      	and	A, ep:0x5e <_ml_driver_mode>
    450c:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    450e:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    4510:	b680      	and	A, io:0x0 <__dp__>
    4512:	b75e      	and	A, ep:0x5e <_ml_driver_mode>
    4514:	b682      	and	A, io:0x2 <_LinCmnd>
    4516:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    4518:	3b33      	subc	X, ep:0x33 <_g_DiagResponse+0x3>
    451a:	6800      	lod	AH, #0
    451c:	3b12      	subc	X, ep:0x12 <__data_dp_size+0x2>
    451e:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    4520:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4522:	b682      	and	A, io:0x2 <_LinCmnd>
    4524:	bfbc      	xor	A, ep:0xbc <_l_u8AdcPowerOff>
    4526:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    4528:	6800      	lod	AH, #0
    452a:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    452c:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    452e:	1106      	call	0x473c <__mlx4_flash_start+0x73c>
    4530:	e781      	or	Y, ep:0x81 <__data_size+0x7>
    4532:	1108      	call	0x4744 <__mlx4_flash_start+0x744>
    4534:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4536:	7381      	lod	A, ep:0x81 <__data_size+0x7>
    4538:	5404      	ret	#5
    453a:	202f      	add	X, #47
    453c:	e78e      	or	Y, ep:0x8e <_s_CVRequestStruct>
    453e:	0102      	jmp	0x4744 <__mlx4_flash_start+0x744>
    4540:	a752      	or	A, ep:0x52 <_LinFrameDataBuffer>
    4542:	1104      	call	0x474c <__mlx4_flash_start+0x74c>
    4544:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4546:	7381      	lod	A, ep:0x81 <__data_size+0x7>
    4548:	5404      	ret	#5
    454a:	6800      	lod	AH, #0
    454c:	b780      	and	A, ep:0x80 <__data_size+0x6>
    454e:	7381      	lod	A, ep:0x81 <__data_size+0x7>
    4550:	5404      	ret	#5
    4552:	e684      	or	Y, io:0x4 <_LinMess>
    4554:	1102      	call	0x475a <__mlx4_flash_start+0x75a>
    4556:	b582      	and	A, dp:0x82 <_targetPos>
    4558:	29d4      	sub	X, dp:0xd4 <_g_u16falg>
    455a:	7201      	lod	A, [S-2]
    455c:	e682      	or	Y, io:0x2 <_LinCmnd>
    455e:	1101      	call	0x4762 <__mlx4_flash_start+0x762>
    4560:	248f      	or	X, #-113
    4562:	e688      	or	Y, io:0x8 <__bist_stat_size>
    4564:	1101      	call	0x4768 <__mlx4_flash_start+0x768>
    4566:	2967      	sub	X, dp:0x67 <_ml_driver_mode+0x9>
    4568:	2487      	or	X, #-121
    456a:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    456c:	bf8d      	xor	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    456e:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4570:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4572:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4574:	b782      	and	A, ep:0x82 <_targetPos>
    4576:	22d2      	add	X, [A++]
    4578:	0b04      	setb	io:0x00.4
    457a:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    457c:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    457e:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4580:	22e5      	add	X, MH
    4582:	b10c      	adc	A, dp:0xc <__bist_stat_size+0x4>
    4584:	b20d      	adc	A, [S-14]
    4586:	7238      	lod	A, [S-57]
    4588:	b202      	adc	A, [S-3]
    458a:	728c      	lod	A, io:0xc <__bist_stat_size+0x4>
    458c:	b203      	adc	A, [S-4]
    458e:	728d      	lod	A, io:0xd <__bist_stat_size+0x5>
    4590:	b63e      	and	A, [S-63]
    4592:	22d7      	.word	0x22d7
    4594:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    4596:	7201      	lod	A, [S-2]
    4598:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    459a:	b365      	adc	A, ep:0x65 <_ml_driver_mode+0x7>
    459c:	bf81      	xor	A, ep:0x81 <__data_size+0x7>
    459e:	0101      	jmp	0x47a2 <__mlx4_flash_start+0x7a2>
    45a0:	6800      	lod	AH, #0
    45a2:	b781      	and	A, ep:0x81 <__data_size+0x7>
    45a4:	0b04      	setb	io:0x00.4
    45a6:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    45a8:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    45aa:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    45ac:	22e5      	add	X, MH
    45ae:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    45b0:	7235      	lod	A, [S-54]
    45b2:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    45b4:	7289      	lod	A, io:0x9 <__bist_stat_size+0x1>
    45b6:	718a      	lod	A, dp:0x8a <_l_u8OBDValveStatusFault>
    45b8:	b338      	adc	A, ep:0x38 <_g_u16CorrectionRatio>
    45ba:	738b      	lod	A, ep:0x8b <_l_u8ValueFaultFlag>
    45bc:	b30e      	adc	A, ep:0xe <__bist_stat_size+0x6>
    45be:	b20f      	adc	A, [S-16]
    45c0:	738e      	lod	A, ep:0x8e <_s_CVRequestStruct>
    45c2:	728f      	lod	A, io:0xf <__bist_stat_size+0x7>
    45c4:	5408      	ret	#9
    45c6:	7ca6      	lod	X, #-90
    45c8:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    45ca:	6800      	lod	AH, #0
    45cc:	b384      	adc	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    45ce:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    45d0:	7380      	lod	A, ep:0x80 <__data_size+0x6>
    45d2:	7334      	lod	A, ep:0x34 <_g_DiagResponse+0x4>
    45d4:	7235      	lod	A, [S-54]
    45d6:	7ca7      	lod	X, #-89
    45d8:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    45da:	6c03      	lod	YH, #3
    45dc:	2300      	add	X, ep:0x0 <__dp__>
    45de:	2295      	add	X, io:0x15 <__data_dp_size+0x5>
    45e0:	23ee      	add	X, ep:0xee <_l_u16PhysicalTargetPos>
    45e2:	2300      	add	X, ep:0x0 <__dp__>
    45e4:	2300      	add	X, ep:0x0 <__dp__>
    45e6:	23a1      	add	X, ep:0xa1 <_l_u8StallOcc>
    45e8:	240b      	or	X, #11
    45ea:	23cb      	add	X, ep:0xcb <_l_u8DriftCheckCount+0x1>
    45ec:	2300      	add	X, ep:0x0 <__dp__>
    45ee:	2300      	add	X, ep:0x0 <__dp__>
    45f0:	2304      	add	X, ep:0x4 <_LinMess>
    45f2:	23c3      	add	X, ep:0xc3 <_l_u16CoilZeroCurrCountB+0x1>
    45f4:	23e6      	add	X, ep:0xe6 <_g_i16PID_D>
    45f6:	23da      	add	X, ep:0xda <_l_u16StartupDelayInit>
    45f8:	2300      	add	X, ep:0x0 <__dp__>
    45fa:	23b7      	add	X, ep:0xb7 <_g_i16SupplyVoltage+0x1>
    45fc:	b780      	and	A, ep:0x80 <__data_size+0x6>
    45fe:	2301      	add	X, ep:0x1 <__dp__+0x1>
    4600:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4602:	7381      	lod	A, ep:0x81 <__data_size+0x7>
    4604:	5404      	ret	#5
    4606:	6800      	lod	AH, #0
    4608:	e682      	or	Y, io:0x2 <_LinCmnd>
    460a:	0104      	jmp	0x4814 <__mlx4_flash_start+0x814>
    460c:	b681      	and	A, io:0x1 <__dp__+0x1>
    460e:	7282      	lod	A, io:0x2 <_LinCmnd>
    4610:	b684      	and	A, io:0x4 <_LinMess>
    4612:	230d      	add	X, ep:0xd <__bist_stat_size+0x5>
    4614:	b680      	and	A, io:0x0 <__dp__>
    4616:	7282      	lod	A, io:0x2 <_LinCmnd>
    4618:	b680      	and	A, io:0x0 <__dp__>
    461a:	7283      	lod	A, io:0x3 <_LinCmnd+0x1>
    461c:	22fe      	add	X, [X+6]
    461e:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4620:	a688      	or	A, io:0x8 <__bist_stat_size>
    4622:	0102      	jmp	0x4828 <__mlx4_flash_start+0x828>
    4624:	b582      	and	A, dp:0x82 <_targetPos>
    4626:	2315      	add	X, ep:0x15 <__data_dp_size+0x5>
    4628:	b581      	and	A, dp:0x81 <__data_size+0x7>
    462a:	7170      	lod	A, dp:0x70 <_ml_driver_mode+0x12>
    462c:	a684      	or	A, io:0x4 <_LinMess>
    462e:	0101      	jmp	0x4832 <__mlx4_flash_start+0x832>
    4630:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4632:	be83      	xor	A, io:0x3 <_LinCmnd+0x1>
    4634:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4636:	7271      	lod	A, [S-114]
    4638:	b286      	adc	A, io:0x6 <_LinMess2>
    463a:	4616      	mov	[S-23], YL
    463c:	7286      	lod	A, io:0x6 <_LinMess2>
    463e:	b271      	adc	A, [S-114]
    4640:	b5a3      	and	A, dp:0xa3 <_l_u8BackgroundSchedulerTaskID>
    4642:	0009      	jmp	0x4656 <__mlx4_flash_start+0x656>
    4644:	6c02      	lod	YH, #2
    4646:	bd8e      	xor	A, dp:0x8e <_s_CVRequestStruct>
    4648:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    464a:	bd8d      	xor	A, dp:0x8d <_l_u8AliveRollingCounter+0x1>
    464c:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    464e:	bd8b      	xor	A, dp:0x8b <_l_u8ValueFaultFlag>
    4650:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4652:	bd87      	xor	A, dp:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4654:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4656:	6c02      	lod	YH, #2
    4658:	f581      	and	Y, dp:0x81 <__data_size+0x7>
    465a:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    465c:	f582      	and	Y, dp:0x82 <_targetPos>
    465e:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4660:	f584      	and	Y, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4662:	2333      	add	X, ep:0x33 <_g_DiagResponse+0x3>
    4664:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4666:	b691      	and	A, io:0x11 <__data_dp_size+0x1>
    4668:	b170      	adc	A, dp:0x70 <_ml_driver_mode+0x12>
    466a:	76a3      	jmp	io:0x23 <_l_u8VTIdx+0x1>
    466c:	e78a      	or	Y, ep:0x8a <_l_u8OBDValveStatusFault>
    466e:	1008      	call	0x4680 <__mlx4_flash_start+0x680>
    4670:	8782      	or	AL, ep:0x82 <_targetPos>
    4672:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4674:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    4676:	4794      	mov	ep:0x94 <_s_CVRequestStruct+0x6>, YL
    4678:	0101      	jmp	0x487c <__mlx4_flash_start+0x87c>
    467a:	231c      	add	X, ep:0x1c <_g_sMotorFault>
    467c:	b287      	adc	A, io:0x7 <_LinProtectedID>
    467e:	231d      	add	X, ep:0x1d <_g_sMotorFault+0x1>
    4680:	e78c      	or	Y, ep:0x8c <_l_u8AliveRollingCounter>
    4682:	1003      	call	0x468a <__mlx4_flash_start+0x68a>
    4684:	8782      	or	AL, ep:0x82 <_targetPos>
    4686:	4050      	jmp	fp2:0x80
    4688:	231f      	add	X, ep:0x1f <__ramfunc_size+0x1>
    468a:	22fe      	add	X, [X+6]
    468c:	b202      	adc	A, [S-3]
    468e:	b36b      	adc	A, ep:0x6b <_ml_driver_mode+0xd>
    4690:	836a      	add	AL, ep:0x6a <_ml_driver_mode+0xc>
    4692:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    4694:	bf81      	xor	A, ep:0x81 <__data_size+0x7>
    4696:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4698:	6c03      	lod	YH, #3
    469a:	2375      	add	X, ep:0x75 <__bss_dp_end+0x3>
    469c:	2351      	add	X, ep:0x51 <_g_u16PID_I+0x1>
    469e:	236c      	add	X, ep:0x6c <_ml_driver_mode+0xe>
    46a0:	2375      	add	X, ep:0x75 <__bss_dp_end+0x3>
    46a2:	8681      	or	AL, io:0x1 <__dp__+0x1>
    46a4:	7202      	lod	A, [S-3]
    46a6:	b203      	adc	A, [S-4]
    46a8:	8e80      	cmp	AL, io:0x0 <__dp__>
    46aa:	f36b      	adc	Y, ep:0x6b <_ml_driver_mode+0xd>
    46ac:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    46ae:	b786      	and	A, ep:0x86 <_l_u16OBDValveStatusPosition>
    46b0:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    46b2:	0002      	jmp	0x46b8 <__mlx4_flash_start+0x6b8>
    46b4:	0106      	jmp	0x48c2 <__mlx4_flash_start+0x8c2>
    46b6:	2373      	add	X, ep:0x73 <__bss_dp_end+0x1>
    46b8:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    46ba:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    46bc:	1003      	call	0x46c4 <__mlx4_flash_start+0x6c4>
    46be:	b78f      	and	A, ep:0x8f <_s_CVRequestStruct+0x1>
    46c0:	2362      	add	X, ep:0x62 <_ml_driver_mode+0x4>
    46c2:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    46c4:	0000      	nop
    46c6:	0000      	nop
    46c8:	0000      	nop
    46ca:	0000      	nop
    46cc:	0000      	nop
    46ce:	0000      	nop
    46d0:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    46d2:	e780      	or	Y, ep:0x80 <__data_size+0x6>
    46d4:	0108      	jmp	0x48e6 <__mlx4_flash_start+0x8e6>
    46d6:	2362      	add	X, ep:0x62 <_ml_driver_mode+0x4>
    46d8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    46da:	7202      	lod	A, [S-3]
    46dc:	b203      	adc	A, [S-4]
    46de:	ce80      	cmp	AH, io:0x0 <__dp__>
    46e0:	b78e      	and	A, ep:0x8e <_s_CVRequestStruct>
    46e2:	bb6b      	subc	A, ep:0x6b <_ml_driver_mode+0xd>
    46e4:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    46e6:	7203      	lod	A, [S-4]
    46e8:	4c02 6800 	add	D, #1920034816
    46ec:	7271 
    46ee:	b16d      	adc	A, dp:0x6d <_ml_driver_mode+0xf>
    46f0:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    46f2:	716d      	lod	A, dp:0x6d <_ml_driver_mode+0xf>
    46f4:	0b04      	setb	io:0x00.4
    46f6:	b25e      	adc	A, [S-95]
    46f8:	f688      	and	Y, io:0x8 <__bist_stat_size>
    46fa:	725e      	lod	A, [S-95]
    46fc:	2388      	add	X, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    46fe:	7189      	lod	A, dp:0x89 <_l_u8OBDValveStatusVolt>
    4700:	7134      	lod	A, dp:0x34 <_g_DiagResponse+0x4>
    4702:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4704:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    4706:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4708:	7388      	lod	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    470a:	5408      	ret	#9
    470c:	7c55      	lod	X, #85
    470e:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    4710:	b691      	and	A, io:0x11 <__data_dp_size+0x1>
    4712:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4714:	3beb      	subc	X, ep:0xeb <_LINBaud+0x1>
    4716:	b5a6      	and	A, dp:0xa6 <_l_u8RamPreError+0x2>
    4718:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    471a:	a58f      	or	A, dp:0x8f <_s_CVRequestStruct+0x1>
    471c:	1103      	call	0x4924 <__mlx4_flash_start+0x924>
    471e:	b16c      	adc	A, dp:0x6c <_ml_driver_mode+0xe>
    4720:	bd84      	xor	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4722:	716c      	lod	A, dp:0x6c <_ml_driver_mode+0xe>
    4724:	b271      	adc	A, [S-114]
    4726:	6800      	lod	AH, #0
    4728:	a688      	or	A, io:0x8 <__bist_stat_size>
    472a:	110a      	call	0x4940 <__mlx4_flash_start+0x940>
    472c:	b23b      	adc	A, [S-60]
    472e:	f684      	and	Y, io:0x4 <_LinMess>
    4730:	723b      	lod	A, [S-60]
    4732:	b35a      	adc	A, ep:0x5a <_LIN_nad>
    4734:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4736:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4738:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    473a:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    473c:	7343      	lod	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    473e:	7344      	lod	A, ep:0x44 <_g_e8MotorDirectionCCW>
    4740:	6800      	lod	AH, #0
    4742:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4744:	b286      	adc	A, io:0x6 <_LinMess2>
    4746:	010a      	jmp	0x495c <__mlx4_flash_start+0x95c>
    4748:	000e      	jmp	0x4766 <__mlx4_flash_start+0x766>
    474a:	e680      	or	Y, io:0x0 <__dp__>
    474c:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    474e:	0103      	jmp	0x4956 <__mlx4_flash_start+0x956>
    4750:	f782      	and	Y, ep:0x82 <_targetPos>
    4752:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4754:	22fe      	add	X, [X+6]
    4756:	bf8d      	xor	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4758:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    475a:	22fe      	add	X, [X+6]
    475c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    475e:	f788      	and	Y, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4760:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4762:	7200      	lod	A, [S-1]
    4764:	22fe      	add	X, [X+6]
    4766:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4768:	f784      	and	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    476a:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    476c:	22fe      	add	X, [X+6]
    476e:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    4770:	bf8d      	xor	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4772:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    4774:	a682      	or	A, io:0x2 <_LinCmnd>
    4776:	1106      	call	0x4984 <__mlx4_flash_start+0x984>
    4778:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    477a:	bf8e      	xor	A, ep:0x8e <_s_CVRequestStruct>
    477c:	a681      	or	A, io:0x1 <__dp__+0x1>
    477e:	0101      	jmp	0x4982 <__mlx4_flash_start+0x982>
    4780:	f781      	and	Y, ep:0x81 <__data_size+0x7>
    4782:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    4784:	22fe      	add	X, [X+6]
    4786:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4788:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    478a:	0101      	jmp	0x498e <__mlx4_flash_start+0x98e>
    478c:	2300      	add	X, ep:0x0 <__dp__>
    478e:	7264      	lod	A, [S-101]
    4790:	b286      	adc	A, io:0x6 <_LinMess2>
    4792:	7265      	lod	A, [S-102]
    4794:	22fe      	add	X, [X+6]
    4796:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4798:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    479a:	0101      	jmp	0x499e <__mlx4_flash_start+0x99e>
    479c:	2300      	add	X, ep:0x0 <__dp__>
    479e:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    47a0:	be86      	xor	A, io:0x6 <_LinMess2>
    47a2:	6c02      	lod	YH, #2
    47a4:	3e04      	xor	X, [S-5]
    47a6:	23d9      	add	X, ep:0xd9 <_g_u8MotorStatusSpeed>
    47a8:	3e05      	xor	X, [S-6]
    47aa:	23d9      	add	X, ep:0xd9 <_g_u8MotorStatusSpeed>
    47ac:	3e06      	xor	X, [S-7]
    47ae:	23d9      	add	X, ep:0xd9 <_g_u8MotorStatusSpeed>
    47b0:	3e07      	xor	X, [S-8]
    47b2:	22fe      	add	X, [X+6]
    47b4:	b285      	adc	A, io:0x5 <_LinMess+0x1>
    47b6:	e681      	or	Y, io:0x1 <__dp__+0x1>
    47b8:	0106      	jmp	0x49c6 <__mlx4_flash_start+0x9c6>
    47ba:	e682      	or	Y, io:0x2 <_LinCmnd>
    47bc:	0102      	jmp	0x49c2 <__mlx4_flash_start+0x9c2>
    47be:	b680      	and	A, io:0x0 <__dp__>
    47c0:	23e4      	add	X, ep:0xe4 <_g_i16PID_E>
    47c2:	b682      	and	A, io:0x2 <_LinCmnd>
    47c4:	23e4      	add	X, ep:0xe4 <_g_i16PID_E>
    47c6:	b684      	and	A, io:0x4 <_LinMess>
    47c8:	726c      	lod	A, [S-109]
    47ca:	22fe      	add	X, [X+6]
    47cc:	b301      	adc	A, ep:0x1 <__dp__+0x1>
    47ce:	7382      	lod	A, ep:0x82 <_targetPos>
    47d0:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    47d2:	7383      	lod	A, ep:0x83 <_targetPos+0x1>
    47d4:	f686      	and	Y, io:0x6 <_LinMess2>
    47d6:	bf92      	xor	A, ep:0x92 <_s_CVRequestStruct+0x4>
    47d8:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    47da:	22fe      	add	X, [X+6]
    47dc:	b781      	and	A, ep:0x81 <__data_size+0x7>
    47de:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    47e0:	0101      	jmp	0x49e4 <__mlx4_flash_start+0x9e4>
    47e2:	2300      	add	X, ep:0x0 <__dp__>
    47e4:	e68e      	or	Y, io:0xe <__bist_stat_size+0x6>
    47e6:	010e      	jmp	0x4a04 <__mlx4_flash_start+0xa04>
    47e8:	763e      	jmp	[S-63]
    47ea:	7207      	lod	A, [S-8]
    47ec:	7206      	lod	A, [S-7]
    47ee:	b286      	adc	A, io:0x6 <_LinMess2>
    47f0:	7202      	lod	A, [S-3]
    47f2:	7204      	lod	A, [S-5]
    47f4:	b287      	adc	A, io:0x7 <_LinProtectedID>
    47f6:	7203      	lod	A, [S-4]
    47f8:	7205      	lod	A, [S-6]
    47fa:	b25c      	adc	A, [S-93]
    47fc:	f684      	and	Y, io:0x4 <_LinMess>
    47fe:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4800:	725c      	lod	A, [S-93]
    4802:	22fe      	add	X, [X+6]
    4804:	b25c      	adc	A, [S-93]
    4806:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4808:	b386      	adc	A, ep:0x86 <_l_u16OBDValveStatusPosition>
    480a:	e780      	or	Y, ep:0x80 <__data_size+0x6>
    480c:	0101      	jmp	0x4a10 <__mlx4_flash_start+0xa10>
    480e:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4810:	be8b      	xor	A, io:0xb <__bist_stat_size+0x3>
    4812:	725c      	lod	A, [S-93]
    4814:	22fe      	add	X, [X+6]
    4816:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4818:	e301      	add	Y, ep:0x1 <__dp__+0x1>
    481a:	0101      	jmp	0x4a1e <__mlx4_flash_start+0xa1e>
    481c:	2300      	add	X, ep:0x0 <__dp__>
    481e:	b387      	adc	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4820:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4822:	0001      	jmp	0x4826 <__mlx4_flash_start+0x826>
    4824:	230f      	add	X, ep:0xf <__bist_stat_size+0x7>
    4826:	7271      	lod	A, [S-114]
    4828:	be8c      	xor	A, io:0xc <__bist_stat_size+0x4>
    482a:	4608      	mov	[S-9], YL
    482c:	6c02      	lod	YH, #2
    482e:	b11c      	adc	A, dp:0x1c <_g_sMotorFault>
    4830:	241e      	or	X, #30
    4832:	b11d      	adc	A, dp:0x1d <_g_sMotorFault+0x1>
    4834:	241e      	or	X, #30
    4836:	b12c      	adc	A, dp:0x2c <__data_dp_end+0x4>
    4838:	241e      	or	X, #30
    483a:	b12d      	adc	A, dp:0x2d <__data_dp_end+0x5>
    483c:	b387      	adc	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    483e:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4840:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4842:	b371      	adc	A, ep:0x71 <_ml_driver_mode+0x13>
    4844:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4846:	4788      	mov	ep:0x88 <_l_u8OBDValveStatusOverTempWarn>, YL
    4848:	0009      	jmp	0x485c <__mlx4_flash_start+0x85c>
    484a:	6c03      	lod	YH, #3
    484c:	bd8e      	xor	A, dp:0x8e <_s_CVRequestStruct>
    484e:	2436      	or	X, #54
    4850:	bd8d      	xor	A, dp:0x8d <_l_u8AliveRollingCounter+0x1>
    4852:	2436      	or	X, #54
    4854:	bd8b      	xor	A, dp:0x8b <_l_u8ValueFaultFlag>
    4856:	2436      	or	X, #54
    4858:	bd87      	xor	A, dp:0x87 <_l_u16OBDValveStatusPosition+0x1>
    485a:	2436      	or	X, #54
    485c:	6c03      	lod	YH, #3
    485e:	f581      	and	Y, dp:0x81 <__data_size+0x7>
    4860:	2436      	or	X, #54
    4862:	f582      	and	Y, dp:0x82 <_targetPos>
    4864:	2436      	or	X, #54
    4866:	f584      	and	Y, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4868:	2436      	or	X, #54
    486a:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    486c:	6c02      	lod	YH, #2
    486e:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    4870:	243e      	or	X, #62
    4872:	711d      	lod	A, dp:0x1d <_g_sMotorFault+0x1>
    4874:	243e      	or	X, #62
    4876:	712c      	lod	A, dp:0x2c <__data_dp_end+0x4>
    4878:	243e      	or	X, #62
    487a:	712d      	lod	A, dp:0x2d <__data_dp_end+0x5>
    487c:	22fe      	add	X, [X+6]
    487e:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4880:	b682      	and	A, io:0x2 <_LinCmnd>
    4882:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4884:	7c01      	lod	X, #1
    4886:	5018      	call	fp0:0xC0
    4888:	54c0      	.word	0x54c0
    488a:	b780      	and	A, ep:0x80 <__data_size+0x6>
    488c:	733e      	lod	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    488e:	733f      	lod	A, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    4890:	5401      	ret
    4892:	3e60      	xor	X, [S-97]
    4894:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4896:	773a      	lod	PC, ep:0x3a <_g_u16MicroStepIdx>
    4898:	773b      	lod	PC, ep:0x3b <_g_u16MicroStepIdx+0x1>
    489a:	773f      	lod	PC, ep:0x3f <_g_u16TargetCommutTimerPeriod+0x1>
    489c:	355b      	and	X, dp:0x5b <_LIN_nad+0x1>
    489e:	365b      	and	X, [S-92]
    48a0:	3730      	and	X, ep:0x30 <_g_DiagResponse>
    48a2:	7736      	lod	PC, ep:0x36 <_g_DiagResponse+0x6>
    48a4:	3ba0      	subc	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    48a6:	b78f      	and	A, ep:0x8f <_s_CVRequestStruct+0x1>
    48a8:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    48aa:	b681      	and	A, io:0x1 <__dp__+0x1>
    48ac:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    48ae:	b78e      	and	A, ep:0x8e <_s_CVRequestStruct>
    48b0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    48b2:	b680      	and	A, io:0x0 <__dp__>
    48b4:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    48b6:	b780      	and	A, ep:0x80 <__data_size+0x6>
    48b8:	7301      	lod	A, ep:0x1 <__dp__+0x1>
    48ba:	b780      	and	A, ep:0x80 <__data_size+0x6>
    48bc:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    48be:	494e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, AH
    48c0:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    48c2:	493a      	mov	dp:0x3a <_g_u16MicroStepIdx>, AH
    48c4:	490e      	mov	dp:0xe <__bist_stat_size+0x6>, AH
    48c6:	4964      	mov	dp:0x64 <_ml_driver_mode+0x6>, AH
    48c8:	735f      	lod	A, ep:0x5f <_ml_driver_mode+0x1>
    48ca:	736c      	lod	A, ep:0x6c <_ml_driver_mode+0xe>
    48cc:	735c      	lod	A, ep:0x5c <_LinMessage>
    48ce:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    48d0:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    48d2:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    48d4:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    48d6:	b58b      	and	A, dp:0x8b <_l_u8ValueFaultFlag>
    48d8:	7105      	lod	A, dp:0x5 <_LinMess+0x1>
    48da:	7103      	lod	A, dp:0x3 <_LinCmnd+0x1>
    48dc:	b58c      	and	A, dp:0x8c <_l_u8AliveRollingCounter>
    48de:	7104      	lod	A, dp:0x4 <_LinMess>
    48e0:	7102      	lod	A, dp:0x2 <_LinCmnd>
    48e2:	b583      	and	A, dp:0x83 <_targetPos+0x1>
    48e4:	7107      	lod	A, dp:0x7 <_LinProtectedID>
    48e6:	7106      	lod	A, dp:0x6 <_LinMess2>
    48e8:	b680      	and	A, io:0x0 <__dp__>
    48ea:	77c6      	lod	PC, ep:0xc6 <_l_u8OverTemperatureShutCount>
    48ec:	77ca      	lod	PC, ep:0xca <_l_u8DriftCheckCount>
    48ee:	8681      	or	AL, io:0x1 <__dp__+0x1>
    48f0:	0101      	jmp	0x4af4 <__mlx4_flash_start+0xaf4>
    48f2:	2475      	or	X, #117
    48f4:	b687      	and	A, io:0x7 <_LinProtectedID>
    48f6:	7336      	lod	A, ep:0x36 <_g_DiagResponse+0x6>
    48f8:	7237      	lod	A, [S-56]
    48fa:	b788      	and	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    48fc:	730d      	lod	A, ep:0xd <__bist_stat_size+0x5>
    48fe:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4900:	738c      	lod	A, ep:0x8c <_l_u8AliveRollingCounter>
    4902:	b784      	and	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4904:	738d      	lod	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4906:	7c02      	lod	X, #2
    4908:	5820      	inc	S, #33
    490a:	b681      	and	A, io:0x1 <__dp__+0x1>
    490c:	62ca      	lod	AL, [--PC]
    490e:	622b      	lod	AL, [S-44]
    4910:	3448      	and	X, #72
    4912:	5809      	inc	S, #10
    4914:	62e6      	lod	AL, Y
    4916:	2489      	or	X, #-119
    4918:	b78a      	and	A, ep:0x8a <_l_u8OBDValveStatusFault>
    491a:	b682      	and	A, io:0x2 <_LinCmnd>
    491c:	62ca      	lod	AL, [--PC]
    491e:	5018      	call	fp0:0xC0
    4920:	54c0      	.word	0x54c0
    4922:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4924:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4926:	24a3      	or	X, #-93
    4928:	b680      	and	A, io:0x0 <__dp__>
    492a:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    492c:	a781      	or	A, ep:0x81 <__data_size+0x7>
    492e:	0106      	jmp	0x4b3c <__mlx4_flash_start+0xb3c>
    4930:	bf8e      	xor	A, ep:0x8e <_s_CVRequestStruct>
    4932:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4934:	b239      	adc	A, [S-58]
    4936:	7238      	lod	A, [S-57]
    4938:	b582      	and	A, dp:0x82 <_targetPos>
    493a:	b686      	and	A, io:0x6 <_LinMess2>
    493c:	e680      	or	Y, io:0x0 <__dp__>
    493e:	0101      	jmp	0x4b42 <__mlx4_flash_start+0xb42>
    4940:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4942:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4944:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4946:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    4948:	bd88      	xor	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    494a:	716f      	lod	A, dp:0x6f <_ml_driver_mode+0x11>
    494c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    494e:	a78d      	or	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    4950:	1101      	call	0x4b54 <__mlx4_flash_start+0xb54>
    4952:	24c2      	or	X, #-62
    4954:	4d02      	mov	dp:0x2 <_LinCmnd>, YH
    4956:	494e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, AH
    4958:	b58e      	and	A, dp:0x8e <_s_CVRequestStruct>
    495a:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    495c:	e53e      	or	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    495e:	1101      	call	0x4b62 <__mlx4_flash_start+0xb62>
    4960:	24c2      	or	X, #-62
    4962:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4964:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    4966:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4968:	b341      	adc	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    496a:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    496c:	7341      	lod	A, ep:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    496e:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4970:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4972:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4974:	b343      	adc	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4976:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4978:	7343      	lod	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    497a:	b344      	adc	A, ep:0x44 <_g_e8MotorDirectionCCW>
    497c:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    497e:	7344      	lod	A, ep:0x44 <_g_e8MotorDirectionCCW>
    4980:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4982:	24ae      	or	X, #-82
    4984:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4986:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    4988:	b580      	and	A, dp:0x80 <__data_size+0x6>
    498a:	7167      	lod	A, dp:0x67 <_ml_driver_mode+0x9>
    498c:	b58e      	and	A, dp:0x8e <_s_CVRequestStruct>
    498e:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    4990:	e106      	add	Y, dp:0x6 <_LinMess2>
    4992:	0108      	jmp	0x4ba4 <__mlx4_flash_start+0xba4>
    4994:	b266      	adc	A, [S-103]
    4996:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4998:	7266      	lod	A, [S-103]
    499a:	b267      	adc	A, [S-104]
    499c:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    499e:	7267      	lod	A, [S-104]
    49a0:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    49a2:	24c8      	or	X, #-56
    49a4:	4d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, YH
    49a6:	4968      	mov	dp:0x68 <_ml_driver_mode+0xa>, AH
    49a8:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    49aa:	b780      	and	A, ep:0x80 <__data_size+0x6>
    49ac:	733a      	lod	A, ep:0x3a <_g_u16MicroStepIdx>
    49ae:	623a      	lod	AL, [S-59]
    49b0:	a688      	or	A, io:0x8 <__bist_stat_size>
    49b2:	1104      	call	0x4bbc <__mlx4_flash_start+0xbbc>
    49b4:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49b6:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    49b8:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49ba:	24f2      	or	X, #-14
    49bc:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49be:	a78d      	or	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    49c0:	0103      	jmp	0x4bc8 <__mlx4_flash_start+0xbc8>
    49c2:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    49c4:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    49c6:	2494      	or	X, #-108
    49c8:	580e      	inc	S, #15
    49ca:	0803      	clrb	dp:0x00.3
    49cc:	0906      	clrb	io:0x00.6
    49ce:	62e6      	lod	AL, Y
    49d0:	24e4      	or	X, #-28
    49d2:	623a      	lod	AL, [S-59]
    49d4:	a688      	or	A, io:0x8 <__bist_stat_size>
    49d6:	0106      	jmp	0x4be4 <__mlx4_flash_start+0xbe4>
    49d8:	24e4      	or	X, #-28
    49da:	626f      	lod	AL, [S-112]
    49dc:	0001      	jmp	0x49e0 <__mlx4_flash_start+0x9e0>
    49de:	24e9      	or	X, #-23
    49e0:	b586      	and	A, dp:0x86 <_l_u16OBDValveStatusPosition>
    49e2:	29d4      	sub	X, dp:0xd4 <_g_u16falg>
    49e4:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    49e6:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    49e8:	380d      	subc	X, #13
    49ea:	3805      	subc	X, #5
    49ec:	3479      	and	X, #121
    49ee:	303a      	adc	X, #58
    49f0:	39f6      	subc	X, dp:0xf6 <_g_AdcMotorRunStepper4+0x2>
    49f2:	b26c      	adc	A, [S-109]
    49f4:	a686      	or	A, io:0x6 <_LinMess2>
    49f6:	0106      	jmp	0x4c04 <__mlx4_flash_start+0xc04>
    49f8:	f681      	and	Y, io:0x1 <__dp__+0x1>
    49fa:	726c      	lod	A, [S-109]
    49fc:	b26e      	adc	A, [S-111]
    49fe:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    4a00:	1101      	call	0x4c04 <__mlx4_flash_start+0xc04>
    4a02:	6376      	lod	AL, ep:0x76 <__bss_dp_end+0x4>
    4a04:	3cc3      	xor	X, #-61
    4a06:	b688      	and	A, io:0x8 <__bist_stat_size>
    4a08:	be38      	xor	A, [S-57]
    4a0a:	0101      	jmp	0x4c0e <__mlx4_flash_start+0xc0e>
    4a0c:	2494      	or	X, #-108
    4a0e:	580e      	inc	S, #15
    4a10:	0905      	clrb	io:0x00.5
    4a12:	0802      	clrb	dp:0x00.2
    4a14:	62e6      	lod	AL, Y
    4a16:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a18:	623a      	lod	AL, [S-59]
    4a1a:	2522      	or	X, dp:0x22 <_l_u8VTIdx>
    4a1c:	623a      	lod	AL, [S-59]
    4a1e:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4a20:	bd8e      	xor	A, dp:0x8e <_s_CVRequestStruct>
    4a22:	a681      	or	A, io:0x1 <__dp__+0x1>
    4a24:	1102      	call	0x4c2a <__mlx4_flash_start+0xc2a>
    4a26:	a78c      	or	A, ep:0x8c <_l_u8AliveRollingCounter>
    4a28:	0101      	jmp	0x4c2c <__mlx4_flash_start+0xc2c>
    4a2a:	f581      	and	Y, dp:0x81 <__data_size+0x7>
    4a2c:	715c      	lod	A, dp:0x5c <_LinMessage>
    4a2e:	4050      	jmp	fp2:0x80
    4a30:	6c04      	lod	YH, #4
    4a32:	2528      	or	X, dp:0x28 <__data_dp_end>
    4a34:	2542      	or	X, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4a36:	254f      	or	X, dp:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4a38:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a3a:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4a3c:	a581      	or	A, dp:0x81 <__data_size+0x7>
    4a3e:	0107      	jmp	0x4c4e <__mlx4_flash_start+0xc4e>
    4a40:	bd8e      	xor	A, dp:0x8e <_s_CVRequestStruct>
    4a42:	715c      	lod	A, dp:0x5c <_LinMessage>
    4a44:	484f      	macu	D, AL, [X]
    4a46:	6c04      	lod	YH, #4
    4a48:	2557      	or	X, dp:0x57 <_LinFrameDataBuffer+0x5>
    4a4a:	2584      	or	X, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4a4c:	25c6      	or	X, dp:0xc6 <_l_u8OverTemperatureShutCount>
    4a4e:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4a50:	484e      	macu	D, AL, [X++]
    4a52:	61c0      	lod	AL, dp:0xc0 <_l_u16CoilCurrentStartDelay>
    4a54:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4a56:	1104      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a58:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a5a:	e585      	or	Y, dp:0x85 <_l_u8OBDValveStatusMove>
    4a5c:	1101      	call	0x4c60 <__mlx4_flash_start+0xc60>
    4a5e:	2918      	sub	X, dp:0x18 <__data_dp_start>
    4a60:	b16c      	adc	A, dp:0x6c <_ml_driver_mode+0xe>
    4a62:	a581      	or	A, dp:0x81 <__data_size+0x7>
    4a64:	010e      	jmp	0x4c82 <__mlx4_flash_start+0xc82>
    4a66:	b168      	adc	A, dp:0x68 <_ml_driver_mode+0xa>
    4a68:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4a6a:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    4a6c:	b169      	adc	A, dp:0x69 <_ml_driver_mode+0xb>
    4a6e:	cd80      	cmp	AH, dp:0x80 <__data_size+0x6>
    4a70:	7169      	lod	A, dp:0x69 <_ml_driver_mode+0xb>
    4a72:	1107      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a74:	4d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, YH
    4a76:	4968      	mov	dp:0x68 <_ml_driver_mode+0xa>, AH
    4a78:	b16e      	adc	A, dp:0x6e <_ml_driver_mode+0x10>
    4a7a:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4a7c:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    4a7e:	1101      	call	0x4c82 <__mlx4_flash_start+0xc82>
    4a80:	6376      	lod	AL, ep:0x76 <__bss_dp_end+0x4>
    4a82:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4a84:	61d6      	lod	AL, dp:0xd6 <_g_u8ValveInitState>
    4a86:	7271      	lod	A, [S-114]
    4a88:	b256      	adc	A, [S-87]
    4a8a:	c242      	add	AH, [S-67]
    4a8c:	c943      	sub	AH, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a8e:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4a90:	4616      	mov	[S-23], YL
    4a92:	e242      	add	Y, [S-67]
    4a94:	e943      	sub	Y, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4a96:	1002      	call	0x4a9c <__mlx4_flash_start+0xa9c>
    4a98:	b271      	adc	A, [S-114]
    4a9a:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4a9c:	2494      	or	X, #-108
    4a9e:	b15a      	adc	A, dp:0x5a <_LIN_nad>
    4aa0:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4aa2:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4aa4:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4aa6:	1001      	call	0x4aaa <__mlx4_flash_start+0xaaa>
    4aa8:	251d      	or	X, dp:0x1d <_g_sMotorFault+0x1>
    4aaa:	6394      	lod	AL, ep:0x94 <_s_CVRequestStruct+0x6>
    4aac:	25ee      	or	X, dp:0xee <_l_u16PhysicalTargetPos>
    4aae:	61c0      	lod	AL, dp:0xc0 <_l_u16CoilCurrentStartDelay>
    4ab0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4ab2:	1102      	call	0x4cb8 <__mlx4_flash_start+0xcb8>
    4ab4:	7c06      	lod	X, #6
    4ab6:	2494      	or	X, #-108
    4ab8:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4aba:	e144      	add	Y, dp:0x44 <_g_e8MotorDirectionCCW>
    4abc:	0005      	jmp	0x4ac8 <__mlx4_flash_start+0xac8>
    4abe:	b142      	adc	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    4ac0:	e589      	or	Y, dp:0x89 <_l_u8OBDValveStatusVolt>
    4ac2:	b143      	adc	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4ac4:	ed81      	cmp	Y, dp:0x81 <__data_size+0x7>
    4ac6:	0003      	jmp	0x4ace <__mlx4_flash_start+0xace>
    4ac8:	623d      	lod	AL, [S-62]
    4aca:	6207      	lod	AL, [S-8]
    4acc:	255c      	or	X, dp:0x5c <_LinMessage>
    4ace:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4ad0:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4ad2:	1107      	call	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad4:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4ad6:	0105      	jmp	0x4ce2 <__mlx4_flash_start+0xce2>
    4ad8:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    4ada:	e73e      	or	Y, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4adc:	1002      	call	0x4ae2 <__mlx4_flash_start+0xae2>
    4ade:	b681      	and	A, io:0x1 <__dp__+0x1>
    4ae0:	2495      	or	X, #-107
    4ae2:	b36c      	adc	A, ep:0x6c <_ml_driver_mode+0xe>
    4ae4:	a781      	or	A, ep:0x81 <__data_size+0x7>
    4ae6:	0105      	jmp	0x4cf2 <__mlx4_flash_start+0xcf2>
    4ae8:	bf8e      	xor	A, ep:0x8e <_s_CVRequestStruct>
    4aea:	736c      	lod	A, ep:0x6c <_ml_driver_mode+0xe>
    4aec:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4aee:	b680      	and	A, io:0x0 <__dp__>
    4af0:	62d2      	lod	AL, [A++]
    4af2:	4d40      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, YH
    4af4:	4954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AH
    4af6:	4d42      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, YH
    4af8:	4956      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AH
    4afa:	7c4a      	lod	X, #74
    4afc:	380e      	subc	X, #14
    4afe:	3806      	subc	X, #6
    4b00:	344c      	and	X, #76
    4b02:	484f      	macu	D, AL, [X]
    4b04:	5c01      	dec	S, #2
    4b06:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b08:	61d0      	lod	AL, dp:0xd0 <_l_u8ErrorLogIdx>
    4b0a:	380f      	subc	X, #15
    4b0c:	3806      	subc	X, #6
    4b0e:	300a      	adc	X, #10
    4b10:	39f0      	subc	X, dp:0xf0 <_l_u16PhysicalCalibTravel>
    4b12:	348f      	and	X, #-113
    4b14:	5c02      	dec	S, #3
    4b16:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4b18:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4b1a:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4b1c:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4b1e:	4946      	mov	dp:0x46 <_g_u16ActuatorActPos>, AH
    4b20:	4948      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, AH
    4b22:	b58f      	and	A, dp:0x8f <_s_CVRequestStruct+0x1>
    4b24:	714b      	lod	A, dp:0x4b <__bss_dp_size+0x1>
    4b26:	714a      	lod	A, dp:0x4a <__bss_dp_size>
    4b28:	b343      	adc	A, ep:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    4b2a:	b242      	adc	A, [S-67]
    4b2c:	b141      	adc	A, dp:0x41 <_g_u16MotorCurrentMovAvgxN+0x1>
    4b2e:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4b30:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    4b32:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b34:	7241      	lod	A, [S-66]
    4b36:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b38:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4b3a:	4616      	mov	[S-23], YL
    4b3c:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b3e:	8140      	add	AL, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b40:	8a41      	sub	AL, [S-66]
    4b42:	8b42      	sub	AL, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b44:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    4b46:	7241      	lod	A, [S-66]
    4b48:	7342      	lod	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4b4a:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    4b4c:	7251      	lod	A, [S-82]
    4b4e:	7352      	lod	A, ep:0x52 <_LinFrameDataBuffer>
    4b50:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4b52:	bf8c      	xor	A, ep:0x8c <_l_u8AliveRollingCounter>
    4b54:	e784      	or	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4b56:	0101      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4b58:	25c3      	or	X, dp:0xc3 <_l_u16CoilZeroCurrCountB+0x1>
    4b5a:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4b5c:	e307      	add	Y, ep:0x7 <_LinProtectedID>
    4b5e:	100b      	call	0x4b76 <__mlx4_flash_start+0xb76>
    4b60:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4b62:	b152      	adc	A, dp:0x52 <_LinFrameDataBuffer>
    4b64:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4b66:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    4b68:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4b6a:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b6c:	7151      	lod	A, dp:0x51 <_g_u16PID_I+0x1>
    4b6e:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4b70:	4516      	mov	dp:0x16 <__data_dp_size+0x6>, YL
    4b72:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    4b74:	25ae      	or	X, dp:0xae <_l_u8LinInFrameBufState>
    4b76:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4b78:	e104      	add	Y, dp:0x4 <_LinMess>
    4b7a:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4b7c:	e905      	sub	Y, dp:0x5 <_LinMess+0x1>
    4b7e:	b152      	adc	A, dp:0x52 <_LinFrameDataBuffer>
    4b80:	ed80      	cmp	Y, dp:0x80 <__data_size+0x6>
    4b82:	1001      	call	0x4b86 <__mlx4_flash_start+0xb86>
    4b84:	2494      	or	X, #-108
    4b86:	4950      	mov	dp:0x50 <_g_u16PID_I>, AH
    4b88:	4952      	mov	dp:0x52 <_LinFrameDataBuffer>, AH
    4b8a:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4b8c:	61dd      	lod	AL, dp:0xdd <_g_u8MotorStartupMode>
    4b8e:	1001      	call	0x4b92 <__mlx4_flash_start+0xb92>
    4b90:	25ee      	or	X, dp:0xee <_l_u16PhysicalTargetPos>
    4b92:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4b94:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4b96:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4b98:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4b9a:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4b9c:	e588      	or	Y, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4b9e:	0101      	jmp	0x4da2 <__mlx4_flash_start+0xda2>
    4ba0:	2507      	or	X, dp:0x7 <_LinProtectedID>
    4ba2:	b150      	adc	A, dp:0x50 <_g_u16PID_I>
    4ba4:	4592      	mov	dp:0x92 <_s_CVRequestStruct+0x4>, YL
    4ba6:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    4ba8:	b153      	adc	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4baa:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4bac:	7353      	lod	A, ep:0x53 <_LinFrameDataBuffer+0x1>
    4bae:	b351      	adc	A, ep:0x51 <_g_u16PID_I+0x1>
    4bb0:	b252      	adc	A, [S-83]
    4bb2:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4bb4:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4bb6:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    4bb8:	7350      	lod	A, ep:0x50 <_g_u16PID_I>
    4bba:	7251      	lod	A, [S-82]
    4bbc:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    4bbe:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4bc0:	4616      	mov	[S-23], YL
    4bc2:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4bc4:	e349      	add	Y, ep:0x49 <_g_u16ActuatorTgtPos+0x1>
    4bc6:	ea4a      	sub	Y, [S-75]
    4bc8:	e94b      	sub	Y, dp:0x4b <__bss_dp_size+0x1>
    4bca:	1008      	call	0x4bdc <__mlx4_flash_start+0xbdc>
    4bcc:	8350      	add	AL, ep:0x50 <_g_u16PID_I>
    4bce:	8a51      	sub	AL, [S-82]
    4bd0:	8952      	sub	AL, dp:0x52 <_LinFrameDataBuffer>
    4bd2:	e346      	add	Y, ep:0x46 <_g_u16ActuatorActPos>
    4bd4:	ea47      	sub	Y, [S-72]
    4bd6:	e948      	sub	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    4bd8:	0001      	jmp	0x4bdc <__mlx4_flash_start+0xbdc>
    4bda:	25f6      	or	X, dp:0xf6 <_g_AdcMotorRunStepper4+0x2>
    4bdc:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4bde:	bf8c      	xor	A, ep:0x8c <_l_u8AliveRollingCounter>
    4be0:	e784      	or	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4be2:	1103      	call	0x4dea <__mlx4_flash_start+0xdea>
    4be4:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4be6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4be8:	2495      	or	X, #-107
    4bea:	2494      	or	X, #-108
    4bec:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4bee:	b252      	adc	A, [S-83]
    4bf0:	e680      	or	Y, io:0x0 <__dp__>
    4bf2:	b153      	adc	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4bf4:	ed80      	cmp	Y, dp:0x80 <__data_size+0x6>
    4bf6:	1101      	call	0x4dfa <__mlx4_flash_start+0xdfa>
    4bf8:	260e      	or	X, [S-15]
    4bfa:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4bfc:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4bfe:	7153      	lod	A, dp:0x53 <_LinFrameDataBuffer+0x1>
    4c00:	4616      	mov	[S-23], YL
    4c02:	7252      	lod	A, [S-83]
    4c04:	b251      	adc	A, [S-82]
    4c06:	4616      	mov	[S-23], YL
    4c08:	7251      	lod	A, [S-82]
    4c0a:	b250      	adc	A, [S-81]
    4c0c:	4616      	mov	[S-23], YL
    4c0e:	7250      	lod	A, [S-81]
    4c10:	b26a      	adc	A, [S-107]
    4c12:	4616      	mov	[S-23], YL
    4c14:	be8e      	xor	A, io:0xe <__bist_stat_size+0x6>
    4c16:	726a      	lod	A, [S-107]
    4c18:	61fb      	lod	AL, dp:0xfb <_g_AdcMotorRunStepper4+0x7>
    4c1a:	25f7      	or	X, dp:0xf7 <_g_AdcMotorRunStepper4+0x3>
    4c1c:	b250      	adc	A, [S-81]
    4c1e:	b151      	adc	A, dp:0x51 <_g_u16PID_I+0x1>
    4c20:	e687      	or	Y, io:0x7 <_LinProtectedID>
    4c22:	ed8c      	cmp	Y, dp:0x8c <_l_u8AliveRollingCounter>
    4c24:	1001      	call	0x4c28 <__mlx4_flash_start+0xc28>
    4c26:	261a      	or	X, [S-27]
    4c28:	4510      	mov	dp:0x10 <__data_dp_size>, YL
    4c2a:	4616      	mov	[S-23], YL
    4c2c:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4c2e:	61fb      	lod	AL, dp:0xfb <_g_AdcMotorRunStepper4+0x7>
    4c30:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4c32:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4c34:	7258      	lod	A, [S-89]
    4c36:	7159      	lod	A, dp:0x59 <_LinFrameDataBuffer+0x7>
    4c38:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4c3a:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4c3c:	623a      	lod	AL, [S-59]
    4c3e:	484f      	macu	D, AL, [X]
    4c40:	380d      	subc	X, #13
    4c42:	3806      	subc	X, #6
    4c44:	e53e      	or	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4c46:	0108      	jmp	0x4e58 <__mlx4_flash_start+0xe58>
    4c48:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4c4a:	b34f      	adc	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4c4c:	b24e      	adc	A, [S-79]
    4c4e:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4c50:	4616      	mov	[S-23], YL
    4c52:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    4c54:	724e      	lod	A, [S-79]
    4c56:	2622      	or	X, [S-35]
    4c58:	580e      	inc	S, #15
    4c5a:	0903      	clrb	io:0x00.3
    4c5c:	0809      	clrb	dp:0x01.1
    4c5e:	62e6      	lod	AL, Y
    4c60:	262c      	or	X, [S-45]
    4c62:	623a      	lod	AL, [S-59]
    4c64:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4c66:	715a      	lod	A, dp:0x5a <_LIN_nad>
    4c68:	6394      	lod	AL, ep:0x94 <_s_CVRequestStruct+0x6>
    4c6a:	b583      	and	A, dp:0x83 <_targetPos+0x1>
    4c6c:	b688      	and	A, io:0x8 <__bist_stat_size>
    4c6e:	2495      	or	X, #-107
    4c70:	b739      	and	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4c72:	b638      	and	A, [S-57]
    4c74:	348a      	and	X, #-118
    4c76:	4c58      	dadjs	D, A
    4c78:	b342      	adc	A, ep:0x42 <_g_u16MotorCurrentLPFx64>
    4c7a:	e780      	or	Y, ep:0x80 <__data_size+0x6>
    4c7c:	0101      	jmp	0x4e80 <__mlx4_flash_start+0xe80>
    4c7e:	2647      	or	X, [S-72]
    4c80:	b340      	adc	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    4c82:	b241      	adc	A, [S-66]
    4c84:	e358      	add	Y, ep:0x58 <_LinFrameDataBuffer+0x6>
    4c86:	ea59      	sub	Y, [S-90]
    4c88:	1002      	call	0x4c8e <__mlx4_flash_start+0xc8e>
    4c8a:	7c04      	lod	X, #4
    4c8c:	2494      	or	X, #-108
    4c8e:	b34e      	adc	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c90:	b24f      	adc	A, [S-80]
    4c92:	484f      	macu	D, AL, [X]
    4c94:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c96:	8a4f      	sub	AL, [S-80]
    4c98:	1001      	call	0x4c9c <__mlx4_flash_start+0xc9c>
    4c9a:	2635      	or	X, [S-54]
    4c9c:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4c9e:	724f      	lod	A, [S-80]
    4ca0:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4ca2:	b259      	adc	A, [S-90]
    4ca4:	4610      	mov	[S-17], YL
    4ca6:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4ca8:	8358      	add	AL, ep:0x58 <_LinFrameDataBuffer+0x6>
    4caa:	8a59      	sub	AL, [S-90]
    4cac:	0004      	jmp	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cae:	e34e      	add	Y, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cb0:	ea4f      	sub	Y, [S-80]
    4cb2:	1001      	call	0x4cb6 <__mlx4_flash_start+0xcb6>
    4cb4:	2635      	or	X, [S-54]
    4cb6:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4cb8:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    4cba:	b259      	adc	A, [S-90]
    4cbc:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4cbe:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4cc0:	7130      	lod	A, dp:0x30 <_g_DiagResponse>
    4cc2:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    4cc4:	7331      	lod	A, ep:0x31 <_g_DiagResponse+0x1>
    4cc6:	7232      	lod	A, [S-51]
    4cc8:	7133      	lod	A, dp:0x33 <_g_DiagResponse+0x3>
    4cca:	e355      	add	Y, ep:0x55 <_LinFrameDataBuffer+0x3>
    4ccc:	ea56      	sub	Y, [S-87]
    4cce:	e957      	sub	Y, dp:0x57 <_LinFrameDataBuffer+0x5>
    4cd0:	1002      	call	0x4cd6 <__mlx4_flash_start+0xcd6>
    4cd2:	b585      	and	A, dp:0x85 <_l_u8OBDValveStatusMove>
    4cd4:	2636      	or	X, [S-55]
    4cd6:	b15c      	adc	A, dp:0x5c <_LinMessage>
    4cd8:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4cda:	1102      	call	0x4ee0 <__mlx4_flash_start+0xee0>
    4cdc:	a584      	or	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4cde:	1101      	call	0x4ee2 <__mlx4_flash_start+0xee2>
    4ce0:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4ce2:	b359      	adc	A, ep:0x59 <_LinFrameDataBuffer+0x7>
    4ce4:	b158      	adc	A, dp:0x58 <_LinFrameDataBuffer+0x6>
    4ce6:	4592      	mov	dp:0x92 <_s_CVRequestStruct+0x4>, YL
    4ce8:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4cea:	b680      	and	A, io:0x0 <__dp__>
    4cec:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cee:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4cf0:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cf2:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cf4:	b359      	adc	A, ep:0x59 <_LinFrameDataBuffer+0x7>
    4cf6:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    4cf8:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cfa:	8e80      	cmp	AL, io:0x0 <__dp__>
    4cfc:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4cfe:	724f      	lod	A, [S-80]
    4d00:	b358      	adc	A, ep:0x58 <_LinFrameDataBuffer+0x6>
    4d02:	b259      	adc	A, [S-90]
    4d04:	b53e      	and	A, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    4d06:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d08:	0102      	jmp	0x4f0e <__mlx4_flash_start+0xf0e>
    4d0a:	0005      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d0c:	269c      	or	X, io:0x1c <_g_sMotorFault>
    4d0e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d10:	ea05      	sub	Y, [S-6]
    4d12:	0001      	jmp	0x4d16 <__mlx4_flash_start+0xd16>
    4d14:	269c      	or	X, io:0x1c <_g_sMotorFault>
    4d16:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4d18:	8a4f      	sub	AL, [S-80]
    4d1a:	e788      	or	Y, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4d1c:	ee8c      	cmp	Y, io:0xc <__bist_stat_size+0x4>
    4d1e:	0003      	jmp	0x4d26 <__mlx4_flash_start+0xd26>
    4d20:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    4d22:	4610      	mov	[S-17], YL
    4d24:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4d26:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d28:	0102      	jmp	0x4f2e <__mlx4_flash_start+0xf2e>
    4d2a:	0004      	jmp	0x4d34 <__mlx4_flash_start+0xd34>
    4d2c:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4d2e:	e304      	add	Y, ep:0x4 <_LinMess>
    4d30:	ea05      	sub	Y, [S-6]
    4d32:	100d      	call	0x4d4e <__mlx4_flash_start+0xd4e>
    4d34:	b582      	and	A, dp:0x82 <_targetPos>
    4d36:	2636      	or	X, [S-55]
    4d38:	c34e      	add	AH, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    4d3a:	ca4f      	sub	AH, [S-80]
    4d3c:	e783      	or	Y, ep:0x83 <_targetPos+0x1>
    4d3e:	ee86      	cmp	Y, io:0x6 <_LinMess2>
    4d40:	1003      	call	0x4d48 <__mlx4_flash_start+0xd48>
    4d42:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4d44:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    4d46:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4d48:	e107      	add	Y, dp:0x7 <_LinProtectedID>
    4d4a:	0102      	jmp	0x4f50 <__mlx4_flash_start+0xf50>
    4d4c:	1004      	call	0x4d56 <__mlx4_flash_start+0xd56>
    4d4e:	26ad      	or	X, io:0x2d <__data_dp_end+0x5>
    4d50:	e304      	add	Y, ep:0x4 <_LinMess>
    4d52:	ea05      	sub	Y, [S-6]
    4d54:	0002      	jmp	0x4d5a <__mlx4_flash_start+0xd5a>
    4d56:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4d58:	2636      	or	X, [S-55]
    4d5a:	4d58      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, YH
    4d5c:	4902      	mov	dp:0x2 <_LinCmnd>, AH
    4d5e:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4d60:	7306      	lod	A, ep:0x6 <_LinMess2>
    4d62:	4c02 7ccb 	add	D, #2097315019
    4d66:	7d02 
    4d68:	b25e      	adc	A, [S-95]
    4d6a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4d6c:	725e      	lod	A, [S-95]
    4d6e:	344a      	and	X, #74
    4d70:	3906      	subc	X, dp:0x6 <_LinMess2>
    4d72:	b681      	and	A, io:0x1 <__dp__+0x1>
    4d74:	724e      	lod	A, [S-79]
    4d76:	7245      	lod	A, [S-70]
    4d78:	b239      	adc	A, [S-58]
    4d7a:	7271      	lod	A, [S-114]
    4d7c:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    4d7e:	7239      	lod	A, [S-58]
    4d80:	5c00      	dec	S
    4d82:	4d1c      	mov	dp:0x1c <_g_sMotorFault>, YH
    4d84:	4962      	mov	dp:0x62 <_ml_driver_mode+0x4>, AH
    4d86:	4d2c      	mov	dp:0x2c <__data_dp_end+0x4>, YH
    4d88:	492e      	mov	dp:0x2e <__data_dp_end+0x6>, AH
    4d8a:	b680      	and	A, io:0x0 <__dp__>
    4d8c:	720d      	lod	A, [S-14]
    4d8e:	3807      	subc	X, #7
    4d90:	380e      	subc	X, #14
    4d92:	3430      	and	X, #48
    4d94:	580e      	inc	S, #15
    4d96:	0803      	clrb	dp:0x00.3
    4d98:	0907      	clrb	io:0x00.7
    4d9a:	62e6      	lod	AL, Y
    4d9c:	26ca      	or	X, [--PC]
    4d9e:	623a      	lod	AL, [S-59]
    4da0:	a688      	or	A, io:0x8 <__bist_stat_size>
    4da2:	0101      	jmp	0x4fa6 <__mlx4_flash_start+0xfa6>
    4da4:	26ca      	or	X, [--PC]
    4da6:	26f1      	or	X, [Y+1]
    4da8:	623a      	lod	AL, [S-59]
    4daa:	a688      	or	A, io:0x8 <__bist_stat_size>
    4dac:	1101      	call	0x4fb0 <__mlx4_flash_start+0xfb0>
    4dae:	26f1      	or	X, [Y+1]
    4db0:	a781      	or	A, ep:0x81 <__data_size+0x7>
    4db2:	1105      	call	0x4fbe <__mlx4_flash_start+0xfbe>
    4db4:	626f      	lod	AL, [S-112]
    4db6:	0001      	jmp	0x4dba <__mlx4_flash_start+0xdba>
    4db8:	26ca      	or	X, [--PC]
    4dba:	b586      	and	A, dp:0x86 <_l_u16OBDValveStatusPosition>
    4dbc:	29d4      	sub	X, dp:0xd4 <_g_u16falg>
    4dbe:	b239      	adc	A, [S-58]
    4dc0:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4dc2:	110e      	call	0x4fe0 <__mlx4_flash_start+0xfe0>
    4dc4:	b680      	and	A, io:0x0 <__dp__>
    4dc6:	e24e      	add	Y, [S-79]
    4dc8:	1108      	call	0x4fda <__mlx4_flash_start+0xfda>
    4dca:	6259      	lod	AL, [S-90]
    4dcc:	6266      	lod	AL, [S-103]
    4dce:	0007      	jmp	0x4dde <__mlx4_flash_start+0xdde>
    4dd0:	b585      	and	A, dp:0x85 <_l_u8OBDValveStatusMove>
    4dd2:	b271      	adc	A, [S-114]
    4dd4:	7239      	lod	A, [S-58]
    4dd6:	b688      	and	A, io:0x8 <__bist_stat_size>
    4dd8:	2495      	or	X, #-107
    4dda:	724e      	lod	A, [S-79]
    4ddc:	6282      	lod	AL, io:0x2 <_LinCmnd>
    4dde:	26ca      	or	X, [--PC]
    4de0:	26ca      	or	X, [--PC]
    4de2:	b33a      	adc	A, ep:0x3a <_g_u16MicroStepIdx>
    4de4:	f782      	and	Y, ep:0x82 <_targetPos>
    4de6:	733a      	lod	A, ep:0x3a <_g_u16MicroStepIdx>
    4de8:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    4dea:	7c4c      	lod	X, #76
    4dec:	3805      	subc	X, #5
    4dee:	3808      	subc	X, #8
    4df0:	3906      	subc	X, dp:0x6 <_LinMess2>
    4df2:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4df4:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    4df6:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    4df8:	b580      	and	A, dp:0x80 <__data_size+0x6>
    4dfa:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    4dfc:	b589      	and	A, dp:0x89 <_l_u8OBDValveStatusVolt>
    4dfe:	580a      	inc	S, #11
    4e00:	0904      	clrb	io:0x00.4
    4e02:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    4e04:	62e6      	lod	AL, Y
    4e06:	b172      	adc	A, dp:0x72 <__bss_dp_end>
    4e08:	26ff      	or	X, [X+7]
    4e0a:	623a      	lod	AL, [S-59]
    4e0c:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4e0e:	4008      	jmp	fp0:0x40
    4e10:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    4e12:	a58f      	or	A, dp:0x8f <_s_CVRequestStruct+0x1>
    4e14:	0101      	jmp	0x5018 <__mlx4_flash_start+0x1018>
    4e16:	2726      	or	X, ep:0x26 <_l_u8StallCountA>
    4e18:	1409      	call	0x462c <__mlx4_flash_start+0x62c>
    4e1a:	3807      	subc	X, #7
    4e1c:	380e      	subc	X, #14
    4e1e:	3430      	and	X, #48
    4e20:	27bd      	or	X, ep:0xbd <_g_u8AdcIsrMode>
    4e22:	b239      	adc	A, [S-58]
    4e24:	7238      	lod	A, [S-57]
    4e26:	b68b      	and	A, io:0xb <__bist_stat_size+0x3>
    4e28:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e2a:	24a3      	or	X, #-93
    4e2c:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    4e2e:	b239      	adc	A, [S-58]
    4e30:	7238      	lod	A, [S-57]
    4e32:	4040      	jmp	fp2:0x00
    4e34:	624a      	lod	AL, [S-75]
    4e36:	1504      	call	0x4840 <__mlx4_flash_start+0x840>
    4e38:	b23b      	adc	A, [S-60]
    4e3a:	f681      	and	Y, io:0x1 <__dp__+0x1>
    4e3c:	723b      	lod	A, [S-60]
    4e3e:	24a3      	or	X, #-93
    4e40:	b23b      	adc	A, [S-60]
    4e42:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4e44:	723b      	lod	A, [S-60]
    4e46:	b687      	and	A, io:0x7 <_LinProtectedID>
    4e48:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e4a:	24a3      	or	X, #-93
    4e4c:	4060      	jmp	fp3:0x00
    4e4e:	624a      	lod	AL, [S-75]
    4e50:	e589      	or	Y, dp:0x89 <_l_u8OBDValveStatusVolt>
    4e52:	1109      	call	0x5066 <__mlx4_flash_start+0x1066>
    4e54:	b339      	adc	A, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4e56:	e78f      	or	Y, ep:0x8f <_s_CVRequestStruct+0x1>
    4e58:	010a      	jmp	0x506e <__mlx4_flash_start+0x106e>
    4e5a:	1409      	call	0x466e <__mlx4_flash_start+0x66e>
    4e5c:	b686      	and	A, io:0x6 <_LinMess2>
    4e5e:	7338      	lod	A, ep:0x38 <_g_u16CorrectionRatio>
    4e60:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4e62:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4e64:	24a3      	or	X, #-93
    4e66:	4060      	jmp	fp3:0x00
    4e68:	622e      	lod	AL, [S-47]
    4e6a:	0501      	jmp	0x486e <__mlx4_flash_start+0x86e>
    4e6c:	2739      	or	X, ep:0x39 <_g_u16CorrectionRatio+0x1>
    4e6e:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4e70:	26ff      	or	X, [X+7]
    4e72:	e583      	or	Y, dp:0x83 <_targetPos+0x1>
    4e74:	1001      	call	0x4e78 <__mlx4_flash_start+0xe78>
    4e76:	274c      	or	X, ep:0x4c <_l_u16ActuatorBufferedTgtPos>
    4e78:	b791      	and	A, ep:0x91 <_s_CVRequestStruct+0x3>
    4e7a:	d78f      	and	AH, ep:0x8f <_s_CVRequestStruct+0x1>
    4e7c:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4e7e:	bf87      	xor	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    4e80:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    4e82:	4060      	jmp	fp3:0x00
    4e84:	4d62      	mov	dp:0x62 <_ml_driver_mode+0x4>, YH
    4e86:	4e87      	mov	io:0x7 <_LinProtectedID>, YH
    4e88:	b63d      	and	A, [S-62]
    4e8a:	721e      	lod	A, [S-31]
    4e8c:	4962      	mov	dp:0x62 <_ml_driver_mode+0x4>, AH
    4e8e:	4d2e      	mov	dp:0x2e <__data_dp_end+0x6>, YH
    4e90:	4e8b      	mov	io:0xb <__bist_stat_size+0x3>, YH
    4e92:	b63d      	and	A, [S-62]
    4e94:	721f      	lod	A, [S-32]
    4e96:	492e      	mov	dp:0x2e <__data_dp_end+0x6>, AH
    4e98:	7492      	lod	PC, #-110
    4e9a:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4e9c:	a581      	or	A, dp:0x81 <__data_size+0x7>
    4e9e:	1101      	call	0x50a2 <__mlx4_flash_start+0x10a2>
    4ea0:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    4ea2:	d245      	adc	AH, [S-70]
    4ea4:	7245      	lod	A, [S-70]
    4ea6:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    4ea8:	6c01      	lod	YH, #1
    4eaa:	2768      	or	X, ep:0x68 <_ml_driver_mode+0xa>
    4eac:	277b      	or	X, ep:0x7b <__data_size+0x1>
    4eae:	278a      	or	X, ep:0x8a <_l_u8OBDValveStatusFault>
    4eb0:	26ff      	or	X, [X+7]
    4eb2:	26ff      	or	X, [X+7]
    4eb4:	26ff      	or	X, [X+7]
    4eb6:	26ff      	or	X, [X+7]
    4eb8:	275e      	or	X, ep:0x5e <_ml_driver_mode>
    4eba:	26ff      	or	X, [X+7]
    4ebc:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ebe:	a781      	or	A, ep:0x81 <__data_size+0x7>
    4ec0:	0106      	jmp	0x50ce <__mlx4_flash_start+0x10ce>
    4ec2:	b780      	and	A, ep:0x80 <__data_size+0x6>
    4ec4:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ec6:	b271      	adc	A, [S-114]
    4ec8:	7238      	lod	A, [S-57]
    4eca:	b68c      	and	A, io:0xc <__bist_stat_size+0x4>
    4ecc:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4ece:	26ff      	or	X, [X+7]
    4ed0:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4ed2:	730e      	lod	A, ep:0xe <__bist_stat_size+0x6>
    4ed4:	bf82      	xor	A, ep:0x82 <_targetPos>
    4ed6:	d345      	adc	AH, ep:0x45 <_g_e8MotorDirectionCCW+0x1>
    4ed8:	b209      	adc	A, [S-10]
    4eda:	720f      	lod	A, [S-16]
    4edc:	be81      	xor	A, io:0x1 <__dp__+0x1>
    4ede:	d792      	and	AH, ep:0x92 <_s_CVRequestStruct+0x4>
    4ee0:	1101      	call	0x50e4 <__mlx4_flash_start+0x10e4>
    4ee2:	26ff      	or	X, [X+7]
    4ee4:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    4ee6:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    4ee8:	b638      	and	A, [S-57]
    4eea:	a688      	or	A, io:0x8 <__bist_stat_size>
    4eec:	1103      	call	0x50f4 <__mlx4_flash_start+0x10f4>
    4eee:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ef0:	f784      	and	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4ef2:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    4ef4:	24a3      	or	X, #-93
    4ef6:	b30d      	adc	A, ep:0xd <__bist_stat_size+0x5>
    4ef8:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4efa:	0102      	jmp	0x5100 <__mlx4_flash_start+0x1100>
    4efc:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4efe:	26ff      	or	X, [X+7]
    4f00:	b360      	adc	A, ep:0x60 <_ml_driver_mode+0x2>
    4f02:	b161      	adc	A, dp:0x61 <_ml_driver_mode+0x3>
    4f04:	f580      	and	Y, dp:0x80 <__data_size+0x6>
    4f06:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f08:	7260      	lod	A, [S-97]
    4f0a:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    4f0c:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f0e:	7261      	lod	A, [S-98]
    4f10:	b581      	and	A, dp:0x81 <__data_size+0x7>
    4f12:	26ff      	or	X, [X+7]
    4f14:	b209      	adc	A, [S-10]
    4f16:	e68f      	or	Y, io:0xf <__bist_stat_size+0x7>
    4f18:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4f1a:	1102      	call	0x5120 <__mlx4_flash_start+0x1120>
    4f1c:	f781      	and	Y, ep:0x81 <__data_size+0x7>
    4f1e:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4f20:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    4f22:	4610      	mov	[S-17], YL
    4f24:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4f26:	4610      	mov	[S-17], YL
    4f28:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    4f2a:	720d      	lod	A, [S-14]
    4f2c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f2e:	b31e      	adc	A, ep:0x1e <__ramfunc_size>
    4f30:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4f32:	0104      	jmp	0x513c <__mlx4_flash_start+0x113c>
    4f34:	b31f      	adc	A, ep:0x1f <__ramfunc_size+0x1>
    4f36:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4f38:	1105      	call	0x5144 <__mlx4_flash_start+0x1144>
    4f3a:	8788      	or	AL, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4f3c:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f3e:	b680      	and	A, io:0x0 <__dp__>
    4f40:	720d      	lod	A, [S-14]
    4f42:	27b5      	or	X, ep:0xb5 <_g_i16MotorVoltage+0x1>
    4f44:	3bea      	subc	X, ep:0xea <_LINBaud>
    4f46:	b30c      	adc	A, ep:0xc <__bist_stat_size+0x4>
    4f48:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f4a:	4050      	jmp	fp2:0x80
    4f4c:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    4f4e:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    4f50:	f588      	and	Y, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4f52:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    4f54:	a68c      	or	A, io:0xc <__bist_stat_size+0x4>
    4f56:	0105      	jmp	0x5162 <__mlx4_flash_start+0x1162>
    4f58:	b20d      	adc	A, [S-14]
    4f5a:	f688      	and	Y, io:0x8 <__bist_stat_size>
    4f5c:	720d      	lod	A, [S-14]
    4f5e:	b582      	and	A, dp:0x82 <_targetPos>
    4f60:	26ff      	or	X, [X+7]
    4f62:	720d      	lod	A, [S-14]
    4f64:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    4f66:	b7a7      	and	A, ep:0xa7 <_l_u8RamPreError+0x3>
    4f68:	730c      	lod	A, ep:0xc <__bist_stat_size+0x4>
    4f6a:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f6c:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    4f6e:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    4f70:	3beb      	subc	X, ep:0xeb <_LINBaud+0x1>
    4f72:	7360      	lod	A, ep:0x60 <_ml_driver_mode+0x2>
    4f74:	7161      	lod	A, dp:0x61 <_ml_driver_mode+0x3>
    4f76:	b582      	and	A, dp:0x82 <_targetPos>
    4f78:	26ff      	or	X, [X+7]
    4f7a:	1501      	call	0x497e <__mlx4_flash_start+0x97e>
    4f7c:	2800      	sub	X, #0
    4f7e:	b35c      	adc	A, ep:0x5c <_LinMessage>
    4f80:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4f82:	1109      	call	0x5196 <__mlx4_flash_start+0x1196>
    4f84:	f784      	and	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4f86:	735c      	lod	A, ep:0x5c <_LinMessage>
    4f88:	4804      	mulu	D, A, [Y++]
    4f8a:	b73e      	and	A, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    4f8c:	7307      	lod	A, ep:0x7 <_LinProtectedID>
    4f8e:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4f90:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4f92:	0101      	jmp	0x5196 <__mlx4_flash_start+0x1196>
    4f94:	24a3      	or	X, #-93
    4f96:	5cc2      	neg	A
    4f98:	b10d      	adc	A, dp:0xd <__bist_stat_size+0x5>
    4f9a:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4f9c:	0103      	jmp	0x51a4 <__mlx4_flash_start+0x11a4>
    4f9e:	7ca8      	lod	X, #-88
    4fa0:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    4fa2:	24a3      	or	X, #-93
    4fa4:	b261      	adc	A, [S-98]
    4fa6:	4600      	mov	[S-1], YL
    4fa8:	e681      	or	Y, io:0x1 <__dp__+0x1>
    4faa:	0104      	jmp	0x51b4 <__mlx4_flash_start+0x11b4>
    4fac:	0001      	jmp	0x4fb0 <__mlx4_flash_start+0xfb0>
    4fae:	24a3      	or	X, #-93
    4fb0:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    4fb2:	27e7      	or	X, ep:0xe7 <_g_i16PID_D+0x1>
    4fb4:	5c00      	dec	S
    4fb6:	b35f      	adc	A, ep:0x5f <_ml_driver_mode+0x1>
    4fb8:	a783      	or	A, ep:0x83 <_targetPos+0x1>
    4fba:	1103      	call	0x51c2 <__mlx4_flash_start+0x11c2>
    4fbc:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4fbe:	bf83      	xor	A, ep:0x83 <_targetPos+0x1>
    4fc0:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    4fc2:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    4fc4:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    4fc6:	1102      	call	0x51cc <__mlx4_flash_start+0x11cc>
    4fc8:	b784      	and	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    4fca:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    4fcc:	b781      	and	A, ep:0x81 <__data_size+0x7>
    4fce:	b260      	adc	A, [S-97]
    4fd0:	725b      	lod	A, [S-92]
    4fd2:	be87      	xor	A, io:0x7 <_LinProtectedID>
    4fd4:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fd6:	724c      	lod	A, [S-77]
    4fd8:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fda:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4fdc:	8681      	or	AL, io:0x1 <__dp__+0x1>
    4fde:	b556      	and	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4fe0:	7137      	lod	A, dp:0x37 <_g_DiagResponse+0x7>
    4fe2:	c681      	or	AH, io:0x1 <__dp__+0x1>
    4fe4:	b556      	and	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    4fe6:	7136      	lod	A, dp:0x36 <_g_DiagResponse+0x6>
    4fe8:	b25b      	adc	A, [S-92]
    4fea:	be88      	xor	A, io:0x8 <__bist_stat_size>
    4fec:	4788      	mov	ep:0x88 <_l_u8OBDValveStatusOverTempWarn>, YL
    4fee:	f693      	and	Y, io:0x13 <__data_dp_size+0x3>
    4ff0:	725b      	lod	A, [S-92]
    4ff2:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    4ff4:	0002      	jmp	0x4ffa <__mlx4_flash_start+0xffa>
    4ff6:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    4ff8:	27fe      	or	X, ep:0xfe <_l_au8FiFoErrorLog>
    4ffa:	4d08      	mov	dp:0x8 <__bist_stat_size>, YH
    4ffc:	490a      	mov	dp:0xa <__bist_stat_size+0x2>, AH
    4ffe:	281f      	sub	X, #31
    5000:	b239      	adc	A, [S-58]
    5002:	a68f      	or	A, io:0xf <__bist_stat_size+0x7>
    5004:	0101      	jmp	0x5208 <__mlx4_flash_start+0x1208>
    5006:	2814      	sub	X, #20
    5008:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    500a:	a782      	or	A, ep:0x82 <_targetPos>
    500c:	0103      	jmp	0x5214 <__mlx4_flash_start+0x1214>
    500e:	b689      	and	A, io:0x9 <__bist_stat_size+0x1>
    5010:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    5012:	24a3      	or	X, #-93
    5014:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    5016:	a781      	or	A, ep:0x81 <__data_size+0x7>
    5018:	0107      	jmp	0x5228 <__mlx4_flash_start+0x1228>
    501a:	b108      	adc	A, dp:0x8 <__bist_stat_size>
    501c:	e580      	or	Y, dp:0x80 <__data_size+0x6>
    501e:	b109      	adc	A, dp:0x9 <__bist_stat_size+0x1>
    5020:	ed80      	cmp	Y, dp:0x80 <__data_size+0x6>
    5022:	1102      	call	0x5228 <__mlx4_flash_start+0x1228>
    5024:	f782      	and	Y, ep:0x82 <_targetPos>
    5026:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5028:	e24c      	add	Y, [S-77]
    502a:	0109      	jmp	0x523e <__mlx4_flash_start+0x123e>
    502c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    502e:	bf87      	xor	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    5030:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5032:	4692      	mov	io:0x12 <__data_dp_size+0x2>, YL
    5034:	b308      	adc	A, ep:0x8 <__bist_stat_size>
    5036:	77e6      	lod	PC, ep:0xe6 <_g_i16PID_D>
    5038:	8681      	or	AL, io:0x1 <__dp__+0x1>
    503a:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    503c:	77e6      	lod	PC, ep:0xe6 <_g_i16PID_D>
    503e:	b139      	adc	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5040:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    5042:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5044:	1106      	call	0x5252 <__mlx4_flash_start+0x1252>
    5046:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    5048:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    504a:	b35b      	adc	A, ep:0x5b <_LIN_nad+0x1>
    504c:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    504e:	1107      	call	0x525e <__mlx4_flash_start+0x125e>
    5050:	2849      	sub	X, #73
    5052:	b208      	adc	A, [S-9]
    5054:	b309      	adc	A, ep:0x9 <__bist_stat_size+0x1>
    5056:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    5058:	e14c      	add	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    505a:	0105      	jmp	0x5266 <__mlx4_flash_start+0x1266>
    505c:	6233      	lod	AL, [S-52]
    505e:	7cce      	lod	X, #-50
    5060:	7d08      	lod	X, dp:0x8 <__bist_stat_size>
    5062:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5064:	26ca      	or	X, [--PC]
    5066:	820a      	add	AL, [S-11]
    5068:	8b0b      	sub	AL, ep:0xb <__bist_stat_size+0x3>
    506a:	8681      	or	AL, io:0x1 <__dp__+0x1>
    506c:	8f80      	cmp	AL, ep:0x80 <__data_size+0x6>
    506e:	0103      	jmp	0x5276 <__mlx4_flash_start+0x1276>
    5070:	b684      	and	A, io:0x4 <_LinMess>
    5072:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    5074:	24a3      	or	X, #-93
    5076:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    5078:	a782      	or	A, ep:0x82 <_targetPos>
    507a:	0105      	jmp	0x5286 <__mlx4_flash_start+0x1286>
    507c:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    507e:	bf8d      	xor	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    5080:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    5082:	b581      	and	A, dp:0x81 <__data_size+0x7>
    5084:	29d4      	sub	X, dp:0xd4 <_g_u16falg>
    5086:	b35e      	adc	A, ep:0x5e <_ml_driver_mode>
    5088:	f782      	and	Y, ep:0x82 <_targetPos>
    508a:	735e      	lod	A, ep:0x5e <_ml_driver_mode>
    508c:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    508e:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    5090:	24a3      	or	X, #-93
    5092:	b58f      	and	A, dp:0x8f <_s_CVRequestStruct+0x1>
    5094:	7139      	lod	A, dp:0x39 <_g_u16CorrectionRatio+0x1>
    5096:	b580      	and	A, dp:0x80 <__data_size+0x6>
    5098:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    509a:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    509c:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    509e:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    50a0:	b738      	and	A, ep:0x38 <_g_u16CorrectionRatio>
    50a2:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    50a4:	110b      	call	0x52bc <__mlx4_flash_start+0x12bc>
    50a6:	b239      	adc	A, [S-58]
    50a8:	7238      	lod	A, [S-57]
    50aa:	b685      	and	A, io:0x5 <_LinMess+0x1>
    50ac:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    50ae:	b23b      	adc	A, [S-60]
    50b0:	f684      	and	Y, io:0x4 <_LinMess>
    50b2:	723b      	lod	A, [S-60]
    50b4:	b25e      	adc	A, [S-95]
    50b6:	be8d      	xor	A, io:0xd <__bist_stat_size+0x5>
    50b8:	725e      	lod	A, [S-95]
    50ba:	24a1      	or	X, #-95
    50bc:	3805      	subc	X, #5
    50be:	3808      	subc	X, #8
    50c0:	346b      	and	X, #107
    50c2:	34b0      	and	X, #-80
    50c4:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    50c6:	b34c      	adc	A, ep:0x4c <_l_u16ActuatorBufferedTgtPos>
    50c8:	c781      	or	AH, ep:0x81 <__data_size+0x7>
    50ca:	4796      	mov	ep:0x96 <_l_u8MotorControl>, YL
    50cc:	b65b      	and	A, [S-92]
    50ce:	7236      	lod	A, [S-55]
    50d0:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    50d2:	b65b      	and	A, [S-92]
    50d4:	7237      	lod	A, [S-56]
    50d6:	b364      	adc	A, ep:0x64 <_ml_driver_mode+0x6>
    50d8:	bf84      	xor	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    50da:	0101      	jmp	0x52de <__mlx4_flash_start+0x12de>
    50dc:	b581      	and	A, dp:0x81 <__data_size+0x7>
    50de:	858a      	or	AL, dp:0x8a <_l_u8OBDValveStatusFault>
    50e0:	715d      	lod	A, dp:0x5d <_LinMessage+0x1>
    50e2:	b164      	adc	A, dp:0x64 <_ml_driver_mode+0x6>
    50e4:	bd83      	xor	A, dp:0x83 <_targetPos+0x1>
    50e6:	8582      	or	AL, dp:0x82 <_targetPos>
    50e8:	714d      	lod	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    50ea:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    50ec:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    50ee:	5c00      	dec	S
    50f0:	0101      	jmp	0x52f4 <__mlx4_flash_start+0x12f4>
    50f2:	5c02      	dec	S, #3
    50f4:	580e      	inc	S, #15
    50f6:	0809      	clrb	dp:0x01.1
    50f8:	090c      	clrb	io:0x01.4
    50fa:	62e6      	lod	AL, Y
    50fc:	b16f      	adc	A, dp:0x6f <_ml_driver_mode+0x11>
    50fe:	a588      	or	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    5100:	1103      	call	0x5308 <__mlx4_flash_start+0x1308>
    5102:	a584      	or	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5104:	0105      	jmp	0x5310 <__mlx4_flash_start+0x1310>
    5106:	24a3      	or	X, #-93
    5108:	2892      	sub	X, #-110
    510a:	623a      	lod	AL, [S-59]
    510c:	a688      	or	A, io:0x8 <__bist_stat_size>
    510e:	0106      	jmp	0x531c <__mlx4_flash_start+0x131c>
    5110:	287a      	sub	X, #122
    5112:	623a      	lod	AL, [S-59]
    5114:	a788      	or	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    5116:	1102      	call	0x531c <__mlx4_flash_start+0x131c>
    5118:	be88      	xor	A, io:0x8 <__bist_stat_size>
    511a:	1101      	call	0x531e <__mlx4_flash_start+0x131e>
    511c:	2853      	sub	X, #83
    511e:	a781      	or	A, ep:0x81 <__data_size+0x7>
    5120:	1107      	call	0x5330 <__mlx4_flash_start+0x1330>
    5122:	287a      	sub	X, #122
    5124:	b14d      	adc	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5126:	e580      	or	Y, dp:0x80 <__data_size+0x6>
    5128:	1101      	call	0x532c <__mlx4_flash_start+0x132c>
    512a:	28a6      	sub	X, #-90
    512c:	5cc2      	neg	A
    512e:	287a      	sub	X, #122
    5130:	6241      	lod	AL, [S-66]
    5132:	0001      	jmp	0x5136 <__mlx4_flash_start+0x1136>
    5134:	2711      	or	X, ep:0x11 <__data_dp_size+0x1>
    5136:	b14d      	adc	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5138:	a581      	or	A, dp:0x81 <__data_size+0x7>
    513a:	1101      	call	0x533e <__mlx4_flash_start+0x133e>
    513c:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    513e:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    5140:	8d80      	cmp	AL, dp:0x80 <__data_size+0x6>
    5142:	714d      	lod	A, dp:0x4d <_l_u16ActuatorBufferedTgtPos+0x1>
    5144:	e580      	or	Y, dp:0x80 <__data_size+0x6>
    5146:	1101      	call	0x534a <__mlx4_flash_start+0x134a>
    5148:	0501      	jmp	0x4b4c <__mlx4_flash_start+0xb4c>
    514a:	287a      	sub	X, #122
    514c:	b36f      	adc	A, ep:0x6f <_ml_driver_mode+0x11>
    514e:	bf87      	xor	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    5150:	736f      	lod	A, ep:0x6f <_ml_driver_mode+0x11>
    5152:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    5154:	3468      	and	X, #104
    5156:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5158:	b203      	adc	A, [S-4]
    515a:	4610      	mov	[S-17], YL
    515c:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    515e:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    5160:	724f      	lod	A, [S-80]
    5162:	4c4f      	dadju	D, [X]
    5164:	6217      	lod	AL, [S-24]
    5166:	6233      	lod	AL, [S-52]
    5168:	b582      	and	A, dp:0x82 <_targetPos>
    516a:	7170      	lod	A, dp:0x70 <_ml_driver_mode+0x12>
    516c:	b580      	and	A, dp:0x80 <__data_size+0x6>
    516e:	484f      	macu	D, AL, [X]
    5170:	380a      	subc	X, #10
    5172:	3420      	and	X, #32
    5174:	3965      	subc	X, dp:0x65 <_ml_driver_mode+0x7>
    5176:	3501      	and	X, dp:0x1 <__dp__+0x1>
    5178:	37a4      	and	X, ep:0xa4 <_l_u8RamPreError>
    517a:	346b      	and	X, #107
    517c:	5806      	inc	S, #7
    517e:	090e      	clrb	io:0x01.6
    5180:	623a      	lod	AL, [S-59]
    5182:	484f      	macu	D, AL, [X]
    5184:	b302      	adc	A, ep:0x2 <_LinCmnd>
    5186:	b203      	adc	A, [S-4]
    5188:	4610      	mov	[S-17], YL
    518a:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    518c:	834e      	add	AL, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    518e:	8a4f      	sub	AL, [S-80]
    5190:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    5192:	724f      	lod	A, [S-80]
    5194:	4c4f      	dadju	D, [X]
    5196:	3409      	and	X, #9
    5198:	3808      	subc	X, #8
    519a:	28eb      	sub	X, #-21
    519c:	623a      	lod	AL, [S-59]
    519e:	a688      	or	A, io:0x8 <__bist_stat_size>
    51a0:	1101      	call	0x53a4 <__mlx4_flash_start+0x13a4>
    51a2:	28fb      	sub	X, #-5
    51a4:	351b      	and	X, dp:0x1b <_g_u8NAD>
    51a6:	b582      	and	A, dp:0x82 <_targetPos>
    51a8:	b682      	and	A, io:0x2 <_LinCmnd>
    51aa:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    51ac:	b681      	and	A, io:0x1 <__dp__+0x1>
    51ae:	7201      	lod	A, [S-2]
    51b0:	2487      	or	X, #-121
    51b2:	6217      	lod	AL, [S-24]
    51b4:	b580      	and	A, dp:0x80 <__data_size+0x6>
    51b6:	0007      	jmp	0x51c6 <__mlx4_flash_start+0x11c6>
    51b8:	1107      	call	0x53c8 <__mlx4_flash_start+0x13c8>
    51ba:	d68f      	and	AH, io:0xf <__bist_stat_size+0x7>
    51bc:	d78f      	and	AH, ep:0x8f <_s_CVRequestStruct+0x1>
    51be:	7234      	lod	A, [S-53]
    51c0:	7335      	lod	A, ep:0x35 <_g_DiagResponse+0x5>
    51c2:	6228      	lod	AL, [S-41]
    51c4:	28e5      	sub	X, #-27
    51c6:	2906      	sub	X, dp:0x6 <_LinMess2>
    51c8:	6233      	lod	AL, [S-52]
    51ca:	4040      	jmp	fp2:0x00
    51cc:	3501      	and	X, dp:0x1 <__dp__+0x1>
    51ce:	580a      	inc	S, #11
    51d0:	0902      	clrb	io:0x00.2
    51d2:	62e6      	lod	AL, Y
    51d4:	28e7      	sub	X, #-25
    51d6:	623a      	lod	AL, [S-59]
    51d8:	a684      	or	A, io:0x4 <_LinMess>
    51da:	110d      	call	0x53f6 <__mlx4_flash_start+0x13f6>
    51dc:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    51de:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    51e0:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    51e2:	624a      	lod	AL, [S-75]
    51e4:	6346      	lod	AL, ep:0x46 <_g_u16ActuatorActPos>
    51e6:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    51e8:	e15d      	add	Y, dp:0x5d <_LinMessage+0x1>
    51ea:	0109      	jmp	0x53fe <__mlx4_flash_start+0x13fe>
    51ec:	622e      	lod	AL, [S-47]
    51ee:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    51f0:	4784      	mov	ep:0x84 <_l_u8OBDValveStatusSpeedLevel>, YL
    51f2:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    51f4:	28e6      	sub	X, #-26
    51f6:	4040      	jmp	fp2:0x00
    51f8:	624a      	lod	AL, [S-75]
    51fa:	351b      	and	X, dp:0x1b <_g_u8NAD>
    51fc:	2853      	sub	X, #83
    51fe:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    5200:	4040      	jmp	fp2:0x00
    5202:	4784      	mov	ep:0x84 <_l_u8OBDValveStatusSpeedLevel>, YL
    5204:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    5206:	7ccf      	lod	X, #-49
    5208:	7d34      	lod	X, dp:0x34 <_g_DiagResponse+0x4>
    520a:	28d9      	sub	X, #-39
    520c:	351b      	and	X, dp:0x1b <_g_u8NAD>
    520e:	580a      	inc	S, #11
    5210:	0902      	clrb	io:0x00.2
    5212:	62e6      	lod	AL, Y
    5214:	2907      	sub	X, dp:0x7 <_LinProtectedID>
    5216:	623a      	lod	AL, [S-59]
    5218:	a684      	or	A, io:0x4 <_LinMess>
    521a:	0101      	jmp	0x541e <__mlx4_flash_start+0x141e>
    521c:	28fb      	sub	X, #-5
    521e:	b15f      	adc	A, dp:0x5f <_ml_driver_mode+0x1>
    5220:	a583      	or	A, dp:0x83 <_targetPos+0x1>
    5222:	1103      	call	0x542a <__mlx4_flash_start+0x142a>
    5224:	b100      	adc	A, dp:0x0 <__dp__>
    5226:	a581      	or	A, dp:0x81 <__data_size+0x7>
    5228:	0102      	jmp	0x542e <__mlx4_flash_start+0x142e>
    522a:	b785      	and	A, ep:0x85 <_l_u8OBDValveStatusMove>
    522c:	62bc      	lod	AL, io:0x3c <_g_u16CommutTimerPeriod>
    522e:	24a3      	or	X, #-93
    5230:	3807      	subc	X, #7
    5232:	3809      	subc	X, #9
    5234:	3468      	and	X, #104
    5236:	6282      	lod	AL, io:0x2 <_LinCmnd>
    5238:	b638      	and	A, [S-57]
    523a:	a688      	or	A, io:0x8 <__bist_stat_size>
    523c:	0101      	jmp	0x5440 <__mlx4_flash_start+0x1440>
    523e:	2494      	or	X, #-108
    5240:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5242:	b68e      	and	A, io:0xe <__bist_stat_size+0x6>
    5244:	7201      	lod	A, [S-2]
    5246:	b68a      	and	A, io:0xa <__bist_stat_size+0x2>
    5248:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    524a:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    524c:	580e      	inc	S, #15
    524e:	0803      	clrb	dp:0x00.3
    5250:	0906      	clrb	io:0x00.6
    5252:	62e6      	lod	AL, Y
    5254:	2926      	sub	X, dp:0x26 <_l_u8StallCountA>
    5256:	623a      	lod	AL, [S-59]
    5258:	a688      	or	A, io:0x8 <__bist_stat_size>
    525a:	010a      	jmp	0x5470 <__mlx4_flash_start+0x1470>
    525c:	248c      	or	X, #-116
    525e:	626f      	lod	AL, [S-112]
    5260:	1007      	call	0x5270 <__mlx4_flash_start+0x1270>
    5262:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    5264:	b684      	and	A, io:0x4 <_LinMess>
    5266:	62ca      	lod	AL, [--PC]
    5268:	628e      	lod	AL, io:0xe <__bist_stat_size+0x6>
    526a:	b780      	and	A, ep:0x80 <__data_size+0x6>
    526c:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    526e:	2a05      	sub	X, [S-6]
    5270:	2926      	sub	X, dp:0x26 <_l_u8StallCountA>
    5272:	5c00      	dec	S
    5274:	b580      	and	A, dp:0x80 <__data_size+0x6>
    5276:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    5278:	4954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AH
    527a:	4956      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AH
    527c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    527e:	a78d      	or	A, ep:0x8d <_l_u8AliveRollingCounter+0x1>
    5280:	1103      	call	0x5488 <__mlx4_flash_start+0x1488>
    5282:	4940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, AH
    5284:	4942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, AH
    5286:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    5288:	b78e      	and	A, ep:0x8e <_s_CVRequestStruct>
    528a:	b763      	and	A, ep:0x63 <_ml_driver_mode+0x5>
    528c:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    528e:	b780      	and	A, ep:0x80 <__data_size+0x6>
    5290:	735a      	lod	A, ep:0x5a <_LIN_nad>
    5292:	736a      	lod	A, ep:0x6a <_ml_driver_mode+0xc>
    5294:	736b      	lod	A, ep:0x6b <_ml_driver_mode+0xd>
    5296:	b303      	adc	A, ep:0x3 <_LinCmnd+0x1>
    5298:	4710      	mov	ep:0x10 <__data_dp_size>, YL
    529a:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    529c:	b302      	adc	A, ep:0x2 <_LinCmnd>
    529e:	4716      	mov	ep:0x16 <__data_dp_size+0x6>, YL
    52a0:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    52a2:	4c4e      	dadju	D, [X++]
    52a4:	34ef      	and	X, #-17
    52a6:	3985      	subc	X, dp:0x85 <_l_u8OBDValveStatusMove>
    52a8:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    52aa:	4c4f      	dadju	D, [X]
    52ac:	484f      	macu	D, AL, [X]
    52ae:	3806      	subc	X, #6
    52b0:	380a      	subc	X, #10
    52b2:	3428      	and	X, #40
    52b4:	3beb      	subc	X, ep:0xeb <_LINBaud+0x1>
    52b6:	b780      	and	A, ep:0x80 <__data_size+0x6>
    52b8:	736d      	lod	A, ep:0x6d <_ml_driver_mode+0xf>
    52ba:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    52bc:	b6a7      	and	A, io:0x27 <_l_u8StallCountA+0x1>
    52be:	726e      	lod	A, [S-111]
    52c0:	b23b      	adc	A, [S-60]
    52c2:	a68d      	or	A, io:0xd <__bist_stat_size+0x5>
    52c4:	1103      	call	0x54cc <__mlx4_flash_start+0x14cc>
    52c6:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    52c8:	b78c      	and	A, ep:0x8c <_l_u8AliveRollingCounter>
    52ca:	735b      	lod	A, ep:0x5b <_LIN_nad+0x1>
    52cc:	2282      	add	X, io:0x2 <_LinCmnd>
    52ce:	622b      	lod	AL, [S-44]
    52d0:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    52d2:	3f88      	xor	X, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    52d4:	b680      	and	A, io:0x0 <__dp__>
    52d6:	7271      	lod	A, [S-114]
    52d8:	7c54      	lod	X, #84
    52da:	b307      	adc	A, ep:0x7 <_LinProtectedID>
    52dc:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    52de:	4c04      	add	D, [Y++]
    52e0:	3805      	subc	X, #5
    52e2:	3808      	subc	X, #8
    52e4:	3449      	and	X, #73
    52e6:	3906      	subc	X, dp:0x6 <_LinMess2>
    52e8:	3512      	and	X, dp:0x12 <__data_dp_size+0x2>
    52ea:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    52ec:	623a      	lod	AL, [S-59]
    52ee:	b58c      	and	A, dp:0x8c <_l_u8AliveRollingCounter>
    52f0:	b55d      	and	A, dp:0x5d <_LinMessage+0x1>
    52f2:	580a      	inc	S, #11
    52f4:	0902      	clrb	io:0x00.2
    52f6:	62e6      	lod	AL, Y
    52f8:	2979      	sub	X, dp:0x79 <__bss_dp_end+0x7>
    52fa:	623a      	lod	AL, [S-59]
    52fc:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    52fe:	0102      	jmp	0x5504 <__mlx4_flash_end+0x14>
    5300:	3502      	and	X, dp:0x2 <_LinCmnd>
    5302:	2979      	sub	X, dp:0x79 <__bss_dp_end+0x7>
    5304:	351b      	and	X, dp:0x1b <_g_u8NAD>
    5306:	b271      	adc	A, [S-114]
    5308:	8681      	or	AL, io:0x1 <__dp__+0x1>
    530a:	7271      	lod	A, [S-114]
    530c:	a681      	or	A, io:0x1 <__dp__+0x1>
    530e:	1105      	call	0x551a <__mlx4_flash_end+0x2a>
    5310:	e686      	or	Y, io:0x6 <_LinMess2>
    5312:	0101      	jmp	0x5516 <__mlx4_flash_end+0x26>
    5314:	296c      	sub	X, dp:0x6c <_ml_driver_mode+0xe>
    5316:	b584      	and	A, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5318:	29d4      	sub	X, dp:0xd4 <_g_u16falg>
    531a:	3809      	subc	X, #9
    531c:	5806      	inc	S, #7
    531e:	0902      	clrb	io:0x00.2
    5320:	623a      	lod	AL, [S-59]
    5322:	29b2      	sub	X, dp:0xb2 <_g_i16ChipTemperature>
    5324:	623a      	lod	AL, [S-59]
    5326:	a688      	or	A, io:0x8 <__bist_stat_size>
    5328:	0101      	jmp	0x552c <__mlx4_flash_end+0x3c>
    532a:	29b2      	sub	X, dp:0xb2 <_g_i16ChipTemperature>
    532c:	b580      	and	A, dp:0x80 <__data_size+0x6>
    532e:	7143      	lod	A, dp:0x43 <_g_u16MotorCurrentLPFx64+0x1>
    5330:	7144      	lod	A, dp:0x44 <_g_e8MotorDirectionCCW>
    5332:	b304      	adc	A, ep:0x4 <_LinMess>
    5334:	b205      	adc	A, [S-6]
    5336:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    5338:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    533a:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    533c:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    533e:	7241      	lod	A, [S-66]
    5340:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    5342:	4792      	mov	ep:0x92 <_s_CVRequestStruct+0x4>, YL
    5344:	4696      	mov	io:0x16 <__data_dp_size+0x6>, YL
    5346:	4596      	mov	dp:0x96 <_l_u8MotorControl>, YL
    5348:	8340      	add	AL, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    534a:	8a41      	sub	AL, [S-66]
    534c:	8942      	sub	AL, dp:0x42 <_g_u16MotorCurrentLPFx64>
    534e:	7340      	lod	A, ep:0x40 <_g_u16MotorCurrentMovAvgxN>
    5350:	7241      	lod	A, [S-66]
    5352:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    5354:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    5356:	b788      	and	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    5358:	b682      	and	A, io:0x2 <_LinCmnd>
    535a:	62ca      	lod	AL, [--PC]
    535c:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    535e:	f784      	and	Y, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5360:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    5362:	24a3      	or	X, #-93
    5364:	6281      	lod	AL, io:0x1 <__dp__+0x1>
    5366:	b271      	adc	A, [S-114]
    5368:	e685      	or	Y, io:0x5 <_LinMess+0x1>
    536a:	0103      	jmp	0x5572 <_INDXtbl+0x32>
    536c:	b784      	and	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    536e:	b585      	and	A, dp:0x85 <_l_u8OBDValveStatusMove>
    5370:	29bb      	sub	X, dp:0xbb <__bss_size+0x1>
    5372:	b786      	and	A, ep:0x86 <_l_u16OBDValveStatusPosition>
    5374:	b587      	and	A, dp:0x87 <_l_u16OBDValveStatusPosition+0x1>
    5376:	b763      	and	A, ep:0x63 <_ml_driver_mode+0x5>
    5378:	b561      	and	A, dp:0x61 <_ml_driver_mode+0x3>
    537a:	b683      	and	A, io:0x3 <_LinCmnd+0x1>
    537c:	77bc      	lod	PC, ep:0xbc <_l_u8AdcPowerOff>
    537e:	b682      	and	A, io:0x2 <_LinCmnd>
    5380:	75bc      	lod	PC, dp:0xbc <_l_u8AdcPowerOff>
    5382:	3b33      	subc	X, ep:0x33 <_g_DiagResponse+0x3>
    5384:	580f      	inc	S, #16
    5386:	080b      	clrb	dp:0x01.3
    5388:	0902      	clrb	io:0x00.2
    538a:	62e6      	lod	AL, Y
    538c:	29c2      	sub	X, dp:0xc2 <_l_u16CoilZeroCurrCountB>
    538e:	623a      	lod	AL, [S-59]
    5390:	a688      	or	A, io:0x8 <__bist_stat_size>
    5392:	0105      	jmp	0x559e <_INDXtbl+0x5e>
    5394:	b726      	and	A, ep:0x26 <_l_u8StallCountA>
    5396:	bf8f      	xor	A, ep:0x8f <_s_CVRequestStruct+0x1>
    5398:	0101      	jmp	0x559c <_INDXtbl+0x5c>
    539a:	2982      	sub	X, dp:0x82 <_targetPos>
    539c:	29c2      	sub	X, dp:0xc2 <_l_u16CoilZeroCurrCountB>
    539e:	623a      	lod	AL, [S-59]
    53a0:	b785      	and	A, ep:0x85 <_l_u8OBDValveStatusMove>
    53a2:	b682      	and	A, io:0x2 <_LinCmnd>
    53a4:	62ca      	lod	AL, [--PC]
    53a6:	24a3      	or	X, #-93
    53a8:	7172      	lod	A, dp:0x72 <__bss_dp_end>
    53aa:	b738      	and	A, ep:0x38 <_g_u16CorrectionRatio>
    53ac:	7370      	lod	A, ep:0x70 <_ml_driver_mode+0x12>
    53ae:	b787      	and	A, ep:0x87 <_l_u16OBDValveStatusPosition+0x1>
    53b0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53b2:	734f      	lod	A, ep:0x4f <_l_u16ActuatorBufferedSpdRPM+0x1>
    53b4:	b786      	and	A, ep:0x86 <_l_u16OBDValveStatusPosition>
    53b6:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53b8:	734e      	lod	A, ep:0x4e <_l_u16ActuatorBufferedSpdRPM>
    53ba:	4c4e      	dadju	D, [X++]
    53bc:	4c4f      	dadju	D, [X]
    53be:	b784      	and	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    53c0:	b75f      	and	A, ep:0x5f <_ml_driver_mode+0x1>
    53c2:	773e      	lod	PC, ep:0x3e <_g_u16TargetCommutTimerPeriod>
    53c4:	3469      	and	X, #105
    53c6:	3807      	subc	X, #7
    53c8:	380a      	subc	X, #10
    53ca:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    53cc:	b585      	and	A, dp:0x85 <_l_u8OBDValveStatusMove>
    53ce:	b55d      	and	A, dp:0x5d <_LinMessage+0x1>
    53d0:	8581      	or	AL, dp:0x81 <__data_size+0x7>
    53d2:	580e      	inc	S, #15
    53d4:	0803      	clrb	dp:0x00.3
    53d6:	0906      	clrb	io:0x00.6
    53d8:	62e6      	lod	AL, Y
    53da:	29e9      	sub	X, dp:0xe9 <_LINPresc+0x1>
    53dc:	623a      	lod	AL, [S-59]
    53de:	be88      	xor	A, io:0x8 <__bist_stat_size>
    53e0:	110c      	call	0x55fa <_start+0x12>
    53e2:	2a3c      	sub	X, [S-61]
    53e4:	627c      	lod	AL, [S-125]
    53e6:	0101      	jmp	0x55ea <_start+0x2>
    53e8:	29e9      	sub	X, dp:0xe9 <_LINPresc+0x1>
    53ea:	623a      	lod	AL, [S-59]
    53ec:	c581      	or	AH, dp:0x81 <__data_size+0x7>
    53ee:	0107      	jmp	0x55fe <_start+0x16>
    53f0:	bf84      	xor	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    53f2:	1104      	call	0x55fc <_start+0x14>
    53f4:	a681      	or	A, io:0x1 <__dp__+0x1>
    53f6:	1102      	call	0x55fc <_start+0x14>
    53f8:	29ef      	sub	X, dp:0xef <_l_u16PhysicalTargetPos+0x1>
    53fa:	29e9      	sub	X, dp:0xe9 <_LINPresc+0x1>
    53fc:	29ef      	sub	X, dp:0xef <_l_u16PhysicalTargetPos+0x1>
    53fe:	b101      	adc	A, dp:0x1 <__dp__+0x1>
    5400:	e584      	or	Y, dp:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5402:	0103      	jmp	0x560a <__ram_section_init>
    5404:	b372      	adc	A, ep:0x72 <__bss_dp_end>
    5406:	b684      	and	A, io:0x4 <_LinMess>
    5408:	62ca      	lod	AL, [--PC]
    540a:	b365      	adc	A, ep:0x65 <_ml_driver_mode+0x7>
    540c:	a784      	or	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    540e:	1101      	call	0x5612 <__ram_section_init+0x8>
    5410:	2a1b      	sub	X, [S-28]
    5412:	3448      	and	X, #72
    5414:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    5416:	3804      	subc	X, #4
    5418:	3e40      	xor	X, [S-65]
    541a:	3f8c      	xor	X, ep:0x8c <_l_u8AliveRollingCounter>
    541c:	b723      	and	A, ep:0x23 <_l_u8VTIdx+0x1>
    541e:	bf84      	xor	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5420:	0105      	jmp	0x562c <__ram_section_init+0x22>
    5422:	623a      	lod	AL, [S-59]
    5424:	bf88      	xor	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    5426:	1101      	call	0x562a <__ram_section_init+0x20>
    5428:	2a0e      	sub	X, [S-15]
    542a:	2a3a      	sub	X, [S-59]
    542c:	3e98      	xor	X, io:0x18 <__data_dp_start>
    542e:	580b      	inc	S, #12
    5430:	090d      	clrb	io:0x01.5
    5432:	62e6      	lod	AL, Y
    5434:	2a17      	sub	X, [S-24]
    5436:	3468      	and	X, #104
    5438:	3790      	and	X, ep:0x90 <_s_CVRequestStruct+0x2>
    543a:	3806      	subc	X, #6
    543c:	380a      	subc	X, #10
    543e:	b370      	adc	A, ep:0x70 <_ml_driver_mode+0x12>
    5440:	bf88      	xor	A, ep:0x88 <_l_u8OBDValveStatusOverTempWarn>
    5442:	010d      	jmp	0x565e <_STACK_IT+0x12>
    5444:	b638      	and	A, [S-57]
    5446:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5448:	110a      	call	0x565e <_STACK_IT+0x12>
    544a:	2a3c      	sub	X, [S-61]
    544c:	627c      	lod	AL, [S-125]
    544e:	0101      	jmp	0x5652 <_STACK_IT+0x6>
    5450:	2a17      	sub	X, [S-24]
    5452:	b723      	and	A, ep:0x23 <_l_u8VTIdx+0x1>
    5454:	bf84      	xor	A, ep:0x84 <_l_u8OBDValveStatusSpeedLevel>
    5456:	110e      	call	0x5674 <_STACK_IT+0x28>
    5458:	623a      	lod	AL, [S-59]
    545a:	7c05      	lod	X, #5
    545c:	2a17      	sub	X, [S-24]
    545e:	580e      	inc	S, #15
    5460:	0805      	clrb	dp:0x00.5
    5462:	0902      	clrb	io:0x00.2
    5464:	62e6      	lod	AL, Y
    5466:	2a2f      	sub	X, [S-48]
    5468:	627c      	lod	AL, [S-125]
    546a:	2a2f      	sub	X, [S-48]
    546c:	623a      	lod	AL, [S-59]
    546e:	be88      	xor	A, io:0x8 <__bist_stat_size>
    5470:	0103      	jmp	0x5678 <_STACK_IT+0x2c>
    5472:	2a2f      	sub	X, [S-48]
    5474:	622b      	lod	AL, [S-44]
    5476:	2a72      	sub	X, [S-115]
    5478:	4d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, YH
    547a:	4930      	mov	dp:0x30 <_g_DiagResponse>, AH
    547c:	3449      	and	X, #73
    547e:	3809      	subc	X, #9
    5480:	3805      	subc	X, #5
    5482:	37a0      	and	X, ep:0xa0 <_l_u8OBDValveMechanicalError>
    5484:	3986      	subc	X, dp:0x86 <_l_u16OBDValveStatusPosition>
    5486:	580e      	inc	S, #15
    5488:	0803      	clrb	dp:0x00.3
    548a:	0903      	clrb	io:0x00.3
    548c:	62e6      	lod	AL, Y
    548e:	2a43      	sub	X, [S-68]
    5490:	2a60      	sub	X, [S-97]
    5492:	627c      	lod	AL, [S-125]
    5494:	0101      	jmp	0x5698 <__fatal+0xa>
    5496:	2a43      	sub	X, [S-68]
    5498:	623a      	lod	AL, [S-59]
    549a:	b330      	adc	A, ep:0x30 <_g_DiagResponse>
    549c:	b231      	adc	A, [S-50]
    549e:	8781      	or	AL, ep:0x81 <__data_size+0x7>
    54a0:	8e80      	cmp	AL, io:0x0 <__dp__>
    54a2:	7330      	lod	A, ep:0x30 <_g_DiagResponse>
    54a4:	7231      	lod	A, [S-50]
    54a6:	b588      	and	A, dp:0x88 <_l_u8OBDValveStatusOverTempWarn>
    54a8:	e75d      	or	Y, ep:0x5d <_LinMessage+0x1>
    54aa:	b589      	and	A, dp:0x89 <_l_u8OBDValveStatusVolt>
    54ac:	ee5d      	cmp	Y, [S-94]
    54ae:	1102      	call	0x56b4 <__fatal+0x26>
    54b0:	b782      	and	A, ep:0x82 <_targetPos>
    54b2:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54b4:	b58a      	and	A, dp:0x8a <_l_u8OBDValveStatusFault>
    54b6:	e75d      	or	Y, ep:0x5d <_LinMessage+0x1>
    54b8:	b58b      	and	A, dp:0x8b <_l_u8ValueFaultFlag>
    54ba:	ee5d      	cmp	Y, [S-94]
    54bc:	0001      	jmp	0x54c0 <__mlx4_flash_start+0x14c0>
    54be:	2918      	sub	X, dp:0x18 <__data_dp_start>
    54c0:	623a      	lod	AL, [S-59]
    54c2:	a688      	or	A, io:0x8 <__bist_stat_size>
    54c4:	1101      	call	0x56c8 <__fatal+0x3a>
    54c6:	2a43      	sub	X, [S-68]
    54c8:	b201      	adc	A, [S-2]
    54ca:	b33b      	adc	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54cc:	a782      	or	A, ep:0x82 <_targetPos>
    54ce:	1105      	call	0x56da <__fatal+0x4c>
    54d0:	7c05      	lod	X, #5
    54d2:	e684      	or	Y, io:0x4 <_LinMess>
    54d4:	0101      	jmp	0x56d8 <__fatal+0x4a>
    54d6:	29e2      	sub	X, dp:0xe2 <_g_u16MotorRefVoltage>
    54d8:	2a1b      	sub	X, [S-28]
    54da:	e684      	or	Y, io:0x4 <_LinMess>
    54dc:	0103      	jmp	0x56e4 <__fatal+0x56>
    54de:	b68f      	and	A, io:0xf <__bist_stat_size+0x7>
    54e0:	62b5      	lod	AL, io:0x35 <_g_DiagResponse+0x5>
    54e2:	24a3      	or	X, #-93
    54e4:	b783      	and	A, ep:0x83 <_targetPos+0x1>
    54e6:	b682      	and	A, io:0x2 <_LinCmnd>
    54e8:	62ca      	lod	AL, [--PC]
    54ea:	b780      	and	A, ep:0x80 <__data_size+0x6>
    54ec:	733b      	lod	A, ep:0x3b <_g_u16MicroStepIdx+0x1>
    54ee:	24a3      	or	X, #-93

Disassembly of section .mlx4_table:

00005540 <_INDXtbl>:
    5540:	c0c0      	add	AH, #-64
    5542:	c0c0      	add	AH, #-64
    5544:	c0c0      	add	AH, #-64
    5546:	c0c0      	add	AH, #-64
    5548:	c0c0      	add	AH, #-64
    554a:	c0c0      	add	AH, #-64
    554c:	c0c0      	add	AH, #-64
    554e:	c0c0      	add	AH, #-64
    5550:	c0c0      	add	AH, #-64
    5552:	c0c0      	add	AH, #-64
    5554:	c0c0      	add	AH, #-64
    5556:	c0c0      	add	AH, #-64
    5558:	c0c0      	add	AH, #-64
    555a:	c0c0      	add	AH, #-64
    555c:	c0c0      	add	AH, #-64
    555e:	c0c0      	add	AH, #-64
    5560:	c0c0      	add	AH, #-64
    5562:	c0c0      	add	AH, #-64
    5564:	c0c0      	add	AH, #-64
    5566:	c0c0      	add	AH, #-64
    5568:	c0c0      	add	AH, #-64
    556a:	c0c0      	add	AH, #-64
    556c:	c0c0      	add	AH, #-64
    556e:	c0c0      	add	AH, #-64
    5570:	c0c0      	add	AH, #-64
    5572:	c0c0      	add	AH, #-64
    5574:	c0c0      	add	AH, #-64
    5576:	c0c0      	add	AH, #-64
    5578:	c0c0      	add	AH, #-64
    557a:	c0c0      	add	AH, #-64
    557c:	1110      	call	0x579e <__prestart+0x84>
    557e:	c0c0      	add	AH, #-64
    5580:	0f2f      	lod	C, io:0x05.7
    5582:	a0a0      	add	A, #-96
    5584:	a0a0      	add	A, #-96
    5586:	a0a0      	add	A, #-96
    5588:	a0a0      	add	A, #-96
    558a:	a0a0      	add	A, #-96
    558c:	a0a0      	add	A, #-96
    558e:	a0a0      	add	A, #-96
    5590:	2707      	or	X, ep:0x7 <_LinProtectedID>
    5592:	a0a0      	add	A, #-96
    5594:	a0a0      	add	A, #-96
    5596:	a0a0      	add	A, #-96
    5598:	a0a0      	add	A, #-96
    559a:	a0a0      	add	A, #-96
    559c:	a0a0      	add	A, #-96
    559e:	a0a0      	add	A, #-96
    55a0:	a0a0      	add	A, #-96
    55a2:	a0a0      	add	A, #-96
    55a4:	a0a0      	add	A, #-96
    55a6:	a0a0      	add	A, #-96
    55a8:	a0a0      	add	A, #-96
    55aa:	a0a0      	add	A, #-96
    55ac:	a0a0      	add	A, #-96
    55ae:	a0a0      	add	A, #-96
    55b0:	a0a0      	add	A, #-96
    55b2:	a0a0      	add	A, #-96
    55b4:	a0a0      	add	A, #-96
    55b6:	a0a0      	add	A, #-96
    55b8:	a0a0      	add	A, #-96
    55ba:	a0a0      	add	A, #-96
    55bc:	a0a0      	add	A, #-96
    55be:	a0a0      	add	A, #-96

000055c0 <_AUTOADDtbl>:
    55c0:	2610      	or	X, [S-17]
    55c2:	1626      	call	0x5210 <__mlx4_flash_start+0x1210>
    55c4:	0000      	nop
    55c6:	0000      	nop

Disassembly of section .mlx16_vectors:

0000bf68 <__vectors>:
    bf68:	54f0      	mov	UPr, #0
    bf6a:	76da 571a 	jmpf	0x571a <__prestart>
    bf6e:	a55a      	or	A, dp:0x5a <_LIN_nad>
    bf70:	54f8      	mov	UPr, #8
    bf72:	76da 564c 	jmpf	0x564c <_STACK_IT>
    bf76:	0000      	nop
    bf78:	54f8      	mov	UPr, #8
    bf7a:	6402      	lod	YL, #2
    bf7c:	76da 568e 	jmpf	0x568e <__fatal>
    bf80:	54f8      	mov	UPr, #8
    bf82:	6403      	lod	YL, #3
    bf84:	76da 568e 	jmpf	0x568e <__fatal>
    bf88:	54f8      	mov	UPr, #8
    bf8a:	6404      	lod	YL, #4
    bf8c:	76da 568e 	jmpf	0x568e <__fatal>
    bf90:	54f0      	mov	UPr, #0
    bf92:	6405      	lod	YL, #5
    bf94:	76da 568e 	jmpf	0x568e <__fatal>
    bf98:	54f0      	mov	UPr, #0
    bf9a:	6406      	lod	YL, #6
    bf9c:	76da 568e 	jmpf	0x568e <__fatal>
    bfa0:	54f0      	mov	UPr, #0
    bfa2:	6407      	lod	YL, #7
    bfa4:	76da 568e 	jmpf	0x568e <__fatal>
    bfa8:	54f0      	mov	UPr, #0
    bfaa:	6408      	lod	YL, #8
    bfac:	76da 568e 	jmpf	0x568e <__fatal>
    bfb0:	54d4      	psup	#4
    bfb2:	76da 5db4 	jmpf	0x5db4 <_linit>
    bfb6:	0000      	nop
    bfb8:	54d5      	psup	#5
    bfba:	76da 98fc 	jmpf	0x98fc <_TIMER_IT>
    bfbe:	0000      	nop
    bfc0:	54d4      	psup	#4
    bfc2:	76da 8268 	jmpf	0x8268 <_ADC_IT>
    bfc6:	0000      	nop
    bfc8:	54f0      	mov	UPr, #0
    bfca:	640c      	lod	YL, #12
    bfcc:	76da 568e 	jmpf	0x568e <__fatal>
    bfd0:	54d3      	psup	#3
    bfd2:	76da 8fa2 	jmpf	0x8fa2 <_EXT0_IT>
    bfd6:	0000      	nop
    bfd8:	54f0      	mov	UPr, #0
    bfda:	640e      	lod	YL, #14
    bfdc:	76da 568e 	jmpf	0x568e <__fatal>
    bfe0:	54f0      	mov	UPr, #0
    bfe2:	640f      	lod	YL, #15
    bfe4:	76da 568e 	jmpf	0x568e <__fatal>
    bfe8:	54f0      	mov	UPr, #0
    bfea:	6410      	lod	YL, #16
    bfec:	76da 568e 	jmpf	0x568e <__fatal>
    bff0:	54d2      	psup	#2
    bff2:	76da 8512 	jmpf	0x8512 <_EXT4_IT>
    bff6:	0000      	nop
    bff8:	54f0      	mov	UPr, #0
    bffa:	6412      	lod	YL, #18
    bffc:	76da 568e 	jmpf	0x568e <__fatal>

Disassembly of section .system_services:

0000bf60 <mlx_enter_protected_mode>:
    bf60:	08b3      	clrb	MH.3
    bf62:	5401      	ret
    bf64:	0000      	nop

Disassembly of section .ramfunc:

00000740 <_WriteTMTR>:
 *  Write TM_TR register
 */
__attribute__ ((noinline, section(".ramfunc")))
void WriteTMTR (void)
{
    __asm__ __volatile__
 740:	7eda 6000 	lod	X, #24576
 744:	7ada 11b4 	lod	Y, #4532
 748:	54c6      	movsw	[X++], [Y++]
 74a:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
 74e:	a410      	or	A, #16
 750:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 754:	54c6      	movsw	[X++], [Y++]
 756:	b4ef      	and	A, #-17
 758:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
 75c:	5401      	ret

Disassembly of section .text:

000055e8 <_start>:
/*
 * Clears M register
 */
static INLINE void SYS_clearCpuStatus (void)
{
    __asm__ __volatile__ (
    55e8:	7000      	lod	A, #0
    55ea:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    55ec:	70ff      	lod	A, #-1
    55ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);
    55f2:	72da 01ae 	lod	A, #430
    55f6:	52ef      	mov	S, A

    _low_level_init();
    55f8:	82db 68fa 	callf	0x68fa <__low_level_init>
    _ram_section_init();    /* Initialize .data and .bss sections */
    55fc:	1006      	call	0x560a <__ram_section_init>
    _premain();
    55fe:	82db 6a4c 	callf	0x6a4c <__premain>
    (void)main();
    5602:	82db 6c26 	callf	0x6c26 <_main>
    _fatal();
    5606:	1043      	call	0x568e <__fatal>
    5608:	5401      	ret

0000560a <__ram_section_init>:
    uint16 *r;
#endif /* !RAM_APPLICATION */


    /* clear .bss and .dp.bss sections */
    for (w = &_bss_dp_start; w < &_bss_dp_end; ) {
    560a:	7ada 0028 	lod	Y, #40
    560e:	eeda 0072 	cmp	Y, #114
    5612:	1c03      	jnc	0x561a <__ram_section_init+0x10>
        *w++ = 0;
    5614:	7000      	lod	A, #0
    5616:	52d6      	mov	[Y++], A
    5618:	07fa      	jmp	0x560e <__ram_section_init+0x4>
    }

    for (w = &_bss_start; w < &_bss_end; ) {
    561a:	7ada 00ec 	lod	Y, #236
    561e:	eeda 01a6 	cmp	Y, #422
    5622:	1c03      	jnc	0x562a <__ram_section_init+0x20>
        *w++ = 0;
    5624:	7000      	lod	A, #0
    5626:	52d6      	mov	[Y++], A
    5628:	07fa      	jmp	0x561e <__ram_section_init+0x14>
    }

#if !defined (RAM_APPLICATION)  /* skip ROM-to-RAM loading for RAM application */
    /* initialize .data and .dp.data sections */
    r = &_data_load_start;      /* copy data from rom */
    562a:	7eda 9a02 	lod	X, #39426

    for (w = &_data_dp_start; w < &_data_dp_end; ) {
    562e:	7ada 0018 	lod	Y, #24
    5632:	eeda 0028 	cmp	Y, #40
    5636:	1c02      	jnc	0x563c <__ram_section_init+0x32>
        *w++ = *r++;
    5638:	54ce      	movsw	[Y++], [X++]
    563a:	07fb      	jmp	0x5632 <__ram_section_init+0x28>
    }

    for (w = &_data_start; w < &_data_end; ) {
    563c:	7ada 0072 	lod	Y, #114
    5640:	eeda 00ec 	cmp	Y, #236
    5644:	1c02      	jnc	0x564a <__ram_section_init+0x40>
        *w++ = *r++;
    5646:	54ce      	movsw	[Y++], [X++]
    5648:	07fb      	jmp	0x5640 <__ram_section_init+0x36>
    564a:	5401      	ret

0000564c <_STACK_IT>:
 */
__MLX_TEXT__ void STACK_IT(void)
{
	/* SET_STACK( &stack); */
	/* Chip header is valid and chip successfully initialised; LIN Command Reset use AWD to reset chip */
	if ( (bistHeader == C_CHIP_HEADER) && ((bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET) || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)) )
    564c:	72d8 01a6 	lod	A, 0x1a6 <__bss_end>
    5650:	aeda b598 	cmp	A, #46488
    5654:	1d19      	jne	0x5688 <_STACK_IT+0x3c>
    5656:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    565a:	aeda 3072 	cmp	A, #12402
    565e:	1905      	je	0x566a <_STACK_IT+0x1e>
    5660:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    5664:	aeda 3212 	cmp	A, #12818
    5668:	1d0f      	jne	0x5688 <_STACK_IT+0x3c>
	{
		/* INLINE MLX16_RESET (Don't use stack) */
		do
		{
			if ( (PLL_CTRL & PLL_EN) != 0u )								/* Only delay in case of PLL is active */
    566a:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    566e:	b401      	and	A, #1
    5670:	1903      	je	0x5678 <_STACK_IT+0x2c>
			{
				DELAY_US( 250);											/* Should be called with period > 200us, otherwise bit AWD_WRITE_FAIL will be set and further acknowledgment will fail during next 200 us */
    5672:	7eda 06d6 	lod	X, #1750
    5676:	1bff      	djnz	X, 0x5676 <_STACK_IT+0x2a>
			}
			AWD_CTRL = (AWD_ATT | AWD_WRITE_FAIL | ((uint16)3u << 8u) | 1u);		/* Set 1:1 pre-scaler and minimal period; AWD timeout will be 100 us */
    5678:	72da 6301 	lod	A, #25345
    567c:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
		} while ( (AWD_CTRL & (AWD_ATT | AWD_WRITE_FAIL)) != 0u );
    567e:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5680:	b6da 6000 	and	A, #24576
    5684:	1d72      	jne	0x566a <_STACK_IT+0x1e>
		for ( ; ; ) {
    5686:	07ff      	jmp	0x5686 <_STACK_IT+0x3a>
			/* wait for reset */
		}
	}
	__asm__( "mov yl, #01");
    5688:	6401      	lod	YL, #1
	__asm__( "jmp __fatal");
    568a:	0001      	jmp	0x568e <__fatal>
    568c:	5401      	ret

0000568e <__fatal>:
 * 0x079C: Address of failure (from stack)
 */
__MLX_TEXT__ void _fatal (void)
{
	/* YL = Error-reason; Don't use stack (MMP151125-1) */
	__asm__("lod X, 0x2026");													/* X = [FL_CTRL0] */
    568e:	7ed8 2026 	lod	X, 0x2026 <__ep__+0x1026>
	__asm__("and X, #0x07");													/* X[2:0] = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) */
    5692:	3407      	and	X, #7
	__asm__("lod A, 0x2040");													/* A = [PLL_STAT] */
    5694:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
	__asm__("and A, #0x03");													/* A[1:0] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) */
    5698:	b403      	and	A, #3
	__asm__("asl A, #2");
    569a:	44a2      	asl	A, #2
	__asm__("asl A, #2");														/* A[5:4] = (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569c:	44a2      	asl	A, #2
	__asm__("or  A, X");														/* A(L) = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    569e:	a6ee      	or	A, X
	__asm__("lod YH, AL");														/* YH = ([FL_CTRL0] & (FL_DBE | FL_SBE | FL_DETECT)) | (([PLL_STAT] & (PLL_CM | PLL_LOCKED)) << 4) */
    56a0:	6ee0      	lod	YH, AL
	__asm__("mov _bistError, Y");
    56a2:	5ad8 01aa 	mov	0x1aa <_bistError>, Y
	__asm__("lod A, [S-2]");													/* Save address of failed instruction */
    56a6:	7201      	lod	A, [S-2]
	__asm__("mov _bistErrorInfo, A");											/* Failure address */
    56a8:	52d8 01ac 	mov	0x1ac <_bistErrorInfo>, A

#if _SUPPORT_CRASH_RECOVERY
	/* Crash recovery */
	if ( (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) && ((uint8)(bistError & 0xFFu) < 0x05u) )	/* MMP151125-1 */
    56ac:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    56b0:	aeda 1a45 	cmp	A, #6725
    56b4:	1d20      	jne	0x56f6 <__fatal+0x68>
    56b6:	72d8 01aa 	lod	A, 0x1aa <_bistError>
    56ba:	8c04      	cmp	AL, #4
    56bc:	1e1c      	jug	0x56f6 <__fatal+0x68>
	{
		/* Crash recovery is enabled, and type of IRQ is between 0x01 and 0x04 */
		bistResetInfo = C_CHIP_STATE_FATAL_CRASH_RECOVERY;						/* Start recovery (on-going) */
    56be:	72da 1872 	lod	A, #6258
    56c2:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
		SET_STACK( &stack);														/* Re-initialise stack */
    56c6:	72da 01ae 	lod	A, #430
    56ca:	52ef      	mov	S, A
		ENTER_SYSTEM_MODE();													/* Protected mode, highest priority (0) (MMP141023-1) */
    56cc:	4407      	mov	R, #0
    56ce:	500c      	call	fp0:0x60
    56d0:	54f0      	mov	UPr, #0
		XI0_PEND = CLR_T1_INT4;
    56d2:	7040      	lod	A, #64
    56d4:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI2_PEND = 0xFFFFu;														/* Clear all XI2_PEND flags */
    56d8:	70ff      	lod	A, #-1
    56da:	52d8 2038 	mov	0x2038 <__ep__+0x1038>, A
		XI4_PEND = (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV);
    56de:	72da e100 	lod	A, #57600
    56e2:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		PEND = CLR_TIMER_IT;													/* Core-Timer */
    56e6:	7020      	lod	A, #32
    56e8:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		SET_PRIORITY( 7);														/* Protected mode, low priority (7) */
    56ec:	54f7      	mov	UPr, #7
				NVRAM_SavePage( NVRAM1_PAGE2 | NVRAM_PAGE_WR_SKIP_WAIT);
			}
		}
#endif /* (_DEBUG_FATAL != FALSE) */

		(void) main();
    56ee:	82db 6c26 	callf	0x6c26 <_main>

		/* Should never come here, as main should not be left */
		__asm__( "mov YL, #0x19");												/* C_MLX16_MAIN_FATAL */
    56f2:	6419      	lod	YL, #25
		/* lint -e{974} */ _fatal();
    56f4:	17cc      	call	0x568e <__fatal>
	}
#endif /* _SUPPORT_CRASH_RECOVERY */

	SET_STACK( &stack);															/* Re-initialise stack (MMP141023-1) */
    56f6:	72da 01ae 	lod	A, #430
    56fa:	52ef      	mov	S, A
	ENTER_SYSTEM_MODE();														/* Protected mode, highest priority (0) (MMP141023-1) */
    56fc:	4407      	mov	R, #0
    56fe:	500c      	call	fp0:0x60
    5700:	54f0      	mov	UPr, #0
	FL_CTRL0 &= (uint16)~(FL_DBE | FL_SBE);										/* Clear DBE and SBE errors (MMP141023-1) */
    5702:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5706:	b4f9      	and	A, #-7
    5708:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
		}
	}
#endif /* (_DEBUG_FATAL != FALSE) */

	/* Disable motor driver first, before waiting for watchdog */
	DRVCFG_DIS_UVWT();															/* Tri-state (disconnect) the phase U, V, W and T (MMP130919-1) */
    570c:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    5710:	b6da fe00 	and	A, #65024
    5714:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	for (;;) {
    5718:	07ff      	jmp	0x5718 <__fatal+0x8a>

0000571a <__prestart>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _prestart(void)
{
    571a:	5801      	inc	S, #2
    571c:	7000      	lod	A, #0
    571e:	52e3      	mov	M, A
                             * Note that UPR register (== M[11:8]) was already
                             * initialized during execution of the reset vector
                             * (see JMPVECTOR macro)
                             */

    PRIO = 0xFFFF;          /* set lowest priorties (undefined after reset) */
    5720:	70ff      	lod	A, #-1
    5722:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A

    SET_STACK(&stack);      /* Init stack */
    5726:	72da 01ae 	lod	A, #430
    572a:	52ef      	mov	S, A

    NVRAM_LoadAll();        /* Load NVRAM before trimming (NVRAM will be used by trimming) (MMP110921-1) */
    572c:	1130      	call	0x598e <_NVRAM_LoadAll>
         * 0x10E9: CRC8
         * 0x10EA: Bit 7:3: Project Software version ID, Bit 2:0: Patch Software version ID
         * 0x10EB: Project-ID
         * 0x10EC-0x10FB: Patch-table
         */
        if ((FL_CTRL0 & FL_DETECT) == 0)
    572e:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5732:	b401      	and	A, #1
    5734:	1d27      	jne	0x5784 <__prestart+0x6a>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    5736:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    573a:	5cf2      	usex	A
    573c:	4422      	asl	A
    573e:	7ada 10e8 	lod	Y, #4328
    5742:	eae2      	sub	Y, A
    5744:	62d8 10e8 	lod	AL, 0x10e8 <__ep__+0xe8>
    5748:	5cf2      	usex	A
    574a:	7ee2      	lod	X, A
    574c:	7014      	lod	A, #20
    574e:	aaee      	sub	A, X
    5750:	4432      	lsr	A
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    5752:	7ee2      	lod	X, A
    5754:	7000      	lod	A, #0
    5756:	08a7      	clrb	ML.7
    5758:	b2d6      	adc	A, [Y++]
    575a:	1bfe      	djnz	X, 0x5758 <__prestart+0x3e>
    575c:	92e4      	adc	AL, AH
    575e:	9000      	adc	AL, #0
    5760:	5cf2      	usex	A
        {
            /* This is a ROM chip */
            uint16 u16CRC = nvram_CalcCRC( ((uint16*) 0x10E8) - u16PatchSize,
                                           ((END_MLX_PATCH_ADDR + 1) - 0x10E8 - u16PatchSize)/2 );

            if ( u16CRC == 0xFFU )
    5762:	aeda 00ff 	cmp	A, #255
    5766:	1d0e      	jne	0x5784 <__prestart+0x6a>
            {
                /* Correct Checksum */
                if ( (u16PatchVersion & C_NVRAM_PATCH_MASK) == C_NVRAM_PATCH_ID )
    5768:	72d8 10ea 	lod	A, 0x10ea <__ep__+0xea>
    576c:	b4f8      	and	A, #-8
    576e:	aeda 04b8 	cmp	A, #1208
    5772:	1d08      	jne	0x5784 <__prestart+0x6a>
                {
                    /* Correct Project-ID and ROM Firmware version */
                    uint16 *u16PatchAddr = (uint16*) BGN_MLX_PATCH_ADDR;
    5774:	7eda 10ec 	lod	X, #4332
                    uint16 *u16PatchIo = (uint16*) &PATCH0_I;
    5778:	7ada 200c 	lod	Y, #8204
                    do
                    {
                        *u16PatchIo++ = *u16PatchAddr++;
    577c:	54ce      	movsw	[Y++], [X++]
                    } while ( u16PatchIo <= (uint16*) &PATCH3_A);
    577e:	eeda 201a 	cmp	Y, #8218
    5782:	1a7c      	jule	0x577c <__prestart+0x62>
     *
     *****************************************************************************
     */
    __MLX_TEXT__  static INLINE void bist_CheckReset (void)
    {
        if ( bistHeader == C_CHIP_HEADER )                                     /* Chip header is valid and chip successfully initialized by ... */
    5784:	72d8 01a6 	lod	A, 0x1a6 <__bss_end>
    5788:	aeda b598 	cmp	A, #46488
    578c:	1901      	je	0x5790 <__prestart+0x76>
    578e:	0037      	jmp	0x57fe <__prestart+0xe4>
        {
            if ( ((AWD_CTRL & AWD_RST) != 0) || WD_BOOT_CHECK() )              /* Check both Analog Watchdog and Digital Watchdog */
    5790:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5792:	ac00      	cmp	A, #0
    5794:	1a84      	jsl	0x579e <__prestart+0x84>
    5796:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    579a:	8c00      	cmp	AL, #0
    579c:	1e98      	jsge	0x57ce <__prestart+0xb4>
            {
                if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&
    579e:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57a2:	aeda 3072 	cmp	A, #12402
    57a6:	1d01      	jne	0x57aa <__prestart+0x90>
    57a8:	0031      	jmp	0x580c <__prestart+0xf2>
    57aa:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57ae:	aeda 3212 	cmp	A, #12818
    57b2:	192c      	je	0x580c <__prestart+0xf2>
                     (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )
                {
                    if ( (bistResetInfo == C_CHIP_STATE_COLD_START) ||         /* Chip-state is Cold-start or (pass including RAM-init) or ... */
    57b4:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57b8:	1905      	je	0x57c4 <__prestart+0xaa>
    57ba:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57be:	aeda 1a45 	cmp	A, #6725
    57c2:	1d03      	jne	0x57ca <__prestart+0xb0>
                         (bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA) )   /* ... Chip-state is fatal-recovery enabled (fully initialized) */
                    {
                        bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    57c4:	72da 5c92 	lod	A, #23698
    57c8:	000d      	jmp	0x57e4 <__prestart+0xca>
                    }
                    else
                    {
                        bistResetInfo = C_CHIP_STATE_COLD_START;
    57ca:	7c00      	lod	X, #0
    57cc:	0015      	jmp	0x57f8 <__prestart+0xde>
                    /* LIN Command Reset
                     * or
                     * Loader enter Programming mode Reset */
                }
            }
            else if ( (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET) &&         /* LIN Command Reset must be passed through Analod Watchdog reset */
    57ce:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57d2:	aeda 3072 	cmp	A, #12402
    57d6:	1909      	je	0x57ea <__prestart+0xd0>
    57d8:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57dc:	aeda 3212 	cmp	A, #12818
    57e0:	1904      	je	0x57ea <__prestart+0xd0>
                      (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) )      /* Loader Prog Reset must be passed through Analog Watchdog reset */
            {
                bistResetInfo = C_CHIP_STATE_COLD_START;
    57e2:	7000      	lod	A, #0
    57e4:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
    57e8:	0011      	jmp	0x580c <__prestart+0xf2>
            }
            else if ( bistResetInfo == C_CHIP_STATE_FATAL_RECOVER_ENA )
    57ea:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    57ee:	aeda 1a45 	cmp	A, #6725
    57f2:	1d0c      	jne	0x580c <__prestart+0xf2>
            {
                bistResetInfo = C_CHIP_STATE_UV_RESET;
    57f4:	7eda 56d2 	lod	X, #22226
    57f8:	5ed8 01a8 	mov	0x1a8 <_bistResetInfo>, X
    57fc:	0007      	jmp	0x580c <__prestart+0xf2>
            }
        }
        else
        {
            bistResetInfo = C_CHIP_STATE_COLD_START;
    57fe:	7000      	lod	A, #0
    5800:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
            bistHeader = C_CHIP_HEADER;
    5804:	7eda b598 	lod	X, #46488
    5808:	5ed8 01a6 	mov	0x1a6 <__bss_end>, X

    bist_CheckReset();      /* Check the reason of the reset and store in non initialized memory */

#ifdef HAS_NVRAM_CRC
    /* Incase of Watchdog-reset or LIN-command reset, skip CRC check as it's already performed at cold-start */
    if (
    580c:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    5810:	aeda 3072 	cmp	A, #12402
    5814:	1919      	je	0x5848 <__prestart+0x12e>
    5816:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    581a:	aeda 3212 	cmp	A, #12818
    581e:	1914      	je	0x5848 <__prestart+0x12e>
    5820:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    5824:	aeda 5c92 	cmp	A, #23698
    5828:	190f      	je	0x5848 <__prestart+0x12e>
 * const uint16_t u16Length: Length (in 16-bit words)
 *
 * returns a 8-bit (extended to 16-bit) CRC (Sum with carry) calculation over the specified area.
 */
__MLX_TEXT__ static __inline__ uint16 nvram_CalcCRC( const uint16_t *pu16BeginAddress, const uint16_t u16Length)
{
    582a:	7ada 1180 	lod	Y, #4480
    uint16 u16Result;
    uint16 u16Result2;  /* Clobbering of the register */
    uint16 u16Result3;  /* Clobbering of the register */
    __asm__ __volatile__
    582e:	7c20      	lod	X, #32
    5830:	7000      	lod	A, #0
    5832:	08a7      	clrb	ML.7
    5834:	b2d6      	adc	A, [Y++]
    5836:	1bfe      	djnz	X, 0x5834 <__prestart+0x11a>
    5838:	92e4      	adc	AL, AH
    583a:	9000      	adc	AL, #0
    583c:	5cf2      	usex	A
        uint16 u16CRC;

        /* Melexis Production area - CRC1 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA1,
                                ((END_MLX_CALIB_ADDRESS_AREA1 + 1) - BGN_MLX_CALIB_ADDRESS_AREA1)/2 );
        if ( u16CRC != 0xFF )
    583e:	aeda 00ff 	cmp	A, #255
    5842:	1902      	je	0x5848 <__prestart+0x12e>
        {
#ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #1 is corrupt */
            asm( "mov yl, #0xC8");              /* C_ERR_INV_MLXPAGE_CRC1 */    /* MLX NVRAM CRC #1 failure */
    5844:	64c8      	lod	YL, #-56
            asm( "jmpf __fatal");
    5846:	0723      	jmp	0x568e <__fatal>
     *      5. Trimming of the RC Oscillator
     *      6. Trimming of Watchdog RC Oscillator
     *      7. Trimming of the ADC Reference voltages VRH1..3
     *      8. Configure PLL
     */
    CONTROL = OUTB_WE | OUTC_WE;                                            /* Grant access to ANA_OUTx registers */
    5848:	6030      	lod	AL, #48
    584a:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTB = EEP_ANA_OUTB_PT35;                                           /* Vdd, Bias, Bandgap */
    584e:	72d8 11a8 	lod	A, 0x11a8 <__ep__+0x1a8>
    5852:	52d8 201e 	mov	0x201e <__ep__+0x101e>, A
    ANA_OUTC = EEP_ANA_OUTC_PT35 | 0x8000;                                  /* PLL, Oscillator, Ena CK_TRIM */
    5856:	72d8 11aa 	lod	A, 0x11aa <__ep__+0x1aa>
    585a:	a6da 8000 	or	A, #32768
    585e:	52d8 2020 	mov	0x2020 <__ep__+0x1020>, A
    ANA_OUTD = EEP_ANA_OUTD_PT35;                                           /* ADC references 1 and 2 trimming */
    5862:	72d8 11ac 	lod	A, 0x11ac <__ep__+0x1ac>
    5866:	52d8 204a 	mov	0x204a <__ep__+0x104a>, A
    ANA_OUTE = (EEP_ANA_OUTE_PT35 & 0x00FF) | 0xC000;                       /* ADC references 3; only low 8 bits are relevant; ADC @ 4MHz */
    586a:	72d8 11ae 	lod	A, 0x11ae <__ep__+0x1ae>
    586e:	b6da 00ff 	and	A, #255
    5872:	a6da c000 	or	A, #49152
    5876:	52d8 204c 	mov	0x204c <__ep__+0x104c>, A
    CONTROL &= ~(OUTB_WE | OUTC_WE);
    587a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    587e:	94cf      	and	AL, #-49
    5880:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL

#if (MCU_PLL_MULT <= 80)    /* if CPU clock <= 20 MHz */
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_FL;                 /* use flash-ready option */
#else
    CONTROL_EXT = (CONTROL_EXT & ~RDY_OPTION) | RDY_OPT_1;                  /* use 1 wait-state */
    5884:	72d8 2054 	lod	A, 0x2054 <__ep__+0x1054>
    5888:	b4f9      	and	A, #-7
    588a:	a402      	or	A, #2
    588c:	52d8 2054 	mov	0x2054 <__ep__+0x1054>, A
#endif

    if ( (FL_CTRL0 & FL_DETECT) != 0 )
    5890:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    5894:	b401      	and	A, #1
    5896:	1914      	je	0x58c0 <__prestart+0x1a6>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
    5898:	72d8 11b4 	lod	A, 0x11b4 <__ep__+0x1b4>
    589c:	7ad8 11b6 	lod	Y, 0x11b6 <__ep__+0x1b6>
    58a0:	a6e6      	or	A, Y
    58a2:	190e      	je	0x58c0 <__prestart+0x1a6>
    extern uint16 _ramfunc_end;

    uint16 *w;
    uint16 *r;

    r = &_ramfunc_load_start;
    58a4:	7eda 55c8 	lod	X, #21960

    for (w = &_ramfunc_start; w < &_ramfunc_end; ) {
    58a8:	7ada 0740 	lod	Y, #1856
    58ac:	eeda 075e 	cmp	Y, #1886
    58b0:	1c05      	jnc	0x58bc <__prestart+0x1a2>
        *w++ = *r++;
    58b2:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b4:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b6:	54ce      	movsw	[Y++], [X++]
        *w++ = *r++;
    58b8:	54ce      	movsw	[Y++], [X++]
    58ba:	07f8      	jmp	0x58ac <__prestart+0x192>
    {
        /* This is a flash chip */
        if ((EEP_TM_TR_LSW | EEP_TM_TR_MSW) != 0)                           /* Check if both Upper 16-bits and Lower 16-bits of TM_TR are NON-ZERO */
        {
            install_ram_functions();                                        /* .. install RAM functions (TM_TR can be updated only from RAM ..  */
            WriteTMTR();                                                    /* .. and init TM_TR register to trim the Flash; can start PLL now  */
    58bc:	82db 0740 	callf	0x740 <_WriteTMTR>

__MLX_TEXT__ static void init_PLL (void)
{
    uint_fast8_t i;

    PLL_CTRL = ((uint16)DEF_FBDIV << 8)
    58c0:	72da 6fd1 	lod	A, #28625
    58c4:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58c8:	7800      	lod	Y, #0
    {
        if ( PLL_STAT & PLL_LOCKED )
    58ca:	72d8 2040 	lod	A, 0x2040 <__ep__+0x1040>
    58ce:	b401      	and	A, #1
    58d0:	1d03      	jne	0x58d8 <__prestart+0x1be>
                | PLL_EN;

    /* The hardware itself takes care that the PLL has locked and therefore
     * reached its final stable frequency before enabling its use.
     */
    for ( i = 0; i < NSAMPLES; i++ )
    58d2:	e001      	add	Y, #1
    58d4:	ec63      	cmp	Y, #99
    58d6:	1a79      	jule	0x58ca <__prestart+0x1b0>
            break;  /* PLL has successfully locked */
        }
        /* else : try locking again */
    }

    if ( NSAMPLES == i )
    58d8:	ec64      	cmp	Y, #100
    58da:	1d01      	jne	0x58de <__prestart+0x1c4>
    {
        /* Locking failed */
        /* TBD */
        for (;;); /* loop until WD reset for the time being */
    58dc:	07ff      	jmp	0x58dc <__prestart+0x1c2>

    /*
     * Calibrate 1MHz internal clock using CK_TRIM divider
     * This 1MHz clock is used by 15-bit core timer, watchdog and EEPROM
     */
    CK_TRIM = DEF_CK_TRIM;
    58de:	6024      	lod	AL, #36
    58e0:	42d8 2029 	mov	0x2029 <__ep__+0x1029>, AL

#ifdef HAS_RAM_TEST
    if (       (bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET)
    58e4:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    58e8:	aeda 3072 	cmp	A, #12402
    58ec:	190e      	je	0x590a <__prestart+0x1f0>
    58ee:	82db 6606 	callf	0x6606 <_LDR_GetState>
    58f2:	8c00      	cmp	AL, #0
    58f4:	1d0a      	jne	0x590a <__prestart+0x1f0>
    58f6:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    58fa:	aeda 3212 	cmp	A, #12818
    58fe:	1905      	je	0x590a <__prestart+0x1f0>
    5900:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    5904:	aeda 5c92 	cmp	A, #23698
    5908:	1d02      	jne	0x590e <__prestart+0x1f4>
       )
    {
        /* Else: skip RAM test during Flash reprogramming (loader state != 0)
         * otherwise stFixedRamNAD.nad stored in no-init RAM will be corrupted
         */
        __asm__ __volatile__ ("jmp _start");
    590a:	066e      	jmp	0x55e8 <_start>
    590c:	5403      	ret	#4
    }
    else
    {
        /* We're about to start the application .. */
        /* .. execute the RAM test first */
        __asm__ __volatile__ ("jmp _RAM_Test");
    590e:	76da 68aa 	jmpf	0x68aa <_RAM_Test>
    5912:	5403      	ret	#4

00005914 <_MLX16_RESET>:
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    5914:	7ae3      	lod	Y, M
 *      In this case analog WD is used for reset. The PLL disabling is done
 *      to decrease AWD reset failure rate
 */
__MLX_TEXT__  void MLX16_RESET (void)
{
    ATOMIC_CODE (
    5916:	4407      	mov	R, #0
    5918:	500c      	call	fp0:0x60
    591a:	54f0      	mov	UPr, #0
    591c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    591e:	b430      	and	A, #48
    5920:	ac10      	cmp	A, #16
    5922:	1914      	je	0x594c <_MLX16_RESET+0x38>
    5924:	1e03      	jug	0x592c <_MLX16_RESET+0x18>
    5926:	ac00      	cmp	A, #0
    5928:	190c      	je	0x5942 <_MLX16_RESET+0x2e>
    592a:	002f      	jmp	0x598a <_MLX16_RESET+0x76>
    592c:	ac20      	cmp	A, #32
    592e:	1903      	je	0x5936 <_MLX16_RESET+0x22>
    5930:	ac30      	cmp	A, #48
    5932:	1904      	je	0x593c <_MLX16_RESET+0x28>
    5934:	002a      	jmp	0x598a <_MLX16_RESET+0x76>
    5936:	6000      	lod	AL, #0
    5938:	4282      	mov	io:0x2 <_LinCmnd>, AL
    593a:	07fd      	jmp	0x5936 <_MLX16_RESET+0x22>
    593c:	6000      	lod	AL, #0
    593e:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5940:	07ff      	jmp	0x5940 <_MLX16_RESET+0x2c>
    5942:	6001      	lod	AL, #1
    5944:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5946:	6010      	lod	AL, #16
    5948:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
    594a:	07ff      	jmp	0x594a <_MLX16_RESET+0x36>
    594c:	6282      	lod	AL, io:0x2 <_LinCmnd>
    594e:	66e0      	lod	YL, AL
    5950:	5cf6      	usex	Y
    5952:	44a6      	asl	Y, #2
    5954:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5956:	b403      	and	A, #3
    5958:	4422      	asl	A
    595a:	ac00      	cmp	A, #0
    595c:	1b03      	jsle	0x5964 <_MLX16_RESET+0x50>
    595e:	42e9      	mov	Cx, AL
    5960:	4426      	asl	Y
    5962:	1ffe      	djnz	Cx, 0x5960 <_MLX16_RESET+0x4c>
    5964:	ec7d      	cmp	Y, #125
    5966:	1c01      	jnc	0x596a <_MLX16_RESET+0x56>
    5968:	07ff      	jmp	0x5968 <_MLX16_RESET+0x54>
    596a:	7eda 06d6 	lod	X, #1750
    596e:	1bff      	djnz	X, 0x596e <_MLX16_RESET+0x5a>
    5970:	72da 6301 	lod	A, #25345
    5974:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
    5976:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    5978:	b6da 6000 	and	A, #24576
    597c:	1d76      	jne	0x596a <_MLX16_RESET+0x56>
    597e:	72d8 203e 	lod	A, 0x203e <__ep__+0x103e>
    5982:	b4fe      	and	A, #-2
    5984:	52d8 203e 	mov	0x203e <__ep__+0x103e>, A
    5988:	07ff      	jmp	0x5988 <_MLX16_RESET+0x74>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    598a:	5ae3      	mov	M, Y
    598c:	5401      	ret

0000598e <_NVRAM_LoadAll>:
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
        WD_T = 0;                       /* .. acknowledge the watchdog */
    598e:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5992:	b401      	and	A, #1
    5994:	1908      	je	0x59a6 <_NVRAM_LoadAll+0x18>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5996:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5998:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    599a:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    599c:	b430      	and	A, #48
    599e:	1977      	je	0x598e <_NVRAM_LoadAll>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59a0:	6000      	lod	AL, #0
    59a2:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59a4:	07f4      	jmp	0x598e <_NVRAM_LoadAll>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
        WDG_Manager(); /* polling */
    }

    /* yso: EEPROM Select and Mode select should in two different commands according to spr */
    NV_CTRL = NV_SEL;                   /* select NVRAM2 (both pages) */
    59a6:	72da 8000 	lod	A, #32768
    59aa:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL | NV_SEL;  /* Execute Recall command (Flash -> RAM) for NVRAM2 */
    59ae:	72da 8001 	lod	A, #32769
    59b2:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59b6:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59ba:	b401      	and	A, #1
    59bc:	1908      	je	0x59ce <_NVRAM_LoadAll+0x40>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59be:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    59c0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59c2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59c4:	b430      	and	A, #48
    59c6:	1977      	je	0x59b6 <_NVRAM_LoadAll+0x28>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59c8:	6000      	lod	AL, #0
    59ca:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59cc:	07f4      	jmp	0x59b6 <_NVRAM_LoadAll+0x28>
    while ((NV_CTRL & NV_BUSY) != 0) {  /* wait until command will be finished */
        WDG_Manager(); /* polling */
    }

    NV_CTRL = 0;                        /* select NVRAM1 (both pages) */
    59ce:	7000      	lod	A, #0
    59d0:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    NV_CTRL = NV_CONF_RECALL;           /* Execute Recall (Flash -> RAM) for NVRAM1 */
    59d4:	7001      	lod	A, #1
    59d6:	52d8 2024 	mov	0x2024 <__ep__+0x1024>, A
    59da:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    59de:	b401      	and	A, #1
    59e0:	1908      	je	0x59f2 <_NVRAM_LoadAll+0x64>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    59e2:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    59e4:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    59e6:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    59e8:	b430      	and	A, #48
    59ea:	1977      	je	0x59da <_NVRAM_LoadAll+0x4c>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    59ec:	6000      	lod	AL, #0
    59ee:	4282      	mov	io:0x2 <_LinCmnd>, AL
    59f0:	07f4      	jmp	0x59da <_NVRAM_LoadAll+0x4c>
    59f2:	5401      	ret

000059f4 <_NVRAM_SavePage>:
__MLX_TEXT__  void NVRAM_SavePage (uint16_t page)
{
    uint16_t mode;


    switch (page & ~NVRAM_PAGE_WR_SKIP_WAIT) {
    59f4:	7ee2      	lod	X, A
    59f6:	b6da 7fff 	and	A, #32767
    59fa:	ac01      	cmp	A, #1
    59fc:	1906      	je	0x5a0a <_NVRAM_SavePage+0x16>
    59fe:	1803      	jc	0x5a06 <_NVRAM_SavePage+0x12>
    5a00:	ac02      	cmp	A, #2
    5a02:	1905      	je	0x5a0e <_NVRAM_SavePage+0x1a>
    5a04:	5401      	ret
        case NVRAM1_PAGE1:
            mode = 0 | NV1_MEM_ALLC | 0;
    5a06:	7810      	lod	Y, #16
            break;
    5a08:	0004      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>

        case NVRAM1_PAGE2:
            mode = 0 | NV1_MEM_ALLC | NV1_MEM_SEL;
    5a0a:	7818      	lod	Y, #24
            break;
    5a0c:	0002      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>

        case NVRAM2_PAGE1:
            mode = NV_SEL | NV2_MEM_ALLC | 0;
    5a0e:	7ada 8400 	lod	Y, #33792
    5a12:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a16:	b401      	and	A, #1
    5a18:	1908      	je	0x5a2a <_NVRAM_SavePage+0x36>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a1a:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5a1c:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a1e:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a20:	b430      	and	A, #48
    5a22:	1977      	je	0x5a12 <_NVRAM_SavePage+0x1e>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a24:	6000      	lod	AL, #0
    5a26:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a28:	07f4      	jmp	0x5a12 <_NVRAM_SavePage+0x1e>
        while ((NV_CTRL & NV_BUSY) != 0) {  /* wait if previous access is ongoing */
            WDG_Manager(); /* polling */
        }

        /* yso: EEPROM Select and Mode select should in two different commands according to spr */
        NV_CTRL = mode;                     /* select NVRAM chip and page           */
    5a2a:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y
        NV_CTRL = mode | NV_CONF_STORE;     /* Execute Store command (RAM -> Flash) */
    5a2e:	e403      	or	Y, #3
    5a30:	5ad8 2024 	mov	0x2024 <__ep__+0x1024>, Y

		if ( (page & NVRAM_PAGE_WR_SKIP_WAIT) == 0 )
    5a34:	2c00      	cmp	X, #0
    5a36:	1a8c      	jsl	0x5a50 <_NVRAM_SavePage+0x5c>
    5a38:	72d8 2024 	lod	A, 0x2024 <__ep__+0x1024>
    5a3c:	b401      	and	A, #1
    5a3e:	1908      	je	0x5a50 <_NVRAM_SavePage+0x5c>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5a40:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5a42:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5a44:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5a46:	b430      	and	A, #48
    5a48:	1977      	je	0x5a38 <_NVRAM_SavePage+0x44>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5a4a:	6000      	lod	AL, #0
    5a4c:	4282      	mov	io:0x2 <_LinCmnd>, AL
    5a4e:	07f4      	jmp	0x5a38 <_NVRAM_SavePage+0x44>
    5a50:	5401      	ret

00005a52 <_NVRAM_BufferFill>:
 *
 * Notes:
 *  1. NVRAM buffer has only word-size access for writing
 */
__MLX_TEXT__  void NVRAM_BufferFill (uint16_t address, uint8_t data)
{
    5a52:	7ae2      	lod	Y, A
    5a54:	6203      	lod	AL, [S-4]
    5a56:	5cf2      	usex	A
    5a58:	7ee2      	lod	X, A
    uint16_t *dst;
    uint16_t w;


    if ((address & 1) != 0) {                                   /* if address is odd ..                 */
    5a5a:	72e6      	lod	A, Y
    5a5c:	b401      	and	A, #1
    5a5e:	1908      	je	0x5a70 <_NVRAM_BufferFill+0x1e>
        address &= ~1;                                          /* .. make it even ..                   */
    5a60:	f4fe      	and	Y, #-2
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a62:	72f0      	lod	A, [Y]
        w = (w & 0x00FF) | ((uint16_t)data << 8);               /* replace high-byte with a data byte   */
    5a64:	b6da 00ff 	and	A, #255
    5a68:	36da 00ff 	and	X, #255
    5a6c:	7eec      	swap	X
    5a6e:	0003      	jmp	0x5a76 <_NVRAM_BufferFill+0x24>
    }
    else {                                                      /* else: address is even                */
        dst = (uint16_t *)(address);
        w = *dst;                                               /* .. and read the word                 */
    5a70:	72f0      	lod	A, [Y]
        w = (w & 0xFF00) | data;                                /* replace low-byte with a data byte    */
    5a72:	b6da ff00 	and	A, #65280
    5a76:	a6ee      	or	A, X
    }

    *dst = w;                                                   /* write the word back to memory        */
    5a78:	52f0      	mov	[Y], A
    5a7a:	5401      	ret

00005a7c <_NVRAM_SaveAll>:
 * Notes:
 *  1. Should NOT be used by application. Use NVRAM_Save instead.
 */
__MLX_TEXT__  void NVRAM_SaveAll (void)
{
    NVRAM_SavePage(NVRAM1_PAGE1);
    5a7c:	7000      	lod	A, #0
    5a7e:	17ba      	call	0x59f4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM1_PAGE2);
    5a80:	7001      	lod	A, #1
    5a82:	17b8      	call	0x59f4 <_NVRAM_SavePage>
    NVRAM_SavePage(NVRAM2_PAGE1);
    5a84:	7002      	lod	A, #2
    5a86:	17b6      	call	0x59f4 <_NVRAM_SavePage>
    5a88:	5401      	ret

00005a8a <_ml_ReleaseBuffer>:
    5a8a:	602f      	lod	AL, #47
    5a8c:	0033      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005a8e <_ml_ReleaseBufferProg>:
    5a8e:	9401      	and	AL, #1
    5a90:	44a0      	asl	AL, #2
    5a92:	44a0      	asl	AL, #2
    5a94:	840f      	or	AL, #15
    5a96:	002e      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005a98 <_ml_DataReady>:
    5a98:	6ae0      	lod	AH, AL
    5a9a:	6015      	lod	AL, #21
    5a9c:	7eda 0008 	lod	X, #8
    5aa0:	7ada 0052 	lod	Y, #82
    5aa4:	54c6      	movsw	[X++], [Y++]
    5aa6:	54c6      	movsw	[X++], [Y++]
    5aa8:	54c6      	movsw	[X++], [Y++]
    5aaa:	54c6      	movsw	[X++], [Y++]
    5aac:	0023      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aae <_ml_AssignFrameToMessageID>:
    5aae:	6a03      	lod	AH, [S-4]
    5ab0:	d43f      	and	AH, #63
    5ab2:	0004      	jmp	0x5abc <_ml_EnableMessage+0x4>

00005ab4 <_ml_DisableMessage>:
    5ab4:	6802      	lod	AH, #2
    5ab6:	0001      	jmp	0x5aba <_ml_EnableMessage+0x2>

00005ab8 <_ml_EnableMessage>:
    5ab8:	6803      	lod	AH, #3
    5aba:	44d4      	rr	AH, #2
    5abc:	44a0      	asl	AL, #2
    5abe:	44a0      	asl	AL, #2
    5ac0:	8406      	or	AL, #6
    5ac2:	0018      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005ac4 <_ml_AutoAddressingConfig>:
    5ac4:	44a0      	asl	AL, #2
    5ac6:	44a0      	asl	AL, #2
    5ac8:	840d      	or	AL, #13
    5aca:	0014      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005acc <_ml_SetSlewRate>:
    5acc:	44a2      	asl	A, #2
    5ace:	44a2      	asl	A, #2
    5ad0:	a407      	or	A, #7
    5ad2:	0010      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005ad4 <_ml_SetOptions>:
    5ad4:	6a03      	lod	AH, [S-4]
    5ad6:	44a4      	asl	AH, #2
    5ad8:	86e4      	or	AL, AH
    5ada:	44a0      	asl	AL, #2
    5adc:	44a0      	asl	AL, #2
    5ade:	840b      	or	AL, #11
    5ae0:	c607      	or	AH, [S-8]
    5ae2:	44a4      	asl	AH, #2
    5ae4:	c605      	or	AH, [S-6]
    5ae6:	dc01      	xor	AH, #1
    5ae8:	0005      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aea <_ml_DiscardFrame>:
    5aea:	6005      	lod	AL, #5
    5aec:	0003      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005aee <_ml_ContFrame>:
    5aee:	6ae0      	lod	AH, AL
    5af0:	6025      	lod	AL, #37
    5af2:	0000      	nop
    5af4:	54e2      	mov	Cx, #2
    5af6:	52d8 0002 	mov	0x2 <_LinCmnd>, A
    5afa:	7ae2      	lod	Y, A
    5afc:	6041      	lod	AL, #65
    5afe:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5b02:	7eda 03e8 	lod	X, #1000
    5b06:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5b0a:	9402      	and	AL, #2
    5b0c:	1d03      	jne	0x5b14 <_ml_ContFrame+0x26>
    5b0e:	1bfb      	djnz	X, 0x5b06 <_ml_ContFrame+0x18>
    5b10:	7002      	lod	A, #2
    5b12:	5401      	ret
    5b14:	7ee6      	lod	X, Y
    5b16:	340f      	and	X, #15
    5b18:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b1c:	6800      	lod	AH, #0
    5b1e:	aeee      	cmp	A, X
    5b20:	1d02      	jne	0x5b26 <_ml_ContFrame+0x38>
    5b22:	7000      	lod	A, #0
    5b24:	5401      	ret
    5b26:	72e6      	lod	A, Y
    5b28:	1fe6      	djnz	Cx, 0x5af6 <_ml_ContFrame+0x8>
    5b2a:	7001      	lod	A, #1
    5b2c:	5401      	ret

00005b2e <_ml_LinModuleVersion>:
    5b2e:	602a      	lod	AL, #42
    5b30:	17e1      	call	0x5af4 <_ml_ContFrame+0x6>
    5b32:	ac00      	cmp	A, #0
    5b34:	1d11      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b36:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b3a:	940f      	and	AL, #15
    5b3c:	8c0a      	cmp	AL, #10
    5b3e:	1d0c      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b40:	66e4      	lod	YL, AH
    5b42:	601a      	lod	AL, #26
    5b44:	17d7      	call	0x5af4 <_ml_ContFrame+0x6>
    5b46:	ac00      	cmp	A, #0
    5b48:	1d07      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b4a:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b4e:	940f      	and	AL, #15
    5b50:	8c0a      	cmp	AL, #10
    5b52:	1d02      	jne	0x5b58 <_ml_LinModuleVersion+0x2a>
    5b54:	62e8      	lod	AL, YL
    5b56:	5401      	ret
    5b58:	7000      	lod	A, #0
    5b5a:	5401      	ret

00005b5c <_ml_GetState>:
    5b5c:	44a2      	asl	A, #2
    5b5e:	44a2      	asl	A, #2
    5b60:	a40c      	or	A, #12
    5b62:	17c8      	call	0x5af4 <_ml_ContFrame+0x6>
    5b64:	ac00      	cmp	A, #0
    5b66:	1d0b      	jne	0x5b7e <_ml_GetState+0x22>
    5b68:	72d8 0000 	lod	A, 0x0 <__dp__>
    5b6c:	8c0c      	cmp	AL, #12
    5b6e:	1d07      	jne	0x5b7e <_ml_GetState+0x22>
    5b70:	62e4      	lod	AL, AH
    5b72:	44f4      	asr	AH, #2
    5b74:	44f4      	asr	AH, #2
    5b76:	4ad8 a001 	mov	0x1a0 <_LinStatus>, AH
    5b7a:	b40f      	and	A, #15
    5b7c:	5401      	ret
    5b7e:	70ff      	lod	A, #-1
    5b80:	5401      	ret

00005b82 <_ml_SetBaudRate>:
    5b82:	44a0      	asl	AL, #2
    5b84:	44a0      	asl	AL, #2
    5b86:	8402      	or	AL, #2
    5b88:	7a03      	lod	Y, [S-4]
    5b8a:	6ae8      	lod	AH, YL
    5b8c:	07b3      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005b8e <_ml_SetAutoBaudRateMode>:
    5b8e:	6ae0      	lod	AH, AL
    5b90:	6002      	lod	AL, #2
    5b92:	84e0      	or	AL, #-32
    5b94:	07af      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005b96 <_ml_Connect>:
    5b96:	6002      	lod	AL, #2
    5b98:	0008      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005b9a <_ml_Disconnect>:
    5b9a:	6001      	lod	AL, #1
    5b9c:	0006      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005b9e <_ml_SwitchToFast>:
    5b9e:	600f      	lod	AL, #15
    5ba0:	0004      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005ba2 <_ml_WakeUp>:
    5ba2:	6008      	lod	AL, #8
    5ba4:	0002      	jmp	0x5baa <_ml_GotoSleep+0x4>

00005ba6 <_ml_GotoSleep>:
    5ba6:	6004      	lod	AL, #4
    5ba8:	0000      	nop
    5baa:	44a0      	asl	AL, #2
    5bac:	44a0      	asl	AL, #2
    5bae:	8401      	or	AL, #1
    5bb0:	07a1      	jmp	0x5af4 <_ml_ContFrame+0x6>

00005bb2 <_ml_GetLinEventData>:
__MLX_TEXT__  void ml_GetLinEventData (void)
{
    uint16_t LinCommand;


    SLVIT = 0xAAU;                      /* Disable all slave interrupts                 */
    5bb2:	60aa      	lod	AL, #-86
    5bb4:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    LinMessage = LinMess;               /* Get the message from the shared memory area  */
    5bb8:	7104      	lod	A, dp:0x4 <_LinMess>
    5bba:	515c      	mov	dp:0x5c <_LinMessage>, A
#if defined (DEBUG_HAS_MLX4_EVENT_BUFFER)
    events[idx & BUF_MASK] = LinMessage;
    idx++;
#endif

    CLEAR_MLX4_INT();                   /* Clear pending M4_SHEM interrupt */
    5bbc:	7810      	lod	Y, #16
    5bbe:	5ad8 2008 	mov	0x2008 <__ep__+0x1008>, Y

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5bc2:	b40f      	and	A, #15

#if defined (_DEBUG_LIN_MARK)
    markv(1, 0x8A00, LinCommand);       /* Mark instruction : display the command received */
#endif /* _DEBUG_LIN_MARK */

    if (evMESSrcvd == LinCommand)  {    /* if message received then copy LinFrame to LinFrameDataBuffer (4 words) */
    5bc4:	ac03      	cmp	A, #3
    5bc6:	1d09      	jne	0x5bda <_ml_GetLinEventData+0x28>
         * so can copy a word at a time.
         */
        uint16_t const *src = (uint16_t const *)LinFrame;
        uint16_t *dst       = (uint16_t *)LinFrameDataBuffer;

        *dst++ = *src++;    /* copy 4 words => 8 bytes */
    5bc8:	7108      	lod	A, dp:0x8 <__bist_stat_size>
    5bca:	5152      	mov	dp:0x52 <_LinFrameDataBuffer>, A
        *dst++ = *src++;
    5bcc:	790a      	lod	Y, dp:0xa <__bist_stat_size+0x2>
    5bce:	5954      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, Y
        *dst++ = *src++;
    5bd0:	710c      	lod	A, dp:0xc <__bist_stat_size+0x4>
    5bd2:	5156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, A
        *dst++ = *src++;
    5bd4:	790e      	lod	Y, dp:0xe <__bist_stat_size+0x6>
    5bd6:	5958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, Y

        (void)ml_ReleaseBuffer();           /* release LinFrame[] buffer for MLX4;
    5bd8:	1758      	call	0x5a8a <_ml_ReleaseBuffer>
                                             * of the LIN ISR
                                             */
    }
    /* else : LinFrame (shared) is not copied to LinFrameDataBuffer (mlx16 private) */

    SLVCMD = 0x42U;                     /* Do the handshake and let the Mlx4 go */
    5bda:	6042      	lod	AL, #66
    5bdc:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL
    5be0:	5401      	ret

00005be2 <_ml_ProccessLinEvent>:

/* ----------------------------------------------------------------------------
 * Process LIN event
 */
__MLX_TEXT__  void ml_ProccessLinEvent (void)
{
    5be2:	5803      	inc	S, #4
    ml_LinError Error;
    uint16_t LinCommand;

    LinCommand = LinMessage & 0x000FU;  /* get the command: LinCommand = LinMessage[3:0]    */
    5be4:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5be6:	72e6      	lod	A, Y
    5be8:	b40f      	and	A, #15
    5bea:	5203      	mov	[S-4], A
        }
    }
#else /* standard LIN handler */

#if defined (HAS_LIN_AUTOADDRESSING)
    if ( LinCommand == evCOOLAUTO )    /* Cooling Auto-Addressing pulse */
    5bec:	ac07      	cmp	A, #7
    5bee:	1d07      	jne	0x5bfe <_ml_ProccessLinEvent+0x1c>
    {
        ml_uint8 CoolingPulse = (ml_uint8) ((LinMessage >> 4) & 0x000F);
    5bf0:	44b6      	lsr	Y, #2
    5bf2:	44b6      	lsr	Y, #2
    5bf4:	72e6      	lod	A, Y
    5bf6:	b40f      	and	A, #15
        mlu_AutoAddressingStep( CoolingPulse);
    5bf8:	82db 79ec 	callf	0x79ec <_mlu_AutoAddressingStep>
    5bfc:	00c7      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    }
    else
    {

#endif /* HAS_LIN_AUTOADDRESSING */
    ml_MessageID LinID = (LinMessage >> 8) & 0x003F; /* get the LinID: LinID = LinMessage[13:8] */
    5bfe:	72e6      	lod	A, Y
    5c00:	6000      	lod	AL, #0
    5c02:	72e4      	swap	A
    5c04:	b43f      	and	A, #63
    5c06:	5201      	mov	[S-2], A

#if (LIN_PIN_LOADER != 0)
    if (ml_driver_mode != kLinLoaderMode) {  /* --- Application mode --------------------------- */
    5c08:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    5c0c:	8c55      	cmp	AL, #85
    5c0e:	1d01      	jne	0x5c12 <_ml_ProccessLinEvent+0x30>
    5c10:	009d      	jmp	0x5d4c <_ml_ProccessLinEvent+0x16a>
        if (LDR_GetState() == 0) {
    5c12:	82db 6606 	callf	0x6606 <_LDR_GetState>
    5c16:	8c00      	cmp	AL, #0
    5c18:	1901      	je	0x5c1c <_ml_ProccessLinEvent+0x3a>
    5c1a:	006a      	jmp	0x5cf0 <_ml_ProccessLinEvent+0x10e>
#endif
            switch(LinCommand) {
    5c1c:	7203      	lod	A, [S-4]
    5c1e:	a0ff      	add	A, #-1
    5c20:	ac04      	cmp	A, #4
    5c22:	1a01      	jule	0x5c26 <_ml_ProccessLinEvent+0x44>
    5c24:	00b3      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5c26:	4422      	asl	A
    5c28:	7ae2      	lod	Y, A
    5c2a:	e2da 6ba0 	add	Y, #27552
    5c2e:	72f0      	lod	A, [Y]
    5c30:	76e2      	jmp	A
                     * LinMessage[7:4]      New state
                     * LinMessage[3:0]      event code
                     */
                    ml_uint16 NewState;

                    NewState = LinMessage & 0x00F0U;
    5c32:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5c34:	72e6      	lod	A, Y
    5c36:	b6da 00f0 	and	A, #240
                    if ((stSLEEP << 4) == NewState) {           /* signal to application only transition to SLEEP state */
    5c3a:	ac40      	cmp	A, #64
    5c3c:	1901      	je	0x5c40 <_ml_ProccessLinEvent+0x5e>
    5c3e:	00a6      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_OUT | IO4_ENABLE;            /* IO4 = 1 */
#endif

                        ml_StateReason Reason = (ml_StateReason)((LinMessage >> 12) & 0x000FU);    /* decode the reason of SLEEP */
    5c40:	44c6      	rl	Y, #2
    5c42:	44c6      	rl	Y, #2
    5c44:	f40f      	and	Y, #15
                        mlu_LinSleepMode(Reason);
    5c46:	72e6      	lod	A, Y
    5c48:	82db 78cc 	callf	0x78cc <_mlu_LinSleepMode>
                    }
                    /* else: skip signaling other transitions */
                    }
                    break;
    5c4c:	009f      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

                case evERR :    /* error detected by the LIN task */
                    /* get the error type */
                    Error = (LinMessage >> 4) & 0x000F;
    5c4e:	795c      	lod	Y, dp:0x5c <_LinMessage>
    5c50:	72e6      	lod	A, Y
    5c52:	44b2      	lsr	A, #2
    5c54:	44b2      	lsr	A, #2
    5c56:	b40f      	and	A, #15
    5c58:	7ee2      	lod	X, A

                    if (ml_erBit == Error) {
    5c5a:	ac05      	cmp	A, #5
    5c5c:	1d0e      	jne	0x5c7a <_ml_ProccessLinEvent+0x98>
                        *
                        * LinMessage[12:15] Crashed Byte
                        *                   0-8: data byte number
                        *                   15: collision before start of TX
                        */
                        crashedBit = (ml_uint8) ((LinMessage >> 8) & 0x000F);
    5c5e:	6400      	lod	YL, #0
    5c60:	7ae8      	swap	Y
    5c62:	72e6      	lod	A, Y
    5c64:	b40f      	and	A, #15
                        crashedByte = (ml_uint8) ((LinMessage >> 12) & 0x000F);
    5c66:	44b6      	lsr	Y, #2
    5c68:	44b6      	lsr	Y, #2

                        /* If collision was during TX of STOP bit,
                         * report it as a separate error (SAE J2602)
                         */
                        if ( ((crashedBit == 0) || (crashedBit > 9)) && (crashedByte != 15) ) {
    5c6a:	80ff      	add	AL, #-1
    5c6c:	8c08      	cmp	AL, #8
    5c6e:	1a17      	jule	0x5c9e <_ml_ProccessLinEvent+0xbc>
    5c70:	62e8      	lod	AL, YL
    5c72:	8c0f      	cmp	AL, #15
    5c74:	1914      	je	0x5c9e <_ml_ProccessLinEvent+0xbc>
                            Error = ml_erStopBitTX;
    5c76:	7c10      	lod	X, #16
    5c78:	0012      	jmp	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        }
                        /* else : collision was during TX of the data bits */
                    }
                    else if (ml_erBreakDetected == Error) {
    5c7a:	ac0c      	cmp	A, #12
    5c7c:	1d05      	jne	0x5c88 <_ml_ProccessLinEvent+0xa6>
                        ml_uint8 nbytes; /* number of received bytes */

                        nbytes = (LinMessage >> 12) & 0x000F;  /* get LINmess+3 parameter */
    5c7e:	44c6      	rl	Y, #2
    5c80:	44c6      	rl	Y, #2
    5c82:	f40f      	and	Y, #15
                        if(nbytes == 0)
    5c84:	1d0c      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        {
                            /* TODO also check if ID byte = 0, otherwise it is a real stop bit error */
                            break;
    5c86:	0082      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                        }
                    }
                    else if (ml_erLinModuleReset == Error)  {
    5c88:	ac02      	cmp	A, #2
    5c8a:	1d09      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                        ml_uint8 subcode;

                        subcode = (LinMessage >> 8) & 0x000F;  /* get LINmess+2 parameter */
    5c8c:	6400      	lod	YL, #0
    5c8e:	7ae8      	swap	Y
    5c90:	72e6      	lod	A, Y
    5c92:	b40f      	and	A, #15

                        if (subcode == erCRASHTX) {
    5c94:	8c02      	cmp	AL, #2
    5c96:	1d03      	jne	0x5c9e <_ml_ProccessLinEvent+0xbc>
                            /* Propagation delay error : TX/RX propagation can not
                             * be calculated by LIN module due to collision at start bit
                             * of the own response. Both dominant and recessive collisions
                             * could be the reason of this error
                             */
                            (void)ml_Disconnect();  /* for safety and clarity (MLX4 is already in disconnected state) */
    5c98:	1780      	call	0x5b9a <_ml_Disconnect>
                            (void)ml_Connect();
    5c9a:	177d      	call	0x5b96 <_ml_Connect>
                            Error = ml_erBit; /* map this error to "collision error" for application */
    5c9c:	7c05      	lod	X, #5
                        }
                    }
                    /* else :  Nothing for other errors */

                    mlu_ErrorDetected(Error); /* notify application about error */
    5c9e:	72ee      	lod	A, X
    5ca0:	82db 78b6 	callf	0x78b6 <_mlu_ErrorDetected>
                    break;
    5ca4:	0073      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                case evMESSrcvd :/* Message received (data is available in the buffer) */

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif
                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5ca6:	7104      	lod	A, dp:0x4 <_LinMess>
    5ca8:	52d8 00e8 	mov	0xe8 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cac:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cae:	42d8 00ea 	mov	0xea <_LINBaud>, AL

#if (LIN_PIN_LOADER != 0)
                    if (LinID != D_DIA) {  /* fast check if it is not MRF frame */
    5cb2:	6201      	lod	AL, [S-2]
    5cb4:	8c10      	cmp	AL, #16
    5cb6:	1902      	je	0x5cbc <_ml_ProccessLinEvent+0xda>
                        mlu_MessageReceived(LinID); /* notify application */
    5cb8:	7201      	lod	A, [S-2]
    5cba:	000a      	jmp	0x5cd0 <_ml_ProccessLinEvent+0xee>
                    }
                    else if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_FALSE) ) { /* check if we received a Read By ID for the loader */
    5cbc:	54ca 0000 	pushw	#0
    5cc0:	72da 0052 	lod	A, #82
    5cc4:	10b5      	call	0x5e30 <_ldr_isReadByIdMessage>
    5cc6:	5c01      	dec	S, #2
    5cc8:	8c00      	cmp	AL, #0
    5cca:	1901      	je	0x5cce <_ml_ProccessLinEvent+0xec>
    5ccc:	0034      	jmp	0x5d36 <_ml_ProccessLinEvent+0x154>
                        ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
                    }
                    else {
                        mlu_MessageReceived(D_DIA); /* notify application */
    5cce:	7010      	lod	A, #16
    5cd0:	82db 78f2 	callf	0x78f2 <_mlu_MessageReceived>
                    }
#else
                    mlu_MessageReceived(LinID); /* notify application */
#endif /* LIN_PIN_LOADER */                    
                    break;
    5cd4:	005b      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

#if defined (DEBUG_HAS_SLEEP_STATE_MARKER)
                    IO_EXTIO = IO4_ENABLE;  /* IO4 = 0 */
#endif

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5cd6:	7104      	lod	A, dp:0x4 <_LinMess>
    5cd8:	52d8 00e8 	mov	0xe8 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5cdc:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5cde:	42d8 00ea 	mov	0xea <_LINBaud>, AL

                    mlu_DataRequest(LinID);
    5ce2:	7201      	lod	A, [S-2]
    5ce4:	82db 77ea 	callf	0x77ea <_mlu_DataRequest>
                    break;
    5ce8:	0051      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

                case evENDtx :  /* Transmit done (without any collision) */
                    mlu_DataTransmitted();
    5cea:	82db 784e 	callf	0x784e <_mlu_DataTransmitted>
                    break;
    5cee:	004e      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
        }
        /*
         * state != 0 => flash reprogramming states
         */
        else {
            switch(LinCommand) {
    5cf0:	7203      	lod	A, [S-4]
    5cf2:	ac03      	cmp	A, #3
    5cf4:	190d      	je	0x5d10 <_ml_ProccessLinEvent+0x12e>
    5cf6:	1e03      	jug	0x5cfe <_ml_ProccessLinEvent+0x11c>
    5cf8:	ac02      	cmp	A, #2
    5cfa:	1905      	je	0x5d06 <_ml_ProccessLinEvent+0x124>
    5cfc:	0047      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5cfe:	7203      	lod	A, [S-4]
    5d00:	ac04      	cmp	A, #4
    5d02:	191d      	je	0x5d3e <_ml_ProccessLinEvent+0x15c>
    5d04:	0043      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                case evERR :    /* error detected by the LIN task */
                    /*
                     * There is no recovering from critical error erCRASH, erCRASHTX
                     * A reset should be applied to recover from such errors
                     */
                    Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d06:	615c      	lod	AL, dp:0x5c <_LinMessage>
    5d08:	44b2      	lsr	A, #2
    5d0a:	44b2      	lsr	A, #2
    5d0c:	b40f      	and	A, #15
    5d0e:	002f      	jmp	0x5d6e <_ml_ProccessLinEvent+0x18c>
                    ml_ldr_ErrorDetected(Error);        /* notify flash loader about error */
                    break;

                case evMESSrcvd :/* Message received (data is available in the buffer) */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d10:	7104      	lod	A, dp:0x4 <_LinMess>
    5d12:	52d8 00e8 	mov	0xe8 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d16:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d18:	42d8 00ea 	mov	0xea <_LINBaud>, AL

                    if (LinID == D_DIA) {
    5d1c:	6201      	lod	AL, [S-2]
    5d1e:	8c10      	cmp	AL, #16
    5d20:	1901      	je	0x5d24 <_ml_ProccessLinEvent+0x142>
    5d22:	0034      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                        if ( ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE) ) { /* check if we received a Read By ID for the loader */
    5d24:	54ca 0001 	pushw	#1
    5d28:	72da 0052 	lod	A, #82
    5d2c:	1081      	call	0x5e30 <_ldr_isReadByIdMessage>
    5d2e:	5c01      	dec	S, #2
    5d30:	8c00      	cmp	AL, #0
    5d32:	1d01      	jne	0x5d36 <_ml_ProccessLinEvent+0x154>
    5d34:	002b      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                            ml_ldr_ReadByIdMessage(LinFrameDataBuffer[3]);
    5d36:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    5d38:	5cf2      	usex	A
    5d3a:	11ed      	call	0x6116 <_ml_ldr_ReadByIdMessage>
    5d3c:	0027      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                    }
                    break;

                case evMESSrqst :/* ID received, TX identified, request data */

                    LINPresc = LinMess;     /* Copy LIN prescaller |XXXX|XXXX|PRES|XXXX| */
    5d3e:	7104      	lod	A, dp:0x4 <_LinMess>
    5d40:	52d8 00e8 	mov	0xe8 <_LINPresc>, A
                    LINBaud  = LinMess2;    /* Copy LIN baud (divider) */
    5d44:	6106      	lod	AL, dp:0x6 <_LinMess2>
    5d46:	42d8 00ea 	mov	0xea <_LINBaud>, AL
    5d4a:	001d      	jmp	0x5d86 <_ml_ProccessLinEvent+0x1a4>
            }
        }
    }
    else {
         /* --- Loader mode -------------------------------------------------- */
         switch(LinCommand) {
    5d4c:	7203      	lod	A, [S-4]
    5d4e:	ac03      	cmp	A, #3
    5d50:	1910      	je	0x5d72 <_ml_ProccessLinEvent+0x190>
    5d52:	1e03      	jug	0x5d5a <_ml_ProccessLinEvent+0x178>
    5d54:	ac02      	cmp	A, #2
    5d56:	1907      	je	0x5d66 <_ml_ProccessLinEvent+0x184>
    5d58:	0019      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5d5a:	7203      	lod	A, [S-4]
    5d5c:	ac04      	cmp	A, #4
    5d5e:	1913      	je	0x5d86 <_ml_ProccessLinEvent+0x1a4>
    5d60:	ac05      	cmp	A, #5
    5d62:	1913      	je	0x5d8a <_ml_ProccessLinEvent+0x1a8>
    5d64:	0013      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
             case evERR :    /* error detected by the LIN task */
                 Error = (LinMessage >> 4) & 0x000F; /* get the error type */
    5d66:	44b6      	lsr	Y, #2
    5d68:	44b6      	lsr	Y, #2
    5d6a:	f40f      	and	Y, #15
                 ml_ldr_ErrorDetected(Error); /* notify flash loader about error */
    5d6c:	72e6      	lod	A, Y
    5d6e:	113c      	call	0x5fe8 <_ml_ldr_ErrorDetected>
                 break;
    5d70:	000d      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

             case evMESSrcvd : /* Message received (data is available in the buffer) */
                 if ( (LinID == D_DIA) /* MRF diag frame */
    5d72:	6201      	lod	AL, [S-2]
    5d74:	8c10      	cmp	AL, #16
    5d76:	1d0a      	jne	0x5d8c <_ml_ProccessLinEvent+0x1aa>
    5d78:	6152      	lod	AL, dp:0x52 <_LinFrameDataBuffer>
    5d7a:	8d5a      	cmp	AL, dp:0x5a <_LIN_nad>
    5d7c:	1902      	je	0x5d82 <_ml_ProccessLinEvent+0x1a0>
    5d7e:	8c7f      	cmp	AL, #127
    5d80:	1d05      	jne	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                      && (   (LinFrameDataBuffer[0] == LIN_nad)
                          || (LinFrameDataBuffer[0] == 0x7F /* wildcard */ )))
                 {
                     ml_DiagReceived();  /* notify loader */
    5d82:	1217      	call	0x61b2 <_ml_DiagReceived>
    5d84:	0003      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>
                     /* ignore message */
                 }
                 break;

             case evMESSrqst :   /* message ID received, TX identified, request data */
                 (void)ml_DiscardFrame();   /* other requests are not expected in the loader mode */
    5d86:	16b1      	call	0x5aea <_ml_DiscardFrame>
                 break;
    5d88:	0001      	jmp	0x5d8c <_ml_ProccessLinEvent+0x1aa>

             case evENDtx :  /* Transmit done (without any collision) */
                 ml_DiagRequest();
    5d8a:	11e1      	call	0x614e <_ml_DiagRequest>
#if defined (HAS_LIN_AUTOADDRESSING)
    }
#endif /* HAS_LIN_AUTOADDRESSING */
#endif /* STANDALONE_LOADER */

    SLVIT = 0xABU;  /* Enable Event interrupt (SLVIT[8] = 1) (get ready for the next interrupt) */
    5d8c:	60ab      	lod	AL, #-85
    5d8e:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL
    5d92:	5405      	ret	#6

00005d94 <_ml_SetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To set NAD for Loader (by default value is MLX_NAD).
 */
__MLX_TEXT__ ml_Status ml_SetLoaderNAD(ml_uint8 Nad)
{
    stFixedRamNAD.nad = Nad;
    5d94:	42d8 0014 	mov	0x14 <__data_dp_size+0x4>, AL
    stFixedRamNAD.key = _mlx_NAD_Security_Key;
    5d98:	7ada 0010 	lod	Y, #16
    5d9c:	7eda 72ef 	lod	X, #29423
    5da0:	5ef0      	mov	[Y], X
    5da2:	7eda e861 	lod	X, #59489
    5da6:	5ef2      	mov	[Y+2], X
    LIN_nad = Nad;
    5da8:	415a      	mov	dp:0x5a <_LIN_nad>, AL
    return ML_SUCCESS;
}
    5daa:	7000      	lod	A, #0
    5dac:	5401      	ret

00005dae <_ml_GetLoaderNAD>:
/* ----------------------------------------------------------------------------
 * To get NAD of Loader.
 */
__MLX_TEXT__ ml_uint8 ml_GetLoaderNAD(void)
{
    return LIN_nad;
    5dae:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5db0:	5cf2      	usex	A
}
    5db2:	5401      	ret

00005db4 <_linit>:
 * This function is called whenever an EVENT interrupt from the LIN task (Mlx4)
 * occurs
 */
void __interrupt__ ml_LinInterruptHandler(void);
__MLX_TEXT__  void ml_LinInterruptHandler(void)
{
    5db4:	52df      	push	A
    5db6:	5edf      	push	X
    5db8:	5adf      	push	Y
    5dba:	4c83      	push	D
    ml_GetLinEventData();
    5dbc:	16fa      	call	0x5bb2 <_ml_GetLinEventData>
    ml_ProccessLinEvent();
    5dbe:	1711      	call	0x5be2 <_ml_ProccessLinEvent>
    5dc0:	4cc3      	pop	D
    5dc2:	7acf      	pop	Y
    5dc4:	7ecf      	pop	X
    5dc6:	72cf      	pop	A
    5dc8:	4407      	mov	R, #0
    5dca:	72cb      	pop	M
    5dcc:	5401      	ret

00005dce <_ml_InitLinModule>:
     * Assuming that LIN interrupt priority (if availabe for configuration)
     * is set by the application
     */

#if (LIN_PIN_LOADER != 0)
    if (   (0 == LDR_GetState())
    5dce:	82db 6606 	callf	0x6606 <_LDR_GetState>
    5dd2:	8c00      	cmp	AL, #0
    5dd4:	1d0a      	jne	0x5dea <_ml_InitLinModule+0x1c>
    5dd6:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    5dda:	aeda 3212 	cmp	A, #12818
    5dde:	1905      	je	0x5dea <_ml_InitLinModule+0x1c>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {  /* if we're in loader state 0 (application mode) .. */
        ENABLE_MLX4_INT();      /* .. enable LIN interrupt                          */
    5de0:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    5de4:	a410      	or	A, #16
    5de6:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    5dea:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    5dec:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    5dee:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    5df0:	b430      	and	A, #48
    5df2:	1902      	je	0x5df8 <_ml_InitLinModule+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    5df4:	6000      	lod	AL, #0
    5df6:	4282      	mov	io:0x2 <_LinCmnd>, AL
    /* MLX4/MLX16 synchronization.
     * If the Mlx16 is here before the Mlx4, it will wait for MLX4.
     * If the Mlx4 reached this point before MLX16, then the Mlx16 does not wait
     */
    WDG_Manager();              /* keep system alive    */
    SLVCMD = 0x84U;             /* signal to MLX4       */
    5df8:	6084      	lod	AL, #-124
    5dfa:	42d8 200a 	mov	0x200a <__ep__+0x100a>, AL

    while ( (SLVCMD & 0x04U) == 0U ) {
    5dfe:	62d8 200a 	lod	AL, 0x200a <__ep__+0x100a>
    5e02:	b404      	and	A, #4
    5e04:	197c      	je	0x5dfe <_ml_InitLinModule+0x30>
     * (event). Before that, it is going to send an event to indicate a state
     * change. Now that the initialization of both chips is done (the LIN part
     * still needs to be configured!) enable the interrupts to allow inter-chip
     * communication
     */
    SLVIT = 0xABU;          /* Enable Mlx4 Event interrupt */
    5e06:	60ab      	lod	AL, #-85
    5e08:	42d8 200b 	mov	0x200b <__ep__+0x100b>, AL

#if (LIN_PIN_LOADER != 0)
    ml_driver_mode = kLinAppMode;
    5e0c:	6000      	lod	AL, #0
    5e0e:	42d8 005e 	mov	0x5e <_ml_driver_mode>, AL

    /* Initial NAD */
    if (stFixedRamNAD.key == _mlx_NAD_Security_Key)
    5e12:	72d8 0010 	lod	A, 0x10 <__data_dp_size>
    5e16:	7ad8 0012 	lod	Y, 0x12 <__data_dp_size+0x2>
    5e1a:	4cb2 72ef 	cmp	YA, #-396266769
    5e1e:	e861 
    5e20:	1d03      	jne	0x5e28 <_ml_InitLinModule+0x5a>
    {
        LIN_nad = stFixedRamNAD.nad;
    5e22:	62d8 0014 	lod	AL, 0x14 <__data_dp_size+0x4>
    5e26:	0001      	jmp	0x5e2a <_ml_InitLinModule+0x5c>
    }
    else
    {
        LIN_nad = MLX_NAD_DEFAULT;
    5e28:	6001      	lod	AL, #1
    5e2a:	415a      	mov	dp:0x5a <_LIN_nad>, AL
    }
#endif /* LIN_PIN_LOADER */

    return ML_SUCCESS;
}
    5e2c:	7000      	lod	A, #0
    5e2e:	5401      	ret

00005e30 <_ldr_isReadByIdMessage>:
 *
 * Inputs: LIN_nad(Global), READ_BY_ID_BC, LDR_SUPPLIER_ID, LDR_FUNCTION_ID
 *
 */
__MLX_TEXT__ ml_bool ldr_isReadByIdMessage (const void *buffer, ml_bool CheckWildcard)
{
    5e30:	5801      	inc	S, #2
    5e32:	7ae2      	lod	Y, A
    5e34:	6205      	lod	AL, [S-6]
    5e36:	5cf2      	usex	A
    5e38:	5201      	mov	[S-2], A
    uint16_t const *src = (uint16_t const *)buffer;

    if ( ( (src[0] == (READ_BY_ID_BC[0] | 0x7F )) ||    /* LIN_nad or wildcard (0x7F) */
    5e3a:	7ef0      	lod	X, [Y]
    5e3c:	2eda 067f 	cmp	X, #1663
    5e40:	1907      	je	0x5e50 <_ldr_isReadByIdMessage+0x20>
    5e42:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5e44:	b6da 06ff 	and	A, #1791
    5e48:	a6da 0600 	or	A, #1536
    5e4c:	2ee2      	cmp	X, A
    5e4e:	1d15      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e50:	72f2      	lod	A, [Y+2]
    5e52:	8cb2      	cmp	AL, #-78
    5e54:	1d12      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e56:	7ef4      	lod	X, [Y+4]
    5e58:	2c13      	cmp	X, #19
    5e5a:	1d04      	jne	0x5e64 <_ldr_isReadByIdMessage+0x34>
    5e5c:	72f6      	lod	A, [Y+6]
    5e5e:	aeda cafe 	cmp	A, #51966
    5e62:	1909      	je	0x5e76 <_ldr_isReadByIdMessage+0x46>
    5e64:	6201      	lod	AL, [S-2]
    5e66:	8c01      	cmp	AL, #1
    5e68:	1d08      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e6a:	2eda 7fff 	cmp	X, #32767
    5e6e:	1d05      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
    5e70:	72f6      	lod	A, [Y+6]
    5e72:	acff      	cmp	A, #-1
    5e74:	1d02      	jne	0x5e7a <_ldr_isReadByIdMessage+0x4a>
             )
           )
         )
       )
    {
        return ML_TRUE;
    5e76:	7001      	lod	A, #1
    5e78:	5403      	ret	#4
    }
    else
    {
        return ML_FALSE;
    5e7a:	7000      	lod	A, #0
    }
}
    5e7c:	5403      	ret	#4
 *  LinFrameDataBuffer[]: out, LIN frame buffer
 *  LIN_nad : in, LIN Node Address
 *  MLX4_error: in/out
 */
__MLX_TEXT__  static void ml_PrepareErrorResponse (ml_MLX16_error_t MLX16_error)
{
    5e7e:	5801      	inc	S, #2
    5e80:	5201      	mov	[S-2], A
    LinFrameDataBuffer[0] = LIN_nad;    /* NAD */
    5e82:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5e84:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 3;          /* PCI */
    5e86:	6003      	lod	AL, #3
    5e88:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0x7F;       /* RSID */
    5e8a:	607f      	lod	AL, #127
    5e8c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = ML_ERROR_BIT | LDR_GetState();      /* NodeStatus */
    5e8e:	13bb      	call	0x6606 <_LDR_GetState>
    5e90:	8480      	or	AL, #-128
    5e92:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)MLX16_error | MLX4_error; /* Combine MLX16_error (4 MSBs) and MLX4_error (4 LSBs) */
    5e94:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5e96:	8601      	or	AL, [S-2]
    5e98:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL

    LinFrameDataBuffer[5] = 0xFF;       /* not used */
    5e9a:	60ff      	lod	AL, #-1
    5e9c:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = 0xFF;
    5e9e:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
    LinFrameDataBuffer[7] = 0xFF;
    5ea0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    /* Reset last error after reporting. If transmission of the status message
     * failed we will get another error which cause this failure. This _last_
     * detected error will be reported to master in next status frame.
     * Master aborts operation on any error.
     */
    MLX4_error = 0;  /* set to "No error" */
    5ea2:	6000      	lod	AL, #0
    5ea4:	415f      	mov	dp:0x5f <_ml_driver_mode+0x1>, AL
    5ea6:	5403      	ret	#4
 *
 * \note
 * 1. Assumes that SID of request is 0xB4
 */
__MLX_TEXT__  static uint8 ml_FlashUploadStatus (ml_MLX16_error_t MLX16_error)
{
    5ea8:	5801      	inc	S, #2
    5eaa:	7ae2      	lod	Y, A
    uint8 blReturn;

    if ((MLX16_error != ddErNONE) || (MLX4_error != 0)) {  /* MLX16 or MLX4 error */
    5eac:	aeda 00f0 	cmp	A, #240
    5eb0:	1d02      	jne	0x5eb6 <_ldr_isReadByIdMessage+0x86>
    5eb2:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5eb4:	1904      	je	0x5ebe <_ldr_isReadByIdMessage+0x8e>
        ml_PrepareErrorResponse(MLX16_error);
    5eb6:	72e6      	lod	A, Y
    5eb8:	17e2      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
        blReturn = ML_FALSE;
    5eba:	7000      	lod	A, #0
    5ebc:	000e      	jmp	0x5eda <_ldr_isReadByIdMessage+0xaa>
    }
    else { /* no error, reply status */
        LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    5ebe:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5ec0:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 2;                  /* PCI : length = 2 databytes (SID + status) */
    5ec2:	6002      	lod	AL, #2
    5ec4:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    5ec6:	60f4      	lod	AL, #-12
    5ec8:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    5eca:	139d      	call	0x6606 <_LDR_GetState>
    5ecc:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL

        LinFrameDataBuffer[4] = 0xFF;               /* not used */
    5ece:	60ff      	lod	AL, #-1
    5ed0:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
        LinFrameDataBuffer[5] = 0xFF;
    5ed2:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
        LinFrameDataBuffer[6] = 0xFF;
    5ed4:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
        LinFrameDataBuffer[7] = 0xFF;
    5ed6:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
        blReturn = ML_TRUE;
    5ed8:	7001      	lod	A, #1
    5eda:	5201      	mov	[S-2], A
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);      /* Signal to MLX4 that the data is ready */
    5edc:	7000      	lod	A, #0
    5ede:	15dc      	call	0x5a98 <_ml_DataReady>

    return ( blReturn );
}
    5ee0:	7201      	lod	A, [S-2]
    5ee2:	5403      	ret	#4
 *      LinFrameDataBuffer[]  LIN frame buffer
 *
 * Global variables used : ddDataAddress, ddDataCounter, ddDataSize, ddCurrentOp
 */
__MLX_TEXT__  static void ml_ReadData (ml_uint8 BufferIndex, ml_uint8 BufferSize)
{
    5ee4:	5807      	inc	S, #8
    5ee6:	660b      	lod	YL, [S-12]
    5ee8:	5cf6      	usex	Y
    5eea:	7ee6      	lod	X, Y
    uint16_t size = BufferSize;
    uint8_t *src = (uint8_t *)(ddDataAddress + ddDataCounter);      /* read byte directly from memory */
    5eec:	7966      	lod	Y, dp:0x66 <_ml_driver_mode+0x8>
    5eee:	e16e      	add	Y, dp:0x6e <_ml_driver_mode+0x10>
    5ef0:	5a07      	mov	[S-8], Y
    uint8_t *dst = (uint8_t *)(&LinFrameDataBuffer[BufferIndex]);
    5ef2:	7ae2      	lod	Y, A
    5ef4:	e2da 0052 	add	Y, #82


    do {
        if (ddDataCounter < ddDataSize) {   /* if there's something to send ..  */
    5ef8:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    5efa:	5205      	mov	[S-6], A
    5efc:	72e6      	lod	A, Y
    5efe:	a001      	add	A, #1
    5f00:	5203      	mov	[S-4], A
    5f02:	20ff      	add	X, #-1
    5f04:	5e01      	mov	[S-2], X
    5f06:	7e05      	lod	X, [S-6]
    5f08:	2d6a      	cmp	X, dp:0x6a <_ml_driver_mode+0xc>
    5f0a:	1c04      	jnc	0x5f14 <_ldr_isReadByIdMessage+0xe4>
            *dst++ = *src++;                /* .. take it from memory           */
    5f0c:	7e07      	lod	X, [S-8]
    5f0e:	62de      	lod	AL, [X++]
    5f10:	5e07      	mov	[S-8], X
    5f12:	0001      	jmp	0x5f16 <_ldr_isReadByIdMessage+0xe6>
        }
        else {                              /* no more data in memory .. */
            *dst++ = 0xFF;                  /* .. fill up the rest of the frame with 0xFF */
    5f14:	60ff      	lod	AL, #-1
    5f16:	42f0      	mov	[Y], AL
    5f18:	7a03      	lod	Y, [S-4]
        }

        ddDataCounter += 1;
    5f1a:	7205      	lod	A, [S-6]
    5f1c:	a001      	add	A, #1
    5f1e:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    } while (--size != 0);
    5f20:	7e01      	lod	X, [S-2]
    5f22:	1d6a      	jne	0x5ef8 <_ldr_isReadByIdMessage+0xc8>

    if (ddDataCounter >= ddDataSize) {      /* if all requested data were sent .. */
    5f24:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    5f26:	1802      	jc	0x5f2c <_ldr_isReadByIdMessage+0xfc>
        (void)ml_ContFrame(ML_DISABLED);    /* .. clear the Continuous Frames flag for the Mlx4 */
    5f28:	7000      	lod	A, #0
    5f2a:	15e1      	call	0x5aee <_ml_ContFrame>
    5f2c:	5409      	ret	#10
 *  1. Can be a Single Frame or a First Frame
 *      Single Frame format : NAD RPCI RSID NodeStatus Data1 Data2 Data3 Data4
 *      First Frame format  : NAD RPCI RLEN RSID NodeStatus Data1 Data2 Data3
 */
__MLX_TEXT__  static void ml_SendReadResponse(void)
{
    5f2e:	5801      	inc	S, #2
    ml_uint16 ResponseLength;


    if (MLX4_error != 0) {
    5f30:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5f32:	1904      	je	0x5f3c <_ldr_isReadByIdMessage+0x10c>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5f34:	72da 00f0 	lod	A, #240
    5f38:	17a2      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5f3a:	0039      	jmp	0x5fae <_ldr_isReadByIdMessage+0x17e>
    }
    else {  /* Prepare the Response */
        ResponseLength = ddDataSize + 2;    /* Length = flash data + status + SID */
    5f3c:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    5f3e:	7ae2      	lod	Y, A
    5f40:	e002      	add	Y, #2
    5f42:	5a01      	mov	[S-2], Y

        if (ddDataSize > 4) {   /* if more than 4 bytes are requested than will send using Continuous Frames .. */
    5f44:	ac04      	cmp	A, #4
    5f46:	1a17      	jule	0x5f76 <_ldr_isReadByIdMessage+0x146>

            (void)ml_ContFrame(ML_ENABLED);/* signal to MLX4 that some Continuous Frames are coming */
    5f48:	7001      	lod	A, #1
    5f4a:	15d1      	call	0x5aee <_ml_ContFrame>
                                /* Next frames will be TX frames (see ml_DiagRequest) */

            ddFrameCounter = 0; /* reset frame counter */
    5f4c:	6000      	lod	AL, #0
    5f4e:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

            /* Fill the buffer for the First Frame (FF) */
            LinFrameDataBuffer[0] = LIN_nad;                                            /* NAD */
    5f50:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5f52:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x10 | (ml_uint8) ((ResponseLength & 0x0F00) >> 8); /* PCI = 0001 xxxx where xxxx is length/256 */
    5f54:	7201      	lod	A, [S-2]
    5f56:	b6da 0f00 	and	A, #3840
    5f5a:	6000      	lod	AL, #0
    5f5c:	72e4      	swap	A
    5f5e:	8410      	or	AL, #16
    5f60:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = (ml_uint8) (ResponseLength & 0x00FF);               /* note : RLEN has to be < 4095 (spec)      */
    5f62:	6601      	lod	YL, [S-2]
    5f64:	4554      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, YL
            LinFrameDataBuffer[3] = 0xF4;                                               /* RSID =  SID + 0x40 */
    5f66:	60f4      	lod	AL, #-12
    5f68:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = LDR_GetState();                                     /* NodeStatus : since no error, error bit is not set */
    5f6a:	134d      	call	0x6606 <_LDR_GetState>
    5f6c:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
            ml_ReadData(5, 3);    /* FF: copy to LinFrameDataBuffer[5] next 3 bytes from (ddDataAddress + ddDataCounter) */
    5f6e:	54ca 0003 	pushw	#3
    5f72:	7005      	lod	A, #5
    5f74:	001a      	jmp	0x5faa <_ldr_isReadByIdMessage+0x17a>
        }
        else { /* Single Frame (SF) is enough to deliver 4 (or less) bytes */

            /* Fill the buffer */
            LinFrameDataBuffer[0] = LIN_nad;
    5f76:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5f78:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = (ml_uint8) ResponseLength;  /* RPCI = length */
    5f7a:	6201      	lod	AL, [S-2]
    5f7c:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF4;                       /* RSID =  SID + 0x40 */
    5f7e:	60f4      	lod	AL, #-12
    5f80:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
            LinFrameDataBuffer[3] = LDR_GetState();             /* NodeStatus : since no error, error bit is not set */
    5f82:	1341      	call	0x6606 <_LDR_GetState>
    5f84:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            /*
             * Intercept direct loader state reading from Flash (a word @ 0xBF66) and
             * replace it by the loader state returned by LDR_GetState()
             * TODO: MPT should not read loader state directly
             */
            if ((ddDataAddress == 0xBF66) && (ddDataSize == 2)) {   /* if a _word_ reading from address 0xBF66 is requested .. */
    5f86:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    5f88:	aeda bf66 	cmp	A, #48998
    5f8c:	1d0b      	jne	0x5fa4 <_ldr_isReadByIdMessage+0x174>
    5f8e:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    5f90:	ac02      	cmp	A, #2
    5f92:	1d08      	jne	0x5fa4 <_ldr_isReadByIdMessage+0x174>
                LinFrameDataBuffer[4] = LDR_GetState();             /* .. replace it by a state information (LSByte) */
    5f94:	1338      	call	0x6606 <_LDR_GetState>
    5f96:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
                LinFrameDataBuffer[5] = 0;                          /* .. MSByte of the loader state is always 0 */
    5f98:	6400      	lod	YL, #0
    5f9a:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
                LinFrameDataBuffer[6] = 0xFF;                       /* frame padding */
    5f9c:	60ff      	lod	AL, #-1
    5f9e:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
                LinFrameDataBuffer[7] = 0xFF;                       /* frame padding */
    5fa0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    5fa2:	0005      	jmp	0x5fae <_ldr_isReadByIdMessage+0x17e>
            }
            else {
                ml_ReadData(4, 4);  /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
    5fa4:	54ca 0004 	pushw	#4
    5fa8:	7004      	lod	A, #4
    5faa:	179c      	call	0x5ee4 <_ldr_isReadByIdMessage+0xb4>
    5fac:	5c01      	dec	S, #2
            ml_ReadData(4, 4);      /* SF: copy to LinFrameDataBuffer[4] next 4 bytes from (ddDataAddress + ddDataCounter) */
#endif
        }
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal that the data is ready to send */
    5fae:	7000      	lod	A, #0
    5fb0:	1573      	call	0x5a98 <_ml_DataReady>
    5fb2:	5403      	ret	#4
/* ----------------------------------------------------------------------------
 * Send a response to a write request (to flash, RAM or EEPROM)
 * Frame format : NAD PCI RSID NodeStatus BLK1 BLK0 TIM1 TIM0
 */
__MLX_TEXT__  static void ml_SendWriteResponse(uint16_t timeout)
{
    5fb4:	5801      	inc	S, #2
    5fb6:	5201      	mov	[S-2], A
    if (MLX4_error != 0) {
    5fb8:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5fba:	1904      	je	0x5fc4 <_ldr_isReadByIdMessage+0x194>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5fbc:	72da 00f0 	lod	A, #240
    5fc0:	175e      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5fc2:	000f      	jmp	0x5fe2 <_ldr_isReadByIdMessage+0x1b2>
    }
    else {
        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    5fc4:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    5fc6:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;                               /* PCI (Single Frame + Length) */
    5fc8:	6006      	lod	AL, #6
    5fca:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;                               /* RSID = SID + 0x40 */
    5fcc:	60f4      	lod	AL, #-12
    5fce:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = LDR_GetState();                     /* NodeStatus : since no error, error bit is not set */
    5fd0:	131a      	call	0x6606 <_LDR_GetState>
    5fd2:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (ml_uint8)(ddDataSize >> 8);        /* Size of next allowed block (MSB) */
    5fd4:	796a      	lod	Y, dp:0x6a <_ml_driver_mode+0xc>
    5fd6:	4d56      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (ml_uint8)(ddDataSize & 0x00FF);    /* Size of next allowed block (LSB) */
    5fd8:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (ml_uint8)(timeout >> 8);           /* command execution time (MSB)     */
    5fda:	7201      	lod	A, [S-2]
    5fdc:	4958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (ml_uint8)(timeout & 0xFF);         /* command execution time (LSB)     */
    5fde:	6201      	lod	AL, [S-2]
    5fe0:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
    }

    (void)ml_DataReady(ML_END_OF_TX_DISABLED);                      /* Signal to MLX4 that the data is ready */
    5fe2:	7000      	lod	A, #0
    5fe4:	1559      	call	0x5a98 <_ml_DataReady>
    5fe6:	5403      	ret	#4

00005fe8 <_ml_ldr_ErrorDetected>:
{
    /*
     * Sometimes erShort error is detected by MLX4 during flash uploading due to
     * transition slow/fast mode. Ignore ml_erShort error during reprogramming
     */
    if (Error != ml_erShort) {
    5fe8:	ac0a      	cmp	A, #10
    5fea:	1901      	je	0x5fee <_ml_ldr_ErrorDetected+0x6>
        MLX4_error = (ml_uint8)Error;  /* save as last detected MLX4 error */
    5fec:	415f      	mov	dp:0x5f <_ml_driver_mode+0x1>, AL
    5fee:	5401      	ret
 * \param     add_info        additional information to write into `LinFrameDataBuffer[]'
 *
 * Globals: Same as for ml_ldr_ReadFlashCRC16
 */
__MLX_TEXT__ static void ml_ldr_SendCrcResponse (uint16 add_info)
{
    5ff0:	5807      	inc	S, #8
    5ff2:	5207      	mov	[S-8], A
    if (MLX4_error != 0) {
    5ff4:	615f      	lod	AL, dp:0x5f <_ml_driver_mode+0x1>
    5ff6:	1904      	je	0x6000 <_ml_ldr_ErrorDetected+0x18>
        ml_PrepareErrorResponse(ddErNONE); /* Error response */
    5ff8:	72da 00f0 	lod	A, #240
    5ffc:	1740      	call	0x5e7e <_ldr_isReadByIdMessage+0x4e>
    5ffe:	0040      	jmp	0x6080 <_ml_ldr_ErrorDetected+0x98>
    }
    else {

#if STANDALONE_LOADER != 1
        ml_Disconnect(); /* Disconnect Mlx4 from LIN bus; Preventing mlx4 unwanted interrupts */
    6000:	15cc      	call	0x5b9a <_ml_Disconnect>
 * Calling this function ones increase calculation speed instead of every byte
 * function calling from 'mathlib'.
 */
__MLX_TEXT__ static uint16 ml_ldr_ReadFlashCRC16 (void)
{
    const uint8 *data = (uint8 *)ddDataAddress;
    6002:	7966      	lod	Y, dp:0x66 <_ml_driver_mode+0x8>
    6004:	5a05      	mov	[S-6], Y

    uint16 i;
    uint16 crc = 0xFFFF;
    6006:	78ff      	lod	Y, #-1

    for (i = 0; i < ddDataSize; i++) {
    6008:	7000      	lod	A, #0
    600a:	5201      	mov	[S-2], A
    600c:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    600e:	5203      	mov	[S-4], A
    6010:	7000      	lod	A, #0
    6012:	ae03      	cmp	A, [S-4]
    6014:	1c26      	jnc	0x6062 <_ml_ldr_ErrorDetected+0x7a>
        crc  = (uint8)(crc >> 8) | (crc << 8);
    6016:	7ae8      	swap	Y
        crc ^= *data;
    6018:	7e05      	lod	X, [S-6]
    601a:	62de      	lod	AL, [X++]
    601c:	5e05      	mov	[S-6], X
    601e:	5cf2      	usex	A
    6020:	fee2      	xor	Y, A
        data++;
        crc ^= (uint8)(crc & 0xff) >> 4;
    6022:	62e8      	lod	AL, YL
    6024:	44b0      	lsr	AL, #2
    6026:	44b0      	lsr	AL, #2
    6028:	5cf2      	usex	A
    602a:	fee2      	xor	Y, A
        crc ^= (crc << 8) << 4;
    602c:	72e6      	lod	A, Y
    602e:	b40f      	and	A, #15
    6030:	44d2      	rr	A, #2
    6032:	44d2      	rr	A, #2
    6034:	fee2      	xor	Y, A
        crc ^= ((crc & 0xff) << 4) << 1;
    6036:	72e6      	lod	A, Y
    6038:	b6da 00ff 	and	A, #255
    603c:	44a2      	asl	A, #2
    603e:	44a2      	asl	A, #2
    6040:	4422      	asl	A
    6042:	fee2      	xor	Y, A

        if ((i & 0x0FFF) == 0)
    6044:	7201      	lod	A, [S-2]
    6046:	b6da 0fff 	and	A, #4095
    604a:	1d07      	jne	0x605a <_ml_ldr_ErrorDetected+0x72>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    604c:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    604e:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6050:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6052:	b430      	and	A, #48
    6054:	1902      	je	0x605a <_ml_ldr_ErrorDetected+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6056:	6000      	lod	AL, #0
    6058:	4282      	mov	io:0x2 <_LinCmnd>, AL
    const uint8 *data = (uint8 *)ddDataAddress;

    uint16 i;
    uint16 crc = 0xFFFF;

    for (i = 0; i < ddDataSize; i++) {
    605a:	7201      	lod	A, [S-2]
    605c:	a001      	add	A, #1
    605e:	5201      	mov	[S-2], A
    6060:	07d8      	jmp	0x6012 <_ml_ldr_ErrorDetected+0x2a>
        uint16 flash_block_crc = ml_ldr_ReadFlashCRC16();

        /* ...wait... */

        /* Fill the buffer */
        LinFrameDataBuffer[0] = LIN_nad;
    6062:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6064:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
        LinFrameDataBuffer[1] = 0x06;           /* RPCI = length           */
    6066:	6006      	lod	AL, #6
    6068:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
        LinFrameDataBuffer[2] = 0xF4;           /* RSID =  SID + 0x40      */
    606a:	60f4      	lod	AL, #-12
    606c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
        LinFrameDataBuffer[3] = 0xFF;           /* 0xFF means CRC is ready (reserved) */
    606e:	60ff      	lod	AL, #-1
    6070:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
        LinFrameDataBuffer[4] = (uint8) (flash_block_crc >> 8) & 0xFF;    /* MSB of CRC   */
    6072:	4d56      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, YH
        LinFrameDataBuffer[5] = (uint8) (flash_block_crc) & 0xFF;         /* LSB of CRC   */
    6074:	4557      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, YL
        LinFrameDataBuffer[6] = (uint8) (add_info >> 8) & 0xFF;           /* MSB of word  */
    6076:	7207      	lod	A, [S-8]
    6078:	4958      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AH
        LinFrameDataBuffer[7] = (uint8) (add_info) & 0xFF;                /* LSB of word  */
    607a:	6607      	lod	YL, [S-8]
    607c:	4559      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, YL

#if STANDALONE_LOADER != 1
        ml_Connect();                 /* Connect Mlx4 to LIN bus; Calculation of CRC is over */
    607e:	158b      	call	0x5b96 <_ml_Connect>
#endif /* !STANDALONE_LOADER */
    }
    (void)ml_DataReady(ML_DISABLED);  /* Signal that the data is ready to send               */
    6080:	7000      	lod	A, #0
    6082:	150a      	call	0x5a98 <_ml_DataReady>
    6084:	5409      	ret	#10

00006086 <_ml_ldr_SwitchToProgMode>:

/* ----------------------------------------------------------------------------
 *  Switch to programming mode
 */
__MLX_TEXT__  void ml_ldr_SwitchToProgMode (ml_bool Reset)
{
    6086:	5801      	inc	S, #2
    6088:	5201      	mov	[S-2], A

    /*
     * Test is the application needs to be stopped
     * Note: mlu_ApplicationStop doesn't exits if LoaderState != 0
     */
    if ((LDR_GetState() == 0) && (mlu_ApplicationStop() != ML_SUCCESS)) { /* if application can not be stopped .. */
    608a:	12bd      	call	0x6606 <_LDR_GetState>
    608c:	8c00      	cmp	AL, #0
    608e:	1d09      	jne	0x60a2 <_ml_ldr_SwitchToProgMode+0x1c>
    6090:	82db 77ca 	callf	0x77ca <_mlu_ApplicationStop>
    6094:	8c00      	cmp	AL, #0
    6096:	1905      	je	0x60a2 <_ml_ldr_SwitchToProgMode+0x1c>

        /*
         * Stay in application mode (kLinAppMode)
         */

        ml_driver_mode = kLinAppMode; /* TODO: check this one */
    6098:	6000      	lod	AL, #0
    609a:	415e      	mov	dp:0x5e <_ml_driver_mode>, AL
        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_DISABLED);    /* Disable prog mode, SID = 0xB2 */
    609c:	7000      	lod	A, #0
    609e:	14f7      	call	0x5a8e <_ml_ReleaseBufferProg>
    60a0:	5403      	ret	#4
    }
    else {
        MLX16_MASK_ALL_INT();           /* mask all interrupts */
    60a2:	7000      	lod	A, #0
    60a4:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

        if (   (0 == LDR_GetState())
    60a8:	12ae      	call	0x6606 <_LDR_GetState>
    60aa:	8c00      	cmp	AL, #0
    60ac:	1d0b      	jne	0x60c4 <_ml_ldr_SwitchToProgMode+0x3e>
    60ae:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    60b2:	aeda 3212 	cmp	A, #12818
    60b6:	1906      	je	0x60c4 <_ml_ldr_SwitchToProgMode+0x3e>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            && (bistResetInfo != C_CHIP_STATE_LOADER_PROG_RESET) /* if reset reason isn't EnterProgMode */
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
           )
        {   /* in state 0 .. */
            NVRAM_SaveAll();            /* save NVRAM; will be restored on next reset       */
    60b8:	14e1      	call	0x5a7c <_NVRAM_SaveAll>
            ENABLE_MLX4_INT();          /* enable only LIN interrupt */
    60ba:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    60be:	a410      	or	A, #16
    60c0:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
        }
        /* else : for other loader state use LIN interrupt polling */

        ml_driver_mode  = kLinLoaderMode;   /* loader mode */
    60c4:	6055      	lod	AL, #85
    60c6:	415e      	mov	dp:0x5e <_ml_driver_mode>, AL
        ddCurrentOp = 0;                    /* reset ddCurrentOp state machine */
    60c8:	6000      	lod	AL, #0
    60ca:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
        Flash_InitDriver();
    60cc:	12a7      	call	0x661c <_Flash_InitDriver>

        /*
         * Can be also used for LIN loader if binary compatibility is not required
         */
        (void)ml_ReleaseBufferProg(ML_ENABLED); /* Enable prog mode: sending of prepared buffer w/o message request */
    60ce:	7001      	lod	A, #1
    60d0:	14de      	call	0x5a8e <_ml_ReleaseBufferProg>

        if (Reset == ML_TRUE) {
    60d2:	6201      	lod	AL, [S-2]
    60d4:	8c01      	cmp	AL, #1
    60d6:	1d0b      	jne	0x60ee <_ml_ldr_SwitchToProgMode+0x68>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
            bistResetInfo = C_CHIP_STATE_LOADER_PROG_RESET;
    60d8:	72da 3212 	lod	A, #12818
    60dc:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
            MLX4_RESET();           /* reset the Mlx4   */
    60e0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    60e4:	94fe      	and	AL, #-2
    60e6:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
            MLX16_RESET();          /* reset the Mlx16  */
    60ea:	1414      	call	0x5914 <_MLX16_RESET>
            for (;;) {
    60ec:	07ff      	jmp	0x60ec <_ml_ldr_SwitchToProgMode+0x66>
            }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        }
        else {
            /* Prepare the data to be sent */
            LinFrameDataBuffer[0] = LIN_nad;
    60ee:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    60f0:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
            LinFrameDataBuffer[1] = 0x06;   /* PCI */
    60f2:	6006      	lod	AL, #6
    60f4:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
            LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    60f6:	60f2      	lod	AL, #-14
    60f8:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL

            uint32_t version = ml_GetPlatformVersion();

            LinFrameDataBuffer[3] = (ml_uint8)(version >> 24);
    60fa:	4cea 0004 	movu	YA, #4
    60fe:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
            LinFrameDataBuffer[4] = (ml_uint8)(version >> 16);
    6100:	4cea 0401 	movu	YA, #1025
    6104:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
            LinFrameDataBuffer[5] = (ml_uint8)(version >>  8);
    6106:	6000      	lod	AL, #0
    6108:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
            LinFrameDataBuffer[6] = (ml_uint8)version;
    610a:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL

            LinFrameDataBuffer[7] = LDR_GetState();
    610c:	127c      	call	0x6606 <_LDR_GetState>
    610e:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL

            (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6110:	7000      	lod	A, #0
    6112:	14c2      	call	0x5a98 <_ml_DataReady>
    6114:	5403      	ret	#4

00006116 <_ml_ldr_ReadByIdMessage>:
 *
 * \param Id            identifier value of ReadById message
 */
__MLX_TEXT__ void ml_ldr_ReadByIdMessage (uint8_t Id)
{
    if (_mlx_MsgEnterProgModeID == Id) { /* EnterProgMode frame was requested */
    6116:	8c33      	cmp	AL, #51
    6118:	1d03      	jne	0x6120 <_ml_ldr_ReadByIdMessage+0xa>
#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        ml_ldr_SwitchToProgMode(ML_TRUE);
    611a:	7001      	lod	A, #1
    611c:	17b4      	call	0x6086 <_ml_ldr_SwitchToProgMode>
    611e:	5401      	ret
#else /* LDR_RESET_ON_ENTER_PROG_MODE */
        ml_ldr_SwitchToProgMode(ML_FALSE);
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
    }
    else if (_mlx_MsgLinProdID == Id) {  /* LIN product identification frame was requested */
    6120:	ac00      	cmp	A, #0
    6122:	1d14      	jne	0x614c <_ml_ldr_ReadByIdMessage+0x36>
 * Send positive response with Loader identifiers
 */
__MLX_TEXT__ void ml_ldr_SendLinProdIDResponse (void)
{
    /* Enable prog mode: sending of prepared data buffer w/o message request */
    (void)ml_ReleaseBufferProg(ML_ENABLED);
    6124:	7001      	lod	A, #1
    6126:	14b3      	call	0x5a8e <_ml_ReleaseBufferProg>

    /* Prepare the data to be sent */
    LinFrameDataBuffer[0] = LIN_nad;
    6128:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    612a:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
    LinFrameDataBuffer[1] = 0x06;   /* PCI */
    612c:	6006      	lod	AL, #6
    612e:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
    LinFrameDataBuffer[2] = 0xF2;   /* SID + 0x40 */
    6130:	60f2      	lod	AL, #-14
    6132:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
    LinFrameDataBuffer[3] = (ml_uint8)(LDR_SUPPLIER_ID);
    6134:	6013      	lod	AL, #19
    6136:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
    LinFrameDataBuffer[4] = (ml_uint8)(LDR_SUPPLIER_ID >> 8);
    6138:	6000      	lod	AL, #0
    613a:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
    LinFrameDataBuffer[5] = (ml_uint8)(LDR_FUNCTION_ID);
    613c:	60fe      	lod	AL, #-2
    613e:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
    LinFrameDataBuffer[6] = (ml_uint8)(LDR_FUNCTION_ID >> 8);
    6140:	60ca      	lod	AL, #-54
    6142:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
#if defined (HAS_ROM_LOADER)
    LinFrameDataBuffer[7] = 0;
#else
    LinFrameDataBuffer[7] = 1;
    6144:	6001      	lod	AL, #1
    6146:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL
#endif
    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    6148:	7000      	lod	A, #0
    614a:	14a6      	call	0x5a98 <_ml_DataReady>
    614c:	5401      	ret

0000614e <_ml_DiagRequest>:
#if 0
    WDG_Manager();
#endif


    switch (pendingAction) {
    614e:	6171      	lod	AL, dp:0x71 <_ml_driver_mode+0x13>
    6150:	8c03      	cmp	AL, #3
    6152:	1d15      	jne	0x617e <_ml_DiagRequest+0x30>

#if STANDALONE_LOADER == 0
        case ddFastProt:
            (void)ml_ContFrame(ML_DISABLED);
    6154:	7000      	lod	A, #0
    6156:	14cb      	call	0x5aee <_ml_ContFrame>
            (void)ml_Disconnect();
    6158:	1520      	call	0x5b9a <_ml_Disconnect>
            /* Set baudrate */
            (void)ml_SetFastBaudRate(peCurrentValue);
    615a:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    615c:	5cf2      	usex	A
    615e:	1377      	call	0x684e <_ml_SetFastBaudRate>
            /* Configure the Mlx4 software */
            (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6160:	54ca 0000 	pushw	#0
    6164:	54ca 0001 	pushw	#1
    6168:	54ca 0000 	pushw	#0
    616c:	7001      	lod	A, #1
    616e:	14b2      	call	0x5ad4 <_ml_SetOptions>
                            0U,             /* TXStopBitLength = 1 Bit */
                            ML_ENABLED,     /* StateChangeSignal */
                            ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                           );
            (void)ml_SetSlewRate(ML_SLEWFAST);
    6170:	7001      	lod	A, #1
    6172:	14ac      	call	0x5acc <_ml_SetSlewRate>
            (void)ml_SwitchToFast(); /* Switch to fast protocol */
    6174:	1514      	call	0x5b9e <_ml_SwitchToFast>
            pendingAction = 0;
    6176:	6000      	lod	AL, #0
    6178:	4171      	mov	dp:0x71 <_ml_driver_mode+0x13>, AL
            break;
    617a:	5c05      	dec	S, #6
    617c:	5401      	ret
#endif /* STANDALONE_LOADER */

        default:    /* Continuous Frame (CF) reading handling */
            if ((ddCurrentOp == ddReadAdd)
    617e:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    6180:	8c06      	cmp	AL, #6
    6182:	1902      	je	0x6188 <_ml_DiagRequest+0x3a>
    6184:	8c08      	cmp	AL, #8
    6186:	1d14      	jne	0x61b0 <_ml_DiagRequest+0x62>
                    || (ddCurrentOp == ddEeRead)
#endif /* LDR_HAS_EEPROM_COMMANDS */
               )
            {
                /* Flash, Table or EEPROM Read Operation */
                if (ddDataCounter < ddDataSize) {       /* if there is still data to send .. */
    6188:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    618a:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    618c:	1c11      	jnc	0x61b0 <_ml_DiagRequest+0x62>
                    ddFrameCounter += 1;
    618e:	6170      	lod	AL, dp:0x70 <_ml_driver_mode+0x12>
    6190:	8001      	add	AL, #1
    6192:	66e0      	lod	YL, AL
    6194:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                    /* Fill the buffer : NAD PCI Data1 Data2 Data3 Data4 Data5 Data6 */
                    LinFrameDataBuffer[0] = LIN_nad;                            /* NAD */
    6196:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6198:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
                    LinFrameDataBuffer[1] = 0x20 | ((ddFrameCounter) & 0x0F);   /* RPCI */
    619a:	62e8      	lod	AL, YL
    619c:	940f      	and	AL, #15
    619e:	8420      	or	AL, #32
    61a0:	4153      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, AL
                    ml_ReadData(2, 6);      /* copy next 6 bytes from ddDataAddress to buffer starting from LinFrameDataBuffer[2] */
    61a2:	54ca 0006 	pushw	#6
    61a6:	7002      	lod	A, #2
    61a8:	169d      	call	0x5ee4 <_ldr_isReadByIdMessage+0xb4>
                                            /* if less than 6 bytes left, fill with 0xFF */

                    (void)ml_DataReady(ML_END_OF_TX_DISABLED);
    61aa:	7000      	lod	A, #0
    61ac:	1475      	call	0x5a98 <_ml_DataReady>
    61ae:	5c01      	dec	S, #2
    61b0:	5401      	ret

000061b2 <_ml_DiagReceived>:
 * Get the data received
 * byte 0 : NAD (LinFrameDataBuffer[0])
 * byte 1 : PCI (Protocol Control Information) (LinFrameDataBuffer[1])
 */
__MLX_TEXT__  void ml_DiagReceived (void)
{
    61b2:	580d      	inc	S, #14

#if 0
    WDG_Manager();
#endif

    const ml_uint8 PCI = LinFrameDataBuffer[1];
    61b4:	6153      	lod	AL, dp:0x53 <_LinFrameDataBuffer+0x1>
    61b6:	5cf2      	usex	A
    61b8:	520b      	mov	[S-12], A
     *
     * \note:
     * CF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    if ((PCI & 0xF0) == 0x20) {                                 /* if Consecutive Frame (CF) frame received ..  */
    61ba:	b6da 00f0 	and	A, #240
    61be:	ac20      	cmp	A, #32
    61c0:	1901      	je	0x61c4 <_ml_DiagReceived+0x12>
    61c2:	0073      	jmp	0x62aa <_ml_DiagReceived+0xf8>

#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (ddCurrentOp == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
    61c4:	7a0b      	lod	Y, [S-12]
    61c6:	f40f      	and	Y, #15
    61c8:	6170      	lod	AL, dp:0x70 <_ml_driver_mode+0x12>
    61ca:	4209      	mov	[S-10], AL
    61cc:	b40f      	and	A, #15
    61ce:	eee2      	cmp	Y, A
    61d0:	1901      	je	0x61d4 <_ml_DiagReceived+0x22>
    61d2:	0067      	jmp	0x62a2 <_ml_DiagReceived+0xf0>
                ddFrameCounter += 1;
    61d4:	6209      	lod	AL, [S-10]
    61d6:	8001      	add	AL, #1
    61d8:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                if (ddCurrentOp == ddWriteAdd) {
    61da:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    61dc:	8c85      	cmp	AL, #-123
    61de:	1901      	je	0x61e2 <_ml_DiagReceived+0x30>
    61e0:	003d      	jmp	0x625c <_ml_DiagReceived+0xaa>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    61e2:	7800      	lod	Y, #0
    61e4:	5a0d      	mov	[S-14], Y
                        if (ddDataCounter < ddDataSize) {
    61e6:	796e      	lod	Y, dp:0x6e <_ml_driver_mode+0x10>
    61e8:	ed6a      	cmp	Y, dp:0x6a <_ml_driver_mode+0xc>
    61ea:	1c0a      	jnc	0x6200 <_ml_DiagReceived+0x4e>
                            Flash_PageBufferFill(ddAddressOffset + ddDataCounter, Data[i]);
    61ec:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    61ee:	a2e6      	add	A, Y
    61f0:	7a0d      	lod	Y, [S-14]
    61f2:	e2da 0054 	add	Y, #84
    61f6:	66f0      	lod	YL, [Y]
    61f8:	5cf6      	usex	Y
    61fa:	5adf      	push	Y
    61fc:	1246      	call	0x668a <_Flash_PageBufferFill>
    61fe:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6200:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6202:	a001      	add	A, #1
    6204:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
#endif /* LDR_HAS_PROTECTION_KEY */
            if ((PCI & 0x0F) == (ddFrameCounter & 0x0F)) {  /* if local frame counter (4 bits) matches the counter in PCI .. */
                ddFrameCounter += 1;

                if (ddCurrentOp == ddWriteAdd) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6206:	7a0d      	lod	Y, [S-14]
    6208:	e001      	add	Y, #1
    620a:	5a0d      	mov	[S-14], Y
    620c:	ec05      	cmp	Y, #5
    620e:	1a6b      	jule	0x61e6 <_ml_DiagReceived+0x34>
                    }

                    /* If all data has been written to the buffer, write the flash
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6210:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    6212:	1c01      	jnc	0x6216 <_ml_DiagReceived+0x64>
    6214:	01f7      	jmp	0x6604 <_ml_DiagReceived+0x452>

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);
    6216:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6218:	1308      	call	0x682a <_Flash_PageWriteFiltered>
    621a:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
#else
                        (void)Flash_PageWriteFiltered(ddDataAddress);
#endif /* LDR_FLASH_WRITE_TEST */

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                        if (FLASH_ERR_NONE == flashWriteStatus) {
    621c:	ac00      	cmp	A, #0
    621e:	1901      	je	0x6222 <_ml_DiagReceived+0x70>
    6220:	0042      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
    6222:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6224:	796c      	lod	Y, dp:0x6c <_ml_driver_mode+0xe>
    6226:	aee6      	cmp	A, Y
    6228:	1c15      	jnc	0x6254 <_ml_DiagReceived+0xa2>
 * ddDataCounter after a block has been written in flash.
 * Also read the next block.
 */
__MLX_TEXT__  static void ml_UpdateDataIndex (void)
{
    ddDataAddress += 128;           /* Get the next block */
    622a:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    622c:	7ee2      	lod	X, A
    622e:	22da 0080 	add	X, #128
    6232:	5d66      	mov	dp:0x66 <_ml_driver_mode+0x8>, X
    ddAddressOffset = 0;            /* Reset the address offset (0 since we start at the beginning of a next block) */
    6234:	7000      	lod	A, #0
    6236:	5168      	mov	dp:0x68 <_ml_driver_mode+0xa>, A
    ddDataCounter = 0;              /* Reset the data counter */
    6238:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    ddDataSize = ddDataSizeRq;      /* Calculate the next size */
    623a:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
    if (ddDataSize > 128) {
    623c:	eeda 0080 	cmp	Y, #128
    6240:	1a03      	jule	0x6248 <_ml_DiagReceived+0x96>
        ddDataSize = 128;
    6242:	72da 0080 	lod	A, #128
    6246:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
    }
    /* else : size is correct */

    ddDataSizeRq -= ddDataSize;
    6248:	72e6      	lod	A, Y
    624a:	a96a      	sub	A, dp:0x6a <_ml_driver_mode+0xc>
    624c:	516c      	mov	dp:0x6c <_ml_driver_mode+0xe>, A

    Flash_PageRead(ddDataAddress);  /* Read the flash block (128 bytes) to internal RAM buffer */
    624e:	72ee      	lod	A, X
    6250:	120d      	call	0x666c <_Flash_PageRead>
    6252:	0029      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
#endif /* LDR_FLASH_WRITE_TEST */
                            if (ddDataCounter < ddDataSizeRq) { /* if there is still some data to be written ..*/
                                ml_UpdateDataIndex();           /* .. update the indexes and counters */
                            }
                            else {                              /* Operation is done */
                                ddDataSize = 0;
    6254:	7800      	lod	Y, #0
    6256:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                                ddDataSizeRq = 0;
    6258:	596c      	mov	dp:0x6c <_ml_driver_mode+0xe>, Y
    625a:	0025      	jmp	0x62a6 <_ml_DiagReceived+0xf4>
                        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that there are no more Continuous Frame after that */
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
    625c:	8c47      	cmp	AL, #71
    625e:	1d23      	jne	0x62a6 <_ml_DiagReceived+0xf4>
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6260:	7000      	lod	A, #0
    6262:	520d      	mov	[S-14], A
                        if (ddDataCounter < ddDataSize) {
    6264:	796e      	lod	Y, dp:0x6e <_ml_driver_mode+0x10>
    6266:	ed6a      	cmp	Y, dp:0x6a <_ml_driver_mode+0xc>
    6268:	1c0b      	jnc	0x6280 <_ml_DiagReceived+0xce>
                            NVRAM_BufferFill(ddDataAddress + ddDataCounter, Data[i]);
    626a:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    626c:	a2e6      	add	A, Y
    626e:	7a0d      	lod	Y, [S-14]
    6270:	e2da 0054 	add	Y, #84
    6274:	66f0      	lod	YL, [Y]
    6276:	5cf6      	usex	Y
    6278:	5adf      	push	Y
    627a:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
    627e:	5c01      	dec	S, #2
                        }
                        /* else : ignore padding data beyond the original message size (ddDataSize) */

                        ddDataCounter += 1;
    6280:	716e      	lod	A, dp:0x6e <_ml_driver_mode+0x10>
    6282:	a001      	add	A, #1
    6284:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
                    }
                    /* else: message is not fully received yet  */
                }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                else if (ddCurrentOp == ddEeWrite) {
                    for (i = 0; i < 6; i++) {               /* Store the Data received */
    6286:	7a0d      	lod	Y, [S-14]
    6288:	e001      	add	Y, #1
    628a:	5a0d      	mov	[S-14], Y
    628c:	ec05      	cmp	Y, #5
    628e:	1a6a      	jule	0x6264 <_ml_DiagReceived+0xb2>
                    }

                    /* If all data has been written to the buffer, write the EEPROM
                     * This also means that this was the last Continuous Frame
                     */
                    if (ddDataCounter >= ddDataSize) {
    6290:	ad6a      	cmp	A, dp:0x6a <_ml_driver_mode+0xc>
    6292:	1c01      	jnc	0x6296 <_ml_DiagReceived+0xe4>
    6294:	01b7      	jmp	0x6604 <_ml_DiagReceived+0x452>
                        NVRAM_SaveAll();                    /* Save the EEPROM */
    6296:	82db 5a7c 	callf	0x5a7c <_NVRAM_SaveAll>
                        ddDataSize = 0;
    629a:	7000      	lod	A, #0
    629c:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
                        (void)ml_ContFrame(ML_DISABLED);    /* no more Continuous Frame (signal to MLX4) */
    629e:	1427      	call	0x5aee <_ml_ContFrame>
    62a0:	540f      	ret	#16
                else {              /* unknown operation .. */
                    (void)ml_ContFrame(ML_DISABLED); /* .. signal to MLX4 that there are no more Continuous Frame after that */
                }
            }
            else {                  /* Error in the CF frame counter */
                ddCurrentOp = 0;    /* Cancel the current operation */
    62a2:	6400      	lod	YL, #0
    62a4:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                (void)ml_ContFrame(ML_DISABLED); /* signal to MLX4 that there are no more Continuous Frame after that */
    62a6:	7000      	lod	A, #0
    62a8:	07fa      	jmp	0x629e <_ml_DiagReceived+0xec>
     *
     * \note:
     * FF is only used for the commands: ddWriteKey and ddData (operations
     * ddWriteAdd, ddEeWrite)
     */
    else if ((PCI & 0xF0) == 0x10) {    /* if First Frame (FF) frame received .. */
    62aa:	ac10      	cmp	A, #16
    62ac:	1901      	je	0x62b0 <_ml_DiagReceived+0xfe>
    62ae:	0041      	jmp	0x6332 <_ml_DiagReceived+0x180>
        ml_uint8 const * const Data = &LinFrameDataBuffer[4]; /* data start from byte 4 of the frame  */
        const ml_uint8 SID = LinFrameDataBuffer[3];           /* byte 3 : SID (Service Identifier)    */
    62b0:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
#if defined (LDR_HAS_PROTECTION_KEY)
        /* if Loader isn't protected with key or permitted command is requested */
        if ( (0 == ldr_isProtectedByKey()) || (Data[0] == ddWriteKey) ) {
#endif /* LDR_HAS_PROTECTION_KEY */

            if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4)    */
    62b2:	8cb4      	cmp	AL, #-76
    62b4:	1901      	je	0x62b8 <_ml_DiagReceived+0x106>
    62b6:	01a0      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                ml_FlashUploadStatus(ddErOP);   /* .. send error                                        */
            }
            else {                              /* Data Dump operation (SID = 0xB4) */
                if (Data[0] == ddData) {
    62b8:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    62ba:	8cd3      	cmp	AL, #-45
    62bc:	1901      	je	0x62c0 <_ml_DiagReceived+0x10e>
    62be:	019c      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                    ddFrameCounter = 1;         /* Data is being sent - reset the frame counter */
    62c0:	6001      	lod	AL, #1
    62c2:	4170      	mov	dp:0x70 <_ml_driver_mode+0x12>, AL

                    /* Check the preceding command */
                    if (ddCurrentOp == ddWriteAdd) {
    62c4:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    62c6:	8c85      	cmp	AL, #-123
    62c8:	1d14      	jne	0x62f2 <_ml_DiagReceived+0x140>
                        /* Write data to Flash buffer */
                        Flash_PageBufferFill(ddAddressOffset,     Data[1]);
    62ca:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    62cc:	5cf2      	usex	A
    62ce:	52df      	push	A
    62d0:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62d2:	11db      	call	0x668a <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 1, Data[2]);
    62d4:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62d6:	a001      	add	A, #1
    62d8:	6558      	lod	YL, dp:0x58 <_LinFrameDataBuffer+0x6>
    62da:	5cf6      	usex	Y
    62dc:	5adf      	push	Y
    62de:	11d5      	call	0x668a <_Flash_PageBufferFill>
                        Flash_PageBufferFill(ddAddressOffset + 2, Data[3]);
    62e0:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    62e2:	a002      	add	A, #2
    62e4:	6559      	lod	YL, dp:0x59 <_LinFrameDataBuffer+0x7>
    62e6:	5cf6      	usex	Y
    62e8:	5adf      	push	Y
    62ea:	11cf      	call	0x668a <_Flash_PageBufferFill>
                        ddDataCounter = 3;
    62ec:	7003      	lod	A, #3
    62ee:	516e      	mov	dp:0x6e <_ml_driver_mode+0x10>, A
    62f0:	0018      	jmp	0x6322 <_ml_DiagReceived+0x170>

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
                    }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                    else if (ddCurrentOp == ddEeWrite) {
    62f2:	8c47      	cmp	AL, #71
    62f4:	1d1b      	jne	0x632c <_ml_DiagReceived+0x17a>
                        /* Write data to EEPROM buffer */
                        NVRAM_BufferFill(ddDataAddress,     Data[1]);
    62f6:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    62f8:	5cf2      	usex	A
    62fa:	52df      	push	A
    62fc:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    62fe:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 1, Data[2]);
    6302:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6304:	a001      	add	A, #1
    6306:	6558      	lod	YL, dp:0x58 <_LinFrameDataBuffer+0x6>
    6308:	5cf6      	usex	Y
    630a:	5adf      	push	Y
    630c:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        NVRAM_BufferFill(ddDataAddress + 2, Data[3]);
    6310:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6312:	a002      	add	A, #2
    6314:	6559      	lod	YL, dp:0x59 <_LinFrameDataBuffer+0x7>
    6316:	5cf6      	usex	Y
    6318:	5adf      	push	Y
    631a:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                        ddDataCounter = 3;
    631e:	7803      	lod	Y, #3
    6320:	596e      	mov	dp:0x6e <_ml_driver_mode+0x10>, Y

                        (void)ml_ContFrame(ML_ENABLED); /* signal to MLX4 that some Continuous Frames are coming */
    6322:	7001      	lod	A, #1
    6324:	82db 5aee 	callf	0x5aee <_ml_ContFrame>
    6328:	5c05      	dec	S, #6
    632a:	540f      	ret	#16
                    }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                    else { /* There is a problem : what is the data for ? */
                        ml_FlashUploadStatus(ddErDATA); /* Send error status */
    632c:	7020      	lod	A, #32
    632e:	15bc      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
    6330:	540f      	ret	#16
    }
    /* --- Single Frame (SF) -------------------------------------
     *            [0] [1] [2] [3] [4] [5] [6] [7]
     * SF format: NAD PCI SID D0  D1  D2  D3  D4
     */
    else if ((PCI & 0xF0) == 0x00) {        /* if Single Frame (SF) is received .. */
    6332:	620b      	lod	AL, [S-12]
    6334:	94f0      	and	AL, #-16
    6336:	1901      	je	0x633a <_ml_DiagReceived+0x188>
    6338:	0162      	jmp	0x65fe <_ml_DiagReceived+0x44c>
        (void)ml_ContFrame(ML_DISABLED);    /* signal to MLX4 that this is NOT Continuous Frame */
    633a:	7000      	lod	A, #0
    633c:	82db 5aee 	callf	0x5aee <_ml_ContFrame>

        ml_uint8 const * const Data = &LinFrameDataBuffer[3];   /* data start from byte 3 of the frame */
        const ml_uint16 MessageLength = PCI & 0x0F;             /* length */
    6340:	720b      	lod	A, [S-12]
    6342:	b40f      	and	A, #15
    6344:	7ee2      	lod	X, A
        const ml_uint8 SID = LinFrameDataBuffer[2];             /* byte 2 : SID (Service Identifier) */
    6346:	6154      	lod	AL, dp:0x54 <_LinFrameDataBuffer+0x2>

        if (SID != 0xB4) {                  /* if this is not a Data Dump operation (SID = 0xB4) .. */
    6348:	8cb4      	cmp	AL, #-76
    634a:	190d      	je	0x6366 <_ml_DiagReceived+0x1b4>
            if (ldr_isReadByIdMessage(LinFrameDataBuffer, ML_TRUE)) {  /* check if ReadById (SID = 0xB2) */
    634c:	54ca 0001 	pushw	#1
    6350:	72da 0052 	lod	A, #82
    6354:	156d      	call	0x5e30 <_ldr_isReadByIdMessage>
    6356:	5c01      	dec	S, #2
    6358:	8c00      	cmp	AL, #0
    635a:	1d01      	jne	0x635e <_ml_DiagReceived+0x1ac>
    635c:	014d      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                ml_ldr_ReadByIdMessage(Data[0]);
    635e:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    6360:	5cf2      	usex	A
    6362:	16d9      	call	0x6116 <_ml_ldr_ReadByIdMessage>
    6364:	540f      	ret	#16
                /* Get the requested 'address' and the 'size'
                 * Not used for ddRestart, ddNop, ddFastProt, ddSlowProt, ddErazeAll, ddEeRestore, ddEeSave
                 * Special care for ddTableExist, ddWriteTable, ddReadTable
                 * Do not do that for ddData and for ddNop (ddDataAddress will be used)
                 */
                if ((Data[0] != ddData) && (Data[0] != ddNop)) {            /* if not Data/Status command(s) .. */
    6366:	6155      	lod	AL, dp:0x55 <_LinFrameDataBuffer+0x3>
    6368:	4207      	mov	[S-8], AL
    636a:	8cd3      	cmp	AL, #-45
    636c:	190a      	je	0x6382 <_ml_DiagReceived+0x1d0>
    636e:	8c80      	cmp	AL, #-128
    6370:	1908      	je	0x6382 <_ml_DiagReceived+0x1d0>
                    ddDataAddress = (((ml_uint16) Data[1]) << 8) | Data[2]; /* .. reload address .. */
    6372:	6956      	lod	AH, dp:0x56 <_LinFrameDataBuffer+0x4>
    6374:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    6376:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A
                    ddDataSize    = (((ml_uint16) Data[3]) << 8) | Data[4]; /* .. and size */
    6378:	6958      	lod	AH, dp:0x58 <_LinFrameDataBuffer+0x6>
    637a:	6159      	lod	AL, dp:0x59 <_LinFrameDataBuffer+0x7>
    637c:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A
                    ddDataCounter = 0;
    637e:	7800      	lod	Y, #0
    6380:	596e      	mov	dp:0x6e <_ml_driver_mode+0x10>, Y
                }
                /* else : do not update ddDataAddress, ddDataSize and ddDataCounter
                 *        for ddData or ddNop operations
                 */

                if ((Data[0] & 0x20 /* bit5 */) != 0)            /* if command is Read Flash (ddReadAdd) or Write Flash (ddWriteAdd) .. */
    6382:	6607      	lod	YL, [S-8]
    6384:	5cf6      	usex	Y
    6386:	72e6      	lod	A, Y
    6388:	b420      	and	A, #32
    638a:	1929      	je	0x63de <_ml_DiagReceived+0x22c>
                {
                    if ((Data[0] & 0x30 /* bits 4-5 */) == 0x20) /* if command is Write Flash (Data[0] = xx10xxxx) */
    638c:	72e6      	lod	A, Y
    638e:	b430      	and	A, #48
    6390:	ac20      	cmp	A, #32
    6392:	1d18      	jne	0x63c4 <_ml_DiagReceived+0x212>
                         * Return arguments :
                         *  - ddBlockAddress : base address of the flash
                         *  - ddAddressOffset : offset to address the flash buffer
                         *  - ddBlockSizeRequest : block size that can be written at once
                         */
                        ddCurrentOp = ddWriteAdd;
    6394:	6085      	lod	AL, #-123
    6396:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL

                        /* Get the address and the size requested */
                        /* ddFlashBlockAddress = Data[0] & 0x0F; */ /* get the MSBs - not used for now */
                        ddAddressOffset = ddDataAddress & 0x007F;   /* Address offset */
    6398:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    639a:	7ae2      	lod	Y, A
    639c:	f47f      	and	Y, #127
    639e:	5968      	mov	dp:0x68 <_ml_driver_mode+0xa>, Y
                        ddDataAddress  &= 0xFF80;                   /* Flash Base Address (7 LSBs are 0) */
    63a0:	b480      	and	A, #-128
    63a2:	5205      	mov	[S-6], A
    63a4:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A

                        ddDataSizeRq = ddDataSize;                  /* memorize requested size */
    63a6:	7d6a      	lod	X, dp:0x6a <_ml_driver_mode+0xc>
    63a8:	5d6c      	mov	dp:0x6c <_ml_driver_mode+0xe>, X
                        ddDataSize   = 128 - ddAddressOffset;       /* max data chunk that can be written from the base address */
    63aa:	72da 0080 	lod	A, #128
    63ae:	aae6      	sub	A, Y
    63b0:	516a      	mov	dp:0x6a <_ml_driver_mode+0xc>, A

                        if (ddDataSize > ddDataSizeRq) {            /* if requested less than max ..    */
    63b2:	aeee      	cmp	A, X
    63b4:	1a01      	jule	0x63b8 <_ml_DiagReceived+0x206>
                            ddDataSize = ddDataSizeRq;              /* .. do a requested size           */
    63b6:	5d6a      	mov	dp:0x6a <_ml_driver_mode+0xc>, X
                        }
                        /* else : do max possible data chunk */

                        ml_SendWriteResponse(Flash_GetWriteTime(ddDataAddress));
    63b8:	7205      	lod	A, [S-6]
    63ba:	1148      	call	0x664c <_Flash_GetWriteTime>
    63bc:	15fb      	call	0x5fb4 <_ldr_isReadByIdMessage+0x184>
                        Flash_PageRead(ddDataAddress);              /* Read the flash block (128 bytes) to internal RAM buffer */
    63be:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    63c0:	1155      	call	0x666c <_Flash_PageRead>
    63c2:	540f      	ret	#16
                    }
                    else {
                        /* CRC calculation instead of Read Flash command   */
                        if ((ddCurrentOp == ddProtExtension) && \
    63c4:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    63c6:	8cd6      	cmp	AL, #-42
    63c8:	1901      	je	0x63cc <_ml_DiagReceived+0x21a>
    63ca:	0087      	jmp	0x64da <_ml_DiagReceived+0x328>
    63cc:	6161      	lod	AL, dp:0x61 <_ml_driver_mode+0x3>
    63ce:	1901      	je	0x63d2 <_ml_DiagReceived+0x220>
    63d0:	0084      	jmp	0x64da <_ml_DiagReceived+0x328>
    63d2:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    63d4:	8c01      	cmp	AL, #1
    63d6:	1901      	je	0x63da <_ml_DiagReceived+0x228>
    63d8:	0080      	jmp	0x64da <_ml_DiagReceived+0x328>
                        {
                            /* CRC calculation and response sending
                             * Global:            - ddDataAddress (address in the flash)
                             *                    - ddDataSize
                             */
                            ml_ldr_SendCrcResponse(ddDataSize);
    63da:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    63dc:	0106      	jmp	0x65ea <_ml_DiagReceived+0x438>
                            ml_SendReadResponse();                      /* Prepare the Response */
                        }
                    }
                }
                else {
                    switch(Data[0]) {
    63de:	eeda 0080 	cmp	Y, #128
    63e2:	1d01      	jne	0x63e6 <_ml_DiagReceived+0x234>
    63e4:	002d      	jmp	0x6440 <_ml_DiagReceived+0x28e>
    63e6:	1f0c      	jsg	0x6400 <_ml_DiagReceived+0x24e>
    63e8:	ec08      	cmp	Y, #8
    63ea:	1d01      	jne	0x63ee <_ml_DiagReceived+0x23c>
    63ec:	0065      	jmp	0x64b8 <_ml_DiagReceived+0x306>
    63ee:	1f04      	jsg	0x63f8 <_ml_DiagReceived+0x246>
    63f0:	ec03      	cmp	Y, #3
    63f2:	1d01      	jne	0x63f6 <_ml_DiagReceived+0x244>
    63f4:	0039      	jmp	0x6468 <_ml_DiagReceived+0x2b6>
    63f6:	0100      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    63f8:	ec47      	cmp	Y, #71
    63fa:	1d01      	jne	0x63fe <_ml_DiagReceived+0x24c>
    63fc:	0059      	jmp	0x64b0 <_ml_DiagReceived+0x2fe>
    63fe:	00fc      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    6400:	eeda 00c1 	cmp	Y, #193
    6404:	190f      	je	0x6424 <_ml_DiagReceived+0x272>
    6406:	1f05      	jsg	0x6412 <_ml_DiagReceived+0x260>
    6408:	eeda 0092 	cmp	Y, #146
    640c:	1d01      	jne	0x6410 <_ml_DiagReceived+0x25e>
    640e:	0059      	jmp	0x64c2 <_ml_DiagReceived+0x310>
    6410:	00f3      	jmp	0x65f8 <_ml_DiagReceived+0x446>
    6412:	eeda 00d3 	cmp	Y, #211
    6416:	1d01      	jne	0x641a <_ml_DiagReceived+0x268>
    6418:	0063      	jmp	0x64e0 <_ml_DiagReceived+0x32e>
    641a:	eeda 00d6 	cmp	Y, #214
    641e:	1d01      	jne	0x6422 <_ml_DiagReceived+0x270>
    6420:	00c6      	jmp	0x65ae <_ml_DiagReceived+0x3fc>
    6422:	00ea      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                        /* General Operations **************************************************************/
                        case ddRestart :
                            if (Data[1] == LDR_GetState()) {
    6424:	10f0      	call	0x6606 <_LDR_GetState>
    6426:	66e0      	lod	YL, AL
    6428:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    642a:	8ee8      	cmp	AL, YL
    642c:	1d01      	jne	0x6430 <_ml_DiagReceived+0x27e>
    642e:	00ea      	jmp	0x6604 <_ml_DiagReceived+0x452>
                                /* skip reset if Loader's state is equal to required */
                            }
                            else {
                                MLX4_RESET();                       /* reset the Mlx4   */
    6430:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6434:	94fe      	and	AL, #-2
    6436:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
                                MLX16_RESET();                      /* reset the Mlx16  */
    643a:	82db 5914 	callf	0x5914 <_MLX16_RESET>
                            }
                            break;
    643e:	540f      	ret	#16

                        case ddNop :
                            /* DO NOT modify ddCurrentOp, as the operation might still be in process */
                            /* Return the status and eventually the block size and data bytes */
                            if (ddCurrentOp == ddWriteAdd) {
    6440:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    6442:	8c85      	cmp	AL, #-123
    6444:	1d09      	jne	0x6458 <_ml_DiagReceived+0x2a6>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                if (FLASH_ERR_NONE == flashWriteStatus) {
    6446:	7164      	lod	A, dp:0x64 <_ml_driver_mode+0x6>
    6448:	1d05      	jne	0x6454 <_ml_DiagReceived+0x2a2>
#endif /* LDR_FLASH_WRITE_TEST */
                                    if (0 == ddDataSize) {          /* if nothing to request */
    644a:	716a      	lod	A, dp:0x6a <_ml_driver_mode+0xc>
    644c:	1901      	je	0x6450 <_ml_DiagReceived+0x29e>
    644e:	076e      	jmp	0x632c <_ml_DiagReceived+0x17a>
                                        ddCurrentOp = 0;            /* operation done */
    6450:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    6452:	0007      	jmp	0x6462 <_ml_DiagReceived+0x2b0>
                                        ml_FlashUploadStatus(ddErDATA);     /* MPT-613 */ /* TODO:check */
                                    }
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                }
                                else { /* previous writing to flash failed */
                                    ml_FlashUploadStatus(ddErFLASH);
    6454:	7050      	lod	A, #80
    6456:	076b      	jmp	0x632e <_ml_DiagReceived+0x17c>
                                }
#endif /* LDR_FLASH_WRITE_TEST */
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    6458:	8c47      	cmp	AL, #71
    645a:	1901      	je	0x645e <_ml_DiagReceived+0x2ac>
    645c:	00b6      	jmp	0x65ca <_ml_DiagReceived+0x418>
                                ddCurrentOp = 0;                /* operation done */
    645e:	6400      	lod	YL, #0
    6460:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                                ml_SendWriteResponse(0);        /* Prepare the Response */
    6462:	7000      	lod	A, #0
    6464:	15a7      	call	0x5fb4 <_ldr_isReadByIdMessage+0x184>
    6466:	540f      	ret	#16
                            break;

#if STANDALONE_LOADER == 0
                        /* Fast Protocol */
                        case ddFastProt :
                            if (PCI == 3) { /* check if Data[1] is significant byte */
    6468:	620b      	lod	AL, [S-12]
    646a:	8c03      	cmp	AL, #3
    646c:	1d08      	jne	0x647e <_ml_DiagReceived+0x2cc>
                                peCurrentValue = Data[1];
    646e:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    6470:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL
                                if (peCurrentValue > ML_FAST_BAUDRATE_K) { /* saturate requested baudrate[kBd] to MAX Baudrate */
    6472:	8c64      	cmp	AL, #100
    6474:	1e04      	jug	0x647e <_ml_DiagReceived+0x2cc>
                                    peCurrentValue = ML_FAST_BAUDRATE_K;
                                }
                                else if (peCurrentValue < ML_MIN_FAST_BAUDRATE_K) { /* check with MIN baudrate[kBd] */
    6476:	8c12      	cmp	AL, #18
    6478:	1e04      	jug	0x6482 <_ml_DiagReceived+0x2d0>
                                    peCurrentValue = ML_MIN_FAST_BAUDRATE_K;
    647a:	6013      	lod	AL, #19
    647c:	0001      	jmp	0x6480 <_ml_DiagReceived+0x2ce>
                                }
                            }
                            else {
                                peCurrentValue = ML_FAST_BAUDRATE_K; /* set MAX baudrate if Master doesn't support flexible baudrate */
    647e:	6064      	lod	AL, #100
    6480:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL
                            }
                            /* Prepare S2M message */
                            LinFrameDataBuffer[0] = LIN_nad;            /* NAD */
    6482:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    6484:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
                            LinFrameDataBuffer[1] = 3;                  /* PCI : length = 3 databytes (SID + status + baudrate) */
    6486:	6403      	lod	YL, #3
    6488:	4553      	mov	dp:0x53 <_LinFrameDataBuffer+0x1>, YL
                            LinFrameDataBuffer[2] = 0xF4;               /* RSID = SID + 0x40 */
    648a:	60f4      	lod	AL, #-12
    648c:	4154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, AL
                            LinFrameDataBuffer[3] = LDR_GetState();     /* NodeStatus : since no error, error bit is not set */
    648e:	10bb      	call	0x6606 <_LDR_GetState>
    6490:	4155      	mov	dp:0x55 <_LinFrameDataBuffer+0x3>, AL
                            LinFrameDataBuffer[4] = peCurrentValue;     /* Applied Fast Protocol baudrate */
    6492:	6162      	lod	AL, dp:0x62 <_ml_driver_mode+0x4>
    6494:	4156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, AL
                            LinFrameDataBuffer[5] = 0xFF;
    6496:	60ff      	lod	AL, #-1
    6498:	4157      	mov	dp:0x57 <_LinFrameDataBuffer+0x5>, AL
                            LinFrameDataBuffer[6] = 0xFF;
    649a:	4158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, AL
                            LinFrameDataBuffer[7] = 0xFF;
    649c:	4159      	mov	dp:0x59 <_LinFrameDataBuffer+0x7>, AL

                            (void)ml_DataReady(ML_END_OF_TX_DISABLED);  /* Signal to MLX4 that the data is ready */
    649e:	7000      	lod	A, #0
    64a0:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
                            (void)ml_ContFrame(ML_ENABLED);
    64a4:	7001      	lod	A, #1
    64a6:	82db 5aee 	callf	0x5aee <_ml_ContFrame>
                            pendingAction = ddFastProt;
    64aa:	6003      	lod	AL, #3
    64ac:	4171      	mov	dp:0x71 <_ml_driver_mode+0x13>, AL
                            break;
    64ae:	540f      	ret	#16
#endif /* STANDALONE_LOADER */

#if (LDR_HAS_EEPROM_COMMANDS != 0)
                        /* EEPROM Operations ***************************************************************/
                        case ddEeWrite :
                            ddCurrentOp = ddEeWrite;    /* Write to the EEPROM      */
    64b0:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64b2:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
    64b6:	07d5      	jmp	0x6462 <_ml_DiagReceived+0x2b0>
                            ml_SendWriteResponse(0);    /* Prepare the Response     */
                            break;

                        case ddEeRead :
                            ddCurrentOp = ddEeRead;     /* Read the EEPROM          */
    64b8:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                            NVRAM_LoadAll();            /* Load the EEPROM values   */
    64ba:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
                            ml_SendReadResponse();      /* Prepare the Response     */
    64be:	1537      	call	0x5f2e <_ldr_isReadByIdMessage+0xfe>
                            break;
    64c0:	540f      	ret	#16
#endif /* LDR_HAS_EEPROM_COMMANDS */

                        /* simple case with Table #8 (read-only) */
                        case ddReadTable :
                        {
                            uint16_t table_number = (ml_uint8)(ddDataAddress >> 8); /* get table number form Data[1] */
    64c2:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    64c4:	6000      	lod	AL, #0
    64c6:	72e4      	swap	A

                            if (table_number != 8) {                                /* if table other than 8 is requested ..    */
    64c8:	ac08      	cmp	A, #8
    64ca:	1902      	je	0x64d0 <_ml_DiagReceived+0x31e>
                                ml_FlashUploadStatus(ddErTBL);                      /* .. send error status                     */
    64cc:	7010      	lod	A, #16
    64ce:	072f      	jmp	0x632e <_ml_DiagReceived+0x17c>
                            }
                            else {                                                  /* Error : table does not exist */
                                ddDataSize    = sizeof(_mlx_loader_info);           /* table size; TODO: size = MIN(real_table_size, requested_size) */
    64d0:	7801      	lod	Y, #1
    64d2:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                                ddDataAddress = (ml_uint16)&_mlx_loader_info;       /* get the address of the table */
    64d4:	72da 6bac 	lod	A, #27564
    64d8:	5166      	mov	dp:0x66 <_ml_driver_mode+0x8>, A
                                ddCurrentOp   = ddReadAdd;                          /* use the same operations to read tables as for the Flash => ddReadAdd */
    64da:	6006      	lod	AL, #6
    64dc:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    64de:	07ef      	jmp	0x64be <_ml_DiagReceived+0x30c>
                        }

                        /* all operations longer than one frame *********************************************/
                        case ddData :   /* ddData for Single Frame (only 1, 2, 3 or 4 bytes to write) */

                            if (ddCurrentOp == ddWriteAdd) {    /* if previous command is ddWriteAdd (write Flash) */
    64e0:	6160      	lod	AL, dp:0x60 <_ml_driver_mode+0x2>
    64e2:	8c85      	cmp	AL, #-123
    64e4:	1901      	je	0x64e8 <_ml_DiagReceived+0x336>
    64e6:	0042      	jmp	0x656c <_ml_DiagReceived+0x3ba>
                                * Intercept direct writing to loader state word (a word @ 0xBF66)
                                * and replace it:
                                *  0xBF66 = 0  ==>  loader_flags.app_enabled  = 1
                                *  0xBF66 = 1  ==>  loader_flags.app_disabled = 1
                                */
                                if (((ddDataAddress + ddAddressOffset)== 0xBF66)    /* if writing to address 0xBF66 is requested .. */
    64e8:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    64ea:	a168      	add	A, dp:0x68 <_ml_driver_mode+0xa>
    64ec:	aeda bf66 	cmp	A, #48998
    64f0:	1d24      	jne	0x653a <_ml_DiagReceived+0x388>
    64f2:	716c      	lod	A, dp:0x6c <_ml_driver_mode+0xe>
    64f4:	ac02      	cmp	A, #2
    64f6:	1d21      	jne	0x653a <_ml_DiagReceived+0x388>
                                    && (ddDataSizeRq == 2))                         /* .. with data size of 2 bytes ..      */
                                {
                                    uint16_t new_state = Data[1];                   /* new loader state */
    64f8:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    64fa:	5cf2      	usex	A

                                    switch (new_state) {
    64fc:	1903      	je	0x6504 <_ml_DiagReceived+0x352>
    64fe:	ac01      	cmp	A, #1
    6500:	190d      	je	0x651c <_ml_DiagReceived+0x36a>
    6502:	0051      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                                        case 0:     /* transition to state 0 ==> enable application */
                                        {
                                            uint16_t addr = (uint16_t)&loader_flags.app_enabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    6504:	72da be84 	lod	A, #48772
    6508:	10b1      	call	0x666c <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    650a:	72da be84 	lod	A, #48772
    650e:	b47f      	and	A, #127
    6510:	54ca 0001 	pushw	#1
    6514:	10ba      	call	0x668a <_Flash_PageBufferFill>
                                                                                                    /* TODO: address masking is redundant; check if we can use address instead of offset in Flash_PageBufferFill */
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page back to the flash */
    6516:	72da be84 	lod	A, #48772
    651a:	000b      	jmp	0x6532 <_ml_DiagReceived+0x380>
                                                while (1) { WDG_Manager(); }
                                            }
                                            /* else: expected values */
#endif /* DEBUG_LOADER_FLAGS */
                                            uint16_t addr = (uint16_t)&loader_flags.app_disabled;
                                            Flash_PageRead(addr);                                   /* copy page to buffer starting from base address */
    651c:	72da be80 	lod	A, #48768
    6520:	10a5      	call	0x666c <_Flash_PageRead>
                                            Flash_PageBufferFill(addr & ML_FLASH_BUFFER_MASK, 1);   /* write to buffer using address offset */
    6522:	72da be80 	lod	A, #48768
    6526:	b47f      	and	A, #127
    6528:	54ca 0001 	pushw	#1
    652c:	10ae      	call	0x668a <_Flash_PageBufferFill>
#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                            flashWriteStatus = Flash_PageWrite(addr);   /* [unfiltered] write page into the flash */
    652e:	72da be80 	lod	A, #48768
    6532:	10c3      	call	0x66ba <_Flash_PageWrite>
    6534:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
                                            }
                                            /* else: no errors after Flash write */
#endif /* DEBUG_LOADER_FLAGS */

                                        }
                                            break;
    6536:	5c01      	dec	S, #2
    6538:	0036      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    653a:	7800      	lod	Y, #0
    653c:	5a0d      	mov	[S-14], Y
    653e:	20fe      	add	X, #-2
    6540:	5e03      	mov	[S-4], X
    6542:	eeee      	cmp	Y, X
    6544:	1c0f      	jnc	0x6564 <_ml_DiagReceived+0x3b2>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
    6546:	7168      	lod	A, dp:0x68 <_ml_driver_mode+0xa>
    6548:	a20d      	add	A, [S-14]
    654a:	7a0d      	lod	Y, [S-14]
    654c:	e2da 0056 	add	Y, #86
    6550:	66f0      	lod	YL, [Y]
    6552:	5cf6      	usex	Y
    6554:	5adf      	push	Y
    6556:	1099      	call	0x668a <_Flash_PageBufferFill>
                                            break;
                                    }
                                }
                                else {
#endif /* HAS_H12_LOADER_PROTOCOL */
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6558:	5c01      	dec	S, #2
    655a:	720d      	lod	A, [S-14]
    655c:	a001      	add	A, #1
    655e:	520d      	mov	[S-14], A
    6560:	ae03      	cmp	A, [S-4]
    6562:	1871      	jc	0x6546 <_ml_DiagReceived+0x394>
                                    Flash_PageBufferFill(ddAddressOffset + i, Data[i+1]);
                                }

#if (LDR_FLASH_WRITE_TEST != FLASH_TEST_NONE)
                                flashWriteStatus = Flash_PageWriteFiltered(ddDataAddress);  /* write page into the flash */
    6564:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    6566:	1161      	call	0x682a <_Flash_PageWriteFiltered>
    6568:	5164      	mov	dp:0x64 <_ml_driver_mode+0x6>, A
    656a:	001d      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
#if !defined (HAS_H12_LOADER_PROTOCOL)
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
    656c:	8c47      	cmp	AL, #71
    656e:	1d19      	jne	0x65a2 <_ml_DiagReceived+0x3f0>
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6570:	7800      	lod	Y, #0
    6572:	5a0d      	mov	[S-14], Y
    6574:	20fe      	add	X, #-2
    6576:	5e01      	mov	[S-2], X
    6578:	eeee      	cmp	Y, X
    657a:	1c10      	jnc	0x659c <_ml_DiagReceived+0x3ea>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
    657c:	7166      	lod	A, dp:0x66 <_ml_driver_mode+0x8>
    657e:	a20d      	add	A, [S-14]
    6580:	7a0d      	lod	Y, [S-14]
    6582:	e2da 0056 	add	Y, #86
    6586:	66f0      	lod	YL, [Y]
    6588:	5cf6      	usex	Y
    658a:	5adf      	push	Y
    658c:	82db 5a52 	callf	0x5a52 <_NVRAM_BufferFill>
                                }
#endif
                            }
#if (LDR_HAS_EEPROM_COMMANDS != 0)
                            else if (ddCurrentOp == ddEeWrite) {
                                for (i = 0; i < (MessageLength - 2); i++) { /* don't count SID and command opcode */
    6590:	5c01      	dec	S, #2
    6592:	720d      	lod	A, [S-14]
    6594:	a001      	add	A, #1
    6596:	520d      	mov	[S-14], A
    6598:	ae01      	cmp	A, [S-2]
    659a:	1870      	jc	0x657c <_ml_DiagReceived+0x3ca>
                                    NVRAM_BufferFill(ddDataAddress + i, Data[i+1]);
                                }

                                NVRAM_SaveAll();
    659c:	82db 5a7c 	callf	0x5a7c <_NVRAM_SaveAll>
    65a0:	0002      	jmp	0x65a6 <_ml_DiagReceived+0x3f4>
                            }
#endif /* LDR_HAS_EEPROM_COMMANDS */

                            else {                              /* There is a problem : what is the data for ?  */
                                ml_FlashUploadStatus(ddErDATA); /* Send error status                            */
    65a2:	7020      	lod	A, #32
    65a4:	1481      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
                            }

                            /* Since it was a Single Frame, the operation has been completed */
                            ddDataSizeRq = 0;
    65a6:	7800      	lod	Y, #0
    65a8:	596c      	mov	dp:0x6c <_ml_driver_mode+0xe>, Y
                            ddDataSize = 0;
    65aa:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y
                            /* ddCurrentOp = 0; */
                            break;
    65ac:	540f      	ret	#16
                         *                            \   PE Code
                         *                             ddProtExtension = 0xD6
                         */
                        case ddProtExtension:
                            /* Set ddProtExtension as current operation */
                            ddCurrentOp = ddProtExtension;
    65ae:	60d6      	lod	AL, #-42
    65b0:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
                            /* Get protocol extension command CODE */
                            peCurrentOp = Data[1];
    65b2:	6156      	lod	AL, dp:0x56 <_LinFrameDataBuffer+0x4>
    65b4:	4161      	mov	dp:0x61 <_ml_driver_mode+0x3>, AL

                            /* --------------------------------
                             Commands for Read Flash redefining
                             ---------------------------------- */
                            if (peCurrentOp == peReadFlashModify) {
    65b6:	1d0c      	jne	0x65d0 <_ml_DiagReceived+0x41e>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65b8:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    65ba:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65bc:	5cf2      	usex	A
    65be:	1903      	je	0x65c6 <_ml_DiagReceived+0x414>
    65c0:	ac01      	cmp	A, #1
    65c2:	1903      	je	0x65ca <_ml_DiagReceived+0x418>
    65c4:	0017      	jmp	0x65f4 <_ml_DiagReceived+0x442>
                                /* Normal ReadFlash command execution */
                                case rfmNormal:
                                    ddCurrentOp = 0;
    65c6:	6000      	lod	AL, #0
    65c8:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
                                    break;

                                /* CRC calculation instead of ReadFlash command */
                                case rfmCrcCalc:
                                    ml_FlashUploadStatus(ddErNONE); /* Send Status with no errors */
    65ca:	72da 00f0 	lod	A, #240
    65ce:	06af      	jmp	0x632e <_ml_DiagReceived+0x17c>
                                }
                            }
                            /* --------------------------------
                             Flash Margin modify commands
                             ---------------------------------- */
                            else if (peCurrentOp == peMarginModify) {
    65d0:	8c01      	cmp	AL, #1
    65d2:	1d10      	jne	0x65f4 <_ml_DiagReceived+0x442>
                                /* Get protocol extension command VALUE */
                                peCurrentValue = Data[2];
    65d4:	6157      	lod	AL, dp:0x57 <_LinFrameDataBuffer+0x5>
    65d6:	4162      	mov	dp:0x62 <_ml_driver_mode+0x4>, AL

                                switch (peCurrentValue) {
    65d8:	1d0a      	jne	0x65ee <_ml_DiagReceived+0x43c>
                                /* Set up signed offset to threshold for MardinRead */
                                case mmMarginSetOffset: {
                                    /* Get signed offset value */
                                    int16 offset_iref = (int8) Data[3];
    65da:	6158      	lod	AL, dp:0x58 <_LinFrameDataBuffer+0x6>
    65dc:	5ce2      	ssex	A

                                    /* Change IREF by offset value in FLASHTRIMA register */
                                    uint16 saved_iref = Flash_IREF_Offset(offset_iref);
    65de:	1101      	call	0x67e2 <_Flash_IREF_Offset>

                                    /* Use this functionality for response generation */
                                    ddDataAddress = ML_FLASH_START_ADDRESS;
    65e0:	7ada 4000 	lod	Y, #16384
    65e4:	5966      	mov	dp:0x66 <_ml_driver_mode+0x8>, Y
                                    ddDataSize = 0; /* No data to CRC */
    65e6:	7800      	lod	Y, #0
    65e8:	596a      	mov	dp:0x6a <_ml_driver_mode+0xc>, Y

                                    /* Used to generate response with old IREF value
                                     * No CRC calculation, 0xFFFF will be returned */
                                    ml_ldr_SendCrcResponse(saved_iref);
    65ea:	1502      	call	0x5ff0 <_ml_ldr_ErrorDetected+0x8>
                                    break;
    65ec:	540f      	ret	#16
                                }
                                /* Wrong protocol extension command VALUE sets ddErOp */
                                default:
                                    ddCurrentOp = 0;
    65ee:	6000      	lod	AL, #0
    65f0:	4160      	mov	dp:0x60 <_ml_driver_mode+0x2>, AL
    65f2:	0002      	jmp	0x65f8 <_ml_DiagReceived+0x446>
                                    ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                                }
                            }
                            /* Wrong protocol extension command CODE sets ddErOp */
                            else {
                                ddCurrentOp = 0;
    65f4:	6400      	lod	YL, #0
    65f6:	4560      	mov	dp:0x60 <_ml_driver_mode+0x2>, YL
                                ml_FlashUploadStatus(ddErOP); /* Send Status with error: incorrect operation mode  */
                            }
                            break;

                        default :   /* no action */
                            ml_FlashUploadStatus(ddErOP);       /* Send error status */
    65f8:	72da 00d0 	lod	A, #208
    65fc:	0698      	jmp	0x632e <_ml_DiagReceived+0x17c>
            }
#endif /* LDR_HAS_PROTECTION_KEY */
        }
    }
    else {                              /* PCI not valid .. */
        ml_FlashUploadStatus(ddErPCI);  /* .. send error status */
    65fe:	72da 00b0 	lod	A, #176
    6602:	1452      	call	0x5ea8 <_ldr_isReadByIdMessage+0x78>
    6604:	540f      	ret	#16

00006606 <_LDR_GetState>:
 * 0             0            3        3        3             loading new application (high part)
 * 0             1            3        4        0             application mode
 */
__MLX_TEXT__  ml_uint8 LDR_GetState (void)
{
    ml_uint8 loader_state = (loader_flags.app_disabled
    6606:	7ada be80 	lod	Y, #48768
    660a:	62f0      	lod	AL, [Y]
    660c:	82d8 be84 	add	AL, 0xbe84 <_loader_flags+0x4>
    6610:	66e0      	lod	YL, AL
    6612:	72d8 bf66 	lod	A, 0xbf66 <_loader_rst_state>
    6616:	a2e6      	add	A, Y
    6618:	b403      	and	A, #3
            + loader_flags.app_enabled
            + loader_rst_state) & 3;

    return loader_state;
}
    661a:	5401      	ret

0000661c <_Flash_InitDriver>:
 *     of the new application (with new Reset Vector) was also already written
 *     at the end of state 2.
 */
__MLX_TEXT__ void Flash_InitDriver(void)
{
    if (LDR_GetState() == 3) {                                          /* in state 3 skip erasing of the last sector (see notes above) .. */
    661c:	17f4      	call	0x6606 <_LDR_GetState>
    661e:	8c03      	cmp	AL, #3
    6620:	1d03      	jne	0x6628 <_Flash_InitDriver+0xc>
        erase_sectors_bitmap = 1u << (ML_FLASH_NUMBER_OF_SECTORS - 1);  /* .. => mark last sector as erased  */
    6622:	72da 8000 	lod	A, #32768
    6626:	0001      	jmp	0x662a <_Flash_InitDriver+0xe>
    }
    else {
        erase_sectors_bitmap = 0;                                       /*  so far, no sectors have been erased yet */
    6628:	7000      	lod	A, #0
    662a:	52d8 01a4 	mov	0x1a4 <_page_buffer+0x2>, A
    662e:	5401      	ret
 */
__MLX_TEXT__ static uint16_t AddrToSector (uint16_t addr)
{
    //TODO: assert ((addr >= ML_FLASH_START_ADDRESS) && (addr < (ML_FLASH_START_ADDRESS + ML_FLASH_SIZE_IN_BYTES))

    return (addr - ML_FLASH_START_ADDRESS) / ML_FLASH_SECTOR_SIZE_IN_BYTES;
    6630:	a2da c000 	add	A, #49152
    6634:	72e4      	swap	A
    6636:	b6da 00ff 	and	A, #255
    663a:	44b2      	lsr	A, #2
    663c:	4432      	lsr	A
}
    663e:	5401      	ret
 * \param   sector  sector number to be checked (0-15)
 * \return          true if specified sector was already erased
 */
__MLX_TEXT__ static bool IsSectorErased (uint16_t sector)
{
    return erase_sectors_bitmap & (1u << sector);
    6640:	44e2      	sfb	A
    6642:	b6d8 01a4 	and	A, 0x1a4 <_page_buffer+0x2>
    6646:	1901      	je	0x664a <_Flash_InitDriver+0x2e>
    6648:	7001      	lod	A, #1
}
    664a:	5401      	ret

0000664c <_Flash_GetWriteTime>:
 */
__MLX_TEXT__ uint16_t Flash_GetWriteTime(uint16_t addr)
{
    uint16_t wr_time;

    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */
    664c:	b480      	and	A, #-128

    uint16_t sector_number = AddrToSector(addr);
    664e:	17f0      	call	0x6630 <_Flash_InitDriver+0x14>
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
    6650:	17f7      	call	0x6640 <_Flash_InitDriver+0x24>
    6652:	8c00      	cmp	AL, #0
    6654:	1d09      	jne	0x6668 <_Flash_GetWriteTime+0x1c>
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6656:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    665a:	8c01      	cmp	AL, #1
    665c:	1a02      	jule	0x6662 <_Flash_GetWriteTime+0x16>
    addr = addr & ~ML_FLASH_BUFFER_MASK;            /* get start address of the page */

    uint16_t sector_number = AddrToSector(addr);
    if ( ! IsSectorErased(sector_number) ) {        /* if Flash sector is not erased yet ..  */
        if (HasSectorEraseByHw()) {                 /* if full sector can be erase by HW ..  */
            wr_time = ML_FLASH_H12_ERASE_WRITE_TIMEOUT_MS;
    665e:	7030      	lod	A, #48
    6660:	5401      	ret
        }
        else {                                      /* else: more time is needed to simulate sector erase in SW */
            wr_time = ML_FLASH_H11_ERASE_WRITE_TIMEOUT_MS;
    6662:	72da 02a6 	lod	A, #678
    6666:	5401      	ret
        }
    }
    else {                                          /* else: Flash sector was already erased */
        wr_time = ML_FLASH_WRITE_ONLY_TIMEOUT_MS;
    6668:	7006      	lod	A, #6
    }

    return wr_time;
}
    666a:	5401      	ret

0000666c <_Flash_PageRead>:
 * Notes:
 *  1. Automatically aligns requested address to the nearest page located
 *     below in memory.
 */
__MLX_TEXT__ void Flash_PageRead (uint16_t addr)
{
    666c:	5803      	inc	S, #4
#if _FAST
    uint16_t *src = (uint16_t *)(addr & ~(ML_FLASH_BUFFER_SIZE_IN_WORDS * 2 - 1));    /* get page start address */
    666e:	b480      	and	A, #-128
    6670:	5203      	mov	[S-4], A
    uint16_t *dst = (uint16_t *)page_buffer;
    6672:	7ed8 01a2 	lod	X, 0x1a2 <_page_buffer>
    6676:	5e01      	mov	[S-2], X

    do
    {
        *dst++ = *src++;
    6678:	7a03      	lod	Y, [S-4]
    667a:	54c6      	movsw	[X++], [Y++]
    667c:	5a03      	mov	[S-4], Y
    } while (dst < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    667e:	7201      	lod	A, [S-2]
    6680:	a2da 0080 	add	A, #128
    6684:	2ee2      	cmp	X, A
    6686:	1878      	jc	0x6678 <_Flash_PageRead+0xc>
    6688:	5405      	ret	#6

0000668a <_Flash_PageBufferFill>:
    offset &= ML_FLASH_BUFFER_MASK;                         /* mask address bits and leave only the offset */

#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)
    NVRAM_BufferFill((uint16_t)&page_buffer[offset], data); /* use a helper function to write bytes into NVRAM buffer */
#else
    page_buffer[offset] = data;                             /* RAM allows byte access ==> can write directly          */
    668a:	b47f      	and	A, #127
    668c:	7ae2      	lod	Y, A
    668e:	e2d8 01a2 	add	Y, 0x1a2 <_page_buffer>
    6692:	6203      	lod	AL, [S-4]
    6694:	42f0      	mov	[Y], AL
    6696:	5401      	ret

00006698 <_Flash_PageVerifyBuffer>:
 * Verifies Flash Page at 'addr' against RAM buffer
 */
__MLX_TEXT__  uint16_t Flash_PageVerifyBuffer (uint16_t addr)
{
#if _FAST
    uint16_t *dst = (uint16_t *)(addr & ~ML_FLASH_BUFFER_MASK);    /* get page start address */
    6698:	b480      	and	A, #-128
    669a:	7ee2      	lod	X, A
    uint16_t *src = (uint16_t *)page_buffer;
    669c:	7ad8 01a2 	lod	Y, 0x1a2 <_page_buffer>

    do
    {
        if ( *src++ != *dst++ )
    66a0:	72d6      	lod	A, [Y++]
    66a2:	aede      	cmp	A, [X++]
    66a4:	1902      	je	0x66aa <_Flash_PageVerifyBuffer+0x12>
        {
            return FLASH_ERR_VERIFICATION_FAILED;
    66a6:	7001      	lod	A, #1
    66a8:	5401      	ret
        }
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    66aa:	72d8 01a2 	lod	A, 0x1a2 <_page_buffer>
    66ae:	a2da 0080 	add	A, #128
    66b2:	eee2      	cmp	Y, A
    66b4:	1875      	jc	0x66a0 <_Flash_PageVerifyBuffer+0x8>
        src++;

    } while (--size != 0);
#endif /* _FAST */

    return FLASH_ERR_NONE;
    66b6:	7000      	lod	A, #0
}
    66b8:	5401      	ret

000066ba <_Flash_PageWrite>:
 *     the page address by HW. Note, that if FL_CTRL0 = FL_ERASE (or FL_WRITE)
 *     writing to the flash address only triggers the erase or write operation,
 *     but not selects the flash page.
 */
__MLX_TEXT__ uint16_t Flash_PageWrite (uint16_t addr)
{
    66ba:	5809      	inc	S, #10
    uint16_t volatile *dst;

    addr = addr & ~ML_FLASH_BUFFER_MASK;    /* get start address of the page */
    66bc:	b480      	and	A, #-128
    66be:	5209      	mov	[S-10], A

#if defined (SUPPORT_LINNETWORK_LOADER)
    if ( (LDR_GetState() == 1) && (addr == (((uint16_t)&loader_rst_state) & ~ML_FLASH_BUFFER_MASK)) )
    66c0:	17a2      	call	0x6606 <_LDR_GetState>
    66c2:	8c01      	cmp	AL, #1
    66c4:	1d0b      	jne	0x66dc <_Flash_PageWrite+0x22>
    66c6:	72da bf66 	lod	A, #48998
    66ca:	b480      	and	A, #-128
    66cc:	7a09      	lod	Y, [S-10]
    66ce:	eee2      	cmp	Y, A
    66d0:	1d05      	jne	0x66dc <_Flash_PageWrite+0x22>
    {
        /* Programming the LoaderB (LoaderState 1); This page is the LoaderState-page of LoaderB; Write LIN NAD in this page too. */
#if defined (HAS_FLASH_WRITE_BUFFER_IN_NVRAM_SRAM)               /* use NVRAM SRAM area as a page buffer */
        NVRAM_BufferFill((uint16_t)&page_buffer[0x76], LIN_nad); /* use a helper function to write bytes into NVRAM buffer */
#else                                                            /* RAM allows byte access ==> can write directly          */
        page_buffer[0x76] = LIN_nad;                             /* Write NAD into STACK_IT segment; This same address is used by LoaderB premain */
    66d2:	7ad8 01a2 	lod	Y, 0x1a2 <_page_buffer>
    66d6:	e076      	add	Y, #118
    66d8:	615a      	lod	AL, dp:0x5a <_LIN_nad>
    66da:	42f0      	mov	[Y], AL
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    66dc:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    66de:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    66e0:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    66e2:	b430      	and	A, #48
    66e4:	1902      	je	0x66ea <_Flash_PageWrite+0x30>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    66e6:	6000      	lod	AL, #0
    66e8:	4282      	mov	io:0x2 <_LinCmnd>, AL
    }
#endif /* SUPPORT_LINNETWORK_LOADER */

    WDG_Manager();

    if ( !mlx_isPowerOk() ) {                               /* if power supply is not Ok .. */
    66ea:	11fc      	call	0x6ae4 <_mlx_isPowerOk>
    66ec:	8c00      	cmp	AL, #0
    66ee:	1d02      	jne	0x66f4 <_Flash_PageWrite+0x3a>
        return FLASH_ERR_VERIFICATION_FAILED;
    66f0:	7001      	lod	A, #1
    66f2:	540b      	ret	#12
    }
    /* else: power is Ok */


    if (addr != ML_APP_CONTROL_PAGE_ADDRESS) {              /* if not the Application Control Page ..   */
    66f4:	7a09      	lod	Y, [S-10]
    66f6:	eeda be80 	cmp	Y, #48768
    66fa:	1d01      	jne	0x66fe <_Flash_PageWrite+0x44>
    66fc:	0045      	jmp	0x6788 <_Flash_PageWrite+0xce>
        uint16_t sector_number = AddrToSector(addr);
    66fe:	72e6      	lod	A, Y
    6700:	1797      	call	0x6630 <_Flash_InitDriver+0x14>
    6702:	5207      	mov	[S-8], A
        if ( ! IsSectorErased(sector_number) ) {            /* if Flash sector is not erased yet ..     */
    6704:	179d      	call	0x6640 <_Flash_InitDriver+0x24>
    6706:	8c00      	cmp	AL, #0
    6708:	1901      	je	0x670c <_Flash_PageWrite+0x52>
    670a:	003e      	jmp	0x6788 <_Flash_PageWrite+0xce>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    670c:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    670e:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6710:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6712:	b430      	and	A, #48
    6714:	1902      	je	0x671a <_Flash_PageWrite+0x60>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6716:	6000      	lod	AL, #0
    6718:	4282      	mov	io:0x2 <_LinCmnd>, AL
 * Erases specified sector
 */
__MLX_TEXT__ static void EraseSector(uint16_t sector)
{
    uint16_t volatile *dst;
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);
    671a:	7207      	lod	A, [S-8]
    671c:	487a 0800 	muls	Y, A, #2048
    6720:	e2da 4000 	add	Y, #16384
    6724:	5a05      	mov	[S-6], Y
#elif defined (DEBUG_FORCE_H11_FLASH_DETECTION)
# warning     "DEBUG_FORCE_H11_FLASH_DETECTION is enabled"
    return false;

#else
    return (EEP_FLASH_ERASE_SIZE > 1U);
    6726:	62d8 11b2 	lod	AL, 0x11b2 <__ep__+0x1b2>
    672a:	8c01      	cmp	AL, #1
    672c:	1a03      	jule	0x6734 <_Flash_PageWrite+0x7a>
    uint16_t addr = ML_FLASH_START_ADDRESS + (sector * ML_FLASH_SECTOR_SIZE_IN_BYTES);


    uint_fast8_t i;
    if (HasSectorEraseByHw()) {
        i = 1;  /* single iteration to erase sector */
    672e:	7801      	lod	Y, #1
    6730:	5a03      	mov	[S-4], Y
    6732:	0002      	jmp	0x6738 <_Flash_PageWrite+0x7e>
    }
    else {
        i = ML_FLASH_SECTOR_SIZE_IN_PAGES;  /* emulate sector erase by erasing page-by-page */
    6734:	7010      	lod	A, #16
    6736:	5203      	mov	[S-4], A
        /*
         * Select page for erasing:
         *  - set latch mode
         *  - write (any value) to the two consecutive words within the page
         */
        FL_CTRL0 = 0;                           /* set LATCH mode                           */
    6738:	7800      	lod	Y, #0
    673a:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y
        dst = (uint16_t *)addr;                 /* select page by writing to the latches .. */
        *dst++ = 0;                             /* .. at least two words                    */
    673e:	7a05      	lod	Y, [S-6]
    6740:	7000      	lod	A, #0
    6742:	52d6      	mov	[Y++], A
        *dst++ = 0;
    6744:	52d6      	mov	[Y++], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6746:	7c02      	lod	X, #2
            FL_CTRL0 = FL_ERASE | FL_ERASE_TIME;    /* set ERASE mode and specify erase timing  */
    6748:	72da 00c8 	lod	A, #200
    674c:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            if (ml_driver_mode != kLinLoaderMode) { /* abort illegal erase operation (PLTF-732) */
    6750:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    6754:	8c55      	cmp	AL, #85
    6756:	1903      	je	0x675e <_Flash_PageWrite+0xa4>
                FL_CTRL0 = 0;
    6758:	7000      	lod	A, #0
    675a:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
            }
            *dst = 0;                               /* trigger ERASE operation by writing to flash  */
    675e:	7000      	lod	A, #0
    6760:	52f0      	mov	[Y], A
        IO_EXTIO |= IO5_OUT;
#endif
        /*
         * Erase selected flash page (CPU is frozen while flash is being erased)
         */
        for (uint8_t ers = 2; ers > 0; ers--) {     /* erase selected page twice (PLTF-700)     */
    6762:	72ee      	lod	A, X
    6764:	80ff      	add	AL, #-1
    6766:	5cf2      	usex	A
    6768:	7ee2      	lod	X, A
    676a:	1d6e      	jne	0x6748 <_Flash_PageWrite+0x8e>

#if defined (DEBUG_FLASH_ERASE_TIMING)
        IO_EXTIO &= ~IO5_OUT;
#endif

        addr += ML_FLASH_PAGE_SIZE_IN_BYTES;    /* next page */
    676c:	7a05      	lod	Y, [S-6]
    676e:	e2da 0080 	add	Y, #128
    6772:	5a05      	mov	[S-6], Y
        i--;                                    /* next erase iteration */
    } while (i != 0);
    6774:	7203      	lod	A, [S-4]
    6776:	a0ff      	add	A, #-1
    6778:	5203      	mov	[S-4], A
    677a:	1d5e      	jne	0x6738 <_Flash_PageWrite+0x7e>


    erase_sectors_bitmap |= (1u << sector);     /* flag the sector as ERASED */
    677c:	7207      	lod	A, [S-8]
    677e:	44e2      	sfb	A
    6780:	a6d8 01a4 	or	A, 0x1a4 <_page_buffer+0x2>
    6784:	52d8 01a4 	mov	0x1a4 <_page_buffer+0x2>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6788:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    678a:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    678c:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    678e:	b430      	and	A, #48
    6790:	1902      	je	0x6796 <_Flash_PageWrite+0xdc>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6792:	6400      	lod	YL, #0
    6794:	4682      	mov	io:0x2 <_LinCmnd>, YL
    WDG_Manager();

    /*
     * Load flash latches with data to be written
     */
    FL_CTRL0 = 0;                           /* set LATCH mode   */
    6796:	7000      	lod	A, #0
    6798:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A

#if _FAST
    uint16_t *src = (uint16_t *)page_buffer;
    679c:	7ad8 01a2 	lod	Y, 0x1a2 <_page_buffer>
    dst = (uint16_t *)addr;
    67a0:	7e09      	lod	X, [S-10]
    67a2:	5a01      	mov	[S-2], Y

    do                                      /* load flash latches .. */
    {
        *dst++ = *src++;
    67a4:	54c6      	movsw	[X++], [Y++]
    } while (src < (uint16_t *)(page_buffer + ML_FLASH_BUFFER_SIZE_IN_WORDS * sizeof(uint16_t)));
    67a6:	7201      	lod	A, [S-2]
    67a8:	a2da 0080 	add	A, #128
    67ac:	eee2      	cmp	Y, A
    67ae:	187a      	jc	0x67a4 <_Flash_PageWrite+0xea>


    /*
     * Write data from latches to flash page (CPU is frozen while flash is being erased)
     */
    FL_CTRL0 = FL_WRITE | FL_WRITE_TIME;    /* set WRITE mode and specify write timing */
    67b0:	7818      	lod	Y, #24
    67b2:	5ad8 2026 	mov	0x2026 <__ep__+0x1026>, Y

    if (ml_driver_mode != kLinLoaderMode) { /* abort write operation (PLTF-732) */
    67b6:	62d8 005e 	lod	AL, 0x5e <_ml_driver_mode>
    67ba:	8c55      	cmp	AL, #85
    67bc:	1903      	je	0x67c4 <_Flash_PageWrite+0x10a>
        FL_CTRL0 = 0;
    67be:	7000      	lod	A, #0
    67c0:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
    }

    dst = (uint16_t *)addr;
    *dst = (uint16_t)dst;                   /* trigger write operation by writing to flash */
    67c4:	7a09      	lod	Y, [S-10]
    67c6:	5af0      	mov	[Y], Y

    FL_CTRL0 = 0;                           /* reset command register */
    67c8:	7000      	lod	A, #0
    67ca:	52d8 2026 	mov	0x2026 <__ep__+0x1026>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    67ce:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    67d0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    67d2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    67d4:	b430      	and	A, #48
    67d6:	1902      	je	0x67dc <_Flash_PageWrite+0x122>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    67d8:	6400      	lod	YL, #0
    67da:	4682      	mov	io:0x2 <_LinCmnd>, YL
#elif (LDR_FLASH_WRITE_TEST == FLASH_TEST_NORMAL)

    WDG_Manager();

    uint16_t  status;
    status = Flash_PageVerifyBuffer(addr);
    67dc:	7209      	lod	A, [S-10]
    67de:	175c      	call	0x6698 <_Flash_PageVerifyBuffer>

#else
    #error "Incorrect setting for LDR_FLASH_WRITE_TEST define"

#endif /* LDR_FLASH_WRITE_TEST */
}
    67e0:	540b      	ret	#12

000067e2 <_Flash_IREF_Offset>:
 *  \param[in]    int16  offset_iref                         Offset to IREF
 *
 *  \return       uint16 (MSB-new_iref, LSB-old_iref)        IREF thresholds
 */
__MLX_TEXT__ uint16 Flash_IREF_Offset (int16_t offset_iref)
{
    67e2:	5801      	inc	S, #2

    /*
     * Change IREF in FLASHTRIMA register.
     * Note, that this is read-modify-write access to FLASHTRIMA
     */
    io_flash_trim_a.u16 = FLASHTRIMA;                /* save old io value */
    67e4:	7ad8 2050 	lod	Y, 0x2050 <__ep__+0x1050>
    67e8:	5a01      	mov	[S-2], Y
    uint16_t saved_iref = io_flash_trim_a.iref;      /* save old iref value */
    67ea:	7ae8      	swap	Y
    67ec:	f6da 00ff 	and	Y, #255
    67f0:	4436      	lsr	Y
    67f2:	7ee6      	lod	X, Y
    67f4:	343f      	and	X, #63

    /* IREF value saturation when overflow */
    int16 set_iref = saved_iref + offset_iref;
    67f6:	a2ee      	add	A, X
    if (set_iref > 0x3F) {
    67f8:	ac3f      	cmp	A, #63
    67fa:	1b02      	jsle	0x6800 <_Flash_IREF_Offset+0x1e>
        set_iref = 0x3F;
    67fc:	703f      	lod	A, #63
    67fe:	0003      	jmp	0x6806 <_Flash_IREF_Offset+0x24>
    }
    else if (set_iref < 0) {
    6800:	ac00      	cmp	A, #0
    6802:	1e81      	jsge	0x6806 <_Flash_IREF_Offset+0x24>
        set_iref = 0;
    6804:	7000      	lod	A, #0
    }

    /* Initialise threshold by absolute value */
    io_flash_trim_a.iref = (set_iref);
    6806:	7ae2      	lod	Y, A
    6808:	f43f      	and	Y, #63
    680a:	f6da 00ff 	and	Y, #255
    680e:	7ae8      	swap	Y
    6810:	4426      	asl	Y
    6812:	7201      	lod	A, [S-2]
    6814:	b6da 81ff 	and	A, #33279
    6818:	a6e6      	or	A, Y
    FLASHTRIMA = io_flash_trim_a.u16;            /* set new io_port value */
    681a:	52d8 2050 	mov	0x2050 <__ep__+0x1050>, A

    /* return MSB-new_IREF; LSB-old_IREF */
    saved_iref |= (io_flash_trim_a.iref << 8);
    681e:	4432      	lsr	A
    6820:	b6da 3f00 	and	A, #16128
    6824:	26e2      	or	X, A

    /* else - return only saved_iref value, no any changes with IREF */

    return saved_iref;
}
    6826:	72ee      	lod	A, X
    6828:	5403      	ret	#4

0000682a <_Flash_PageWriteFiltered>:
/* ----------------------------------------------------------------------------
 * Wrapper for Flash_PageWrite which checks the input addresses to eliminate
 * writing requests to certain Flash pages (depending on the loader state)
 */
__MLX_TEXT__ uint16_t Flash_PageWriteFiltered (uint16_t addr)
{
    682a:	5801      	inc	S, #2
    addr = addr & ~ML_FLASH_BUFFER_MASK;        /* get start address of the page */
    682c:	b480      	and	A, #-128
    682e:	5201      	mov	[S-2], A

    if (addr == ML_APP_CONTROL_PAGE_ADDRESS) {  /* if writing of Application Control Page is requested .. */
    6830:	aeda be80 	cmp	A, #48768
    6834:	1907      	je	0x6844 <_Flash_PageWriteFiltered+0x1a>
        return FLASH_ERR_NONE;                  /* .. skip it */
    }
    /* else: continue with writing procedure  */

#if !defined (HAS_H12_LOADER_PROTOCOL)
    if ((addr == ML_MCU_FAR_PAGE_0_ADDRESS)     /* if writing of Far Page 0 is requested .. */
    6836:	7201      	lod	A, [S-2]
    6838:	aeda bf00 	cmp	A, #48896
    683c:	1d05      	jne	0x6848 <_Flash_PageWriteFiltered+0x1e>
    683e:	16e3      	call	0x6606 <_LDR_GetState>
    6840:	8c03      	cmp	AL, #3
    6842:	1d02      	jne	0x6848 <_Flash_PageWriteFiltered+0x1e>
        && (LDR_GetState() == 3)) {             /* .. in State 3 of the loader ..           */
        return FLASH_ERR_NONE;                  /* .. then skip writing (this page was already written in State 2) */
    6844:	7000      	lod	A, #0
    6846:	5403      	ret	#4
    }
    /* else: continue with writing procedure */
#endif


    return Flash_PageWrite(addr);
    6848:	7201      	lod	A, [S-2]
    684a:	1737      	call	0x66ba <_Flash_PageWrite>
}
    684c:	5403      	ret	#4

0000684e <_ml_SetFastBaudRate>:
 * Input (global):
 *      FPLL            System clock frequency[kHz]
 *
 */
__MLX_TEXT__ void ml_SetFastBaudRate (uint8_t FastBaudRate)
{
    684e:	5805      	inc	S, #6
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6850:	4cc2 45c0 	mov	D, #280000
    6854:	0004 
    6856:	4872 0006 	muls	A, A, #6
    685a:	5203      	mov	[S-4], A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    685c:	4c80      	mov	YA, D
    685e:	7e03      	lod	X, [S-4]
    6860:	4c63      	divu	YA, X
    6862:	4c63      	divu	YA, X
    6864:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6866:	7ae2      	lod	Y, A

    uint16_t ml_CptHi = 2;

    uint16_t ml_CptLowTemp = divU16_U32byU16( (FPLL * 10), (FastBaudRate * 2 * (ml_CptHi + 1)) );

    uint8_t ml_FastPresc = 0;
    6868:	7000      	lod	A, #0
    686a:	5205      	mov	[S-6], A

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
    686c:	eeda 027a 	cmp	Y, #634
    6870:	1e04      	jug	0x687a <_ml_SetFastBaudRate+0x2c>
            ml_CptLowTemp >>= 1;
        }
        /* Otherwise set ml_FastPresc and finish */
        else {
            ml_FastPresc = (presc_cnt - 1) & 0xF;
    6872:	80ff      	add	AL, #-1
    6874:	b40f      	and	A, #15
    6876:	5205      	mov	[S-6], A
            break;
    6878:	0005      	jmp	0x6884 <_ml_SetFastBaudRate+0x36>
    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {

        /* Divide by two if value out of range */
        if (ml_CptLowTemp >= 635) {
            ml_CptLowTemp >>= 1;
    687a:	4436      	lsr	Y

    uint8_t ml_FastPresc = 0;
    uint8_t ml_FastDivider;

    /* Searching of ml_FastPresc by ml_CptLowTemp */
    for (uint8_t presc_cnt = 0; presc_cnt < 3; presc_cnt++) {
    687c:	8001      	add	AL, #1
    687e:	5cf2      	usex	A
    6880:	8c02      	cmp	AL, #2
    6882:	1a74      	jule	0x686c <_ml_SetFastBaudRate+0x1e>
    6884:	72e6      	lod	A, Y
    6886:	a005      	add	A, #5
    6888:	4cf2      	usex	YA
    688a:	7c0a      	lod	X, #10
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    688c:	4c63      	divu	YA, X
    688e:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    6890:	8080      	add	AL, #-128
    6892:	5cf2      	usex	A

    /* Evaluate ml_FastDivider according to ml_CptLowTemp value*/
    ml_FastDivider = 64 * ml_CptHi + divU16_U32byU16((ml_CptLowTemp + 5), 10);

    /* Setting up the Fast Protocol Baudrate */
    ml_SetBaudRate(ml_FastPresc, ml_FastDivider);
    6894:	52df      	push	A
    6896:	7207      	lod	A, [S-8]
    6898:	82db 5b82 	callf	0x5b82 <_ml_SetBaudRate>
    689c:	5c01      	dec	S, #2
    689e:	5407      	ret	#8
    68a0:	b66d      	and	A, [S-110]
    68a2:	6ddb      	lod	YH, dp:0xdb <_l_u16StartupDelayInit+0x1>
    68a4:	dbb6      	subc	AH, ep:0xb6 <_g_i16SupplyVoltage>
    68a6:	b66d      	and	A, [S-110]
    68a8:	6ddb      	lod	YH, dp:0xdb <_l_u16StartupDelayInit+0x1>

000068aa <_RAM_Test>:
    68aa:	7ada 68a0 	lod	Y, #26784
    68ae:	4cc0      	mov	D, YA
    68b0:	7c00      	lod	X, #0
    68b2:	54c6      	movsw	[X++], [Y++]
    68b4:	54c6      	movsw	[X++], [Y++]
    68b6:	54c6      	movsw	[X++], [Y++]
    68b8:	7800      	lod	Y, #0
    68ba:	54c6      	movsw	[X++], [Y++]
    68bc:	2eda 07fe 	cmp	X, #2046
    68c0:	1a7c      	jule	0x68ba <_RAM_Test+0x10>
    68c2:	4c80      	mov	YA, D
    68c4:	7c00      	lod	X, #0
    68c6:	72de      	lod	A, [X++]
    68c8:	aed6      	cmp	A, [Y++]
    68ca:	1d0a      	jne	0x68e0 <_RAM_Test+0x36>
    68cc:	72de      	lod	A, [X++]
    68ce:	aed6      	cmp	A, [Y++]
    68d0:	1d07      	jne	0x68e0 <_RAM_Test+0x36>
    68d2:	72de      	lod	A, [X++]
    68d4:	aed6      	cmp	A, [Y++]
    68d6:	1d04      	jne	0x68e0 <_RAM_Test+0x36>
    68d8:	7800      	lod	Y, #0
    68da:	72de      	lod	A, [X++]
    68dc:	aed6      	cmp	A, [Y++]
    68de:	1903      	je	0x68e6 <_RAM_Test+0x3c>
    68e0:	64f3      	lod	YL, #-13
    68e2:	76da 568e 	jmpf	0x568e <__fatal>
    68e6:	2eda 07fe 	cmp	X, #2046
    68ea:	1a77      	jule	0x68da <_RAM_Test+0x30>
    68ec:	4c80      	mov	YA, D
    68ee:	e002      	add	Y, #2
    68f0:	eeda 68a6 	cmp	Y, #26790
    68f4:	1d5c      	jne	0x68ae <_RAM_Test+0x4>
    68f6:	76da 55e8 	jmpf	0x55e8 <_start>

000068fa <__low_level_init>:
 *
 * NOTE: Function with the same name (i.e. low_level_init) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _low_level_init (void)
{
    68fa:	580d      	inc	S, #14
    /* The MLX16 is running at full-speed as PLL is started in prestart.c, as specified by MCU_PLL_MULT */

    if ( bistHeader != C_CHIP_HEADER )
    68fc:	72d8 01a6 	lod	A, 0x1a6 <__bss_end>
    6900:	aeda b598 	cmp	A, #46488
    6904:	1907      	je	0x6914 <__low_level_init+0x1a>
    {
        /* update the registers because of RAM test and NOLOAD */
        bistHeader = C_CHIP_HEADER;
    6906:	72da b598 	lod	A, #46488
    690a:	52d8 01a6 	mov	0x1a6 <__bss_end>, A
        bistResetInfo = C_CHIP_STATE_COLD_START;
    690e:	7800      	lod	Y, #0
    6910:	5ad8 01a8 	mov	0x1a8 <_bistResetInfo>, Y
    }

#ifdef HAS_NVRAM_CRC

    if (   (bistResetInfo != C_CHIP_STATE_LIN_CMD_RESET)
    6914:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    6918:	aeda 3072 	cmp	A, #12402
    691c:	1d01      	jne	0x6920 <__low_level_init+0x26>
    691e:	0071      	jmp	0x6a02 <__low_level_init+0x108>
    6920:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    6924:	aeda 3212 	cmp	A, #12818
    6928:	1d01      	jne	0x692c <__low_level_init+0x32>
    692a:	006b      	jmp	0x6a02 <__low_level_init+0x108>
    692c:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    6930:	aeda 5c92 	cmp	A, #23698
    6934:	1d01      	jne	0x6938 <__low_level_init+0x3e>
    6936:	0065      	jmp	0x6a02 <__low_level_init+0x108>
    6938:	7c0f      	lod	X, #15
    693a:	7ada 11c0 	lod	Y, #4544
    693e:	7000      	lod	A, #0
    6940:	08a7      	clrb	ML.7
    6942:	b2d6      	adc	A, [Y++]
    6944:	1bfe      	djnz	X, 0x6942 <__low_level_init+0x48>
    6946:	92e4      	adc	AL, AH
    6948:	9000      	adc	AL, #0
    694a:	5cf2      	usex	A
        uint16 u16CRC;

        /* MLX Chip calibration data - CRC2 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA2,
                                ((END_MLX_CALIB_ADDRESS_AREA2 + 1) - BGN_MLX_CALIB_ADDRESS_AREA2)/2 );
        if ( u16CRC != 0xFF )
    694c:	aeda 00ff 	cmp	A, #255
    6950:	1903      	je	0x6958 <__low_level_init+0x5e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #2 is corrupt */
            asm( "mov yl, #0xC9");                  /* C_ERR_INV_MLXPAGE_CRC2 */    /* MLX NVRAM CRC #2 failure */
    6952:	64c9      	lod	YL, #-55
            asm( "jmpf __fatal");
    6954:	76da 568e 	jmpf	0x568e <__fatal>
    6958:	7c0c      	lod	X, #12
    695a:	7ada 11de 	lod	Y, #4574
    695e:	7000      	lod	A, #0
    6960:	08a7      	clrb	ML.7
    6962:	b2d6      	adc	A, [Y++]
    6964:	1bfe      	djnz	X, 0x6962 <__low_level_init+0x68>
    6966:	92e4      	adc	AL, AH
    6968:	9000      	adc	AL, #0
    696a:	5cf2      	usex	A
        }

        /* Other chip values - CRC3 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA3,
                                ((END_MLX_CALIB_ADDRESS_AREA3 + 1) - BGN_MLX_CALIB_ADDRESS_AREA3)/2 );
        if ( u16CRC != 0xFF )
    696c:	aeda 00ff 	cmp	A, #255
    6970:	1903      	je	0x6978 <__low_level_init+0x7e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #3 is corrupt */
            asm( "mov yl, #0xCA");                  /* C_ERR_INV_MLXPAGE_CRC3 */    /* MLX NVRAM CRC #3 failure */
    6972:	64ca      	lod	YL, #-54
            asm( "jmpf __fatal");
    6974:	76da 568e 	jmpf	0x568e <__fatal>
    6978:	7c05      	lod	X, #5
    697a:	7ada 11f6 	lod	Y, #4598
    697e:	7000      	lod	A, #0
    6980:	08a7      	clrb	ML.7
    6982:	b2d6      	adc	A, [Y++]
    6984:	1bfe      	djnz	X, 0x6982 <__low_level_init+0x88>
    6986:	92e4      	adc	AL, AH
    6988:	9000      	adc	AL, #0
    698a:	5cf2      	usex	A
        }

        /* Flash/NVRAM#2 Trimming - CRC4 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA4,
                                ((END_MLX_CALIB_ADDRESS_AREA4 + 1) - BGN_MLX_CALIB_ADDRESS_AREA4)/2 );
        if ( u16CRC != 0xFF )
    698c:	aeda 00ff 	cmp	A, #255
    6990:	1903      	je	0x6998 <__low_level_init+0x9e>
        {
    #ifdef HAS_NVRAM_CRC_FAIL_HANG
            /* Area #4 is corrupt */
            asm( "mov yl, #0xCB");                  /* C_ERR_INV_MLXPAGE_CRC4 */    /* MLX NVRAM CRC #4 failure */
    6992:	64cb      	lod	YL, #-53
            asm( "jmpf __fatal");
    6994:	76da 568e 	jmpf	0x568e <__fatal>
    6998:	7ada 10fc 	lod	Y, #4348
    699c:	7c02      	lod	X, #2
    699e:	7000      	lod	A, #0
    69a0:	08a7      	clrb	ML.7
    69a2:	b2d6      	adc	A, [Y++]
    69a4:	1bfe      	djnz	X, 0x69a2 <__low_level_init+0xa8>
    69a6:	92e4      	adc	AL, AH
    69a8:	9000      	adc	AL, #0
    69aa:	5cf2      	usex	A
        }

        /* Flash/NVRAM#1 Trimming - CRC5 */
        u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
        if (( u16CRC != 0xFF ) ||                                                   /* Check if checksum is corrupted */
    69ac:	aeda 00ff 	cmp	A, #255
    69b0:	1d07      	jne	0x69c0 <__low_level_init+0xc6>
    69b2:	7eda 11f8 	lod	X, #4600
    69b6:	7ada 10fe 	lod	Y, #4350
    69ba:	72f0      	lod	A, [Y]
    69bc:	aef8      	cmp	A, [X]
    69be:	1921      	je	0x6a02 <__low_level_init+0x108>
            (*((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) != *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4 + 2))) )   /* Trim NVRAM 1 check */
        {
            /* Area #5 is corrupt; Copy from Melexis area and calc CRC */
            *((uint16*)  BGN_MLX_CALIB_ADDRESS_AREA5) = 0;
    69c0:	7000      	lod	A, #0
    69c2:	7eda 10fc 	lod	X, #4348
    69c6:	52f8      	mov	[X], A
            *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA5 + 2)) = *((uint16*) (BGN_MLX_CALIB_ADDRESS_AREA4+2));
    69c8:	7eda 10fe 	lod	X, #4350
    69cc:	7ada 11f8 	lod	Y, #4600
    69d0:	7af0      	lod	Y, [Y]
    69d2:	5af8      	mov	[X], Y
    69d4:	7ada 10fc 	lod	Y, #4348
    69d8:	7c02      	lod	X, #2
    69da:	7000      	lod	A, #0
    69dc:	08a7      	clrb	ML.7
    69de:	b2d6      	adc	A, [Y++]
    69e0:	1bfe      	djnz	X, 0x69de <__low_level_init+0xe4>
    69e2:	92e4      	adc	AL, AH
    69e4:	9000      	adc	AL, #0
    69e6:	5cf2      	usex	A
    69e8:	5205      	mov	[S-6], A
            u16CRC = nvram_CalcCRC( (uint16*) BGN_MLX_CALIB_ADDRESS_AREA5,
                                    ((END_MLX_CALIB_ADDRESS_AREA5 + 1) - BGN_MLX_CALIB_ADDRESS_AREA5)/2 );
            *((uint16*) BGN_MLX_CALIB_ADDRESS_AREA5) = (0xFF - u16CRC);
    69ea:	72da 00ff 	lod	A, #255
    69ee:	aa05      	sub	A, [S-6]
    69f0:	7ada 10fc 	lod	Y, #4348
    69f4:	52f0      	mov	[Y], A
            NVRAM_SavePage(NVRAM1_PAGE2);
    69f6:	7001      	lod	A, #1
    69f8:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
            asm( "mov yl, #0xCC");                  /* C_ERR_INV_MLXPAGE_CRC5 */    /* MLX NVRAM CRC #5 failure */
    69fc:	64cc      	lod	YL, #-52
            asm( "jmpf __fatal");
    69fe:	76da 568e 	jmpf	0x568e <__fatal>
        }
    }
#endif /* HAS_NVRAM_CRC */

    CONTROL |= OUTA_WE;                                                         /* Grant access to ANA_OUTx registers */
    6a02:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a06:	8408      	or	AL, #8
    6a08:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTA = EEP_ANA_OUTA & ~TEST_MODE_DIS;                                   /* ANA_OUTA is not set */
    6a0c:	72d8 11f0 	lod	A, 0x11f0 <__ep__+0x1f0>
    6a10:	b6da ff7f 	and	A, #65407
    6a14:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
    CONTROL &= ~OUTA_WE;
    6a18:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a1c:	94f7      	and	AL, #-9
    6a1e:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    ANA_OUTG = 0x0004U;                                                         /* Motor-driver FET switching slew-rate at 100% */
    6a22:	7c04      	lod	X, #4
    6a24:	5ed8 28cc 	mov	0x28cc <__io__+0xcc>, X
#if defined(DEF_SHRAMH) && defined(DEF_SHRAML)
    /* ------------------------------------------------------------------------
     * Initialize shared memory and start MLX4 processor
     * NOTE: Port SHRAM can only be changed when Mlx4 is in reset
     */
    SHRAM = ((uint16)DEF_SHRAMH << 8) | DEF_SHRAML;
    6a28:	72da 7c50 	lod	A, #31824
    6a2c:	52d8 2002 	mov	0x2002 <__ep__+0x1002>, A
#endif

    MLX4_RESET();
    6a30:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a34:	94fe      	and	AL, #-2
    6a36:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    NOP();
    6a3a:	0000      	nop
    NOP();
    6a3c:	0000      	nop
    NOP();
    6a3e:	0000      	nop
    MLX4_START();
    6a40:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    6a44:	8401      	or	AL, #1
    6a46:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    6a4a:	540f      	ret	#16

00006a4c <__premain>:
 *
 * NOTE: Function with the same name (i.e. premain) linked from
 * application directory overrides this function
 */
__MLX_TEXT__ void _premain (void)
{
    6a4c:	587f      	inc	S, #128
    /*
     * Here page_buffer on the stack is initialised.
     * Reset on EnterProgMode is needed to run Loader routine from zero stack when LDR_GetState = 0.
     */
    ml_uint8 page_buffer_stack[128] __attribute__((aligned(2)));
    page_buffer = page_buffer_stack;
    6a4e:	72ef      	lod	A, S
    6a50:	a080      	add	A, #-128
    6a52:	52d8 01a2 	mov	0x1a2 <_page_buffer>, A
#endif /* LDR_HAS_PAGE_BUFFER_ON_STACK */

    if (   (LDR_GetState() != 0)
    6a56:	15d7      	call	0x6606 <_LDR_GetState>
    6a58:	8c00      	cmp	AL, #0
    6a5a:	1d06      	jne	0x6a68 <__premain+0x1c>
    6a5c:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    6a60:	aeda 3212 	cmp	A, #12818
    6a64:	1901      	je	0x6a68 <__premain+0x1c>
    6a66:	003b      	jmp	0x6ade <__premain+0x92>
        || (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET)
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
       )
    {
#if defined (SUPPORT_LINNETWORK_LOADER)
	    if ( stFixedRamNAD.key != _mlx_NAD_Security_Key )
    6a68:	72d8 0010 	lod	A, 0x10 <__data_dp_size>
    6a6c:	7ad8 0012 	lod	Y, 0x12 <__data_dp_size+0x2>
    6a70:	4cb2 72ef 	cmp	YA, #-396266769
    6a74:	e861 
    6a76:	1913      	je	0x6a9e <__premain+0x52>
		{
			uint8_t u8NAD = (uint8_t) *((uint16_t*) 0xBF76);					/* Get NAD from Flash at STACK_IT Segment */
    6a78:	7ada bf76 	lod	Y, #49014
    6a7c:	72f0      	lod	A, [Y]
    6a7e:	5cf2      	usex	A
			if ( (u8NAD & 0x80) || (u8NAD == 0x00) )
    6a80:	8c00      	cmp	AL, #0
    6a82:	1a82      	jsl	0x6a88 <__premain+0x3c>
    6a84:	ac00      	cmp	A, #0
    6a86:	1d01      	jne	0x6a8a <__premain+0x3e>
			{
				u8NAD = 0x7F;													/* Invalid NAD; Use default NAD */
    6a88:	707f      	lod	A, #127
			}
			stFixedRamNAD.nad = u8NAD;
    6a8a:	42d8 0014 	mov	0x14 <__data_dp_size+0x4>, AL
			stFixedRamNAD.key = _mlx_NAD_Security_Key;
    6a8e:	72da 72ef 	lod	A, #29423
    6a92:	52d8 0010 	mov	0x10 <__data_dp_size>, A
    6a96:	72da e861 	lod	A, #59489
    6a9a:	52d8 0012 	mov	0x12 <__data_dp_size+0x2>, A
		}
#endif /* SUPPORT_LINNETWORK_LOADER */

        SET_PRIORITY(7);                /* System mode, low priority (7) */
    6a9e:	54f7      	mov	UPr, #7

        ml_LinInit();
    6aa0:	106e      	call	0x6b7e <_ml_LinInit>
        (void)ml_Connect();
    6aa2:	82db 5b96 	callf	0x5b96 <_ml_Connect>

#if defined (LDR_RESET_ON_ENTER_PROG_MODE)
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
    6aa6:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    6aaa:	aeda 3212 	cmp	A, #12818
    6aae:	1d07      	jne	0x6abe <__premain+0x72>
            ml_ldr_SwitchToProgMode(ML_FALSE);
    6ab0:	7000      	lod	A, #0
    6ab2:	82db 6086 	callf	0x6086 <_ml_ldr_SwitchToProgMode>
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
    6ab6:	72da 5c92 	lod	A, #23698
    6aba:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6abe:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6ac0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6ac2:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6ac4:	b430      	and	A, #48
    6ac6:	1902      	je	0x6acc <__premain+0x80>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6ac8:	6000      	lod	AL, #0
    6aca:	4282      	mov	io:0x2 <_LinCmnd>, AL
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
            WDG_Manager();
            
            if (PEND & CLR_M4_SHE_IT) { /* If LIN interrupt requested */
    6acc:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6ad0:	b410      	and	A, #16
    6ad2:	1975      	je	0x6abe <__premain+0x72>

                /*
                 * LIN interrupt pending bit will be cleared in ml_GetLinEventData
                 */

                ml_GetLinEventData();
    6ad4:	82db 5bb2 	callf	0x5bb2 <_ml_GetLinEventData>
                ml_ProccessLinEvent();
    6ad8:	82db 5be2 	callf	0x5be2 <_ml_ProccessLinEvent>
        if (bistResetInfo == C_CHIP_STATE_LOADER_PROG_RESET) {
            ml_ldr_SwitchToProgMode(ML_FALSE);
            bistResetInfo = C_CHIP_STATE_WATCHDOG_RESET;
        }
#endif /* LDR_RESET_ON_ENTER_PROG_MODE */
        for (;;) {
    6adc:	07f0      	jmp	0x6abe <__premain+0x72>
            }
        }
    }
#endif /* LIN_PIN_LOADER */

    SET_PRIORITY(7);                    /* System mode, low priority (7) */
    6ade:	54f7      	mov	UPr, #7
    6ae0:	5c7f      	dec	S, #128
    6ae2:	5401      	ret

00006ae4 <_mlx_isPowerOk>:

/* ----------------------------------------------------------------------------
 * To check power supply.
 */
__MLX_TEXT__  bool mlx_isPowerOk (void)
{
    6ae4:	5805      	inc	S, #6
    /* ADC setting and result place in stack */
    volatile uint16 adc_setting[] = { (ADC_CH0 | ADC_REF_2_50_V), ADC_CFG_END_MARKER };
    6ae6:	7003      	lod	A, #3
    6ae8:	5205      	mov	[S-6], A
    6aea:	70ff      	lod	A, #-1
    6aec:	5203      	mov	[S-4], A
    volatile uint16 adc_result[]  = { 0 };
    6aee:	7000      	lod	A, #0
    6af0:	5201      	mov	[S-2], A

    /* In case ADC is active, wait to finish it */
    if ((ADC_CTRL & ADC_START) != 0)
    6af2:	7290      	lod	A, io:0x10 <__data_dp_size>
    6af4:	b401      	and	A, #1
    6af6:	1917      	je	0x6b26 <_mlx_isPowerOk+0x42>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6af8:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6afa:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6afc:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6afe:	b430      	and	A, #48
    6b00:	1902      	je	0x6b06 <_mlx_isPowerOk+0x22>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b02:	6000      	lod	AL, #0
    6b04:	4282      	mov	io:0x2 <_LinCmnd>, AL
    {
        uint16 u16MaxDelay = 2U;
        WDG_Manager();
        ADC_CTRL &= ~ADC_LOOP;      /* Stop looping (infinity) */
    6b06:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b08:	b4fb      	and	A, #-5
    6b0a:	5290      	mov	io:0x10 <__data_dp_size>, A
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b0c:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b0e:	b401      	and	A, #1
    6b10:	190a      	je	0x6b26 <_mlx_isPowerOk+0x42>
    6b12:	7801      	lod	Y, #1
        {
            __asm__ __volatile__ (
    6b14:	7eda 15e0 	lod	X, #5600
    6b18:	1bff      	djnz	X, 0x6b18 <_mlx_isPowerOk+0x34>
    #define MLX813xx_USEC_DELAY(us) DELAY((FPLL * (uint32)(us) + 2000) / 5000)

    static INLINE void MLX813xx_MSEC_DELAY(int16 msec)
    {
        int16 i;
        for(i = 0; i < msec; i++)
    6b1a:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b1c:	b401      	and	A, #1
    6b1e:	1903      	je	0x6b26 <_mlx_isPowerOk+0x42>
    6b20:	e0ff      	add	Y, #-1
    6b22:	ecff      	cmp	Y, #-1
    6b24:	1d77      	jne	0x6b14 <_mlx_isPowerOk+0x30>
        while ((ADC_CTRL & ADC_START) && (u16MaxDelay-- > 0))
        {
            MLX813xx_MSEC_DELAY(1);
        }
    }
    ADC_CTRL = 0U;                  /* clear the ADC control register */
    6b26:	7000      	lod	A, #0
    6b28:	5290      	mov	io:0x10 <__data_dp_size>, A

    /* Configure for Vsup measurement */
    ADC_INIT( adc_setting,
    6b2a:	72ef      	lod	A, S
    6b2c:	a0fe      	add	A, #-2
    6b2e:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
    6b30:	72ef      	lod	A, S
    6b32:	a0fa      	add	A, #-6
    6b34:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
    6b36:	72da 0080 	lod	A, #128
    6b3a:	5290      	mov	io:0x10 <__data_dp_size>, A
              adc_result,
              ADC_SOFTWARE_TRIGGER,
              ADC_SINGLE_SEQUNCE_MODE );

    ADC_START_SEQUENCE();
    6b3c:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b3e:	a401      	or	A, #1
    6b40:	5290      	mov	io:0x10 <__data_dp_size>, A
    DELAY(500);                     /* some delay for sample and hold */
    6b42:	7eda 01f4 	lod	X, #500
    6b46:	1bff      	djnz	X, 0x6b46 <_mlx_isPowerOk+0x62>
    ADC_TRIGGER_NEXT_CONVERSION();
    6b48:	7040      	lod	A, #64
    6b4a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    6b4e:	7290      	lod	A, io:0x10 <__data_dp_size>
    6b50:	a6da 0100 	or	A, #256
    6b54:	5290      	mov	io:0x10 <__data_dp_size>, A
    6b56:	72d8 2008 	lod	A, 0x2008 <__ep__+0x1008>
    6b5a:	b440      	and	A, #64
    6b5c:	1d08      	jne	0x6b6e <_mlx_isPowerOk+0x8a>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6b5e:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6b60:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6b62:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6b64:	b430      	and	A, #48
    6b66:	1977      	je	0x6b56 <_mlx_isPowerOk+0x72>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6b68:	6000      	lod	AL, #0
    6b6a:	4282      	mov	io:0x2 <_LinCmnd>, AL
    6b6c:	07f4      	jmp	0x6b56 <_mlx_isPowerOk+0x72>

    while (ADC_IS_BUSY()) {         /* wait until current channel conversion completed */
        WDG_Manager();
    }

    if ( adc_result[0] <= POWER_LOW ) {
    6b6e:	7201      	lod	A, [S-2]
    6b70:	aeda 0158 	cmp	A, #344
    6b74:	1e02      	jug	0x6b7a <_mlx_isPowerOk+0x96>
        return false;
    6b76:	7000      	lod	A, #0
    6b78:	5407      	ret	#8
    }
    else {
        return true;
    6b7a:	7001      	lod	A, #1
    }
}
    6b7c:	5407      	ret	#8

00006b7e <_ml_LinInit>:
/*
 *
 */
__MLX_TEXT__  void ml_LinInit(void)
{
	(void)ml_InitLinModule();          /* Start and initialize the LIN Module */
    6b7e:	82db 5dce 	callf	0x5dce <_ml_InitLinModule>

	/* The LIN Module is now in the DISCONNECTED state */

#if STANDALONE_LOADER == 0
	/* Configure the Mlx4 software */
    (void)ml_SetOptions (1U,        /* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    6b82:	54ca 0000 	pushw	#0
    6b86:	54ca 0001 	pushw	#1
    6b8a:	54ca 0000 	pushw	#0
    6b8e:	7001      	lod	A, #1
    6b90:	82db 5ad4 	callf	0x5ad4 <_ml_SetOptions>
                    0U,             /* TXStopBitLength = 1 Bit */
                    ML_ENABLED,     /* StateChangeSignal */
                    ML_LIGHTSLEEP   /* SleepMode: lightsleep mode */
                   );
    (void)ml_SetSlewRate(ML_SLEWHIGH);
    6b94:	7000      	lod	A, #0
    6b96:	82db 5acc 	callf	0x5acc <_ml_SetSlewRate>
    6b9a:	5c05      	dec	S, #6
    6b9c:	5401      	ret
    6b9e:	0000      	nop
    6ba0:	5c32      	dec	S, #51
    6ba2:	5c4e      	dec	S, #79
    6ba4:	5ca6      	sne	Y
    6ba6:	5cd6      	.word	0x5cd6
    6ba8:	5cea      	ssex	
    6baa:	0000      	nop
    6bac:	0001      	jmp	0x6bb0 <_muldivI16_I16byI16byI16+0x2>

00006bae <_muldivI16_I16byI16byI16>:
    6bae:	7a03      	lod	Y, [S-4]
    6bb0:	4831      	muls	YA, A, Y
    6bb2:	7e05      	lod	X, [S-6]
    6bb4:	4c73      	divs	YA, X
    6bb6:	4c73      	divs	YA, X
    6bb8:	4c7b      	dadjs	YA, X
    6bba:	5401      	ret

00006bbc <_muldivU16_U16byU16byU16>:
    6bbc:	7a03      	lod	Y, [S-4]
    6bbe:	4821      	mulu	YA, A, Y
    6bc0:	7e05      	lod	X, [S-6]
    6bc2:	4c63      	divu	YA, X
    6bc4:	4c63      	divu	YA, X
    6bc6:	5401      	ret

00006bc8 <_divI32_I32byI16>:
    6bc8:	7e03      	lod	X, [S-4]
    6bca:	1d87      	jnn	0x6bda <_divI32_I32byU16+0x2>
    6bcc:	5cce      	neg	X
    6bce:	5e03      	mov	[S-4], X
    6bd0:	e000      	add	Y, #0
    6bd2:	1d86      	jnn	0x6be0 <_divI32_I32byU16+0x8>
    6bd4:	4cf0      	neg	YA
    6bd6:	0011      	jmp	0x6bfa <_divU32_U32byU16>

00006bd8 <_divI32_I32byU16>:
    6bd8:	7e03      	lod	X, [S-4]
    6bda:	e000      	add	Y, #0
    6bdc:	1d8e      	jnn	0x6bfa <_divU32_U32byU16>
    6bde:	4cf0      	neg	YA
    6be0:	4ca3      	push	YA
    6be2:	72e6      	lod	A, Y
    6be4:	7800      	lod	Y, #0
    6be6:	7e07      	lod	X, [S-8]
    6be8:	4c63      	divu	YA, X
    6bea:	4c63      	divu	YA, X
    6bec:	5201      	mov	[S-2], A
    6bee:	7203      	lod	A, [S-4]
    6bf0:	4c63      	divu	YA, X
    6bf2:	4c63      	divu	YA, X
    6bf4:	7a01      	lod	Y, [S-2]
    6bf6:	4cf0      	neg	YA
    6bf8:	5405      	ret	#6

00006bfa <_divU32_U32byU16>:
    6bfa:	4ca3      	push	YA
    6bfc:	72e6      	lod	A, Y
    6bfe:	7800      	lod	Y, #0
    6c00:	7e07      	lod	X, [S-8]
    6c02:	4c63      	divu	YA, X
    6c04:	4c63      	divu	YA, X
    6c06:	5201      	mov	[S-2], A
    6c08:	7203      	lod	A, [S-4]
    6c0a:	4c63      	divu	YA, X
    6c0c:	4c63      	divu	YA, X
    6c0e:	7a01      	lod	Y, [S-2]
    6c10:	5405      	ret	#6

00006c12 <_mulI32_I16byU16>:
    6c12:	a000      	add	A, #0
    6c14:	1d85      	jnn	0x6c20 <_mulU32_U16byU16>
    6c16:	5cc2      	neg	A
    6c18:	7a03      	lod	Y, [S-4]
    6c1a:	4821      	mulu	YA, A, Y
    6c1c:	4cf0      	neg	YA
    6c1e:	5401      	ret

00006c20 <_mulU32_U16byU16>:
    6c20:	7a03      	lod	Y, [S-4]
    6c22:	4821      	mulu	YA, A, Y
    6c24:	5401      	ret

00006c26 <_main>:

#pragma space none

int16 main( void)
{
	MLX315_SystemInit();                               	/* initialize MLX315 hardware */
    6c26:	1351      	call	0x72ca <_MLX315_SystemInit>
	
	SET_PRIORITY(0);							       	/* Enter application mode */
    6c28:	54f0      	mov	UPr, #0

	/* driver initialize area */
	NVRAM_Init();                              			/* Load User NVRAM storage parameters */
    6c2a:	82db 9230 	callf	0x9230 <_NVRAM_Init>
	ADC_Init();									       	/* Initialize ADC */
    6c2e:	82db 81d4 	callf	0x81d4 <_ADC_Init>
	DiagnosticsInit();							       	/* Initialize Diagnostic */
    6c32:	82db 8484 	callf	0x8484 <_DiagnosticsInit>
	MotorDriverInit();							       	/*  Initialize Motor-driver */
    6c36:	82db 8992 	callf	0x8992 <_MotorDriverInit>
	PID_Init();										   	/* PID Control initialization */
    6c3a:	82db 966e 	callf	0x966e <_PID_Init>
	LIN_Init();											/* initialize LIN interface */
    6c3e:	82db 767e 	callf	0x767e <_LIN_Init>
	
	SET_PRIORITY(7);									/* Enable interrupts:MASK LEVEL lowest */
    6c42:	54f7      	mov	UPr, #7
	
	/* system service */
	ErrorLogInit();								       	/* Initialize Error-logging management */	
    6c44:	82db 87b0 	callf	0x87b0 <_ErrorLogInit>
	Timer_Init();								       	/* Initialize (Core) Timer */
    6c48:	82db 9886 	callf	0x9886 <_Timer_Init>

#if _SUPPORT_MOTOR_SELFTEST
	MotorDiagnosticSelfTest();							/* Self-test Motor-Driver */
#endif
	/* Application initialize area */
	App_CoolantValveSMInit();
    6c4c:	1012      	call	0x6c72 <_App_CoolantValveSMInit>
	System_BackgroundTaskInit();
    6c4e:	13c7      	call	0x73de <_System_BackgroundTaskInit>
	
	for(;;)
	{
		/* user application */
		App_CoolantValveSM();
    6c50:	1294      	call	0x717a <_App_CoolantValveSM>

		/* driver and service */
		MotorDriver_MainFunction();
    6c52:	82db 8d70 	callf	0x8d70 <_MotorDriver_MainFunction>
		LIN_MainFunction();
    6c56:	82db 79c0 	callf	0x79c0 <_LIN_MainFunction>
		
		/* system background application */
		System_BackgroundMemoryTest();
    6c5a:	82db 74ae 	callf	0x74ae <_System_BackgroundMemoryTest>
		System_BackgroundIORegTest();
    6c5e:	82db 74f6 	callf	0x74f6 <_System_BackgroundIORegTest>
 */
__MLX_TEXT__  static INLINE void awdg_restart (void)
{
    uint16 temp;    /* use temp variable as a workaround for compiler issue [MLXCOMP-17] */

    temp = AWD_CTRL;
    6c62:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    AWD_CTRL = temp;
    6c64:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
{
    awdg_restart();

    /* Request [PLTF-626]: Acknowledge Digital Watchdog
     */
    if ((WD_CTRL & WD_MODE) != 0) {     /* if digital watchdog is enabled .. */
    6c66:	6283      	lod	AL, io:0x3 <_LinCmnd+0x1>
    6c68:	b430      	and	A, #48
    6c6a:	1972      	je	0x6c50 <_main+0x2a>
        WD_T = 0;                       /* .. acknowledge the watchdog */
    6c6c:	6000      	lod	AL, #0
    6c6e:	4282      	mov	io:0x2 <_LinCmnd>, AL
#endif
	/* Application initialize area */
	App_CoolantValveSMInit();
	System_BackgroundTaskInit();
	
	for(;;)
    6c70:	07ef      	jmp	0x6c50 <_main+0x2a>

00006c72 <_App_CoolantValveSMInit>:
void handleEmergencyRunEvent(void);
void handleSleepEvent(void);
void Valve_GotoSleep(void);

void App_CoolantValveSMInit(void)
{
    6c72:	581f      	inc	S, #32
	uint16 cv_nvm[3];
	Motor_ControlParams motor_params;

	{
		/* unnitialized,use default value */
		l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6c74:	72da 0190 	lod	A, #400
    6c78:	52d8 00ec 	mov	0xec <__data_end>, A
		l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;	
    6c7c:	52d8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, A
		l_u16PhysicalCalibTravel = C_VALVE_DEF_TRAVEL;
    6c80:	7ada 0780 	lod	Y, #1920
    6c84:	5ad8 00f0 	mov	0xf0 <_l_u16PhysicalCalibTravel>, Y
		l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6c88:	6000      	lod	AL, #0
    6c8a:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
		l_e8CalibrationStep = (uint8)C_CALIB_NONE;
    6c8e:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
	}

	/* configure motor control params */
	motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6c92:	7800      	lod	Y, #0
    6c94:	5a19      	mov	[S-26], Y
	motor_params.ActPos = l_u16PhysicalActualPos;
    6c96:	7eda 0190 	lod	X, #400
    6c9a:	5e15      	mov	[S-22], X
	motor_params.TgtPos = l_u16PhysicalTargetPos;
    6c9c:	5e17      	mov	[S-24], X
	motor_params.SpdRPM = NVRAM_SPEED1;
    6c9e:	72da 00c8 	lod	A, #200
    6ca2:	520f      	mov	[S-16], A
	MotorDriverSetParams(motor_params);
    6ca4:	7aef      	lod	Y, S
    6ca6:	e0f4      	add	Y, #-12
    6ca8:	5a0d      	mov	[S-14], Y
    6caa:	7ee6      	lod	X, Y
    6cac:	7aef      	lod	Y, S
    6cae:	e0e6      	add	Y, #-26
    6cb0:	54e6      	mov	Cx, #6
    6cb2:	54c6      	movsw	[X++], [Y++]
    6cb4:	1ffe      	djnz	Cx, 0x6cb2 <_App_CoolantValveSMInit+0x40>
    6cb6:	82db 886c 	callf	0x886c <_MotorDriverSetParams>
	
#if _SUPPORT_ENDSTOP_DETECTION
	l_u8EndstopCheckLock = 0u; 		/* unlock endstop check when wake-up or power up  */
    6cba:	6000      	lod	AL, #0
    6cbc:	42d8 0098 	mov	0x98 <_l_u8EndstopCheckLock>, AL
#endif

	l_u8OBDValveElectricError = (uint8)OBD_VALVE_ELECTRIC_INDET;
    6cc0:	6080      	lod	AL, #-128
    6cc2:	42d8 009f 	mov	0x9f <_l_u8OBDValveElectricError>, AL

#if _SUPPORT_STALLDET
	l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_INDET;
    6cc6:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
    6cca:	5c0b      	dec	S, #12
    6ccc:	5415      	ret	#22

00006cce <_handleOpeningPosition>:
	g_u8ValveInitState = l_e8ValveState;
	
}

void handleOpeningPosition(void)
{
    6cce:	580b      	inc	S, #12
	Motor_ControlParams motor_params;
	
	/* handle master normal start motor request */
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_START)
    6cd0:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    6cd4:	ac03      	cmp	A, #3
    6cd6:	1d0d      	jne	0x6cf2 <_handleOpeningPosition+0x24>
	{
		s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6cd8:	7000      	lod	A, #0
    6cda:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
		/* when endstop detection is enabled,target position is set to make sure the maximun valve range 
		  * may be reached,for the endstop function to operates normally.
		  */
		{
			/* opening to target position */
			l_u16PhysicalTargetPos = s_CVRequestStruct.m_opening + C_VALVE_ZERO_POS;
    6cde:	72d8 0090 	lod	A, 0x90 <_s_CVRequestStruct+0x2>
    6ce2:	a2da 0190 	add	A, #400
    6ce6:	52d8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, A
		/* unlock endstop check,need position already gone compensation? */
		/* still lock for endstop check? */
//		if(l_u8EndstopCheckLock == 0u)
		{
			/* only update target position */
			l_u8MotorControl = C_MOTOR_START_ONLY;
    6cea:	6004      	lod	AL, #4
    6cec:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
    6cf0:	540d      	ret	#14
		/* only update target position */
		l_u8MotorControl = C_MOTOR_START_ONLY;
#endif /* _SUPPORT_ENDSTOP_DETECTION */

	}
	else if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_STOP)
    6cf2:	ac01      	cmp	A, #1
    6cf4:	1d06      	jne	0x6d02 <_handleOpeningPosition+0x34>
	{
#if _SUPPORT_ENDSTOP_DETECTION
		/* endstop check unlock process[1]:1)stop request;2)need moving request */
		l_u8EndstopCheckLock = 0u;	
    6cf6:	6000      	lod	AL, #0
    6cf8:	42d8 0098 	mov	0x98 <_l_u8EndstopCheckLock>, AL
#endif
		/* only stop motor:immediate */
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6cfc:	6002      	lod	AL, #2
    6cfe:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
    6d02:	540d      	ret	#14

00006d04 <_handleStateTransition>:
}

void handleStateTransition(void)
{
	/* unnitialized -> initializing */
	if(l_e8ValveState == (uint8)C_STATE_UNINITIALIZED)
    6d04:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    6d08:	1d06      	jne	0x6d16 <_handleStateTransition+0x12>
	{
		if(l_e8CalibrationStep == (uint8)C_CALIB_START)
    6d0a:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6d0e:	8c01      	cmp	AL, #1
    6d10:	1d02      	jne	0x6d16 <_handleStateTransition+0x12>
		{
			l_e8ValveState = (uint8)C_STATE_INITIALIZING;
    6d12:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
		}
	}
	/* initializing -> unnitialize,initializing -> initialized */
	/* permanent electric error,temperory electric error,mechanical error */
	if(l_e8ValveState == (uint8)C_STATE_INITIALIZING)
    6d16:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    6d1a:	8c01      	cmp	AL, #1
    6d1c:	1d13      	jne	0x6d44 <_handleStateTransition+0x40>
	{
		/* error block/hall sensor,or error meichanical valve broken */
		if(((l_u8OBDValveElectricError & OBD_VALVE_ELECTRIC_PERM) != 0u) || 
    6d1e:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    6d22:	b401      	and	A, #1
    6d24:	1d04      	jne	0x6d2e <_handleStateTransition+0x2a>
    6d26:	62d8 00a0 	lod	AL, 0xa0 <_l_u8OBDValveMechanicalError>
    6d2a:	b407      	and	A, #7
    6d2c:	1903      	je	0x6d34 <_handleStateTransition+0x30>
			((l_u8OBDValveMechanicalError & OBD_VALVE_MECHANICAL_MASK) != 0u))
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6d2e:	6000      	lod	AL, #0
    6d30:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
			/* start calibration pause timer,prevent from contiuous calibration */
//			Timer_Start(CALIB_PAUSE_TIMER,C_PI_TICKS_500MS);
		}
		/* range error */
		if(l_e8CalibrationStep == (uint8)C_CALIB_NONE)
    6d34:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6d38:	1903      	je	0x6d40 <_handleStateTransition+0x3c>
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
			/* start calibration pause timer,prevent from contiuous calibration */
//			Timer_Start(CALIB_PAUSE_TIMER,C_PI_TICKS_500MS);
		}
		else if(l_e8CalibrationStep == (uint8)C_CALIB_DONE)
    6d3a:	8c0a      	cmp	AL, #10
    6d3c:	1d03      	jne	0x6d44 <_handleStateTransition+0x40>
		{
			l_e8ValveState = (uint8)C_STATE_INITIALIZED;
    6d3e:	6002      	lod	AL, #2
    6d40:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
		{
		}
	}
	/* initialized -> uninitialized */
	/* permanent electric error,valve block or broken(endstop check) */
	if(l_e8ValveState == (uint8)C_STATE_INITIALIZED)
    6d44:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    6d48:	8c02      	cmp	AL, #2
    6d4a:	1d0b      	jne	0x6d62 <_handleStateTransition+0x5e>
	{
		/* degrade mode caused by non auto-recovery error,motor should be reset to stop state:
		  * 1) mechanical stall(expected/unexpected), 
		  * 2) permanent electric error(coil open/short) 
		  */
		if(((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) != 0u) || 
    6d4c:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    6d50:	b401      	and	A, #1
    6d52:	1d04      	jne	0x6d5c <_handleStateTransition+0x58>
    6d54:	62d8 00a0 	lod	AL, 0xa0 <_l_u8OBDValveMechanicalError>
    6d58:	b407      	and	A, #7
    6d5a:	1903      	je	0x6d62 <_handleStateTransition+0x5e>
			((l_u8OBDValveMechanicalError & (uint8)OBD_VALVE_MECHANICAL_MASK) != 0u))
		{
			l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    6d5c:	6000      	lod	AL, #0
    6d5e:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
			/* start calibration pause timer,prevent from contiuous calibration */
//			Timer_Start(CALIB_PAUSE_TIMER,C_PI_TICKS_500MS);
		}
	}
	g_u8ValveInitState = l_e8ValveState;
    6d62:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    6d66:	42d8 00d6 	mov	0xd6 <_g_u8ValveInitState>, AL
    6d6a:	5401      	ret

00006d6c <_handleInitiliazeProcess>:
		}
	}
}

void handleInitiliazeProcess(void)
{
    6d6c:	580b      	inc	S, #12
	Motor_ControlParams motor_params;
	uint16 range_temp;	/* range travelled from end to end,with hall sensor detection steps */

	if(l_e8CalibrationStep == (uint8)C_CALIB_START)
    6d6e:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6d72:	8c01      	cmp	AL, #1
    6d74:	1d06      	jne	0x6d82 <_handleInitiliazeProcess+0x16>
	{
		if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6d76:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    6d7a:	ac05      	cmp	A, #5
    6d7c:	1d02      	jne	0x6d82 <_handleInitiliazeProcess+0x16>
        {
			l_e8CalibrationStep = (uint8)C_CALIB_SETUP_LO_ENDPOS;
    6d7e:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
		}
	}

	if( l_e8CalibrationStep == (uint8)C_CALIB_SETUP_LO_ENDPOS )
    6d82:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6d86:	8c05      	cmp	AL, #5
    6d88:	1d15      	jne	0x6db4 <_handleInitiliazeProcess+0x48>
	{
		/* setup low endstop */
		if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6d8a:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    6d8e:	ac05      	cmp	A, #5
    6d90:	1d11      	jne	0x6db4 <_handleInitiliazeProcess+0x48>
		{
            s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6d92:	7000      	lod	A, #0
    6d94:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
            /* setup motor parameters and start motor */
			l_u16PhysicalActualPos = C_VALVE_RANGE_MAX + C_VALVE_ZERO_POS;
    6d98:	72da 0a60 	lod	A, #2656
    6d9c:	52d8 00ec 	mov	0xec <__data_end>, A
			l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;
    6da0:	72da 0190 	lod	A, #400
    6da4:	52d8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, A
			/* client-server:post message */
			l_u8MotorControl = C_MOTOR_START;
    6da8:	6003      	lod	AL, #3
    6daa:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL

		    l_e8CalibrationStep = (uint8) C_CALIB_CHECK_LO_ENDPOS;
    6dae:	6006      	lod	AL, #6
    6db0:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
        }
	}

	if(l_e8CalibrationStep == (uint8)C_CALIB_CHECK_LO_ENDPOS)
    6db4:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6db8:	8c06      	cmp	AL, #6
    6dba:	1d2e      	jne	0x6e18 <_handleInitiliazeProcess+0xac>
	{
#if _SUPPORT_STALLDET
		/* hall stall shall always be detected */
		if ( l_u8StallOcc == TRUE)
    6dbc:	62d8 00a1 	lod	AL, 0xa1 <_l_u8StallOcc>
    6dc0:	8c01      	cmp	AL, #1
    6dc2:	1d11      	jne	0x6de6 <_handleInitiliazeProcess+0x7a>
		{		
			l_u8StallOcc = FALSE;
    6dc4:	6000      	lod	AL, #0
    6dc6:	42d8 00a1 	mov	0xa1 <_l_u8StallOcc>, AL
			MotorDriverClearFaultStatus();
    6dca:	82db 88ac 	callf	0x88ac <_MotorDriverClearFaultStatus>
			l_u8ValveInitEnds |= (uint8)C_VALVE_INIT_END_LO;
    6dce:	62d8 009d 	lod	AL, 0x9d <_l_u8ValveInitEnds>
    6dd2:	8402      	or	AL, #2
    6dd4:	42d8 009d 	mov	0x9d <_l_u8ValveInitEnds>, AL
            {
				{
//					l_u16PhysicalCalibTravel = range_temp;
					l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6dd8:	72da 0190 	lod	A, #400
    6ddc:	52d8 00ec 	mov	0xec <__data_end>, A
					l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;
    6de0:	52d8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, A
    6de4:	000a      	jmp	0x6dfa <_handleInitiliazeProcess+0x8e>

		}
        /* or the valve os over range */
		else
		{
			if(l_u16PhysicalActualPos <= C_VALVE_ZERO_POS)
    6de6:	72d8 00ec 	lod	A, 0xec <__data_end>
    6dea:	aeda 0190 	cmp	A, #400
    6dee:	1e09      	jug	0x6e02 <_handleInitiliazeProcess+0x96>
			{
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_RANGE_BROKEN;
    6df0:	6002      	lod	AL, #2
    6df2:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BROKEN;
    6df6:	42d8 008b 	mov	0x8b <_l_u8ValueFaultFlag>, AL
				l_e8CalibrationStep = (uint8)C_CALIB_END;
    6dfa:	6009      	lod	AL, #9
    6dfc:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
    6e00:	000b      	jmp	0x6e18 <_handleInitiliazeProcess+0xac>
			}
			else
			{
				if(s_CVRequestStruct.m_request == C_MOTOR_REQUEST_STOP)
    6e02:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    6e06:	ac01      	cmp	A, #1
    6e08:	1d02      	jne	0x6e0e <_handleInitiliazeProcess+0xa2>
				{
					/* stop stepper motor:immediate */
					l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6e0a:	6002      	lod	AL, #2
    6e0c:	0003      	jmp	0x6e14 <_handleInitiliazeProcess+0xa8>
					/* re-start calibration */
				}
				else if(s_CVRequestStruct.m_request == C_MOTOR_REQUEST_CALIBRATION)
    6e0e:	ac05      	cmp	A, #5
    6e10:	1d03      	jne	0x6e18 <_handleInitiliazeProcess+0xac>
				{
					l_u8MotorControl = C_MOTOR_START_ONLY;
    6e12:	6004      	lod	AL, #4
    6e14:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
	{
		/* unsupported state,should never enter */
	}

	/* calibration end */
	if(l_e8CalibrationStep == (uint8)C_CALIB_END)
    6e18:	62d8 009e 	lod	AL, 0x9e <_l_e8CalibrationStep>
    6e1c:	8c09      	cmp	AL, #9
    6e1e:	1d18      	jne	0x6e50 <_handleInitiliazeProcess+0xe4>
	{
#if _SUPPORT_STALLDET
        if((l_u8OBDValveMechanicalError != OBD_VALVE_RANGE_BLOCK) && (l_u8OBDValveMechanicalError != OBD_VALVE_RANGE_BROKEN))
    6e20:	62d8 00a0 	lod	AL, 0xa0 <_l_u8OBDValveMechanicalError>
    6e24:	80ff      	add	AL, #-1
    6e26:	8c01      	cmp	AL, #1
    6e28:	1a0a      	jule	0x6e3e <_handleInitiliazeProcess+0xd2>
        {		
			l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
    6e2a:	6000      	lod	AL, #0
    6e2c:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
			/* synchronize step motor position? */
			/* client-server:post message */
			l_u8MotorControl = C_MOTOR_STOP;
    6e30:	6001      	lod	AL, #1
    6e32:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
		    l_e8CalibrationStep = (uint8)C_CALIB_DONE;
    6e36:	600a      	lod	AL, #10
    6e38:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
    6e3c:	540d      	ret	#14

        }
		else
		{
			/* stop stepper motor:immediate */
			l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6e3e:	6002      	lod	AL, #2
    6e40:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
			l_e8CalibrationStep = (uint8)C_CALIB_NONE;
    6e44:	6000      	lod	AL, #0
    6e46:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
		    s_CVRequestStruct.m_request = (uint16)C_MOTOR_REQUEST_NONE;
    6e4a:	7000      	lod	A, #0
    6e4c:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
    6e50:	540d      	ret	#14

00006e52 <_handleStartInitialize>:

void handleStartInitialize(void)
{
//	uint8 ret = Timer_IsExpired(CALIB_PAUSE_TIMER);
	
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_CALIBRATION)
    6e52:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    6e56:	ac05      	cmp	A, #5
    6e58:	1d1b      	jne	0x6e90 <_handleStartInitialize+0x3e>
	{
		if(s_CVRequestStruct.m_opening <= C_VALVE_RANGE_MAX)
    6e5a:	72d8 0090 	lod	A, 0x90 <_s_CVRequestStruct+0x2>
    6e5e:	aeda 08d0 	cmp	A, #2256
    6e62:	1e16      	jug	0x6e90 <_handleStartInitialize+0x3e>
		{
			Timer_Start(FAULT_HOLD_TIMER,C_PI_TICKS_500MS);
    6e64:	54ca 03e8 	pushw	#1000
    6e68:	7008      	lod	A, #8
    6e6a:	82db 989a 	callf	0x989a <_Timer_Start>
			l_e8CalibrationStep = (uint8)C_CALIB_START;
    6e6e:	6001      	lod	AL, #1
    6e70:	42d8 009e 	mov	0x9e <_l_e8CalibrationStep>, AL
			l_u8ValveInitEnds = (uint8)C_VALVE_INIT_END_NONE;
    6e74:	6000      	lod	AL, #0
    6e76:	42d8 009d 	mov	0x9d <_l_u8ValveInitEnds>, AL
			/* reset OBD status */
			l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_INDET;
    6e7a:	6080      	lod	AL, #-128
    6e7c:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
			l_u8OBDValveElectricError = (uint8)OBD_VALVE_ELECTRIC_INDET;
    6e80:	42d8 009f 	mov	0x9f <_l_u8OBDValveElectricError>, AL
			/* reset motor status */
			MotorDriverClearFaultStatus();
    6e84:	82db 88ac 	callf	0x88ac <_MotorDriverClearFaultStatus>
			l_u8ValueFaultFlag = 0;
    6e88:	6000      	lod	AL, #0
    6e8a:	42d8 008b 	mov	0x8b <_l_u8ValueFaultFlag>, AL
    6e8e:	5c01      	dec	S, #2
    6e90:	5401      	ret

00006e92 <_handleEndstopCheck>:
	}
}

/* stall detection and endstop check */
void handleEndstopCheck(void)
{
    6e92:	5815      	inc	S, #22
	Motor_ControlParams motor_params;
	Motor_RuntimeStatus motor_status;
	
	MotorDriverGetStatus(&motor_status);
    6e94:	72ef      	lod	A, S
    6e96:	a0f6      	add	A, #-10
    6e98:	82db 8890 	callf	0x8890 <_MotorDriverGetStatus>

  	if(motor_status.Fault.ST != 0u)	/* stall found? */
    6e9c:	7207      	lod	A, [S-8]
    6e9e:	b6da 03c0 	and	A, #960
    6ea2:	1d01      	jne	0x6ea6 <_handleEndstopCheck+0x14>
    6ea4:	0044      	jmp	0x6f2e <_handleEndstopCheck+0x9c>
  	{
		MotorDriverClearFaultStatus();		/* clear motor stall and stop motor */
    6ea6:	82db 88ac 	callf	0x88ac <_MotorDriverClearFaultStatus>
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    6eaa:	6002      	lod	AL, #2
    6eac:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL

		/* give low endstop check a tolerance:minimum valve range shall be guaranteed */
		if(motor_status.Direction == C_MOTOR_DIR_CCW)
    6eb0:	6201      	lod	AL, [S-2]
    6eb2:	8c01      	cmp	AL, #1
    6eb4:	1d1a      	jne	0x6eea <_handleEndstopCheck+0x58>
		{
			if(l_u16PhysicalActualPos > C_VALVE_ZERO_POS)
    6eb6:	7ad8 00ec 	lod	Y, 0xec <__data_end>
    6eba:	eeda 0190 	cmp	Y, #400
    6ebe:	1e1d      	jug	0x6efa <_handleEndstopCheck+0x68>
			{
				/* stall detect within normal valve range */
				l_u8OBDValveMechanicalError = OBD_VALVE_RANGE_BLOCK;
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BLOCK;
			}
			else if(l_u16PhysicalActualPos > (C_VALVE_ZERO_POS - C_VALVE_TOLERANCE_POS))
    6ec0:	eeda 00a0 	cmp	Y, #160
    6ec4:	1a0c      	jule	0x6ede <_handleEndstopCheck+0x4c>
			{
				/* GM spec. to report real position,to prevent from overflow */
				l_u16PhysicalActualPos = C_VALVE_ZERO_POS;
    6ec6:	7ada 0190 	lod	Y, #400
    6eca:	5ad8 00ec 	mov	0xec <__data_end>, Y
				l_u16PhysicalTargetPos = C_VALVE_ZERO_POS;
    6ece:	5ad8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, Y
				/* client-server:post message */
				l_u8MotorControl = C_MOTOR_STOP;
    6ed2:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL

				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
    6ed6:	6000      	lod	AL, #0
    6ed8:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
    6edc:	5417      	ret	#24
			}
			else
			{
				l_u8OBDValveMechanicalError = OBD_VALVE_RANGE_BROKEN;
    6ede:	6402      	lod	YL, #2
    6ee0:	46d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, YL
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BROKEN;
    6ee4:	46d8 008b 	mov	0x8b <_l_u8ValueFaultFlag>, YL
    6ee8:	5417      	ret	#24
			}
		}
		else if(motor_status.Direction == C_MOTOR_DIR_CW)
    6eea:	8c00      	cmp	AL, #0
    6eec:	1d20      	jne	0x6f2e <_handleEndstopCheck+0x9c>
		{
			if(l_u16PhysicalActualPos < (C_VALVE_ZERO_POS + C_VALVE_DEF_TRAVEL))
    6eee:	72d8 00ec 	lod	A, 0xec <__data_end>
    6ef2:	aeda 090f 	cmp	A, #2319
    6ef6:	1e06      	jug	0x6f04 <_handleEndstopCheck+0x72>
			{
				/* stall detect within normal valve range */
				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_RANGE_BLOCK;	
    6ef8:	6001      	lod	AL, #1
    6efa:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BLOCK;
    6efe:	42d8 008b 	mov	0x8b <_l_u8ValueFaultFlag>, AL
    6f02:	5417      	ret	#24
			}
			else if(l_u16PhysicalActualPos < (C_VALVE_ZERO_POS + C_VALVE_RANGE_MAX))
    6f04:	aeda 0a5f 	cmp	A, #2655
    6f08:	1e0d      	jug	0x6f24 <_handleEndstopCheck+0x92>
			{
				/* GM spec. to report real position,to prevent from overflow */
				l_u16PhysicalActualPos = C_VALVE_ZERO_POS + C_VALVE_DEF_TRAVEL;
    6f0a:	72da 0910 	lod	A, #2320
    6f0e:	52d8 00ec 	mov	0xec <__data_end>, A
				l_u16PhysicalTargetPos = C_VALVE_ZERO_POS + C_VALVE_DEF_TRAVEL;
    6f12:	52d8 00ee 	mov	0xee <_l_u16PhysicalTargetPos>, A
				/* client-server:post message */
				l_u8MotorControl = C_MOTOR_STOP;
    6f16:	6001      	lod	AL, #1
    6f18:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL

				l_u8OBDValveMechanicalError = (uint8)OBD_VALVE_MECHANICAL_OK;
    6f1c:	6400      	lod	YL, #0
    6f1e:	46d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, YL
    6f22:	5417      	ret	#24
			}
			else
			{
				l_u8OBDValveMechanicalError = OBD_VALVE_RANGE_BROKEN;
    6f24:	6002      	lod	AL, #2
    6f26:	42d8 00a0 	mov	0xa0 <_l_u8OBDValveMechanicalError>, AL
				l_u8ValueFaultFlag = (uint8)OBD_VALVE_RANGE_BROKEN;
    6f2a:	42d8 008b 	mov	0x8b <_l_u8ValueFaultFlag>, AL
    6f2e:	5417      	ret	#24

00006f30 <_handleSynchronizePosition>:
	}
}


void handleSynchronizePosition(void)
{
    6f30:	581b      	inc	S, #28
	Motor_RuntimeStatus motor_status;
	Motor_ControlParams motor_params;

	/* motor control type,signal to Motor Driver only once */
	if(l_u8MotorControl == C_MOTOR_STOP_ONLY)
    6f32:	62d8 0096 	lod	AL, 0x96 <_l_u8MotorControl>
    6f36:	8c02      	cmp	AL, #2
    6f38:	1d0b      	jne	0x6f50 <_handleSynchronizePosition+0x20>
	{
		/* stop stepper motor:immediate */
		motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6f3a:	7000      	lod	A, #0
    6f3c:	5211      	mov	[S-18], A
		motor_params.TgtPos = 0xFFFFu;
    6f3e:	78ff      	lod	Y, #-1
    6f40:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = 0xFFFFu;
    6f42:	5a0d      	mov	[S-14], Y
		motor_params.SpdRPM = 0xFFFFu;
    6f44:	5a07      	mov	[S-8], Y
		MotorDriverSetParams(motor_params);
    6f46:	580b      	inc	S, #12
    6f48:	7eef      	lod	X, S
    6f4a:	20f4      	add	X, #-12
    6f4c:	5e0d      	mov	[S-14], X
    6f4e:	001f      	jmp	0x6f8e <_handleSynchronizePosition+0x5e>
	}
	else if(l_u8MotorControl == C_MOTOR_STOP)
    6f50:	8c01      	cmp	AL, #1
    6f52:	1d02      	jne	0x6f58 <_handleSynchronizePosition+0x28>
	{
		motor_params.MotorCtrl = C_MOTOR_CTRL_STOP;
    6f54:	7000      	lod	A, #0
    6f56:	0003      	jmp	0x6f5e <_handleSynchronizePosition+0x2e>
		motor_params.TgtPos = l_u16PhysicalTargetPos;
		motor_params.ActPos = l_u16PhysicalActualPos;
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
		MotorDriverSetParams(motor_params);
	}
	else if(l_u8MotorControl == C_MOTOR_START)
    6f58:	8c03      	cmp	AL, #3
    6f5a:	1d08      	jne	0x6f6c <_handleSynchronizePosition+0x3c>
	{
		/* stop stepper motor:start with new parameters */
		motor_params.MotorCtrl = C_MOTOR_CTRL_START;
    6f5c:	7001      	lod	A, #1
    6f5e:	5211      	mov	[S-18], A
		motor_params.TgtPos = l_u16PhysicalTargetPos;
    6f60:	7ad8 00ee 	lod	Y, 0xee <_l_u16PhysicalTargetPos>
    6f64:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = l_u16PhysicalActualPos;
    6f66:	7ed8 00ec 	lod	X, 0xec <__data_end>
    6f6a:	0008      	jmp	0x6f7c <_handleSynchronizePosition+0x4c>
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
		MotorDriverSetParams(motor_params);
	}
	else if(l_u8MotorControl == C_MOTOR_START_ONLY)
    6f6c:	8c04      	cmp	AL, #4
    6f6e:	1d17      	jne	0x6f9e <_handleSynchronizePosition+0x6e>
	{
		/* only update target position */
		motor_params.MotorCtrl = C_MOTOR_CTRL_START;
    6f70:	7001      	lod	A, #1
    6f72:	5211      	mov	[S-18], A
		motor_params.TgtPos = l_u16PhysicalTargetPos;
    6f74:	7ad8 00ee 	lod	Y, 0xee <_l_u16PhysicalTargetPos>
    6f78:	5a0f      	mov	[S-16], Y
		motor_params.ActPos = 0xFFFF;
    6f7a:	7cff      	lod	X, #-1
    6f7c:	5e0d      	mov	[S-14], X
		motor_params.SpdRPM = s_CVRequestStruct.m_speed;
    6f7e:	72d8 0094 	lod	A, 0x94 <_s_CVRequestStruct+0x6>
    6f82:	5207      	mov	[S-8], A
		MotorDriverSetParams(motor_params);
    6f84:	580b      	inc	S, #12
    6f86:	7aef      	lod	Y, S
    6f88:	e0f4      	add	Y, #-12
    6f8a:	5a0d      	mov	[S-14], Y
    6f8c:	7ee6      	lod	X, Y
    6f8e:	7aef      	lod	Y, S
    6f90:	e0e2      	add	Y, #-30
    6f92:	54e6      	mov	Cx, #6
    6f94:	54c6      	movsw	[X++], [Y++]
    6f96:	1ffe      	djnz	Cx, 0x6f94 <_handleSynchronizePosition+0x64>
    6f98:	82db 886c 	callf	0x886c <_MotorDriverSetParams>
    6f9c:	5c0b      	dec	S, #12
	}
	else
	{

	}
	l_u8MotorControl = C_MOTOR_NONE;
    6f9e:	6000      	lod	AL, #0
    6fa0:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
	
		/* Motor Driver Status */
	MotorDriverGetStatus(&motor_status);
    6fa4:	72ef      	lod	A, S
    6fa6:	a0e4      	add	A, #-28
    6fa8:	82db 8890 	callf	0x8890 <_MotorDriverGetStatus>

	CmdArr[0] = motor_status.Fault.ST;
    6fac:	7219      	lod	A, [S-26]
    6fae:	44b2      	lsr	A, #2
    6fb0:	44b2      	lsr	A, #2
    6fb2:	44b2      	lsr	A, #2
    6fb4:	b40f      	and	A, #15
    6fb6:	42d8 007a 	mov	0x7a <__data_size>, AL
	CmdArr[1] = g_u16falg;
    6fba:	72d8 00d4 	lod	A, 0xd4 <_g_u16falg>
    6fbe:	42d8 007b 	mov	0x7b <__data_size+0x1>, AL
	CmdArr[2] = g_e8MotorDirectionCCW;
    6fc2:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    6fc4:	42d8 007c 	mov	0x7c <__data_size+0x2>, AL

	/* position */
	l_u16PhysicalActualPos = motor_status.ActPos;
    6fc8:	7a17      	lod	Y, [S-24]
    6fca:	5ad8 00ec 	mov	0xec <__data_end>, Y
	l_u8OBDValveElectricError &= (uint8)(~OBD_VALVE_ELECTRIC_INDET);			/* diagnostic has been done */
    6fce:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    6fd2:	4205      	mov	[S-6], AL
    6fd4:	947f      	and	AL, #127
    6fd6:	66e0      	lod	YL, AL
    6fd8:	42d8 009f 	mov	0x9f <_l_u8OBDValveElectricError>, AL
	/* temporary electric error is recoverable */
	if((motor_status.Fault.UV != 0u) || (motor_status.Fault.OV != 0u) ||
    6fdc:	6219      	lod	AL, [S-26]
    6fde:	4204      	mov	[S-5], AL
    6fe0:	9423      	and	AL, #35
    6fe2:	1903      	je	0x6fea <_handleSynchronizePosition+0xba>
		(motor_status.Fault.TS != 0u))
	{
		l_u8OBDValveElectricError |= (uint8)OBD_VALVE_ELECTRIC_TEMP;
    6fe4:	62e8      	lod	AL, YL
    6fe6:	8402      	or	AL, #2
    6fe8:	0002      	jmp	0x6fee <_handleSynchronizePosition+0xbe>
	}
	else
	{
		l_u8OBDValveElectricError &= (uint8)(~OBD_VALVE_ELECTRIC_TEMP);
    6fea:	6205      	lod	AL, [S-6]
    6fec:	947d      	and	AL, #125
    6fee:	42d8 009f 	mov	0x9f <_l_u8OBDValveElectricError>, AL
	}
	/* permenant electric error is cleared only by a starting a new initialization */
	if((motor_status.Fault.OPEN != 0u) || (motor_status.Fault.SHORT != 0u))
    6ff2:	6204      	lod	AL, [S-5]
    6ff4:	940c      	and	AL, #12
    6ff6:	1905      	je	0x7002 <_handleSynchronizePosition+0xd2>
	{
		l_u8OBDValveElectricError |= (uint8)OBD_VALVE_ELECTRIC_PERM;
    6ff8:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    6ffc:	8401      	or	AL, #1
    6ffe:	42d8 009f 	mov	0x9f <_l_u8OBDValveElectricError>, AL
	}
	/* stall occurence detected,dealing by valve application */
	if(motor_status.Fault.ST != 0u)
    7002:	7219      	lod	A, [S-26]
    7004:	b6da 03c0 	and	A, #960
    7008:	1904      	je	0x7012 <_handleSynchronizePosition+0xe2>
	{
		l_u8StallOcc = TRUE;
    700a:	6001      	lod	AL, #1
    700c:	42d8 00a1 	mov	0xa1 <_l_u8StallOcc>, AL
    7010:	0003      	jmp	0x7018 <_handleSynchronizePosition+0xe8>
	}
	else
	{
		l_u8StallOcc = FALSE;
    7012:	6400      	lod	YL, #0
    7014:	46d8 00a1 	mov	0xa1 <_l_u8StallOcc>, YL
	}

	uint16 temp;
	uint8 wait = Timer_IsExpired(FAULT_HOLD_TIMER);
    7018:	7008      	lod	A, #8
    701a:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    701e:	66e0      	lod	YL, AL
    7020:	5cf6      	usex	Y
	/* fault signal */
	/* NEXT:fault state logic,use indeterminate */
	if( (((l_u8OBDValveMechanicalError != OBD_VALVE_MECHANICAL_OK) && (l_u8OBDValveMechanicalError != OBD_VALVE_MECHANICAL_INDET)) ||
    7022:	62d8 00a0 	lod	AL, 0xa0 <_l_u8OBDValveMechanicalError>
    7026:	1902      	je	0x702c <_handleSynchronizePosition+0xfc>
    7028:	8c80      	cmp	AL, #-128
    702a:	1d08      	jne	0x703c <_handleSynchronizePosition+0x10c>
    702c:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    7030:	1902      	je	0x7036 <_handleSynchronizePosition+0x106>
    7032:	8c80      	cmp	AL, #-128
    7034:	1d03      	jne	0x703c <_handleSynchronizePosition+0x10c>
    7036:	62e8      	lod	AL, YL
    7038:	8c01      	cmp	AL, #1
    703a:	1d2a      	jne	0x7090 <_handleSynchronizePosition+0x160>
			((l_u8OBDValveElectricError != OBD_VALVE_ELECTRIC_OK) && (l_u8OBDValveElectricError != OBD_VALVE_ELECTRIC_INDET))) || (wait ==TRUE) )
	{
		if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) == 0x01)
    703c:	66d8 009f 	lod	YL, 0x9f <_l_u8OBDValveElectricError>
    7040:	72e6      	lod	A, Y
    7042:	b401      	and	A, #1
    7044:	190e      	je	0x7062 <_handleSynchronizePosition+0x132>
		{
			if(motor_status.Fault.SHORT != 0u)
    7046:	6219      	lod	AL, [S-26]
    7048:	4203      	mov	[S-4], AL
    704a:	9408      	and	AL, #8
    704c:	1902      	je	0x7052 <_handleSynchronizePosition+0x122>
			{
				l_u8OBDValveStatusFault = C_STATUS_FAULT_COIL_SHORT;
    704e:	6001      	lod	AL, #1
    7050:	0006      	jmp	0x705e <_handleSynchronizePosition+0x12e>
			}
			else if(motor_status.Fault.OPEN != 0u)
    7052:	6203      	lod	AL, [S-4]
    7054:	9404      	and	AL, #4
    7056:	1902      	je	0x705c <_handleSynchronizePosition+0x12c>
			{
				l_u8OBDValveStatusFault = C_STATUS_FAULT_COIL_OPEN;
    7058:	6002      	lod	AL, #2
    705a:	0001      	jmp	0x705e <_handleSynchronizePosition+0x12e>
			}
			else
			{
				l_u8OBDValveStatusFault = C_STATUS_NO_FAULT;
    705c:	6000      	lod	AL, #0
    705e:	42d8 008a 	mov	0x8a <_l_u8OBDValveStatusFault>, AL
		else
		{

		}

		if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_PERM) != 0x01)
    7062:	72e6      	lod	A, Y
    7064:	b401      	and	A, #1
    7066:	1d14      	jne	0x7090 <_handleSynchronizePosition+0x160>
		{
			if(motor_status.Fault.TS != 0u)
    7068:	6219      	lod	AL, [S-26]
    706a:	9420      	and	AL, #32
    706c:	1902      	je	0x7072 <_handleSynchronizePosition+0x142>
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_OVTEMP_SHUTDOWN;
    706e:	6003      	lod	AL, #3
    7070:	0009      	jmp	0x7084 <_handleSynchronizePosition+0x154>
			}
			else if(l_u8ValueFaultFlag == OBD_VALVE_RANGE_BLOCK)
    7072:	62d8 008b 	lod	AL, 0x8b <_l_u8ValueFaultFlag>
    7076:	8c01      	cmp	AL, #1
    7078:	1d02      	jne	0x707e <_handleSynchronizePosition+0x14e>
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_STALL;
    707a:	6005      	lod	AL, #5
    707c:	0003      	jmp	0x7084 <_handleSynchronizePosition+0x154>
			}
			else if(l_u8ValueFaultFlag == OBD_VALVE_RANGE_BROKEN)
    707e:	8c02      	cmp	AL, #2
    7080:	1d04      	jne	0x708a <_handleSynchronizePosition+0x15a>
			{
				l_u8OBDValveStatusFault = C_FAULT_STATE_BROKEN;
    7082:	6004      	lod	AL, #4
    7084:	42d8 008a 	mov	0x8a <_l_u8OBDValveStatusFault>, AL
    7088:	0003      	jmp	0x7090 <_handleSynchronizePosition+0x160>
			}
			else
			{
				l_u8OBDValveStatusFault = C_STATUS_NO_FAULT;
    708a:	6400      	lod	YL, #0
    708c:	46d8 008a 	mov	0x8a <_l_u8OBDValveStatusFault>, YL
		{

		}
	}

	if((l_u8OBDValveElectricError & (uint8)OBD_VALVE_ELECTRIC_TEMP) == 0x02)
    7090:	62d8 009f 	lod	AL, 0x9f <_l_u8OBDValveElectricError>
    7094:	b402      	and	A, #2
    7096:	190f      	je	0x70b6 <_handleSynchronizePosition+0x186>
	{
		if(motor_status.Fault.OV != 0u)
    7098:	6219      	lod	AL, [S-26]
    709a:	4202      	mov	[S-3], AL
    709c:	9402      	and	AL, #2
    709e:	1902      	je	0x70a4 <_handleSynchronizePosition+0x174>
		{
			l_u8OBDValveStatusVolt = C_VOLT_OVER;
    70a0:	6001      	lod	AL, #1
    70a2:	000a      	jmp	0x70b8 <_handleSynchronizePosition+0x188>
		}
		else if(motor_status.Fault.UV != 0u)
    70a4:	6202      	lod	AL, [S-3]
    70a6:	9401      	and	AL, #1
    70a8:	1902      	je	0x70ae <_handleSynchronizePosition+0x17e>
		{
			l_u8OBDValveStatusVolt = C_VOLT_UNDER;
    70aa:	6002      	lod	AL, #2
    70ac:	0005      	jmp	0x70b8 <_handleSynchronizePosition+0x188>
		}
		else
		{
			l_u8OBDValveStatusVolt = C_VOLT_OK;
    70ae:	6400      	lod	YL, #0
    70b0:	46d8 0089 	mov	0x89 <_l_u8OBDValveStatusVolt>, YL
    70b4:	0003      	jmp	0x70bc <_handleSynchronizePosition+0x18c>
		}
	}
	else
	{
		l_u8OBDValveStatusVolt = C_VOLT_OK;
    70b6:	6000      	lod	AL, #0
    70b8:	42d8 0089 	mov	0x89 <_l_u8OBDValveStatusVolt>, AL
	}

	if(motor_status.Fault.TW != 0u)
    70bc:	6219      	lod	AL, [S-26]
    70be:	9410      	and	AL, #16
    70c0:	1904      	je	0x70ca <_handleSynchronizePosition+0x19a>
	{
		l_u8OBDValveStatusOverTempWarn = C_TEMPERATURE_HIGH_WARNING;
    70c2:	6001      	lod	AL, #1
    70c4:	42d8 0088 	mov	0x88 <_l_u8OBDValveStatusOverTempWarn>, AL
    70c8:	0003      	jmp	0x70d0 <_handleSynchronizePosition+0x1a0>
	}
	else
	{
		l_u8OBDValveStatusOverTempWarn = C_TEMPERATURE_OK;
    70ca:	6400      	lod	YL, #0
    70cc:	46d8 0088 	mov	0x88 <_l_u8OBDValveStatusOverTempWarn>, YL
	}

	/* opening signal */
		/* GM spec. report real position valve opening */
		if(l_e8ValveState == C_STATE_INITIALIZED)
    70d0:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    70d4:	8c02      	cmp	AL, #2
    70d6:	1d0e      	jne	0x70f4 <_handleSynchronizePosition+0x1c4>
		{
			if(l_u16PhysicalActualPos <= C_VALVE_ZERO_POS)
    70d8:	72d8 00ec 	lod	A, 0xec <__data_end>
    70dc:	aeda 0190 	cmp	A, #400
    70e0:	1a09      	jule	0x70f4 <_handleSynchronizePosition+0x1c4>
			{
				temp = C_VALVE_FULL_CLOSE_LIN;
			}
			else if(l_u16PhysicalActualPos >= (C_VALVE_DEF_TRAVEL + C_VALVE_ZERO_POS))
    70e2:	aeda 090f 	cmp	A, #2319
    70e6:	1a03      	jule	0x70ee <_handleSynchronizePosition+0x1be>
			{
				temp = C_VALVE_DEF_TRAVEL;
    70e8:	72da 0780 	lod	A, #1920
    70ec:	0004      	jmp	0x70f6 <_handleSynchronizePosition+0x1c6>
			}
			else
			{
				temp = l_u16PhysicalActualPos - C_VALVE_ZERO_POS;
    70ee:	a2da fe70 	add	A, #65136
    70f2:	0001      	jmp	0x70f6 <_handleSynchronizePosition+0x1c6>
			}
		}
		else
		{
			temp = C_VALVE_RESPONSE_UNKONWNPOS;
    70f4:	7000      	lod	A, #0
		}
		l_u16OBDValveStatusPosition = (uint16)temp;
    70f6:	52d8 0086 	mov	0x86 <_l_u16OBDValveStatusPosition>, A

	/* motor status */
	/* application provider-consumer interface */
	MotorDriverGetStatus(&motor_status);
    70fa:	72ef      	lod	A, S
    70fc:	a0e4      	add	A, #-28
    70fe:	82db 8890 	callf	0x8890 <_MotorDriverGetStatus>
	/* move in process signal */
	if(motor_status.Mode != (uint8)MSM_STOP)
    7102:	621b      	lod	AL, [S-28]
    7104:	190e      	je	0x7122 <_handleSynchronizePosition+0x1f2>
	{
		l_u8OBDValveStatusMove = C_STATUS_MOVE_ACTIVE;
    7106:	6001      	lod	AL, #1
    7108:	42d8 0085 	mov	0x85 <_l_u8OBDValveStatusMove>, AL
		/* torque signal */
		l_u8OBDValveStatusSpeedLevel = (uint8)((s_CVRequestStruct.m_torque / 10u) + 1u);	/* convert physical value to signal */
    710c:	72d8 0092 	lod	A, 0x92 <_s_CVRequestStruct+0x4>
    7110:	4822 cccd 	mulu	YA, A, #52429
    7114:	72e6      	lod	A, Y
    7116:	44b2      	lsr	A, #2
    7118:	4432      	lsr	A
    711a:	8001      	add	AL, #1
    711c:	42d8 0084 	mov	0x84 <_l_u8OBDValveStatusSpeedLevel>, AL
    7120:	541d      	ret	#30
	}
	else
	{
		l_u8OBDValveStatusMove = C_STATUS_MOVE_IDLE;
    7122:	6000      	lod	AL, #0
    7124:	42d8 0085 	mov	0x85 <_l_u8OBDValveStatusMove>, AL
    7128:	541d      	ret	#30

0000712a <_Valve_GotoSleep>:
		}
	}
}

void Valve_GotoSleep(void)
{
    712a:	5805      	inc	S, #6
	uint16 cv_nvm[3];
	/* stop MCU */
	MLX315_GotoSleep();
    712c:	113c      	call	0x73a6 <_MLX315_GotoSleep>
    712e:	5407      	ret	#8

00007130 <_handleSleepEvent>:
		l_u8EmrunStatus = 0u;
	}
}

void handleSleepEvent(void)
{
    7130:	5809      	inc	S, #10
	Motor_RuntimeStatus motor_status;
	
	if(s_CVRequestStruct.m_request == (uint16)C_MOTOR_REQUEST_SLEEP)
    7132:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    7136:	ac06      	cmp	A, #6
    7138:	1d0b      	jne	0x7150 <_handleSleepEvent+0x20>
	{
		MotorDriverGetStatus(&motor_status);
    713a:	72ef      	lod	A, S
    713c:	a0f6      	add	A, #-10
    713e:	82db 8890 	callf	0x8890 <_MotorDriverGetStatus>
		/* conditions:
		  * 1) target position equals current position(motor stop/degrade) 
		  * 2) sleep request
		  */
		if(motor_status.Mode != (uint8)MSM_STOP)
    7142:	6209      	lod	AL, [S-10]
    7144:	1904      	je	0x714e <_handleSleepEvent+0x1e>
		{
			/* stop motor first before entering sleep:immediate */
			l_u8MotorControl = C_MOTOR_STOP_ONLY;
    7146:	6002      	lod	AL, #2
    7148:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
    714c:	540b      	ret	#12
		}
		else
		{
			Valve_GotoSleep();
    714e:	17ed      	call	0x712a <_Valve_GotoSleep>
    7150:	540b      	ret	#12

00007152 <_handleEmergencyRunEvent>:
//		l_u8OBDValveStatusSpeedLevel = C_CTRL_TORQUE_NO;
	}
}

void handleEmergencyRunEvent(void)
{
    7152:	5815      	inc	S, #22
	Motor_RuntimeStatus motor_status;
	Motor_ControlParams motor_params;
	
	if(s_CVRequestStruct.m_request == C_MOTOR_REQUEST_EMRUN)
    7154:	72d8 008e 	lod	A, 0x8e <_s_CVRequestStruct>
    7158:	ac07      	cmp	A, #7
    715a:	1d0b      	jne	0x7172 <_handleEmergencyRunEvent+0x20>
	{
#if _SUPPORT_BUSTIMEOUT_SLEEP
		/* query motor state */
		MotorDriverGetStatus(&motor_status);
    715c:	72ef      	lod	A, S
    715e:	a0ea      	add	A, #-22
    7160:	82db 8890 	callf	0x8890 <_MotorDriverGetStatus>
		l_u8MotorControl = C_MOTOR_STOP_ONLY;
    7164:	6002      	lod	AL, #2
    7166:	42d8 0096 	mov	0x96 <_l_u8MotorControl>, AL
		if(motor_status.Mode == (uint8)MSM_STOP)
    716a:	6215      	lod	AL, [S-22]
    716c:	1d05      	jne	0x7178 <_handleEmergencyRunEvent+0x26>
		{
			Valve_GotoSleep();
    716e:	17dd      	call	0x712a <_Valve_GotoSleep>
    7170:	5417      	ret	#24
#endif
	}
	else
	{
		/* emergency run should be triggered only once */
		l_u8EmrunStatus = 0u;
    7172:	6000      	lod	AL, #0
    7174:	42d8 0097 	mov	0x97 <_l_u8EmrunStatus>, AL
    7178:	5417      	ret	#24

0000717a <_App_CoolantValveSM>:
	
}

void App_CoolantValveSM(void)
{
	switch(l_e8ValveState)
    717a:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    717e:	5cf2      	usex	A
    7180:	ac01      	cmp	A, #1
    7182:	1909      	je	0x7196 <_App_CoolantValveSM+0x1c>
    7184:	1f03      	jsg	0x718c <_App_CoolantValveSM+0x12>
    7186:	ac00      	cmp	A, #0
    7188:	1904      	je	0x7192 <_App_CoolantValveSM+0x18>
    718a:	000a      	jmp	0x71a0 <_App_CoolantValveSM+0x26>
    718c:	ac02      	cmp	A, #2
    718e:	1905      	je	0x719a <_App_CoolantValveSM+0x20>
    7190:	0007      	jmp	0x71a0 <_App_CoolantValveSM+0x26>
    {
    case C_STATE_UNINITIALIZED:
		/* 1)request calibration;2)Motor not in degrade mode? */
		handleStartInitialize();
    7192:	165f      	call	0x6e52 <_handleStartInitialize>
		break;
    7194:	0008      	jmp	0x71a6 <_App_CoolantValveSM+0x2c>
	case C_STATE_INITIALIZING:
		handleInitiliazeProcess();
    7196:	15ea      	call	0x6d6c <_handleInitiliazeProcess>
		break;
    7198:	0006      	jmp	0x71a6 <_App_CoolantValveSM+0x2c>
	case C_STATE_INITIALIZED:
		/* handle master normal start motor request */
		handleOpeningPosition();
    719a:	1599      	call	0x6cce <_handleOpeningPosition>
#if _SUPPORT_STALLDET
		/* stall endstop check */        
		/* 1)endstop broken or valve over range; 
	  	  * 2)endstop unreachable or stall(valve)  
	  	  */
		handleEndstopCheck();
    719c:	167a      	call	0x6e92 <_handleEndstopCheck>
#endif
		break;
    719e:	0003      	jmp	0x71a6 <_App_CoolantValveSM+0x2c>
	default:
		l_e8ValveState = (uint8)C_STATE_UNINITIALIZED;
    71a0:	6000      	lod	AL, #0
    71a2:	42d8 00a2 	mov	0xa2 <_l_e8ValveState>, AL
		break;
    }
	/* synchronize motor position to valve physical position */
	handleSynchronizePosition();
    71a6:	16c4      	call	0x6f30 <_handleSynchronizePosition>
	/* state transition */
	handleStateTransition();
    71a8:	15ad      	call	0x6d04 <_handleStateTransition>
	/* handle event */
	/* bus time out:emergency run */
	handleEmergencyRunEvent();
    71aa:	17d3      	call	0x7152 <_handleEmergencyRunEvent>
	/* goto sleep command */
	handleSleepEvent();
    71ac:	17c1      	call	0x7130 <_handleSleepEvent>
    71ae:	5401      	ret

000071b0 <_HandleActCfrCtrl>:
	MLX315_GotoSleep();
}

/* Event handler */
void HandleActCfrCtrl(const ACT_CFR_CTRL *pCfrCtrl)
{	
    71b0:	5803      	inc	S, #4
    71b2:	7ae2      	lod	Y, A
	uint16 u16TempPos;

	/* move enable and torque defined transmit */
	u16TempPos = (uint16)((uint8)pCfrCtrl->PositionRequest_H * 256 + (uint8)pCfrCtrl->PositionRequest_L);
    71b4:	6af1      	lod	AH, [Y+1]
    71b6:	6000      	lod	AL, #0
    71b8:	7ee2      	lod	X, A
    71ba:	62f0      	lod	AL, [Y]
    71bc:	5cf2      	usex	A
    71be:	22e2      	add	X, A
	targetPos = u16TempPos;
    71c0:	5ed8 0082 	mov	0x82 <_targetPos>, X

	if((pCfrCtrl->EnableRequest == C_CTRL_MOVE_ENA))	//torque is valid no matter which value qiang
    71c4:	62f2      	lod	AL, [Y+2]
    71c6:	4203      	mov	[S-4], AL
    71c8:	9401      	and	AL, #1
    71ca:	1925      	je	0x7216 <_HandleActCfrCtrl+0x66>
	{
		if(u16TempPos <= C_VALVE_DEF_TRAVEL)	//position commend is valid;
    71cc:	2eda 0780 	cmp	X, #1920
    71d0:	1e2b      	jug	0x7228 <_HandleActCfrCtrl+0x78>
		{
			if(pCfrCtrl->InitRequest == C_CTRL_INIT_ENA)
    71d2:	6203      	lod	AL, [S-4]
    71d4:	940e      	and	AL, #14
    71d6:	4201      	mov	[S-2], AL
    71d8:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    71dc:	4202      	mov	[S-3], AL
    71de:	6201      	lod	AL, [S-2]
    71e0:	8c02      	cmp	AL, #2
    71e2:	1d14      	jne	0x720c <_HandleActCfrCtrl+0x5c>
			{
				if((l_e8ValveState == C_STATE_UNINITIALIZED) || (l_e8ValveState == C_STATE_INITIALIZING))
    71e4:	6202      	lod	AL, [S-3]
    71e6:	8c01      	cmp	AL, #1
    71e8:	1e07      	jug	0x71f8 <_HandleActCfrCtrl+0x48>
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_CALIBRATION;
    71ea:	7005      	lod	A, #5
    71ec:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
					s_CVRequestStruct.m_opening = 0;
    71f0:	7000      	lod	A, #0
    71f2:	52d8 0090 	mov	0x90 <_s_CVRequestStruct+0x2>, A
    71f6:	0005      	jmp	0x7202 <_HandleActCfrCtrl+0x52>
					s_CVRequestStruct.m_speed = NVRAM_SPEED1;		//speed is fixed
				}
				else
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_START;
    71f8:	7003      	lod	A, #3
    71fa:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
					s_CVRequestStruct.m_opening = u16TempPos;
    71fe:	5ed8 0090 	mov	0x90 <_s_CVRequestStruct+0x2>, X
					s_CVRequestStruct.m_speed = NVRAM_SPEED1;
    7202:	72da 00c8 	lod	A, #200
    7206:	52d8 0094 	mov	0x94 <_s_CVRequestStruct+0x6>, A
    720a:	5405      	ret	#6
				}
			}
			else
			{
				if((l_e8ValveState == C_STATE_UNINITIALIZED) || (l_e8ValveState == C_STATE_INITIALIZING))
    720c:	6202      	lod	AL, [S-3]
    720e:	8c01      	cmp	AL, #1
    7210:	1e73      	jug	0x71f8 <_HandleActCfrCtrl+0x48>
				{
					s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    7212:	7001      	lod	A, #1
    7214:	07f2      	jmp	0x71fa <_HandleActCfrCtrl+0x4a>
	}
	else
	{
		/* The actuator shall treat torque values of Not defined and Not used (0xC-0xF) the same way as No Torque Value Requested */
		/* motor request stop */
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    7216:	7001      	lod	A, #1
    7218:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
		s_CVRequestStruct.m_opening = u16TempPos;
    721c:	5ed8 0090 	mov	0x90 <_s_CVRequestStruct+0x2>, X
//		s_CVRequestStruct.m_torque = C_CTRL_TORQUE_NO;
		s_CVRequestStruct.m_speed = NVRAM_SPEED1;
    7220:	72da 00c8 	lod	A, #200
    7224:	52d8 0094 	mov	0x94 <_s_CVRequestStruct+0x6>, A
    7228:	5405      	ret	#6

0000722a <_HandleActRfrSta>:
	}
}


void HandleActRfrSta(ACT_RFR_STA *pRfrSta)
{
    722a:	5805      	inc	S, #6
    722c:	7ee2      	lod	X, A

	/* NEXT  fault signal  */
	pRfrSta->CurrentInitState = l_e8ValveState;
    722e:	62d8 00a2 	lod	AL, 0xa2 <_l_e8ValveState>
    7232:	9403      	and	AL, #3
    7234:	4420      	asl	AL
    7236:	4205      	mov	[S-6], AL
    7238:	62f8      	lod	AL, [X]
    723a:	94f9      	and	AL, #-7
    723c:	66e0      	lod	YL, AL
    723e:	6205      	lod	AL, [S-6]
    7240:	86e8      	or	AL, YL
    7242:	66e0      	lod	YL, AL
    7244:	42f8      	mov	[X], AL
	pRfrSta->RunState = l_u8OBDValveStatusMove;
    7246:	62d8 0085 	lod	AL, 0x85 <_l_u8OBDValveStatusMove>
    724a:	9401      	and	AL, #1
    724c:	44a0      	asl	AL, #2
    724e:	4420      	asl	AL
    7250:	4204      	mov	[S-5], AL
    7252:	62e8      	lod	AL, YL
    7254:	94f7      	and	AL, #-9
    7256:	66e0      	lod	YL, AL
    7258:	6204      	lod	AL, [S-5]
    725a:	86e8      	or	AL, YL
    725c:	66e0      	lod	YL, AL
    725e:	42f8      	mov	[X], AL
	pRfrSta->FaultState = l_u8OBDValveStatusFault;
    7260:	62d8 008a 	lod	AL, 0x8a <_l_u8OBDValveStatusFault>
    7264:	44a0      	asl	AL, #2
    7266:	44a0      	asl	AL, #2
    7268:	4202      	mov	[S-3], AL
    726a:	62e8      	lod	AL, YL
    726c:	940f      	and	AL, #15
    726e:	8602      	or	AL, [S-3]
    7270:	42f8      	mov	[X], AL
	pRfrSta->byVoltStat = l_u8OBDValveStatusVolt;
    7272:	62d8 0089 	lod	AL, 0x89 <_l_u8OBDValveStatusVolt>
    7276:	9403      	and	AL, #3
    7278:	4201      	mov	[S-2], AL
    727a:	62f9      	lod	AL, [X+1]
    727c:	94fc      	and	AL, #-4
    727e:	66e0      	lod	YL, AL
    7280:	6201      	lod	AL, [S-2]
    7282:	86e8      	or	AL, YL
    7284:	66e0      	lod	YL, AL
    7286:	42f9      	mov	[X+1], AL
	pRfrSta->OverTempWarning = l_u8OBDValveStatusOverTempWarn;
    7288:	62d8 0088 	lod	AL, 0x88 <_l_u8OBDValveStatusOverTempWarn>
    728c:	9403      	and	AL, #3
    728e:	44a0      	asl	AL, #2
    7290:	4200      	mov	[S-1], AL
    7292:	62e8      	lod	AL, YL
    7294:	94f3      	and	AL, #-13
    7296:	8600      	or	AL, [S-1]
    7298:	42f9      	mov	[X+1], AL
	pRfrSta->PositionFbk_L = (uint8)(l_u16OBDValveStatusPosition & 0x00FF);
    729a:	72d8 0086 	lod	A, 0x86 <_l_u16OBDValveStatusPosition>
    729e:	42fa      	mov	[X+2], AL
	pRfrSta->PositionFbk_H = (uint8)((l_u16OBDValveStatusPosition & 0xFF00) >> 8);
    72a0:	4afb      	mov	[X+3], AH
	pRfrSta->byReserved4 = (uint8)g_i16ChipTemperature;
    72a2:	72d8 00b2 	lod	A, 0xb2 <_g_i16ChipTemperature>
    72a6:	42fc      	mov	[X+4], AL
    72a8:	5407      	ret	#8

000072aa <_HandleNMReq>:
}

/* handle network management event:callback */
void HandleNMReq(uint8 reason)
{
	if(reason == C_ML_REASON_CMD)
    72aa:	8c01      	cmp	AL, #1
    72ac:	1d02      	jne	0x72b2 <_HandleNMReq+0x8>
    {
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_SLEEP;
    72ae:	7006      	lod	A, #6
    72b0:	0003      	jmp	0x72b8 <_HandleNMReq+0xe>
    }
	else if(reason == C_ML_REASON_TIMEOUT)
    72b2:	8c02      	cmp	AL, #2
    72b4:	1d04      	jne	0x72be <_HandleNMReq+0x14>
	{
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_EMRUN;
    72b6:	7007      	lod	A, #7
    72b8:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
    72bc:	5401      	ret
	}
	else if(reason == C_ML_REASON_WAKEUP)
    72be:	8c04      	cmp	AL, #4
    72c0:	1d03      	jne	0x72c8 <_HandleNMReq+0x1e>
	{
		s_CVRequestStruct.m_request = C_MOTOR_REQUEST_STOP;
    72c2:	7001      	lod	A, #1
    72c4:	52d8 008e 	mov	0x8e <_s_CVRequestStruct>, A
    72c8:	5401      	ret

000072ca <_MLX315_SystemInit>:
#if WATCHDOG == DISABLED
	WD_CTRL = 0u;															/* Disable digital Watch-dog */
	AWD_CTRL = 0x8000u;														/* Disable analogue Watch-dog */
#endif /* WATCHDOG == DISABLED */
#if WATCHDOG == ENABLED
	WD_T = WatchDog_PeriodOf100ms;											/* Initialise the (Digital) watch-dog comparator to 100ms */
    72ca:	60c3      	lod	AL, #-61
    72cc:	4282      	mov	io:0x2 <_LinCmnd>, AL
	WD_CTRL = WatchDog_ModeTimer;											/* Define the mode and start the watchdog */
    72ce:	6012      	lod	AL, #18
    72d0:	4283      	mov	io:0x3 <_LinCmnd+0x1>, AL
 *
 *****************************************************************************
 */
__MLX_TEXT__  static INLINE void awdg_init (uint8 prescaler, uint8 timer)
{
    AWD_CTRL = ((uint16)(prescaler & 3) << 8) | timer;
    72d2:	72da 019c 	lod	A, #412
    72d6:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
#endif /* WATCHDOG == ENABLED */

	/* I/O ports  */
#if MCU_ASSP_MODE
	/* IO[5]:HALL, IO[4]:GND-HW connected, IO[3:0]:debug purpose,PMOS not disabled */
	ANA_OUTL |= ASSP;														/* ASSP-mode */
    72d8:	72d8 28d4 	lod	A, 0x28d4 <__io__+0xd4>
    72dc:	a401      	or	A, #1
    72de:	52d8 28d4 	mov	0x28d4 <__io__+0xd4>, A
	
	ANA_OUTM = (IO5_OUTCFG_SOFT | IO4_OUTCFG_SOFT | IO3_OUTCFG_SOFT | 
    72e2:	70ff      	lod	A, #-1
    72e4:	52d8 28d6 	mov	0x28d6 <__io__+0xd6>, A
				IO2_OUTCFG_SOFT | IO1_OUTCFG_SOFT | IO0_OUTCFG_SOFT);
	ANA_OUTN = ((uint16)0u << 5u) | ((uint16)0u << 4u) | ((uint16)0u << 3u) | 
    72e8:	7000      	lod	A, #0
    72ea:	52d8 28d8 	mov	0x28d8 <__io__+0xd8>, A
				((uint16)0u << 2u) | ((uint16)0u << 1u) | ((uint16)0u << 0u);
	IO_DEB = ( IO5_DEBOUNCE_OFF | IO4_DEBOUNCE_OFF | IO3_DEBOUNCE_OFF | 
    72ee:	52d8 28c0 	mov	0x28c0 <__io__+0xc0>, A
				IO2_DEBOUNCE_OFF | IO1_DEBOUNCE_OFF | IO0_DEBOUNCE_OFF);
	ANA_OUTF = ( IO3_ENA | IO2_ENA | IO1_ENA | IO0_ENA | 
    72f2:	72da 300f 	lod	A, #12303
    72f6:	52d8 204e 	mov	0x204e <__ep__+0x104e>, A

#if _SUPPORT_TESTMODE_OFF
	/* ******************************************** */
	/* *** D. (Optional) Chip test-mode disable *** */
	/* ******************************************** */
	CONTROL |= OUTA_WE;														/* Grant access to ANA_OUTx registers */
    72fa:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    72fe:	8408      	or	AL, #8
    7300:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	ANA_OUTA |= TEST_MODE_DIS;												/* Disable test-mode */
    7304:	72d8 201c 	lod	A, 0x201c <__ep__+0x101c>
    7308:	a6da 0080 	or	A, #128
    730c:	52d8 201c 	mov	0x201c <__ep__+0x101c>, A
	CONTROL &= ~OUTA_WE;
    7310:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7314:	94f7      	and	AL, #-9
    7316:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
#endif /* MCU_ASSP_MODE */
#endif /* _DEBUG_SPI */
#endif /* _DEBUG */

	/* Disable Driver */
	DRVCFG_DIS_UVWT();
    731a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    731e:	b6da fe00 	and	A, #65024
    7322:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

	/* Interrupts */
	/* System Tick Timer - Core Timer  */
	PRIO &= ~((uint16)3u << 0u) ;												/* Set CoreTimer priority to 6 (3..6) */
    7326:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    732a:	b4fc      	and	A, #-4
    732c:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(6u - 3u) << 0u);
    7330:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7334:	a403      	or	A, #3
    7336:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_TIMER_IT;
    733a:	7020      	lod	A, #32
    733c:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_TIMER_IT;														/* Enable Timer interrupt */
    7340:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7344:	a420      	or	A, #32
    7346:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	
	/* BLDC motor Commutation/Stepper timer */
	XI0_PEND = CLR_T1_INT4;														/* Clear (potentially) Timer1 second level interrupts (T1_INT4) */
    734a:	7040      	lod	A, #64
    734c:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
	XI0_MASK |= EN_T1_INT4;														/* Enable Timer1, CompareB (T1_INT4) */
    7350:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    7354:	a440      	or	A, #64
    7356:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	PRIO &= ~((uint16)3u << 6u);												/* Set Timer1 priority to 4 (3..6) */
    735a:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    735e:	b6da ff3f 	and	A, #65343
    7362:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(4u - 3u) << 6u);									
    7366:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    736a:	a440      	or	A, #64
    736c:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PEND = CLR_EXT0_IT;
    7370:	72da 0100 	lod	A, #256
    7374:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT0_IT;	
    7378:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    737c:	a6da 0100 	or	A, #256
    7380:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

	/* HALL,diagnostic(OVT,OVC,UV,OV) interrupt */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */							/* EXT4_IT Priority: 3 (3..6) */
	PRIO &= ~((uint16)3u << 14u);												/* EXT4_IT Priority: 3 (3..6) */
    7384:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7388:	b6da 3fff 	and	A, #16383
    738c:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(3u - 3u) << 14u);
	PEND = CLR_EXT4_IT;
    7390:	72da 1000 	lod	A, #4096
    7394:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    7398:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    739c:	a6da 1000 	or	A, #4096
    73a0:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
    73a4:	5401      	ret

000073a6 <_MLX315_GotoSleep>:
	 * Wake up is done by resetting the chip. The source of the wake up can be found in ANA_INB.
	 * Note: In case between MLX4_HALT and MLX16_HALT a LIN-bus event happens, the chip will not
	 * enter SLEEP but HALT-mode. To allow a LIN-wakeup, the Analogue Watchdog is set to minimum
	 * period of 100us to allow a chip reset.
	 */
	IO_WU = 0;														/* Disable IO3 wake up */
    73a6:	7000      	lod	A, #0
    73a8:	52d8 28c8 	mov	0x28c8 <__io__+0xc8>, A
	ANA_OUTG &= 0xFF9Eu;											/* Clear Internal WU delay and DIS_GTSM */
    73ac:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    73b0:	b49e      	and	A, #-98
    73b2:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
	MASK = 0;
    73b6:	7000      	lod	A, #0
    73b8:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* Go into sleep/halt */
	AWD_CTRL = ((uint16)3u << 8u) | 1u;								/* Set 1:1 prescaler and minimal period; AWD timeout will be 100 us (MMP140813-2) */
    73bc:	72da 0301 	lod	A, #769
    73c0:	529a      	mov	io:0x1a <_g_u8ControlFrameID>, A
	MLX4_RESET();
    73c2:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    73c6:	94fe      	and	AL, #-2
    73c8:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	MLX16_HALT();													/* See MELEXIS doc */
    73cc:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    73d0:	8402      	or	AL, #2
    73d2:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
    73d6:	0000      	nop
	/* Chip should reset upon LIN bus changes */
	/* We should never make it to here, as a backup we add a chip reset */
	MLX16_RESET();
    73d8:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    73dc:	5401      	ret

000073de <_System_BackgroundTaskInit>:
void System_BackgroundTaskInit(void)
{
  /* *************************************************** */
	/* *** A. Initialise background schedule (Task-ID) *** */
	/* *************************************************** */
	l_u8BackgroundSchedulerTaskID = 0u;
    73de:	6000      	lod	AL, #0
    73e0:	42d8 00a3 	mov	0xa3 <_l_u8BackgroundSchedulerTaskID>, AL
    73e4:	5401      	ret

000073e6 <_FlashBackgroundTest>:
 *				To avoid huge delay, the calculation is split into segments of u16Size
 *				16-bits words. When reaching the Flash-end, the checksum is compared
 *				against first calculated Flash CRC.
 * ****************************************************************************	*/
uint16 FlashBackgroundTest( uint16 u16Size)
{
    73e6:	5807      	inc	S, #8
    73e8:	7ee2      	lod	X, A
	uint16 u16Result = C_FLASH_CRC_CALCULATING;
    73ea:	4cd3      	swap	D
    73ec:	48cf      	asl	D, #16
    73ee:	4c0a 0002 	addu	D, #2
	static uint16 *pu16Segment = (uint16 *) FLASH_START_ADDR;
	static uint16 u16FlashCRC = 0u;

	if ( u16Size == 0u )
    73f2:	ac00      	cmp	A, #0
    73f4:	1d06      	jne	0x7402 <_FlashBackgroundTest+0x1c>
	{
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    73f6:	72da 4000 	lod	A, #16384
    73fa:	52d8 00a6 	mov	0xa6 <_l_u8RamPreError+0x2>, A
		return ( u16Result );
    73fe:	7002      	lod	A, #2
    7400:	5409      	ret	#10
	}
	if ( pu16Segment == (uint16 *) FLASH_START_ADDR )
    7402:	7ad8 00a6 	lod	Y, 0xa6 <_l_u8RamPreError+0x2>
    7406:	eeda 4000 	cmp	Y, #16384
    740a:	1d03      	jne	0x7412 <_FlashBackgroundTest+0x2c>
	{
		u16FlashCRC = 0xFFFFu;													/* Initialise the CRC preset with 0xFFFF */
    740c:	70ff      	lod	A, #-1
    740e:	52d8 00a8 	mov	0xa8 <_l_u8RamPreError+0x4>, A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
    7412:	72e6      	lod	A, Y
    7414:	a2ee      	add	A, X
    7416:	aeda c000 	cmp	A, #49152
    741a:	1a04      	jule	0x7424 <_FlashBackgroundTest+0x3e>
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
    741c:	72da c000 	lod	A, #49152
    7420:	7ee2      	lod	X, A
    7422:	2ae6      	sub	X, Y
	}
	for ( ; u16Size > 0u; u16Size-- )
    7424:	2c00      	cmp	X, #0
    7426:	1928      	je	0x7478 <_FlashBackgroundTest+0x92>
    7428:	5a03      	mov	[S-4], Y
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
    742a:	7a03      	lod	Y, [S-4]
    742c:	eeda bf4e 	cmp	Y, #48974
    7430:	191d      	je	0x746c <_FlashBackgroundTest+0x86>
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
    7432:	72f0      	lod	A, [Y]
    7434:	5205      	mov	[S-6], A
			for ( u8Count = 16u; u8Count > 0u; u8Count-- )
    7436:	7810      	lod	Y, #16
    7438:	5a07      	mov	[S-8], Y
    743a:	7ad8 00a8 	lod	Y, 0xa8 <_l_u8RamPreError+0x4>
			{
				uint16 u16XorFlag = u16FlashCRC & 0x8000U;
    743e:	72e6      	lod	A, Y
    7440:	b6da 8000 	and	A, #32768
    7444:	5201      	mov	[S-2], A
				u16FlashCRC = (u16FlashCRC << 1u);
    7446:	4426      	asl	Y
				if ( (u16Data & 0x8000u) != 0u )
    7448:	7205      	lod	A, [S-6]
    744a:	ac00      	cmp	A, #0
    744c:	1e81      	jsge	0x7450 <_FlashBackgroundTest+0x6a>
				{
					u16FlashCRC++;
    744e:	e001      	add	Y, #1
				}
				if ( u16XorFlag != 0u)
    7450:	7201      	lod	A, [S-2]
    7452:	1902      	je	0x7458 <_FlashBackgroundTest+0x72>
				{
					u16FlashCRC ^= POLY;
    7454:	feda 1021 	xor	Y, #4129
				}
				u16Data <<= 1u;
    7458:	7205      	lod	A, [S-6]
    745a:	4422      	asl	A
    745c:	5205      	mov	[S-6], A
	{
		if ( pu16Segment != (uint16 *) FLASH_CRC_ADDR )
		{
			uint8 u8Count;
			uint16 u16Data = *pu16Segment;
			for ( u8Count = 16u; u8Count > 0u; u8Count-- )
    745e:	6207      	lod	AL, [S-8]
    7460:	80ff      	add	AL, #-1
    7462:	5cf2      	usex	A
    7464:	5207      	mov	[S-8], A
    7466:	1d6b      	jne	0x743e <_FlashBackgroundTest+0x58>
    7468:	5ad8 00a8 	mov	0xa8 <_l_u8RamPreError+0x4>, Y
					u16FlashCRC ^= POLY;
				}
				u16Data <<= 1u;
			}
		}
		pu16Segment++;
    746c:	7203      	lod	A, [S-4]
    746e:	a002      	add	A, #2
    7470:	5203      	mov	[S-4], A
	}
	if ( ((uint16) pu16Segment + u16Size) > FLASH_END_ADDR )
	{
		u16Size = (FLASH_END_ADDR - (uint16) pu16Segment);
	}
	for ( ; u16Size > 0u; u16Size-- )
    7472:	1bdb      	djnz	X, 0x742a <_FlashBackgroundTest+0x44>
    7474:	52d8 00a6 	mov	0xa6 <_l_u8RamPreError+0x2>, A
			}
		}
		pu16Segment++;
	}

	if ( (uint16) pu16Segment >= FLASH_END_ADDR )
    7478:	72d8 00a6 	lod	A, 0xa6 <_l_u8RamPreError+0x2>
    747c:	aeda bfff 	cmp	A, #49151
    7480:	1a14      	jule	0x74aa <_FlashBackgroundTest+0xc4>
	{
		/* CRC fully calculated, check values */
		pu16Segment = (uint16 *) FLASH_START_ADDR;
    7482:	7ada 4000 	lod	Y, #16384
    7486:	5ad8 00a6 	mov	0xa6 <_l_u8RamPreError+0x2>, Y
		if ( *(uint16 *) FLASH_CRC_ADDR != 0u )									/* Flash/ROM Checksum programmed? */
    748a:	7ada bf4e 	lod	Y, #48974
    748e:	72f0      	lod	A, [Y]
    7490:	190c      	je	0x74aa <_FlashBackgroundTest+0xc4>
		{
			if ( *(uint16 *) FLASH_CRC_ADDR != u16FlashCRC )
    7492:	aed8 00a8 	cmp	A, 0xa8 <_l_u8RamPreError+0x4>
    7496:	1905      	je	0x74a2 <_FlashBackgroundTest+0xbc>
			{
				u16Result = C_FLASH_CRC_FAILED;
    7498:	4cd3      	swap	D
    749a:	48cf      	asl	D, #16
    749c:	4c0a 0000 	addu	D, #0
    74a0:	0004      	jmp	0x74aa <_FlashBackgroundTest+0xc4>
			}
			else
			{
				u16Result = C_FLASH_CRC_OK;
    74a2:	4cd3      	swap	D
    74a4:	48cf      	asl	D, #16
    74a6:	4c0a 0001 	addu	D, #1
			}
		}
	}

	return ( u16Result );
    74aa:	4c88      	mov	A, DL

} /* End of FlashBackgroundTest() */
    74ac:	5409      	ret	#10

000074ae <_System_BackgroundMemoryTest>:
			l_u8RamPreError = FALSE;										/* Error is gone (caused by wrong NVRAM shadow-RAM) */
		}
	}
#endif	/* (MOTOR_PARAMS == MP_NVRAM) || (VALVE_PARAMS == VP_NVRAM) */
	/* Flash CRC runtime check,schedule ID:[1-127],[129-255] */
	if((l_u8BackgroundSchedulerTaskID != 0u) && (l_u8BackgroundSchedulerTaskID != 128u))
    74ae:	62d8 00a3 	lod	AL, 0xa3 <_l_u8BackgroundSchedulerTaskID>
    74b2:	1919      	je	0x74e6 <_System_BackgroundMemoryTest+0x38>
    74b4:	8c80      	cmp	AL, #-128
    74b6:	1917      	je	0x74e6 <_System_BackgroundMemoryTest+0x38>
	{
		if ( (FL_CTRL0 & FL_DETECT) != 0u )									/* MMP150603-2 */
    74b8:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    74bc:	b401      	and	A, #1
    74be:	1913      	je	0x74e6 <_System_BackgroundMemoryTest+0x38>
		{
			if ( FlashBackgroundTest( C_FLASH_SEGMENT_SZ) == (uint16)C_FLASH_CRC_FAILED )	/* Check Flash/ROM Memory Checksum (max. 250us) */
    74c0:	7004      	lod	A, #4
    74c2:	1791      	call	0x73e6 <_FlashBackgroundTest>
    74c4:	ac00      	cmp	A, #0
    74c6:	1d0f      	jne	0x74e6 <_System_BackgroundMemoryTest+0x38>
			{
				SetLastError( (uint8) C_ERR_FLASH_BG);
    74c8:	72da 00f9 	lod	A, #249
    74cc:	82db 87d8 	callf	0x87d8 <_SetLastError>
				MLX4_RESET();													/* Reset the Mlx4   */
    74d0:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    74d4:	94fe      	and	AL, #-2
    74d6:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    74da:	72da 3072 	lod	A, #12402
    74de:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
				MLX16_RESET();													/* Reset the Mlx16  */
    74e2:	82db 5914 	callf	0x5914 <_MLX16_RESET>
			}
		}
	}
	l_u8BackgroundSchedulerTaskID++; 
    74e6:	62d8 00a3 	lod	AL, 0xa3 <_l_u8BackgroundSchedulerTaskID>
    74ea:	8001      	add	AL, #1
    74ec:	42d8 00a3 	mov	0xa3 <_l_u8BackgroundSchedulerTaskID>, AL
    74f0:	5401      	ret

000074f2 <_RamBackgroundTest>:
	/* Use compare instead of CRC-check !! */
	u16Page = u16Page;
	
	return TRUE;

} /* End of RamBackgroundTest() */
    74f2:	7001      	lod	A, #1
    74f4:	5401      	ret

000074f6 <_System_BackgroundIORegTest>:
{
	/* ************************************ */
	/* *** s. Critical peripheral check *** */
	/* ************************************ */
	/* Check: Motor commutation timer disabled */
	if ( (TMR1_CTRL & TMRx_T_EBLK) == 0u )
    74f6:	72aa      	lod	A, io:0x2a <__data_dp_end+0x2>
    74f8:	b401      	and	A, #1
    74fa:	1d0d      	jne	0x7516 <_System_BackgroundIORegTest+0x20>
	{
		/* Communication timer is disabled; Motor is stopped too */
		if ( g_u8MotorStartupMode != (uint8)MSM_STOP )
    74fc:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    7500:	1903      	je	0x7508 <_System_BackgroundIORegTest+0x12>
		{
			TMR1_CTRL = ((1u * TMRx_DIV0) | (0u * TMRx_MODE0) | TMRx_T_EBLK) | TMRx_START; 				/* Start timer mode 0 */
    7502:	72da 4003 	lod	A, #16387
    7506:	0002      	jmp	0x750c <_System_BackgroundIORegTest+0x16>
		}
		else
		{
			TMR1_CTRL = (1u * TMRx_DIV0) | (0u * TMRx_MODE0) | TMRx_T_EBLK;	/* Timer mode 0, Divider 16 */;								/* Timer mode 0 */
    7508:	72da 4001 	lod	A, #16385
    750c:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
		}
		SetLastError( (uint8) C_ERR_IOREG);
    750e:	72da 00fc 	lod	A, #252
    7512:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check: Administrative timer disabled */
	if ( (TIMER & TMR_EN) == 0u )							
    7516:	7286      	lod	A, io:0x6 <_LinMess2>
    7518:	ac00      	cmp	A, #0
    751a:	1a87      	jsl	0x752a <_System_BackgroundIORegTest+0x34>
	{
		TIMER = TMR_EN | CT_PERIODIC_RATE;
    751c:	72da 81f4 	lod	A, #33268
    7520:	5286      	mov	io:0x6 <_LinMess2>, A
		SetLastError( (uint8) C_ERR_IOREG);
    7522:	72da 00fc 	lod	A, #252
    7526:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check: IRQ-Mask (Respectively: Diagnostics, Timer1, CoreTimer and LIN-Communication */
	if ( (MASK & (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT)) != (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT) )
    752a:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    752e:	b6da 1130 	and	A, #4400
    7532:	aeda 1130 	cmp	A, #4400
    7536:	190e      	je	0x7554 <_System_BackgroundIORegTest+0x5e>
	{
		PEND = (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7538:	72da 1130 	lod	A, #4400
    753c:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
		MASK |= (EN_EXT4_IT | EN_EXT0_IT | EN_TIMER_IT | EN_M4_SHE_IT);
    7540:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    7544:	a6da 1130 	or	A, #4400
    7548:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
		SetLastError( (uint8) C_ERR_IOREG);
    754c:	72da 00fc 	lod	A, #252
    7550:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check: IRQ-priority (Respectively: Diagnostics, Timer1, CoreTimer) */
	if ( (PRIO & (((uint16)3u << 14u) | ((uint16)3u << 6u) | ((uint16)3u << 0u))) != 
    7554:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7558:	b6da c0c3 	and	A, #49347
    755c:	ac43      	cmp	A, #67
    755e:	190f      	je	0x757e <_System_BackgroundIORegTest+0x88>
		(/*((uint16)(3-3) << 14) |*/ ((uint16)(4u - 3u) << 6u) | ((uint16)(6u - 3u) << 0u)) )
	{
		PRIO &= ~(((uint16)3u << 14u) | ((uint16)3u << 6u) | ((uint16)3u << 0u));
    7560:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7564:	b6da 3f3c 	and	A, #16188
    7568:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
		PRIO |=  (/*((uint16)(3u - 3u) << 14u) |*/ ((uint16)(4u - 3u) << 6u) | ((uint16)(6u - 3u) << 0u));
    756c:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    7570:	a443      	or	A, #67
    7572:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
		SetLastError( (uint8) C_ERR_IOREG);
    7576:	72da 00fc 	lod	A, #252
    757a:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check: 2nd level IRQ Timer1 */
	if ( (XI0_MASK & EN_T1_INT4) == 0u )
    757e:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    7582:	b440      	and	A, #64
    7584:	1d09      	jne	0x7598 <_System_BackgroundIORegTest+0xa2>
	{
		XI0_PEND = EN_T1_INT4;
    7586:	7040      	lod	A, #64
    7588:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		XI0_MASK = EN_T1_INT4;
    758c:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
		SetLastError( (uint8) C_ERR_IOREG);
    7590:	72da 00fc 	lod	A, #252
    7594:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check: 2nd level IRQ Diagnostics */
	if ( (XI4_MASK & (XI4_OVT | XI4_UV | XI4_OV | XI4_OC_DRV)) != C_DIAG_MASK )
    7598:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    759c:	b6da e100 	and	A, #57600
    75a0:	aeda e100 	cmp	A, #57600
    75a4:	190a      	je	0x75ba <_System_BackgroundIORegTest+0xc4>
	{
		XI4_PEND = C_DIAG_MASK; 										/* MMP150409-1 */
    75a6:	72da e100 	lod	A, #57600
    75aa:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
		XI4_MASK = C_DIAG_MASK; 										/* MMP150409-1 */
    75ae:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
		SetLastError( (uint8) C_ERR_IOREG);
    75b2:	72da 00fc 	lod	A, #252
    75b6:	82db 87d8 	callf	0x87d8 <_SetLastError>
	}
	/* Check:driver check */
	if ( (g_u8MotorStartupMode != (uint8)MSM_STOP) && ((DRVCFG & (DRV_CFG_T|DRV_CFG_W|DRV_CFG_V|DRV_CFG_U)) == 0u) )
    75ba:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    75be:	1908      	je	0x75d0 <_System_BackgroundIORegTest+0xda>
    75c0:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    75c4:	8c00      	cmp	AL, #0
    75c6:	1d04      	jne	0x75d0 <_System_BackgroundIORegTest+0xda>
	{
		/* Driver have been disabled */
		SetLastError( (uint8) C_ERR_IOREG);
    75c8:	72da 00fc 	lod	A, #252
    75cc:	82db 87d8 	callf	0x87d8 <_SetLastError>
    75d0:	5401      	ret

000075d2 <_handleNetworkManagement>:
}

/* network management handler */
void handleNetworkManagement(void)
{
	if(l_e8CommState == COMM_STATE_OPERATIONAL)
    75d2:	62d8 00ac 	lod	AL, 0xac <_l_e8CommState>
    75d6:	8c01      	cmp	AL, #1
    75d8:	1d0c      	jne	0x75f2 <_handleNetworkManagement+0x20>
	{
		if(l_u8NMEventPending != C_ML_REASON_NO)
    75da:	62d8 00ab 	lod	AL, 0xab <_l_u8NMEventPending>
    75de:	191c      	je	0x7618 <_handleNetworkManagement+0x46>
		{
			HandleNMReq(l_u8NMEventPending);
    75e0:	5cf2      	usex	A
    75e2:	1663      	call	0x72aa <_HandleNMReq>
			l_u8NMEventPending = C_ML_REASON_NO;
    75e4:	6000      	lod	AL, #0
    75e6:	42d8 00ab 	mov	0xab <_l_u8NMEventPending>, AL
			l_e8CommState = COMM_STATE_STOPPED;
    75ea:	6002      	lod	AL, #2
    75ec:	42d8 00ac 	mov	0xac <_l_e8CommState>, AL
    75f0:	5401      	ret
		}
	}
	else if(l_e8CommState == COMM_STATE_STOPPED)
    75f2:	8c02      	cmp	AL, #2
    75f4:	1d11      	jne	0x7618 <_handleNetworkManagement+0x46>
	{
		
		if((ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0u))
    75f6:	7009      	lod	A, #9
    75f8:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    75fc:	acff      	cmp	A, #-1
    75fe:	190c      	je	0x7618 <_handleNetworkManagement+0x46>
    7600:	62d8 01a0 	lod	AL, 0x1a0 <_LinStatus>
    7604:	b401      	and	A, #1
    7606:	1908      	je	0x7618 <_handleNetworkManagement+0x46>
		{
			/* MLX4 has detected a SYNC field */
			(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    7608:	7008      	lod	A, #8
    760a:	82db 5b5c 	callf	0x5b5c <_ml_GetState>

			l_e8CommState = COMM_STATE_OPERATIONAL;
    760e:	6001      	lod	AL, #1
    7610:	42d8 00ac 	mov	0xac <_l_e8CommState>, AL
			HandleNMReq(C_ML_REASON_WAKEUP);
    7614:	7004      	lod	A, #4
    7616:	1649      	call	0x72aa <_HandleNMReq>
    7618:	5401      	ret

0000761a <_CalcProtectionBits>:
/* **************************************************************************** *
 * CalcProtectionBits
 *
 * **************************************************************************** */
uint8 CalcProtectionBits( uint8 byFrameID)
{
    761a:	5807      	inc	S, #8
	uint8 u8Temp;
	
	u8Temp = ((byFrameID & 0x01u) ^ ((byFrameID & 0x02u) >> 1u) ^ ((byFrameID & 0x04u) >> 2u) ^ ((byFrameID & 0x10u) >> 4u));
    761c:	7ee2      	lod	X, A
    761e:	9401      	and	AL, #1
    7620:	7aee      	lod	Y, X
    7622:	f402      	and	Y, #2
    7624:	4436      	lsr	Y
    7626:	9ee8      	xor	AL, YL
    7628:	7aee      	lod	Y, X
    762a:	f404      	and	Y, #4
    762c:	44b6      	lsr	Y, #2
    762e:	9ee8      	xor	AL, YL
    7630:	7aee      	lod	Y, X
    7632:	f410      	and	Y, #16
    7634:	44b6      	lsr	Y, #2
    7636:	44b6      	lsr	Y, #2
	byFrameID |= (u8Temp > 0u) ? 0x40u : 0x00u;
    7638:	8ee8      	cmp	AL, YL
    763a:	1902      	je	0x7640 <_CalcProtectionBits+0x26>
    763c:	2440      	or	X, #64
    763e:	0003      	jmp	0x7646 <_CalcProtectionBits+0x2c>
    7640:	72ee      	lod	A, X
    7642:	5cf2      	usex	A
    7644:	7ee2      	lod	X, A
	u8Temp = (((byFrameID & 0x02u) >> 1u) ^ ((byFrameID & 0x08u) >> 3u) ^ ((byFrameID & 0x10u) >> 4u) ^ ((byFrameID & 0x20u) >> 5u));
    7646:	7aee      	lod	Y, X
    7648:	f402      	and	Y, #2
    764a:	4436      	lsr	Y
    764c:	72ee      	lod	A, X
    764e:	b408      	and	A, #8
    7650:	44b2      	lsr	A, #2
    7652:	4432      	lsr	A
    7654:	9ee8      	xor	AL, YL
    7656:	7aee      	lod	Y, X
    7658:	f410      	and	Y, #16
    765a:	44b6      	lsr	Y, #2
    765c:	44b6      	lsr	Y, #2
    765e:	9ee8      	xor	AL, YL
    7660:	7aee      	lod	Y, X
    7662:	f420      	and	Y, #32
    7664:	44b6      	lsr	Y, #2
    7666:	44b6      	lsr	Y, #2
    7668:	4436      	lsr	Y
	byFrameID |= (u8Temp > 0u) ? 0x00u : 0x80u;
    766a:	8ee8      	cmp	AL, YL
    766c:	1904      	je	0x7676 <_CalcProtectionBits+0x5c>
    766e:	72ee      	lod	A, X
    7670:	5cf2      	usex	A
    7672:	7ee2      	lod	X, A
    7674:	0002      	jmp	0x767a <_CalcProtectionBits+0x60>
    7676:	26da 0080 	or	X, #128
	
	return ( byFrameID );
} /* End of CalcProtectionBits() */
    767a:	72ee      	lod	A, X
    767c:	5409      	ret	#10

0000767e <_LIN_Init>:
 *
 * Initialise LIN communication interface.
 * Default start-up, at 9600 Baud
 * ****************************************************************************	*/
void LIN_Init(void)
{
    767e:	5803      	inc	S, #4
	uint16 buf[2];
	uint8 temp;
	
	/* Initialise LIN Communication */
	LIN_XCFG &= ~DISTERM;														/* Enable LIN pull-up resistor (MMP150811-2) */
    7680:	72a0      	lod	A, io:0x20 <_g_u16StartupDelay>
    7682:	b4fb      	and	A, #-5
    7684:	52a0      	mov	io:0x20 <_g_u16StartupDelay>, A
	(void) ml_InitLinModule();													/* Initialise the LIN module */
    7686:	82db 5dce 	callf	0x5dce <_ml_InitLinModule>
#if _SUPPORT_AUTO_BAUDRATE == FALSE
	/* Fixed baudrate */
	(void) ml_SetBaudRate( (ml_uint8) LIN_BR_PRESCALER, (ml_uint8)LIN_BR_DIV);	/* Program the baudrate : default startup : 9600baud @ 20.0 Mhz	*/
#else
	/* Auto baudrate only on first LIN frame */
	(void) ml_SetAutoBaudRateMode( ML_ABR_ON_FIRST_FRAME);						/* MMP141215-1 */
    768a:	7000      	lod	A, #0
    768c:	82db 5b8e 	callf	0x5b8e <_ml_SetAutoBaudRateMode>
#endif

	/* Setup LIN options, including slew-rate */
	(void) ml_SetOptions( 1U,													/* IDStopBitLength = 1.5 Bit (Melexis LIN Master has 1.5 Tbit stop bit */
    7690:	54ca 0000 	pushw	#0
    7694:	54ca 0001 	pushw	#1
    7698:	54ca 0000 	pushw	#0
    769c:	7001      	lod	A, #1
    769e:	82db 5ad4 	callf	0x5ad4 <_ml_SetOptions>
						  ML_LIGHTSLEEP);										/* SleepMode: light-sleep mode */

#if (LIN_BR < 12000)
	(void) ml_SetSlewRate( ML_SLEWLOW);
#else /* (LIN_BR < 10000) */
	(void) ml_SetSlewRate( ML_SLEWHIGH);
    76a2:	7000      	lod	A, #0
    76a4:	82db 5acc 	callf	0x5acc <_ml_SetSlewRate>

#if defined (HAS_LIN_NEXT_FRAME_ID)
	(void) ml_EnableFilter( 0);													/* Enable filter */
#endif

	(void)NVRAM_Read(0x1000,buf,2);
    76a8:	54ca 0002 	pushw	#2
    76ac:	72ef      	lod	A, S
    76ae:	a0f4      	add	A, #-12
    76b0:	52df      	push	A
    76b2:	72da 1000 	lod	A, #4096
    76b6:	82db 92ae 	callf	0x92ae <_NVRAM_Read>
		(void) ml_AssignFrameToMessageID( MSG_STATUS, byFrameID);
	}
#endif

#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
	temp = (uint8)(buf[0] & 0x00FFu);
    76ba:	7e0d      	lod	X, [S-14]
    76bc:	7aee      	lod	Y, X
    76be:	5cf6      	usex	Y
    if ( (temp & 0x80u) == 0x00u )
    76c0:	5c09      	dec	S, #10
    76c2:	62e8      	lod	AL, YL
    76c4:	8c00      	cmp	AL, #0
    76c6:	1a89      	jsl	0x76da <_LIN_Init+0x5c>
	{
		g_u8NAD = temp;
    76c8:	451b      	mov	dp:0x1b <_g_u8NAD>, YL
		g_u8ControlFrameID = (uint8)(buf[0] >> 8u);
    76ca:	7eec      	swap	X
    76cc:	36da 00ff 	and	X, #255
    76d0:	72ee      	lod	A, X
    76d2:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
		g_u8StatusFrameID = (uint8)(buf[1] & 0x00FFu);
    76d4:	7201      	lod	A, [S-2]
    76d6:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
    76d8:	0015      	jmp	0x7704 <_LIN_Init+0x86>
	}
	else
	{
        g_u8NAD = C_DEFAULT_NAD;
    76da:	6016      	lod	AL, #22
    76dc:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
		g_u8ControlFrameID = mlxACT_CTRL;
    76de:	60c4      	lod	AL, #-60
    76e0:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
		g_u8StatusFrameID  = mlxACT_STATUS;
    76e2:	6085      	lod	AL, #-123
    76e4:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL

		/* store to NVM */
		buf[0] = (uint8)C_DEFAULT_NAD;
		buf[0] |= ((uint16)mlxACT_CTRL << 8u);
    76e6:	72da c416 	lod	A, #50198
    76ea:	5203      	mov	[S-4], A
		buf[1] = (uint8)mlxACT_STATUS;
		buf[1] |= ((uint16)C_VARIANT << 8u);
    76ec:	7085      	lod	A, #-123
    76ee:	5201      	mov	[S-2], A
		(void)NVRAM_Write(0x1000, buf, 2);
    76f0:	54ca 0002 	pushw	#2
    76f4:	72ef      	lod	A, S
    76f6:	a0fa      	add	A, #-6
    76f8:	52df      	push	A
    76fa:	72da 1000 	lod	A, #4096
    76fe:	82db 933a 	callf	0x933a <_NVRAM_Write>
    7702:	5c03      	dec	S, #4
	}
	/* dynamic bound message id to frame id */
	(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7704:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7706:	5cf2      	usex	A
    7708:	52df      	push	A
    770a:	7001      	lod	A, #1
    770c:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
	(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7710:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7712:	5cf2      	usex	A
    7714:	52df      	push	A
    7716:	7000      	lod	A, #0
    7718:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
#endif

    (void) ml_SetLoaderNAD( g_u8NAD);											/* Setup NAD at power-up */
    771c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    771e:	5cf2      	usex	A
    7720:	82db 5d94 	callf	0x5d94 <_ml_SetLoaderNAD>

	(void) ml_Connect();
    7724:	82db 5b96 	callf	0x5b96 <_ml_Connect>

	/* Check chip-state for LIN-command RESET, to setup diagnostic-response */
	if ( bistResetInfo == C_CHIP_STATE_LIN_CMD_RESET )
    7728:	72d8 01a8 	lod	A, 0x1a8 <_bistResetInfo>
    772c:	5c03      	dec	S, #4
    772e:	aeda 3072 	cmp	A, #12402
    7732:	1d03      	jne	0x773a <_LIN_Init+0xbc>
	{
#if ((LINPROT & LINXX) == LIN2J)
		RfrDiagReset();														/* Prepare a diagnostics response reply */
#endif
		bistResetInfo = C_CHIP_STATE_COLD_START;
    7734:	7000      	lod	A, #0
    7736:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
    773a:	5405      	ret	#6

0000773c <_handleMLX4StatusSupervisor>:
{
	/* ********************** */
	/* *** n. MLX4 status *** */
	/* ********************** */
	/* MLX4 LIN-Bus activity check  */
	if ( (ml_GetState( ML_NOT_CLEAR) != ml_stINVALID) && ((LinStatus & ML_LIN_BUS_ACTIVITY) != 0u) )
    773c:	7009      	lod	A, #9
    773e:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    7742:	acff      	cmp	A, #-1
    7744:	190d      	je	0x7760 <_handleMLX4StatusSupervisor+0x24>
    7746:	62d8 01a0 	lod	AL, 0x1a0 <_LinStatus>
    774a:	b401      	and	A, #1
    774c:	1909      	je	0x7760 <_handleMLX4StatusSupervisor+0x24>
	{
		/* MLX4 has detected a SYNC field */
		Timer_Start(MLX4_STATUS_CHECK_TIMER, C_MLX4_STATE_TIMEOUT);
    774e:	54ca 03e8 	pushw	#1000
    7752:	7000      	lod	A, #0
    7754:	82db 989a 	callf	0x989a <_Timer_Start>
		(void) ml_GetState( ML_CLR_LIN_BUS_ACTIVITY);
    7758:	7008      	lod	A, #8
    775a:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    775e:	5c01      	dec	S, #2
	}

	if ( Timer_IsExpired(MLX4_STATUS_CHECK_TIMER) == TRUE ) /* MMP130905-4 - End */
    7760:	7000      	lod	A, #0
    7762:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    7766:	8c01      	cmp	AL, #1
    7768:	1d2f      	jne	0x77c8 <_handleMLX4StatusSupervisor+0x8c>
	{
		/* Didn't receive MLX4 LIN command and/or data-request in the last period, or need immediate reset */
		Timer_Start(MLX4_STATUS_CHECK_TIMER, C_MLX4_STATE_TIMEOUT);						/* MLX4 State check counter reset; MLX4 still active */
    776a:	54ca 03e8 	pushw	#1000
    776e:	7000      	lod	A, #0
    7770:	82db 989a 	callf	0x989a <_Timer_Start>
		if ( ml_GetState( ML_NOT_CLEAR) == ml_stINVALID )		/* MMP130811-1 */
    7774:	7009      	lod	A, #9
    7776:	82db 5b5c 	callf	0x5b5c <_ml_GetState>
    777a:	5c01      	dec	S, #2
    777c:	acff      	cmp	A, #-1
    777e:	1d21      	jne	0x77c2 <_handleMLX4StatusSupervisor+0x86>
		{
			l_u8Mlx4ErrorStateOcc++;
    7780:	62d8 00aa 	lod	AL, 0xaa <_l_u8Mlx4ErrorStateOcc>
    7784:	8001      	add	AL, #1
    7786:	42d8 00aa 	mov	0xaa <_l_u8Mlx4ErrorStateOcc>, AL
			if ( l_u8Mlx4ErrorStateOcc >= (uint8) C_MLX4_STATE_ERROR_THRSHLD )
    778a:	8c03      	cmp	AL, #3
    778c:	1a1d      	jule	0x77c8 <_handleMLX4StatusSupervisor+0x8c>
			{
				/* Signal Error; Reset MLX4 */
				MLX4_RESET();
    778e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7792:	94fe      	and	AL, #-2
    7794:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				NOP();
    7798:	0000      	nop
				NOP();
    779a:	0000      	nop
				NOP();
    779c:	0000      	nop
				MLX4_START();
    779e:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    77a2:	8401      	or	AL, #1
    77a4:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
				if ( (l_u8Mlx4ErrorStateOcc & (uint8)C_MLX4_STATE_NOT_LOGGED) == 0u )	/* MMP131126-1 */
    77a8:	62d8 00aa 	lod	AL, 0xaa <_l_u8Mlx4ErrorStateOcc>
    77ac:	b440      	and	A, #64
    77ae:	1d04      	jne	0x77b8 <_handleMLX4StatusSupervisor+0x7c>
				{
					SetLastError( (uint8) C_ERR_MLX4_RESTART);
    77b0:	72da 00fa 	lod	A, #250
    77b4:	82db 87d8 	callf	0x87d8 <_SetLastError>
				}
				LIN_Init();										/* Re-initialise LIN interface w/o changing position */
    77b8:	1762      	call	0x767e <_LIN_Init>
				l_u8Mlx4ErrorStateOcc = 0;
    77ba:	6000      	lod	AL, #0
    77bc:	42d8 00aa 	mov	0xaa <_l_u8Mlx4ErrorStateOcc>, AL
    77c0:	5401      	ret
			}
		}
		else
		{
			l_u8Mlx4ErrorStateOcc = 0;
    77c2:	6000      	lod	AL, #0
    77c4:	42d8 00aa 	mov	0xaa <_l_u8Mlx4ErrorStateOcc>, AL
    77c8:	5401      	ret

000077ca <_mlu_ApplicationStop>:
 *  LIN API event: mlu_ApplicationStop
 * ****************************************************************************	*/
ml_Status mlu_ApplicationStop(void)
{
	/* Disable all IRQ's, except LIN */
	XI0_MASK = 0;
    77ca:	7000      	lod	A, #0
    77cc:	52d8 202a 	mov	0x202a <__ep__+0x102a>, A
	XI1_MASK = 0;
    77d0:	52d8 202c 	mov	0x202c <__ep__+0x102c>, A
	XI2_MASK = 0;
    77d4:	52d8 202e 	mov	0x202e <__ep__+0x102e>, A
	XI3_MASK = 0;
    77d8:	52d8 2030 	mov	0x2030 <__ep__+0x1030>, A
	XI4_MASK = 0;
    77dc:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	MASK = EN_M4_SHE_IT;														/* Disable all interrupts, except LIN M4_SHE_IT */
    77e0:	7010      	lod	A, #16
    77e2:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A

	return ( ML_SUCCESS );														/* Return that the application has stopped */
} /* End of mlu_ApplicationStop */
    77e6:	7000      	lod	A, #0
    77e8:	5401      	ret

000077ea <_mlu_DataRequest>:

/* ****************************************************************************	*
 *  LIN API event: Data Request (slave TX)
 * ****************************************************************************	*/
void mlu_DataRequest( ml_MessageID MessageIndex) 
{
    77ea:	5801      	inc	S, #2
	/* Data requested; No longer Bus time-out */

	if ( MessageIndex == (uint8) mlxRFR_DIAG )
    77ec:	8c11      	cmp	AL, #17
    77ee:	1d1e      	jne	0x782c <_mlu_DataRequest+0x42>
	{
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
		if(Timer_IsExpired(DIAG_RESPONSE_TIMER) == TRUE)
    77f0:	7006      	lod	A, #6
    77f2:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    77f6:	8c01      	cmp	AL, #1
    77f8:	1d05      	jne	0x7804 <_mlu_DataRequest+0x1a>
		{
			if ( g_u8BufferOutID == QR_RFR_DIAG )								/* Pending response type: Diagnostic */
    77fa:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    77fc:	8c07      	cmp	AL, #7
    77fe:	1d02      	jne	0x7804 <_mlu_DataRequest+0x1a>
			{
				g_u8BufferOutID = (uint8) QR_INVALID;							/* Invalidate Diagnostics response */
    7800:	60ff      	lod	AL, #-1
    7802:	4118      	mov	dp:0x18 <__data_dp_start>, AL
			}
		}
#endif	

		/* Diagnostic */
		if ( g_u8BufferOutID == (uint8) QR_RFR_DIAG ) /* diagnostic buffer ready? */
    7804:	6118      	lod	AL, dp:0x18 <__data_dp_start>
    7806:	8c07      	cmp	AL, #7
    7808:	1d0e      	jne	0x7826 <_mlu_DataRequest+0x3c>
			/* Copy g_DiagResponse to LinFrameDataBuffer */
			RFR_DIAG *pDiag = &g_DiagResponse;
			uint16 *src = (uint16 *) pDiag;
			uint16 *dst = (uint16 *) LinFrameDataBuffer;
			
			dst[0] = src[0];
    780a:	7130      	lod	A, dp:0x30 <_g_DiagResponse>
    780c:	5152      	mov	dp:0x52 <_LinFrameDataBuffer>, A
			dst[1] = src[1];
    780e:	7132      	lod	A, dp:0x32 <_g_DiagResponse+0x2>
    7810:	5154      	mov	dp:0x54 <_LinFrameDataBuffer+0x2>, A
			dst[2] = src[2];
    7812:	7134      	lod	A, dp:0x34 <_g_DiagResponse+0x4>
    7814:	5156      	mov	dp:0x56 <_LinFrameDataBuffer+0x4>, A
			dst[3] = src[3];
    7816:	7136      	lod	A, dp:0x36 <_g_DiagResponse+0x6>
    7818:	5158      	mov	dp:0x58 <_LinFrameDataBuffer+0x6>, A

			(void) ml_DataReady( ML_END_OF_TX_DISABLED);
    781a:	7000      	lod	A, #0
    781c:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
			g_u8BufferOutID = (uint8) QR_INVALID;								/* Invalidate LIN output buffer */
    7820:	60ff      	lod	AL, #-1
    7822:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7824:	5403      	ret	#4
		}
		else
		{
			(void) ml_DiscardFrame();											/* Output buffer response doesn't match requested response */
    7826:	82db 5aea 	callf	0x5aea <_ml_DiscardFrame>
    782a:	5403      	ret	#4
		}
	}
	else if ( MessageIndex == (uint8) MSG_STATUS )
    782c:	ac00      	cmp	A, #0
    782e:	1d0e      	jne	0x784c <_mlu_DataRequest+0x62>
	{
		ACT_RFR_STA *pRfrSta = (ACT_RFR_STA *)LinFrameDataBuffer;
		/* Status AGS */
		HandleActRfrSta(pRfrSta);
    7830:	72da 0052 	lod	A, #82
    7834:	14fa      	call	0x722a <_HandleActRfrSta>
		/* LIN communication error */
		pRfrSta->ResponseError = l_u8ErrorCommunication;
    7836:	62d8 00ad 	lod	AL, 0xad <_l_u8ErrorCommunication>
    783a:	9401      	and	AL, #1
    783c:	4201      	mov	[S-2], AL
    783e:	6152      	lod	AL, dp:0x52 <_LinFrameDataBuffer>
    7840:	94fe      	and	AL, #-2
    7842:	8601      	or	AL, [S-2]
    7844:	4152      	mov	dp:0x52 <_LinFrameDataBuffer>, AL
		(void) ml_DataReady( ML_END_OF_TX_ENABLED);
    7846:	7001      	lod	A, #1
    7848:	82db 5a98 	callf	0x5a98 <_ml_DataReady>
    784c:	5403      	ret	#4

0000784e <_mlu_DataTransmitted>:
/* ****************************************************************************	*
 *  LIN API event: mlu_DataTransmitted
 * ****************************************************************************	*/
void mlu_DataTransmitted(void) 
{
    l_u8ErrorCommunication = FALSE;
    784e:	6000      	lod	AL, #0
    7850:	42d8 00ad 	mov	0xad <_l_u8ErrorCommunication>, AL
    7854:	5401      	ret

00007856 <_LIN2x_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The 
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2x_ErrorHandling( ml_LinError Error)
{
    7856:	5803      	inc	S, #4
    7858:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) LinProtectedID & 0x3Fu;							/* Get Frame-ID without parity bits */
    785a:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    785c:	b43f      	and	A, #63
    785e:	5203      	mov	[S-4], A
	
	if ( (u8FrameID == (uint8) ML_MRF_ID) && 
    7860:	8c3c      	cmp	AL, #60
    7862:	1d06      	jne	0x7870 <_LIN2x_ErrorHandling+0x1a>
    7864:	ec06      	cmp	Y, #6
    7866:	1902      	je	0x786c <_LIN2x_ErrorHandling+0x16>
    7868:	ec04      	cmp	Y, #4
    786a:	1d02      	jne	0x7870 <_LIN2x_ErrorHandling+0x1a>
	{
		/*
		 * Abort Diagnostic communication with corrupted Diagnostic request
		 * Checked by LIN2.1 CT test case 13.2.2
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    786c:	60ff      	lod	AL, #-1
    786e:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	{
		/* Do NOT set response_error bit, because error occurred in a header */
	}
	
	/* Checksum error:checksum error in message received */
	if( Error == ml_erCheckSum )
    7870:	ec04      	cmp	Y, #4
    7872:	1904      	je	0x787c <_LIN2x_ErrorHandling+0x26>
			l_u8ErrorCommunication = TRUE;
		}
	}

	/* Transmit cycle data collision:data collision during transmit cycle */
	if( Error == ml_erBit )
    7874:	ec05      	cmp	Y, #5
    7876:	190d      	je	0x7892 <_LIN2x_ErrorHandling+0x3c>
	{
		l_u8ErrorCommunication = TRUE;
	}
	
	/* Error data framing:start or stop bit error while receiving data */
	if( Error == ml_erDataFraming )
    7878:	ec06      	cmp	Y, #6
    787a:	1d09      	jne	0x788e <_LIN2x_ErrorHandling+0x38>
	{
		if( (u8FrameID == (uint8) ML_MRF_ID) || (u8FrameID == (g_u8ControlFrameID & 0x3Fu)) )
    787c:	6203      	lod	AL, [S-4]
    787e:	8c3c      	cmp	AL, #60
    7880:	1908      	je	0x7892 <_LIN2x_ErrorHandling+0x3c>
    7882:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7884:	b43f      	and	A, #63
    7886:	7a03      	lod	Y, [S-4]
    7888:	eee2      	cmp	Y, A
    788a:	1d14      	jne	0x78b4 <_LIN2x_ErrorHandling+0x5e>
    788c:	0002      	jmp	0x7892 <_LIN2x_ErrorHandling+0x3c>
			l_u8ErrorCommunication = TRUE;
		}
	}

	/* Error during STOP bit transmission */
	if( Error == ml_erStopBitTX )
    788e:	ec10      	cmp	Y, #16
    7890:	1d04      	jne	0x789a <_LIN2x_ErrorHandling+0x44>
	{
		l_u8ErrorCommunication = TRUE;
    7892:	6001      	lod	AL, #1
    7894:	42d8 00ad 	mov	0xad <_l_u8ErrorCommunication>, AL
    7898:	5405      	ret	#6
	{
	
	}
	
	/* Unexpectable break:A header has been detected inside a frame */
	if(Error == ml_erBreakDetected)
    789a:	ec0c      	cmp	Y, #12
    789c:	1d0b      	jne	0x78b4 <_LIN2x_ErrorHandling+0x5e>
	{
		/* LCT3.8:INCOMPLETE FRAME RECEPTION */
		if( (u8FrameID == (uint8) ML_MRF_ID) || (u8FrameID == (g_u8ControlFrameID & 0x3Fu)) )
    789e:	6203      	lod	AL, [S-4]
    78a0:	8c3c      	cmp	AL, #60
    78a2:	1905      	je	0x78ae <_LIN2x_ErrorHandling+0x58>
    78a4:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    78a6:	b43f      	and	A, #63
    78a8:	7a03      	lod	Y, [S-4]
    78aa:	eee2      	cmp	Y, A
    78ac:	1d03      	jne	0x78b4 <_LIN2x_ErrorHandling+0x5e>
		{
			l_u8ErrorCommunication = TRUE;
    78ae:	6001      	lod	AL, #1
    78b0:	42d8 00ad 	mov	0xad <_l_u8ErrorCommunication>, AL
    78b4:	5405      	ret	#6

000078b6 <_mlu_ErrorDetected>:

/* ****************************************************************************	*
 *  LIN API event: mlu_ErrorDetected
 * ****************************************************************************	*/
void mlu_ErrorDetected( ml_LinError Error)
{
    78b6:	5801      	inc	S, #2
    78b8:	5201      	mov	[S-2], A
	SetLastError( (uint8) C_ERR_LIN_COMM | ((uint8)Error & 0x1Fu));
    78ba:	a6da 0080 	or	A, #128
    78be:	b6da 009f 	and	A, #159
    78c2:	82db 87d8 	callf	0x87d8 <_SetLastError>
#if ((LINPROT & LINXX) == LIN2J)
     LIN2J_ErrorHandling(Error);
#endif
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
    LIN2x_ErrorHandling(Error);
    78c6:	7201      	lod	A, [S-2]
    78c8:	17c6      	call	0x7856 <_LIN2x_ErrorHandling>
    78ca:	5403      	ret	#4

000078cc <_mlu_LinSleepMode>:
{
	/*
	 * MLX4 FW handles Goto Sleep frame (0x3C, 0x00 ...) automatically
	 * and does not report it via mlu_MessageReceived event.
	 */
	if ( (Reason == ml_reasonMaster) || (Reason == ml_reasonCommand) )			/* MMP130918-1 */
    78cc:	7ae2      	lod	Y, A
    78ce:	a0ff      	add	A, #-1
    78d0:	ac01      	cmp	A, #1
    78d2:	1e03      	jug	0x78da <_mlu_LinSleepMode+0xe>
	{
		l_u8NMEventPending = C_ML_REASON_CMD;       
    78d4:	6001      	lod	AL, #1
    78d6:	42d8 00ab 	mov	0xab <_l_u8NMEventPending>, AL
	}

	if ( (Reason == ml_reasonTimeOut) || (Reason == ml_reasonTimeOutDominant) )
    78da:	72e6      	lod	A, Y
    78dc:	a0fa      	add	A, #-6
    78de:	ac01      	cmp	A, #1
    78e0:	1e07      	jug	0x78f0 <_mlu_LinSleepMode+0x24>
		/*
		 * LIN bus was inactive for 4 seconds without receiving an explicit
		 * "Go-to-Sleep frame". This can be considered as a failure of the Master or
		 * PHY layer. Slave can enter limp-home mode.
		 */
		l_u8NMEventPending = C_ML_REASON_TIMEOUT; 
    78e2:	6002      	lod	AL, #2
    78e4:	42d8 00ab 	mov	0xab <_l_u8NMEventPending>, AL
        SetLastError( (uint8) C_ERR_LIN_BUS_TIMEOUT);
    78e8:	72da 00bf 	lod	A, #191
    78ec:	82db 87d8 	callf	0x87d8 <_SetLastError>
    78f0:	5401      	ret

000078f2 <_mlu_MessageReceived>:

/* ****************************************************************************	*
 *  LIN API event: MessageReceived (slave RX)
 * ****************************************************************************	*/
void mlu_MessageReceived( ml_MessageID MessageIndex)
{
    78f2:	7ae2      	lod	Y, A
    if ( l_u8LinInFrameBufState != (uint8) C_LIN_IN_FULL )
    78f4:	62d8 00ae 	lod	AL, 0xae <_l_u8LinInFrameBufState>
    78f8:	8c01      	cmp	AL, #1
    78fa:	190f      	je	0x791a <_mlu_MessageReceived+0x28>
	{
		/* Buffer is either empty or message is postpone (overwrite allowed) */
		l_u8LinInFrameMsgID = MessageIndex;
    78fc:	46d8 00f2 	mov	0xf2 <_l_u8LinInFrameMsgID>, YL

		/* LIN In-frame buffer to a Copy LIN In-frame buffer */
		{
			uint16 *pu16Source = (uint16 *) LinFrameDataBuffer;
			uint16 *pu16Target = (uint16 *) &g_LinCmdFrameBuffer;
			*pu16Target = *pu16Source;
    7900:	7152      	lod	A, dp:0x52 <_LinFrameDataBuffer>
    7902:	5128      	mov	dp:0x28 <__data_dp_end>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7904:	7154      	lod	A, dp:0x54 <_LinFrameDataBuffer+0x2>
    7906:	512a      	mov	dp:0x2a <__data_dp_end+0x2>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    7908:	7156      	lod	A, dp:0x56 <_LinFrameDataBuffer+0x4>
    790a:	512c      	mov	dp:0x2c <__data_dp_end+0x4>, A
			pu16Target++;
			pu16Source++;
			*pu16Target = *pu16Source;
    790c:	7158      	lod	A, dp:0x58 <_LinFrameDataBuffer+0x6>
    790e:	512e      	mov	dp:0x2e <__data_dp_end+0x6>, A
		}
		l_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7910:	6001      	lod	AL, #1
    7912:	42d8 00ae 	mov	0xae <_l_u8LinInFrameBufState>, AL
	
		LinFrame[0] = 0x00;														/* Clear NAD address */
    7916:	6000      	lod	AL, #0
    7918:	4108      	mov	dp:0x8 <__bist_stat_size>, AL
    791a:	5401      	ret

0000791c <_LIN2J_ErrorHandling>:
 *	To see if this slave is addressed, check the NAD in the LinFrame. The
 *	position within the LinFrame depends on the Frame-ID.
 *
 * ****************************************************************************	*/
void LIN2J_ErrorHandling( ml_LinError Error)
{
    791c:	5803      	inc	S, #4
    791e:	7ae2      	lod	Y, A
	uint8 u8FrameID = (uint8) (LinProtectedID & 0x3Fu);							/* Get Frame-ID without parity bits */
    7920:	6107      	lod	AL, dp:0x7 <_LinProtectedID>
    7922:	b43f      	and	A, #63
    7924:	5203      	mov	[S-4], A
	
	if ( (u8FrameID == (uint8) ML_MRF_ID) && ((Error == ml_erDataFraming) || (Error == ml_erCheckSum)) )
    7926:	8c3c      	cmp	AL, #60
    7928:	1d06      	jne	0x7936 <_LIN2J_ErrorHandling+0x1a>
    792a:	ec06      	cmp	Y, #6
    792c:	1902      	je	0x7932 <_LIN2J_ErrorHandling+0x16>
    792e:	ec04      	cmp	Y, #4
    7930:	1d02      	jne	0x7936 <_LIN2J_ErrorHandling+0x1a>
	{
		/*
		 * LCT13.2.2:Abort Diagnostic communication with corrupted Diagnostic request
		 */
		g_u8BufferOutID = (uint8) QR_INVALID;
    7932:	60ff      	lod	AL, #-1
    7934:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	}

	/* ---- ml_erLinModuleReset -------------------------------------------- */
	if ( Error == ml_erLinModuleReset )
    7936:	ec02      	cmp	Y, #2
    7938:	1921      	je	0x797c <_LIN2J_ErrorHandling+0x60>
	{
		/* Non-recoverable failure has occurred in the LIN Module */
		/* switch to System Mode and reinitialise LIN module */
	}
	/* ---- ml_erIdParity -------------------------------------------------- */
	else if ( (Error == ml_erIdParity) || (Error == ml_erIdFraming ) )
    793a:	ec03      	cmp	Y, #3
    793c:	1916      	je	0x796a <_LIN2J_ErrorHandling+0x4e>
    793e:	ec07      	cmp	Y, #7
    7940:	1914      	je	0x796a <_LIN2J_ErrorHandling+0x4e>
		/* Parity error in ID field received -or- Stop bit error of the ID field (SAE_J2602-2: 5.4.1.1) */
		{
			l_u8ErrorCommunication = TRUE;
		}
	}
	else if ( (Error == ml_erCheckSum) || (Error == ml_erDataFraming) )
    7942:	ec04      	cmp	Y, #4
    7944:	1902      	je	0x794a <_LIN2J_ErrorHandling+0x2e>
    7946:	ec06      	cmp	Y, #6
    7948:	1d0e      	jne	0x7966 <_LIN2J_ErrorHandling+0x4a>
	{
		/* Checksum error in message received -OR- Stop or Start bit error while receiving data (SAE_J2602-2: 5.4.1.2 & 5.4.1.3) */
		if ( (u8FrameID == (((g_u8NAD & 0x0Fu) << 2u) + 0x00u)) ||				/* CONTROL_MSG */
    794a:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
    794c:	72e6      	lod	A, Y
    794e:	b40f      	and	A, #15
    7950:	44a2      	asl	A, #2
    7952:	7e03      	lod	X, [S-4]
    7954:	2ee2      	cmp	X, A
    7956:	1909      	je	0x796a <_LIN2J_ErrorHandling+0x4e>
    7958:	6203      	lod	AL, [S-4]
    795a:	8c3c      	cmp	AL, #60
    795c:	1d0f      	jne	0x797c <_LIN2J_ErrorHandling+0x60>
    795e:	6108      	lod	AL, dp:0x8 <__bist_stat_size>
    7960:	8ee8      	cmp	AL, YL
    7962:	1d0c      	jne	0x797c <_LIN2J_ErrorHandling+0x60>
    7964:	0002      	jmp	0x796a <_LIN2J_ErrorHandling+0x4e>
			 ((u8FrameID == (uint8)ML_MRF_ID) && (LinFrame[0] == g_u8NAD)) )	/* DIAG_3C_MSG */
		{
			l_u8ErrorCommunication = TRUE;
		}
	}
	else if ( Error == ml_erSynchField )
    7966:	ec08      	cmp	Y, #8
    7968:	1d04      	jne	0x7972 <_LIN2J_ErrorHandling+0x56>
	{
		/* Sync field timing error;
		 * In case: BufferOutID is QR_RFR_DIAG, and NAD is real-NAD (SAE_J2602-2: 5.4.1.4) 
		 * 5.4.1.4 if auto baudrate , status byte is ignored 
		 */
		l_u8ErrorCommunication = TRUE;
    796a:	6001      	lod	AL, #1
    796c:	42d8 00ad 	mov	0xad <_l_u8ErrorCommunication>, AL
    7970:	5405      	ret	#6
	}
	else if ( Error == ml_erBit )
    7972:	ec05      	cmp	Y, #5
    7974:	1d03      	jne	0x797c <_LIN2J_ErrorHandling+0x60>
	{
		/* Data collision during the transmit cycle (SAE_J2602-2: 5.4.1.5) */
		l_u8ErrorCommunication = TRUE;
    7976:	6001      	lod	AL, #1
    7978:	42d8 00ad 	mov	0xad <_l_u8ErrorCommunication>, AL
    797c:	5405      	ret	#6

0000797e <_handleLinInMsg>:
/* ****************************************************************************	*
 *  LIN API: HandleLinInMsg 
 * ****************************************************************************	*/
void handleLinInMsg( void)
{
	if(l_u8LinInFrameBufState != C_LIN_IN_FREE)
    797e:	62d8 00ae 	lod	AL, 0xae <_l_u8LinInFrameBufState>
    7982:	191d      	je	0x79be <_handleLinInMsg+0x40>
    {
		if ( l_u8LinInFrameBufState == (uint8) C_LIN_IN_POSTPONE )
    7984:	8c02      	cmp	AL, #2
    7986:	1d03      	jne	0x798e <_handleLinInMsg+0x10>
		{
			/* Last message postponed; Try again (without overwritten by LIN message ISR */
			l_u8LinInFrameBufState = (uint8) C_LIN_IN_FULL;
    7988:	6001      	lod	AL, #1
    798a:	42d8 00ae 	mov	0xae <_l_u8LinInFrameBufState>, AL
		}

	    /* LIN 2.x,LIN 2.x_J2602 */
		if ( l_u8LinInFrameMsgID == (uint8) mlxDFR_DIAG )
    798e:	62d8 00f2 	lod	AL, 0xf2 <_l_u8LinInFrameMsgID>
    7992:	8c10      	cmp	AL, #16
    7994:	1d08      	jne	0x79a6 <_handleLinInMsg+0x28>
		{
#if ((LINPROT & LINXX) == LIN20) || ((LINPROT & LINXX) == LIN21)
       		Timer_Start(DIAG_RESPONSE_TIMER, (uint16)PI_TICKS_PER_SECOND);
    7996:	54ca 07d0 	pushw	#2000
    799a:	7006      	lod	A, #6
    799c:	82db 989a 	callf	0x989a <_Timer_Start>
#endif
			/* Diagnostic request frame */
			HandleDfrDiag();
    79a0:	135e      	call	0x805e <_HandleDfrDiag>
    79a2:	5c01      	dec	S, #2
    79a4:	0005      	jmp	0x79b0 <_handleLinInMsg+0x32>
		}
		else if ( l_u8LinInFrameMsgID == (uint8) MSG_CONTROL )
    79a6:	8c01      	cmp	AL, #1
    79a8:	1d03      	jne	0x79b0 <_handleLinInMsg+0x32>
		{
			/* Control */
			HandleActCfrCtrl((ACT_CFR_CTRL *)&g_LinCmdFrameBuffer);
    79aa:	72da 0028 	lod	A, #40
    79ae:	1400      	call	0x71b0 <_HandleActCfrCtrl>
		else
		{
			
		}

		if ( l_u8LinInFrameBufState != (uint8) C_LIN_IN_POSTPONE )
    79b0:	62d8 00ae 	lod	AL, 0xae <_l_u8LinInFrameBufState>
    79b4:	8c02      	cmp	AL, #2
    79b6:	1903      	je	0x79be <_handleLinInMsg+0x40>
		{
			/* LIN Message is handled; Release LIN message buffer */
			l_u8LinInFrameBufState = (uint8) C_LIN_IN_FREE;
    79b8:	6000      	lod	AL, #0
    79ba:	42d8 00ae 	mov	0xae <_l_u8LinInFrameBufState>, AL
    79be:	5401      	ret

000079c0 <_LIN_MainFunction>:
/* public function implementation */

/* LIN communication software component */
void LIN_MainFunction(void)
{
	switch(l_e8CommState)
    79c0:	62d8 00ac 	lod	AL, 0xac <_l_e8CommState>
    79c4:	5cf2      	usex	A
    79c6:	ac01      	cmp	A, #1
    79c8:	1909      	je	0x79dc <_LIN_MainFunction+0x1c>
    79ca:	1f03      	jsg	0x79d2 <_LIN_MainFunction+0x12>
    79cc:	ac00      	cmp	A, #0
    79ce:	1904      	je	0x79d8 <_LIN_MainFunction+0x18>
    79d0:	0008      	jmp	0x79e2 <_LIN_MainFunction+0x22>
    79d2:	ac02      	cmp	A, #2
    79d4:	1909      	je	0x79e8 <_LIN_MainFunction+0x28>
    79d6:	0005      	jmp	0x79e2 <_LIN_MainFunction+0x22>
	{
	case COMM_STATE_PREOPERATIONAL:     /* Pre-operational */
		l_e8CommState = COMM_STATE_OPERATIONAL;
    79d8:	6001      	lod	AL, #1
    79da:	0004      	jmp	0x79e4 <_LIN_MainFunction+0x24>
		break;
	case COMM_STATE_OPERATIONAL:    	/* operational */
		handleLinInMsg();
    79dc:	17d0      	call	0x797e <_handleLinInMsg>
#if _SUPPORT_LIN_BUS_ACTIVITY_CHECK
		handleMLX4StatusSupervisor();
    79de:	16ae      	call	0x773c <_handleMLX4StatusSupervisor>
#endif /* _SUPPORT_LIN_BUS_ACTIVITY_CHECK */
		break;
    79e0:	0003      	jmp	0x79e8 <_LIN_MainFunction+0x28>
	case COMM_STATE_STOPPED:    		/* sleep/timeout */
		
		break;
	default:
		l_e8CommState = COMM_STATE_PREOPERATIONAL;
    79e2:	6000      	lod	AL, #0
    79e4:	42d8 00ac 	mov	0xac <_l_e8CommState>, AL
		break;
	}

	handleNetworkManagement();
    79e8:	15f4      	call	0x75d2 <_handleNetworkManagement>
    79ea:	5401      	ret

000079ec <_mlu_AutoAddressingStep>:
/* ****************************************************************************	*
 *  LIN API event: mlu_AutoAddressingStep
 * ****************************************************************************	*/
void mlu_AutoAddressingStep( ml_uint8 StepNumber)
{
	(void) StepNumber; 
    79ec:	5401      	ret

000079ee <_SetupDiagResponse>:

/* ****************************************************************************	*
 * SetupDiagResponse
 * ****************************************************************************	*/
void SetupDiagResponse( uint8 u8NAD, uint8 u8SID, uint8 u8ResponseCode)
{
    79ee:	5801      	inc	S, #2
    79f0:	6605      	lod	YL, [S-6]
    79f2:	5cf6      	usex	Y
    79f4:	5a01      	mov	[S-2], Y
    79f6:	6607      	lod	YL, [S-8]
    79f8:	5cf6      	usex	Y
	g_DiagResponse.byNAD = u8NAD;
    79fa:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
	if ( u8ResponseCode == (uint8) C_ERRCODE_POSITIVE_RESPONSE )
    79fc:	1d09      	jne	0x7a10 <_SetupDiagResponse+0x22>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x01|  SID | Reserved | Reserved | Reserved | Reserved | Reserved |
		 *	|  NAD  |     | |0x40|   0xFF   |   0xFF   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_REASSIGN_NAD;
    79fe:	6001      	lod	AL, #1
    7a00:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (u8SID | C_RSID_OK);
    7a02:	6201      	lod	AL, [S-2]
    7a04:	8440      	or	AL, #64
    7a06:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    7a08:	60ff      	lod	AL, #-1
    7a0a:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;								/* Clear Pending feedback (MMP151130-1) */
    7a0c:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    7a0e:	0007      	jmp	0x7a1e <_SetupDiagResponse+0x30>
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 *	|Initial| 0x03| 0x7F | Requested| Response | Reserved | Reserved | Reserved |
		 *	|  NAD  |     |      |    SID   |   Code   |   0xFF   |   0xFF   |   0xFF   |
		 *	+-------+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byPCI = (uint8) C_RPCI_NOK;
    7a10:	6003      	lod	AL, #3
    7a12:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_RSID_NOK;
    7a14:	607f      	lod	AL, #127
    7a16:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = u8SID;
    7a18:	6201      	lod	AL, [S-2]
    7a1a:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = u8ResponseCode;
    7a1c:	4534      	mov	dp:0x34 <_g_DiagResponse+0x4>, YL
	}

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    7a1e:	6007      	lod	AL, #7
    7a20:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7a22:	5403      	ret	#4

00007a24 <_CheckSupplier>:
/* ****************************************************************************	*
 * CheckSupplier
 * ****************************************************************************	*/
uint16 CheckSupplier( uint16 const u16SupplierID)
{
	uint16 u16Result = FALSE;
    7a24:	7800      	lod	Y, #0
	if ( (u16SupplierID == (uint16) C_WILDCARD_SUPPLIER_ID)
    7a26:	aeda 7fff 	cmp	A, #32767
    7a2a:	1902      	je	0x7a30 <_CheckSupplier+0xc>
    7a2c:	ac13      	cmp	A, #19
    7a2e:	1d01      	jne	0x7a32 <_CheckSupplier+0xe>
		|| (u16SupplierID == (uint16)C_SUPPLIER_ID) )
	{
		u16Result = TRUE;
    7a30:	7801      	lod	Y, #1
	}
	return ( u16Result );
} /* End of CheckSupplier() */
    7a32:	72e6      	lod	A, Y
    7a34:	5401      	ret

00007a36 <_ValidSupplierFunctionID>:
 * Pre:		Pointer to address of supplier and function ID
 * Post:	FALSE: Incorrect supplier and/or function ID
 *			TRUE: Correct supplier and function ID
 * ****************************************************************************	*/
uint16 ValidSupplierFunctionID( uint16 const u16SupplierID, uint16 const u16FunctionID )
{
    7a36:	7a03      	lod	Y, [S-4]
	uint16 u16Result = FALSE;
    7a38:	7c00      	lod	X, #0
	if ( ((u16SupplierID == C_SUPPLIER_ID)
    7a3a:	ac13      	cmp	A, #19
    7a3c:	1903      	je	0x7a44 <_ValidSupplierFunctionID+0xe>
    7a3e:	aeda 7fff 	cmp	A, #32767
    7a42:	1d05      	jne	0x7a4e <_ValidSupplierFunctionID+0x18>
    7a44:	ec16      	cmp	Y, #22
    7a46:	1902      	je	0x7a4c <_ValidSupplierFunctionID+0x16>
    7a48:	ecff      	cmp	Y, #-1
    7a4a:	1d01      	jne	0x7a4e <_ValidSupplierFunctionID+0x18>
		|| (u16SupplierID == C_WILDCARD_SUPPLIER_ID)) &&
		((u16FunctionID == C_FUNCTION_ID)
		|| (u16FunctionID == C_WILDCARD_FUNCTION_ID)) )
	{
		u16Result = TRUE;
    7a4c:	7c01      	lod	X, #1
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */
    7a4e:	72ee      	lod	A, X
    7a50:	5401      	ret

00007a52 <_handleReassignNAD>:
} /* End of StoreD2to5() */



void handleReassignNAD(const DFR_DIAG *pDiag)
{
    7a52:	5803      	inc	S, #4
    7a54:	5203      	mov	[S-4], A
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xB0 | Supplier | Supplier | Function | Function |  New NAD |
	 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |          |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 */
	if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u), (pDiag->byD3) | ((uint16)(pDiag->byD4) << 8u)) != FALSE)
    7a56:	7a03      	lod	Y, [S-4]
    7a58:	62f5      	lod	AL, [Y+5]
    7a5a:	5cf2      	usex	A
    7a5c:	7ee2      	lod	X, A
    7a5e:	6af6      	lod	AH, [Y+6]
    7a60:	6000      	lod	AL, #0
    7a62:	26e2      	or	X, A
    7a64:	6af4      	lod	AH, [Y+4]
    7a66:	62f3      	lod	AL, [Y+3]
    7a68:	5edf      	push	X
    7a6a:	17e5      	call	0x7a36 <_ValidSupplierFunctionID>
    7a6c:	5c01      	dec	S, #2
    7a6e:	ac00      	cmp	A, #0
    7a70:	190b      	je	0x7a88 <_handleReassignNAD+0x36>
		buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
		(void)NVRAM_Write(0x1000, buf, 2);
#endif
			/* J2602,LIN2.0:automatic save confifuration */
#if ( (LINPROT & LINXX) == LIN21 )
		g_u8NAD = pDiag->byD5;
    7a72:	7a03      	lod	Y, [S-4]
    7a74:	62f7      	lod	AL, [Y+7]
    7a76:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
		SetupDiagResponse( C_DEFAULT_NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
    7a78:	54ca 0000 	pushw	#0
    7a7c:	62f2      	lod	AL, [Y+2]
    7a7e:	5cf2      	usex	A
    7a80:	52df      	push	A
    7a82:	7016      	lod	A, #22
    7a84:	17b4      	call	0x79ee <_SetupDiagResponse>
    7a86:	5c03      	dec	S, #4
    7a88:	5405      	ret	#6

00007a8a <_handleAssignFrameID>:

	}
}

void handleAssignFrameID(const DFR_DIAG *pDiag)
{
    7a8a:	5805      	inc	S, #6
    7a8c:	5201      	mov	[S-2], A
	 *	| NAD | 0x06| 0xB1| Supplier | Supplier |  Message |  Message |   Frame  |
	 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 * Only LIN 2.0 (Obsolete in LIN 2.1)
	 */
	if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u)) != FALSE )
    7a8e:	7a01      	lod	Y, [S-2]
    7a90:	6af4      	lod	AH, [Y+4]
    7a92:	62f3      	lod	AL, [Y+3]
    7a94:	17c7      	call	0x7a24 <_CheckSupplier>
    7a96:	ac00      	cmp	A, #0
    7a98:	1d01      	jne	0x7a9c <_handleAssignFrameID+0x12>
    7a9a:	0042      	jmp	0x7b20 <_handleAssignFrameID+0x96>
	{
		wMessageID = ((uint16) pDiag->byD4 << 8u) | ((uint16) pDiag->byD3);
    7a9c:	7e01      	lod	X, [S-2]
    7a9e:	6efe      	lod	YH, [X+6]
    7aa0:	66fd      	lod	YL, [X+5]
		if ( wMessageID == MSG_CONTROL )
    7aa2:	ec01      	cmp	Y, #1
    7aa4:	1d09      	jne	0x7ab8 <_handleAssignFrameID+0x2e>
		{
			g_u8ControlFrameID = pDiag->byD5;
    7aa6:	62ff      	lod	AL, [X+7]
    7aa8:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
			(void) ml_Disconnect();
    7aaa:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7aae:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7ab0:	5cf2      	usex	A
    7ab2:	52df      	push	A
    7ab4:	7001      	lod	A, #1
    7ab6:	000b      	jmp	0x7ace <_handleAssignFrameID+0x44>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
			(void)NVRAM_Write(0x1000, buf, 2);
		}
		else if ( wMessageID == MSG_STATUS )
    7ab8:	ec00      	cmp	Y, #0
    7aba:	1d28      	jne	0x7b0c <_handleAssignFrameID+0x82>
		{
			g_u8StatusFrameID = pDiag->byD5;
    7abc:	7a01      	lod	Y, [S-2]
    7abe:	62f7      	lod	AL, [Y+7]
    7ac0:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
			(void) ml_Disconnect();
    7ac2:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7ac6:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7ac8:	5cf2      	usex	A
    7aca:	52df      	push	A
    7acc:	7000      	lod	A, #0
    7ace:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
			(void) ml_Connect();
    7ad2:	82db 5b96 	callf	0x5b96 <_ml_Connect>
			/* Status Frame-ID changed */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);	/* Status = Positive feedback */
    7ad6:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ad8:	5cf2      	usex	A
    7ada:	54ca 0000 	pushw	#0
    7ade:	7e05      	lod	X, [S-6]
    7ae0:	66fa      	lod	YL, [X+2]
    7ae2:	5cf6      	usex	Y
    7ae4:	5adf      	push	Y
    7ae6:	1783      	call	0x79ee <_SetupDiagResponse>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7ae8:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7aea:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7aec:	520b      	mov	[S-12], A
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7aee:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7af0:	a6da ff00 	or	A, #65280
    7af4:	5209      	mov	[S-10], A
			(void)NVRAM_Write(0x1000, buf, 2);
    7af6:	54ca 0002 	pushw	#2
    7afa:	72ef      	lod	A, S
    7afc:	a0f2      	add	A, #-14
    7afe:	52df      	push	A
    7b00:	72da 1000 	lod	A, #4096
    7b04:	82db 933a 	callf	0x933a <_NVRAM_Write>
    7b08:	5c09      	dec	S, #10
    7b0a:	5407      	ret	#8
		}
		else
		{
			/* Wrong Message-ID */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    7b0c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b0e:	5cf2      	usex	A
    7b10:	54ca 0012 	pushw	#18
    7b14:	7e03      	lod	X, [S-4]
    7b16:	66fa      	lod	YL, [X+2]
    7b18:	5cf6      	usex	Y
    7b1a:	5adf      	push	Y
    7b1c:	1768      	call	0x79ee <_SetupDiagResponse>
    7b1e:	5c03      	dec	S, #4
    7b20:	5407      	ret	#8

00007b22 <_handleReadByIdentifier>:
		}
	}
}

void handleReadByIdentifier(const DFR_DIAG *pDiag)
{
    7b22:	5803      	inc	S, #4
    7b24:	5203      	mov	[S-4], A
	 * (0x40-0xFF: Reserved)
	 * (M) = Mandatory
	 * (O) = Optional
	 * (U) = User defined
	 */
	if ( ValidSupplierFunctionID( (pDiag->byD2) | ((uint16)(pDiag->byD3) << 8u), (pDiag->byD4) | ((uint16)(pDiag->byD5) << 8u)) != FALSE )
    7b26:	7a03      	lod	Y, [S-4]
    7b28:	62f6      	lod	AL, [Y+6]
    7b2a:	5cf2      	usex	A
    7b2c:	7ee2      	lod	X, A
    7b2e:	6af7      	lod	AH, [Y+7]
    7b30:	6000      	lod	AL, #0
    7b32:	26e2      	or	X, A
    7b34:	6af5      	lod	AH, [Y+5]
    7b36:	62f4      	lod	AL, [Y+4]
    7b38:	5edf      	push	X
    7b3a:	177d      	call	0x7a36 <_ValidSupplierFunctionID>
    7b3c:	5c01      	dec	S, #2
    7b3e:	ac00      	cmp	A, #0
    7b40:	1d01      	jne	0x7b44 <_handleReadByIdentifier+0x22>
    7b42:	0082      	jmp	0x7c48 <_handleReadByIdentifier+0x126>
	{
		if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    7b44:	7e03      	lod	X, [S-4]
    7b46:	62fb      	lod	AL, [X+3]
    7b48:	1d0b      	jne	0x7b60 <_handleReadByIdentifier+0x3e>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xF2 | Supplier | Supplier | Function | Function |  Variant |
			 *	|     |     |      | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |    ID    |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7b4a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b4c:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
    7b4e:	6006      	lod	AL, #6
    7b50:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7b52:	60f2      	lod	AL, #-14
    7b54:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* (MMP160613-3) */
    7b56:	60ff      	lod	AL, #-1
    7b58:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7b5a:	7013      	lod	A, #19
    7b5c:	7816      	lod	Y, #22
    7b5e:	0026      	jmp	0x7bac <_handleReadByIdentifier+0x8a>
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_00;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			g_DiagResponse.byD5 = (uint8) C_VARIANT;	/* (MMP160613-3) */
			StoreD1to4( C_SUPPLIER_ID, C_FUNCTION_ID);					/* Supplier & Function-ID */
		}
		else if ( pDiag->byD1 == C_SERIAL_NR_ID )
    7b60:	8c01      	cmp	AL, #1
    7b62:	1d0e      	jne	0x7b80 <_handleReadByIdentifier+0x5e>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x05| 0xF2 | SerialNr | SerialNr | SerialNr | SerialNr | Reserved |
			 *	|     |     |      |   (LSB)  |		     |          |   (MSB)  |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7b64:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b66:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
    7b68:	6005      	lod	AL, #5
    7b6a:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7b6c:	60f2      	lod	AL, #-14
    7b6e:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7b70:	7800      	lod	Y, #0
	__asm__ __volatile__
    7b72:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7b74:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7b76:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    7b78:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    7b7a:	6007      	lod	AL, #7
    7b7c:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7b7e:	5405      	ret	#6
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_01;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SERIAL_NO_LSW, C_SERIAL_NO_MSW);	/* Serial-number */
		}
		else if ( pDiag->byD1 == (uint8) C_SVN_ID )
    7b80:	8c30      	cmp	AL, #48
    7b82:	1d09      	jne	0x7b96 <_handleReadByIdentifier+0x74>
		{
			g_DiagResponse.byNAD = g_u8NAD;
    7b84:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b86:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
    7b88:	6005      	lod	AL, #5
    7b8a:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7b8c:	60f2      	lod	AL, #-14
    7b8e:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7b90:	72da 0304 	lod	A, #772
    7b94:	000a      	jmp	0x7baa <_handleReadByIdentifier+0x88>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_30;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SVN, 0xFFFFU);											/* Firmware SVN */
		}
		else if( pDiag->byD1 == (uint8) C_SW_VER_ID )
    7b96:	8c32      	cmp	AL, #50
    7b98:	1d0e      	jne	0x7bb6 <_handleReadByIdentifier+0x94>
		{
			g_DiagResponse.byNAD = g_u8NAD;
    7b9a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7b9c:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_32;
    7b9e:	6005      	lod	AL, #5
    7ba0:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7ba2:	60f2      	lod	AL, #-14
    7ba4:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    7ba6:	72da 0c04 	lod	A, #3076
    7baa:	78ff      	lod	Y, #-1
	__asm__ __volatile__
    7bac:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7bae:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7bb0:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    7bb2:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
    7bb4:	07e2      	jmp	0x7b7a <_handleReadByIdentifier+0x58>
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_32;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to4( C_SW_VER, 0xFFFFU);											/* Firmware Software version */
		}
#if ((LINPROT & LINXX) == LIN21)
		else if ( pDiag->byD1 == (uint8) C_VERIFY_NAD )
    7bb6:	8c21      	cmp	AL, #33
    7bb8:	1d0c      	jne	0x7bd2 <_handleReadByIdentifier+0xb0>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x04| 0xF2 |    NAD   |  Control |  Status  | Reserved | Reserved |
			 *	|     |     |      |   NVRAM  | Frame ID | Frame ID |		   |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7bba:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
    7bbc:	4530      	mov	dp:0x30 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_21;
    7bbe:	6004      	lod	AL, #4
    7bc0:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7bc2:	60f2      	lod	AL, #-14
    7bc4:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = (uint8) g_u8NAD;						/* Stored NAD (NVRAM) */
    7bc6:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
			g_DiagResponse.byD2 = (uint8) g_u8ControlFrameID;	/* Frame-ID for Control-message */
    7bc8:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7bca:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
			g_DiagResponse.byD3 = (uint8) g_u8StatusFrameID;	/* Frame-ID for Status-message */
    7bcc:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7bce:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
    7bd0:	07d4      	jmp	0x7b7a <_handleReadByIdentifier+0x58>
			g_u8BufferOutID = (uint8) QR_RFR_DIAG;						/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( pDiag->byD1 == (uint8) C_SW_HW_REF )
    7bd2:	8c2a      	cmp	AL, #42
    7bd4:	1d0b      	jne	0x7bec <_handleReadByIdentifier+0xca>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 | Software | Hardware | Reserved | Reserved | Reserved |
			 *	|     |     |      |  Ref. ID |  Ref. ID |          |	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7bd6:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7bd8:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_2A;
    7bda:	6003      	lod	AL, #3
    7bdc:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7bde:	60f2      	lod	AL, #-14
    7be0:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
			g_DiagResponse.byD1 = (uint8) C_SW_REF;					/* SW-reference */
    7be2:	6089      	lod	AL, #-119
    7be4:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
			g_DiagResponse.byD2 = (uint8) C_HW_REF;					/* HW-reference */
    7be6:	6010      	lod	AL, #16
    7be8:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    7bea:	07c7      	jmp	0x7b7a <_handleReadByIdentifier+0x58>
			g_u8BufferOutID = (uint8) QR_RFR_DIAG;					/* LIN Output buffer is valid (RFR_DIAG) */
		}
		else if ( pDiag->byD1 == (uint8) C_MLX_HW_SW_REF )
    7bec:	8c3c      	cmp	AL, #60
    7bee:	1d0a      	jne	0x7c04 <_handleReadByIdentifier+0xe2>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 |  Chip HW |  Chip SW | Reserved | Reserved | Reserved |
			 *	|     |     |      |    ID    |    ID    |          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7bf0:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7bf2:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3C;
    7bf4:	6003      	lod	AL, #3
    7bf6:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7bf8:	60f2      	lod	AL, #-14
    7bfa:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7bfc:	7ada 1182 	lod	Y, #4482
    7c00:	72f0      	lod	A, [Y]
    7c02:	0015      	jmp	0x7c2e <_handleReadByIdentifier+0x10c>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3C;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to2( *((uint16 *) C_ADDR_MLX_HWSWID));				/* Chip HW/SW-ID */
		}
		else if ( pDiag->byD1 == (uint8) C_LIN_CUST_ID )
    7c04:	8c3d      	cmp	AL, #61
    7c06:	1d09      	jne	0x7c1a <_handleReadByIdentifier+0xf8>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 | Customer | Customer | Reserved | Reserved | Reserved |
			 *	|     |     |      | ID (LSB) | ID (MSB) |          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c08:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7c0a:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3D;
    7c0c:	6003      	lod	AL, #3
    7c0e:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c10:	60f2      	lod	AL, #-14
    7c12:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7c14:	72da 1000 	lod	A, #4096
    7c18:	000a      	jmp	0x7c2e <_handleReadByIdentifier+0x10c>
    7c1a:	651b      	lod	YL, dp:0x1b <_g_u8NAD>
			g_DiagResponse.byNAD = g_u8NAD;
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3D;
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
			StoreD1to2( C_CUSTOMER_ID );						/* Customer-ID */
		}
		else if ( pDiag->byD1 == (uint8) C_PROD_DATE )
    7c1c:	8c3e      	cmp	AL, #62
    7c1e:	1d0a      	jne	0x7c34 <_handleReadByIdentifier+0x112>
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 *	| NAD | 0x03| 0xF2 |Production|Production| Reserved | Reserved | Reserved |
			 *	|     |     |      |Date (LSB)|Date (MSB)|          | 	       |          |
			 *	+-----+-----+------+----------+----------+----------+----------+----------+
			 */
			g_DiagResponse.byNAD = g_u8NAD;
    7c20:	4530      	mov	dp:0x30 <_g_DiagResponse>, YL
			g_DiagResponse.byPCI = (uint8) C_RPCI_READ_BY_ID_3E;
    7c22:	6003      	lod	AL, #3
    7c24:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
			g_DiagResponse.byRSID = (uint8) C_RSID_READ_BY_ID;
    7c26:	60f2      	lod	AL, #-14
    7c28:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	}
	return ( u16Result );
} /* End of ValidSupplierFunctionID() */

static __inline__ void StoreD1to2( uint16 a)
{
    7c2a:	72da 100c 	lod	A, #4108
	__asm__ __volatile__
    7c2e:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    7c30:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    7c32:	07a3      	jmp	0x7b7a <_handleReadByIdentifier+0x58>
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else
		{
			/* Identifier not supported */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    7c34:	62e8      	lod	AL, YL
    7c36:	5cf2      	usex	A
    7c38:	54ca 0012 	pushw	#18
    7c3c:	7e05      	lod	X, [S-6]
    7c3e:	66fa      	lod	YL, [X+2]
    7c40:	5cf6      	usex	Y
    7c42:	5adf      	push	Y
    7c44:	16d4      	call	0x79ee <_SetupDiagResponse>
    7c46:	5c03      	dec	S, #4
    7c48:	5405      	ret	#6

00007c4a <_handleConditionalChangeNAD>:
			
}

/* not supported */
void handleConditionalChangeNAD(const DFR_DIAG *pDiag)
{
    7c4a:	5807      	inc	S, #8
    7c4c:	7ee2      	lod	X, A
	 */
	/* Get the identifier of possible read by ID response and selected by Id */
	/* Extract the data byte selected by Byte */
	uint16 buf[2];
	uint8 u8SerialNo[4];
	uint8 u8DataByte = 0x00;
    7c4e:	7800      	lod	Y, #0
	uint8 u8Error = (uint8) C_ERR_NONE;
	
	if ( pDiag->byD1 == 0x00u ) /* Requested Id = LIN Product Identification */
    7c50:	62fb      	lod	AL, [X+3]
    7c52:	1d13      	jne	0x7c7a <_handleConditionalChangeNAD+0x30>
	{
		if ( pDiag->byD2 == 1u )
    7c54:	62fc      	lod	AL, [X+4]
    7c56:	8c01      	cmp	AL, #1
    7c58:	1d02      	jne	0x7c5e <_handleConditionalChangeNAD+0x14>
		{
			u8DataByte = (uint8) ((uint16)C_SUPPLIER_ID & 0xFFu);				/* LSB of Supplier-ID */
    7c5a:	7813      	lod	Y, #19
    7c5c:	0037      	jmp	0x7ccc <_handleConditionalChangeNAD+0x82>
		}
		else if ( pDiag->byD2 == 2u )
    7c5e:	8c02      	cmp	AL, #2
    7c60:	1d01      	jne	0x7c64 <_handleConditionalChangeNAD+0x1a>
    7c62:	0034      	jmp	0x7ccc <_handleConditionalChangeNAD+0x82>
		{
			u8DataByte = (uint8) ((uint16)C_SUPPLIER_ID >> 8u);					/* MSB of Supplier-ID */
		}
		else if ( pDiag->byD2 == 3u )
    7c64:	8c03      	cmp	AL, #3
    7c66:	1d02      	jne	0x7c6c <_handleConditionalChangeNAD+0x22>
		{
			u8DataByte = (uint8) ((uint16)C_FUNCTION_ID & 0xFFu);				/* LSB of Function-ID */
    7c68:	7816      	lod	Y, #22
    7c6a:	0030      	jmp	0x7ccc <_handleConditionalChangeNAD+0x82>
		}
		else if ( pDiag->byD2 == 4u )
    7c6c:	8c04      	cmp	AL, #4
    7c6e:	192e      	je	0x7ccc <_handleConditionalChangeNAD+0x82>
		{
			u8DataByte = (uint8) ((uint16)C_FUNCTION_ID >> 8u); 					/*lint !e572 */	/* MSB of Function-ID */
		}
		else if ( pDiag->byD2 == 5u )
    7c70:	8c05      	cmp	AL, #5
    7c72:	1d0a      	jne	0x7c88 <_handleConditionalChangeNAD+0x3e>
		{
			u8DataByte = C_VARIANT;
    7c74:	7ada 00ff 	lod	Y, #255
    7c78:	0029      	jmp	0x7ccc <_handleConditionalChangeNAD+0x82>
		else
		{
			u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ; 				/* Selected byte not in range, not valid => no response */
		}
	}
	else if ( pDiag->byD1 == 0x01u ) 									/* Requested Id = Serial number (optional) */
    7c7a:	8c01      	cmp	AL, #1
    7c7c:	1d1a      	jne	0x7cb2 <_handleConditionalChangeNAD+0x68>
	{
		if ( (pDiag->byD2 == 0u) || (pDiag->byD2 > 4u) )
    7c7e:	66fc      	lod	YL, [X+4]
    7c80:	62e8      	lod	AL, YL
    7c82:	80ff      	add	AL, #-1
    7c84:	8c03      	cmp	AL, #3
    7c86:	1a05      	jule	0x7c92 <_handleConditionalChangeNAD+0x48>
		{
			/* Selected byte not in range, not valid => no response */
			u8Error = (uint8) C_ERRCODE_INV_MSG_INV_SZ; 				/* Status = Invalid Format */
    7c88:	4cd3      	swap	D
    7c8a:	48cf      	asl	D, #16
    7c8c:	4c0a 0013 	addu	D, #19
    7c90:	0014      	jmp	0x7cba <_handleConditionalChangeNAD+0x70>
		}
		else
		{
			u8SerialNo[0] = (uint8)C_SERIAL_NO_LSW;
    7c92:	6000      	lod	AL, #0
    7c94:	4207      	mov	[S-8], AL
			u8SerialNo[1] = (uint8)((uint16)C_SERIAL_NO_LSW >> 8u);
    7c96:	4206      	mov	[S-7], AL
			u8SerialNo[2] = (uint8)C_SERIAL_NO_MSW;
    7c98:	4205      	mov	[S-6], AL
			u8SerialNo[3] = (uint8)((uint16)C_SERIAL_NO_MSW >> 8u);
    7c9a:	4204      	mov	[S-5], AL
			
			u8DataByte = u8SerialNo[pDiag->byD2 - 1u]; 					/* Serial-number[n] */
    7c9c:	62e8      	lod	AL, YL
    7c9e:	5cf2      	usex	A
    7ca0:	7aef      	lod	Y, S
    7ca2:	e0f8      	add	Y, #-8
    7ca4:	a2e6      	add	A, Y
    7ca6:	7ae2      	lod	Y, A
    7ca8:	e0ff      	add	Y, #-1
    7caa:	62f0      	lod	AL, [Y]
    7cac:	66e0      	lod	YL, AL
    7cae:	5cf6      	usex	Y
    7cb0:	000d      	jmp	0x7ccc <_handleConditionalChangeNAD+0x82>
		}
	}
	else
	{
		/* Identifier not supported */
		u8Error = (uint8) C_ERRCODE_SFUNC_NOSUP;						/* Status = Negative feedback */
    7cb2:	4cd3      	swap	D
    7cb4:	48cf      	asl	D, #16
    7cb6:	4c0a 0012 	addu	D, #18
	}

	if ( u8Error != (uint8) C_ERR_NONE )
	{
		SetupDiagResponse( g_u8NAD, pDiag->bySID, u8Error);
    7cba:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7cbc:	5cf2      	usex	A
    7cbe:	4c8b      	push	DL
    7cc0:	66fa      	lod	YL, [X+2]
    7cc2:	5cf6      	usex	Y
    7cc4:	5adf      	push	Y
    7cc6:	1693      	call	0x79ee <_SetupDiagResponse>
    7cc8:	5c03      	dec	S, #4
    7cca:	5409      	ret	#10
	}
	else
	{
		/* Do a bitwise XOR with Invert */
		u8DataByte ^= pDiag->byD4;
    7ccc:	62fe      	lod	AL, [X+6]
    7cce:	9ee8      	xor	AL, YL

		/* Do a bitwise AND with Mask */
		u8DataByte &= pDiag->byD3;
    7cd0:	96fd      	and	AL, [X+5]

		if ( u8DataByte == 0u )												/* Condition PASSED */
    7cd2:	1d1a      	jne	0x7d08 <_handleConditionalChangeNAD+0xbe>
		{
			uint8 byInitialNAD = g_u8NAD;
			g_u8NAD = pDiag->byD5;
    7cd4:	62ff      	lod	AL, [X+7]
    7cd6:	411b      	mov	dp:0x1b <_g_u8NAD>, AL
			/* NAD changed */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE); /* Status = Positive feedback */
    7cd8:	5cf2      	usex	A
    7cda:	54ca 0000 	pushw	#0
    7cde:	66fa      	lod	YL, [X+2]
    7ce0:	5cf6      	usex	Y
    7ce2:	5adf      	push	Y
    7ce4:	1684      	call	0x79ee <_SetupDiagResponse>
			/* Store NVRAM */
			buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7ce6:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7ce8:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7cea:	5207      	mov	[S-8], A
			buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7cec:	7aef      	lod	Y, S
    7cee:	e0f8      	add	Y, #-8
    7cf0:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7cf2:	a6da ff00 	or	A, #65280
    7cf6:	5205      	mov	[S-6], A
			(void)NVRAM_Write(0x1000, buf, 2);
    7cf8:	54ca 0002 	pushw	#2
    7cfc:	5adf      	push	Y
    7cfe:	72da 1000 	lod	A, #4096
    7d02:	82db 933a 	callf	0x933a <_NVRAM_Write>
    7d06:	5c07      	dec	S, #8
    7d08:	5409      	ret	#10

00007d0a <_handleDataDump>:

}

/* not supported */
void handleDataDump(const DFR_DIAG *pDiag)
{
    7d0a:	5805      	inc	S, #6
    7d0c:	5201      	mov	[S-2], A
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xB4| Supplier | Supplier |  Variant |  HW-Ref  |  SW-Ref  |
	 *	|	  | 	|	  | ID (LSB) | ID (MSB) |	 ID    |	ID	  |    ID	 |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 */
	if ( CheckSupplier( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u)) != FALSE)
    7d0e:	7a01      	lod	Y, [S-2]
    7d10:	6af4      	lod	AH, [Y+4]
    7d12:	62f3      	lod	AL, [Y+3]
    7d14:	1687      	call	0x7a24 <_CheckSupplier>
    7d16:	ac00      	cmp	A, #0
    7d18:	1d01      	jne	0x7d1c <_handleDataDump+0x12>
    7d1a:	003e      	jmp	0x7d98 <_handleDataDump+0x8e>
	{
		(void)NVRAM_Read(0x1001,buf,2);										/* little endian or big endian */
    7d1c:	54ca 0002 	pushw	#2
    7d20:	7eef      	lod	X, S
    7d22:	20f8      	add	X, #-8
    7d24:	5edf      	push	X
    7d26:	72da 1001 	lod	A, #4097
    7d2a:	82db 92ae 	callf	0x92ae <_NVRAM_Read>
		if ( pDiag->byD3 != 0xFFu )
    7d2e:	7e05      	lod	X, [S-6]
    7d30:	66fd      	lod	YL, [X+5]
    7d32:	5c03      	dec	S, #4
    7d34:	62e8      	lod	AL, YL
    7d36:	8cff      	cmp	AL, #-1
    7d38:	1906      	je	0x7d46 <_handleDataDump+0x3c>
		{
			buf[0] = (buf[0] & 0xFF00u) | (pDiag->byD3);					/* Set new Variant-ID */
    7d3a:	7205      	lod	A, [S-6]
    7d3c:	b6da ff00 	and	A, #65280
    7d40:	5cf6      	usex	Y
    7d42:	a6e6      	or	A, Y
    7d44:	5205      	mov	[S-6], A
		}
		
		if ( pDiag->byD4 != 0xFFu )
    7d46:	7a01      	lod	Y, [S-2]
    7d48:	62f6      	lod	AL, [Y+6]
    7d4a:	8cff      	cmp	AL, #-1
    7d4c:	1907      	je	0x7d5c <_handleDataDump+0x52>
		{
			buf[1] = (buf[1] & 0x00FFu) | ((uint16)pDiag->byD4 << 8u);										/* Set new HW-Reference */
    7d4e:	7a03      	lod	Y, [S-4]
    7d50:	f6da 00ff 	and	Y, #255
    7d54:	6800      	lod	AH, #0
    7d56:	72e4      	swap	A
    7d58:	e6e2      	or	Y, A
    7d5a:	5a03      	mov	[S-4], Y
		}

		if ( pDiag->byD5 != 0xFFu )
    7d5c:	7e01      	lod	X, [S-2]
    7d5e:	66ff      	lod	YL, [X+7]
    7d60:	62e8      	lod	AL, YL
    7d62:	8cff      	cmp	AL, #-1
    7d64:	1906      	je	0x7d72 <_handleDataDump+0x68>
		{
			/* -=#=- Note: SW-Ref should not be changed by this function, but be reprogramming the flash */
			 buf[2] = (buf[1] & 0xFF00u) | (pDiag->byD5); 										/* Set new SW-Reference */
    7d66:	7203      	lod	A, [S-4]
    7d68:	b6da ff00 	and	A, #65280
    7d6c:	5cf6      	usex	Y
    7d6e:	a6e6      	or	A, Y
    7d70:	5201      	mov	[S-2], A
		}
		/* Variant-ID and/or HW-reference and/or SW-reference changed */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE); /* Status = Positive feedback */
    7d72:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7d74:	5cf2      	usex	A
    7d76:	54ca 0000 	pushw	#0
    7d7a:	7e03      	lod	X, [S-4]
    7d7c:	66fa      	lod	YL, [X+2]
    7d7e:	5cf6      	usex	Y
    7d80:	5adf      	push	Y
    7d82:	1635      	call	0x79ee <_SetupDiagResponse>
		/* Store NVRAM */
		(void)NVRAM_Write(0x1000, buf, 2);
    7d84:	54ca 0002 	pushw	#2
    7d88:	72ef      	lod	A, S
    7d8a:	a0f4      	add	A, #-12
    7d8c:	52df      	push	A
    7d8e:	72da 1000 	lod	A, #4096
    7d92:	82db 933a 	callf	0x933a <_NVRAM_Write>
    7d96:	5c07      	dec	S, #8
    7d98:	5407      	ret	#8

00007d9a <_handleTargetReset>:
}

void handleTargetReset(const DFR_DIAG *pDiag)
{
	/* Reset Target */
	MLX4_RESET();														/* Reset the Mlx4	*/
    7d9a:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    7d9e:	94fe      	and	AL, #-2
    7da0:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
	bistResetInfo = C_CHIP_STATE_LIN_CMD_RESET;
    7da4:	72da 3072 	lod	A, #12402
    7da8:	52d8 01a8 	mov	0x1a8 <_bistResetInfo>, A
	MLX16_RESET();														/* Reset the Mlx16	*/
    7dac:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    7db0:	5401      	ret

00007db2 <_handleSaveConfig>:
	/* This reset restart the chip as POR, and doesn't come back (no answer) */

}

void handleSaveConfig(const DFR_DIAG *pDiag)
{
    7db2:	5803      	inc	S, #4
    7db4:	7ae2      	lod	Y, A
	 *	| NAD | 0x01| 0xB6| 0xFF | 0xFF |  0xFF |  0xFF  |  0xFF |
	 *	+-----+-----+-----+----------+----------+----------+----------+----------+
	 *	Only LIN 2.1
	 */
	/* LIN2.1:After reception of the service and the NAD is correct the slave node shall response(not wait until the configuration is saved) */
	SetupDiagResponse( C_DEFAULT_NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    7db6:	54ca 0000 	pushw	#0
    7dba:	62f2      	lod	AL, [Y+2]
    7dbc:	5cf2      	usex	A
    7dbe:	52df      	push	A
    7dc0:	7016      	lod	A, #22
    7dc2:	1615      	call	0x79ee <_SetupDiagResponse>
	/* store to NVRAM */
	buf[0] = (uint16)g_u8NAD | ((uint16)g_u8ControlFrameID << 8u);
    7dc4:	691a      	lod	AH, dp:0x1a <_g_u8ControlFrameID>
    7dc6:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7dc8:	5207      	mov	[S-8], A
	buf[1] = (uint16)g_u8StatusFrameID | ((uint16)C_VARIANT << 8u);
    7dca:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7dcc:	a6da ff00 	or	A, #65280
    7dd0:	5205      	mov	[S-6], A
	(void)NVRAM_Write(0x1000, buf, 2);
    7dd2:	54ca 0002 	pushw	#2
    7dd6:	72ef      	lod	A, S
    7dd8:	a0f6      	add	A, #-10
    7dda:	52df      	push	A
    7ddc:	72da 1000 	lod	A, #4096
    7de0:	82db 933a 	callf	0x933a <_NVRAM_Write>
    7de4:	5c07      	dec	S, #8
    7de6:	5405      	ret	#6

00007de8 <_handleAssignFrameIDRange>:
}

void handleAssignFrameIDRange(const DFR_DIAG *pDiag)
{
    7de8:	5801      	inc	S, #2
    7dea:	5201      	mov	[S-2], A
	 * correct PIDs.
	 *
	 * A response shall only be sent if the NAD match.
	 */
	/* Since the slave node has only two frames the last two must be set to do not care (0xFF), otherwise the request will fail. */
	if ( (pDiag->byD4 != 0xFFu) || (pDiag->byD5 != 0xFFu) || (pDiag->byD1 > 1u) || ((pDiag->byD1 == 1u) && (pDiag->byD3 != 0xFFu)) )
    7dec:	7a01      	lod	Y, [S-2]
    7dee:	72f6      	lod	A, [Y+6]
    7df0:	acff      	cmp	A, #-1
    7df2:	1901      	je	0x7df6 <_handleAssignFrameIDRange+0xe>
    7df4:	0053      	jmp	0x7e9c <_handleAssignFrameIDRange+0xb4>
    7df6:	62f3      	lod	AL, [Y+3]
    7df8:	8c01      	cmp	AL, #1
    7dfa:	1a01      	jule	0x7dfe <_handleAssignFrameIDRange+0x16>
    7dfc:	004f      	jmp	0x7e9c <_handleAssignFrameIDRange+0xb4>
    7dfe:	1d04      	jne	0x7e08 <_handleAssignFrameIDRange+0x20>
    7e00:	62f5      	lod	AL, [Y+5]
    7e02:	8cff      	cmp	AL, #-1
    7e04:	1901      	je	0x7e08 <_handleAssignFrameIDRange+0x20>
    7e06:	004a      	jmp	0x7e9c <_handleAssignFrameIDRange+0xb4>
		/* Negative feedback */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
	}
	else
	{
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_PENDING);		/* Status = Pending */
    7e08:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7e0a:	5cf2      	usex	A
    7e0c:	54ca 0078 	pushw	#120
    7e10:	7e03      	lod	X, [S-4]
    7e12:	66fa      	lod	YL, [X+2]
    7e14:	5cf6      	usex	Y
    7e16:	5adf      	push	Y
    7e18:	15ea      	call	0x79ee <_SetupDiagResponse>

		u16NvramStoreResult = (uint8)~C_NVRAM_STORE_OKAY;
    7e1a:	7ada 00ff 	lod	Y, #255
		if ( pDiag->byD1 == 0u )
    7e1e:	5c03      	dec	S, #4
    7e20:	7e01      	lod	X, [S-2]
    7e22:	62fb      	lod	AL, [X+3]
    7e24:	1d18      	jne	0x7e56 <_handleAssignFrameIDRange+0x6e>
		{
			/* Starting with first message-index */
			if ( pDiag->byD2 != 0xFFu )
    7e26:	62fc      	lod	AL, [X+4]
    7e28:	8cff      	cmp	AL, #-1
    7e2a:	1910      	je	0x7e4c <_handleAssignFrameIDRange+0x64>
			{
				/* First Frame-ID is Status-message Frame-ID */
				g_u8StatusFrameID = pDiag->byD2;
    7e2c:	4119      	mov	dp:0x19 <_g_u8StatusFrameID>, AL
				(void) ml_Disconnect();
    7e2e:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
				if ( g_u8StatusFrameID != 0x00u )				/* MMP130913-1 - Begin */
    7e32:	6119      	lod	AL, dp:0x19 <_g_u8StatusFrameID>
    7e34:	1907      	je	0x7e44 <_handleAssignFrameIDRange+0x5c>
				{
					(void) ml_AssignFrameToMessageID( MSG_STATUS, g_u8StatusFrameID);
    7e36:	5cf2      	usex	A
    7e38:	52df      	push	A
    7e3a:	7000      	lod	A, #0
    7e3c:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
    7e40:	5c01      	dec	S, #2
    7e42:	0003      	jmp	0x7e4a <_handleAssignFrameIDRange+0x62>
				}
				else
				{
					(void) ml_DisableMessage( MSG_STATUS);
    7e44:	7000      	lod	A, #0
    7e46:	82db 5ab4 	callf	0x5ab4 <_ml_DisableMessage>
				}														/* MMP130913-1 - End */
				u16NvramStoreResult = C_NVRAM_STORE_OKAY;
    7e4a:	7800      	lod	Y, #0
			}
			
			if ( pDiag->byD3 != 0xFFu )
    7e4c:	7e01      	lod	X, [S-2]
    7e4e:	62fd      	lod	AL, [X+5]
    7e50:	8cff      	cmp	AL, #-1
    7e52:	1915      	je	0x7e7e <_handleAssignFrameIDRange+0x96>
    7e54:	0004      	jmp	0x7e5e <_handleAssignFrameIDRange+0x76>
					(void) ml_DisableMessage( MSG_CONTROL);
				}														/* MMP130913-1 - End */
				u16NvramStoreResult = C_NVRAM_STORE_OKAY;
			}
		}
		else if ( pDiag->byD1 == 1u )
    7e56:	8c01      	cmp	AL, #1
    7e58:	1d21      	jne	0x7e9c <_handleAssignFrameIDRange+0xb4>
		{
			/* Second Frame-ID is Control-message Frame-ID */
			g_u8ControlFrameID = pDiag->byD2;
    7e5a:	7a01      	lod	Y, [S-2]
    7e5c:	62f4      	lod	AL, [Y+4]
    7e5e:	411a      	mov	dp:0x1a <_g_u8ControlFrameID>, AL
			(void) ml_Disconnect();
    7e60:	82db 5b9a 	callf	0x5b9a <_ml_Disconnect>
			if ( g_u8ControlFrameID != 0x00u )				/* MMP130913-1 - Begin */
    7e64:	611a      	lod	AL, dp:0x1a <_g_u8ControlFrameID>
    7e66:	1907      	je	0x7e76 <_handleAssignFrameIDRange+0x8e>
			{
				(void) ml_AssignFrameToMessageID( MSG_CONTROL, g_u8ControlFrameID);
    7e68:	5cf2      	usex	A
    7e6a:	52df      	push	A
    7e6c:	7001      	lod	A, #1
    7e6e:	82db 5aae 	callf	0x5aae <_ml_AssignFrameToMessageID>
    7e72:	5c01      	dec	S, #2
    7e74:	0006      	jmp	0x7e82 <_handleAssignFrameIDRange+0x9a>
			}
			else
			{
				(void) ml_DisableMessage( MSG_CONTROL);
    7e76:	7001      	lod	A, #1
    7e78:	82db 5ab4 	callf	0x5ab4 <_ml_DisableMessage>
    7e7c:	0002      	jmp	0x7e82 <_handleAssignFrameIDRange+0x9a>
		else
		{
			
		}
		/* Assign frame ID range success */
		if ( u16NvramStoreResult == C_NVRAM_STORE_OKAY )
    7e7e:	ec00      	cmp	Y, #0
    7e80:	1d0d      	jne	0x7e9c <_handleAssignFrameIDRange+0xb4>
		{
			(void) ml_Connect();
    7e82:	82db 5b96 	callf	0x5b96 <_ml_Connect>
			/* save configuration is implemented by save configuration service */
			/* Positive feedback */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_POSITIVE_RESPONSE);/* Status = Positive feedback */
    7e86:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7e88:	5cf2      	usex	A
    7e8a:	54ca 0000 	pushw	#0
    7e8e:	7e03      	lod	X, [S-4]
    7e90:	66fa      	lod	YL, [X+2]
    7e92:	5cf6      	usex	Y
    7e94:	5adf      	push	Y
    7e96:	15ab      	call	0x79ee <_SetupDiagResponse>
    7e98:	5c03      	dec	S, #4
    7e9a:	5403      	ret	#4
		}
		else
		{
			/* Negative feedback */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);	/* Status = Negative feedback */
    7e9c:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7e9e:	5cf2      	usex	A
    7ea0:	54ca 0012 	pushw	#18
    7ea4:	07f4      	jmp	0x7e8e <_handleAssignFrameIDRange+0xa6>

00007ea6 <_handleWriteByIdentifier>:
		}
	}
}

void handleWriteByIdentifier(const DFR_DIAG *pDiag)
{
    7ea6:	5803      	inc	S, #4
    7ea8:	7ae2      	lod	Y, A
	 *	| NAD | 0x06| 0x0B |Identifier| ID Data1 | ID Data2 | ID Data3 | ID Data4 |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 * Identifier: 00
	 * ID data 1-4
	 */
	uint16 u16SupplierID = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    7eaa:	6af5      	lod	AH, [Y+5]
    7eac:	6000      	lod	AL, #0
    7eae:	5203      	mov	[S-4], A
    7eb0:	62f4      	lod	AL, [Y+4]
    7eb2:	5cf2      	usex	A
    7eb4:	a603      	or	A, [S-4]
    7eb6:	5203      	mov	[S-4], A
	uint16 u16ParamID = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    7eb8:	6af7      	lod	AH, [Y+7]
    7eba:	6000      	lod	AL, #0
    7ebc:	7ee2      	lod	X, A
    7ebe:	62f6      	lod	AL, [Y+6]
    7ec0:	5cf2      	usex	A
    7ec2:	26e2      	or	X, A
	
	if ( pDiag->byD1 == (uint8) C_LIN_PROD_ID )
    7ec4:	62f3      	lod	AL, [Y+3]
    7ec6:	1d09      	jne	0x7eda <_handleWriteByIdentifier+0x34>
	{
		/* Write Function ID */
		if ( (u16SupplierID == C_SUPPLIER_ID) && (u16ParamID == C_FUNCTION_ID) )			/* MMP130626-1 */
    7ec8:	7203      	lod	A, [S-4]
    7eca:	ac13      	cmp	A, #19
    7ecc:	1d04      	jne	0x7ed6 <_handleWriteByIdentifier+0x30>
    7ece:	2c16      	cmp	X, #22
    7ed0:	1d02      	jne	0x7ed6 <_handleWriteByIdentifier+0x30>
			/* Correct Supplier ID; Change Function ID allowed */
			/* Store NVRAM */
		
			{
				/* Function-ID changed:set up response */
				g_DiagResponse.byNAD = g_u8NAD;
    7ed2:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ed4:	000a      	jmp	0x7eea <_handleWriteByIdentifier+0x44>
			}
		}
		else
		{
			/* Wrong Supplier ID (Wild-card not allowed) */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);	/* Status = Negative feedback */
    7ed6:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ed8:	001b      	jmp	0x7f10 <_handleWriteByIdentifier+0x6a>
		}
	}
	else if ( pDiag->byD1 == (uint8) C_LIN_CUST_ID )
    7eda:	8c3d      	cmp	AL, #61
    7edc:	1d22      	jne	0x7f22 <_handleWriteByIdentifier+0x7c>
    7ede:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ee0:	4201      	mov	[S-2], AL
	{
		/* Write Customer ID */
		if ( u16SupplierID == C_SUPPLIER_ID )
    7ee2:	7203      	lod	A, [S-4]
    7ee4:	ac13      	cmp	A, #19
    7ee6:	1d13      	jne	0x7f0e <_handleWriteByIdentifier+0x68>
		{
			/* Correct Supplier ID; Change Function ID allowed */
			/* Store NVRAM */
			{
				/* Customer-ID changed:set up response */
				g_DiagResponse.byNAD = g_u8NAD;
    7ee8:	6201      	lod	AL, [S-2]
    7eea:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
				g_DiagResponse.byPCI = (uint8) C_RSID_WRITE_BY_ID;							/* Positive feedback */
    7eec:	6006      	lod	AL, #6
    7eee:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
				g_DiagResponse.byRSID = (uint8) C_RPCI_WRITE_BY_ID;
    7ef0:	600b      	lod	AL, #11
    7ef2:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
				g_DiagResponse.byD1 = pDiag->byD1;
    7ef4:	62f3      	lod	AL, [Y+3]
    7ef6:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
				g_DiagResponse.byD2 = pDiag->byD2;
    7ef8:	62f4      	lod	AL, [Y+4]
    7efa:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
				g_DiagResponse.byD3 = pDiag->byD3;
    7efc:	62f5      	lod	AL, [Y+5]
    7efe:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
				g_DiagResponse.byD4 = pDiag->byD4;
    7f00:	62f6      	lod	AL, [Y+6]
    7f02:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
				g_DiagResponse.byD5 = pDiag->byD5;
    7f04:	62f7      	lod	AL, [Y+7]
    7f06:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

				g_u8BufferOutID = (uint8) QR_RFR_DIAG;										/* LIN Output buffer is valid (RFR_DIAG) */
    7f08:	6007      	lod	AL, #7
    7f0a:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7f0c:	5405      	ret	#6
			}
		}
		else
		{
			/* Wrong Supplier ID (Wild-card not allowed) */
			SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_INV_MSG_INV_SZ);	/* Status = Negative feedback */
    7f0e:	6201      	lod	AL, [S-2]
    7f10:	5cf2      	usex	A
    7f12:	54ca 0013 	pushw	#19
    7f16:	66f2      	lod	YL, [Y+2]
    7f18:	5cf6      	usex	Y
    7f1a:	5adf      	push	Y
    7f1c:	1568      	call	0x79ee <_SetupDiagResponse>
    7f1e:	5c03      	dec	S, #4
    7f20:	5405      	ret	#6
		}
	}
	else if ( pDiag->byD1 == (uint8) C_PROD_DATE )
    7f22:	8c3e      	cmp	AL, #62
    7f24:	195c      	je	0x7ede <_handleWriteByIdentifier+0x38>
		}
	}
	else
	{
		/* Identifier not supported */
		SetupDiagResponse( g_u8NAD, pDiag->bySID, (uint8) C_ERRCODE_SFUNC_NOSUP);			/* Status = Negative feedback */
    7f26:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f28:	5cf2      	usex	A
    7f2a:	54ca 0012 	pushw	#18
    7f2e:	07f3      	jmp	0x7f16 <_handleWriteByIdentifier+0x70>

00007f30 <_handleReadErrorCodes>:
	 *	| NAD | PCI | RSID |    D1    |    D2    |    D3    |    D4    |    D5    |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 *	| NAD | 0x06| 0xEC | Error[0] | Error[1] | Error[2] | Error[3] | Error[4] |
	 *	+-----+-----+------+----------+----------+----------+----------+----------+
	 */
	g_DiagResponse.byNAD = g_u8NAD;
    7f30:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f32:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
	g_DiagResponse.byPCI = 0x06;
    7f34:	6006      	lod	AL, #6
    7f36:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
	g_DiagResponse.byRSID = (uint8) C_SID_MLX_ERROR_CODES;
    7f38:	60ec      	lod	AL, #-20
    7f3a:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
	g_DiagResponse.byD1 = GetLastError();													/* Oldest Error-code */
    7f3c:	82db 880e 	callf	0x880e <_GetLastError>
    7f40:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
	g_DiagResponse.byD2 = GetLastError();
    7f42:	82db 880e 	callf	0x880e <_GetLastError>
    7f46:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
	g_DiagResponse.byD3 = GetLastError();
    7f48:	82db 880e 	callf	0x880e <_GetLastError>
    7f4c:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
	g_DiagResponse.byD4 = GetLastError();
    7f4e:	82db 880e 	callf	0x880e <_GetLastError>
    7f52:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
	g_DiagResponse.byD5 = GetLastError();
    7f54:	82db 880e 	callf	0x880e <_GetLastError>
    7f58:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

	g_u8BufferOutID = (uint8) QR_RFR_DIAG;													/* LIN Output buffer is valid (RFR_DIAG) */
    7f5a:	6007      	lod	AL, #7
    7f5c:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7f5e:	5401      	ret

00007f60 <_handleMLXEEPatch>:
}

void handleMLXEEPatch(const DFR_DIAG *pDiag)
{
    7f60:	5805      	inc	S, #6
    7f62:	7ee2      	lod	X, A
	/* EEPROM/NVRAM Patch support
	 * D1.bit 7 = 0 : Read Patch area
	 *			  1 : Write Patch area
	 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3D.
	 */
	uint16 u16Index = (uint16) (pDiag->byD1 & 0x3Fu);
    7f64:	62fb      	lod	AL, [X+3]
    7f66:	4201      	mov	[S-2], AL
    7f68:	66e0      	lod	YL, AL
    7f6a:	f43f      	and	Y, #63
    7f6c:	72e6      	lod	A, Y
    7f6e:	4422      	asl	A
    7f70:	5203      	mov	[S-4], A
	if ( (pDiag->byD1 & 0x80u) != 0u )
    7f72:	6201      	lod	AL, [S-2]
    7f74:	8c00      	cmp	AL, #0
    7f76:	1e91      	jsge	0x7f9a <_handleMLXEEPatch+0x3a>
		 *	| NAD | 0x06| 0xED |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
		 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
	     * No Response
		 */
		uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    7f78:	7a03      	lod	Y, [S-4]
    7f7a:	e2da 1080 	add	Y, #4224
    7f7e:	5a05      	mov	[S-6], Y
		*pu16NvramData = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    7f80:	6afd      	lod	AH, [X+5]
    7f82:	62fc      	lod	AL, [X+4]
    7f84:	7a05      	lod	Y, [S-6]
    7f86:	52f0      	mov	[Y], A
		pu16NvramData++;
    7f88:	7a03      	lod	Y, [S-4]
    7f8a:	e2da 1082 	add	Y, #4226
    7f8e:	5a05      	mov	[S-6], Y
		*pu16NvramData = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    7f90:	6aff      	lod	AH, [X+7]
    7f92:	62fe      	lod	AL, [X+6]
    7f94:	7a05      	lod	Y, [S-6]
    7f96:	52f0      	mov	[Y], A
    7f98:	5407      	ret	#8
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 *	| NAD | 0x06| 0xED |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
		 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byNAD = g_u8NAD;
    7f9a:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7f9c:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    7f9e:	6006      	lod	AL, #6
    7fa0:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_PATCH;
    7fa2:	60ed      	lod	AL, #-19
    7fa4:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) u16Index;
    7fa6:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
		{
			uint16 *pu16NvramData = ((uint16 *) C_ADDR_PATCHPAGE) + u16Index;	/* NVRAM 16-bit pointer */
    7fa8:	7a03      	lod	Y, [S-4]
    7faa:	e2da 1080 	add	Y, #4224
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    7fae:	72f0      	lod	A, [Y]
    7fb0:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    7fb2:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    7fb4:	4935      	mov	dp:0x35 <_g_DiagResponse+0x5>, AH
    7fb6:	4536      	mov	dp:0x36 <_g_DiagResponse+0x6>, YL
    7fb8:	4d37      	mov	dp:0x37 <_g_DiagResponse+0x7>, YH
		"mov dp:_g_DiagResponse+6, YL\n\t"
		"mov dp:_g_DiagResponse+7, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    7fba:	6007      	lod	AL, #7
    7fbc:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    7fbe:	5407      	ret	#8

00007fc0 <_handleMLXEEUserPage>:
		}
	}
}

void handleMLXEEUserPage(const DFR_DIAG *pDiag)
{
    7fc0:	5805      	inc	S, #6
    7fc2:	7ee2      	lod	X, A
	/* EEPROM/NVRAM User-page #1 support
	 * D1.bit 7 = 0 : Read User-page #1
	 *			  1 : Write User-page #1
	 * D1.bit[6:0] : 16-bit data index. Valid 0x00 through 0x3F.
	 */
	uint16 u16Index = (uint16) (pDiag->byD1 & 0x3Fu);
    7fc4:	62fb      	lod	AL, [X+3]
    7fc6:	4201      	mov	[S-2], AL
    7fc8:	66e0      	lod	YL, AL
    7fca:	f43f      	and	Y, #63
    7fcc:	72e6      	lod	A, Y
    7fce:	4422      	asl	A
    7fd0:	5203      	mov	[S-4], A
	if ( (pDiag->byD1 & 0x80u) != 0x00u )
    7fd2:	6201      	lod	AL, [S-2]
    7fd4:	8c00      	cmp	AL, #0
    7fd6:	1e8d      	jsge	0x7ff2 <_handleMLXEEUserPage+0x32>
		 *	| NAD | 0x06| 0xEE |  Write   | W[index] | W[index] |W[index+1]|W[index+1]|
		 *	|     |     |      |   Index  |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
	     * No Response
		 */
		uint16 *pu16NvramData = ((uint16 *) C_ADDR_USERPAGE1) + u16Index;	/* NVRAM 16-bit pointer */
    7fd8:	7a03      	lod	Y, [S-4]
    7fda:	e2da 1000 	add	Y, #4096
    7fde:	5a05      	mov	[S-6], Y
		pu16NvramData[0] = (((uint16) pDiag->byD3) << 8u) | ((uint16) pDiag->byD2);
    7fe0:	6afd      	lod	AH, [X+5]
    7fe2:	62fc      	lod	AL, [X+4]
    7fe4:	7a05      	lod	Y, [S-6]
    7fe6:	52f0      	mov	[Y], A
		pu16NvramData[1] = (((uint16) pDiag->byD5) << 8u) | ((uint16) pDiag->byD4);
    7fe8:	6aff      	lod	AH, [X+7]
    7fea:	62fe      	lod	AL, [X+6]
    7fec:	7a05      	lod	Y, [S-6]
    7fee:	52f2      	mov	[Y+2], A
    7ff0:	5407      	ret	#8
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 *	| NAD | 0x06| 0xEE |Read Index| R[index] | R[index] |R[index+1]|R[index+1]|
		 *	|     |     |      |          |  (LSB)   |  (MSB)   |   (LSB)  |   (MSB)  |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 */
		g_DiagResponse.byNAD = g_u8NAD;
    7ff2:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    7ff4:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    7ff6:	6006      	lod	AL, #6
    7ff8:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) C_SID_MLX_EE_USERPG1;
    7ffa:	60ee      	lod	AL, #-18
    7ffc:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD1 = (uint8) u16Index;
    7ffe:	4533      	mov	dp:0x33 <_g_DiagResponse+0x3>, YL
		{
			uint16 *pu16NvramData = ((uint16 *) C_ADDR_USERPAGE1) + u16Index;	/* NVRAM 16-bit pointer */
    8000:	7a03      	lod	Y, [S-4]
    8002:	e2da 1000 	add	Y, #4096
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to4() */

static __inline__ void StoreD2to5( uint16 a, uint16 b)
{
    8006:	72f0      	lod	A, [Y]
    8008:	7af2      	lod	Y, [Y+2]
	__asm__ __volatile__
    800a:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
    800c:	4935      	mov	dp:0x35 <_g_DiagResponse+0x5>, AH
    800e:	4536      	mov	dp:0x36 <_g_DiagResponse+0x6>, YL
    8010:	4d37      	mov	dp:0x37 <_g_DiagResponse+0x7>, YH
		"mov dp:_g_DiagResponse+6, YL\n\t"
		"mov dp:_g_DiagResponse+7, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    8012:	6007      	lod	AL, #7
    8014:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    8016:	5407      	ret	#8

00008018 <_handleMLXEEStore>:
		}
	}
}

void handleMLXEEStore(const DFR_DIAG *pDiag)
{
    8018:	5801      	inc	S, #2
    801a:	5201      	mov	[S-2], A
	if ( pDiag->byD1 == (uint8) C_EE_STORE_USERPG1 )
    801c:	7a01      	lod	Y, [S-2]
    801e:	62f3      	lod	AL, [Y+3]
    8020:	8cee      	cmp	AL, #-18
    8022:	1d14      	jne	0x804c <_handleMLXEEStore+0x34>
		 *	| NAD | 0x06| 0xEF |   0xEE   | Pages &  |          |          |          |
		 *	|     |     |      |          | ResetFlg |          |          |          |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 * No Response
		 */
		(void) NVRAM_Store( pDiag->byD2);
    8024:	62f4      	lod	AL, [Y+4]
    8026:	5cf2      	usex	A
    8028:	82db 9490 	callf	0x9490 <_NVRAM_Store>
		if ( (pDiag->byD2 != 0xFFu) && ((pDiag->byD2 & C_NVRAM_USER_PAGE_RESET) != 0u) )
    802c:	7a01      	lod	Y, [S-2]
    802e:	62f4      	lod	AL, [Y+4]
    8030:	8cff      	cmp	AL, #-1
    8032:	1914      	je	0x805c <_handleMLXEEStore+0x44>
    8034:	b420      	and	A, #32
    8036:	1912      	je	0x805c <_handleMLXEEStore+0x44>
		{
			(void) mlu_ApplicationStop();
    8038:	82db 77ca 	callf	0x77ca <_mlu_ApplicationStop>
			MLX4_RESET();												/* Reset the Mlx4   */
    803c:	62d8 2000 	lod	AL, 0x2000 <__ep__+0x1000>
    8040:	94fe      	and	AL, #-2
    8042:	42d8 2000 	mov	0x2000 <__ep__+0x1000>, AL
			MLX16_RESET();												/* Reset the Mlx16  */
    8046:	82db 5914 	callf	0x5914 <_MLX16_RESET>
    804a:	5403      	ret	#4
		}
	}
	else if ( (pDiag->byD1 == (uint8) C_EE_STORE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0u) )	/* MMP150603-2 */
    804c:	8ced      	cmp	AL, #-19
    804e:	1d06      	jne	0x805c <_handleMLXEEStore+0x44>
    8050:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    8054:	b401      	and	A, #1
    8056:	1d02      	jne	0x805c <_handleMLXEEStore+0x44>
		 *	| NAD | 0x06| 0xEF |   0xED   |          |          |          |          |
		 *	|     |     |      |          |          |          |          |          |
		 *	+-----+-----+------+----------+----------+----------+----------+----------+
		 * No Response
		 */
		NVRAM_StorePatch();
    8058:	82db 950a 	callf	0x950a <_NVRAM_StorePatch>
    805c:	5403      	ret	#4

0000805e <_HandleDfrDiag>:

/* ****************************************************************************	*
 * Diagnostic
 * ****************************************************************************	*/
void HandleDfrDiag( void)
{
    805e:	5801      	inc	S, #2
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	uint16 u16DiagPCI_SID;

#if ((LINPROT & LINXX) == LIN21) || ((LINPROT & LINXX) == LIN22) 			/* LIN 2.1, LIN 2.2 */
	if ( pDiag->byNAD != 0x7Eu )
    8060:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    8062:	4201      	mov	[S-2], AL
    8064:	8c7e      	cmp	AL, #126
    8066:	1902      	je	0x806c <_HandleDfrDiag+0xe>
	{
		g_u8BufferOutID = (uint8) QR_INVALID;
    8068:	60ff      	lod	AL, #-1
    806a:	4118      	mov	dp:0x18 <__data_dp_start>, AL
	if ( pDiag->byNAD == 0x00u )	/* Other bytes should be 0xFF, and are ignored */
	{
		/* ACT_DFR_DIAG_SLEEP: Sleep request (Optional) */
	}
	/* assign NAD service shall be used with initial NAD */
	if((pDiag->byNAD == (uint8)C_DEFAULT_NAD) || (pDiag->byNAD == (uint8)C_BROADCAST_NAD))
    806c:	6201      	lod	AL, [S-2]
    806e:	8c16      	cmp	AL, #22
    8070:	1902      	je	0x8076 <_HandleDfrDiag+0x18>
    8072:	8c7f      	cmp	AL, #127
    8074:	1d0e      	jne	0x8092 <_HandleDfrDiag+0x34>
	{
		u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8u) | ((uint16)pDiag->bySID);
    8076:	6d29      	lod	YH, dp:0x29 <__data_dp_end+0x1>
    8078:	652a      	lod	YL, dp:0x2a <__data_dp_end+0x2>
		/* support padding */
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    807a:	60ff      	lod	AL, #-1
    807c:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    807e:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    8080:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    8082:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    8084:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
		if(u16DiagPCI_SID == C_PCI_SID_REASSIGN_NAD)
    8086:	eeda 06b0 	cmp	Y, #1712
    808a:	1d03      	jne	0x8092 <_HandleDfrDiag+0x34>
		{
			handleReassignNAD(pDiag);
    808c:	72da 0028 	lod	A, #40
    8090:	14e0      	call	0x7a52 <_handleReassignNAD>
		}
	}
	/* other service shall use configure NAD */	
	if ( (pDiag->byNAD == g_u8NAD) || (pDiag->byNAD == (uint8) C_BROADCAST_NAD) )
    8092:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    8094:	8d1b      	cmp	AL, dp:0x1b <_g_u8NAD>
    8096:	1903      	je	0x809e <_HandleDfrDiag+0x40>
    8098:	8c7f      	cmp	AL, #127
    809a:	1901      	je	0x809e <_HandleDfrDiag+0x40>
    809c:	004e      	jmp	0x813a <_HandleDfrDiag+0xdc>
	{
		u16DiagPCI_SID = (((uint16)pDiag->byPCI) << 8u) | ((uint16)pDiag->bySID);
    809e:	6d29      	lod	YH, dp:0x29 <__data_dp_end+0x1>
    80a0:	6400      	lod	YL, #0
    80a2:	612a      	lod	AL, dp:0x2a <__data_dp_end+0x2>
    80a4:	4200      	mov	[S-1], AL
    80a6:	5cf2      	usex	A
    80a8:	e6e2      	or	Y, A

		/* support padding */
		g_DiagResponse.byD1 = (uint8) C_DIAG_RES;
    80aa:	60ff      	lod	AL, #-1
    80ac:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
		g_DiagResponse.byD2 = (uint8) C_DIAG_RES;
    80ae:	4134      	mov	dp:0x34 <_g_DiagResponse+0x4>, AL
		g_DiagResponse.byD3 = (uint8) C_DIAG_RES;
    80b0:	4135      	mov	dp:0x35 <_g_DiagResponse+0x5>, AL
		g_DiagResponse.byD4 = (uint8) C_DIAG_RES;
    80b2:	4136      	mov	dp:0x36 <_g_DiagResponse+0x6>, AL
		g_DiagResponse.byD5 = (uint8) C_DIAG_RES;
    80b4:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL

		if ( (u16DiagPCI_SID == C_PCI_SID_STOP_ACTUATOR) && (pDiag->byD5 == 0xFEu) )
    80b6:	eeda 06b5 	cmp	Y, #1717
    80ba:	1d04      	jne	0x80c4 <_HandleDfrDiag+0x66>
    80bc:	612f      	lod	AL, dp:0x2f <__data_dp_end+0x7>
    80be:	8cfe      	cmp	AL, #-2
    80c0:	1d1d      	jne	0x80fc <_HandleDfrDiag+0x9e>
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 *	| NAD | 0x06| 0xB5| Supplier | Supplier | Function | Function |  "Stop"  |
			 *	|     |     |     | ID (LSB) | ID (MSB) | ID (LSB) | ID (MSB) |   0xFE   |
			 *	+-----+-----+-----+----------+----------+----------+----------+----------+
			 */
			if ( ValidSupplierFunctionID( (pDiag->byD1) | ((uint16)(pDiag->byD2) << 8u), ((uint16)pDiag->byD3) | ((uint16)(pDiag->byD4) << 8u)) != FALSE )
    80c2:	5403      	ret	#4
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID )
		{
			handleAssignFrameID(pDiag);
		}
#endif /* ((LINPROT & LINXX) == LIN2X) */
		else if ( u16DiagPCI_SID == C_PCI_SID_READ_BY_ID )
    80c4:	eeda 06b2 	cmp	Y, #1714
    80c8:	1d04      	jne	0x80d2 <_HandleDfrDiag+0x74>
		{
			handleReadByIdentifier(pDiag);
    80ca:	72da 0028 	lod	A, #40
    80ce:	1529      	call	0x7b22 <_handleReadByIdentifier>
    80d0:	5403      	ret	#4
		{
			handleDataDump(pDiag);
		}
#endif
#if ((LINPROT & LINXX) == LIN21)
		else if ( u16DiagPCI_SID == C_PCI_SID_SAVE_CONFIG)
    80d2:	eeda 01b6 	cmp	Y, #438
    80d6:	1d04      	jne	0x80e0 <_HandleDfrDiag+0x82>
		{
			handleSaveConfig(pDiag);
    80d8:	72da 0028 	lod	A, #40
    80dc:	166a      	call	0x7db2 <_handleSaveConfig>
    80de:	5403      	ret	#4
		}
		else if ( u16DiagPCI_SID == C_PCI_SID_ASSIGN_FRAME_ID_RNG )
    80e0:	eeda 06b7 	cmp	Y, #1719
    80e4:	1d04      	jne	0x80ee <_HandleDfrDiag+0x90>
		{
			handleAssignFrameIDRange(pDiag);
    80e6:	72da 0028 	lod	A, #40
    80ea:	167e      	call	0x7de8 <_handleAssignFrameIDRange>
    80ec:	5403      	ret	#4
		}
#endif
		else if ( u16DiagPCI_SID == C_PCI_SID_WRITE_BY_ID )
    80ee:	eeda 06cb 	cmp	Y, #1739
    80f2:	1d04      	jne	0x80fc <_HandleDfrDiag+0x9e>
		{
			handleWriteByIdentifier(pDiag);
    80f4:	72da 0028 	lod	A, #40
    80f8:	16d6      	call	0x7ea6 <_handleWriteByIdentifier>
    80fa:	5403      	ret	#4
		{
			handleMLXDebug(pDiag);
		}
#endif /* _SUPPORT_MLX_DEBUG_MODE */

		else if ( pDiag->bySID == (uint8) C_SID_MLX_ERROR_CODES )
    80fc:	6200      	lod	AL, [S-1]
    80fe:	8cec      	cmp	AL, #-20
    8100:	1d04      	jne	0x810a <_HandleDfrDiag+0xac>
		{
			handleReadErrorCodes(pDiag);
    8102:	72da 0028 	lod	A, #40
    8106:	1714      	call	0x7f30 <_handleReadErrorCodes>
    8108:	5403      	ret	#4
		}
		else if ( (pDiag->bySID == (uint8) C_SID_MLX_EE_PATCH) && ((FL_CTRL0 & FL_DETECT) == 0u) )	/* MMP150603-2 */
    810a:	6200      	lod	AL, [S-1]
    810c:	8ced      	cmp	AL, #-19
    810e:	1d08      	jne	0x8120 <_HandleDfrDiag+0xc2>
    8110:	72d8 2026 	lod	A, 0x2026 <__ep__+0x1026>
    8114:	b401      	and	A, #1
    8116:	1d11      	jne	0x813a <_HandleDfrDiag+0xdc>
		{
			handleMLXEEPatch(pDiag);
    8118:	72da 0028 	lod	A, #40
    811c:	1721      	call	0x7f60 <_handleMLXEEPatch>
    811e:	5403      	ret	#4
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_USERPG1 )
    8120:	6200      	lod	AL, [S-1]
    8122:	8cee      	cmp	AL, #-18
    8124:	1d04      	jne	0x812e <_HandleDfrDiag+0xd0>
		{
			handleMLXEEUserPage(pDiag);
    8126:	72da 0028 	lod	A, #40
    812a:	174a      	call	0x7fc0 <_handleMLXEEUserPage>
    812c:	5403      	ret	#4
		}
		else if ( pDiag->bySID == (uint8) C_SID_MLX_EE_STORE )
    812e:	6200      	lod	AL, [S-1]
    8130:	8cef      	cmp	AL, #-17
    8132:	1d03      	jne	0x813a <_HandleDfrDiag+0xdc>
		{
			handleMLXEEStore(pDiag);
    8134:	72da 0028 	lod	A, #40
    8138:	176f      	call	0x8018 <_handleMLXEEStore>
    813a:	5403      	ret	#4

0000813c <_RfrDiagReset>:
 * ****************************************************************************	*/
void RfrDiagReset(void)
{
	DFR_DIAG *pDiag = &g_LinCmdFrameBuffer.Diag;
	
	if ( pDiag->byNAD != C_BROADCAST_NAD )
    813c:	6128      	lod	AL, dp:0x28 <__data_dp_end>
    813e:	8c7f      	cmp	AL, #127
    8140:	1910      	je	0x8162 <_RfrDiagReset+0x26>
	{
		/* Positive Response */
		g_DiagResponse.byNAD = g_u8NAD;
    8142:	611b      	lod	AL, dp:0x1b <_g_u8NAD>
    8144:	4130      	mov	dp:0x30 <_g_DiagResponse>, AL
		g_DiagResponse.byPCI = 0x06;
    8146:	6006      	lod	AL, #6
    8148:	4131      	mov	dp:0x31 <_g_DiagResponse+0x1>, AL
		g_DiagResponse.byRSID = (uint8) (C_SID_RESET | C_RSID_OK);
    814a:	60f5      	lod	AL, #-11
    814c:	4132      	mov	dp:0x32 <_g_DiagResponse+0x2>, AL
		g_DiagResponse.byD5 = (uint8) C_VARIANT;
    814e:	60ff      	lod	AL, #-1
    8150:	4137      	mov	dp:0x37 <_g_DiagResponse+0x7>, AL
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
	return;
} /* End of StoreD1to2() */

static __inline__ void StoreD1to4( uint16 a, uint16 b)
{
    8152:	7013      	lod	A, #19
    8154:	7816      	lod	Y, #22
	__asm__ __volatile__
    8156:	4133      	mov	dp:0x33 <_g_DiagResponse+0x3>, AL
    8158:	4934      	mov	dp:0x34 <_g_DiagResponse+0x4>, AH
    815a:	4535      	mov	dp:0x35 <_g_DiagResponse+0x5>, YL
    815c:	4d36      	mov	dp:0x36 <_g_DiagResponse+0x6>, YH
		"mov dp:_g_DiagResponse+5, YL\n\t"
		"mov dp:_g_DiagResponse+6, YH"
		:
		: "b" (a), "y" (b)
	);
	g_u8BufferOutID = (uint8) QR_RFR_DIAG;									/* LIN Output buffer is valid (RFR_DIAG) */
    815e:	6007      	lod	AL, #7
    8160:	4118      	mov	dp:0x18 <__data_dp_start>, AL
    8162:	5401      	ret

00008164 <_ADC_StartSoftTrig>:
 *
 * Start ADC measurement using Software trigger.
 * ****************************************************************************	*/
void ADC_StartSoftTrig( void)													/* MMP140709-1 - Begin */
{
	PEND = CLR_ADC_IT;
    8164:	7040      	lod	A, #64
    8166:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    816a:	7001      	lod	A, #1
    816c:	5290      	mov	io:0x10 <__data_dp_size>, A
	if ( l_u8AdcPowerOff != 0u )
    816e:	62d8 00bc 	lod	AL, 0xbc <_l_u8AdcPowerOff>
    8172:	1904      	je	0x817c <_ADC_StartSoftTrig+0x18>
    8174:	7eda 008b 	lod	X, #139

static __inline__ void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0u; u16DelayCount-- )
	{
		NOP();
    8178:	0000      	nop
    817a:	1bfe      	djnz	X, 0x8178 <_ADC_StartSoftTrig+0x14>
	{
		NopDelay( DELAY_50us); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    817c:	6000      	lod	AL, #0
    817e:	42d8 00bc 	mov	0xbc <_l_u8AdcPowerOff>, AL
    8182:	7c06      	lod	X, #6
    8184:	0000      	nop
    8186:	1bfe      	djnz	X, 0x8184 <_ADC_StartSoftTrig+0x20>
	NopDelay( ADC_SETTING); /*lint !e522 */
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    8188:	72da 0101 	lod	A, #257
    818c:	5290      	mov	io:0x10 <__data_dp_size>, A
	while ((ADC_CTRL & ADC_START) != 0u) 			/* lint -e{722} */ 			/* Wait for ADC result */
    818e:	7290      	lod	A, io:0x10 <__data_dp_size>
    8190:	b401      	and	A, #1
    8192:	1d7d      	jne	0x818e <_ADC_StartSoftTrig+0x2a>
    8194:	5401      	ret

00008196 <_ADC_Stop>:
 *
 * Stop ADC (with waiting for pending ADC conversions to be finished)
 * ****************************************************************************	*/
void ADC_Stop(void)
{	
	if ( (ADC_CTRL & ADC_START) != 0u )											/* In case ADC is active, wait to finish it */
    8196:	7290      	lod	A, io:0x10 <__data_dp_size>
    8198:	b401      	and	A, #1
    819a:	190f      	je	0x81ba <_ADC_Stop+0x24>
	{
		ADC_CTRL &= ~(uint16)(ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);			/* Stop looping and HW-triggers */
    819c:	7290      	lod	A, io:0x10 <__data_dp_size>
    819e:	b6da ff79 	and	A, #65401
    81a2:	5290      	mov	io:0x10 <__data_dp_size>, A
extern void Timer_Start(TIMER_ID id,uint16 TimerPeriod);						/* Set timer by timer ID*/
extern uint8 Timer_IsExpired(TIMER_ID id);									/* Get the status of timer*/

static __inline__ void NopDelay(uint16 u16DelayCount)
{
	for (; u16DelayCount > 0u; u16DelayCount-- )
    81a4:	7290      	lod	A, io:0x10 <__data_dp_size>
    81a6:	b401      	and	A, #1
    81a8:	1908      	je	0x81ba <_ADC_Stop+0x24>
		while ( (ADC_CTRL & ADC_START) != 0u )									/* As long as the ADC is active ... */
		{
			ADC_CTRL |= ADC_SOFT_TRIG;											/* ... Set S/W trigger */
    81aa:	7290      	lod	A, io:0x10 <__data_dp_size>
    81ac:	a6da 0100 	or	A, #256
    81b0:	5290      	mov	io:0x10 <__data_dp_size>, A
    81b2:	7c12      	lod	X, #18
	{
		NOP();
    81b4:	0000      	nop
    81b6:	1bfe      	djnz	X, 0x81b4 <_ADC_Stop+0x1e>
    81b8:	07f5      	jmp	0x81a4 <_ADC_Stop+0xe>
			NopDelay( DELAY_7us); /*lint !e522 */
		}
	}
	ADC_CTRL = 0u;																/* Clear the ADC control register */
    81ba:	7000      	lod	A, #0
    81bc:	5290      	mov	io:0x10 <__data_dp_size>, A
	BEGIN_CRITICAL_SECTION();
    81be:	54d0      	psup	#0
	MASK &= ~EN_ADC_IT;															/* Disable ADC Interrupt */
    81c0:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    81c4:	b4bf      	and	A, #-65
    81c6:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	END_CRITICAL_SECTION();
    81ca:	72cb      	pop	M
#if ((LINPROT & LINXX) != LIN2J)
	g_u8AdcIsrMode = C_ADC_ISR_NONE;
    81cc:	6000      	lod	AL, #0
    81ce:	42d8 00bd 	mov	0xbd <_g_u8AdcIsrMode>, AL
    81d2:	5401      	ret

000081d4 <_ADC_Init>:
 *
 * Measure Zero-current offset
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Init( void)
{
    81d4:	5801      	inc	S, #2
	uint16 volatile u16ZCO;
	ADC_Stop();																	/* clear the ADC control register */
    81d6:	17df      	call	0x8196 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURROFF;
    81d8:	72da 997c 	lod	A, #39292
    81dc:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &u16ZCO;
    81de:	72ef      	lod	A, S
    81e0:	a0fe      	add	A, #-2
    81e2:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    81e4:	17bf      	call	0x8164 <_ADC_StartSoftTrig>
	l_u16CurrentZeroOffset = /* lint -e{530} */ u16ZCO;
    81e6:	7201      	lod	A, [S-2]
    81e8:	52d8 00be 	mov	0xbe <_l_u16CurrentZeroOffset>, A
	ADC_CTRL = (ADC_START | ADC_SOFT_TRIG);										/* Single shot */
    81ec:	72da 0101 	lod	A, #257
    81f0:	5290      	mov	io:0x10 <__data_dp_size>, A
	while ((ADC_CTRL & ADC_START) != 0u) /* lint -e{722} */ 						/* Wait for ADC result */
    81f2:	7290      	lod	A, io:0x10 <__data_dp_size>
    81f4:	b401      	and	A, #1
    81f6:	1d7d      	jne	0x81f2 <_ADC_Init+0x1e>
	{
		
	}
	l_u16CurrentZeroOffset = (l_u16CurrentZeroOffset + u16ZCO) >> 1u;
    81f8:	72d8 00be 	lod	A, 0xbe <_l_u16CurrentZeroOffset>
    81fc:	7a01      	lod	Y, [S-2]
    81fe:	a2e6      	add	A, Y
    8200:	4432      	lsr	A
    8202:	52d8 00be 	mov	0xbe <_l_u16CurrentZeroOffset>, A
	if ( u16Delta > 6 )															/* Need to define this value: 6 LSB's is approx. 5mA */
		l_u16CurrentZeroOffset = EE_OMCURR;										/* Take calibrated current offset, insetad of measured offset */
#endif /* SUPPORT_CALIBRATED_ZERO_CURRENT */


	PRIO &= ~((uint16)3u << 2u);												/* ADC IRQ Priority: 5 (3..6) (MMP150106-1) */
    8206:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    820a:	b4f3      	and	A, #-13
    820c:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(5u - 3u) << 2u);
    8210:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    8214:	a408      	or	A, #8
    8216:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
    821a:	5403      	ret	#4

0000821c <_ADC_Start>:
 *
 * ADC ISR priority: 3
 * ****************************************************************************	*/
void ADC_Start( void)
{
	ADC_Stop();																	/* clear the ADC control register */
    821c:	17bc      	call	0x8196 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_INIT_4PH;
    821e:	72da 9960 	lod	A, #39264
    8222:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4;
    8224:	72da 00f4 	lod	A, #244
    8228:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_CTRL  = (ADC_LOOP | ADC_TRIG_SRC | ADC_SYNC_SOC);						/* Loop cycle of conversion is done */
    822a:	72da 0086 	lod	A, #134
    822e:	5290      	mov	io:0x10 <__data_dp_size>, A
	ADC_CTRL |= ADC_START;														/* Start ADC */
    8230:	7290      	lod	A, io:0x10 <__data_dp_size>
    8232:	a401      	or	A, #1
    8234:	5290      	mov	io:0x10 <__data_dp_size>, A
	if ( l_u8AdcPowerOff != 0u)													/* MMP140618-1: Add delay */
    8236:	62d8 00bc 	lod	AL, 0xbc <_l_u8AdcPowerOff>
    823a:	1904      	je	0x8244 <_ADC_Start+0x28>
    823c:	7eda 008b 	lod	X, #139
    8240:	0000      	nop
    8242:	1bfe      	djnz	X, 0x8240 <_ADC_Start+0x24>
	{
		NopDelay( DELAY_mPWM); /*lint !e522 */
	}
	l_u8AdcPowerOff = FALSE;
    8244:	6000      	lod	AL, #0
    8246:	42d8 00bc 	mov	0xbc <_l_u8AdcPowerOff>, AL
    824a:	5401      	ret

0000824c <_ADC_PowerOff>:
 *
 * Power-off ADC, by disabling reference voltage
 * ****************************************************************************	*/
void ADC_PowerOff( void)
{
	ADC_Stop();																	/* Stop ADC conversion, and disable ADC-IRQ */
    824c:	17a4      	call	0x8196 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_VREF_OFF;
    824e:	72da 9980 	lod	A, #39296
    8252:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	PEND = CLR_ADC_IT;
    8254:	7040      	lod	A, #64
    8256:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	ADC_CTRL = ADC_START;
    825a:	7001      	lod	A, #1
    825c:	5290      	mov	io:0x10 <__data_dp_size>, A
	ADC_Stop();
    825e:	179b      	call	0x8196 <_ADC_Stop>
	l_u8AdcPowerOff = TRUE;
    8260:	6001      	lod	AL, #1
    8262:	42d8 00bc 	mov	0xbc <_l_u8AdcPowerOff>, AL
    8266:	5401      	ret

00008268 <_ADC_IT>:
 * (push/pop + check for LIN-AA + Check BEMF ZC)
 * ****************************************************************************	*/
__interrupt__ void ADC_IT(void) 
{
#if ((LINPROT & LINXX) != LIN2J)
	if ( g_u8AdcIsrMode == C_ADC_ISR_LIN_AA ) 									/* LIN-AutoAddressing sequence */
    8268:	4407      	mov	R, #0
    826a:	72cb      	pop	M
    826c:	5401      	ret

0000826e <_GetVsupply>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupply( void)
{
	uint16 u16FilteredSupplyVoltage = g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    826e:	7ad8 00f6 	lod	Y, 0xf6 <_g_AdcMotorRunStepper4+0x2>
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8272:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    8276:	5ce2      	ssex	A
    8278:	eae2      	sub	Y, A
    827a:	72d8 11cc 	lod	A, 0x11cc <__ep__+0x1cc>
    827e:	6000      	lod	AL, #0
    8280:	72e4      	swap	A
    int32 result;

    __asm__ __volatile__ (
    8282:	4811      	muls	D, A, Y
 *
 * Example:
 *   int32 result = ((int32) a) * b
 */
static __inline__ int32 mulI32_I16byI16(int16 a, int16 b)
{
    8284:	4c80      	mov	YA, D
    8286:	4c22 0020 	add	YA, #32
    828a:	0000 
    828c:	4cb2 0000 	cmp	YA, #0
    8290:	0000 
    8292:	1e84      	jsge	0x829c <_GetVsupply+0x2e>
    8294:	4c80      	mov	YA, D
    8296:	4c22 005f 	add	YA, #95
    829a:	0000 
    829c:	48b5      	asr	YA, #6
    829e:	52d8 00b6 	mov	0xb6 <_g_i16SupplyVoltage>, A
    82a2:	5401      	ret

000082a4 <_GetVsupplyMotor>:
 *
 * Get Supply-voltage [10mV]
 * ****************************************************************************	*/
void GetVsupplyMotor( void)
{
	uint16 u16FilteredDriverVoltage = g_AdcMotorRunStepper4.FilteredDriverVoltage;
    82a4:	72d8 00fa 	lod	A, 0xfa <_g_AdcMotorRunStepper4+0x6>
#if _SUPPORT_VSMFILTERED
	g_i16MotorVoltage = (int16) ((mulI32_I16byU16( (int16)(u16FilteredDriverVoltage - EE_OVOLTAGE), EE_GVOLTAGE) + (C_GVOLTAGE_DIV/2)) / C_GVOLTAGE_DIV);
    82a8:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    82ac:	5ce6      	ssex	Y
    82ae:	aae6      	sub	A, Y
    82b0:	7ad8 11ce 	lod	Y, 0x11ce <__ep__+0x1ce>
    82b4:	6400      	lod	YL, #0
    82b6:	7ae8      	swap	Y
    82b8:	5adf      	push	Y
    82ba:	82db 6c12 	callf	0x6c12 <_mulI32_I16byU16>
    82be:	4cc0      	mov	D, YA
    82c0:	4c22 0020 	add	YA, #32
    82c4:	0000 
    82c6:	4cb2 0000 	cmp	YA, #0
    82ca:	0000 
    82cc:	1e84      	jsge	0x82d6 <_GetVsupplyMotor+0x32>
    82ce:	4c80      	mov	YA, D
    82d0:	4c22 005f 	add	YA, #95
    82d4:	0000 
    82d6:	48b5      	asr	YA, #6
    82d8:	52d8 00b4 	mov	0xb4 <_g_i16MotorVoltage>, A
    82dc:	5c01      	dec	S, #2
    82de:	5401      	ret

000082e0 <_ResetChipTemperature>:
 *
 * Reset Chip temperature
 * ****************************************************************************	*/
void ResetChipTemperature( void)
{
	g_AdcMotorRunStepper4.IntTemperatureSensor = 0u;
    82e0:	7ada 00f4 	lod	Y, #244
    82e4:	7000      	lod	A, #0
    82e6:	52f0      	mov	[Y], A
    82e8:	5401      	ret

000082ea <_GetChipTemperature>:
 * GetChipTemperature()
 *
 * Get Chip temperature [C]
 * ****************************************************************************	*/
void GetChipTemperature( uint16 u16Init)										/* MMP131020-1 */
{
    82ea:	580b      	inc	S, #12
    82ec:	520b      	mov	[S-12], A
	uint16 u16ChipTemperatureSensor = g_AdcMotorRunStepper4.IntTemperatureSensor;
    82ee:	7ad8 00f4 	lod	Y, 0xf4 <_g_AdcMotorRunStepper4>
	int16 i16ChipTemperature, i16ChipTempDelta;

#if _SUPPORT_TWO_LINE_TEMP_INTERPOLATION
	if ( u16ChipTemperatureSensor < EE_OTEMP )
    82f2:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    82f6:	eee2      	cmp	Y, A
    82f8:	1c11      	jnc	0x831c <_GetChipTemperature+0x32>
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    82fa:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    82fe:	aae6      	sub	A, Y
    8300:	5203      	mov	[S-4], A
    8302:	785a      	lod	Y, #90
    8304:	7ed8 11ba 	lod	X, 0x11ba <__ep__+0x1ba>
    8308:	72d8 11bc 	lod	A, 0x11bc <__ep__+0x1bc>
    830c:	2ae2      	sub	X, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    830e:	7203      	lod	A, [S-4]
    8310:	4821      	mulu	YA, A, Y
    8312:	4c63      	divu	YA, X
    8314:	4c63      	divu	YA, X
    8316:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8318:	2023      	add	X, #35
    831a:	0012      	jmp	0x8340 <_GetChipTemperature+0x56>
    831c:	72d8 11ba 	lod	A, 0x11ba <__ep__+0x1ba>
    8320:	eae2      	sub	Y, A
    8322:	5a01      	mov	[S-2], Y
    8324:	7ed8 11b8 	lod	X, 0x11b8 <__ep__+0x1b8>
    8328:	7ad8 11ba 	lod	Y, 0x11ba <__ep__+0x1ba>
    832c:	2ae6      	sub	X, Y
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    832e:	704b      	lod	A, #75
    8330:	7a01      	lod	Y, [S-2]
    8332:	4821      	mulu	YA, A, Y
    8334:	4c63      	divu	YA, X
    8336:	4c63      	divu	YA, X
    8338:	7ee2      	lod	X, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    833a:	7023      	lod	A, #35
    833c:	aaee      	sub	A, X
    833e:	7ee2      	lod	X, A
	}
#else  /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */
	i16ChipTemperature = (mulI32_I16byI16( (EE_OTEMP - u16ChipTemperatureSensor), EE_GTEMP) / C_GTEMP_DIV) + EE_MIDTEMP;
#endif /* _SUPPORT_TWO_LINE_TEMP_INTERPOLATION */

	if ( u16Init == FALSE )														/* MMP131020-1 */
    8340:	720b      	lod	A, [S-12]
    8342:	1d10      	jne	0x8364 <_GetChipTemperature+0x7a>
	{
		i16ChipTempDelta = i16ChipTemperature - g_i16ChipTemperature;			/* Delta-temp = new-temp - previous-temp */
    8344:	7ad8 00b2 	lod	Y, 0xb2 <_g_i16ChipTemperature>
    8348:	72ee      	lod	A, X
    834a:	aae6      	sub	A, Y
		if ( i16ChipTempDelta < 0 )
		{
			i16ChipTempDelta = -i16ChipTempDelta;								/* Absolute temperature change */
    834c:	ac00      	cmp	A, #0
    834e:	1e81      	jsge	0x8352 <_GetChipTemperature+0x68>
    8350:	5cc2      	neg	A
		}
		if ( (uint16) i16ChipTempDelta > C_TEMPERATURE_JUMP )					/* Temperature change small, then accept new temperature */
    8352:	ac0a      	cmp	A, #10
    8354:	1a07      	jule	0x8364 <_GetChipTemperature+0x7a>
		{
			if ( i16ChipTemperature > g_i16ChipTemperature )					/* To great temperature change; Check temperature change "direction" */
    8356:	2ee6      	cmp	X, Y
    8358:	1b03      	jsle	0x8360 <_GetChipTemperature+0x76>
			{
				i16ChipTemperature = g_i16ChipTemperature + 1;					/* Increase by one degree */
    835a:	7ee6      	lod	X, Y
    835c:	2001      	add	X, #1
    835e:	0002      	jmp	0x8364 <_GetChipTemperature+0x7a>
			}
			else
			{
				i16ChipTemperature = g_i16ChipTemperature - 1;					/* Decrease by one degree */
    8360:	7ee6      	lod	X, Y
    8362:	20ff      	add	X, #-1
			}
		}
	}																			/* MMP131020-1 */
	g_i16ChipTemperature = i16ChipTemperature;
    8364:	5ed8 00b2 	mov	0xb2 <_g_i16ChipTemperature>, X
    8368:	540d      	ret	#14

0000836a <_GetRawMotorDriverCurrent>:
 * ****************************************************************************	*/
uint16 GetRawMotorDriverCurrent( void)
{
	uint16 u16Current = 0;
#if ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL))
	u16Current = g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    836a:	72d8 00fc 	lod	A, 0xfc <_g_AdcMotorRunStepper4+0x8>
	if ( u16Current > l_u16CurrentZeroOffset )
    836e:	7ad8 00be 	lod	Y, 0xbe <_l_u16CurrentZeroOffset>
    8372:	aee6      	cmp	A, Y
    8374:	1a02      	jule	0x837a <_GetRawMotorDriverCurrent+0x10>
	{
		g_u16CurrentMotorCoilA = u16Current -  l_u16CurrentZeroOffset;
    8376:	aae6      	sub	A, Y
    8378:	0001      	jmp	0x837c <_GetRawMotorDriverCurrent+0x12>
	}
	else
	{
		g_u16CurrentMotorCoilA = 0u;
    837a:	7000      	lod	A, #0
    837c:	52d8 00ba 	mov	0xba <__bss_size>, A
	}
	
	u16Current = g_AdcMotorRunStepper4.UnfilteredDriverCurrent2;
    8380:	72d8 00f8 	lod	A, 0xf8 <_g_AdcMotorRunStepper4+0x4>
	if ( u16Current > l_u16CurrentZeroOffset )
    8384:	7ad8 00be 	lod	Y, 0xbe <_l_u16CurrentZeroOffset>
    8388:	aee6      	cmp	A, Y
    838a:	1a02      	jule	0x8390 <_GetRawMotorDriverCurrent+0x26>
	{
		g_u16CurrentMotorCoilB = u16Current - l_u16CurrentZeroOffset;
    838c:	aae6      	sub	A, Y
    838e:	0001      	jmp	0x8392 <_GetRawMotorDriverCurrent+0x28>
	}
	else
	{
		g_u16CurrentMotorCoilB = 0u;
    8390:	7000      	lod	A, #0
    8392:	52d8 00b8 	mov	0xb8 <_g_u16CurrentMotorCoilB>, A
	}
	u16Current = g_u16CurrentMotorCoilA + g_u16CurrentMotorCoilB;
    8396:	72d8 00ba 	lod	A, 0xba <__bss_size>
    839a:	a2d8 00b8 	add	A, 0xb8 <_g_u16CurrentMotorCoilB>
		u16Current = u16Current - l_u16CurrentZeroOffset;
	}
#endif /* ((_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND) || (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL)) */

	return ( u16Current );
} /* End of GetRawMotorDriverCurrent() */
    839e:	5401      	ret

000083a0 <_GetMotorDriverCurrent>:
 *
 * Get Motor Driver Current [mA]
 * ****************************************************************************	*/
int16 GetMotorDriverCurrent( void)
{
	uint16 u16Current = GetRawMotorDriverCurrent();
    83a0:	17e4      	call	0x836a <_GetRawMotorDriverCurrent>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    83a2:	7ad8 11d0 	lod	Y, 0x11d0 <__ep__+0x1d0>
    83a6:	f6da 00ff 	and	Y, #255
    83aa:	e2da 0100 	add	Y, #256
    uint32 result;

    __asm__ __volatile__ (
    83ae:	4801      	mulu	D, A, Y
    83b0:	4c80      	mov	YA, D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    83b2:	4c22 0040 	add	YA, #64
    83b6:	0000 
    83b8:	48a6      	lsr	YA, #7
	u16Current = (uint16) ((mulU32_U16byU16( u16Current, EE_GMCURR) + (C_GMCURR_DIV/2u)) / C_GMCURR_DIV);	/* MMP131117-1 */
	return ( (int16) u16Current);
} /* End of GetMotorDriverCurrent() */
    83ba:	5401      	ret

000083bc <_MeasureVsupplyAndTemperature>:
 *
 * Measure Vbat and Temperature (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureVsupplyAndTemperature( void)
{	
	ADC_Stop();
    83bc:	16ec      	call	0x8196 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_MOTORVOLT;										/* switch ADC input source to Voltage */
    83be:	72da 9970 	lod	A, #39280
    83c2:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredDriverVoltage;
    83c4:	72da 00fa 	lod	A, #250
    83c8:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    83ca:	16cc      	call	0x8164 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_SUPPLYVOLT;										/* switch ADC input source to Voltage */
    83cc:	72da 9974 	lod	A, #39284
    83d0:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.FilteredSupplyVoltage;
    83d2:	72da 00f6 	lod	A, #246
    83d6:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    83d8:	16c5      	call	0x8164 <_ADC_StartSoftTrig>

	ADC_SBASE = (uint16) SBASE_TEMP;											/* switch ADC input source to Temperature */
    83da:	72da 9978 	lod	A, #39288
    83de:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.IntTemperatureSensor;
    83e0:	72da 00f4 	lod	A, #244
    83e4:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    83e6:	16be      	call	0x8164 <_ADC_StartSoftTrig>
    83e8:	5401      	ret

000083ea <_MeasureMotorCurrent>:
 *
 * Measure Motor-current (filtered) (single-shot, software triggered)
 * ****************************************************************************	*/
void MeasureMotorCurrent( void)
{
	ADC_Stop();
    83ea:	16d5      	call	0x8196 <_ADC_Stop>
	ADC_SBASE = (uint16) SBASE_CURRENT;											/* switch ADC input source to Motor-driver current */
    83ec:	72da 996c 	lod	A, #39276
    83f0:	5292      	mov	io:0x12 <__data_dp_size+0x2>, A
	ADC_DBASE = (uint16) &g_AdcMotorRunStepper4.UnfilteredDriverCurrent;
    83f2:	72da 00fc 	lod	A, #252
    83f6:	5294      	mov	io:0x14 <__data_dp_size+0x4>, A
	ADC_StartSoftTrig();														/* MMP140709-1 */
    83f8:	16b5      	call	0x8164 <_ADC_StartSoftTrig>
    83fa:	5401      	ret

000083fc <_HandleDiagnosticEvent>:
 * HandleDiagnosticEvent()
 *
 * Handle Diagnostic Events
 * ****************************************************************************	*/
void HandleDiagnosticEvent( uint16 u16Event)
{
    83fc:	5801      	inc	S, #2
    83fe:	5201      	mov	[S-2], A
	if ( (u16Event & (uint16)(XI4_OC_DRV | XI4_OVT)) != 0u )
    8400:	b6da 8100 	and	A, #33024
    8404:	1d01      	jne	0x8408 <_HandleDiagnosticEvent+0xc>
    8406:	003d      	jmp	0x8482 <_HandleDiagnosticEvent+0x86>
	{
		/* In case over-current or over-temperature, switch off motor */
#if _SUPPORT_DIAG_OC
		if ( (u16Event & (uint16)XI4_OC_DRV) != 0u )
    8408:	7201      	lod	A, [S-2]
    840a:	b6da 0100 	and	A, #256
    840e:	191f      	je	0x844e <_HandleDiagnosticEvent+0x52>
			/* Chip over-current */
			/* The over-current may occur then chips has entered test-mode. The test-mode freezes the
			 * complete digital part of the chip, including the Motor PWM and driver. This may result
			 * in a phase H and a phase L, having a DC-current flow!!
			 */
			if (g_u8MotorStartupMode != (uint8) MSM_STOP)
    8410:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8414:	190a      	je	0x842a <_HandleDiagnosticEvent+0x2e>
    8416:	7eda 008b 	lod	X, #139
    841a:	0000      	nop
    841c:	1bfe      	djnz	X, 0x841a <_HandleDiagnosticEvent+0x1e>
			{
				/* Average between two driver-current measurements */
				NopDelay( DELAY_mPWM); /*lint !e522 */								/* Wait for ESD pulse to be gone and a new ADC measurement have been take place */
				g_i16Current = GetMotorDriverCurrent();
    841e:	17c0      	call	0x83a0 <_GetMotorDriverCurrent>
    8420:	52d8 00b0 	mov	0xb0 <_g_i16Current>, A
				if ( g_i16Current > 1400 )
    8424:	aeda 0578 	cmp	A, #1400
    8428:	1b12      	jsle	0x844e <_HandleDiagnosticEvent+0x52>
					SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
				}
			}
			else
			{
				DRVCFG_DIS_UVWT();												/* Over-current,holding current mode? */
    842a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    842e:	b6da fe00 	and	A, #65024
    8432:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
				DRVCFG_DIS();	
    8436:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    843a:	a6da 0100 	or	A, #256
    843e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
				g_sMotorFault.SHORT = 1u;
    8442:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8444:	8408      	or	AL, #8
    8446:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				SetLastError( (uint8) C_ERR_DIAG_OVER_CURRENT);
    8448:	72da 00d0 	lod	A, #208
    844c:	11c5      	call	0x87d8 <_SetLastError>
			}
		}
#endif /* _SUPPORT_DIAG_OC */
		if ( (u16Event & (uint16)XI4_OVT) != 0u )
    844e:	7201      	lod	A, [S-2]
    8450:	ac00      	cmp	A, #0
    8452:	1e97      	jsge	0x8482 <_HandleDiagnosticEvent+0x86>
		{
			DRVCFG_DIS_UVWT();													/* Over-temperature shutdown,170+-15 */
    8454:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8458:	b6da fe00 	and	A, #65024
    845c:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();
    8460:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8464:	a6da 0100 	or	A, #256
    8468:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			g_sMotorFault.TS = 1u;
    846c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    846e:	8420      	or	AL, #32
    8470:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
			SetLastError( (uint8) C_ERR_DIAG_OVER_TEMP);
    8472:	72da 00d1 	lod	A, #209
    8476:	11b0      	call	0x87d8 <_SetLastError>

			ResetChipTemperature();
    8478:	1733      	call	0x82e0 <_ResetChipTemperature>
    847a:	7eda 008b 	lod	X, #139
    847e:	0000      	nop
    8480:	1bfe      	djnz	X, 0x847e <_HandleDiagnosticEvent+0x82>
    8482:	5403      	ret	#4

00008484 <_DiagnosticsInit>:
 * Don't automatically shut-off motor-driver on over- or under-voltage, or over-temperature.
 * Diagnostic ISR priority: 3 
 * ****************************************************************************	*/
void DiagnosticsInit( void)
{
	DRVCFG |= (DIS_OC | DIS_OT | DIS_OV | DIS_UV);					/* Disable over-current, over-temperature, over-voltage, under-voltage */
    8484:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8488:	a6da f000 	or	A, #61440
    848c:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
	ANA_OUTI &= ~SEL_UV_VS;											/* Enable UV & OV debounce circuitry */
    8490:	72d8 28d0 	lod	A, 0x28d0 <__io__+0xd0>
    8494:	b6da efff 	and	A, #61439
    8498:	52d8 28d0 	mov	0x28d0 <__io__+0xd0>, A
	ANA_OUTG &= 0xFCFFu;												/* Brown-out UV-level = 6V + n * 1V; */
    849c:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    84a0:	b6da fcff 	and	A, #64767
    84a4:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
	ANA_OUTG |= (NVRAM_BROWNOUT_LEVEL << 8u);				
    84a8:	72d8 28cc 	lod	A, 0x28cc <__io__+0xcc>
    84ac:	a6da 0100 	or	A, #256
    84b0:	52d8 28cc 	mov	0x28cc <__io__+0xcc>, A
#if (_SUPPORT_DIAG_OVT == FALSE)
	ANA_OUTG |= INACTIVE_OVT;													/* MMP150409-2 */
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */

#if (_SUPPORT_HALL_SENSOR)
	XI4_PEND = (C_DIAG_MASK | XI4_IO5);
    84b4:	72da e120 	lod	A, #57632
    84b8:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	XI4_MASK |= (C_DIAG_MASK | XI4_IO5);										/* Enable second-level diagnostic interrupts and Hall-switch @ IO[0] */
    84bc:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    84c0:	a6da e120 	or	A, #57632
    84c4:	52d8 2032 	mov	0x2032 <__ep__+0x1032>, A
	l_u16HallSwitchState = (IO_IN & XI4_IO5);
    84c8:	72d8 28ca 	lod	A, 0x28ca <__io__+0xca>
    84cc:	b420      	and	A, #32
    84ce:	52d8 00cc 	mov	0xcc <_l_u16HallSwitchState>, A
	if ( l_u16HallSwitchState != 0u)
    84d2:	1904      	je	0x84dc <_DiagnosticsInit+0x58>
	{
		/* IO[0] is high; Set IRQ-event on falling-edge */
		IO_CFG |= FRB_IO5;
    84d4:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    84d8:	a420      	or	A, #32
    84da:	0003      	jmp	0x84e2 <_DiagnosticsInit+0x5e>
	}
	else
	{
		/* IO[0] is low; Set IRQ-event on rising-edge */
		IO_CFG &= ~FRB_IO5;
    84dc:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    84e0:	b4df      	and	A, #-33
    84e2:	52d8 28be 	mov	0x28be <__io__+0xbe>, A
#else  /* (_SUPPORT_HALL_SENSOR) */
	XI4_PEND = C_DIAG_MASK;
	XI4_MASK |= C_DIAG_MASK;
#endif /* (_SUPPORT_HALL_SENSOR) */
	/* PRIO = (PRIO & ~(3U << 14)) | ((3U - 3U) << 14); */							/* EXT4_IT Priority: 3 (3..6) */
	PRIO &= ~((uint16)3u << 14u);												/* EXT4_IT Priority: 3 (3..6) */
    84e6:	72d8 2004 	lod	A, 0x2004 <__ep__+0x1004>
    84ea:	b6da 3fff 	and	A, #16383
    84ee:	52d8 2004 	mov	0x2004 <__ep__+0x1004>, A
	PRIO |= ((uint16)(3u - 3u) << 14u);
	PEND = CLR_EXT4_IT;
    84f2:	72da 1000 	lod	A, #4096
    84f6:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
	MASK |= EN_EXT4_IT;															/* Enable Diagnostic Interrupt */
    84fa:	72d8 2006 	lod	A, 0x2006 <__ep__+0x1006>
    84fe:	a6da 1000 	or	A, #4096
    8502:	52d8 2006 	mov	0x2006 <__ep__+0x1006>, A
	/* MMP141212-1: Check for OVT and OV. Perform Diagnostics handling if required */
	{
#if (_SUPPORT_DIAG_OVT == FALSE)
		uint16 u16DiagnosticEvent = (ANA_INA & XI4_OV);
#else  /* (_SUPPORT_DIAG_OVT == FALSE) */
		uint16 u16DiagnosticEvent = (ANA_INA & (XI4_OVT | XI4_OV));
    8506:	729c      	lod	A, io:0x1c <_g_sMotorFault>
    8508:	b6da a000 	and	A, #40960
#endif /* (_SUPPORT_DIAG_OVT == FALSE) */
		if ( u16DiagnosticEvent != 0u )
    850c:	1901      	je	0x8510 <_DiagnosticsInit+0x8c>
		{
			HandleDiagnosticEvent( u16DiagnosticEvent);
    850e:	1776      	call	0x83fc <_HandleDiagnosticEvent>
    8510:	5401      	ret

00008512 <_EXT4_IT>:
 * EXT4_IT()
 *
 * Diagnostic & IO Interrupt Service Routine.
 * ****************************************************************************	*/
__interrupt__ void EXT4_IT(void)
{
    8512:	52df      	push	A
    8514:	5edf      	push	X
    8516:	5adf      	push	Y
    8518:	4c83      	push	D
    851a:	5801      	inc	S, #2
	uint16 u16Pending = (XI4_PEND & XI4_MASK);									/* Copy interrupt requests which are not masked   */
    851c:	7ad8 203c 	lod	Y, 0x203c <__ep__+0x103c>
    8520:	72d8 2032 	lod	A, 0x2032 <__ep__+0x1032>
    8524:	f6e2      	and	Y, A
    8526:	5a01      	mov	[S-2], Y
	do
	{
		XI4_PEND = u16Pending;													/* Clear requests which are going to be processed */
    8528:	7201      	lod	A, [S-2]
    852a:	52d8 203c 	mov	0x203c <__ep__+0x103c>, A
	} while ((XI4_PEND & u16Pending) != 0u);
    852e:	72d8 203c 	lod	A, 0x203c <__ep__+0x103c>
    8532:	b601      	and	A, [S-2]
    8534:	1d79      	jne	0x8528 <_EXT4_IT+0x16>

	/* Multiple diagnostics events is most likely caused by Rinnen/ESD-pulse */
	if ( ((u16Pending & XI4_UV) != 0u) && ((u16Pending & (XI4_OC_DRV | XI4_OVT | XI4_OV)) != 0u) )
    8536:	7201      	lod	A, [S-2]
    8538:	b6da 4000 	and	A, #16384
    853c:	1904      	je	0x8546 <_EXT4_IT+0x34>
    853e:	7201      	lod	A, [S-2]
    8540:	b6da a100 	and	A, #41216
    8544:	1d17      	jne	0x8574 <_EXT4_IT+0x62>
	{
		/* Under-voltage together with any other diagnostic event is strange */
	}
	else
	{
		HandleDiagnosticEvent( u16Pending);
    8546:	7201      	lod	A, [S-2]
    8548:	1759      	call	0x83fc <_HandleDiagnosticEvent>

		if ( (u16Pending & XI4_IO5) != 0u )
    854a:	7201      	lod	A, [S-2]
    854c:	b420      	and	A, #32
    854e:	1912      	je	0x8574 <_EXT4_IT+0x62>
		{
			l_u16HallSwitchState = (IO_IN & XI4_IO5);
    8550:	72d8 28ca 	lod	A, 0x28ca <__io__+0xca>
    8554:	b420      	and	A, #32
    8556:	52d8 00cc 	mov	0xcc <_l_u16HallSwitchState>, A
			if ( l_u16HallSwitchState != 0u )
    855a:	1904      	je	0x8564 <_EXT4_IT+0x52>
			{
				/* IO[0] is high; Set IRQ-event on falling-edge */
				IO_CFG |= FRB_IO5;
    855c:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    8560:	a420      	or	A, #32
    8562:	0003      	jmp	0x856a <_EXT4_IT+0x58>
			}
			else
			{
				/* IO[0] is low; Set IRQ-event on rising-edge */
				IO_CFG &= ~FRB_IO5;
    8564:	72d8 28be 	lod	A, 0x28be <__io__+0xbe>
    8568:	b4df      	and	A, #-33
    856a:	52d8 28be 	mov	0x28be <__io__+0xbe>, A
			}

			g_u16HallMicroStepIdx = g_u16ActuatorActPos;
    856e:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8570:	52d8 00ce 	mov	0xce <_g_u16HallMicroStepIdx>, A
    8574:	5c01      	dec	S, #2
    8576:	4cc3      	pop	D
    8578:	7acf      	pop	Y
    857a:	7ecf      	pop	X
    857c:	72cf      	pop	A
    857e:	4407      	mov	R, #0
    8580:	72cb      	pop	M
    8582:	5401      	ret

00008584 <_MotorDiagnosticCheckInit>:
	}
} /* EXT4_IT() */

void MotorDiagnosticCheckInit(void)
{
	l_u16CoilCurrentStartDelay = C_MOVAVG_SZ;
    8584:	7020      	lod	A, #32
    8586:	52d8 00c0 	mov	0xc0 <_l_u16CoilCurrentStartDelay>, A
	l_u16CoilZeroCurrCountA = 0u;
    858a:	7000      	lod	A, #0
    858c:	52d8 00c4 	mov	0xc4 <_l_u16CoilZeroCurrCountA>, A
	l_u16CoilZeroCurrCountB = 0u;
    8590:	52d8 00c2 	mov	0xc2 <_l_u16CoilZeroCurrCountB>, A
    8594:	5401      	ret

00008596 <_MotorDiagnosticOpenCheck>:
}

uint8  MotorDiagnosticOpenCheck(void)
{
	
	if(l_u16CoilCurrentStartDelay == 0u)
    8596:	72d8 00c0 	lod	A, 0xc0 <_l_u16CoilCurrentStartDelay>
    859a:	1d2c      	jne	0x85f4 <_MotorDiagnosticOpenCheck+0x5e>
	{
		if( g_u16CurrentMotorCoilA <  C_MIN_COIL_CURRENT )
    859c:	72d8 00ba 	lod	A, 0xba <__bss_size>
    85a0:	7ad8 00c4 	lod	Y, 0xc4 <_l_u16CoilZeroCurrCountA>
    85a4:	7ed8 00b8 	lod	X, 0xb8 <_g_u16CurrentMotorCoilB>
    85a8:	ac09      	cmp	A, #9
    85aa:	1e03      	jug	0x85b2 <_MotorDiagnosticOpenCheck+0x1c>
		{
			l_u16CoilZeroCurrCountA++;
    85ac:	72e6      	lod	A, Y
    85ae:	a001      	add	A, #1
    85b0:	0004      	jmp	0x85ba <_MotorDiagnosticOpenCheck+0x24>
		}
		else
		{
			if ( l_u16CoilZeroCurrCountA > 0u )
    85b2:	ec00      	cmp	Y, #0
    85b4:	1904      	je	0x85be <_MotorDiagnosticOpenCheck+0x28>
			{
				l_u16CoilZeroCurrCountA--;
    85b6:	72e6      	lod	A, Y
    85b8:	a0ff      	add	A, #-1
    85ba:	52d8 00c4 	mov	0xc4 <_l_u16CoilZeroCurrCountA>, A
    85be:	7ad8 00c4 	lod	Y, 0xc4 <_l_u16CoilZeroCurrCountA>
    85c2:	72d8 00c2 	lod	A, 0xc2 <_l_u16CoilZeroCurrCountB>
			}
		}

		if( g_u16CurrentMotorCoilB < C_MIN_COIL_CURRENT  )
    85c6:	2c09      	cmp	X, #9
    85c8:	1e02      	jug	0x85ce <_MotorDiagnosticOpenCheck+0x38>
		{
			l_u16CoilZeroCurrCountB++;
    85ca:	a001      	add	A, #1
    85cc:	0003      	jmp	0x85d4 <_MotorDiagnosticOpenCheck+0x3e>
		}
		else
		{
			if ( l_u16CoilZeroCurrCountB > 0u )
    85ce:	ac00      	cmp	A, #0
    85d0:	1903      	je	0x85d8 <_MotorDiagnosticOpenCheck+0x42>
			{
				l_u16CoilZeroCurrCountB--;
    85d2:	a0ff      	add	A, #-1
    85d4:	52d8 00c2 	mov	0xc2 <_l_u16CoilZeroCurrCountB>, A
			}
		}

		if((l_u16CoilZeroCurrCountA >= C_COIL_ZERO_CURRENT_COUNT) || (l_u16CoilZeroCurrCountB >= C_COIL_ZERO_CURRENT_COUNT))
    85d8:	ec0f      	cmp	Y, #15
    85da:	1e04      	jug	0x85e4 <_MotorDiagnosticOpenCheck+0x4e>
    85dc:	72d8 00c2 	lod	A, 0xc2 <_l_u16CoilZeroCurrCountB>
    85e0:	ac0f      	cmp	A, #15
    85e2:	1a0b      	jule	0x85fa <_MotorDiagnosticOpenCheck+0x64>
		{
			g_sMotorFault.OPEN = 1u;
    85e4:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    85e6:	8404      	or	AL, #4
    85e8:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
			SetLastError( (uint8) C_ERR_COIL_ZERO_CURRENT);
    85ea:	72da 00e6 	lod	A, #230
    85ee:	10f4      	call	0x87d8 <_SetLastError>
			return 1;
    85f0:	7001      	lod	A, #1
    85f2:	5401      	ret
	}
	else
	{
		if(l_u16CoilCurrentStartDelay > 0u)
		{
			l_u16CoilCurrentStartDelay--;
    85f4:	a0ff      	add	A, #-1
    85f6:	52d8 00c0 	mov	0xc0 <_l_u16CoilCurrentStartDelay>, A
		}
	}

	return 0;
    85fa:	7000      	lod	A, #0
}
    85fc:	5401      	ret

000085fe <_MotorDiagnosticVsupplyAndTemperature>:
{
	
	int16 voltage_raw;

	/* Perform Vbat/Temperature measurement incase motor is stopped */
	if(g_u8MotorStartupMode == (uint8) MSM_STOP)	
    85fe:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8602:	1d01      	jne	0x8606 <_MotorDiagnosticVsupplyAndTemperature+0x8>
	{
		MeasureVsupplyAndTemperature();
    8604:	16db      	call	0x83bc <_MeasureVsupplyAndTemperature>
	}
	/***************************************************
	 * p. Motor over/under temperature
	***************************************************/
	/* Calculate Voltage (100LSB/V) [10mV] */
	GetVsupply();
    8606:	1633      	call	0x826e <_GetVsupply>
	GetVsupplyMotor();
    8608:	164d      	call	0x82a4 <_GetVsupplyMotor>
	/* supply voltage is compensated with the shorty diode voltage drop and inductor voltage drop 
		 * in motor run(current peak) and motor stop(current valley) conditions.
	  */
	if (g_u8MotorStartupMode  != (uint8) MSM_STOP )
    860a:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    860e:	7ad8 00b4 	lod	Y, 0xb4 <_g_i16MotorVoltage>
    8612:	8c00      	cmp	AL, #0
    8614:	1903      	je	0x861c <_MotorDiagnosticVsupplyAndTemperature+0x1e>
	{
		voltage_raw = g_i16MotorVoltage + C_VDS_RUN;
    8616:	72e6      	lod	A, Y
    8618:	a041      	add	A, #65
    861a:	0002      	jmp	0x8620 <_MotorDiagnosticVsupplyAndTemperature+0x22>
	}
	else
	{
		voltage_raw = g_i16MotorVoltage + C_VDS_STOP;
    861c:	72e6      	lod	A, Y
    861e:	a023      	add	A, #35
	}

	if ( voltage_raw < (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS) )
    8620:	aeda 03b5 	cmp	A, #949
    8624:	1f16      	jsg	0x8652 <_MotorDiagnosticVsupplyAndTemperature+0x54>
	{
		voltage_raw = (NVRAM_APPL_UVOLT - C_VOLTAGE_HYS);
		/* First time application under-voltage error */					/* MMP150128-1 - Begin */
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_UV) == 0x00u )
    8626:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    862a:	72e6      	lod	A, Y
    862c:	b404      	and	A, #4
    862e:	1d03      	jne	0x8636 <_MotorDiagnosticVsupplyAndTemperature+0x38>
		{
			/* Need twice a under-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_UV;
    8630:	62e8      	lod	AL, YL
    8632:	8404      	or	AL, #4
    8634:	0032      	jmp	0x869a <_MotorDiagnosticVsupplyAndTemperature+0x9c>
			l_u8UOVoltageCount = 0u;
		}
		else
		{
			l_u8UOVoltageCount++;
    8636:	62d8 00c8 	lod	AL, 0xc8 <_l_u8UOVoltageCount>
    863a:	8001      	add	AL, #1
    863c:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    8640:	8c05      	cmp	AL, #5
    8642:	1e01      	jug	0x8646 <_MotorDiagnosticVsupplyAndTemperature+0x48>
    8644:	0040      	jmp	0x86c6 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    8646:	6006      	lod	AL, #6
    8648:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
				g_sMotorFault.UV = 1u; 								/* 9.5.3.4 */
    864c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    864e:	8401      	or	AL, #1
    8650:	0039      	jmp	0x86c4 <_MotorDiagnosticVsupplyAndTemperature+0xc6>
			}
		}
	}
	else if ( voltage_raw > (NVRAM_APPL_OVOLT + C_VOLTAGE_HYS) )
    8652:	aeda 0672 	cmp	A, #1650
    8656:	1b15      	jsle	0x8682 <_MotorDiagnosticVsupplyAndTemperature+0x84>
	{
		/* First time application over-voltage error */
		if ( (l_e8ErrorDebounceFilter & C_DEBFLT_ERR_OV) == 0x00u )
    8658:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    865c:	72e6      	lod	A, Y
    865e:	b408      	and	A, #8
    8660:	1d03      	jne	0x8668 <_MotorDiagnosticVsupplyAndTemperature+0x6a>
		{
			/* Need twice a over-voltage detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OV;
    8662:	62e8      	lod	AL, YL
    8664:	8408      	or	AL, #8
    8666:	0019      	jmp	0x869a <_MotorDiagnosticVsupplyAndTemperature+0x9c>
			l_u8UOVoltageCount = 0u;
		}
		else
		{
			l_u8UOVoltageCount++;
    8668:	62d8 00c8 	lod	AL, 0xc8 <_l_u8UOVoltageCount>
    866c:	8001      	add	AL, #1
    866e:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    8672:	8c05      	cmp	AL, #5
    8674:	1a28      	jule	0x86c6 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    8676:	6006      	lod	AL, #6
    8678:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
				g_sMotorFault.OV = 1u;									/* 9.5.3.4 */
    867c:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    867e:	8402      	or	AL, #2
    8680:	0021      	jmp	0x86c4 <_MotorDiagnosticVsupplyAndTemperature+0xc6>
			}
		}
	}
	else if ( (voltage_raw >= NVRAM_APPL_UVOLT) && (voltage_raw <= NVRAM_APPL_OVOLT) )
    8682:	a2da fc18 	add	A, #64536
    8686:	aeda 0258 	cmp	A, #600
    868a:	1e1d      	jug	0x86c6 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
	{
		if((l_e8ErrorDebounceFilter & (C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV)) != 0u)
    868c:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    8690:	72e6      	lod	A, Y
    8692:	b40c      	and	A, #12
    8694:	1908      	je	0x86a6 <_MotorDiagnosticVsupplyAndTemperature+0xa8>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~(C_DEBFLT_ERR_UV | C_DEBFLT_ERR_OV);
    8696:	62e8      	lod	AL, YL
    8698:	94f3      	and	AL, #-13
    869a:	42d8 00c9 	mov	0xc9 <_l_e8ErrorDebounceFilter>, AL
			l_u8UOVoltageCount = 0u;
    869e:	6000      	lod	AL, #0
    86a0:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
    86a4:	0010      	jmp	0x86c6 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
		}
		else
		{
			l_u8UOVoltageCount++;
    86a6:	62d8 00c8 	lod	AL, 0xc8 <_l_u8UOVoltageCount>
    86aa:	8001      	add	AL, #1
    86ac:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
			if(l_u8UOVoltageCount >= C_UOV_DEBOUNCE_THR)
    86b0:	8c05      	cmp	AL, #5
    86b2:	1a09      	jule	0x86c6 <_MotorDiagnosticVsupplyAndTemperature+0xc8>
			{
				l_u8UOVoltageCount = C_UOV_DEBOUNCE_THR;
    86b4:	6006      	lod	AL, #6
    86b6:	42d8 00c8 	mov	0xc8 <_l_u8UOVoltageCount>, AL
				g_sMotorFault.UV = 0u;
    86ba:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    86bc:	94fe      	and	AL, #-2
    86be:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				g_sMotorFault.OV = 0u;
    86c0:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    86c2:	94fd      	and	AL, #-3
    86c4:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
	
	/***************************************************
	 * p. Motor over temperature check 
	***************************************************/
	/* Calculate Chip internal temperature (1LSB/C) [C] */
	GetChipTemperature( FALSE)												/* MMP131020-1 */;
    86c6:	7000      	lod	A, #0
    86c8:	1610      	call	0x82ea <_GetChipTemperature>
	/* Thermal Shutdown */
	
	if ( g_i16ChipTemperature > NVRAM_APPL_OTEMP_SHUT )
    86ca:	72d8 00b2 	lod	A, 0xb2 <_g_i16ChipTemperature>
    86ce:	aeda 008c 	cmp	A, #140
    86d2:	1b19      	jsle	0x8706 <_MotorDiagnosticVsupplyAndTemperature+0x108>
    {
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVTS) == 0x00u )
    86d4:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    86d8:	72e6      	lod	A, Y
    86da:	b420      	and	A, #32
    86dc:	1d03      	jne	0x86e4 <_MotorDiagnosticVsupplyAndTemperature+0xe6>
		{
			/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVTS;
    86de:	62e8      	lod	AL, YL
    86e0:	8420      	or	AL, #32
    86e2:	001b      	jmp	0x871a <_MotorDiagnosticVsupplyAndTemperature+0x11c>
			l_u8OverTemperatureShutCount = 0u;
		}
		else
		{
			l_u8OverTemperatureShutCount++;
    86e4:	62d8 00c6 	lod	AL, 0xc6 <_l_u8OverTemperatureShutCount>
    86e8:	8001      	add	AL, #1
    86ea:	42d8 00c6 	mov	0xc6 <_l_u8OverTemperatureShutCount>, AL
			if ( l_u8OverTemperatureShutCount >= (uint8) C_OVT_DEBOUNCE_THR )
    86ee:	8c05      	cmp	AL, #5
    86f0:	1a27      	jule	0x8740 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			{
				l_u8OverTemperatureShutCount = C_OVT_DEBOUNCE_THR;
    86f2:	6006      	lod	AL, #6
    86f4:	42d8 00c6 	mov	0xc6 <_l_u8OverTemperatureShutCount>, AL
				g_sMotorFault.TS = 0x01u;
    86f8:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    86fa:	8420      	or	AL, #32
    86fc:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
				SetLastError( (uint8) C_ERR_APPL_OVER_TEMP);
    86fe:	72da 00a1 	lod	A, #161
    8702:	106a      	call	0x87d8 <_SetLastError>
    8704:	001d      	jmp	0x8740 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			}
		}
	}
	else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP_SHUT - C_TEMPERATURE_HYS) )
    8706:	aeda 0086 	cmp	A, #134
    870a:	1f1a      	jsg	0x8740 <_MotorDiagnosticVsupplyAndTemperature+0x142>
	{
		if(l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVTS)
    870c:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    8710:	72e6      	lod	A, Y
    8712:	b420      	and	A, #32
    8714:	1908      	je	0x8726 <_MotorDiagnosticVsupplyAndTemperature+0x128>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVTS;
    8716:	62e8      	lod	AL, YL
    8718:	94df      	and	AL, #-33
    871a:	42d8 00c9 	mov	0xc9 <_l_e8ErrorDebounceFilter>, AL
			l_u8OverTemperatureShutCount = 0u;
    871e:	6000      	lod	AL, #0
    8720:	42d8 00c6 	mov	0xc6 <_l_u8OverTemperatureShutCount>, AL
    8724:	000d      	jmp	0x8740 <_MotorDiagnosticVsupplyAndTemperature+0x142>
		}
		else
		{
			l_u8OverTemperatureShutCount++;
    8726:	62d8 00c6 	lod	AL, 0xc6 <_l_u8OverTemperatureShutCount>
    872a:	8001      	add	AL, #1
    872c:	42d8 00c6 	mov	0xc6 <_l_u8OverTemperatureShutCount>, AL
			if(l_u8OverTemperatureShutCount >= C_OVT_DEBOUNCE_THR)
    8730:	8c05      	cmp	AL, #5
    8732:	1a06      	jule	0x8740 <_MotorDiagnosticVsupplyAndTemperature+0x142>
			{
				l_u8OverTemperatureShutCount = C_OVT_DEBOUNCE_THR;
    8734:	6006      	lod	AL, #6
    8736:	42d8 00c6 	mov	0xc6 <_l_u8OverTemperatureShutCount>, AL
				g_sMotorFault.TS = 0u;	
    873a:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    873c:	94df      	and	AL, #-33
    873e:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
	}

	
	
	/* Thermal Warning */
	if ( g_i16ChipTemperature > NVRAM_APPL_OTEMP_WARN )
    8740:	72d8 00b2 	lod	A, 0xb2 <_g_i16ChipTemperature>
    8744:	aeda 0082 	cmp	A, #130
    8748:	1b16      	jsle	0x8776 <_MotorDiagnosticVsupplyAndTemperature+0x178>
    {
		if ( (l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT) == 0x00 )
    874a:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    874e:	72e6      	lod	A, Y
    8750:	b402      	and	A, #2
    8752:	1d03      	jne	0x875a <_MotorDiagnosticVsupplyAndTemperature+0x15c>
		{
			/* Need twice a over-temperature detection, to avoid ESD-pulses disturbance will cause degraded mode entering */
			l_e8ErrorDebounceFilter |= (uint8) C_DEBFLT_ERR_OVT;
    8754:	62e8      	lod	AL, YL
    8756:	8402      	or	AL, #2
    8758:	0017      	jmp	0x8788 <_MotorDiagnosticVsupplyAndTemperature+0x18a>
			l_u8OverTemperatureWarnCount = 0u;
		}
		else
		{
			l_u8OverTemperatureWarnCount++;
    875a:	62d8 00c7 	lod	AL, 0xc7 <_l_u8OverTemperatureWarnCount>
    875e:	8001      	add	AL, #1
    8760:	42d8 00c7 	mov	0xc7 <_l_u8OverTemperatureWarnCount>, AL
			if ( l_u8OverTemperatureWarnCount >= (uint8) C_OVT_DEBOUNCE_THR )
    8764:	8c05      	cmp	AL, #5
    8766:	1a23      	jule	0x87ae <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
			{
				l_u8OverTemperatureWarnCount = C_OVT_DEBOUNCE_THR;
    8768:	6006      	lod	AL, #6
    876a:	42d8 00c7 	mov	0xc7 <_l_u8OverTemperatureWarnCount>, AL
				g_sMotorFault.TW = 0x01u;
    876e:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8770:	8410      	or	AL, #16
    8772:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
    8774:	5401      	ret
			}
		}
	}
	else if ( g_i16ChipTemperature < (int16) (NVRAM_APPL_OTEMP_WARN - C_TEMPERATURE_HYS) )
    8776:	ac7c      	cmp	A, #124
    8778:	1f1a      	jsg	0x87ae <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
	{
		if(l_e8ErrorDebounceFilter & (uint8) C_DEBFLT_ERR_OVT)
    877a:	66d8 00c9 	lod	YL, 0xc9 <_l_e8ErrorDebounceFilter>
    877e:	72e6      	lod	A, Y
    8780:	b402      	and	A, #2
    8782:	1908      	je	0x8794 <_MotorDiagnosticVsupplyAndTemperature+0x196>
		{
			l_e8ErrorDebounceFilter &= (uint8) ~C_DEBFLT_ERR_OVT;
    8784:	62e8      	lod	AL, YL
    8786:	94fd      	and	AL, #-3
    8788:	42d8 00c9 	mov	0xc9 <_l_e8ErrorDebounceFilter>, AL
			l_u8OverTemperatureWarnCount = 0u;
    878c:	6000      	lod	AL, #0
    878e:	42d8 00c7 	mov	0xc7 <_l_u8OverTemperatureWarnCount>, AL
    8792:	5401      	ret
		}
		else
		{
			l_u8OverTemperatureWarnCount++;
    8794:	62d8 00c7 	lod	AL, 0xc7 <_l_u8OverTemperatureWarnCount>
    8798:	8001      	add	AL, #1
    879a:	42d8 00c7 	mov	0xc7 <_l_u8OverTemperatureWarnCount>, AL
			if(l_u8OverTemperatureWarnCount >= C_OVT_DEBOUNCE_THR)
    879e:	8c05      	cmp	AL, #5
    87a0:	1a06      	jule	0x87ae <_MotorDiagnosticVsupplyAndTemperature+0x1b0>
			{
				l_u8OverTemperatureWarnCount = C_OVT_DEBOUNCE_THR;
    87a2:	6006      	lod	AL, #6
    87a4:	42d8 00c7 	mov	0xc7 <_l_u8OverTemperatureWarnCount>, AL
				g_sMotorFault.TW = 0u;
    87a8:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    87aa:	94ef      	and	AL, #-17
    87ac:	411c      	mov	dp:0x1c <_g_sMotorFault>, AL
    87ae:	5401      	ret

000087b0 <_ErrorLogInit>:
 *
 *	Comments:	Clear Error-FiFo-buffer, in case watchdog reset occurred, 
 *				otherwise leave untouched.
 * ****************************************************************************	*/
void ErrorLogInit( void)
{
    87b0:	5803      	inc	S, #4
	if ( (AWD_CTRL & AWD_RST) != 0u )
    87b2:	729a      	lod	A, io:0x1a <_g_u8ControlFrameID>
    87b4:	ac00      	cmp	A, #0
    87b6:	1e8f      	jsge	0x87d6 <_ErrorLogInit+0x26>
	{
		uint16 i;
		for ( i = 0u; i < C_ERR_LOG_SZ; i++ )
    87b8:	7000      	lod	A, #0
    87ba:	780a      	lod	Y, #10
    87bc:	5a01      	mov	[S-2], Y
		{
			l_au8FiFoErrorLog[i] = (uint8)C_ERR_NONE;
    87be:	7ee2      	lod	X, A
    87c0:	22da 00fe 	add	X, #254
    87c4:	6400      	lod	YL, #0
    87c6:	46f8      	mov	[X], YL
void ErrorLogInit( void)
{
	if ( (AWD_CTRL & AWD_RST) != 0u )
	{
		uint16 i;
		for ( i = 0u; i < C_ERR_LOG_SZ; i++ )
    87c8:	a001      	add	A, #1
    87ca:	7e01      	lod	X, [S-2]
    87cc:	20ff      	add	X, #-1
    87ce:	5e01      	mov	[S-2], X
    87d0:	1d76      	jne	0x87be <_ErrorLogInit+0xe>
		{
			l_au8FiFoErrorLog[i] = (uint8)C_ERR_NONE;
		}
		l_u8ErrorLogIdx = 0u;
    87d2:	46d8 00d0 	mov	0xd0 <_l_u8ErrorLogIdx>, YL
    87d6:	5405      	ret	#6

000087d8 <_SetLastError>:
 *
 *	Comments:	Save error-code in Error-FiFo-buffer, unless last error is the 
 *				same as error posted.
 * ****************************************************************************	*/
void SetLastError( uint8 u8ErrorCode)
{
    87d8:	5803      	inc	S, #4
    87da:	5203      	mov	[S-4], A
	if ( (l_u8ErrorLogIdx == 0u) || (l_au8FiFoErrorLog[l_u8ErrorLogIdx - 1u] != u8ErrorCode) )
    87dc:	62d8 00d0 	lod	AL, 0xd0 <_l_u8ErrorLogIdx>
    87e0:	4201      	mov	[S-2], AL
    87e2:	1907      	je	0x87f2 <_SetLastError+0x1a>
    87e4:	5cf2      	usex	A
    87e6:	7ae2      	lod	Y, A
    87e8:	e2da 00fd 	add	Y, #253
    87ec:	62f0      	lod	AL, [Y]
    87ee:	8e03      	cmp	AL, [S-4]
    87f0:	190d      	je	0x880c <_SetLastError+0x34>
	{
		/* Don't log the same error over and over again */
		l_au8FiFoErrorLog[l_u8ErrorLogIdx] = u8ErrorCode;
    87f2:	6201      	lod	AL, [S-2]
    87f4:	5cf2      	usex	A
    87f6:	7ae2      	lod	Y, A
    87f8:	e2da 00fe 	add	Y, #254
    87fc:	6203      	lod	AL, [S-4]
    87fe:	42f0      	mov	[Y], AL
		if ( l_u8ErrorLogIdx < (C_ERR_LOG_SZ - 1u) )
    8800:	6201      	lod	AL, [S-2]
    8802:	8c08      	cmp	AL, #8
    8804:	1e03      	jug	0x880c <_SetLastError+0x34>
		{
			l_u8ErrorLogIdx++;
    8806:	8001      	add	AL, #1
    8808:	42d8 00d0 	mov	0xd0 <_l_u8ErrorLogIdx>, AL
    880c:	5405      	ret	#6

0000880e <_GetLastError>:
#endif
	}
} /* End of SetLastError() */

uint8 GetLastError( void)
{
    880e:	5809      	inc	S, #10
	uint8 u8Reply = l_au8FiFoErrorLog[0];
    8810:	62d8 00fe 	lod	AL, 0xfe <_l_au8FiFoErrorLog>
    8814:	5cf2      	usex	A
    8816:	5209      	mov	[S-10], A
	if ( l_u8ErrorLogIdx != 0u )
    8818:	62d8 00d0 	lod	AL, 0xd0 <_l_u8ErrorLogIdx>
    881c:	4207      	mov	[S-8], AL
    881e:	1924      	je	0x8868 <_GetLastError+0x5a>
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8820:	72e3      	lod	A, M
    8822:	5203      	mov	[S-4], A
	{
		uint16 i;
		ATOMIC_CODE
    8824:	4407      	mov	R, #0
    8826:	500c      	call	fp0:0x60
    8828:	54f0      	mov	UPr, #0
    882a:	7001      	lod	A, #1
    882c:	5205      	mov	[S-6], A
    882e:	6207      	lod	AL, [S-8]
    8830:	5cf2      	usex	A
    8832:	5201      	mov	[S-2], A
    8834:	7001      	lod	A, #1
    8836:	ae01      	cmp	A, [S-2]
    8838:	1c0b      	jnc	0x8850 <_GetLastError+0x42>
    883a:	7a05      	lod	Y, [S-6]
    883c:	e2da 00fe 	add	Y, #254
    8840:	7ee6      	lod	X, Y
    8842:	20ff      	add	X, #-1
    8844:	62f0      	lod	AL, [Y]
    8846:	42f8      	mov	[X], AL
    8848:	7205      	lod	A, [S-6]
    884a:	a001      	add	A, #1
    884c:	5205      	mov	[S-6], A
    884e:	07f3      	jmp	0x8836 <_GetLastError+0x28>
    8850:	6207      	lod	AL, [S-8]
    8852:	80ff      	add	AL, #-1
    8854:	42d8 00d0 	mov	0xd0 <_l_u8ErrorLogIdx>, AL
    8858:	5cf2      	usex	A
    885a:	7ae2      	lod	Y, A
    885c:	e2da 00fe 	add	Y, #254
    8860:	6000      	lod	AL, #0
    8862:	42f0      	mov	[Y], AL
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8864:	7203      	lod	A, [S-4]
    8866:	52e3      	mov	M, A
			l_u8ErrorLogIdx--;
			l_au8FiFoErrorLog[l_u8ErrorLogIdx] = C_ERR_NONE;
		);
	}
	return ( u8Reply );
} /* End of GetLastError() */
    8868:	7209      	lod	A, [S-10]
    886a:	540b      	ret	#12

0000886c <_MotorDriverSetParams>:

/* public functions implementation */

void MotorDriverSetParams(Motor_ControlParams params)
{
	l_u8MotorRequest = params.MotorCtrl;
    886c:	7aef      	lod	Y, S
    886e:	e0f2      	add	Y, #-14
    8870:	72f0      	lod	A, [Y]
    8872:	42d8 00d7 	mov	0xd7 <_l_u8MotorRequest>, AL
	if( params.TgtPos != 0xFFFFu )
    8876:	72f2      	lod	A, [Y+2]
    8878:	acff      	cmp	A, #-1
    887a:	1901      	je	0x887e <_MotorDriverSetParams+0x12>
	{
		l_u16ActuatorBufferedTgtPos = params.TgtPos;
    887c:	514c      	mov	dp:0x4c <_l_u16ActuatorBufferedTgtPos>, A
	}
	/* argument check:actuator actual position should not be invalid  */
	if( params.ActPos != 0xFFFFu )
    887e:	72f4      	lod	A, [Y+4]
    8880:	acff      	cmp	A, #-1
    8882:	1901      	je	0x8886 <_MotorDriverSetParams+0x1a>
	{
		g_u16ActuatorActPos = params.ActPos;
    8884:	5146      	mov	dp:0x46 <_g_u16ActuatorActPos>, A
	}

	/* update target speed */
	if( params.SpdRPM != 0xFFFFu )
    8886:	7203      	lod	A, [S-4]
    8888:	acff      	cmp	A, #-1
    888a:	1901      	je	0x888e <_MotorDriverSetParams+0x22>
	{
		l_u16ActuatorBufferedSpdRPM = params.SpdRPM;
    888c:	514e      	mov	dp:0x4e <_l_u16ActuatorBufferedSpdRPM>, A
    888e:	5401      	ret

00008890 <_MotorDriverGetStatus>:
	}
}

void MotorDriverGetStatus(Motor_RuntimeStatus *pstatus)
{
    8890:	7ae2      	lod	Y, A
	pstatus->Mode = g_u8MotorStartupMode;
    8892:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8896:	42f0      	mov	[Y], AL
	pstatus->ActPos = g_u16ActuatorActPos;
    8898:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    889a:	52f4      	mov	[Y+4], A
	pstatus->TgtPos = g_u16ActuatorTgtPos;
    889c:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    889e:	52f6      	mov	[Y+6], A
	pstatus->Fault = g_sMotorFault;
    88a0:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    88a2:	52f2      	mov	[Y+2], A
	pstatus->Direction = g_e8MotorDirectionCCW;
    88a4:	e008      	add	Y, #8
    88a6:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    88a8:	42f0      	mov	[Y], AL
    88aa:	5401      	ret

000088ac <_MotorDriverClearFaultStatus>:
}

void MotorDriverClearFaultStatus(void)
{
	/* clear permanent mechanical or eletric error,latched */
	g_sMotorFault.DRIFT = 0;
    88ac:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    88ae:	94fb      	and	AL, #-5
    88b0:	411d      	mov	dp:0x1d <_g_sMotorFault+0x1>, AL
	g_sMotorFault.ST = 0;
    88b2:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    88b4:	b6da fc3f 	and	A, #64575
    88b8:	511c      	mov	dp:0x1c <_g_sMotorFault>, A
	g_sMotorFault.SHORT = 0;
    88ba:	7ada 001c 	lod	Y, #28
    88be:	62f0      	lod	AL, [Y]
    88c0:	94f7      	and	AL, #-9
    88c2:	42f0      	mov	[Y], AL
	g_sMotorFault.OPEN = 0;
    88c4:	62f0      	lod	AL, [Y]
    88c6:	94fb      	and	AL, #-5
    88c8:	42f0      	mov	[Y], AL
    88ca:	5401      	ret

000088cc <_MotorDriver_4PhaseStepper>:
 * Performance: 13.5us @ 28MHz (BIPOLAR_PWM_SINGLE_INDEPENDED_GND)
 *
 * Based on a 32-step c_ai16MicroStepVector4PH-table!!
 * ****************************************************************************	*/
void MotorDriver_4PhaseStepper( void)
{
    88cc:	5805      	inc	S, #6
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) */

#if (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_INDEPENDED_GND)					/* MMP150515-1 */
	/* EMC CE/RE reduction */
	int16 iPwm1, iPwm2;
	const int16 *pi16Vector = &c_ai16MicroStepVector4PH[g_u16MicroStepIdx];
    88ce:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    88d0:	5203      	mov	[S-4], A
    88d2:	487a 0002 	muls	Y, A, #2
    88d6:	7ee6      	lod	X, Y
    88d8:	22da 9984 	add	X, #39300
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    88dc:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    88de:	7af8      	lod	Y, [X]
    88e0:	4831      	muls	YA, A, Y
    88e2:	48b3      	asr	YA, #4
    88e4:	5a01      	mov	[S-2], Y
    return result;
} /* End of muldivU16_U16byU16byU16() */

static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16Shft4(int16 a, int16 b)
{
    88e6:	5a05      	mov	[S-6], Y
	iPwm1 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	iPwm2 = (int16) (mulI32_I16byU16( *pi16Vector, g_u16CorrectionRatio) >> (20 + PWM_PRESCALER_N));
#elif (PWM_PRESCALER_N == 0U)
	iPwm1 = mulI16_I16byI16Shft4( *pi16Vector, (int16) g_u16CorrectionRatio);	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
    88e8:	2010      	add	X, #16
    88ea:	7af8      	lod	Y, [X]
    88ec:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    88ee:	4831      	muls	YA, A, Y
    88f0:	48b3      	asr	YA, #4
#else
	i16PwmU = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* U */
	pi16Vector += C_MICROSTEP_PER_FULLSTEP;
	i16PwmV = (int16) (mulI16_I16byI16( *pi16Vector, (int16) g_u16CorrectionRatio) >> (4 + PWM_PRESCALER_N));	/* V */
#endif
	if ( (g_u16MicroStepIdx & (2u*C_MICROSTEP_PER_FULLSTEP)) != 0u )
    88f2:	7203      	lod	A, [S-4]
    88f4:	b410      	and	A, #16
    88f6:	1913      	je	0x891e <_MotorDriver_4PhaseStepper+0x52>
	{
		/* 3rd and 4th Quadrant (Pwm1) */
		iPwm1 = (int16)PWM_SCALE_OFFSET + iPwm1;
    88f8:	7205      	lod	A, [S-6]
    88fa:	a2da 02bb 	add	A, #699
    88fe:	5205      	mov	[S-6], A
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = PWM */
		PWM4_LT =  (uint16)iPwm1;
    8900:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM4_HT =  (uint16)PWM_REG_PERIOD - (uint16)iPwm1;
    8904:	72da 0576 	lod	A, #1398
    8908:	aa05      	sub	A, [S-6]
    890a:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM3_LT = (uint16) iPwm1;
		PWM3_HT = (uint16) (PWM_REG_PERIOD - iPwm1);
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */

		/* W = LOW */
		PWM2_HT = 0U;
    890e:	7000      	lod	A, #0
    8910:	52d8 285a 	mov	0x285a <__io__+0x5a>, A
		PWM2_LT = (uint16)PWM_REG_PERIOD + 1U;											/* MMP150603-1 */;
    8914:	72da 0577 	lod	A, #1399
    8918:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
    891c:	0012      	jmp	0x8942 <_MotorDriver_4PhaseStepper+0x76>
	}
	else
	{
		/* 1st and 2nd Quadrant (Pwm1)*/
		/* W = PWM */
		iPwm1 = ((int16) PWM_SCALE_OFFSET - iPwm1);
    891e:	72da 02bb 	lod	A, #699
    8922:	aa01      	sub	A, [S-2]
    8924:	5205      	mov	[S-6], A
		PWM2_LT = (uint16) iPwm1;
    8926:	52d8 2858 	mov	0x2858 <__io__+0x58>, A
		PWM2_HT = (uint16)PWM_REG_PERIOD - (uint16)iPwm1;
    892a:	72da 0576 	lod	A, #1398
    892e:	aa05      	sub	A, [S-6]
    8930:	52d8 285a 	mov	0x285a <__io__+0x5a>, A

#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
		/* U = LOW */
		PWM4_HT = 0U;
    8934:	7000      	lod	A, #0
    8936:	52d8 286e 	mov	0x286e <__io__+0x6e>, A
		PWM4_LT = (uint16)PWM_REG_PERIOD + 1U;											/* MMP150603-1 */
    893a:	72da 0577 	lod	A, #1399
    893e:	52d8 286c 	mov	0x286c <__io__+0x6c>, A
		PWM3_LT = PWM_REG_PERIOD + 1;											/* MMP150603-1 */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}

	{
		uint16 u16Quad = g_u16MicroStepIdx & (3u * C_MICROSTEP_PER_FULLSTEP);
    8942:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    8944:	b418      	and	A, #24
		if ( (u16Quad == 0u) || (u16Quad == (3u * C_MICROSTEP_PER_FULLSTEP)) )
    8946:	1902      	je	0x894c <_MotorDriver_4PhaseStepper+0x80>
    8948:	ac18      	cmp	A, #24
    894a:	1d0f      	jne	0x896a <_MotorDriver_4PhaseStepper+0x9e>
		{
			/* 1st and 4th Quadrant (Pwm2) */
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* T = PWM */
			PWM5_HT = (uint16) iPwm2;
    894c:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16)PWM_REG_PERIOD - (uint16)iPwm2;
    8950:	72da 0576 	lod	A, #1398
    8954:	aae6      	sub	A, Y
    8956:	52d8 2876 	mov	0x2876 <__io__+0x76>, A

			/* V = LOW */
			PWM3_HT = 0U;
    895a:	7800      	lod	Y, #0
    895c:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16)PWM_REG_PERIOD + 1U;										/* MMP150603-1 */
    8960:	72da 0577 	lod	A, #1399
    8964:	52d8 2862 	mov	0x2862 <__io__+0x62>, A
    8968:	000f      	jmp	0x8988 <_MotorDriver_4PhaseStepper+0xbc>
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
		}
		else
		{
			/* 3rd Quadrant (Pwm2) */
			iPwm2 = (0 - iPwm2);
    896a:	5cc6      	neg	Y
#if (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UW_VT)
			/* V = PWM */
			PWM3_HT = (uint16) iPwm2;
    896c:	5ad8 2864 	mov	0x2864 <__io__+0x64>, Y
			PWM3_LT = (uint16)PWM_REG_PERIOD - (uint16)iPwm2;
    8970:	72da 0576 	lod	A, #1398
    8974:	aae6      	sub	A, Y
    8976:	52d8 2862 	mov	0x2862 <__io__+0x62>, A

			/* T = LOW */
			PWM5_HT = 0U;
    897a:	7800      	lod	Y, #0
    897c:	5ad8 2878 	mov	0x2878 <__io__+0x78>, Y
			PWM5_LT = (uint16)PWM_REG_PERIOD + 1U;										/* MMP150603-1 */
    8980:	72da 0577 	lod	A, #1399
    8984:	52d8 2876 	mov	0x2876 <__io__+0x76>, A
		PWM4_LT = (uint16) (0 - iPwm);						/* U = PWM */
#endif /* (_SUPPORT_BIPOLAR_MODE == BIPOLAR_MODE_UT_VW) */
	}
#endif /* (_SUPPORT_PWM_MODE == BIPOLAR_PWM_SINGLE_MIRRORSPECIAL) */

	PWM1_LT = (uint16)PWM_SCALE_OFFSET;													/* Master must be modified at last (value is not important) */
    8988:	7ada 02bb 	lod	Y, #699
    898c:	5ad8 284e 	mov	0x284e <__io__+0x4e>, Y
    8990:	5407      	ret	#8

00008992 <_MotorDriverInit>:
 * MotorDriverInit()
 *
 * Initialise Motor Driver
 * ****************************************************************************	*/
void MotorDriverInit( void)
{
    8992:	5815      	inc	S, #22
    8994:	7808      	lod	Y, #8
    8996:	7004      	lod	A, #4
    uint32 result;

    __asm__ __volatile__ (
    8998:	4801      	mulu	D, A, Y
    899a:	7eef      	lod	X, S
    899c:	20f8      	add	X, #-8
    899e:	4c87      	mov	[X], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    89a0:	7207      	lod	A, [S-8]
    89a2:	52d8 010a 	mov	0x10a <_g_u16MotorMicroStepsPerElecRotation>, A
    uint32 result;

    __asm__ __volatile__ (
    89a6:	700c      	lod	A, #12
    89a8:	7a07      	lod	Y, [S-8]
    89aa:	4801      	mulu	D, A, Y
    89ac:	72ee      	lod	A, X
    89ae:	4cf3      	swap	YA
    89b0:	4c85      	mov	[Y], D
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    89b2:	7a07      	lod	Y, [S-8]
    89b4:	5ad8 010c 	mov	0x10c <_g_u16MotorMicroStepsPerMechRotation>, Y
	g_u16MotorMicroStepsPerMechRotation = (uint16) mulU32_U16byU16( NVRAM_POLE_PAIRS, g_u16MotorMicroStepsPerElecRotation);
	{
		uint16 u16ConstAccelaration = NVRAM_ACCELERATION_CONST;
		if ( u16ConstAccelaration != 0u )
		{
			u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60u), g_u16MotorMicroStepsPerMechRotation);
    89b8:	5adf      	push	Y
    89ba:	4ce2 2c40 	mov	YA, #105000000
    89be:	0642 
    89c0:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    89c4:	4cc0      	mov	D, YA
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    89c6:	5c01      	dec	S, #2
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    89c8:	7c3c      	lod	X, #60
    89ca:	4c63      	divu	YA, X
    89cc:	4c63      	divu	YA, X
    89ce:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    89d0:	a0ff      	add	A, #-1
    89d2:	52d8 011c 	mov	0x11c <_g_au16MotorSpeedCommutTimerPeriod+0xe>, A
    89d6:	52d8 010e 	mov	0x10e <_g_au16MotorSpeedCommutTimerPeriod>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    89da:	4c80      	mov	YA, D
    89dc:	7eda 04e2 	lod	X, #1250
    89e0:	4c63      	divu	YA, X
    89e2:	4c63      	divu	YA, X
    89e4:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    89e6:	a0ff      	add	A, #-1
    89e8:	52d8 011a 	mov	0x11a <_g_au16MotorSpeedCommutTimerPeriod+0xc>, A
    89ec:	52d8 0110 	mov	0x110 <_g_au16MotorSpeedCommutTimerPeriod+0x2>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    89f0:	4c80      	mov	YA, D
    89f2:	7c64      	lod	X, #100
    89f4:	4c63      	divu	YA, X
    89f6:	4c63      	divu	YA, X
    89f8:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    89fa:	a0ff      	add	A, #-1
    89fc:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
    89fe:	52d8 0112 	mov	0x112 <_g_au16MotorSpeedCommutTimerPeriod+0x4>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a02:	4c80      	mov	YA, D
    8a04:	7eda 00c8 	lod	X, #200
    8a08:	4c63      	divu	YA, X
    8a0a:	4c63      	divu	YA, X
    8a0c:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a0e:	7ee2      	lod	X, A
    8a10:	20ff      	add	X, #-1
    8a12:	5ed8 0114 	mov	0x114 <_g_au16MotorSpeedCommutTimerPeriod+0x6>, X
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a16:	4c80      	mov	YA, D
    8a18:	7eda 04e2 	lod	X, #1250
    8a1c:	4c63      	divu	YA, X
    8a1e:	4c63      	divu	YA, X
    8a20:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a22:	7ee2      	lod	X, A
    8a24:	20ff      	add	X, #-1
    8a26:	5ed8 0116 	mov	0x116 <_g_au16MotorSpeedCommutTimerPeriod+0x8>, X
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a2a:	4c80      	mov	YA, D
    8a2c:	7eda 04e2 	lod	X, #1250
    8a30:	4c63      	divu	YA, X
    8a32:	4c63      	divu	YA, X
    8a34:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a36:	a0ff      	add	A, #-1
    8a38:	52d8 0118 	mov	0x118 <_g_au16MotorSpeedCommutTimerPeriod+0xa>, A
			g_au16MotorSpeedCommutTimerPeriod[3] = divU16_U32byU16( u32Temp, NVRAM_SPEED1) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[4] = divU16_U32byU16( u32Temp, NVRAM_SPEED2) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[5] = divU16_U32byU16( u32Temp, NVRAM_SPEED3) - 1u;
			g_au16MotorSpeedCommutTimerPeriod[6] = g_au16MotorSpeedCommutTimerPeriod[1];
			g_au16MotorSpeedCommutTimerPeriod[7] = g_au16MotorSpeedCommutTimerPeriod[0];
			g_u16TargetCommutTimerPeriod = g_au16MotorSpeedCommutTimerPeriod[2];	/* Target commutation timer period (target speed) */
    8a3c:	793c      	lod	Y, dp:0x3c <_g_u16CommutTimerPeriod>
    8a3e:	593e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, Y
    8a40:	4cca 005a 	movu	D, #90
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a44:	4c80      	mov	YA, D
    8a46:	7c3c      	lod	X, #60
    8a48:	4c63      	divu	YA, X
    8a4a:	4c63      	divu	YA, X
    8a4c:	520b      	mov	[S-12], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a4e:	52d8 011e 	mov	0x11e <_g_au16MotorSpeedRPS>, A
    8a52:	4cca 0500 	movu	D, #1280
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a56:	4c80      	mov	YA, D
    8a58:	4c63      	divu	YA, X
    8a5a:	4c63      	divu	YA, X
    8a5c:	5209      	mov	[S-10], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a5e:	52d8 0120 	mov	0x120 <_g_au16MotorSpeedRPS+0x2>, A
    8a62:	4cea 0082 	movu	YA, #130
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a66:	4c63      	divu	YA, X
    8a68:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a6a:	52d8 0122 	mov	0x122 <_g_au16MotorSpeedRPS+0x4>, A
    8a6e:	4cea 00e6 	movu	YA, #230
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a72:	4c63      	divu	YA, X
    8a74:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a76:	52d8 0124 	mov	0x124 <_g_au16MotorSpeedRPS+0x6>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a7a:	4c80      	mov	YA, D
    8a7c:	4c63      	divu	YA, X
    8a7e:	4c63      	divu	YA, X
    8a80:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a82:	52d8 0126 	mov	0x126 <_g_au16MotorSpeedRPS+0x8>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8a86:	4c80      	mov	YA, D
    8a88:	4c63      	divu	YA, X
    8a8a:	4c63      	divu	YA, X
    8a8c:	5207      	mov	[S-8], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8a8e:	52d8 0128 	mov	0x128 <_g_au16MotorSpeedRPS+0xa>, A
			g_au16MotorSpeedRPS[1] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60U);
			g_au16MotorSpeedRPS[2] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED0 + 30U), 60U);
			g_au16MotorSpeedRPS[3] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED1 + 30U), 60U);
			g_au16MotorSpeedRPS[4] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED2 + 30U), 60U);
			g_au16MotorSpeedRPS[5] = divU16_U32byU16( (uint32)(uint16)(NVRAM_SPEED3 + 30U), 60U);
			g_au16MotorSpeedRPS[6] = g_au16MotorSpeedRPS[1];
    8a92:	7a09      	lod	Y, [S-10]
    8a94:	5ad8 012a 	mov	0x12a <_g_au16MotorSpeedRPS+0xc>, Y
			g_au16MotorSpeedRPS[7] = g_au16MotorSpeedRPS[0];
    8a98:	7e0b      	lod	X, [S-12]
    8a9a:	5ed8 012c 	mov	0x12c <_g_au16MotorSpeedRPS+0xe>, X
		}
	}

	g_u16CorrectionRatio = NVRAM_MIN_CORR_RATIO;
    8a9e:	72da 08df 	lod	A, #2271
    8aa2:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A

	/* BLDC motor Commutation/Stepper timer */
	g_u16MicroStepIdx = 0u;
    8aa4:	7800      	lod	Y, #0
    8aa6:	593a      	mov	dp:0x3a <_g_u16MicroStepIdx>, Y

	TMR1_CTRL = C_TMRx_CTRL_MODE0;												/* Timer mode 0 */
    8aa8:	7eda 4001 	lod	X, #16385
    8aac:	5eaa      	mov	io:0x2a <__data_dp_end+0x2>, X
	TMR1_REGB = 0u;																/* Will be overwritten by MotorDriverStart() */
    8aae:	5aac      	mov	io:0x2c <__data_dp_end+0x4>, Y

	/* Setup Motor PWM */	
	PWM1_CTRL = 0u;																/* Disable master */
    8ab0:	6000      	lod	AL, #0
    8ab2:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = 0u;																/* Disable Slave 1 */
    8ab6:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = 0u;																/* Disable Slave 2 */
    8aba:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = 0u;																/* Disable Slave 3 */
    8abe:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = 0u;																/* Disable Slave 4 */
    8ac2:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
	PWM1_PSCL = (uint8)PWM_PRESCALER;											/* Initialise the master pre-scaler ratio (Fck/8) */
    8ac6:	42d8 284b 	mov	0x284b <__io__+0x4b>, AL
	PWM1_PER = (uint16)PWM_REG_PERIOD;
    8aca:	7ada 0576 	lod	Y, #1398
    8ace:	5ad8 284c 	mov	0x284c <__io__+0x4c>, Y
	PWM2_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8ad2:	5ad8 2856 	mov	0x2856 <__io__+0x56>, Y
	PWM3_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8ad6:	5ad8 2860 	mov	0x2860 <__io__+0x60>, Y
	PWM4_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8ada:	5ad8 286a 	mov	0x286a <__io__+0x6a>, Y
	PWM5_PER = (uint16)PWM_REG_PERIOD;											/* -=#=- Probably not needed to set slave period too */
    8ade:	5ad8 2874 	mov	0x2874 <__io__+0x74>, Y
	PWM5_CMP = (((83L * PWM_REG_PERIOD) + 50)/100); 	/*	7.0us */			/* 83% of period */
#else  /* _SUPPORT_PHASE_SHORT_DET */
	/* (Single PWM) 17% 		33% 		50% 		75% 		100%		(7.0us/ADC-conversion)
	 * MF_STEPPER:	Temperature Vs-filt 	Imotor1 	Vsm-unfilt	Imotor2
	 */
	PWM1_CMP = (uint16)(((17UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	7.0us */			/* 17% of period */
    8ae2:	7eda 00ee 	lod	X, #238
    8ae6:	5ed8 2852 	mov	0x2852 <__io__+0x52>, X
	PWM2_CMP = (uint16)(((33UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	7.0us */			/* 33% of period */
    8aea:	72da 01cd 	lod	A, #461
    8aee:	52d8 285c 	mov	0x285c <__io__+0x5c>, A
	PWM3_CMP = (uint16)(((50UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	10.5us */			/* 50% of period */
    8af2:	7ada 02bb 	lod	Y, #699
    8af6:	5ad8 2866 	mov	0x2866 <__io__+0x66>, Y
	PWM4_CMP = (uint16)(((75UL * PWM_REG_PERIOD) + 50U)/100U); 	/*	10.5us */			/* 75% of period */
    8afa:	7eda 0419 	lod	X, #1049
    8afe:	5ed8 2870 	mov	0x2870 <__io__+0x70>, X
	PWM3_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 2 control register - CMPI enabled */
	PWM4_CTRL = (MODE | ECI | EXT | EBLK);										/* initialise the slave 3 control register - CMPI enabled */
	PWM5_CTRL = (MODE | EXT | EBLK);											/* Initialise the slave 4 control register - CMPI disabled */
#else  /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	/* In-depended mode */
	PWM1_CTRL = (EBLK | ECI | EPI); 											/* Initialise the master control register - CMPI and PWMI enabled */
    8b02:	6019      	lod	AL, #25
    8b04:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
	PWM2_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 1 control register - CMPI enabled */
    8b08:	6013      	lod	AL, #19
    8b0a:	42d8 2854 	mov	0x2854 <__io__+0x54>, AL
	PWM3_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 2 control register - CMPI enabled */
    8b0e:	42d8 285e 	mov	0x285e <__io__+0x5e>, AL
	PWM4_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 3 control register - CMPI enabled */
    8b12:	42d8 2868 	mov	0x2868 <__io__+0x68>, AL
	PWM5_CTRL = (ECI | EXT | EBLK); 											/* Initialise the slave 4 control register - CMPI enabled */
    8b16:	42d8 2872 	mov	0x2872 <__io__+0x72>, AL
#endif /* (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_VSM) && (_SUPPORT_PWM_MODE != BIPOLAR_PWM_SINGLE_INDEPENDED_GND) */
	PWM1_CTRL |= EBLK;															/* Start PWM in application mode */
    8b1a:	62d8 284a 	lod	AL, 0x284a <__io__+0x4a>
    8b1e:	8401      	or	AL, #1
    8b20:	42d8 284a 	mov	0x284a <__io__+0x4a>, AL
    8b24:	5417      	ret	#24

00008b26 <_MotorDriverCurrentMeasureInit>:
 * Performance: <10us
 * ****************************************************************************	*/
void MotorDriverCurrentMeasureInit( void)
{
	uint16 u16Count;															/* MMP140331-2 - Begin */
	l_u16StartupDelayInit = 64u * NVRAM_ACCELERATION_POINTS;					/* Calculate the startup-delay, based on acceleration steps */
    8b26:	7040      	lod	A, #64
    8b28:	52d8 00da 	mov	0xda <_l_u16StartupDelayInit>, A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    8b2c:	72e3      	lod	A, M
	}																			/* MMP140331-2 - End */
	else
	{
		
	}
	ATOMIC_CODE
    8b2e:	4407      	mov	R, #0
    8b30:	500c      	call	fp0:0x60
    8b32:	54f0      	mov	UPr, #0
    8b34:	7ad8 00da 	lod	Y, 0xda <_l_u16StartupDelayInit>
    8b38:	5920      	mov	dp:0x20 <_g_u16StartupDelay>, Y
    8b3a:	7800      	lod	Y, #0
    8b3c:	5942      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, Y
    8b3e:	5ad8 012e 	mov	0x12e <_l_u16MotorCurrentRawIdx>, Y
    8b42:	5940      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, Y
    8b44:	5ad8 0130 	mov	0x130 <_l_au16MotorCurrentRaw>, Y
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    8b48:	52e3      	mov	M, A
		l_u16MotorCurrentRawIdx = 0u;											/* Raw current moving average index */
		g_u16MotorCurrentMovAvgxN = 0u;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0u;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
    8b4a:	7ada 0132 	lod	Y, #306
    8b4e:	7c1f      	lod	X, #31
		for ( u16Count = 1u; u16Count < (uint16)C_MOVAVG_SZ; u16Count++ )
		{
			*pStallCurrentRaw = 0u;
    8b50:	7000      	lod	A, #0
    8b52:	52d6      	mov	[Y++], A
    8b54:	1bfd      	djnz	X, 0x8b50 <_MotorDriverCurrentMeasureInit+0x2a>
		g_u16MotorCurrentMovAvgxN = 0u;											/* Moving average motor-current (x 4..16) */
		l_au16MotorCurrentRaw[0] = 0u;
	);
	{
		uint16 *pStallCurrentRaw = &l_au16MotorCurrentRaw[1];
		for ( u16Count = 1u; u16Count < (uint16)C_MOVAVG_SZ; u16Count++ )
    8b56:	5401      	ret

00008b58 <_MotorDriver_InitialPwmDutyCycle>:
 * MotorDriver_InitialPwmDutyCycle()
 *
 * Calculate Motor PWM (initial) Duty-cycle, based on current threshold level and speed
 * ****************************************************************************	*/
void MotorDriver_InitialPwmDutyCycle( uint16 u16CurrentLevel, uint16 u16MotorSpeed)
{
    8b58:	5803      	inc	S, #4
    8b5a:	7e07      	lod	X, [S-8]
    8b5c:	4872 0019 	muls	A, A, #25
    8b60:	7ad8 00b4 	lod	Y, 0xb4 <_g_i16MotorVoltage>
    8b64:	5a03      	mov	[S-4], Y
	if ( u16MotorSpeed == 0u )														/* MMP140228-1 - Begin */
    8b66:	2c00      	cmp	X, #0
    8b68:	1d04      	jne	0x8b72 <_MotorDriver_InitialPwmDutyCycle+0x1a>
	{
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2u * C_FETS_RTOT)) * u16CurrentLevel);
    8b6a:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 4u;
    8b6c:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8b6e:	44b2      	lsr	A, #2
    8b70:	000d      	jmp	0x8b8c <_MotorDriver_InitialPwmDutyCycle+0x34>
	}																				/* MMP140228-1 - End */
	else
	{
		/* Ohmic losses: Ur-losses = (0.5 * R[ohm] * I[mA])/10 [10mV] = (R[ohm] * I[mA])/20 [10mV]
		 * FET losses: Ufet-losses = (Rfet * I[mA])/10 [10mV] = (2 * Rfet * I[mA])/20 [10mV]*/
		g_u16CorrectionRatio  = ((NVRAM_MOTOR_COIL_RTOT + (2u * C_FETS_RTOT)) * u16CurrentLevel);
    8b72:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio /= 20u;													/* Divided by 20 */
    8b74:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8b76:	4822 cccd 	mulu	YA, A, #52429
    8b7a:	72e6      	lod	A, Y
    8b7c:	44b2      	lsr	A, #2
    8b7e:	44b2      	lsr	A, #2
    8b80:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
		g_u16CorrectionRatio += (NVRAM_MOTOR_CONSTANT * u16MotorSpeed);				/* BEMF = Kmotor[10mV/RPS] * Speed[RPS] */
    8b82:	72ee      	lod	A, X
    8b84:	487a 0091 	muls	Y, A, #145
    8b88:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8b8a:	a2e6      	add	A, Y
    8b8c:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8b8e:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8b90:	44a2      	asl	A, #2
    8b92:	4422      	asl	A
    8b94:	7eda 0546 	lod	X, #1350
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8b98:	7ada 0aec 	lod	Y, #2796
    8b9c:	4821      	mulu	YA, A, Y
    8b9e:	4c63      	divu	YA, X
    8ba0:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    8ba2:	52d8 017e 	mov	0x17e <_g_u16PidCtrlRatio>, A
	}
	g_u16PidCtrlRatio =  muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3u, (uint16)PWM_REG_PERIOD << (1u + PWM_PRESCALER_N), NVRAM_VSUP_REF);
	g_u16PID_I = g_u16PidCtrlRatio;
    8ba6:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
	if ( g_i16MotorVoltage > 0 )
    8ba8:	7e03      	lod	X, [S-4]
    8baa:	2c00      	cmp	X, #0
    8bac:	1b08      	jsle	0x8bbe <_MotorDriver_InitialPwmDutyCycle+0x66>
    8bae:	7138      	lod	A, dp:0x38 <_g_u16CorrectionRatio>
    8bb0:	44a2      	asl	A, #2
    8bb2:	4422      	asl	A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    8bb4:	7ada 0aec 	lod	Y, #2796
    8bb8:	4821      	mulu	YA, A, Y
    8bba:	4c63      	divu	YA, X
    8bbc:	4c63      	divu	YA, X
	{
		g_u16CorrectionRatio = muldivU16_U16byU16byU16( g_u16CorrectionRatio << 3u, (uint16)PWM_REG_PERIOD << (1u + PWM_PRESCALER_N), (uint16) g_i16MotorVoltage);
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    8bbe:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
	}
	g_i16PID_D = 0;
    8bc0:	7c00      	lod	X, #0
    8bc2:	5ed8 00e6 	mov	0xe6 <_g_i16PID_D>, X
	g_i16PID_E = 0;
    8bc6:	5ed8 00e4 	mov	0xe4 <_g_i16PID_E>, X
    8bca:	5405      	ret	#6

00008bcc <_MotorDriverStart>:
 * MotorDriverStart()
 *
 * Start Motor Driver
 * ****************************************************************************	*/
void MotorDriverStart( void)
{
    8bcc:	5801      	inc	S, #2
	/* 1)stop, 2)no error,3)target position not equals actual position */
	if( g_u8MotorStartupMode == (uint8)MSM_STOP )
    8bce:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8bd2:	1901      	je	0x8bd6 <_MotorDriverStart+0xa>
    8bd4:	0055      	jmp	0x8c80 <_MotorDriverStart+0xb4>
	{
#if USE_MULTI_PURPOSE_BUFFER
		/* Fill multi-purpose buffer with acceleration-data */
		{
			l_u16SpeedRPM = NVRAM_MIN_SPEED;
    8bd6:	703c      	lod	A, #60
    8bd8:	52d8 0170 	mov	0x170 <_l_u16SpeedRPM>, A
			l_u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    8bdc:	72d8 010c 	lod	A, 0x10c <_g_u16MotorMicroStepsPerMechRotation>
    8be0:	52df      	push	A
    8be2:	4ce2 2c40 	mov	YA, #105000000
    8be6:	0642 
    8be8:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    8bec:	52d8 0172 	mov	0x172 <_l_u32Temp>, A
    8bf0:	5ad8 0174 	mov	0x174 <_l_u32Temp+0x2>, Y
    8bf4:	5c01      	dec	S, #2
    8bf6:	7ed8 0170 	lod	X, 0x170 <_l_u16SpeedRPM>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8bfa:	4c63      	divu	YA, X
    8bfc:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8bfe:	a0ff      	add	A, #-1
    8c00:	52d8 0176 	mov	0x176 <_l_u16LowSpeedPeriod>, A
			l_u16LowSpeedPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1U;
		}
#endif /* USE_MULTI_PURPOSE_BUFFER */

		/* Clear motor-driver current measurement */
		MotorDriverCurrentMeasureInit();
    8c04:	1790      	call	0x8b26 <_MotorDriverCurrentMeasureInit>
#endif
#if _SUPPORT_STALLDET_O
		MotorStallInitO();
#endif /* _SUPPORT_STALLDET_O */
#if _SUPPORT_STALLDET_H
		MotorStallInitH();
    8c06:	12a1      	call	0x914a <_MotorStallInitH>
#endif /* _SUPPORT_STALLDET_H */

		MotorDiagnosticCheckInit();													/* initialize diagnostic */
    8c08:	14bd      	call	0x8584 <_MotorDiagnosticCheckInit>
#endif /* _DEBUG_VOLTAGE_COMPENSATION */

		/* Connect drivers */
		/* Stepper 4-phase/32-steps */
		{
			MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_au16MotorSpeedRPS[1]);	/* MMP140822-1 - Begin */
    8c0a:	72d8 0120 	lod	A, 0x120 <_g_au16MotorSpeedRPS+0x2>
    8c0e:	52df      	push	A
    8c10:	72d8 0180 	lod	A, 0x180 <_g_u16PidRunningThreshold>
    8c14:	17a1      	call	0x8b58 <_MotorDriver_InitialPwmDutyCycle>
		}
		MotorDriver_4PhaseStepper();
    8c16:	165a      	call	0x88cc <_MotorDriver_4PhaseStepper>

#if (_SUPPORT_PWM_DC_RAMPUP == FALSE)												/* MMP140903-2 - Begin */
		if ( g_u16MotorSpeedRPS > g_au16MotorSpeedRPS[1] )
    8c18:	72d8 0108 	lod	A, 0x108 <_g_u16MotorSpeedRPS>
    8c1c:	5c01      	dec	S, #2
    8c1e:	aed8 0120 	cmp	A, 0x120 <_g_au16MotorSpeedRPS+0x2>
    8c22:	1a05      	jule	0x8c2e <_MotorDriverStart+0x62>
		{
			MotorDriver_InitialPwmDutyCycle( g_u16PidRunningThreshold, g_u16MotorSpeedRPS);
    8c24:	52df      	push	A
    8c26:	72d8 0180 	lod	A, 0x180 <_g_u16PidRunningThreshold>
    8c2a:	1796      	call	0x8b58 <_MotorDriver_InitialPwmDutyCycle>
    8c2c:	5c01      	dec	S, #2
		}																			/* MMP140822-1 - End */
#endif /* (_SUPPORT_PWM_DC_RAMPUP == FALSE) */										/* MMP140903-2 - End */
		DRVCFG_PWM_UVWT();															/* Enable the driver and the PWM phase W, V, U and T */
    8c2e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8c32:	b6da fe00 	and	A, #65024
    8c36:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8c3a:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8c3e:	a455      	or	A, #85
    8c40:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A

		/* Setup ADC for Motor Temperature/Current/Voltage measurements */
		ADC_Start();
    8c44:	82db 821c 	callf	0x821c <_ADC_Start>

		g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;								/* Start-up in Acceleration stepper mode */
    8c48:	6001      	lod	AL, #1
    8c4a:	42d8 00dd 	mov	0xdd <_g_u8MotorStartupMode>, AL
		l_u8VTIdx = 0;
    8c4e:	6000      	lod	AL, #0
    8c50:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
		if ( g_u8MotorStartupMode == (uint8) MSM_STEPPER_A )
		{
			if ( g_u16TargetCommutTimerPeriod < l_u16LowSpeedPeriod )
    8c52:	793e      	lod	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    8c54:	72d8 0176 	lod	A, 0x176 <_l_u16LowSpeedPeriod>
    8c58:	eee2      	cmp	Y, A
    8c5a:	1c02      	jnc	0x8c60 <_MotorDriverStart+0x94>
			{
				/* Target speed too fast for motor to start-up with */
				g_u16CommutTimerPeriod = l_u16LowSpeedPeriod;						/* Initial start-up speed */
    8c5c:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
    8c5e:	0001      	jmp	0x8c62 <_MotorDriverStart+0x96>
			}
			else
			{
				/* Target speed is slower than maximum motor start-up speed */
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    8c60:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			}
		}
		/* motor running direction */
		g_e8MotorDirectionCCW = (g_u16ActuatorTgtPos < g_u16ActuatorActPos) ? C_MOTOR_DIR_CCW : C_MOTOR_DIR_CW;
    8c62:	6000      	lod	AL, #0
    8c64:	4201      	mov	[S-2], AL
    8c66:	7948      	lod	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    8c68:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8c6a:	eee2      	cmp	Y, A
    8c6c:	1c02      	jnc	0x8c72 <_MotorDriverStart+0xa6>
    8c6e:	6001      	lod	AL, #1
    8c70:	4201      	mov	[S-2], AL
    8c72:	6201      	lod	AL, [S-2]
    8c74:	4144      	mov	dp:0x44 <_g_e8MotorDirectionCCW>, AL
		/* start commutation timer */
		TMR1_REGB = g_u16CommutTimerPeriod;
    8c76:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    8c78:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
		TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;									/* Start Timer mode 0 */
    8c7a:	72da 4003 	lod	A, #16387
    8c7e:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
    8c80:	5403      	ret	#4

00008c82 <_MotorDriverStop>:
 *						C_STOP_EMERGENCY : Immediate stop (without ramp-down) + delay
 *
 * Stop Motor Driver
 * ****************************************************************************	*/
void MotorDriverStop( uint16 u16Immediate )
{
    8c82:	5805      	inc	S, #6
    8c84:	5205      	mov	[S-6], A
	if(g_u8MotorStartupMode != (uint8) MSM_STOP)
    8c86:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8c8a:	1d01      	jne	0x8c8e <_MotorDriverStop+0xc>
    8c8c:	0070      	jmp	0x8d6e <_MotorDriverStop+0xec>
	{
		if(u16Immediate == (uint16) C_STOP_RAMPDOWN) /*lint !e845 */	/* MMP150922-1 */
    8c8e:	7205      	lod	A, [S-6]
    8c90:	1d22      	jne	0x8cd6 <_MotorDriverStop+0x54>
		{
			if(l_u8VTIdx > 1u)
    8c92:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    8c94:	4203      	mov	[S-4], AL
    8c96:	8c01      	cmp	AL, #1
    8c98:	1a1e      	jule	0x8cd6 <_MotorDriverStop+0x54>
			{
				TMR1_CTRL = C_TMRx_CTRL_MODE0 | TMRx_START;							/* Start timer mode 0 */
    8c9a:	72da 4003 	lod	A, #16387
    8c9e:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
				
				/* Set TargetPos near CurrentPos, including ramp-down */
				if ( g_u16ActuatorActPos > g_u16ActuatorTgtPos )
    8ca0:	7946      	lod	Y, dp:0x46 <_g_u16ActuatorActPos>
    8ca2:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8ca4:	5201      	mov	[S-2], A
    8ca6:	6203      	lod	AL, [S-4]
    8ca8:	5cf2      	usex	A
    8caa:	7ee2      	lod	X, A
    8cac:	ee01      	cmp	Y, [S-2]
    8cae:	1a09      	jule	0x8cc2 <_MotorDriverStop+0x40>
				{
					uint16 u16DeltaPos = g_u16ActuatorActPos - g_u16ActuatorTgtPos;
    8cb0:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8cb2:	7948      	lod	Y, dp:0x48 <_g_u16ActuatorTgtPos>
    8cb4:	aae6      	sub	A, Y
					if ( u16DeltaPos > l_u8VTIdx )
    8cb6:	aeee      	cmp	A, X
    8cb8:	1e01      	jug	0x8cbc <_MotorDriverStop+0x3a>
    8cba:	0059      	jmp	0x8d6e <_MotorDriverStop+0xec>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos - l_u8VTIdx;
    8cbc:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8cbe:	aaee      	sub	A, X
    8cc0:	0008      	jmp	0x8cd2 <_MotorDriverStop+0x50>
					}
				}
				else
				{
					uint16 u16DeltaPos = g_u16ActuatorTgtPos - g_u16ActuatorActPos;
    8cc2:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8cc4:	7946      	lod	Y, dp:0x46 <_g_u16ActuatorActPos>
    8cc6:	aae6      	sub	A, Y
					if ( u16DeltaPos > l_u8VTIdx )
    8cc8:	aeee      	cmp	A, X
    8cca:	1e01      	jug	0x8cce <_MotorDriverStop+0x4c>
    8ccc:	0050      	jmp	0x8d6e <_MotorDriverStop+0xec>
					{
						g_u16ActuatorTgtPos = g_u16ActuatorActPos + l_u8VTIdx;
    8cce:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8cd0:	a2ee      	add	A, X
    8cd2:	5148      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, A
					}
				}
				
				return;
    8cd4:	5407      	ret	#8
			}
		}
		/* 1.First stop ADC, before stopping motor (trigger-event) */
		ADC_Stop();
    8cd6:	82db 8196 	callf	0x8196 <_ADC_Stop>
		g_u8MotorStartupMode = (uint8) MSM_STOP;								/* Stop mode */
    8cda:	6000      	lod	AL, #0
    8cdc:	42d8 00dd 	mov	0xdd <_g_u8MotorStartupMode>, AL
		g_u8MotorStatusSpeed = (uint8) C_MOTOR_SPEED_STOP;						/* Stop */
    8ce0:	42d8 00d9 	mov	0xd9 <_g_u8MotorStatusSpeed>, AL
		/* 3.deal with specific stop request */
		/* in case stop with holding current:not supported yet */
		if(u16Immediate == (uint16) C_STOP_HOLD)
    8ce4:	7205      	lod	A, [S-6]
    8ce6:	ac01      	cmp	A, #1
    8ce8:	1d1b      	jne	0x8d20 <_MotorDriverStop+0x9e>
		{
			/* Keep Motor driver active with a specified amount of current (unless permanent electric error) */
			MotorDriver_InitialPwmDutyCycle( g_u16PidHoldingThreshold, 0);
    8cea:	54ca 0000 	pushw	#0
    8cee:	72d8 0184 	lod	A, 0x184 <_g_u16PidHoldingThreshold>
    8cf2:	1732      	call	0x8b58 <_MotorDriver_InitialPwmDutyCycle>
	
			MotorDriver_4PhaseStepper();
    8cf4:	15eb      	call	0x88cc <_MotorDriver_4PhaseStepper>
			DRVCFG_PWM_UVWT();	
    8cf6:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8cfa:	b6da fe00 	and	A, #65024
    8cfe:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8d02:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d06:	a455      	or	A, #85
    8d08:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			g_u16MotorCurrentLPFx64 = (g_u16PidHoldingThreshold << 6u);				/* Low-pass Filtered motor-current (x 64) */
    8d0c:	72d8 0184 	lod	A, 0x184 <_g_u16PidHoldingThreshold>
    8d10:	44a2      	asl	A, #2
    8d12:	44a2      	asl	A, #2
    8d14:	44a2      	asl	A, #2
    8d16:	5142      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, A

			ADC_Start();															/* Start measuring motor current */
    8d18:	82db 821c 	callf	0x821c <_ADC_Start>
    8d1c:	5c01      	dec	S, #2
    8d1e:	001d      	jmp	0x8d5a <_MotorDriverStop+0xd8>

		}
		/* in case stop with immediately */
		if(u16Immediate == (uint16) C_STOP_IMMEDIATE)
    8d20:	7205      	lod	A, [S-6]
    8d22:	ac02      	cmp	A, #2
    8d24:	1d0b      	jne	0x8d3c <_MotorDriverStop+0xba>
		{
			DRVCFG_GND_UVWT();														/* Make Low-side active, for a short time (recycle current) */
    8d26:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d2a:	b6da fe00 	and	A, #65024
    8d2e:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
    8d32:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d36:	a6da 00aa 	or	A, #170
    8d3a:	000d      	jmp	0x8d56 <_MotorDriverStop+0xd4>
		}
		/* In case of a permanent error, don't connect drivers anymore */
		if(u16Immediate == (uint16)C_STOP_EMERGENCY)
    8d3c:	7205      	lod	A, [S-6]
    8d3e:	ac03      	cmp	A, #3
    8d40:	1d0c      	jne	0x8d5a <_MotorDriverStop+0xd8>
		{
			DRVCFG_DIS_UVWT();
    8d42:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d46:	b6da fe00 	and	A, #65024
    8d4a:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
			DRVCFG_DIS();															/* MMP140903-1 */		
    8d4e:	72d8 28c6 	lod	A, 0x28c6 <__io__+0xc6>
    8d52:	a6da 0100 	or	A, #256
    8d56:	52d8 28c6 	mov	0x28c6 <__io__+0xc6>, A
																					/* MMP130919-1 - End */
		}
		/* 4.stop commutation timer */
		TMR1_CTRL &= ~TMRx_START;													/* Stop "commutation timer" */
    8d5a:	72aa      	lod	A, io:0x2a <__data_dp_end+0x2>
    8d5c:	b4fd      	and	A, #-3
    8d5e:	52aa      	mov	io:0x2a <__data_dp_end+0x2>, A
		XI0_PEND = CLR_T1_INT4;														/* Clear (potentially pending) Timer1 second level interrupts (T1_INT4) */
    8d60:	7040      	lod	A, #64
    8d62:	52d8 2034 	mov	0x2034 <__ep__+0x1034>, A
		PEND = CLR_EXT0_IT;															/* ... and first level interrupt */
    8d66:	72da 0100 	lod	A, #256
    8d6a:	52d8 2008 	mov	0x2008 <__ep__+0x1008>, A
    8d6e:	5407      	ret	#8

00008d70 <_MotorDriver_MainFunction>:
	g_sMotorFault.SHORT = 0;
	g_sMotorFault.OPEN = 0;
}

void MotorDriver_MainFunction(void)
{
    8d70:	5807      	inc	S, #8
	/* Diagnostic */
	MotorDiagnosticVsupplyAndTemperature();
    8d72:	1445      	call	0x85fe <_MotorDiagnosticVsupplyAndTemperature>

	/* Diagnostic protection:motor transfer to degrade mode */
	if((g_sMotorFault.UV != 0u) || (g_sMotorFault.OV != 0u) || 
    8d74:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8d76:	9401      	and	AL, #1
    8d78:	1d13      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d7a:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8d7c:	9402      	and	AL, #2
    8d7e:	1d10      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d80:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8d82:	9404      	and	AL, #4
    8d84:	1d0d      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d86:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8d88:	9408      	and	AL, #8
    8d8a:	1d0a      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d8c:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8d8e:	b6da 03c0 	and	A, #960
    8d92:	1d06      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d94:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    8d96:	9404      	and	AL, #4
    8d98:	1d03      	jne	0x8da0 <_MotorDriver_MainFunction+0x30>
    8d9a:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8d9c:	9420      	and	AL, #32
    8d9e:	1905      	je	0x8daa <_MotorDriver_MainFunction+0x3a>
		(g_sMotorFault.OPEN != 0u) || (g_sMotorFault.SHORT != 0u) ||
		(g_sMotorFault.ST != 0u) || (g_sMotorFault.DRIFT != 0u) || (g_sMotorFault.TS != 0u))
	{
		l_u8MotorStatus = C_MOTOR_STATUS_DEGRADED;
    8da0:	6080      	lod	AL, #-128
    8da2:	42d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, AL
		MotorDriverStop(C_STOP_EMERGENCY);
    8da6:	7003      	lod	A, #3
    8da8:	176c      	call	0x8c82 <_MotorDriverStop>
	}

	/* Stepper Motor State Machine */
	switch( l_u8MotorStatus )
    8daa:	62d8 00d8 	lod	AL, 0xd8 <_l_u8MotorStatus>
    8dae:	5cf2      	usex	A
    8db0:	ac01      	cmp	A, #1
    8db2:	190e      	je	0x8dd0 <_MotorDriver_MainFunction+0x60>
    8db4:	1f04      	jsg	0x8dbe <_MotorDriver_MainFunction+0x4e>
    8db6:	ac00      	cmp	A, #0
    8db8:	1d01      	jne	0x8dbc <_MotorDriver_MainFunction+0x4c>
    8dba:	0055      	jmp	0x8e66 <_MotorDriver_MainFunction+0xf6>
    8dbc:	00ad      	jmp	0x8f18 <_MotorDriver_MainFunction+0x1a8>
    8dbe:	ac04      	cmp	A, #4
    8dc0:	1905      	je	0x8dcc <_MotorDriver_MainFunction+0x5c>
    8dc2:	aeda 0080 	cmp	A, #128
    8dc6:	1d01      	jne	0x8dca <_MotorDriver_MainFunction+0x5a>
    8dc8:	0084      	jmp	0x8ed2 <_MotorDriver_MainFunction+0x162>
    8dca:	00a6      	jmp	0x8f18 <_MotorDriver_MainFunction+0x1a8>
	{
		case C_MOTOR_STATUS_SELFTEST:
			l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8dcc:	6000      	lod	AL, #0
    8dce:	007c      	jmp	0x8ec8 <_MotorDriver_MainFunction+0x158>
			break;
		case C_MOTOR_STATUS_RUNNING:
			/* runtime current PID control  */
			if( Timer_IsExpired(PID_CTRL_TIMER) == TRUE )
    8dd0:	7004      	lod	A, #4
    8dd2:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    8dd6:	8c01      	cmp	AL, #1
    8dd8:	1d08      	jne	0x8dea <_MotorDriver_MainFunction+0x7a>
			{
				PID_Control();													/* PID-control (Current) */
    8dda:	82db 9740 	callf	0x9740 <_PID_Control>
				Timer_Start(PID_CTRL_TIMER,(uint16)NVRAM_PID_RUNNINGCTRL_PER);
    8dde:	54ca 000a 	pushw	#10
    8de2:	7004      	lod	A, #4
    8de4:	82db 989a 	callf	0x989a <_Timer_Start>
    8de8:	5c01      	dec	S, #2
			}
			/* update target speed,may be overwitten by ISR */
			{
				uint32 u32Temp;
				
				u32Temp = divU32_U32byU16( (TIMER_CLOCK * 60U), g_u16MotorMicroStepsPerMechRotation);
    8dea:	7ad8 010c 	lod	Y, 0x10c <_g_u16MotorMicroStepsPerMechRotation>
    8dee:	5adf      	push	Y
    8df0:	4ce2 2c40 	mov	YA, #105000000
    8df4:	0642 
    8df6:	82db 6bfa 	callf	0x6bfa <_divU32_U32byU16>
    8dfa:	4cc0      	mov	D, YA
    8dfc:	5c01      	dec	S, #2
    8dfe:	714e      	lod	A, dp:0x4e <_l_u16ActuatorBufferedSpdRPM>
    8e00:	5207      	mov	[S-8], A
    8e02:	a01e      	add	A, #30
    8e04:	4cf2      	usex	YA
    8e06:	7c3c      	lod	X, #60
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e08:	4c63      	divu	YA, X
    8e0a:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e0c:	52d8 0108 	mov	0x108 <_g_u16MotorSpeedRPS>, A
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    8e10:	4c80      	mov	YA, D
    8e12:	7e07      	lod	X, [S-8]
    8e14:	4c63      	divu	YA, X
    8e16:	4c63      	divu	YA, X
    8e18:	5203      	mov	[S-4], A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    8e1a:	a0ff      	add	A, #-1
    8e1c:	513e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, A
				g_u16MotorSpeedRPS = divU16_U32byU16( (uint32)(uint16)(l_u16ActuatorBufferedSpdRPM + 30U), 60U);
				g_u16TargetCommutTimerPeriod = divU16_U32byU16( u32Temp, l_u16ActuatorBufferedSpdRPM) - 1U;	
			}
			/* need change new direction? */
			if(l_u8MotorRequest == C_MOTOR_CTRL_START)
    8e1e:	62d8 00d7 	lod	AL, 0xd7 <_l_u8MotorRequest>
    8e22:	8c01      	cmp	AL, #1
    8e24:	1d10      	jne	0x8e46 <_MotorDriver_MainFunction+0xd6>
			{
				uint8 u8NewMotorDirectionCCW;
				
				u8NewMotorDirectionCCW = (l_u16ActuatorBufferedTgtPos < g_u16ActuatorActPos) ? C_MOTOR_DIR_CCW : C_MOTOR_DIR_CW;
    8e26:	7c00      	lod	X, #0
    8e28:	794c      	lod	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    8e2a:	5a01      	mov	[S-2], Y
    8e2c:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8e2e:	eee2      	cmp	Y, A
    8e30:	1c01      	jnc	0x8e34 <_MotorDriver_MainFunction+0xc4>
    8e32:	7c01      	lod	X, #1
				/* update new target position:commutation if direction inversed with current direction */
				if ( u8NewMotorDirectionCCW != g_e8MotorDirectionCCW )
    8e34:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    8e36:	7aee      	lod	Y, X
    8e38:	8ee8      	cmp	AL, YL
    8e3a:	1903      	je	0x8e42 <_MotorDriver_MainFunction+0xd2>
		     	{
		        	/* Changing direction; Stop motor first before starting in opposite direction */
		        	MotorDriverStop( (uint16) C_STOP_RAMPDOWN);					/* Change of direction */
    8e3c:	7000      	lod	A, #0
    8e3e:	1721      	call	0x8c82 <_MotorDriverStop>
    8e40:	0002      	jmp	0x8e46 <_MotorDriver_MainFunction+0xd6>
		       	}
				else
				{
					/* only update target position */
					g_u16ActuatorTgtPos = l_u16ActuatorBufferedTgtPos;
    8e42:	7e01      	lod	X, [S-2]
    8e44:	5d48      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, X
				}
			}
			/* Motor request stop */
			if(l_u8MotorRequest == C_MOTOR_CTRL_STOP)
    8e46:	62d8 00d7 	lod	AL, 0xd7 <_l_u8MotorRequest>
    8e4a:	1d05      	jne	0x8e56 <_MotorDriver_MainFunction+0xe6>
			{
				MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    8e4c:	7002      	lod	A, #2
    8e4e:	1719      	call	0x8c82 <_MotorDriverStop>
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8e50:	6000      	lod	AL, #0
    8e52:	42d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, AL
			}
			/* Motor reach target position,stop by commutation ISR */
			if(g_u8MotorStartupMode == (uint8)MSM_STOP)
    8e56:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8e5a:	1901      	je	0x8e5e <_MotorDriver_MainFunction+0xee>
    8e5c:	0060      	jmp	0x8f1e <_MotorDriver_MainFunction+0x1ae>
			{
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8e5e:	6400      	lod	YL, #0
    8e60:	46d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, YL
			}
			break;
    8e64:	5409      	ret	#10
		case C_MOTOR_STATUS_STOP:
			/* ********************************************************** */
			/* *** l. Threshold control (Stepper: Current-threshold) 			   *** */
			/* ********************************************************** */
			if(Timer_IsExpired(PID_THRSHLD_CTRL_TIMER) == TRUE)
    8e66:	7005      	lod	A, #5
    8e68:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    8e6c:	8c01      	cmp	AL, #1
    8e6e:	1d08      	jne	0x8e80 <_MotorDriver_MainFunction+0x110>
			{
				ThresholdControl();
    8e70:	82db 980e 	callf	0x980e <_ThresholdControl>
				Timer_Start(PID_THRSHLD_CTRL_TIMER,(uint16)NVRAM_PID_THRSHLDCTRL_PER);
    8e74:	54ca 0800 	pushw	#2048
    8e78:	7005      	lod	A, #5
    8e7a:	82db 989a 	callf	0x989a <_Timer_Start>
    8e7e:	5c01      	dec	S, #2
			}

			/* Stop-mode & holding-current required:not support */
			if(g_u8MotorHoldingCurrState == TRUE)
    8e80:	62d8 00dc 	lod	AL, 0xdc <_g_u8MotorHoldingCurrState>
    8e84:	8c01      	cmp	AL, #1
    8e86:	1d0e      	jne	0x8ea4 <_MotorDriver_MainFunction+0x134>
			{
				/* holding current */
				if( Timer_IsExpired(PID_CTRL_TIMER) == TRUE)
    8e88:	7004      	lod	A, #4
    8e8a:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    8e8e:	8c01      	cmp	AL, #1
    8e90:	1d09      	jne	0x8ea4 <_MotorDriver_MainFunction+0x134>
				{
					Timer_Start(PID_CTRL_TIMER,(uint16)NVRAM_PID_HOLDINGCTRL_PER);
    8e92:	54ca 0064 	pushw	#100
    8e96:	7004      	lod	A, #4
    8e98:	82db 989a 	callf	0x989a <_Timer_Start>
					PID_Control();
    8e9c:	82db 9740 	callf	0x9740 <_PID_Control>
					MotorDriver_4PhaseStepper();
    8ea0:	1515      	call	0x88cc <_MotorDriver_4PhaseStepper>
    8ea2:	5c01      	dec	S, #2
				}
			}
			/* start request and motor target position not equals actual position */
			if( (l_u8MotorRequest == C_MOTOR_CTRL_START) && (l_u16ActuatorBufferedTgtPos != g_u16ActuatorActPos) )
    8ea4:	62d8 00d7 	lod	AL, 0xd7 <_l_u8MotorRequest>
    8ea8:	8c01      	cmp	AL, #1
    8eaa:	1d11      	jne	0x8ece <_MotorDriver_MainFunction+0x15e>
    8eac:	794c      	lod	Y, dp:0x4c <_l_u16ActuatorBufferedTgtPos>
    8eae:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8eb0:	eee2      	cmp	Y, A
    8eb2:	190d      	je	0x8ece <_MotorDriver_MainFunction+0x15e>
			{
				g_u16ActuatorTgtPos = l_u16ActuatorBufferedTgtPos;
    8eb4:	5948      	mov	dp:0x48 <_g_u16ActuatorTgtPos>, Y
				
				if(Timer_IsExpired(MOTOR_START_DELAY_TIMER) == TRUE)
    8eb6:	7002      	lod	A, #2
    8eb8:	82db 98ac 	callf	0x98ac <_Timer_IsExpired>
    8ebc:	4205      	mov	[S-6], AL
    8ebe:	8c01      	cmp	AL, #1
    8ec0:	1901      	je	0x8ec4 <_MotorDriver_MainFunction+0x154>
    8ec2:	002d      	jmp	0x8f1e <_MotorDriver_MainFunction+0x1ae>
				{			
					MotorDriverStart();
    8ec4:	1683      	call	0x8bcc <_MotorDriverStart>
					l_u8MotorStatus = C_MOTOR_STATUS_RUNNING;
    8ec6:	6205      	lod	AL, [S-6]
    8ec8:	42d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, AL
    8ecc:	5409      	ret	#10
				}
			}
			else
			{
				MotorDriverStop(C_STOP_IMMEDIATE);
    8ece:	7002      	lod	A, #2
    8ed0:	0017      	jmp	0x8f00 <_MotorDriver_MainFunction+0x190>
			}
			break;
		case C_MOTOR_STATUS_DEGRADED:
			/* Diagnostic shutdown protection */
			if((g_sMotorFault.UV != 0u) || (g_sMotorFault.OV != 0u) || 
    8ed2:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8ed4:	9401      	and	AL, #1
    8ed6:	1d13      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8ed8:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8eda:	9402      	and	AL, #2
    8edc:	1d10      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8ede:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8ee0:	9404      	and	AL, #4
    8ee2:	1d0d      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8ee4:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8ee6:	9408      	and	AL, #8
    8ee8:	1d0a      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8eea:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    8eec:	b6da 03c0 	and	A, #960
    8ef0:	1d06      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8ef2:	611d      	lod	AL, dp:0x1d <_g_sMotorFault+0x1>
    8ef4:	9404      	and	AL, #4
    8ef6:	1d03      	jne	0x8efe <_MotorDriver_MainFunction+0x18e>
    8ef8:	611c      	lod	AL, dp:0x1c <_g_sMotorFault>
    8efa:	9420      	and	AL, #32
    8efc:	1903      	je	0x8f04 <_MotorDriver_MainFunction+0x194>
				(g_sMotorFault.OPEN != 0u) || (g_sMotorFault.SHORT != 0u) ||
				(g_sMotorFault.ST != 0u) || (g_sMotorFault.DRIFT != 0u) || (g_sMotorFault.TS != 0u))
			{
				MotorDriverStop(C_STOP_EMERGENCY);
    8efe:	7003      	lod	A, #3
    8f00:	16c0      	call	0x8c82 <_MotorDriverStop>
    8f02:	5409      	ret	#10
			}
			else
			{
				/* degrade mode removed,delay before motor re-start */
				l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8f04:	6400      	lod	YL, #0
    8f06:	46d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, YL
				Timer_Start(MOTOR_START_DELAY_TIMER,C_PI_TICKS_20MS);
    8f0a:	54ca 0028 	pushw	#40
    8f0e:	7002      	lod	A, #2
    8f10:	82db 989a 	callf	0x989a <_Timer_Start>
    8f14:	5c01      	dec	S, #2
			}
			break;
    8f16:	5409      	ret	#10
		default:
			l_u8MotorStatus = C_MOTOR_STATUS_STOP;
    8f18:	6000      	lod	AL, #0
    8f1a:	42d8 00d8 	mov	0xd8 <_l_u8MotorStatus>, AL
    8f1e:	5409      	ret	#10

00008f20 <_MotorDriverCurrentMeasure>:
 *
 * Measure a average motor current, based on ADC current's
 * Performance: Approximate: 10us at 20MHz
 * ****************************************************************************	*/
void MotorDriverCurrentMeasure( void)
{
    8f20:	5803      	inc	S, #4
	uint16 u16MotorCurrentAcc;
	uint16 u16MicroStepMotorCurrent = GetRawMotorDriverCurrent();
    8f22:	82db 836a 	callf	0x836a <_GetRawMotorDriverCurrent>
    8f26:	7ee2      	lod	X, A
	SpiDebugWriteFirst(g_u16PidRunningThreshold|0x8000u);
	SpiDebugWriteNext(g_u16MotorCurrentMovAvgxN);
#endif /* _DEBUG_SPI */

	/* Moving average (sum) of motor-driver current */
	uint16 *pu16MotorCurrentElement = &l_au16MotorCurrentRaw[l_u16MotorCurrentRawIdx];
    8f28:	72d8 012e 	lod	A, 0x12e <_l_u16MotorCurrentRawIdx>
    8f2c:	487a 0002 	muls	Y, A, #2
    8f30:	e2da 0130 	add	Y, #304
    8f34:	5a03      	mov	[S-4], Y
	uint16 u16PrevMotorCurrent = *pu16MotorCurrentElement;
    8f36:	7af0      	lod	Y, [Y]
    8f38:	5a01      	mov	[S-2], Y

	l_u16MotorCurrentRawIdx = (l_u16MotorCurrentRawIdx + 1u) & (C_MOVAVG_SZ - 1u);
    8f3a:	a001      	add	A, #1
    8f3c:	b41f      	and	A, #31
    8f3e:	52d8 012e 	mov	0x12e <_l_u16MotorCurrentRawIdx>, A
	if ( (g_u16StartupDelay != 0u) || (u16MicroStepMotorCurrent < (u16PrevMotorCurrent << 1u)) )	/* Check for valid motor-driver current (at least smaller than 2x previous current)  */
    8f42:	7120      	lod	A, dp:0x20 <_g_u16StartupDelay>
    8f44:	1d04      	jne	0x8f4e <_MotorDriverCurrentMeasure+0x2e>
    8f46:	72e6      	lod	A, Y
    8f48:	4422      	asl	A
    8f4a:	2ee2      	cmp	X, A
    8f4c:	1c06      	jnc	0x8f5a <_MotorDriverCurrentMeasure+0x3a>
	{
		g_u16MotorCurrentMovAvgxN -= u16PrevMotorCurrent;						/* Subtract oldest raw motor-driver current */
    8f4e:	7140      	lod	A, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    8f50:	aa01      	sub	A, [S-2]
		g_u16MotorCurrentMovAvgxN += u16MicroStepMotorCurrent;					/* Add newest raw motor-driver current */
    8f52:	a2ee      	add	A, X
    8f54:	5140      	mov	dp:0x40 <_g_u16MotorCurrentMovAvgxN>, A
		*pu16MotorCurrentElement = u16MicroStepMotorCurrent;					/* Overwrite oldest with newest motor-driver current */
    8f56:	7a03      	lod	Y, [S-4]
    8f58:	5ef0      	mov	[Y], X
	}

	/* During twice the moving-average-buffer size and during acceleration of the motor, LPF should follow
	   lowest value of LPF or Motor-current. As the speed is increasing so also is the BEMF also increasing,
	   which causes the current to decrease. Otherwise a first order (IIR-1) LPF is used. */
	u16MotorCurrentAcc = (g_u16MotorCurrentMovAvgxN << (6u - C_MOVAVG_SSZ));
    8f5a:	7d40      	lod	X, dp:0x40 <_g_u16MotorCurrentMovAvgxN>
    8f5c:	442e      	asl	X
	if ( (g_u16StartupDelay > (l_u16StartupDelayInit - (2u * C_MOVAVG_SZ))) || 
    8f5e:	72d8 00da 	lod	A, 0xda <_l_u16StartupDelayInit>
    8f62:	a0c0      	add	A, #-64
    8f64:	ad20      	cmp	A, dp:0x20 <_g_u16StartupDelay>
    8f66:	1808      	jc	0x8f78 <_MotorDriverCurrentMeasure+0x58>
    8f68:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8f6c:	8c02      	cmp	AL, #2
    8f6e:	1904      	je	0x8f78 <_MotorDriverCurrentMeasure+0x58>
    8f70:	8c01      	cmp	AL, #1
    8f72:	1d04      	jne	0x8f7c <_MotorDriverCurrentMeasure+0x5c>
    8f74:	2d42      	cmp	X, dp:0x42 <_g_u16MotorCurrentLPFx64>
    8f76:	1c02      	jnc	0x8f7c <_MotorDriverCurrentMeasure+0x5c>
		(g_u8MotorStartupMode == (uint8) MSM_STEPPER_D) || 
		((g_u8MotorStartupMode == (uint8) MSM_STEPPER_A) && (u16MotorCurrentAcc < g_u16MotorCurrentLPFx64)) )
	{
		g_u16MotorCurrentLPFx64 = u16MotorCurrentAcc;
    8f78:	5d42      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, X
    8f7a:	000e      	jmp	0x8f98 <_MotorDriverCurrentMeasure+0x78>
#if (MOTOR_MICROSTEPS < 3)
		/* LPF_B: IIR of 0.9921875 (127/128) & 0.0078125 (1/128) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 63u) >> 7u)) + ((u16MotorCurrentAcc + 63u) >> 7u);
#else  /* (MOTOR_MICROSTEPS < 3) */
		/* LPF_B: IIR of 0.99609375 (255/256) & 0.00390625 (1/256) */
		g_u16MotorCurrentLPFx64 = (g_u16MotorCurrentLPFx64 - ((g_u16MotorCurrentLPFx64 + 128u) >> 8u)) + ((u16MotorCurrentAcc + 128u) >> 8u);
    8f7c:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    8f7e:	7ae2      	lod	Y, A
    8f80:	e2da 0080 	add	Y, #128
    8f84:	6400      	lod	YL, #0
    8f86:	7ae8      	swap	Y
    8f88:	aae6      	sub	A, Y
    8f8a:	7aee      	lod	Y, X
    8f8c:	e2da 0080 	add	Y, #128
    8f90:	6400      	lod	YL, #0
    8f92:	7ae8      	swap	Y
    8f94:	a2e6      	add	A, Y
    8f96:	5142      	mov	dp:0x42 <_g_u16MotorCurrentLPFx64>, A
#endif /* (MOTOR_MICROSTEPS < 3) */
	}

	/* startup delay decrement every current meassure(msp) */
	if ( g_u16StartupDelay > 0u )
    8f98:	7120      	lod	A, dp:0x20 <_g_u16StartupDelay>
    8f9a:	1902      	je	0x8fa0 <_MotorDriverCurrentMeasure+0x80>
	{
		g_u16StartupDelay--;
    8f9c:	a0ff      	add	A, #-1
    8f9e:	5120      	mov	dp:0x20 <_g_u16StartupDelay>, A
    8fa0:	5405      	ret	#6

00008fa2 <_EXT0_IT>:
 * Note: The Commutation_ISR() not be interrupted by LIN communication, also not by LIN status request.
 * The g_u8StallOcc flags can be set in this Commutation_ISR(), but cleared in the MotorDriverStop(),
 * before it is communicated back to the ECU/Master.
 * ****************************************************************************	*/
__interrupt__ void EXT0_IT(void)
{
    8fa2:	52df      	push	A
    8fa4:	5edf      	push	X
    8fa6:	5adf      	push	Y
    8fa8:	4c83      	push	D
    8faa:	580b      	inc	S, #12
#if (_DEBUG_COMMUT_ISR != FALSE)
	DEBUG_SET_IO_B();
#endif /* (_DEBUG_COMMUT_ISR != FALSE) && (_DEBUG_HALLLATCH_ISR == FALSE) */

	uint16 pending = XI0_PEND & XI0_MASK;										/* Copy interrupt requests which are not masked   */
    8fac:	7ad8 2034 	lod	Y, 0x2034 <__ep__+0x1034>
    8fb0:	72d8 202a 	lod	A, 0x202a <__ep__+0x102a>
    8fb4:	f6e2      	and	Y, A
	do
	{
		XI0_PEND = pending;														/* Clear requests which are going to be processed */
    8fb6:	5ad8 2034 	mov	0x2034 <__ep__+0x1034>, Y
	} while ((XI0_PEND & pending) != 0u);
    8fba:	72d8 2034 	lod	A, 0x2034 <__ep__+0x1034>
    8fbe:	b6e6      	and	A, Y
    8fc0:	1d7a      	jne	0x8fb6 <_EXT0_IT+0x14>

	if ( g_u8MotorStartupMode == (uint8) MSM_STOP )
    8fc2:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    8fc6:	1d01      	jne	0x8fca <_EXT0_IT+0x28>
    8fc8:	00b8      	jmp	0x913a <_EXT0_IT+0x198>
	{
		return;		/* Used for CPU wake-up */
	}

	if ( g_e8MotorDirectionCCW == C_MOTOR_DIR_CCW)												/* Motor direction counter clockwise is true? */
    8fca:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    8fcc:	8c01      	cmp	AL, #1
    8fce:	1d03      	jne	0x8fd6 <_EXT0_IT+0x34>
	{
		g_u16ActuatorActPos--;													/* Closing */
    8fd0:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8fd2:	a0ff      	add	A, #-1
    8fd4:	0002      	jmp	0x8fda <_EXT0_IT+0x38>
	}
	else
	{
		g_u16ActuatorActPos++;													/* Opening */
    8fd6:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8fd8:	a001      	add	A, #1
    8fda:	5146      	mov	dp:0x46 <_g_u16ActuatorActPos>, A
	}

	{
		int32 i32DeltaPosition = (int32)g_u16ActuatorActPos - (int32)g_u16ActuatorTgtPos;
    8fdc:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    8fde:	4cc8      	movu	D, A
    8fe0:	7148      	lod	A, dp:0x48 <_g_u16ActuatorTgtPos>
    8fe2:	4cf2      	usex	YA
    8fe4:	4c10      	sub	D, YA
		if ( i32DeltaPosition == 0 )
    8fe6:	4cba 0000 	cmps	D, #0
    8fea:	1d0a      	jne	0x9000 <_EXT0_IT+0x5e>
		{
			MotorDriverStop( (uint16) C_STOP_IMMEDIATE);
    8fec:	7002      	lod	A, #2
    8fee:	1649      	call	0x8c82 <_MotorDriverStop>
			return;
    8ff0:	5c0b      	dec	S, #12
    8ff2:	4cc3      	pop	D
    8ff4:	7acf      	pop	Y
    8ff6:	7ecf      	pop	X
    8ff8:	72cf      	pop	A
    8ffa:	4407      	mov	R, #0
    8ffc:	72cb      	pop	M
    8ffe:	5401      	ret
		}
		if ( i32DeltaPosition < 0 )
    9000:	4cba 0000 	cmps	D, #0
    9004:	1e81      	jsge	0x9008 <_EXT0_IT+0x66>
		{
			i32DeltaPosition = -i32DeltaPosition;
    9006:	4cd0      	neg	D
		}
		if ( i32DeltaPosition <= (int16) l_u8VTIdx )
    9008:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    900a:	5cf2      	usex	A
    900c:	5207      	mov	[S-8], A
    900e:	7800      	lod	Y, #0
    9010:	4c90      	cmp	D, YA
    9012:	1f05      	jsg	0x901e <_EXT0_IT+0x7c>
		{
			/* Decelerate motor speed (almost at target-position) */
			g_u16StartupDelay = (uint16) i32DeltaPosition;
    9014:	4c89      	mov	Y, DL
    9016:	5920      	mov	dp:0x20 <_g_u16StartupDelay>, Y
			g_u16TargetCommutTimerPeriod = l_u16LowSpeedPeriod;
    9018:	7ed8 0176 	lod	X, 0x176 <_l_u16LowSpeedPeriod>
    901c:	5d3e      	mov	dp:0x3e <_g_u16TargetCommutTimerPeriod>, X
		}
	}

	/* Current measurement used for Stall-detector "A" and current control (PID) */
	MotorDriverCurrentMeasure();
    901e:	1780      	call	0x8f20 <_MotorDriverCurrentMeasure>

	/* open coil detection */
	(void)MotorDiagnosticOpenCheck();
    9020:	82db 8596 	callf	0x8596 <_MotorDiagnosticOpenCheck>
	/* Update micro-step index */
	{
		/* Motor Direction Inverse */
		if(NVRAM_MOTOR_DIR_INV != 0u)
		{
			if ( g_e8MotorDirectionCCW == C_MOTOR_DIR_CCW )
    9024:	6144      	lod	AL, dp:0x44 <_g_e8MotorDirectionCCW>
    9026:	793e      	lod	Y, dp:0x3e <_g_u16TargetCommutTimerPeriod>
    9028:	5a09      	mov	[S-10], Y
    902a:	793a      	lod	Y, dp:0x3a <_g_u16MicroStepIdx>
    902c:	7d3c      	lod	X, dp:0x3c <_g_u16CommutTimerPeriod>
    902e:	8c01      	cmp	AL, #1
    9030:	1d09      	jne	0x9044 <_EXT0_IT+0xa2>
			{
				/* Counter Clock-wise (Closing) */
				if ( g_u16MicroStepIdx == 0u )
    9032:	ec00      	cmp	Y, #0
    9034:	1d03      	jne	0x903c <_EXT0_IT+0x9a>
				{
					g_u16MicroStepIdx = g_u16MotorMicroStepsPerElecRotation;
    9036:	72d8 010a 	lod	A, 0x10a <_g_u16MotorMicroStepsPerElecRotation>
    903a:	513a      	mov	dp:0x3a <_g_u16MicroStepIdx>, A
				}
				g_u16MicroStepIdx--;													/* Decrement the PWM vector pointer */
    903c:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    903e:	a0ff      	add	A, #-1
    9040:	513a      	mov	dp:0x3a <_g_u16MicroStepIdx>, A
    9042:	0008      	jmp	0x9054 <_EXT0_IT+0xb2>
			}
			else
			{
				/* Clock-wise (Opening) */
				g_u16MicroStepIdx++;													/* Increment the PWM vectors pointer */
    9044:	72e6      	lod	A, Y
    9046:	a001      	add	A, #1
    9048:	513a      	mov	dp:0x3a <_g_u16MicroStepIdx>, A
				if ( g_u16MicroStepIdx >= g_u16MotorMicroStepsPerElecRotation )			/* Test the PWM vectors pointer: 48 usteps per electrical period */
    904a:	aed8 010a 	cmp	A, 0x10a <_g_u16MotorMicroStepsPerElecRotation>
    904e:	1802      	jc	0x9054 <_EXT0_IT+0xb2>
				{
					g_u16MicroStepIdx = 0u;												/* Re-initialise the PWM vectors pointer to 0 */
    9050:	7800      	lod	Y, #0
    9052:	593a      	mov	dp:0x3a <_g_u16MicroStepIdx>, Y
			}
		}
	}

	/* Check for speed update required */
	if ( g_u16CommutTimerPeriod == g_u16TargetCommutTimerPeriod )
    9054:	2e09      	cmp	X, [S-10]
    9056:	1d04      	jne	0x9060 <_EXT0_IT+0xbe>
	{
		g_u8MotorStartupMode = (uint8) MSM_STEPPER_C;
    9058:	6003      	lod	AL, #3
    905a:	42d8 00dd 	mov	0xdd <_g_u8MotorStartupMode>, AL
    905e:	0057      	jmp	0x910e <_EXT0_IT+0x16c>
	}
	else
	{
		/* Update speed */
		uint16 u16Compensation = l_u16SpeedRPM;							/* MMP160606-1 */
    9060:	72d8 0170 	lod	A, 0x170 <_l_u16SpeedRPM>
    9064:	520b      	mov	[S-12], A
		if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )
    9066:	2e09      	cmp	X, [S-10]
    9068:	1c2f      	jnc	0x90c8 <_EXT0_IT+0x126>
		{
			/* Deceleration per micro-step */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_D;					/* Too fast, decelerate */
    906a:	6002      	lod	AL, #2
    906c:	42d8 00dd 	mov	0xdd <_g_u8MotorStartupMode>, AL
    9070:	4cea 0bb8 	movu	YA, #3000
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9074:	7e0b      	lod	X, [S-12]
    9076:	4c63      	divu	YA, X
    9078:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    907a:	2ae2      	sub	X, A
    907c:	5e03      	mov	[S-4], X
    907e:	5ed8 0170 	mov	0x170 <_l_u16SpeedRPM>, X
    9082:	72d8 0172 	lod	A, 0x172 <_l_u32Temp>
    9086:	7ad8 0174 	lod	Y, 0x174 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    908a:	4c63      	divu	YA, X
    908c:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    908e:	7ae2      	lod	Y, A
    9090:	e0ff      	add	Y, #-1
    9092:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM - divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1u;	/* MMP160606-1 */
			l_u8VTIdx--;
    9094:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    9096:	80ff      	add	AL, #-1
    9098:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
			if ( g_u16StartupDelay < l_u8VTIdx )
    909a:	5cf2      	usex	A
    909c:	ad20      	cmp	A, dp:0x20 <_g_u16StartupDelay>
    909e:	1a03      	jule	0x90a6 <_EXT0_IT+0x104>
			{
				g_u16StartupDelay = l_u16StartupDelayInit;						/* MMP130627-1/MMP140331-2: Speed reduction, stall detection post-poned */
    90a0:	72d8 00da 	lod	A, 0xda <_l_u16StartupDelayInit>
    90a4:	5120      	mov	dp:0x20 <_g_u16StartupDelay>, A
			}
			if ( g_u16CommutTimerPeriod > g_u16TargetCommutTimerPeriod )
    90a6:	ee09      	cmp	Y, [S-10]
    90a8:	1a02      	jule	0x90ae <_EXT0_IT+0x10c>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    90aa:	7a09      	lod	Y, [S-10]
    90ac:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    90ae:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    90b0:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    90b2:	72d8 017e 	lod	A, 0x17e <_g_u16PidCtrlRatio>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    90b6:	7a03      	lod	Y, [S-4]
    90b8:	7e0b      	lod	X, [S-12]
    90ba:	4821      	mulu	YA, A, Y
    90bc:	4c63      	divu	YA, X
    90be:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    90c0:	52d8 017e 	mov	0x17e <_g_u16PidCtrlRatio>, A
#if (_SUPPORT_PWM_DC_RAMPDOWN != FALSE)											/* MMP140903-2 - Begin */
			g_u16PidCtrlRatio = muldivU16_U16byU16byU16( g_u16PidCtrlRatio, l_u16SpeedRPM, u16Compensation);	/* MMP160606-2 */
			g_u16PID_I = g_u16PidCtrlRatio;
    90c4:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
    90c6:	0023      	jmp	0x910e <_EXT0_IT+0x16c>
#endif /* (_SUPPORT_PWM_DC_RAMPDOWN != FALSE) */								/* MMP140903-2 - Begin */

		}
		else if ( (g_u16MicroStepIdx == 0u) || ((g_u16MicroStepIdx > NVRAM_ACCELERATION_POINTS) && ((g_u16MicroStepIdx & NVRAM_ACCELERATION_POINTS) == 0u)) )
    90c8:	713a      	lod	A, dp:0x3a <_g_u16MicroStepIdx>
    90ca:	1904      	je	0x90d4 <_EXT0_IT+0x132>
    90cc:	ac01      	cmp	A, #1
    90ce:	1a1f      	jule	0x910e <_EXT0_IT+0x16c>
    90d0:	b401      	and	A, #1
    90d2:	1d1d      	jne	0x910e <_EXT0_IT+0x16c>
		{
			/* Acceleration per acceleration_points ((multiple) full-step) */
			g_u8MotorStartupMode = (uint8) MSM_STEPPER_A;						/* Too slow, accelerate */
    90d4:	6001      	lod	AL, #1
    90d6:	42d8 00dd 	mov	0xdd <_g_u8MotorStartupMode>, AL
    90da:	4cea 0bb8 	movu	YA, #3000
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    90de:	7e0b      	lod	X, [S-12]
    90e0:	4c63      	divu	YA, X
    90e2:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    90e4:	22e2      	add	X, A
    90e6:	5ed8 0170 	mov	0x170 <_l_u16SpeedRPM>, X
    90ea:	72d8 0172 	lod	A, 0x172 <_l_u32Temp>
    90ee:	7ad8 0174 	lod	Y, 0x174 <_l_u32Temp+0x2>
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    90f2:	4c63      	divu	YA, X
    90f4:	4c63      	divu	YA, X
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    90f6:	7ae2      	lod	Y, A
    90f8:	e0ff      	add	Y, #-1
    90fa:	593c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, Y
			l_u16SpeedRPM = l_u16SpeedRPM + divU16_U32byU16( (uint32) 2*NVRAM_ACCELERATION_CONST, l_u16SpeedRPM);	/* MMP160606-1 */
			g_u16CommutTimerPeriod = divU16_U32byU16( l_u32Temp, l_u16SpeedRPM) - 1u;	/* MMP160606-1 */
			l_u8VTIdx++;
    90fc:	6122      	lod	AL, dp:0x22 <_l_u8VTIdx>
    90fe:	8001      	add	AL, #1
    9100:	4122      	mov	dp:0x22 <_l_u8VTIdx>, AL
			if ( g_u16CommutTimerPeriod < g_u16TargetCommutTimerPeriod )		/* MMP150923-1 */
    9102:	ee09      	cmp	Y, [S-10]
    9104:	1c02      	jnc	0x910a <_EXT0_IT+0x168>
			{
				g_u16CommutTimerPeriod = g_u16TargetCommutTimerPeriod;
    9106:	7209      	lod	A, [S-10]
    9108:	513c      	mov	dp:0x3c <_g_u16CommutTimerPeriod>, A
			}
			TMR1_REGB = g_u16CommutTimerPeriod;
    910a:	713c      	lod	A, dp:0x3c <_g_u16CommutTimerPeriod>
    910c:	52ac      	mov	io:0x2c <__data_dp_end+0x4>, A
		{
			/* MISRA C:2012 Rule-15.7:All if ... else if constructs shall be terminated with an else statement */
		}
	}

	VoltageCorrection();
    910e:	12f1      	call	0x96f2 <_VoltageCorrection>

	MotorDriver_4PhaseStepper();
    9110:	82db 88cc 	callf	0x88cc <_MotorDriver_4PhaseStepper>
		MotorDriverStop( (uint16) C_STOP_EMERGENCY);							/* ... stop motor (Stall) */
	}
#endif /* _SUPPORT_STALLDET_O */
#if _SUPPORT_STALLDET_H
	/* Stall detection based on hall-sensor(s) */
	if ( MotorStallCheckH() != (uint16) C_STALL_NOT_FOUND )						/* Stall-detector "H" */
    9114:	1029      	call	0x9168 <_MotorStallCheckH>
    9116:	ac00      	cmp	A, #0
    9118:	1910      	je	0x913a <_EXT0_IT+0x198>
	{
		g_sMotorFault.ST |= (uint16)C_STALL_FOUND_H;
    911a:	711c      	lod	A, dp:0x1c <_g_sMotorFault>
    911c:	44b2      	lsr	A, #2
    911e:	44b2      	lsr	A, #2
    9120:	44b2      	lsr	A, #2
    9122:	b40f      	and	A, #15
    9124:	a404      	or	A, #4
    9126:	44a2      	asl	A, #2
    9128:	44a2      	asl	A, #2
    912a:	44a2      	asl	A, #2
    912c:	791c      	lod	Y, dp:0x1c <_g_sMotorFault>
    912e:	f6da fc3f 	and	Y, #64575
    9132:	e6e2      	or	Y, A
    9134:	591c      	mov	dp:0x1c <_g_sMotorFault>, Y
		MotorDriverStop( (uint16) C_STOP_EMERGENCY);							/* ... stop motor (Stall) */
    9136:	7003      	lod	A, #3
    9138:	15a4      	call	0x8c82 <_MotorDriverStop>
    913a:	5c0b      	dec	S, #12
    913c:	4cc3      	pop	D
    913e:	7acf      	pop	Y
    9140:	7ecf      	pop	X
    9142:	72cf      	pop	A
    9144:	4407      	mov	R, #0
    9146:	72cb      	pop	M
    9148:	5401      	ret

0000914a <_MotorStallInitH>:
 *
 * Initialise Stall detector "H"
 * ****************************************************************************	*/
void MotorStallInitH( void)
{
	g_u8StallTypeComm = (uint8) C_STALL_NOT_FOUND;								/* Used for communication */
    914a:	6000      	lod	AL, #0
    914c:	4124      	mov	dp:0x24 <_g_u8StallTypeComm>, AL
	l_u8StallCountH = 0u;
    914e:	42d8 00df 	mov	0xdf <_l_u8StallCountH>, AL
	l_u8StallCountReboundH = 0u;
    9152:	42d8 00de 	mov	0xde <_l_u8StallCountReboundH>, AL
	g_u16HallMicroStepIdx = g_u16ActuatorActPos;
    9156:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    9158:	52d8 00ce 	mov	0xce <_g_u16HallMicroStepIdx>, A
	l_u16HallMicroStepIdxPre = g_u16HallMicroStepIdx;
    915c:	52d8 017c 	mov	0x17c <_l_u16HallMicroStepIdxPre>, A
	/* Use NVRAM_STALL_CURR_THRSHLD as threshold offset */
	/* Stepper-mode: Hall-sensor switches every 180 degrees of a electric-rotation;
	 * Set threshold at 270 degrees (75% of a full electric rotation) */
	/* l_u16HallMicroStepThrshld = muldivU16_U16byU16byU16( g_u16MotorMicroStepsPerElecRotation, 12, 4);  */ 
	/* MMP130819-3 */
	l_u16HallMicroStepThrshld = C_MOTOR_HALL_STALLDET_STEP;	/* 24 full steps equals 360 degrees */
    9160:	7060      	lod	A, #96
    9162:	52d8 017a 	mov	0x17a <_l_u16HallMicroStepThrshld>, A
    9166:	5401      	ret

00009168 <_MotorStallCheckH>:
 *					 C_STALL_FOUND: Stall have been found
 *
 *
 * ****************************************************************************	*/
uint16 MotorStallCheckH( void)
{
    9168:	5801      	inc	S, #2
	if ( g_u16StartupDelay == 0u )
    916a:	7120      	lod	A, dp:0x20 <_g_u16StartupDelay>
    916c:	1901      	je	0x9170 <_MotorStallCheckH+0x8>
    916e:	004e      	jmp	0x920c <_MotorStallCheckH+0xa4>
	{
		/* stuck stall */
		uint16 u16DeltaPosition;

		if(g_u16ActuatorActPos > l_u16HallMicroStepIdxPre)
    9170:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    9172:	7ad8 017c 	lod	Y, 0x17c <_l_u16HallMicroStepIdxPre>
    9176:	aee6      	cmp	A, Y
    9178:	1a04      	jule	0x9182 <_MotorStallCheckH+0x1a>
		{
			u16DeltaPosition = g_u16ActuatorActPos - l_u16HallMicroStepIdxPre;
    917a:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    917c:	aae6      	sub	A, Y
    917e:	7ae2      	lod	Y, A
    9180:	0002      	jmp	0x9186 <_MotorStallCheckH+0x1e>
		}
		else
		{
			u16DeltaPosition = l_u16HallMicroStepIdxPre - g_u16ActuatorActPos;
    9182:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    9184:	eae2      	sub	Y, A
    9186:	62d8 00df 	lod	AL, 0xdf <_l_u8StallCountH>
    918a:	4200      	mov	[S-1], AL
		}
		if(u16DeltaPosition > l_u16HallMicroStepThrshld)
    918c:	eed8 017a 	cmp	Y, 0x17a <_l_u16HallMicroStepThrshld>
    9190:	1a0b      	jule	0x91a8 <_MotorStallCheckH+0x40>
		{
			g_u16falg += 5;
    9192:	72d8 00d4 	lod	A, 0xd4 <_g_u16falg>
    9196:	a005      	add	A, #5
    9198:	52d8 00d4 	mov	0xd4 <_g_u16falg>, A
			l_u8StallCountH++;
    919c:	6200      	lod	AL, [S-1]
    919e:	8001      	add	AL, #1
    91a0:	42d8 00df 	mov	0xdf <_l_u8StallCountH>, AL
			if ( l_u8StallCountH >= 1u )
    91a4:	1906      	je	0x91b2 <_MotorStallCheckH+0x4a>
    91a6:	002a      	jmp	0x91fc <_MotorStallCheckH+0x94>
				return ( C_STALL_FOUND );
			}
		}
		else
		{
			if ( l_u8StallCountH > 0u)
    91a8:	6200      	lod	AL, [S-1]
    91aa:	1903      	je	0x91b2 <_MotorStallCheckH+0x4a>
			{
				l_u8StallCountH--;
    91ac:	80ff      	add	AL, #-1
    91ae:	42d8 00df 	mov	0xdf <_l_u8StallCountH>, AL
			}
		}
		/* rebounding stall:new hall edge captured  */
		if(l_u16HallMicroStepIdxPre != g_u16HallMicroStepIdx)
    91b2:	7ad8 017c 	lod	Y, 0x17c <_l_u16HallMicroStepIdxPre>
    91b6:	72d8 00ce 	lod	A, 0xce <_g_u16HallMicroStepIdx>
    91ba:	eee2      	cmp	Y, A
    91bc:	192c      	je	0x9216 <_MotorStallCheckH+0xae>
		{
			if(g_u16HallMicroStepIdx > l_u16HallMicroStepIdxPre)
    91be:	aee6      	cmp	A, Y
    91c0:	1a03      	jule	0x91c8 <_MotorStallCheckH+0x60>
			{
				u16DeltaPosition = g_u16HallMicroStepIdx - l_u16HallMicroStepIdxPre;
    91c2:	aae6      	sub	A, Y
    91c4:	7ae2      	lod	Y, A
    91c6:	0001      	jmp	0x91ca <_MotorStallCheckH+0x62>
			}
			else
			{
				u16DeltaPosition = l_u16HallMicroStepIdxPre - g_u16HallMicroStepIdx;
    91c8:	eae2      	sub	Y, A
			}
			/* Normal 6 full steps for one hall signal. */
			if((u16DeltaPosition <= ((uint16)10)) || (u16DeltaPosition >= ((uint16)22)))
    91ca:	72e6      	lod	A, Y
    91cc:	a0f5      	add	A, #-11
    91ce:	ac0a      	cmp	A, #10
    91d0:	1a1a      	jule	0x9206 <_MotorStallCheckH+0x9e>
			{
				g_u16falg += 1;
    91d2:	72d8 00d4 	lod	A, 0xd4 <_g_u16falg>
    91d6:	a001      	add	A, #1
    91d8:	52d8 00d4 	mov	0xd4 <_g_u16falg>, A
				l_u8StallCountReboundH++;
    91dc:	62d8 00de 	lod	AL, 0xde <_l_u8StallCountReboundH>
    91e0:	8001      	add	AL, #1
    91e2:	4201      	mov	[S-2], AL
    91e4:	42d8 00de 	mov	0xde <_l_u8StallCountReboundH>, AL
				if(g_u8ValveInitState == 2)
    91e8:	62d8 00d6 	lod	AL, 0xd6 <_g_u8ValveInitState>
    91ec:	8c02      	cmp	AL, #2
    91ee:	1d08      	jne	0x9200 <_MotorStallCheckH+0x98>
				{
					if ( l_u8StallCountReboundH >= 15u )
    91f0:	6201      	lod	AL, [S-2]
    91f2:	8c0e      	cmp	AL, #14
    91f4:	1a08      	jule	0x9206 <_MotorStallCheckH+0x9e>
					{
						l_u8StallCountReboundH = 0u;
    91f6:	6000      	lod	AL, #0
    91f8:	42d8 00de 	mov	0xde <_l_u8StallCountReboundH>, AL
						return ( C_STALL_FOUND );
    91fc:	7001      	lod	A, #1
    91fe:	5403      	ret	#4
//						l_u8StallCountReboundH--;
//					}
				}
				else
				{
					if ( l_u8StallCountReboundH >= 5u )
    9200:	6201      	lod	AL, [S-2]
    9202:	8c04      	cmp	AL, #4
    9204:	1e78      	jug	0x91f6 <_MotorStallCheckH+0x8e>
			else if(l_u8StallCountReboundH)
			{
				l_u8StallCountReboundH--;
			}
			*/
			l_u16HallMicroStepIdxPre = g_u16HallMicroStepIdx;
    9206:	72d8 00ce 	lod	A, 0xce <_g_u16HallMicroStepIdx>
    920a:	0003      	jmp	0x9212 <_MotorStallCheckH+0xaa>
		}
	}
	else
	{
		/* During start-up delay, follow each micro-step */
		g_u16HallMicroStepIdx = g_u16ActuatorActPos;
    920c:	7146      	lod	A, dp:0x46 <_g_u16ActuatorActPos>
    920e:	52d8 00ce 	mov	0xce <_g_u16HallMicroStepIdx>, A
		l_u16HallMicroStepIdxPre = g_u16HallMicroStepIdx;
    9212:	52d8 017c 	mov	0x17c <_l_u16HallMicroStepIdxPre>, A
	}
	return ( C_STALL_NOT_FOUND );
    9216:	7000      	lod	A, #0
} /* End of MotorStallCheckH() */
    9218:	5403      	ret	#4

0000921a <_NVRAM_CRC8>:
	NVRAM_SavePage( NVRAM1_PAGE2);
} /* End of NVRAM_StorePatch() */


uint8 NVRAM_CRC8( const uint16 *pRAM, uint16 size)
{
    921a:	7ae2      	lod	Y, A
    921c:	7e03      	lod	X, [S-4]
    921e:	7000      	lod	A, #0
    9220:	08a7      	clrb	ML.7
    9222:	b2d6      	adc	A, [Y++]
    9224:	1bfe      	djnz	X, 0x9222 <_NVRAM_CRC8+0x8>
    9226:	92e4      	adc	AL, AH
    9228:	9000      	adc	AL, #0
    922a:	5cf2      	usex	A
	uint16 u16CRC;

	u16CRC = nvram_CalcCRC(pRAM, size);	/* MMP151202-1 */

	return ( (uint8) u16CRC );
    922c:	5cf2      	usex	A
} /* End of NVRAM_CRC8() */
    922e:	5401      	ret

00009230 <_NVRAM_Init>:
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode);


/***********************public functions ***************************/
void NVRAM_Init(void)
{
    9230:	5801      	inc	S, #2
	uint16 i;
	uint16 u16ErrorFlag; 
	uint8  u8CRC;
	
	/* dump to memory */
	NVRAM_LoadAll();
    9232:	82db 598e 	callf	0x598e <_NVRAM_LoadAll>
	u16ErrorFlag = (VARIOUS_L & EENV_DED);										/* Double-bit error state */
    9236:	6280      	lod	AL, io:0x0 <__dp__>
	/* Check Double-bit NVRAM set, User-NVRAM structure-revision and User-NVRAM Checksum */
	/* 1.check user page 1,if fail use default */
	pMRAM = (uint16 *)C_ADDR_USERPAGE1;
    9238:	7ada 1000 	lod	Y, #4096
    923c:	5a01      	mov	[S-2], Y
	pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
	u8CRC = (uint8)NVRAM_CRC8(pMRAM,C_SIZE_USERPAGE1 / 2u);
    923e:	54ca 0040 	pushw	#64
    9242:	72da 1000 	lod	A, #4096
    9246:	17e9      	call	0x921a <_NVRAM_CRC8>
    9248:	66e0      	lod	YL, AL
    924a:	5cf6      	usex	Y
	if(((uint8)pIntegrity->CRC8_Revision != C_NVRAM_USER_REV) || (u8CRC != 0xFFu))
    924c:	7e03      	lod	X, [S-4]
    924e:	72f8      	lod	A, [X]
    9250:	5c01      	dec	S, #2
    9252:	8c02      	cmp	AL, #2
    9254:	1d03      	jne	0x925c <_NVRAM_Init+0x2c>
    9256:	62e8      	lod	AL, YL
    9258:	8cff      	cmp	AL, #-1
    925a:	190b      	je	0x9272 <_NVRAM_Init+0x42>
	{
		/* UniROM */
		pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;		/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    925c:	7c02      	lod	X, #2
    925e:	7a01      	lod	Y, [S-2]
    9260:	5ef0      	mov	[Y], X
		pIntegrity->ProgramCount = 0u;
    9262:	7000      	lod	A, #0
    9264:	52f2      	mov	[Y+2], A
    9266:	7ada 1000 	lod	Y, #4096
    926a:	7c40      	lod	X, #64

		/* nvram may be corrupted,filled with default  */
		for(i = 0;i < (C_SIZE_USERPAGE2 / 2u);i++)
		{
			pMRAM[i] = 0xFFFFu;
    926c:	70ff      	lod	A, #-1
    926e:	52d6      	mov	[Y++], A
    9270:	1bfd      	djnz	X, 0x926c <_NVRAM_Init+0x3c>
		}
	}
	/* 2.check user page 2:if fail padding with 0xFF */
	pMRAM = (uint16 *)C_ADDR_USERPAGE2;
    9272:	7ada 1100 	lod	Y, #4352
    9276:	5a01      	mov	[S-2], Y
	pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
	u8CRC = NVRAM_CRC8(pMRAM,C_SIZE_USERPAGE2 / 2u);
    9278:	54ca 0040 	pushw	#64
    927c:	72da 1100 	lod	A, #4352
    9280:	17cc      	call	0x921a <_NVRAM_CRC8>
    9282:	66e0      	lod	YL, AL
    9284:	5cf6      	usex	Y
	if(((uint8)pIntegrity->CRC8_Revision != C_NVRAM_USER_REV) || (u8CRC != 0xFFu))
    9286:	7e03      	lod	X, [S-4]
    9288:	72f8      	lod	A, [X]
    928a:	5c01      	dec	S, #2
    928c:	8c02      	cmp	AL, #2
    928e:	1d03      	jne	0x9296 <_NVRAM_Init+0x66>
    9290:	62e8      	lod	AL, YL
    9292:	8cff      	cmp	AL, #-1
    9294:	190b      	je	0x92ac <_NVRAM_Init+0x7c>
	{
		/* UniROM */
		pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;		/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    9296:	7c02      	lod	X, #2
    9298:	7a01      	lod	Y, [S-2]
    929a:	5ef0      	mov	[Y], X
		pIntegrity->ProgramCount = 0u;
    929c:	7000      	lod	A, #0
    929e:	52f2      	mov	[Y+2], A
    92a0:	7ada 1100 	lod	Y, #4352
    92a4:	7c40      	lod	X, #64
		
		/* nvram may be corrupted,filled with padding  */
		for(i = 0;i < (C_SIZE_USERPAGE2 / 2u);i++)
		{
			pMRAM[i] = 0xFFFFu;
    92a6:	70ff      	lod	A, #-1
    92a8:	52d6      	mov	[Y++], A
    92aa:	1bfd      	djnz	X, 0x92a6 <_NVRAM_Init+0x76>
    92ac:	5403      	ret	#4

000092ae <_NVRAM_Read>:

}


uint8 NVRAM_Read(uint16 addr,uint16 buf[],uint16 size)
{
    92ae:	5809      	inc	S, #10
    92b0:	7ae2      	lod	Y, A
    92b2:	720d      	lod	A, [S-14]
    92b4:	5209      	mov	[S-10], A
    92b6:	720f      	lod	A, [S-16]
    92b8:	5207      	mov	[S-8], A
	uint16 *pMRAM;
	uint16 i;
	uint8 ret = NVRAM_E_OK;
    92ba:	7000      	lod	A, #0
    92bc:	5201      	mov	[S-2], A
	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE) ))
    92be:	eeda 0fff 	cmp	Y, #4095
    92c2:	1a1a      	jule	0x92f8 <_NVRAM_Read+0x4a>
    92c4:	7207      	lod	A, [S-8]
    92c6:	a2e6      	add	A, Y
    92c8:	aeda 103d 	cmp	A, #4157
    92cc:	1e15      	jug	0x92f8 <_NVRAM_Read+0x4a>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA1_ADDR;
    92ce:	72e6      	lod	A, Y
    92d0:	487a 0002 	muls	Y, A, #2
    92d4:	e2da f004 	add	Y, #61444
    92d8:	5a05      	mov	[S-6], Y
		for(i = 0;i < size;i++)
    92da:	7000      	lod	A, #0
    92dc:	5203      	mov	[S-4], A
    92de:	ae07      	cmp	A, [S-8]
    92e0:	1c2a      	jnc	0x9336 <_NVRAM_Read+0x88>
		{
			buf[i] = pMRAM[i];
    92e2:	7203      	lod	A, [S-4]
    92e4:	487a 0002 	muls	Y, A, #2
    92e8:	7e09      	lod	X, [S-10]
    92ea:	22e6      	add	X, Y
    92ec:	e205      	add	Y, [S-6]
    92ee:	72f0      	lod	A, [Y]
    92f0:	52f8      	mov	[X], A
	uint8 ret = NVRAM_E_OK;
	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE) ))
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA1_ADDR;
		for(i = 0;i < size;i++)
    92f2:	7203      	lod	A, [S-4]
    92f4:	a001      	add	A, #1
    92f6:	07f2      	jmp	0x92dc <_NVRAM_Read+0x2e>
		{
			buf[i] = pMRAM[i];
		}
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
    92f8:	eeda 103d 	cmp	Y, #4157
    92fc:	1a1a      	jule	0x9332 <_NVRAM_Read+0x84>
    92fe:	7207      	lod	A, [S-8]
    9300:	a2e6      	add	A, Y
    9302:	aeda 107b 	cmp	A, #4219
    9306:	1e15      	jug	0x9332 <_NVRAM_Read+0x84>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA2_ADDR;
    9308:	72e6      	lod	A, Y
    930a:	487a 0002 	muls	Y, A, #2
    930e:	e2da f088 	add	Y, #61576
    9312:	5a05      	mov	[S-6], Y
		for(i = 0;i < size;i++)
    9314:	7000      	lod	A, #0
    9316:	5203      	mov	[S-4], A
    9318:	ae07      	cmp	A, [S-8]
    931a:	1c0d      	jnc	0x9336 <_NVRAM_Read+0x88>
		{
			buf[i] = pMRAM[i];
    931c:	7203      	lod	A, [S-4]
    931e:	487a 0002 	muls	Y, A, #2
    9322:	7e09      	lod	X, [S-10]
    9324:	22e6      	add	X, Y
    9326:	e205      	add	Y, [S-6]
    9328:	72f0      	lod	A, [Y]
    932a:	52f8      	mov	[X], A
		}
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY)/sizeof(uint16) + addr - C_NVRAM_AREA2_ADDR;
		for(i = 0;i < size;i++)
    932c:	7203      	lod	A, [S-4]
    932e:	a001      	add	A, #1
    9330:	07f2      	jmp	0x9316 <_NVRAM_Read+0x68>
			buf[i] = pMRAM[i];
		}
	}
	else
	{
		ret = NVRAM_E_INVALID_DATA;
    9332:	7001      	lod	A, #1
    9334:	5201      	mov	[S-2], A
	}

	return ret;
}
    9336:	7201      	lod	A, [S-2]
    9338:	540b      	ret	#12

0000933a <_NVRAM_Write>:


uint8 NVRAM_Write(uint16 addr,const uint16 buf[],uint16 size)
{
    933a:	5813      	inc	S, #20
    933c:	7ae2      	lod	Y, A
    933e:	7217      	lod	A, [S-24]
    9340:	5213      	mov	[S-20], A
    9342:	7219      	lod	A, [S-26]
    9344:	5211      	mov	[S-18], A
	uint16  *pMRAM;
	uint8  u8VerifyRes,u8CRC8;
	PNVRAM_PAGEINTEGRITY pIntegrity;
	uint16  i;
	uint8  ret = NVRAM_E_OK;
    9346:	7000      	lod	A, #0
    9348:	5209      	mov	[S-10], A

	/* address should be even */	
	if((addr >= C_NVRAM_AREA1_ADDR) && ((addr + size) < (C_NVRAM_AREA1_ADDR + C_NVRAM_AREA1_SIZE)))
    934a:	eeda 0fff 	cmp	Y, #4095
    934e:	1e01      	jug	0x9352 <_NVRAM_Write+0x18>
    9350:	004b      	jmp	0x93e8 <_NVRAM_Write+0xae>
    9352:	7211      	lod	A, [S-18]
    9354:	a2e6      	add	A, Y
    9356:	aeda 103d 	cmp	A, #4157
    935a:	1a01      	jule	0x935e <_NVRAM_Write+0x24>
    935c:	0045      	jmp	0x93e8 <_NVRAM_Write+0xae>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA1_ADDR);
    935e:	72e6      	lod	A, Y
    9360:	487a 0002 	muls	Y, A, #2
    9364:	e2da f004 	add	Y, #61444
    9368:	5a0f      	mov	[S-16], Y

		/* copy with verifing */
		u8VerifyRes = 0u;
    936a:	7800      	lod	Y, #0
    936c:	5a0d      	mov	[S-14], Y
		for(i = 0;i < size;i++)
    936e:	7c00      	lod	X, #0
    9370:	7000      	lod	A, #0
    9372:	ae11      	cmp	A, [S-18]
    9374:	1801      	jc	0x9378 <_NVRAM_Write+0x3e>
    9376:	008a      	jmp	0x948c <_NVRAM_Write+0x152>
		{
			if(buf[i] != pMRAM[i])
    9378:	72ee      	lod	A, X
    937a:	4422      	asl	A
    937c:	7a13      	lod	Y, [S-20]
    937e:	e2e2      	add	Y, A
    9380:	5a01      	mov	[S-2], Y
    9382:	7a0f      	lod	Y, [S-16]
    9384:	e2e2      	add	Y, A
    9386:	5a07      	mov	[S-8], Y
    9388:	7a01      	lod	Y, [S-2]
    938a:	72f0      	lod	A, [Y]
    938c:	7a07      	lod	Y, [S-8]
    938e:	aef0      	cmp	A, [Y]
    9390:	1904      	je	0x939a <_NVRAM_Write+0x60>
			{
				u8VerifyRes = 1u;
    9392:	7801      	lod	Y, #1
    9394:	5a0d      	mov	[S-14], Y
				pMRAM[i] = buf[i];
    9396:	7a07      	lod	Y, [S-8]
    9398:	52f0      	mov	[Y], A
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE1 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA1_ADDR);

		/* copy with verifing */
		u8VerifyRes = 0u;
		for(i = 0;i < size;i++)
    939a:	2001      	add	X, #1
    939c:	2e11      	cmp	X, [S-18]
    939e:	186c      	jc	0x9378 <_NVRAM_Write+0x3e>
				pMRAM[i] = buf[i];
			}
		}

		/* page verify result need saving  */
		if(u8VerifyRes == 1u)
    93a0:	620d      	lod	AL, [S-14]
    93a2:	8c01      	cmp	AL, #1
    93a4:	1901      	je	0x93a8 <_NVRAM_Write+0x6e>
    93a6:	0072      	jmp	0x948c <_NVRAM_Write+0x152>
		{
			/* program count and nvram user version */
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
    93a8:	7ada 1000 	lod	Y, #4096
    93ac:	5a0b      	mov	[S-12], Y
			pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;					/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    93ae:	7c02      	lod	X, #2
    93b0:	5ef0      	mov	[Y], X
			pIntegrity->ProgramCount++;
    93b2:	72f2      	lod	A, [Y+2]
    93b4:	a001      	add	A, #1
    93b6:	52f2      	mov	[Y+2], A
			if(pIntegrity->ProgramCount >= C_MAX_NVRAM_PROGRAM_COUNT)
    93b8:	aeda fde7 	cmp	A, #64999
    93bc:	1a03      	jule	0x93c4 <_NVRAM_Write+0x8a>
			{
				pIntegrity->ProgramCount = C_MAX_NVRAM_PROGRAM_COUNT;
    93be:	72da fde8 	lod	A, #65000
    93c2:	52f2      	mov	[Y+2], A
			}
			
			/* page intergrity */
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE1, C_SIZE_USERPAGE1 / 2u);	/* MMP151202-1 */
    93c4:	54ca 0040 	pushw	#64
    93c8:	72da 1000 	lod	A, #4096
    93cc:	1726      	call	0x921a <_NVRAM_CRC8>
    93ce:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    93d0:	60ff      	lod	AL, #-1
    93d2:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    93d4:	7e0d      	lod	X, [S-14]
    93d6:	7af8      	lod	Y, [X]
    93d8:	f6da 00ff 	and	Y, #255
    93dc:	6800      	lod	AH, #0
    93de:	72e4      	swap	A
    93e0:	e6e2      	or	Y, A
    93e2:	5af8      	mov	[X], Y
			
			NVRAM_SavePage( NVRAM1_PAGE1);
    93e4:	7000      	lod	A, #0
    93e6:	004c      	jmp	0x9480 <_NVRAM_Write+0x146>
		}
		
	}
	else if((addr >= C_NVRAM_AREA2_ADDR) && ((addr + size) < (C_NVRAM_AREA2_ADDR + C_NVRAM_AREA2_SIZE)))
    93e8:	eeda 103d 	cmp	Y, #4157
    93ec:	1e01      	jug	0x93f0 <_NVRAM_Write+0xb6>
    93ee:	004c      	jmp	0x9488 <_NVRAM_Write+0x14e>
    93f0:	7211      	lod	A, [S-18]
    93f2:	a2e6      	add	A, Y
    93f4:	aeda 107b 	cmp	A, #4219
    93f8:	1a01      	jule	0x93fc <_NVRAM_Write+0xc2>
    93fa:	0046      	jmp	0x9488 <_NVRAM_Write+0x14e>
	{
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA2_ADDR);
    93fc:	72e6      	lod	A, Y
    93fe:	487a 0002 	muls	Y, A, #2
    9402:	e2da f088 	add	Y, #61576
    9406:	5a0f      	mov	[S-16], Y

		/* copy and verify */
		u8VerifyRes = 0u;
    9408:	7800      	lod	Y, #0
    940a:	5a0d      	mov	[S-14], Y

		for(i = 0;i < size;i++)
    940c:	7c00      	lod	X, #0
    940e:	ee11      	cmp	Y, [S-18]
    9410:	1801      	jc	0x9414 <_NVRAM_Write+0xda>
    9412:	003c      	jmp	0x948c <_NVRAM_Write+0x152>
		{
			if(buf[i] != pMRAM[i])
    9414:	72ee      	lod	A, X
    9416:	4422      	asl	A
    9418:	7a13      	lod	Y, [S-20]
    941a:	e2e2      	add	Y, A
    941c:	5a01      	mov	[S-2], Y
    941e:	7a0f      	lod	Y, [S-16]
    9420:	e2e2      	add	Y, A
    9422:	5a05      	mov	[S-6], Y
    9424:	7a01      	lod	Y, [S-2]
    9426:	72f0      	lod	A, [Y]
    9428:	7a05      	lod	Y, [S-6]
    942a:	aef0      	cmp	A, [Y]
    942c:	1904      	je	0x9436 <_NVRAM_Write+0xfc>
			{
				u8VerifyRes = 1u;
    942e:	7801      	lod	Y, #1
    9430:	5a0d      	mov	[S-14], Y
				pMRAM[i] = buf[i];
    9432:	7a05      	lod	Y, [S-6]
    9434:	52f0      	mov	[Y], A
		pMRAM = (uint16 *)C_ADDR_USERPAGE2 + sizeof(NVRAM_PAGEINTEGRITY) / sizeof(uint16) + (addr - C_NVRAM_AREA2_ADDR);

		/* copy and verify */
		u8VerifyRes = 0u;

		for(i = 0;i < size;i++)
    9436:	2001      	add	X, #1
    9438:	2e11      	cmp	X, [S-18]
    943a:	186c      	jc	0x9414 <_NVRAM_Write+0xda>
				pMRAM[i] = buf[i];
			}
		}

		/* page verify result need saving,then start save process  */
		if(u8VerifyRes == 1u)
    943c:	620d      	lod	AL, [S-14]
    943e:	8c01      	cmp	AL, #1
    9440:	1d25      	jne	0x948c <_NVRAM_Write+0x152>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
    9442:	7ada 1100 	lod	Y, #4352
    9446:	5a0b      	mov	[S-12], Y
			pIntegrity->CRC8_Revision = C_NVRAM_USER_REV;					/* CRC8=0x00,Revision=C_NVRAM_USER_REV */
    9448:	7c02      	lod	X, #2
    944a:	5ef0      	mov	[Y], X
			pIntegrity->ProgramCount++;
    944c:	72f2      	lod	A, [Y+2]
    944e:	a001      	add	A, #1
    9450:	52f2      	mov	[Y+2], A
			if(pIntegrity->ProgramCount >= C_MAX_NVRAM_PROGRAM_COUNT)
    9452:	aeda fde7 	cmp	A, #64999
    9456:	1a03      	jule	0x945e <_NVRAM_Write+0x124>
			{
				pIntegrity->ProgramCount = C_MAX_NVRAM_PROGRAM_COUNT;
    9458:	72da fde8 	lod	A, #65000
    945c:	52f2      	mov	[Y+2], A
			}
			/* page intergrity */
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE2, C_SIZE_USERPAGE2 / 2u);	/* MMP151202-1 */
    945e:	54ca 0040 	pushw	#64
    9462:	72da 1100 	lod	A, #4352
    9466:	16d9      	call	0x921a <_NVRAM_CRC8>
    9468:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    946a:	60ff      	lod	AL, #-1
    946c:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    946e:	7e0d      	lod	X, [S-14]
    9470:	7af8      	lod	Y, [X]
    9472:	f6da 00ff 	and	Y, #255
    9476:	6800      	lod	AH, #0
    9478:	72e4      	swap	A
    947a:	e6e2      	or	Y, A
    947c:	5af8      	mov	[X], Y
			
			NVRAM_SavePage( NVRAM2_PAGE1);
    947e:	7002      	lod	A, #2
    9480:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    9484:	5c01      	dec	S, #2
    9486:	0002      	jmp	0x948c <_NVRAM_Write+0x152>
		}
	}
	else
	{
		ret = NVRAM_E_INVALID_DATA;
    9488:	7001      	lod	A, #1
    948a:	5209      	mov	[S-10], A
	}

	return ret;
	
}
    948c:	7209      	lod	A, [S-10]
    948e:	5415      	ret	#22

00009490 <_NVRAM_Store>:

/* LIN diagnostic compatiable interface:for system configuration page */
uint16 NVRAM_Store( uint16 u16Page)
{
    9490:	5803      	inc	S, #4
    9492:	5203      	mov	[S-4], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;
	uint8 u8CRC8;
	PNVRAM_PAGEINTEGRITY pIntegrity;

	if((u16Page & C_NVRAM_USER_PAGE_1) != 0u)
    9494:	b401      	and	A, #1
    9496:	191a      	je	0x94cc <_NVRAM_Store+0x3c>
	{
		if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0u )
    9498:	6203      	lod	AL, [S-4]
    949a:	8c00      	cmp	AL, #0
    949c:	1a94      	jsl	0x94c6 <_NVRAM_Store+0x36>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE1);
    949e:	7ada 1000 	lod	Y, #4096
    94a2:	5a01      	mov	[S-2], Y
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE1, C_SIZE_USERPAGE1 / 2u);	/* MMP151202-1 */
    94a4:	54ca 0040 	pushw	#64
    94a8:	72da 1000 	lod	A, #4096
    94ac:	16b6      	call	0x921a <_NVRAM_CRC8>
    94ae:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    94b0:	60ff      	lod	AL, #-1
    94b2:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    94b4:	7e03      	lod	X, [S-4]
    94b6:	7af8      	lod	Y, [X]
    94b8:	f6da 00ff 	and	Y, #255
    94bc:	6800      	lod	AH, #0
    94be:	72e4      	swap	A
    94c0:	e6e2      	or	Y, A
    94c2:	5af8      	mov	[X], Y
    94c4:	5c01      	dec	S, #2
			
		}
		NVRAM_SavePage( NVRAM1_PAGE1);
    94c6:	7000      	lod	A, #0
    94c8:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
	}

	if((u16Page & C_NVRAM_USER_PAGE_2) != 0u)
    94cc:	7203      	lod	A, [S-4]
    94ce:	b402      	and	A, #2
    94d0:	191a      	je	0x9506 <_NVRAM_Store+0x76>
	{
		if ( (u16Page & C_MVRAM_USER_PAGE_NoCRC) == 0u )
    94d2:	6203      	lod	AL, [S-4]
    94d4:	8c00      	cmp	AL, #0
    94d6:	1a94      	jsl	0x9500 <_NVRAM_Store+0x70>
		{
			pIntegrity = (PNVRAM_PAGEINTEGRITY)(C_ADDR_USERPAGE2);
    94d8:	7ada 1100 	lod	Y, #4352
    94dc:	5a01      	mov	[S-2], Y
			u8CRC8 = (uint8)NVRAM_CRC8((uint16 *)C_ADDR_USERPAGE2, C_SIZE_USERPAGE2 / 2u);	/* MMP151202-1 */
    94de:	54ca 0040 	pushw	#64
    94e2:	72da 1100 	lod	A, #4352
    94e6:	1699      	call	0x921a <_NVRAM_CRC8>
    94e8:	66e0      	lod	YL, AL
			u8CRC8 = 0xFFu - u8CRC8;
    94ea:	60ff      	lod	AL, #-1
    94ec:	8ae8      	sub	AL, YL
			pIntegrity->CRC8_Revision = (pIntegrity->CRC8_Revision & 0x00FFu) | ((uint16)u8CRC8 << 8u);
    94ee:	7e03      	lod	X, [S-4]
    94f0:	7af8      	lod	Y, [X]
    94f2:	f6da 00ff 	and	Y, #255
    94f6:	6800      	lod	AH, #0
    94f8:	72e4      	swap	A
    94fa:	e6e2      	or	Y, A
    94fc:	5af8      	mov	[X], Y
    94fe:	5c01      	dec	S, #2
		}
		NVRAM_SavePage( NVRAM2_PAGE1);
    9500:	7002      	lod	A, #2
    9502:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
	}

	return u16Result;
}
    9506:	7000      	lod	A, #0
    9508:	5405      	ret	#6

0000950a <_NVRAM_StorePatch>:
 * C_ADDR_PATCHPAGE+0x7A:0x7B:	PATCH3_A
 *
 * ****************************************************************************	*/
void NVRAM_StorePatch( void)
{
	NVRAM_SavePage( NVRAM1_PAGE2);
    950a:	7001      	lod	A, #1
    950c:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    9510:	5401      	ret

00009512 <_NVRAM_CountCRC8>:
 *								TRUE: Calculated CRC8.
 *
 *	Calculate CRC8 on Write-cycle counter.
 * ****************************************************************************	*/
uint8 NVRAM_CountCRC8( PNVRAM_ERRORLOG pNVERRLOG, uint8 byReplaceCRC)
{
    9512:	5807      	inc	S, #8
    9514:	5203      	mov	[S-4], A
    9516:	620b      	lod	AL, [S-12]
    9518:	5cf2      	usex	A
    951a:	5201      	mov	[S-2], A
    951c:	7c01      	lod	X, #1
    951e:	7a03      	lod	Y, [S-4]
    9520:	7000      	lod	A, #0
    9522:	08a7      	clrb	ML.7
    9524:	b2d6      	adc	A, [Y++]
    9526:	1bfe      	djnz	X, 0x9524 <_NVRAM_CountCRC8+0x12>
    9528:	92e4      	adc	AL, AH
    952a:	9000      	adc	AL, #0
    952c:	5cf2      	usex	A
    952e:	5207      	mov	[S-8], A
	uint16 u16CRC = nvram_CalcCRC( (uint16 *) &pNVERRLOG->NvramProgramCycleCount, 1);	/* MMP151202-1 */

	if ( byReplaceCRC != FALSE )
    9530:	7201      	lod	A, [S-2]
    9532:	190c      	je	0x954c <_NVRAM_CountCRC8+0x3a>
	{
		pNVERRLOG->ErrorLogIndex_CRC = (pNVERRLOG->ErrorLogIndex_CRC & 0x00FFu) | ((0xFFu - u16CRC) << 8u);
    9534:	7a03      	lod	Y, [S-4]
    9536:	72f2      	lod	A, [Y+2]
    9538:	b6da 00ff 	and	A, #255
    953c:	7ee2      	lod	X, A
    953e:	72da 00ff 	lod	A, #255
    9542:	aa07      	sub	A, [S-8]
    9544:	6800      	lod	AH, #0
    9546:	72e4      	swap	A
    9548:	26e2      	or	X, A
    954a:	5ef2      	mov	[Y+2], X
	}
	return ( (uint8) ((pNVERRLOG->ErrorLogIndex_CRC >> 8u) ^ u16CRC) );
    954c:	7a03      	lod	Y, [S-4]
    954e:	62f3      	lod	AL, [Y+3]
    9550:	9e07      	xor	AL, [S-8]
    9552:	5cf2      	usex	A
} /* End of NVRAM_CountCRC8() */
    9554:	5409      	ret	#10

00009556 <_PlaceError>:
 *			u8ErrorCode: Error-code
 *	Post:	-
 *	Comments: Write error-code into NVRAM (16-bits words based)
 * ****************************************************************************	*/
void PlaceError( uint16 *pu16ErrorElement, uint16 u16OddEven, uint8 u8ErrorCode)
{
    9556:	5801      	inc	S, #2
    9558:	7ee2      	lod	X, A
    955a:	6207      	lod	AL, [S-8]
    955c:	66e0      	lod	YL, AL
    955e:	5cf6      	usex	Y
    9560:	72f8      	lod	A, [X]
    9562:	5201      	mov	[S-2], A
	if ( u16OddEven != 0u )
    9564:	7205      	lod	A, [S-6]
    9566:	1905      	je	0x9572 <_PlaceError+0x1c>
	{
		/* Odd index: MSB of uint16 */
		*pu16ErrorElement = (uint8)(*pu16ErrorElement) | (((uint16) u8ErrorCode) << 8u);
    9568:	6201      	lod	AL, [S-2]
    956a:	5cf2      	usex	A
    956c:	6c00      	lod	YH, #0
    956e:	7ae8      	swap	Y
    9570:	0003      	jmp	0x9578 <_PlaceError+0x22>
	}
	else
	{
		/* Even index: LSB of uint16 */
		*pu16ErrorElement = (*pu16ErrorElement & 0xFF00u) | ((uint16) u8ErrorCode);
    9572:	7201      	lod	A, [S-2]
    9574:	b6da ff00 	and	A, #65280
    9578:	a6e6      	or	A, Y
    957a:	52f8      	mov	[X], A
    957c:	5403      	ret	#4

0000957e <_NVRAM_LogError>:
 *	result is either 0 or 1, indicating which page should be written next-time.
 * Index at user-page #1/#2: 0-11: Empty/over-write index, FF: Full
 * If index user-page #1 is not 0xFF (Full), write error at page #1, otherwise page #2
 * ****************************************************************************	*/
uint16 NVRAM_LogError( uint8 u8ErrorCode)
{
    957e:	5805      	inc	S, #6
    9580:	5205      	mov	[S-6], A
	uint16 u16Result = C_NVRAM_STORE_OKAY;										/* MMP150219-1 */
    9582:	7000      	lod	A, #0
    9584:	5203      	mov	[S-4], A
	
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
	uint16 u16ErrorLogIdx = (uint8) (pNVERRLOG_UPG->ErrorLogIndex_CRC);
    9586:	7ada 1170 	lod	Y, #4464
    958a:	72f2      	lod	A, [Y+2]
    958c:	5cf2      	usex	A
    958e:	5201      	mov	[S-2], A
	
	
	if ( (u16ErrorLogIdx & 0x80u) == 0x00u )
    9590:	8c00      	cmp	AL, #0
    9592:	1e81      	jsge	0x9596 <_NVRAM_LogError+0x18>
    9594:	003a      	jmp	0x960a <_NVRAM_LogError+0x8c>
	{
		/* Store error on User-Page #1 */										/* MMP150219-1 - Begin */
		if ( u16ErrorLogIdx >= C_MAX_ERRORS_PER_PAGE )						/* Check against array overflow */
    9596:	ac0b      	cmp	A, #11
    9598:	1a02      	jule	0x959e <_NVRAM_LogError+0x20>
		{
			u16ErrorLogIdx = 0u;
    959a:	7000      	lod	A, #0
    959c:	5201      	mov	[S-2], A
		}
		if ( NVRAM_CountCRC8( pNVERRLOG_UPG, FALSE) == 0x00u )
    959e:	54ca 0000 	pushw	#0
    95a2:	72da 1170 	lod	A, #4464
    95a6:	17b5      	call	0x9512 <_NVRAM_CountCRC8>
    95a8:	5c01      	dec	S, #2
    95aa:	8c00      	cmp	AL, #0
    95ac:	1d05      	jne	0x95b8 <_NVRAM_LogError+0x3a>
		{
			pNVERRLOG_UPG->NvramProgramCycleCount++;
    95ae:	7ada 1170 	lod	Y, #4464
    95b2:	72f0      	lod	A, [Y]
    95b4:	a001      	add	A, #1
    95b6:	0003      	jmp	0x95be <_NVRAM_LogError+0x40>
		}
		else
		{
			pNVERRLOG_UPG->NvramProgramCycleCount = 1U;
    95b8:	7001      	lod	A, #1
    95ba:	7ada 1170 	lod	Y, #4464
    95be:	52f0      	mov	[Y], A
		}																		/* MMP150219-1 - End */
		/* store error log */
		if ( pNVERRLOG_UPG->NvramProgramCycleCount < (C_MAX_NVRAM_PROGRAM_COUNT - 1000u) )
    95c0:	7ada 1170 	lod	Y, #4464
    95c4:	72f0      	lod	A, [Y]
    95c6:	aeda f9ff 	cmp	A, #63999
    95ca:	1e1d      	jug	0x9606 <_NVRAM_LogError+0x88>
        {
			(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    95cc:	54ca 0001 	pushw	#1
    95d0:	72da 1170 	lod	A, #4464
    95d4:	179e      	call	0x9512 <_NVRAM_CountCRC8>
			PlaceError( (uint16 *) &(pNVERRLOG_UPG->ErrorLog[u16ErrorLogIdx >> 1u]), u16ErrorLogIdx & 0x01u, u8ErrorCode);
    95d6:	7203      	lod	A, [S-4]
    95d8:	b6da 00fe 	and	A, #254
    95dc:	a2da 1174 	add	A, #4468
    95e0:	7a07      	lod	Y, [S-8]
    95e2:	5adf      	push	Y
    95e4:	7a05      	lod	Y, [S-6]
    95e6:	f401      	and	Y, #1
    95e8:	5adf      	push	Y
    95ea:	17b5      	call	0x9556 <_PlaceError>
			pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00u) | u16ErrorLogIdx;
    95ec:	7ada 1170 	lod	Y, #4464
    95f0:	72f2      	lod	A, [Y+2]
    95f2:	b6da ff00 	and	A, #65280
    95f6:	a607      	or	A, [S-8]
    95f8:	52f2      	mov	[Y+2], A
			/* Save (NV)RAM to NV(RAM) */
			NVRAM_SavePage( NVRAM2_PAGE1 | NVRAM_PAGE_WR_SKIP_WAIT);
    95fa:	72da 8002 	lod	A, #32770
    95fe:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    9602:	5c05      	dec	S, #6
    9604:	0002      	jmp	0x960a <_NVRAM_LogError+0x8c>
		}
		else
		{
			u16Result = C_NVRAM_STORE_MAX_WRITE_CYCLE;
    9606:	7001      	lod	A, #1
    9608:	5203      	mov	[S-4], A
		}
		
	}
	return ( u16Result );														/* MMP150219-1 */
} /* End of NVRAM_LogError() */
    960a:	7203      	lod	A, [S-4]
    960c:	5407      	ret	#8

0000960e <_NVRAM_GetLastError>:
 *
 *	Pre:	-
 *	Post:	(uint8) Last logged error-code
 * ****************************************************************************	*/
uint8 NVRAM_GetLastError( void)
{
    960e:	5801      	inc	S, #2
	uint16 u16ErrorLogIdx;
	uint8 u8Result = 0x00u;														/* No error's */
    9610:	7000      	lod	A, #0
    9612:	5201      	mov	[S-2], A

	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
    9614:	7ada 1170 	lod	Y, #4464
	u16ErrorLogIdx = (uint8) (pNVERRLOG_UPG->ErrorLogIndex_CRC);
    9618:	72f2      	lod	A, [Y+2]
    961a:	5cf2      	usex	A
    961c:	7ee2      	lod	X, A

	if ( u16ErrorLogIdx != 0x00u )
    961e:	190f      	je	0x963e <_NVRAM_GetLastError+0x30>
	{																			/* MMP140218-1 */
		/* Get last error from User-Page #2 */
		u16ErrorLogIdx--;
    9620:	20ff      	add	X, #-1
		{
			uint16 u16ErrorCodes = pNVERRLOG_UPG->ErrorLog[u16ErrorLogIdx >> 1u];
    9622:	72ee      	lod	A, X
    9624:	b4fe      	and	A, #-2
    9626:	7ae2      	lod	Y, A
    9628:	e2da 1174 	add	Y, #4468
    962c:	7af0      	lod	Y, [Y]
			if ( (u16ErrorLogIdx & 0x01u) != 0u )
    962e:	72ee      	lod	A, X
    9630:	b401      	and	A, #1
    9632:	1903      	je	0x963a <_NVRAM_GetLastError+0x2c>
			{
				u8Result = (uint8) (u16ErrorCodes >> 8u);
    9634:	6400      	lod	YL, #0
    9636:	7ae8      	swap	Y
    9638:	0001      	jmp	0x963c <_NVRAM_GetLastError+0x2e>
			}
			else
			{
				u8Result = (uint8) u16ErrorCodes;
    963a:	5cf6      	usex	Y
    963c:	5a01      	mov	[S-2], Y
			}
		}
	}
	return( u8Result );

} /* End of NVRAM_GetLastError() */
    963e:	7201      	lod	A, [S-2]
    9640:	5403      	ret	#4

00009642 <_NVRAM_ClearErrorLog>:
 *	Comments: Clear Application Error logging (in both User-NVRAM pages)
 * ****************************************************************************	*/
void NVRAM_ClearErrorLog( void)
{
	uint16 i;
	PNVRAM_ERRORLOG pNVERRLOG_UPG = (PNVRAM_ERRORLOG) (C_ADDR_USERPAGE2 + C_NVRAM_ERRLOG_OFFSET);
    9642:	7ada 1170 	lod	Y, #4464
	pNVERRLOG_UPG->ErrorLogIndex_CRC = ((pNVERRLOG_UPG->ErrorLogIndex_CRC) & 0xFF00u) | 0x00u;	/* Set index at 0x00 */
    9646:	72f2      	lod	A, [Y+2]
    9648:	b6da ff00 	and	A, #65280
    964c:	52f2      	mov	[Y+2], A
    964e:	7ada 1174 	lod	Y, #4468
    9652:	7c06      	lod	X, #6
	for ( i = 0; i < (C_MAX_ERRORS_PER_PAGE / 2u); i++ )
	{
		pNVERRLOG_UPG->ErrorLog[i] = 0x0000u;
    9654:	7000      	lod	A, #0
    9656:	52d6      	mov	[Y++], A
    9658:	1bfd      	djnz	X, 0x9654 <_NVRAM_ClearErrorLog+0x12>
	}
	(void) NVRAM_CountCRC8( pNVERRLOG_UPG, TRUE);
    965a:	54ca 0001 	pushw	#1
    965e:	72da 1170 	lod	A, #4464
    9662:	1757      	call	0x9512 <_NVRAM_CountCRC8>
	NVRAM_SavePage( NVRAM2_PAGE1);
    9664:	7002      	lod	A, #2
    9666:	82db 59f4 	callf	0x59f4 <_NVRAM_SavePage>
    966a:	5c01      	dec	S, #2
    966c:	5401      	ret

0000966e <_PID_Init>:

/* ***
 * PID_Init()
 * ***/
void PID_Init( void)
{
    966e:	580d      	inc	S, #14
	/* MMP141209-1: Convert [mA] to [ADC-lsb] */
	uint16 u16MCurrgain = EE_GMCURR;
    9670:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    9674:	b6da 00ff 	and	A, #255
    9678:	7ee2      	lod	X, A
    967a:	22da 0100 	add	X, #256
	g_u16PidHoldingThreshold = NVRAM_HOLDING_CURR_LEVEL;
    967e:	7032      	lod	A, #50
    9680:	52d8 0184 	mov	0x184 <_g_u16PidHoldingThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9684:	72da 0080 	lod	A, #128
    9688:	7832      	lod	Y, #50
    968a:	4821      	mulu	YA, A, Y
    968c:	4c63      	divu	YA, X
    968e:	4c63      	divu	YA, X
    9690:	520d      	mov	[S-14], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9692:	52d8 0188 	mov	0x188 <_g_u16PidHoldingThresholdADC>, A
	g_u16PidHoldingThresholdADC = muldivU16_U16byU16byU16( g_u16PidHoldingThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1 */
	g_u16PidRunningThreshold = NVRAM_RUNNING_CURR_LEVEL;
    9696:	72da 012c 	lod	A, #300
    969a:	52d8 0180 	mov	0x180 <_g_u16PidRunningThreshold>, A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    969e:	72da 0080 	lod	A, #128
    96a2:	7ada 012c 	lod	Y, #300
    96a6:	4821      	mulu	YA, A, Y
    96a8:	4c63      	divu	YA, X
    96aa:	4c63      	divu	YA, X
    96ac:	520b      	mov	[S-12], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    96ae:	52d8 0182 	mov	0x182 <_g_u16PidRunningThresholdADC>, A
	g_u16PidRunningThresholdADC = muldivU16_U16byU16byU16( g_u16PidRunningThreshold, C_GMCURR_DIV, u16MCurrgain);	/* MMP141209-1/MMP131219-1 */
	g_u16MotorRefVoltage = NVRAM_VSUP_REF;
    96b2:	7eda 0546 	lod	X, #1350
    96b6:	5ed8 00e2 	mov	0xe2 <_g_u16MotorRefVoltage>, X
    96ba:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    96be:	6000      	lod	AL, #0
    96c0:	72e4      	swap	A
    96c2:	5203      	mov	[S-4], A
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    96c4:	72da 0546 	lod	A, #1350
    96c8:	7840      	lod	Y, #64
    96ca:	7e03      	lod	X, [S-4]
    96cc:	4821      	mulu	YA, A, Y
    96ce:	4c63      	divu	YA, X
    96d0:	4c63      	divu	YA, X
    96d2:	5201      	mov	[S-2], A
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    96d4:	72d8 11ce 	lod	A, 0x11ce <__ep__+0x1ce>
    96d8:	5ce2      	ssex	A
    96da:	a201      	add	A, [S-2]
    96dc:	52d8 00e0 	mov	0xe0 <_l_u16MotorRefVoltageADC>, A
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GVOLTAGE) + EE_OVOLTAGE;
#else  /* _SUPPORT_VSMFILTERED */
	l_u16MotorRefVoltageADC = muldivU16_U16byU16byU16( NVRAM_VSUP_REF, C_GVOLTAGE_DIV, EE_GADC) + EE_OADC;
#endif /* _SUPPORT_VSMFILTERED */

	l_u16MinCorrectionRatio = NVRAM_MIN_CORR_RATIO;								/* MMP150509-2 */
    96e0:	72da 08df 	lod	A, #2271
    96e4:	52d8 018a 	mov	0x18a <_l_u16MinCorrectionRatio>, A
	l_u16MaxCorrectionRatio = NVRAM_MAX_CORR_RATIO;								/* MMP150509-2 */
    96e8:	7ada 55ab 	lod	Y, #21931
    96ec:	5ad8 018c 	mov	0x18c <_l_u16MaxCorrectionRatio>, Y
    96f0:	540f      	ret	#16

000096f2 <_VoltageCorrection>:
 *
 *	Compensate Motor PWM Duty Cycle for voltage changes
 * Performance: 7.5us @ 20Mz
 * ***/
void VoltageCorrection( void)
{
    96f2:	5801      	inc	S, #2

#define ADC_SETTING (uint16)(((2U*PLL_freq)/(1000000U*2*CYCLES_PER_INSTR)) + 1)	/* 2us: 2us*PLL-freq/(10000000us/s * #cycles/instruction) */

static INLINE uint16 GetRawVsupplyMotor( void)
{
extern T_ADC_MOTORRUN_STEPPER4 volatile g_AdcMotorRunStepper4;					/* ADC results Stepper mode */
    96f4:	7ed8 00fa 	lod	X, 0xfa <_g_AdcMotorRunStepper4+0x6>
	uint16 u16MotorVoltageADC = GetRawVsupplyMotor();
#if _DEBUG_VOLTAGE_COMPENSATION
	l_ai16MotorVolt[u16MotorVoltIdx] = g_i16MotorVoltage;
	u16MotorVoltIdx = (u16MotorVoltIdx + 1u) & (SZ_MOTOR_VOLT_COMP - 1u);
#endif /* _DEBUG_VOLTAGE_COMPENSATION */
	if ( (u16MotorVoltageADC > 0u) && (l_u16MotorRefVoltageADC > 0u) )
    96f8:	191f      	je	0x9738 <_VoltageCorrection+0x46>
    96fa:	7ad8 00e0 	lod	Y, 0xe0 <_l_u16MotorRefVoltageADC>
    96fe:	191c      	je	0x9738 <_VoltageCorrection+0x46>
 *
 * Example:
 *   uint32 result = ((uint32) a) * b
 */
static __inline__ uint32 mulU32_U16byU16(uint16 a, uint16 b)
{
    9700:	72d8 017e 	lod	A, 0x17e <_g_u16PidCtrlRatio>
    uint32 result;

    __asm__ __volatile__ (
    9704:	4801      	mulu	D, A, Y
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    uint16 result;
    uint16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9706:	4c80      	mov	YA, D
    9708:	4c63      	divu	YA, X
    970a:	4c63      	divu	YA, X
    970c:	7ee2      	lod	X, A
 *
 * Output :
 *      result      unsigned 16-bit quotient
 */
static __inline__ uint16 divU16_U32byU16(uint32 a, uint16 b)
{
    970e:	7ae2      	lod	Y, A
	{
		/* Correct Motor PWM duty cycle instantly based on change of supply voltage */
		uint16 u16NewCorrectionRatio = divU16_U32byU16( mulU32_U16byU16( g_u16PidCtrlRatio, l_u16MotorRefVoltageADC), u16MotorVoltageADC);
		if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP  )
    9710:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    9714:	190a      	je	0x972a <_VoltageCorrection+0x38>
		{
			if ( u16NewCorrectionRatio < l_u16MinCorrectionRatio )
    9716:	72d8 018a 	lod	A, 0x18a <_l_u16MinCorrectionRatio>
    971a:	2ee2      	cmp	X, A
    971c:	1804      	jc	0x9726 <_VoltageCorrection+0x34>
			{
				/* Underflow */
				u16NewCorrectionRatio = l_u16MinCorrectionRatio;
			}
			else if ( u16NewCorrectionRatio > l_u16MaxCorrectionRatio )
    971e:	72d8 018c 	lod	A, 0x18c <_l_u16MaxCorrectionRatio>
    9722:	2ee2      	cmp	X, A
    9724:	1a07      	jule	0x9734 <_VoltageCorrection+0x42>
			{
				/* Overflow */
				u16NewCorrectionRatio = l_u16MaxCorrectionRatio;
    9726:	7ae2      	lod	Y, A
    9728:	0005      	jmp	0x9734 <_VoltageCorrection+0x42>
			else
			{
				
			}
		}
		else if ( u16NewCorrectionRatio < NVRAM_MIN_HOLDCORR_RATIO )
    972a:	2eda 08de 	cmp	X, #2270
    972e:	1e02      	jug	0x9734 <_VoltageCorrection+0x42>
		{
			/* Underflow */
			u16NewCorrectionRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9730:	7ada 08df 	lod	Y, #2271
		}
		else
		{
			
		}
		g_u16CorrectionRatio = u16NewCorrectionRatio;
    9734:	5938      	mov	dp:0x38 <_g_u16CorrectionRatio>, Y
    9736:	5403      	ret	#4
	}
	else
	{
		g_u16CorrectionRatio = g_u16PidCtrlRatio;
    9738:	72d8 017e 	lod	A, 0x17e <_g_u16PidCtrlRatio>
    973c:	5138      	mov	dp:0x38 <_g_u16CorrectionRatio>, A
    973e:	5403      	ret	#4

00009740 <_PID_Control>:
 *	DC: Motor PWM Duty Cycle; 
 *	Stepper: current-control;
 *	BEMF: speed-control
 * ***/
void PID_Control( void)
{
    9740:	5805      	inc	S, #6
		int16 i16PID_Ipart;
		int16 i16PID_Ppart;
		uint16 u16PidCtrlRatio;

		/* Current Control */
		uint16 u16MotorCurrentLPFFraction = ((g_u16MotorCurrentLPFx64 + 32u) >> 6u);	/* MMP140911-1 */
    9742:	7142      	lod	A, dp:0x42 <_g_u16MotorCurrentLPFx64>
    9744:	7ae2      	lod	Y, A
    9746:	e020      	add	Y, #32
    9748:	44b6      	lsr	Y, #2
    974a:	44b6      	lsr	Y, #2
    974c:	44b6      	lsr	Y, #2
		
		if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    974e:	62d8 00dd 	lod	AL, 0xdd <_g_u8MotorStartupMode>
    9752:	4205      	mov	[S-6], AL
    9754:	1909      	je	0x9768 <_PID_Control+0x28>
		{
			i16ControlError = (int16) (g_u16PidRunningThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    9756:	72d8 0182 	lod	A, 0x182 <_g_u16PidRunningThresholdADC>
    975a:	7ee2      	lod	X, A
    975c:	2ae6      	sub	X, Y
			l_u16MaxPidCtrlRatio = l_u16MaxCorrectionRatio;
    975e:	7ad8 018c 	lod	Y, 0x18c <_l_u16MaxCorrectionRatio>
    9762:	5ad8 0186 	mov	0x186 <_l_u16MaxPidCtrlRatio>, Y
    9766:	0004      	jmp	0x9770 <_PID_Control+0x30>
		}
		else
		{
			i16ControlError = (int16) (g_u16PidHoldingThresholdADC - u16MotorCurrentLPFFraction);	/* MMP140911-1 */
    9768:	72d8 0188 	lod	A, 0x188 <_g_u16PidHoldingThresholdADC>
    976c:	7ee2      	lod	X, A
    976e:	2ae6      	sub	X, Y
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9770:	7aee      	lod	Y, X
    9772:	ead8 00e4 	sub	Y, 0xe4 <_g_i16PID_E>
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9776:	701e      	lod	A, #30
    9778:	4831      	muls	YA, A, Y
    977a:	48b5      	asr	YA, #6
    977c:	b000      	adc	A, #0
    977e:	5203      	mov	[S-4], A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    9780:	52d8 00e6 	mov	0xe6 <_g_i16PID_D>, A
		}

		/* Derivative-part */
		g_i16PID_D = mulI16_I16byI16RndDiv64( (i16ControlError - g_i16PID_E), (int16)NVRAM_PID_COEF_D);
		g_i16PID_E = i16ControlError;
    9784:	5ed8 00e4 	mov	0xe4 <_g_i16PID_E>, X
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    9788:	701e      	lod	A, #30
    978a:	4833      	muls	YA, A, X
    978c:	48b5      	asr	YA, #6
    978e:	b000      	adc	A, #0
    9790:	5201      	mov	[S-2], A
		/* Integral-part */
		i16PID_Ipart = mulI16_I16byI16RndDiv64( i16ControlError, (int16)NVRAM_PID_COEF_I);
		if ( (i16PID_Ipart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ipart)) )
    9792:	ac00      	cmp	A, #0
    9794:	1e87      	jsge	0x97a4 <_PID_Control+0x64>
    9796:	7201      	lod	A, [S-2]
    9798:	5cc2      	neg	A
    979a:	ad50      	cmp	A, dp:0x50 <_g_u16PID_I>
    979c:	1a03      	jule	0x97a4 <_PID_Control+0x64>
		{
			g_u16PID_I = 0u;
    979e:	7800      	lod	Y, #0
    97a0:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    97a2:	0003      	jmp	0x97aa <_PID_Control+0x6a>
		}
		else
		{
			g_u16PID_I = (uint16) ((int16)g_u16PID_I + i16PID_Ipart);
    97a4:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    97a6:	a201      	add	A, [S-2]
    97a8:	5150      	mov	dp:0x50 <_g_u16PID_I>, A
    return result;
} /* End of divI16_I32byI16() */

static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b) __attribute__ ((always_inline));
static __inline__ int16 mulI16_I16byI16RndDiv64(int16 a, int16 b)
{
    97aa:	7832      	lod	Y, #50
    int16 result;
    int16 result2;    /* clobbering of the register */

    __asm__ __volatile__ (
    97ac:	72e6      	lod	A, Y
    97ae:	4833      	muls	YA, A, X
    97b0:	48b5      	asr	YA, #6
    97b2:	b000      	adc	A, #0
    97b4:	7ee2      	lod	X, A
		}
		/* Proportional-part */
		i16PID_Ppart = mulI16_I16byI16RndDiv64( i16ControlError, (int16) NVRAM_PID_COEF_P);
		if ( (i16PID_Ppart < 0) && (g_u16PID_I < ((uint16) -i16PID_Ppart)) )
    97b6:	ac00      	cmp	A, #0
    97b8:	1e8d      	jsge	0x97d4 <_PID_Control+0x94>
    97ba:	5cc2      	neg	A
    97bc:	ad50      	cmp	A, dp:0x50 <_g_u16PID_I>
    97be:	1a0a      	jule	0x97d4 <_PID_Control+0x94>
		{
			if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    97c0:	6205      	lod	AL, [S-6]
    97c2:	1903      	je	0x97ca <_PID_Control+0x8a>
			{
				u16PidCtrlRatio = l_u16MinCorrectionRatio;
    97c4:	7ed8 018a 	lod	X, 0x18a <_l_u16MinCorrectionRatio>
    97c8:	0002      	jmp	0x97ce <_PID_Control+0x8e>
			}
			else
			{
				u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    97ca:	7eda 08df 	lod	X, #2271
			}
			g_u16PID_I = 0u;
    97ce:	7800      	lod	Y, #0
    97d0:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    97d2:	0019      	jmp	0x9806 <_PID_Control+0xc6>
		}
		else
		{
			u16PidCtrlRatio = (uint16) ((int16)g_u16PID_I + i16PID_Ppart + g_i16PID_D);
    97d4:	7150      	lod	A, dp:0x50 <_g_u16PID_I>
    97d6:	a2ee      	add	A, X
    97d8:	7ee2      	lod	X, A
    97da:	22d8 00e6 	add	X, 0xe6 <_g_i16PID_D>
			if ( g_u8MotorStartupMode !=  (uint8)MSM_STOP )
    97de:	6205      	lod	AL, [S-6]
    97e0:	190d      	je	0x97fc <_PID_Control+0xbc>
			{
				if ( u16PidCtrlRatio < l_u16MinCorrectionRatio )
    97e2:	7ad8 018a 	lod	Y, 0x18a <_l_u16MinCorrectionRatio>
    97e6:	2ee6      	cmp	X, Y
    97e8:	1c02      	jnc	0x97ee <_PID_Control+0xae>
				{
					/* Underflow */
					u16PidCtrlRatio = l_u16MinCorrectionRatio;
    97ea:	7ee6      	lod	X, Y
    97ec:	000c      	jmp	0x9806 <_PID_Control+0xc6>
				}
				else if ( u16PidCtrlRatio >= l_u16MaxPidCtrlRatio )
    97ee:	7ad8 0186 	lod	Y, 0x186 <_l_u16MaxPidCtrlRatio>
    97f2:	2ee6      	cmp	X, Y
    97f4:	1808      	jc	0x9806 <_PID_Control+0xc6>
				{
					/* Overflow */
					u16PidCtrlRatio = l_u16MaxPidCtrlRatio;
    97f6:	7ee6      	lod	X, Y
					g_u16PID_I = u16PidCtrlRatio;								/* MMP140617-1 */
    97f8:	5950      	mov	dp:0x50 <_g_u16PID_I>, Y
    97fa:	0005      	jmp	0x9806 <_PID_Control+0xc6>
				else
				{
				
				}
			}
			else if ( u16PidCtrlRatio < NVRAM_MIN_HOLDCORR_RATIO )
    97fc:	2eda 08de 	cmp	X, #2270
    9800:	1e02      	jug	0x9806 <_PID_Control+0xc6>
			{
				/* Underflow */
				u16PidCtrlRatio = NVRAM_MIN_HOLDCORR_RATIO;
    9802:	7eda 08df 	lod	X, #2271
			else
			{
				
			}
		}
		g_u16PidCtrlRatio = u16PidCtrlRatio;
    9806:	5ed8 017e 	mov	0x17e <_g_u16PidCtrlRatio>, X
	}
	VoltageCorrection();
    980a:	1773      	call	0x96f2 <_VoltageCorrection>
    980c:	5407      	ret	#8

0000980e <_ThresholdControl>:
 *	DC-Motor: Motor Power
 *	Stepper: Current Threshold Control
 *	BEMF: Nothing
 * ***/
void ThresholdControl( void)
{
    980e:	5805      	inc	S, #6
		uint16 u16CurrThrshldRatio;
		int16 i16TemperatureBgn = NVRAM_CURRTHRSHLD_TEMP_1;
    9810:	70de      	lod	A, #-34
    9812:	5203      	mov	[S-4], A


#if _SUPPORT_AMBIENT_TEMP
		if ( g_i16AmbjTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
#else  /* _SUPPORT_AMBIENT_TEMP */
		if ( g_i16ChipTemperature < (i16TemperatureBgn - C_CURRTHRSHLD_TEMP_HYS) )
    9814:	72d8 00b2 	lod	A, 0xb2 <_g_i16ChipTemperature>
    9818:	acdc      	cmp	A, #-36
    981a:	1e84      	jsge	0x9824 <_ThresholdControl+0x16>
#endif /* _SUPPORT_AMBIENT_TEMP */
		{
			if ( NVRAM_CURRTHRSHLD_ZONE_1 != 0u )
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;					/* Same as point _1 */
    981c:	7ada 0080 	lod	Y, #128
    9820:	5a05      	mov	[S-6], Y
    9822:	0019      	jmp	0x9856 <_ThresholdControl+0x48>
		}
		else
		{
			uint8 u8CurrThrshldCtrlType = (uint8)NVRAM_CURRTHRSHLD_ZONE_2;				/* Get current threshold compensation-type */
			uint16 u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_2;			/* Get zone end point (_2) */
			int16 i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_2;						
    9824:	7c08      	lod	X, #8
#if _SUPPORT_AMBIENT_TEMP
			if ( g_i16AmbjTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
			if ( g_i16ChipTemperature > i16TemperatureEnd )						/* Temperature above second zone ? */
    9826:	ac08      	cmp	A, #8
    9828:	1b0a      	jsle	0x983e <_ThresholdControl+0x30>
				u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_3;				/* Get zone end point (_3) */
				i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_3;
#if _SUPPORT_AMBIENT_TEMP
				if ( g_i16AmbjTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
				if ( g_i16ChipTemperature > i16TemperatureEnd )					/* Temperature above third zone ? */
    982a:	ac26      	cmp	A, #38
    982c:	1b05      	jsle	0x9838 <_ThresholdControl+0x2a>
#endif /* _SUPPORT_AMBIENT_TEMP */
				{
					i16TemperatureBgn = i16TemperatureEnd;						/* Next zone; begin point (_3) */
    982e:	7826      	lod	Y, #38
    9830:	5a03      	mov	[S-4], Y
					u16CurrThrshldRatioBgn = u16CurrThrshldRatioEnd;
					u8CurrThrshldCtrlType = (uint8)NVRAM_CURRTHRSHLD_ZONE_4;
					u16CurrThrshldRatioEnd = NVRAM_CURRTHRSHLD_RATIO_4;			/* Get zone end point (_3) */
					i16TemperatureEnd = NVRAM_CURRTHRSHLD_TEMP_4;
    9832:	7c3e      	lod	X, #62
#if _SUPPORT_AMBIENT_TEMP
					if ( g_i16AmbjTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
#else  /* _SUPPORT_AMBIENT_TEMP */
					if ( g_i16ChipTemperature > i16TemperatureEnd )				/* Temperature above fourth zone ? */
    9834:	ac3e      	cmp	A, #62
    9836:	1b03      	jsle	0x983e <_ThresholdControl+0x30>
					}
				}
			}
			if ( u8CurrThrshldCtrlType == 1u )
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioBgn;
    9838:	72da 0080 	lod	A, #128
    983c:	000b      	jmp	0x9854 <_ThresholdControl+0x46>
			{
				u16CurrThrshldRatio = u16CurrThrshldRatioEnd;
			}
			else if ( u8CurrThrshldCtrlType == 3u )
			{
				i16TemperatureEnd = i16TemperatureEnd - i16TemperatureBgn;
    983e:	2a03      	sub	X, [S-4]
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    9840:	7000      	lod	A, #0
    9842:	7ad8 00b2 	lod	Y, 0xb2 <_g_i16ChipTemperature>
    9846:	ea03      	sub	Y, [S-4]
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9848:	4831      	muls	YA, A, Y
    984a:	4c73      	divs	YA, X
    984c:	4c73      	divs	YA, X
    984e:	4c7b      	dadjs	YA, X
/*
 *	Multiplication
 */
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c) __attribute__ ((always_inline));
static __inline__ int16 muldivI16_I16byI16byI16(int16 a, int16 b, int16 c)
{
    9850:	a2da 0080 	add	A, #128
    9854:	5205      	mov	[S-6], A
			{
				u16CurrThrshldRatio = 0u;										/* Shutdown motor */
			}
		}
		{
			uint16 u16MCurrgain = EE_GMCURR;
    9856:	72d8 11d0 	lod	A, 0x11d0 <__ep__+0x1d0>
    985a:	b6da 00ff 	and	A, #255
    985e:	7ee2      	lod	X, A
    9860:	22da 0100 	add	X, #256
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9864:	72d8 0184 	lod	A, 0x184 <_g_u16PidHoldingThreshold>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9868:	7a05      	lod	Y, [S-6]
    986a:	4821      	mulu	YA, A, Y
    986c:	4c63      	divu	YA, X
    986e:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9870:	52d8 0188 	mov	0x188 <_g_u16PidHoldingThresholdADC>, A
    9874:	72d8 0180 	lod	A, 0x180 <_g_u16PidRunningThreshold>
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    9878:	7a05      	lod	Y, [S-6]
    987a:	4821      	mulu	YA, A, Y
    987c:	4c63      	divu	YA, X
    987e:	4c63      	divu	YA, X
    return result;
} /* End of muldivI16_I16byI16byI16() */

static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c) __attribute__ ((always_inline));
static __inline__ uint16 muldivU16_U16byU16byU16(uint16 a, uint16 b, uint16 c)
{
    9880:	52d8 0182 	mov	0x182 <_g_u16PidRunningThresholdADC>, A
    9884:	5407      	ret	#8

00009886 <_Timer_Init>:
 * Timer_Init()
 *
 * Initialise the core timer (Mulan2-timer), at a periodic rate of 500us
 * ****************************************************************************	*/
void Timer_Init( void)
{
    9886:	7ada 018e 	lod	Y, #398
    988a:	7c09      	lod	X, #9
	uint16 i;
	for(i = 0; i < (uint16)MAX_TIMER; i++)
	{
		l_u16Timer[i] = 0;
    988c:	7000      	lod	A, #0
    988e:	52d6      	mov	[Y++], A
    9890:	1bfd      	djnz	X, 0x988c <_Timer_Init+0x6>
	}
	/* System Tick Timer - Core Timer  */
	TIMER =  TMR_EN | CT_PERIODIC_RATE;											/* 500us timer */
    9892:	72da 81f4 	lod	A, #33268
    9896:	5286      	mov	io:0x6 <_LinMess2>, A
    9898:	5401      	ret

0000989a <_Timer_Start>:
 * Timer_Start()
 *
 * Set the timer by timer period and timer id
 * ****************************************************************************	*/
void Timer_Start(TIMER_ID id,uint16 TimerPeriod)
{
    989a:	7e03      	lod	X, [S-4]
	if(id < MAX_TIMER)
    989c:	ac08      	cmp	A, #8
    989e:	1e05      	jug	0x98aa <_Timer_Start+0x10>
	{
		l_u16Timer[id] = TimerPeriod;
    98a0:	4422      	asl	A
    98a2:	7ae2      	lod	Y, A
    98a4:	e2da 018e 	add	Y, #398
    98a8:	5ef0      	mov	[Y], X
    98aa:	5401      	ret

000098ac <_Timer_IsExpired>:
 *
 * Get the timer status by timer id
 * ****************************************************************************	*/
uint8 Timer_IsExpired(TIMER_ID id)
{
	if(l_u16Timer[id] == 0u)
    98ac:	4422      	asl	A
    98ae:	7ae2      	lod	Y, A
    98b0:	e2da 018e 	add	Y, #398
    98b4:	72f0      	lod	A, [Y]
    98b6:	1d02      	jne	0x98bc <_Timer_IsExpired+0x10>
	{
		return TRUE;
    98b8:	7001      	lod	A, #1
    98ba:	5401      	ret
	}
	else
	{
		return FALSE;
    98bc:	7000      	lod	A, #0
	}
}
    98be:	5401      	ret

000098c0 <_Timer_SleepCompensation>:
 * Timer_SleepCompensation()
 *
 * Compensate the various timer-counters for the sleep-period
 * ****************************************************************************	*/
void Timer_SleepCompensation( uint16 u16SleepPeriod)
{
    98c0:	5805      	inc	S, #6
    98c2:	5201      	mov	[S-2], A
    98c4:	7ada 0100 	lod	Y, #256
    98c8:	7eda 36b0 	lod	X, #14000
    int16 result;  /*lint -e530 */
    int16 result2; /*lint -e529 */												/* clobbering of the register */

    __asm__ __volatile__ (
    98cc:	4821      	mulu	YA, A, Y
    98ce:	4c63      	divu	YA, X
    98d0:	4c63      	divu	YA, X
    98d2:	5205      	mov	[S-6], A
 */
static INLINE uint16 SYS_getCpuStatus (void)
{
    uint16 status;

    __asm__ __volatile__ (
    98d4:	72e3      	lod	A, M
    98d6:	5203      	mov	[S-4], A
	uint16 i;
	
	u16SleepPeriod = muldivU16_U16byU16byU16( u16SleepPeriod, 256U, (uint16)(CT_PERIODIC_RATE*(PLL_freq/1000000U)));
	ATOMIC_CODE
    98d8:	4407      	mov	R, #0
    98da:	500c      	call	fp0:0x60
    98dc:	54f0      	mov	UPr, #0
    98de:	7ada 018e 	lod	Y, #398
    98e2:	7c09      	lod	X, #9
    98e4:	72f0      	lod	A, [Y]
    98e6:	ae05      	cmp	A, [S-6]
    98e8:	1a02      	jule	0x98ee <_Timer_SleepCompensation+0x2e>
    98ea:	aa05      	sub	A, [S-6]
    98ec:	0001      	jmp	0x98f0 <_Timer_SleepCompensation+0x30>
    98ee:	7000      	lod	A, #0
    98f0:	52f0      	mov	[Y], A
    98f2:	e002      	add	Y, #2
    98f4:	1bf7      	djnz	X, 0x98e4 <_Timer_SleepCompensation+0x24>
/*
 * Set M register value
 */
static INLINE void SYS_setCpuStatus (uint16 status)
{
    __asm__ __volatile__ (
    98f6:	7203      	lod	A, [S-4]
    98f8:	52e3      	mov	M, A
    98fa:	5407      	ret	#8

000098fc <_TIMER_IT>:
 * TIMER_IT()
 *
 * Periodic Timer ISR
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
    98fc:	52df      	push	A
    98fe:	5edf      	push	X
    9900:	5adf      	push	Y
    9902:	7ada 018e 	lod	Y, #398
    9906:	7c09      	lod	X, #9
	uint16 i;
	
	for(i = 0; i < (uint16)MAX_TIMER; i++)
	{	
		if(l_u16Timer[i] > 0u)
    9908:	72f0      	lod	A, [Y]
    990a:	1902      	je	0x9910 <_TIMER_IT+0x14>
		{
			l_u16Timer[i]--;
    990c:	a0ff      	add	A, #-1
    990e:	52f0      	mov	[Y], A
    9910:	e002      	add	Y, #2
    9912:	1bfa      	djnz	X, 0x9908 <_TIMER_IT+0xc>
 * ****************************************************************************	*/
__interrupt__ void TIMER_IT(void) 
{
	uint16 i;
	
	for(i = 0; i < (uint16)MAX_TIMER; i++)
    9914:	7acf      	pop	Y
    9916:	7ecf      	pop	X
    9918:	72cf      	pop	A
    991a:	4407      	mov	R, #0
    991c:	72cb      	pop	M
    991e:	5401      	ret

00009920 <_SpiDebugWriteFirst>:
 *	Post:		Nothing
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
void SpiDebugWriteFirst( uint16 u16Data)
{
    9920:	5801      	inc	S, #2
    9922:	7ee2      	lod	X, A
	SPI1_PSCR |= SPI_FRSSOEN;													/* Toggle Slave-Select */
    9924:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    9928:	8408      	or	AL, #8
    992a:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_PSCR &= ~SPI_FRSSOEN;
    992e:	62d8 289b 	lod	AL, 0x289b <__io__+0x9b>
    9932:	94f7      	and	AL, #-9
    9934:	42d8 289b 	mov	0x289b <__io__+0x9b>, AL
	SPI1_DR = u16Data;															/* Send SPI-Data */
    9938:	5ed8 289e 	mov	0x289e <__io__+0x9e>, X
    993c:	5403      	ret	#4

0000993e <_SpiDebugInit>:
 *
 *	Comments:	Initialise SPI Interface.
 * ****************************************************************************	*/
void SpiDebugInit( void)
{
	SPI1_PCR  = SPI_CKEN;													/* Set the bit SPI_CKEN to 1 */
    993e:	6001      	lod	AL, #1
    9940:	42d8 289a 	mov	0x289a <__io__+0x9a>, AL
	SPI1_BRR  = (uint16)((PLL_freq / DEBUG_SPI_BAUDRATE) + 1u);						/* 100, 200, 400, 800 or 1000 kBaud */
    9944:	701d      	lod	A, #29
    9946:	52d8 289c 	mov	0x289c <__io__+0x9c>, A
	SPI1_CTRL = (SPI_FRSSOEN << 8u) | (SPI_MSTRONLY << 8u) | SPI_RFIE | SPI_TFIE | /* SPI_BYTEMOD | */ SPI_MSTR | SPI_EN | SPI_CKEN;	/* Mode 00 */
    994a:	72da 0ad3 	lod	A, #2771
    994e:	52d8 289a 	mov	0x289a <__io__+0x9a>, A

	SpiDebugWriteFirst( C_DBG_INIT);
    9952:	72da a55a 	lod	A, #42330
    9956:	17e4      	call	0x9920 <_SpiDebugWriteFirst>
    9958:	5401      	ret

0000995a <_SpiDebugWriteNext>:
 *
 *	Comments:	Send 16-bit SPI-data
 * ****************************************************************************	*/
void SpiDebugWriteNext( uint16 u16Data)
{
	SPI1_DR = u16Data;															/* Send SPI-Data */
    995a:	52d8 289e 	mov	0x289e <__io__+0x9e>, A
    995e:	5401      	ret

00009960 <_SBASE_INIT_4PH>:
    9960:	0143 0053 0d63 0473 0d03 ffff               C.S.c.s.....

0000996c <_SBASE_CURRENT>:
    996c:	0d03 ffff                                   ....

00009970 <_SBASE_MOTORVOLT>:
    9970:	0403 ffff                                   ....

00009974 <_SBASE_SUPPLYVOLT>:
    9974:	0003 ffff                                   ....

00009978 <_SBASE_TEMP>:
    9978:	0103 ffff                                   ....

0000997c <_SBASE_CURROFF>:
    997c:	0d03 ffff                                   ....

00009980 <_SBASE_VREF_OFF>:
    9980:	0100 ffff                                   ....

00009984 <_c_ai16MicroStepVector4PH>:
    9984:	0c8b 2528 3c56 5133 62f1 70e2 7a7d 7f62     ..(%V<3Q.b.p}zb.
    9994:	7f62 7a7d 70e2 62f1 5133 3c56 2528 0c8b     b.}z.p.b3QV<(%..
    99a4:	f375 dad8 c3aa aecd 9d0f 8f1e 8583 809e     u...............
    99b4:	809e 8583 8f1e 9d0f aecd c3aa dad8 f375     ..............u.
    99c4:	0c8b 2528 3c56 5133 62f1 70e2 7a7d 7f62     ..(%V<3Q.b.p}zb.

000099d4 <_c_au8DrvCfgSelfTestB4>:
    99d4:	c431 8421 4c13 4812 b5f5                    1.!..L.H..

000099de <_c_au16DrvAdcSelfTestA>:
    99de:	0b03 ffff 0a03 ffff 0903 ffff 1903 ffff     ................

000099ee <_c_au8DrvCfgSelfTestA>:
    99ee:	3020 0c08 0302 c080                          0......

000099f6 <_PageIntegerityDefault>:
    99f6:	0002 0000 0600 00b2 7fff ffff               ............
