Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 1  Win32 Assembler
                                LIN2B.ASM

                      1  Mlx4di    
                      2  
                      3  ; ---------------------------------------------------------------------------
                      4  ;
                      5  ; Description:
                      6  ;  LIN Firmware for the Mlx4
                      7  ;
                      8  ; File:        $Source: /var/cvsmucontrol/Projects/lin/mls_sw/source/lin2b.asm,v $
                      9  ; Created:     September 14th, 2004
                     10  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                     11  ; Updated:     $Date: 2015/05/04 13:27:01 $
                     12  ;              $Author: beh $
                     13  ; Revision:    $Revision: 1.40 $
                     14  ;              $Name: MLX4_LIN_FW_4_1_0 $
                     15  ;
                     16  ; Copyright (c) Melexis Digital Competence Center
                     17  ;
                     18  ; ---------------------------------------------------------------------------
                     19  
0000                 20            intel                        ;make sure the default settings are Intel radix and words format
                     21  
                     22  ;LIN Software
0004                 23  LIN2verASM  equ       4                ;revision code of this file
0001                 24  LIN2revASM  equ       1                ; format : xxxx xxxx x xxx xxxx
0000                 25  LIN2dvtASM  equ       0                ;                  \ \   \    \
                     26  ;Flash Loader                           ;                   \ \   \    rev (0 to 15) -> for the LIN software : ver.rev [LIN2revASM]
0002                 27  LIN2verFLSH  equ       2               ;                    \ \   ver (0 to 7) [LIN2verASM]
0000                 28  LIN2revFLSH  equ       0               ;                     \ stable (1) / in dvt (0) [LIN2dvtASM]
0000                 29  LIN2dvtFLSH  equ       0               ;                      same thing for the flash loader [LIN2verFLSH, LIN2revFLSH, LIN2dvtFLSH]
                     30  
0000                 31  EditNbr   equ       0 
                     32  
                     33  ;--------------- MelexCM constant definitions -----
                     34  ;dcom, dma and IO ports definitions for the Mlx4 periphery (for easier reading of the code)
0000                  0            #include  "periphery.asm" 
                      1  ; ---------------------------------------------------------------------------
                      2  ;
                      3  ; Description:
                      4  ;  MelexCM Constant Definitions
                      5  ;  DCOM, DMA and IO ports definitions for the Mlx4 periphery
                      6  ;
                      7  ; File:        $Source: /var/cvsmucontrol/Projects/lin/platform/libsrc/Mlx4/periphery.asm,v $
                      8  ; Created:     May 9th, 2005
                      9  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                     10  ; Updated:     $Date: 2014/08/18 15:17:01 $
                     11  ;              $Author: beh $
                     12  ; Revision:    $Revision: 1.1 $
                     13  ;              $Name: MLX4_LIN_FW_4_0_0 $
                     14  ;
                     15  ; Copyright (c) Melexis Digital Competence Center
                     16  ;
                     17  ; ---------------------------------------------------------------------------
                     18  
                     19  ;--------------- MSBi DCOM ------------------------
0000                 20  #define   WindCtrl0  0 
0000                 21  #define   WindCtrl1  1 
0000                 22  #define   WindCtrl2  2 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 2  Win32 Assembler
                                PERIPHERY.ASM

0000                 23  #define   WindCtrl3  3 
0000                 24  #define   StatCtrl  4 
0000                 25  #define   InpCtrl   4 
0000                 26  #define   OutCtrl   5 
0000                 27  #define   AuxCtrl   6 
0000                 28  #define   StuffCtrl  7 
0000                 29  #define   PlsCtrl   7 
0000                 30  #define   BrCtrl    8 
0000                 31  #define   CkCtrl    9 
                     32  ;--------------- MSBi I/O -------------------------
0000                 33  #define   CmpCtrl   io:16h 
0000                 34  #define   AuxIn     io:17h 
0000                 35  #define   Stat1     io:18h 
0000                 36  #define   Stat0     io:19h 
0000                 37  #define   Cfg0      io:1Ah 
0000                 38  #define   Cfg1      io:1Bh 
0000                 39  #define   DbCnt     io:1Ch 
0000                 40  #define   IdIdx     io:1Dh 
0000                 41  #define   PrescA    io:1Eh 
0000                 42  #define   PrescB    io:1Fh 
                     43  ;--------------- MSBi DMA -------------------------
0000                 44  #define   Br        0 
0000                 45  #define   IntBr     0 
0000                 46  #define   CmpRW     1 
0000                 47  #define   CmpSetId  1 
0000                 48  #define   CmpChk    2 
0000                 49  #define   CmpTst    2 
                     50  ;--------------- Mlx4 Dig I/0 ---------------------
0000                 51  #define   XcgStat   io:0h 
0000                 52  #define   XcgDr1    io:1h 
0000                 53  #define   XcgDr3    io:2h 
0000                 54  #define   AnalogStat  io:3h 
0000                 55  #define   ComDout   io:4h 
0000                 56  #define   RamRxt    io:5h 
0000                 57  #define   SleepStat  io:6h 
0000                 58  #define   MessStat  io:7h 
                     59  ;indexed I/O
0000                 60  #define   WatchPre  io:7h 
0000                 61  #define   WatchPreIdx  0 
0000                 62  #define   WatchCnt  io:7h 
0000                 63  #define   WatchCntIdx  1 
0000                 64  #define   SleepPre  io:7h 
0000                 65  #define   SleepPreIdx  2 
0000                 66  #define   SleepCnt  io:7h 
0000                 67  #define   SleepCntIdx  3 
0000                 68  #define   MessPre   io:7h 
0000                 69  #define   MessPreIdx  4 
0000                 70  #define   MessCnt   io:7h 
0000                 71  #define   MessCntIdx  5 
0000                 72  #define   EeW0      io:7h 
0000                 73  #define   EeW0Idx   6 
0000                 74  #define   EeW1      io:7h 
0000                 75  #define   EeW1Idx   7 
0000                 76  #define   EeW2      io:7h 
0000                 77  #define   EeW2Idx   8 
0000                 78  #define   EeW3      io:7h 
0000                 79  #define   EeW3Idx   9 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 3  Win32 Assembler
                                PERIPHERY.ASM

                     80  ;--------------- Mlx4 Dig DCOM --------------------
0000                 81  #define   MemRam    10 
0000                 82  #define   Timer     11 
0000                 83  #define   MemTab    11 
0000                 84  #define   AnIo      12 
0000                 85  #define   Int       13 
0000                 86  #define   Flags     14 
0000                 87  #define   System    15 
0000                 88  #define   FSafe     15 
                     89  ;--------------------------------------------------
                     36  
                     37  ;--------------- LIN and API constant definitions -------------
                     38  ;common with mlx16.asm: contains event and command possible values and api constants
0000 U               39            #IFDEF    USE_RELATIVE_PATH 
0000                  0            #include  "lincst.asm" 
                      1  ; ---------------------------------------------------------------------------
                      2  ;
                      3  ; Description:
                      4  ;  LIN Firmware constants for the Mlx4
                      5  ;
                      6  ; File:        $Source: /var/cvsmucontrol/Projects/lin/mls_sw/source/lincst.asm,v $
                      7  ; Created:     September 14th, 2004
                      8  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                      9  ; Updated:     $Date: 2015/04/01 14:20:28 $
                     10  ;              $Author: abb $
                     11  ; Revision:    $Revision: 1.9 $
                     12  ;              $Name: MLX4_LIN_FW_4_1_0 $
                     13  ;
                     14  ; Copyright (c) Melexis Digital Competence Center
                     15  ;
                     16  ; ---------------------------------------------------------------------------
                     17  
                     18  ; lincst.asm : this file contains the constants used in the Mlx4 LIN software. Some of theses constants can be changed, depending
                     19  ;on the application (particularly the time constants, which depends on the oscillator/PLL frequency).
                     20  
                     21  ; --- constansts are not used anymore since Phymd layout could depends on project
                     22  ; Possible values for the LIN cell Slew Rate (Phymd)
                     23  ;Refer to the Mlx4 periphery documentation for the values of your chip (see Phymd[1:0] in the FLASGS 1 dcom).
                     24  ;Be aware that these constants need to be changed also in \libsrc\LIN\lincst.h
                     25  ;SlewRate : (ML_SLEWHIGH=20kbps / ML_SLEWLOW=10kbps / ML_SLEWFAST=max (fast protocol))
                     26  ;ML_SLEWHIGH equ 0
                     27  ;ML_SLEWLOW equ 1
                     28  ;ML_SLEWFAST equ 2
                     29  
0001                 30  cvON      equ       1 
0000                 31  cvOFF     equ       0 
                     32  
0001                 33  cvFRAME   equ       1 
0002                 34  cvIDFILT  equ       2 
0003                 35  cvFUNCT   equ       3 
                     36  
                     37  ;coFILTMODE can be cvIDFILT or cvFRAME
0002                 38  coFILTMODE  equ       cvIDFILT 
                     39  
                     40  ; ROM tables base addresses - if these addresses have to be changed, this should be done
                     41  ;by changing the ROM_TABLE constant in \setup\Chip.mk
0000                 42  #IFDEF    5440      
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 4  Win32 Assembler
                                LINCST.ASM

1540                 43  _INDXtbl  equ       5440 
1580                 44  _PARAMtbl  equ       {5440 + 64} 
15C0                 45  _AUTOADDtbl  equ       {5440 + 128} 
0000                 46  #ELSE     
                     49  
                     50  ; Constants used in the Mlx4
                     51  ; Values for coTIMEOUT
0001                 52  cvTO13    equ       1 
0002                 53  cvTO2x    equ       2 
                     54  
                     55  ;---------------------------
                     56  ;Auto Baudrate Constants
                     57  ;---------------------------
0019                 58  abBRKOVF  equ       25                 ; Autobaudrate : overflow value to change the prescaler during break detection
0035                 59  abSHORTOVF  equ       53               ;0x35 too long low state at worst case: 23MHz CPUCK, 800 b/s, presca 1 (higher CPUCK should use presca = 2)
                     60  
0001                 61  abMINPRESCA  equ       1 
00BC                 62  abBRSTART  equ       188               ;0xBC, BR and Presca at start are chosen to have a valid wake up what ever the frequency is.
0003                 63  abPRESCASTART  equ       3             ;0xBC, presca 3 -> 10K at 30MHz, 3K at 10 MHz -> 5Tbits are always within {250us,5000us}
                     64  
                     65  ; The following constants SHOULD NOT BE CHANGED, from them depends the communication between the Mlx4 and the MLX16.
                     66  ;They should be consistent with \libsrc\LIN\lincst.h
0000                 67  tx        equ       0 
0001                 68  rx        equ       1 
                     69  
0000                 70  chk13     equ       0 
0001                 71  chk20     equ       1 
                     72  
0001                 73  TRUE      equ       1 
0000                 74  FALSE     equ       0 
0001                 75  ENABLED   equ       TRUE 
0000                 76  DISABLED  equ       FALSE 
0002                 77  AUTORESET  equ       2 
0003                 78  FORCE     equ       3 
                     79  
                     80  ;---------------------------
                     81  ;MLX16 to MLX4 Command Codes
                     82  ;---------------------------
0000                 83  pcNONE    equ       0 
0001                 84  pcSTCH    equ       1 
0002                 85  pcCNFBR   equ       2 
0003                 86  pcRX      equ       3 
0004                 87  pcTX      equ       4 
0005                 88  pcSETFRAME  equ       5 
0006                 89  pcCNFID   equ       6 
0007                 90  pcCNFSR   equ       7 
000A                 91  pcSFTVER  equ       10 
000B                 92  pcOPTION  equ       11 
000C                 93  pcGETST   equ       12 
000D                 94  pcCNFAUTO  equ       13 
000E                 95  pcFCNFIG  equ       14 
000F                 96  pcRELBUF  equ       15 
                     97  
                     98  ;---------------------------
                     99  ;MLX16 to MLX4 Sub Command Codes
                    100  ;---------------------------
0000                101  pcDISCARD  equ       0 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 5  Win32 Assembler
                                LINCST.ASM

0001                102  pcDATARDY  equ       1 
0002                103  pcCONTINOUSF  equ       2 
                    104  
                    105  ;---------------------------
                    106  ;MLX4 to MLX16 Event Codes
                    107  ;---------------------------
                    108  ;evNONE equ 0
0001                109  evSTCH    equ       1 
0002                110  evERR     equ       2 
0003                111  evMESSrcvd  equ       3 
0004                112  evMESSrqst  equ       4 
0005                113  evENDtx   equ       5 
0007                114  evCOOLAUTO  equ       7 
                    115  
                    116  ;---------------------------
                    117  ;MLX4 States Codes
                    118  ;---------------------------
0000                119  stINIT    equ       0 
0001                120  stDISC    equ       1 
0002                121  stACT     equ       2 
0004                122  stSLEEP   equ       4 
0008                123  stWKUP    equ       8 
000E                124  stSHORT   equ       14 
000F                125  stFAST    equ       15 
                    126  
                    127  ;---------------------------
                    128  ;Command Ack
                    129  ;---------------------------
0000                130  ackOK     equ       0 
0001                131  ackERR    equ       1 
                    132  
                    133  ;---------------------------
                    134  ;Sleep Codes
                    135  ;---------------------------
0001                136  slMST     equ       1 
0002                137  slAPP     equ       2 
0003                138  slWKUP    equ       3 
0004                139  slWKUPabort  equ       4 
0005                140  slWKUPresp  equ       5 
0008                141  slWKUPbreak  equ       8 
0006                142  slTO      equ       6 
0007                143  slTODOM   equ       7 
000A                144  slREG     equ       10 
                    145  
                    146  ;---------------------------
                    147  ;Error Codes
                    148  ;---------------------------
0000                149  erNOERR   equ       0 
0001                150  erSHORTDONE  equ       1 
0002                151  erCRASH   equ       2 
0003                152  erIDPAR   equ       3 
0004                153  erCKSUM   equ       4 
0005                154  erTXCOL   equ       5 
0006                155  erRX      equ       6 
0007                156  erIDSTOP  equ       7 
0008                157  erSYNC    equ       8 
0009                158  erRXOVR   equ       9 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 6  Win32 Assembler
                                LINCST.ASM

000A                159  erSHORT   equ       10 
000B                160  erTORESP  equ       11 
000C                161  erBRFRM   equ       12 
000F                162  erWKUPINIT  equ       15 
                    163  
0000                164  cnfAUTO   equ       0 
0001                165  cnfSRATE  equ       1 
                    166  
                    167  ;---------------------------
                    168  ;Error Sub Codes
                    169  ;---------------------------
0001                170  erSYNClo  equ       1 
0002                171  erSYNChi  equ       2 
0003                172  erSYNCsbhi  equ       3 
0004                173  erSYNCbhi  equ       4 
0005                174  erSYNChead  equ       5 
                    175  
0000                176  erCRASHIT  equ       0 
0001                177  erCRASHPLL  equ       1 
0002                178  erCRASHTX  equ       2 
                    179  
0001                180  erRXSTART  equ       1 
0002                181  erRXSTOP  equ       2 
                    182  
0001                183  verLIN    equ       1 
0002                184  verEDIT   equ       2 
                    185  
                    186  ;---------------------------
                    187  ;Mark Instruction Codes
                    188  ;---------------------------
                    189  ;msb set if xdma is following the xdcom
                    190  ;group A : errors, reset - x00x xxxx
0001                191  dcRST     equ       1                  ;01h
0002                192  dcWAIT    equ       2                  ;02h
0083                193  dcERROR   equ       131                ;83h
0004                194  dcBREAKER  equ       4                 ;04h
0005                195  dcSLEEP   equ       5                  ;05h
0006                196  dcERRORDEL  equ       6                ;06h
0086                197  dcVER     equ       134                ;86h
0087                198  dcEDIT    equ       135                ;87h
                    199  ;group B : dialog Mlx4/Mlx16, unrecognized ID - x01x xxxx
00A6                200  dcEVENT   equ       166                ;A6h
00A7                201  dcCOMMAND  equ       167               ;A7h
00A8                202  dcID      equ       168                ;A8h
                    203  ;group C : break, sync, byte - x10x xxxx
004A                204  dcBREAK   equ       74                 ;4Ah
00CB                205  dcSYNC    equ       203                ;CBh
004C                206  dcSTART   equ       76                 ;4Ch
004D                207  dcSTOP    equ       77                 ;4Dh
00CE                208  dcDATA    equ       206                ;CEh
00CF                209  dcDATATX  equ       207                ;CFh
                    210  ;fast protocol
0050                211  dcFAST    equ       80                 ;50h: enter fast protocol
0051                212  dcFASTSOF  equ       81                ;51h: start of frame received
00D2                213  dcFASTBYTE  equ       210              ;D2h: byte received
00D3                214  dcFASTTX  equ       211                ;D3h: byte sent
00D5                215  dcFASTPCI  equ       213               ;D5h: PCI received
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 7  Win32 Assembler
                                LINCST.ASM

                    216  ;wake-up and auto-addressing
0054                217  dcWAKEUP  equ       84                 ;54h: wake up pulse sent
0055                218  dcAUTOADD  equ       85                ;55h: auto-addressing pulse sent
                    219  ;debug
00D4                220  dcDEBUG   equ       212                ;D4h
                    221  
                    222  ;---------------------------
                    223  ;Tword access mode
                    224  ;---------------------------
0000 U              225  #IFDEF    COLIN_MODULE  
00A0                228  regTword  equ       {0A0h or 00h}      ; 0 for other cases
0000                229  #ENDIF    
                    230            
                    231  ;end
0000                 43            #ENDIF    
                     44  
                     45  ;--------------- Compiler Switches ----------------
                     46  ;enable or disable part of the code
0000                  0            #include  "switches.asm" 
                      1  ; ---------------------------------------------------------------------------
                      2  ;
                      3  ; Description:
                      4  ;  LIN Firmware Compiler Switches for the Mlx4
                      5  ;
                      6  ; File:        $Source: /home/tester/cvs2git/cvs/mulan2_platform/libsrc/Mlx4/switches.asm,v $
                      7  ; Created:     May 17th, 2011
                      8  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                      9  ; Updated:     $Date: 2014-03-14 17:12:05 $
                     10  ;              $Author: yso $
                     11  ; Revision:    $Revision: 1.15 $
                     12  ;              $Name:  $
                     13  ;
                     14  ; Copyright (c) Melexis Digital Competence Center
                     15  ;
                     16  ; ---------------------------------------------------------------------------
                     17  
                     18  
                     19  ; ---------------------------------------------------------------------------
                     20  ;  These switches values can be configured
                     21  ; ---------------------------------------------------------------------------
                     22  ;coFastStdAlne           equ cvON\cvOFF              ;Enable/Disable Stand Alone 'Enter Programming Mode' Command in Fast Mode
                     23  ;CFG_PLL_FREQ            equ 12\20\22\24[MHz]        ;Mlx4 clock frequency
                     24  ;coTIMEOUT               equ TO13\TO2X               ;Decide to use 1.3 or 2.X standard for RX timeout detection
                     25  ;CFG_SLEEP_TO            equ 13_9600\13_19200\LIN20  ;Define idle bus time before to fall asleep, the switch decide on the standard to follow
                     26  ;coFASTFLASH             equ cvON\cvOFF              ;Enable the fast protocol for flash loading (include lin2b_fastflash.asm)
                     27  ;coDEBUGMARK             equ cvON\cvOFF              ;Enable debugging by mark instructions
                     28  
0001                 29  coDEBUGMARK  equ       cvON            ;Enable debugging by mark instructions
                     30  ; Other switches values defined into Makefile
                     31  
                     32  
                     33  ; ---------------------------------------------------------------------------
                     34  ;  These switches values are hard coded for MLX4 and can't be configured
                     35  ; ---------------------------------------------------------------------------
                     36  ;coFILTMODE              equ IDFILT  ;FRAME : no filtering, the application receives all the LIN ID and decides what to do
                     37  ;                                    ;IDFILT: mapping between LIN ID and INDEX, parameters of each INDEX and LIN ID are defined
                     38  ;                                    ;in rom tables and can be partially changed into RAM."
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 8  Win32 Assembler
                                SWITCHES.ASM

                     39  ;coREDUCERAM             equ cvOFF   ;Amount of space alocated to private Mlx4 RAM.
                     40  ;                                    ;The final value will depends on the amount of switches removed and final value of each of them
                     41  ;coBRCOOL                equ cvON    ;Enable AutoAddressing feature: cvON, cvOFF
                     42  ;coSLEEPMODE             equ cvON    ;Sleep Mode enabled: cvON, cvOFF
                     43  ;coSLEEPAUTO             equ cvON    ;Sleep Mode Command Auto-detect (3C-00): cvON, cvOFF
                     44  ;coWAKEUP                equ cvON    ;Enable Wake-Up pulse generation capabilities: cvON, cvOFF
                     45  ;coWAKEUPSHORT           equ cvON    ;Enable the detection of a short if a wake-up pulse is too long: cvON, cvOFF
                     46  ;coBRCORR                equ cvON    ;Enable baudrate correction: cvON, cvOFF
                     47  ;coIDBANK2               equ cvON    ;Enable the second set of configurable IDs in Identifier Filtering Mode: cvON, cvOFF
                     48  ;                                    ;if coIDBANK2 is off, the configurable IDs are limited to 8, if it is on, to 16.
                     49  ;coFUNCFILT              equ cvOFF   ;Enable Functional Filtering : Enable/Disable Flag and/or QR Messages: cvON, cvOFF
                     50  ;coFILTQR                equ cvOFF   ;Enable QR Messages: cvON, cvOFF (assumes coFUNCFILT eq cvON)
                     51  ;coPARAMLT               equ cvON    ;Enable light parameters: no filtering (assumes coFUNCFILT eq cvOFF)
                     52  ;coIDINIT                equ cvOFF   ;ID Table Initialization for ROM Table: cvON, cvOFF
                     53  ;coBRFRM                 equ cvON    ;Signal a Break in Frame (this is always detected, even if the switch is off): cvON, cvOFF
                     54  ;coFLSHLD                equ cvON    ;Enable Flash Loading Protocol detection: cvON, cvOFF
                     55  ;coPROPMEAS              equ cvON    ;Enable the measurement of the propagation time during TX: cvON, cvOFF
                     56  ;coSTOPBREAK             equ cvON    ;Enable to skip the stop bit error signaling in case a valid break is detected: cvON, cvOFF
                     57  ;
                     58  ;coRSVD5AA5              equ cvON    ;First code word is 5AA5 (cvON) or A55A (cvOFF)
                     59  ;
                     60  ;coPLLCHK                equ cvOFF   ;Enable the check of the PLL status: cvON, cvOFF
                     61  ;coCMD_OPTION            equ cvON    ;Enable the pcOPTION command support
                     62  ;coCMD_SFTVER            equ cvON    ;Enable the pcSFTVER command support
                     63  ;coCMD_GETST             equ cvON    ;Enable the pcGETST command support
                     64  ;coCMD_ACK               equ cvON    ;Do an acknowledge of the commands from the Mlx16 (cvON) or use the erCSYNC message (cvOFF)
                     65  ;
                     66  ;coSPECIALID             equ cvOFF   ;Enable processing of special ID (3D, 3D, 3E, 3F) without accessing the rom tables: cvON, cvOFF
                     67  ;coQR0_USED_BY_3D_FRAME  equ cvOFF   ;Enable use for QR code for special IF 3D
                     68  ;
                     69  ;coFASTFLASHCK           equ cvON    ;Checksum of the Fast Protocol checked or not - DEBUG, default is cvON
                     70  ;coFASTFLASHCKTX         equ cvOFF   ;Checksum of the Fast Protocol checked or not for TX messages - DEBUG, default is cvOFF
                     71  ;coFASTFLASHDBG          equ cvOFF   ;Flash Loading Fast Protocol - DEBUG, default is cvOFF
                     72  ;coFastDb                equ cvON    ;Enable/Disable Fast Edges
                     73  ;coFastCmd               equ cvON    ;Enable/Disable the reception of commands during the RX loop
                     48  
                     49  ;--------------- Far ROM Tables -------------------
                     50  ;access : configure Txtab[5:2] (in MemTab 2)
                     51  ; dcom MemTab,0FDh      ;11 1111 01
                     52  ;                              \  \
                     53  ;                               \  Txtab[1:0] = 01 (ored with arom[7:6])
                     54  ;                               Txtab[5:2] = 1111 (replace arom[11:8])
                     55  ;
                     56  ; arom : DDDD DDXX XXAA
                     57  ;               \    \ \
                     58  ;                \    \ 2 MSBs of A - the 2 LSBs select the nibble
                     59  ;                 \    X
                     60  ;                  dcom MemTab (see above)
                     61  
0000                 62  TableRom  equ       0 
                     63  
00EA                 64  INDXtable  equ       {_INDXtbl shr 7} or 0C0h 
0008                 65  INDXtableX  equ       {_INDXtbl shr 3} and 0Fh 
0000                 66            %assert   {_INDXtbl and 63} eq 0 ;Make sure that INDXtbl is 6 byte address lsb aligned
                     67  
00EB                 68  PARAMtable  equ       {_PARAMtbl shr 7} or 0C0h 
0000                 69  PARAMtableX  equ       {_PARAMtbl shr 3} and 0Fh 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 9  Win32 Assembler
                                LIN2B.ASM

0000                 70            %assert   {_PARAMtbl and 63} eq 0 ;Make sure that PARAMtbl is 6 byte address lsb aligned
                     71  
00EB                 72  AUTOADDtable  equ       {_AUTOADDtbl shr 7} or 0C0h 
0000                 73            %assert   {_AUTOADDtbl and 7} eq 0 ;Make sure that AUTOADDtbl is 3 byte address lsb aligned
0008                 74  AUTOADDtableX  equ       {_AUTOADDtbl shr 3} and 0Fh 
                     75  
                     76  ;--------------------------------------------------
                     77  
0000                 78            words     
                     79  
                     80  ;--------------- linker informations --------------
                     81            segment   word at 0-FFF 'all' ;The total memory map consist of:
0000                 82            contains  'reserved'         ;- reserved locations (at 0..3)
0000                 83            contains  'task0vects'       ;- vectors of task 0 (at 4..7)
0000                 84            contains  'task1vects'       ;- vectors of task 1 (at 8..0Bh)
0000                 85            contains  'code'             ;- normal code (no placement requirements)
                     86  
                     87  ;--------------- RAM mapping ----------------------  <- mapping to review!!
0000                 88            bytes                        ;RAM addresses are 8 bits wide
                     89  
                     90                                         ;local variables of the LIN task:
                     91            segment   byte at 0-9F 'LIN private' 
                     92  ;----------------------- blocs of 16 nibbles
0000                 93  LINevendTX  ds.b      1                ;x x x x
                     94                                         ; \ \ \ \
                     95                                         ;  \ \ \ End TX event must to be sent
                     96                                         ;   \ \ unused
                     97                                         ;    \ unused
                     98                                         ;     unused
0001                 99  LINst     ds.b      1                  ;current state of the LIN task (4 bits)
0002                100  LINbr     ds.b      2                  ;LIN Br register : 2 nibbles (8 bits) - even address so the lsb is 0
0004                101  LINbrNom  ds.b      2                  ;LIN Nominal BaudRate : like LINbr above, but should NEVER change, except during cnfBR
0006                102  LINpresc  ds.b      1                  ;Value for the prescaler A used with LINbr
0007                103  LINprescNom  ds.b      1               ;Value for the prescaler A used with LINbrNom
0008                104  LINbytbuf  ds.b      2                 ;Byte buffer
000A                105  LINchksum  ds.b      2                 ;Message checksum temporary buffer
000C                106  LINindex  ds.b      2                  ;LIN index for ID Filtering Mode, or LIN ID for Frame Processing Mode
                    107                                         ;LIN index for ID Filtering Mode : 0 means the ID has been recognized in RAM; 1, 2, 3 the ID is in ROM
                    108                                         ;or LIN ID 2 msbs for Frame Processing Mode. 1xxx : indicates that the ID is not defined
000E                109  LINIDtmp  ds.b      2                  ;Memorized ID received/processed
                    110  ;-----------------------
0010                111  LIN_IDs   ds.b      12                 ;User set IDs (bank 1)
001C                112  LIN_IDsInit  ds.b      2               ;Index Initialized Flag (bank 1)
001E                113  LINindxbk1  ds.b      1                ;Index result (bank 1)
001F                114  LINindxbk2  ds.b      1                ;Index result (bank 2)
                    115  ;-----------------------
0020                116  LIN_IDs2  ds.b      12                 ;User set IDs (bank 2)
002C                117  LIN_IDsInit2  ds.b      2              ;Index Initialized Flag (bank 2)
002E                118  indx2_tmp  ds.b      2                 ;Index Compare 2 temporary buffer
                    119  ;-----------------------
0030                120  LINtocnt  ds.b      4                  ;Time Out counter (low nibble) - updated at each Tbit during the databytes
0034                121  LINdbg    ds.b      2                  ;Debug (mark instructions)
0036                122  LINtoref  ds.b      2                  ;Time Out reference (low nibble) - calculated when message length is known
0038                123  LINmessbuf  ds.b      1                ;Message buffer
0039                124  LINbytcnt  ds.b      1                 ;Counter used to know how many data bytes have been received
003A                125  MessStatus  ds.b      1                ;Message status
                    126                                         ;x x x x
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 10  Win32 Assembler
                                LIN2B.ASM

                    127                                         ; \ \ \ \
                    128                                         ;  \ \ \ waiting for instruction from Mlx16
                    129                                         ;   \ \ start bit already received
                    130                                         ;    \ indicates that a bit time has passed after the ID (allow immediate start of TX)
                    131                                         ;     message information received
003B                132  LINerrStat  ds.b      1                ;LIN error status flags
                    133                                         ;x x x x
                    134                                         ; \ \ \ \
                    135                                         ;  \ \ \ data stop bit error detected
                    136                                         ;   \ \ wake-up pulse detected (do not handle the break)
                    137                                         ;    \ collision error detected
                    138                                         ;     ID stop bit error detected
003C                139  SleepTimeOut  ds.b      2              ;Used to count the sleep timeouts (access to the analog periphery)
003E                140  ClearByte  ds.b      2                 ;Byte used to clear registers with a dma
                    141  ;-----------------------
0040                142  LINbrcpt  ds.b      5                  ;Break counter
0045                143  LINparity  ds.b      1                 ;Store the temporary values of the ID parity calculation - used only during the ID byte reception
0046                144  highsync  ds.b      3                  ; 3 nibbles for high baudrate margin calculation at every sync bit, record the longest individual bit
0049                145  lowsync   ds.b      3                  ; 3 nibbles for low baudrate margin calculation at every sync bit, record the shortest individual bit
004C                146  LINmesslen  ds.b      1                ;Message length
004D                147  LINstopbit  ds.b      1                ;Stop bit counter (TX area)
004E                148  LINtmp    ds.b      2                  ;Temporary Byte for DMA accesses
                    149  ;-----------------------
0050                150  LINbrsync  ds.b      4                 ;16-bits timer, used to determine the bit period from the SYNC field
0054                151  LINbrhicpt  ds.b      4                ;Break delimiter counter
0058                152  LINbrtmp  ds.b      3                  ;Used for break length calculations
005B                153  LINparam  ds.b      1                  ;x x x x
                    154                                         ; \ \ \ \
                    155                                         ;  \ \ \ Not Used
                    156                                         ;   \ \ ID recognized in Index table
                    157                                         ;    \ 0=TX, 1=RX
                    158                                         ;     checksum : 0=regular (without ID field), 1=enhanced (with ID field)
005C                159  LINbrflag  ds.b      1                 ;Autobaudrate flag
                    160                                         ;x x x x
                    161                                         ; \ \ \ \
                    162                                         ;  \ \ \ edge to be processed
                    163                                         ;   \ \ not used
                    164                                         ;    \ baudrate detected
                    165                                         ;     auto baudrate on every frame
005D                166  LINtxbytlen  ds.b      1               ;Length of the bytes (with the stop bits) (TX area)
                    167  
005E                168  LINstatus  ds.b      1                 ;x x x x
                    169                                         ; \ \ \ \
                    170                                         ;  \ \ \ LIN bus activity
                    171                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                    172                                         ;    \ not used
                    173                                         ;     event overflow occured
                    174  
005F                175  LINflashStatus  ds.b      1            ;x x x x
                    176                                         ; \ \ \ \
                    177                                         ;  \ \ \ programming mode
                    178                                         ;   \ \ continuous frames coming up
                    179                                         ;    \ not used
                    180                                         ;     not used
                    181  
                    182  ;-----------------------
0060                183  ParamBuf  ds.b      2                  ;ID Parameters buffer, to get data from the ROM
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 11  Win32 Assembler
                                LIN2B.ASM

0062                184  indx1_tmp  ds.b      2                 ;Index Compare temporary buffer
                    185  
0064                186  LINoptions1  ds.b      1               ;Options for the Mlx4 soft
                    187                                         ;       x x xx
                    188                                         ;        \ \  \
                    189                                         ;         \ \  header stop bit length (for Slave to Master messages) : 0, 0.5, 1, 1.5 + 1 stop bits
                    190                                         ;          \ stop bits between databytes during TX : 0 or 1 + 1 stop bit -> 1 or 2
                    191                                         ;           not used
0065                192  LINoptions2  ds.b      1               ;Options for the Mlx4 soft
                    193                                         ;       x x x x
                    194                                         ;        \ \ \ \
                    195                                         ;         \ \ \ state change masked (1)
                    196                                         ;          \ \ not used
                    197                                         ;           \ deep sleep (1) / light sleep (0)
                    198                                         ;            not used
                    199  
0066                200  AutoAddPrsc  ds.b      2 
0068                201  AutoAddPrCnt  ds.b      2 
                    202  
006A                203  LINbrLSBs  ds.b      1                 ;xxx 0
                    204                                         ;   \ \
                    205                                         ;    \ always 0 (that means LINbrcorr LSB should always be 0 too)
                    206                                         ;     SYNC field LSBs used for fine-tuning
006B                207  LINbrcorr  ds.b      1                 ;xxx x
                    208                                         ;   \ \
                    209                                         ;    \ 0 : correction not done, 1 : baudrate correction just done
                    210                                         ;     accumulated baudrate correction value, correct the baudrate if a carry is generated
                    211  
006C                212  AutoAddMode  ds.b      1               ;Auto adressing mode  x x x x
                    213                                         ; \ \ \ \
                    214                                         ;  \ \ \ within generation
                    215                                         ;   \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                    216                                         ;    \ auto addressing always enabled
                    217                                         ;     not used
006D                218  AutoAddEv  ds.b      1                 ;Auto addressing event number
006E                219  AutoAddCpt  ds.b      1                ;Auto addressing (de)-counter
006F                220  LINframeflag  ds.b      1              ;x x x x
                    221                                         ; \ \ \ \
                    222                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                    223                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                    224                                         ;    \ discard the frame
                    225                                         ;     frame data ready for transmit
                    226  ;-----------------------
0070                227  Atmp      ds.b      1                  ;Temporary buffer
0071                228  Btmp      ds.b      1                  ;Temporary buffer
0072                229  Xtmp      ds.b      1                  ;Temporary buffer
0073                230            #IF       cvON eq cvON       ;Fast Flash Loading enabled
0073                231  ffSTATUS  ds.b      1                  ;Fast Flash Loading Status
                    232                                         ;x x xx
                    233                                         ; \ \  \
                    234                                         ;  \ \  break detection step nr (3=found)
                    235                                         ;   \ 1 : protocol setting
                    236                                         ;    1 : response requested
0074                237            #ELSE     
0074                240  unused2   ds.b      12                 ;memory free, can be used if future needs
                    241  ;----------------------- 
                    242  ;0x7F ---------- end of access by DMA ------------------------------
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 12  Win32 Assembler
                                LIN2B.ASM

                    243  ;0x7F ---------- end of reserved memory space ----------------------
                    244  ;0x80 ---------- locations used for inter-task communication -------
                    245            segment   byte at 80-8F 'LIN API' 
                    246  
0080                247  LINresp   ds.b      4                  ;0xA0 : MLX4 -> MLX16 Command Response
0084                248  LINcmnd   ds.b      4                  ;0xA4 : MLX16 -> MLX4 Command
0088                249  LINmess   ds.b      6                  ;0xA8 : MLX4 -> MLX16 Events
008E                250  LINID     ds.b      2                  ;0xAE : MLX4 -> MLX16 LIN Protected Identifier
                    251            segment   byte at 90-9F 'LIN Frame' 
0090                252  LINframe  ds.b      16                 ;0xB0 to 0xBF (0xE158 to 0xE15F) : LIN frame : up to 8 bytes (checksum calculated automaticaly)
                    253  
                    254  ;0x9F ---------- end of inter-task memory space ----------------------
                    255  
                    256  ;--------------- reserved memory locations and vector table
                    257  
00A0                258            words                        ;ROM addresses are 16 bits wide
                    259  
                    260            segment   word at 0 'reserved' ;reserved memory locations in ROM
                    261  
                    262                                         ; 5AA5h is a signature of valid program in extrnal memory (RAM)
                    263                                         ; Image with such signature can be put into both RAM and ROM
0000   5AA5         264            dc.w      5AA5h              ;ROM address 0 -- signature of valid image (MLX16 reads this as 0xA55A word)
0001   A55A         265            dc.w      0A55Ah             ;ROM address 1
0002   0000         266            dc.w      0                  ;ROM address 2 is reserved
0003   0000         267            dc.w      0                  ;ROM address 3 is reserved
                    268  
                    269            segment   word at 4 'task0vects' ;vector table of task 0
0004 U 0020         270            jmp       task0_por          ;power-on reset vector of task 0
0005 U 0020         271            jmp       task0_por          ;task reset vector of task 0
0006 U 0020         272            jmp       task0_er           ;external interrupt vector of task 0, should not be possible
0007 U 0020         273            jmp       task0_er           ;attention interrupt vector of task 0, should not be possible
     U              274  
                    275            segment   word at 8 'task1vects' ;vector table of task 1
0008   0000         276            dc.w      0 
0009   0000         277            dc.w      0 
000A   0000         278            dc.w      0 
000B   0000         279            dc.w      0 
                    280  
                    281  ;--------------- ROM tables -----------------------
                    282            segment   word at 0C 'code'  ;normal code (no calls into this code)
                    283  
                    284  ;--------------------------------------------------
                    285  ;Mlx4 Software Version
                    286  ;LIN Software
                    287  ;revision code of this file
                    288  ; SoftVersion : xxxxxxxx x xxx xxxx
                    289  ;                       \ \   \    \
                    290  ;                        \ \   \    rev (0 to 15) -> for the LIN software : ver.rev [LIN2revASM]
                    291  ;                         \ \   ver (0 to 7) [LIN2verASM]
                    292  ;                          \ stable (1) / in dvt (0) [LIN2dvtASM]
                    293  ;                          [EditNbr]
                    294  ; FlashVersion : 00000000 x xxx xxxx
                    295  ;                         \   \    \
                    296  ;                          \   \    rev (0 to 15) -> for the flash loader : ver.rev [LIN2revFLSH]
                    297  ;                           \   ver (0 to 7) [LIN2verFLSH]
                    298  ;                            stable (1) / in dvt (0) [LIN2dvtFLSH]
                    299  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 13  Win32 Assembler
                                LIN2B.ASM

                    300  
000C                301            %assert   LIN2revASM le 15 
000C                302            %assert   LIN2verASM le 7 
000C                303            %assert   LIN2dvtASM le 1 
000C                304            %assert   EditNbr le 255 
000C                305            %assert   LIN2revFLSH le 15 
000C                306            %assert   LIN2verFLSH le 7 
000C                307            %assert   LIN2dvtFLSH le 1 
                    308  
000C   0041         309  SoftVersion  dc.w      {{EditNbr shl 8} or {LIN2dvtASM shl 7} or {LIN2verASM shl 4} or LIN2revASM} 
000D   0020         310  FlashVersion  dc.w      {{LIN2dvtFLSH shl 7} or {LIN2verFLSH shl 4} or LIN2revFLSH} 
000E   0000         311            dc.w      00000h             ; alignment
000F   0000         312            dc.w      00000h 
                    313  
0010                314            %assert   {SoftVersion and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    315  
                    316  ;State Transition ROM table (refer to "state transition.xls")
                    317  ;    to             stDISC   to stACT   to stSLEEP   to stWKUP
                    318  ;       stDISC  (1)   -         ok          ok          ok
                    319  ; from  stACT   (2)   ok        -           ok          -
                    320  ;       stSLEEP (4)   ok        -           -           ok
                    321  ;       stWKUP  (8)   ok        -           -           -
                    322  ;       invalid       -         -           -           -
                    323  ;                   1110(E)  0001(1)     0011(3)    0101(5)    
                    324  
                    325  ;access: and A,Rom:TRANStbl shr 2[X], where X is the targeted state and A the actual state, transission allowed if the result is not 0 
                    326  ;X:       0  1  2  3  4  5  6  7  8  9... F
                    327  ;result   0  E  1  0  3  0  0  0  5  0...
0010   E001         328  TRANStbl  dc.w      0E001h             ;@10h -> 0x0018 (Mlx16)
0011   0300         329            dc.w      00300h             ;@11h -> 0x001A (Mlx16)
0012   0500         330            dc.w      00500h             ;@12h -> 0x001C (Mlx16)
0013   0000         331            dc.w      00000h             ;@13h -> 0x001E (Mlx16)
                    332  
0014                333            %assert   {TRANStbl and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    334  
                    335  ;--------------------------------------------------
                    336  ;TO14tbl : table used to calculate the message maximum response in bit times (timeout)
                    337  ;Tmessage_maximum = 1.4 * 10 * (Ndata + 1)
                    338  ;A value of 1 is added because the timeout should be fine is the response time is exactly the maximum
                    339  ;A value of 20 is added to respect the standard whatever the length of the header is
                    340  ;number of byte/2 is added due to the measurment error (+/- 1/2 Tbit)
                    341  ;access: mov X,Rom:TO14tbl shr 2[B] for the low nibble, where B is the message length minus 1 (0-7) shifted to the left
                    342  ;        add B,#1 to get the high nibble
                    343  ;        mov X,Rom:TO14tbl shr 2[B] for the high nibble
                    344  ;B:            0  1  2  3  4  5  6    7
                    345  ;result (dec) 29 43 57 71 85 99 113 127
                    346  ;result (hex) 1D 2B 39 47 55 63  71  7F
                    347  ;result + 1   1E 2C 3A 48 56 64  72  80
                    348  ;result +20   32 40 4E 5C 6A 78  86  94
                    349  ;result +l/2  33 42 50 5F 6D 7C  8A  99
0014   3342         350  TO14tbl   dc.w      03342h             ;@14h -> 0x0020 (Mlx16)
0015   505F         351            dc.w      0505Fh             ;@15h -> 0x0022 (Mlx16)
0016   6D7C         352            dc.w      06D7Ch             ;@16h -> 0x0024 (Mlx16)
0017   8A99         353            dc.w      08A99h             ;@17h -> 0x0026 (Mlx16)
                    354  
0018                355            %assert   {TO14tbl and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    356  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 14  Win32 Assembler
                                LIN2B.ASM

                    357  ;TO10tbl : table used to calculate the maximum response time when a message has to be sent
                    358  ;Tresponse_maximum = Tmessage_maximum - Tmessage_length
                    359  ;                  = 1.4 * 10 * (Ndata + 1) - 10 * (Ndata + 1) - Ndata * Additional_StopBit
                    360  ;                  = 0.4 * 10 * (Ndata + 1) - Ndata * Additional_StopBit
                    361  ; Ndata * Additional_StopBit will have to be substracted in the processing
                    362  ; Timeout is multiplied by 2 since we are counting at every half Tbit in TX
                    363  ;access: mov X,Rom:TO10tbl shr 2[B] for the low nibble, where B is the message length minus 1 (0-7) shifted to the left
                    364  ;        add B,#1 to get the high nibble
                    365  ;        mov X,Rom:TO10tbl shr 2[B] for the high nibble
                    366  ;B:            0  1  2  3  4  5  6  7
                    367  ;result (dec)  8 12 16 20 24 28 32 36
                    368  ;result (hex) 08 0C 10 14 18 1C 20 24
                    369  ;result - message length in case of 2 stop bit
                    370  ;result - l   07 0A 0D 10 13 16 19 1C  
                    371  ;result *2    0E 14 1A 20 26 2C 32 38
0018   0E14         372  TO10tbl   dc.w      00E14h             ;@18h -> 0x0028 (Mlx16)
0019   1A20         373            dc.w      01A20h             ;@19h -> 0x002A (Mlx16)
001A   262C         374            dc.w      0262Ch             ;@1Ah -> 0x002C (Mlx16)
001B   3238         375            dc.w      03238h             ;@1Bh -> 0x002E (Mlx16)
                    376  
001C                377            %assert   {TO10tbl and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    378  
                    379  ;--------------- ROM-table constants ------------------------------------------------------------------
001C                  0            #include  "cst_rom_tables.asm" 
                      1  ; ---------------------------------------------------------------------------
                      2  ;
                      3  ; Description:
                      4  ;   Timing constant defined in ROM-tables (link-time configuration)
                      5  ;   Fosc = 250 kHz (fixed)
                      6  ;
                      7  ; File:        $Source: /home/tester/cvs2git/cvs/mulan2_platform/libsrc/Mlx4/cst_rom_tables.asm,v $
                      8  ; Created:     June 13th, 2005
                      9  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                     10  ; Updated:     $Date: 2014-03-14 17:12:06 $
                     11  ;              $Author: yso $
                     12  ; Revision:    $Revision: 1.8 $
                     13  ;              $Name:  $
                     14  ;
                     15  ; Copyright (c) Melexis Digital Competence Center
                     16  ;
                     17  ; ---------------------------------------------------------------------------
                     18  
                     19  ; Defines for CFG_SLEEP_TO
001C                 20  #define   coLIN20_ANY  1 
001C                 21  #define   coLIN13_9600  2 
001C                 22  #define   coLIN13_19200  3 
                     23  
                     24  ; Defines for CFG_PLL_FREQ
001C                 25  #define   coPLL_12MHZ  1 
001C                 26  #define   coPLL_18MHZ  2 
001C                 27  #define   coPLL_20MHZ  3 
001C                 28  #define   coPLL_24MHZ  4 
001C                 29  #define   coPLL_25MHZ  5 
001C                 30  #define   coPLL_28MHZ  6 
001C                 31  #define   coPLL_30MHZ  7 
001C                 32  #define   coPLL_32MHZ  8 
                     33  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 15  Win32 Assembler
                                CST_ROM_TABLES.ASM

                     34  ;Constant tables
                     35  
                     36  ;--------------------------------------------------------------------------------------------------
                     37  ; Sleep Timeout (depends on Fosc frequency)
                     38  ;
                     39  ; With an oscillator at Fosc, the formula is:
                     40  ;	Sleep_timeout = (1/Fosc) * 2^(9+SleepPre_Val) * (16 + SleepCnt_Val) * (256 / SleepCntInc)
                     41  ;
                     42  ; Notes:
                     43  ;   1. Use the biggest SleepCnt_Val possible -> (4 bits = 15)
                     44  ;   2. Sleep timeout is not used by fast protocol
                     45  ;
                     46  ;SleepPre_Val or 8 (enable bit)	=> Rom:ConstantTbl shr 2[0]
                     47  ;SleepCnt_Val                   => Rom:ConstantTbl shr 2[1]
                     48  ;SleepCntInc	                => Rom:ConstantTbl shr 2[2]
                     49  
                     50  ConstantTbl  
                     51  
001C                 52  #IF       0         eq 0 
001C                 53  #IF       1         eq 1 
001C   0802          54            dc.w      00802h             ;  [1][0][3][2] ; TO = 4.19 seconds = 4.00 + 4.9%
                     55  
001D                 56  #ELIF     1         eq 2 
001D                 66  #ELSE     
                     71  
                     72  
001D                 73            %assert   {ConstantTbl and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                     74  
                     75  ;--------------------------------------------------------------------------------------------------
                     76  ; Wake-up detection (depends on F_PLL frequency)
                     77  ;
                     78  ; Use 50us as a base interval, i.e. set baudrate counter to 20 kbps in sleep mode
                     79  ;
                     80  ; ( 2^(SleepDelayPre + 1) * SleepDelayCnt) / F_PLL = 50 us
                     81  ;
                     82  ; SleepDelayPre is caPresc (value between 0 and 11)
                     83  ; SleepDelayCnt is caBaud  (value is between 99 and 200)
                     84  
                     85  ;SleepDelayPre                  => Rom:ConstantTbl shr 2[4]
                     86  ;SleepDelay                     => Rom:ConstantTbl shr 2[5]
                     87  ;SleepDelayCnt                  => Rom:ConstantTbl shr 2[6] and Rom:ConstantTbl shr 2[7]
                     88  
                     89  ; Delay used before entering the sleep mode after reception of a sleep command (x50us)
                     90  ; NOTE: it is possible to use 10kbps as baudrate and to double SleepDelay and WUPlsMinimum
                     91  ;or to change each value idependantely
                     92  ;SleepDelay		equ 5	= Rom:ConstantTbl shr 2[5]
                     93  
001D                 94  #IF       0         eq 0 
                     95  
001D                 96            #IF       5 eq 1 
001D   529C         109            dc.w      0529Ch             ; [5][4][7][6] -- for 25MHz
                    110  
001E                111            #ELIF     5 eq 6 
001E                124  #ELSE     
                    129  
                    130  ; Minimum length of a wake-up pulse (x50us)
                    131  ;WUPlsMinimum	equ 3	;150us 	= Rom:ConstantTbl shr 2[8] and Rom:ConstantTbl shr 2[9]
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 16  Win32 Assembler
                                CST_ROM_TABLES.ASM

                    132  
                    133  ; Maximum length of a wake-up pulse (x50us)
                    134  ;WUPlsMaximum	equ 111 = 6Fh	;5ms	= Rom:ConstantTbl shr 2[A] and Rom:ConstantTbl shr 2[B]
                    135  
001E   036F         136            dc.w      0036Fh             ;   [9][8][B][A]; not used by fast protocol
                    137  
                    138  ;--------------------------------------------------------------------------------------------------
                    139  ; MLX4 watchdog (depends on Fosc frequency)
                    140  ; Wdg_timeout = (1/Fosc) * 2^(2+WatchPre_Val) * (16 + WatchPre_Cnt)
                    141  ;
                    142  ;WatchPre_Val	equ 7	= Rom:ConstantTbl shr 2[E] ; Since WatchPre_Val is used to enable the timer (msb to 1), set the msb -> 15
                    143  ;WatchPre_Cnt	equ 15	= Rom:ConstantTbl shr 2[F]
                    144  
                    145  ;--------------------------------------------------------------------------------------------------
                    146  ; Wake-up pulse generation (depends on baud-rate settings)
                    147  ; -> Pulses width #WuPlsCnt# is 5Tbit (between 250us and 5ms)
                    148  ;Pulses width : 5Tbit
                    149  ;WuPlsCnt		equ 5	= Rom:ConstantTbl shr 2[C]
                    150  
                    151  ;--------------------------------------------------------------------------------------------------
                    152  ; PLL config (if any)
                    153  ;PLL: delay to check the PLL (see coPLLCHK switch)
                    154  ; -- number of retries to start the PLL
                    155  ;PLLattempt		equ 3	= Rom:ConstantTbl shr 2[D]
                    156  
001F   35FF         157            dc.w      035FFh             ;   [D][C][F][E]
                    158  
                    159  ; -- counter to wait for the PLL to lock
                    160  ;PLLcnt_lo		equ 0	= Rom:ConstantTbl2 shr 2[0]
                    161  ;PLLcnt_hi		equ 14	= Rom:ConstantTbl2 shr 2[1]
                    162  ; -- counter to do a second check after the PLL has started
                    163  ;PLLchk_lo		equ 0	= Rom:ConstantTbl2 shr 2[2]
                    164  ;PLLchk_hi		equ 14	= Rom:ConstantTbl2 shr 2[3]
                    165  
0020   E0E0         166  ConstantTbl2  dc.w      0E0E0h         ;   [1][0][3][2]
                    167  
0021                168            %assert   {ConstantTbl2 and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    169  
                    170  ;--------------------------------------------------------------------------------------------------
                    171  ; Wake-up request generation (depends on Fosc)
                    172  ; -> Pulses width #WuPlsCnt# is 5Tbit (between 250us and 5ms)
                    173  ; -> Pause 150 ms between two pulses #WuPause#
                    174  ; -> Pause 1.5 s before another pulse sequence #WeSeq#
                    175  ;
                    176  ; WuPause = (1/Fosc) * 2^(9+WuPausePre_Val) * (16 + WuPauseCnt_Val)
                    177  ;
                    178  ; WeSeq   = (1/Fosc) * 2^(9+WuSeqPre_Val)   * (16 + WuSeqPre_Val)
                    179  ;
                    180  
                    181  ;Pause Length : 150ms (exactly 180ms, i.e. +20%) - used with the Sleep Timer
                    182  ;WuPauseCnt_Val	equ 6	= Rom:ConstantTbl2 shr 2[4]
                    183  ;WuPausePre_Val	equ 2	= Rom:ConstantTbl2 shr 2[5] ;Since WuPausePre_Val is used to enable the timer (msb to 1), set the msb -> 10
                    184  
                    185  ;Sequence Pause Length : 1.5s (exactly 1.77s, i.e. +18%) - used with the Sleep Timer
                    186  ;WuSeqCnt_Val	equ 11	= Rom:ConstantTbl2 shr 2[6]
                    187  ;WuSeqPre_Val	equ 5	= Rom:ConstantTbl2 shr 2[7] ;Since WuSeqPre_Val is used to enable the timer (msb to 1), set the msb -> 14
                    188  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 17  Win32 Assembler
                                CST_ROM_TABLES.ASM

0021   A6DB         189            dc.w      0A6DBh             ;   [5][4][7][6]; not used by fast protocol
                    190  
0022   0000         191            dc.w      0                  ;   [9][8][B][A]
                    192  
                    193  ;not used                       => Rom:ConstantTbl2 shr 2[C]
                    194  ;not used                       => Rom:ConstantTbl2 shr 2[D]
                    195  ;MinPresc                       => Rom:ConstantTbl2 shr 2[E]
                    196  ;not used                       => Rom:ConstantTbl2 shr 2[F]
                    197  
0023                198  #IF       0         eq 0 
0023                199            #IF       5 eq 1 
0023   0002         212            dc.w      00002h             ;   [D][C][F][E]
                    213  
0024                214            #ELIF     5 eq 6 
0024                227  #ELSE     
                    232  
                    233  
0024                234  #IF       cvON      eq cvON 
                    235  ;--------------------------------------------------
                    236  ;CRC Tables for the Fast Protocol
                    237  ;index is 1032
0024   A07D         238  ffCrcTblHi  dc.w      0A07Dh 
0025   0AD7         239            dc.w      00AD7h 
0026   E439         240            dc.w      0E439h 
0027   4E93         241            dc.w      04E93h 
0028   E0D3         242  ffCrcTblLo  dc.w      0E0D3h 
0029   97A4         243            dc.w      097A4h 
002A   1F2C         244            dc.w      01F2Ch 
002B   685B         245            dc.w      0685Bh 
                    246  
002C                247            %assert   {ffCrcTblHi and 3} eq 0 ;Make sure the last 2 bits of the table are 0
002C                248            %assert   {ffCrcTblLo and 3} eq 0 
                    249  
                    250                                         ;Constants
                    251  ;ffPrescA		equ 15	= Rom:FastCstTbl shr 2[0]
                    252  ;ffPrescB		equ 1	= Rom:FastCstTbl shr 2[1]
                    253  
                    254  ;Baudrate counter
                    255  ;
                    256  ; Note: fast protocol baud rate (values defined by ffPrescA, ffBaudCntLo and ffBaudCntHi)
                    257  ;       is set at run time now. Values ffPrescA, ffBaudCntLo and ffBaudCntHi are not used anymore
                    258  ;
                    259  ;When the Split signal is set, the baudrate counter is divided in 2 parts : Cpt[5:0] and Cpt[7:6] (see MSBi spec)
                    260  ;At 125kbps the baudrate value is 120, which is 3x40. We put 40 in Cpt[5:0] and 2 in Cpt[7:6] (so from 0 to 2 there are 3 increments)
                    261  ;Br = 10 10 1000
                    262  ;Br = 0xA8
                    263  ;For IntBr, the higher part of the counter is 1 more than for Br. IntBr = 11 101000 = 0xE8
                    264  ;ffBaudCntLo	equ  8	= Rom:FastCstTbl shr 2[2]
                    265  ;ffBaudCntHi	equ 10	= Rom:FastCstTbl shr 2[3]
                    266  ;ffIntBaudCntHi	equ ffBaudCntHi + 4	calculated
                    267  
002C   1FA8         268  FastCstTbl  dc.w      01FA8h           ;[1][0][3][2]; 125kpbs @ 30MHz
                    269  
                    270  
002D                271            %assert   {FastCstTbl and 3} eq 0 ;Make sure the last 2 bits of the table are 0
                    272  
                    273  ;NAD : broadcast (0x7F)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 18  Win32 Assembler
                                CST_ROM_TABLES.ASM

                    274  ;ffNADhi		equ 7	= Rom:FastCstTbl shr 2[5]
                    275  ;ffNADlo		equ 15	= Rom:FastCstTbl shr 2[4]
                    276  
                    277  ;SID : B4 (Data Dump)
                    278  ;ffSID_DDhi		equ 11	= Rom:FastCstTbl shr 2[7]
                    279  ;ffSID_DDlo		equ 4	= Rom:FastCstTbl shr 2[6]
                    280  
002D   7FB4         281            dc.w      07FB4h             ; [5][4][7][6]
                    282  
                    283  ;SID : B2 (Read by Identifier)
                    284  ;ffSID_RBIhi	equ 11	= Rom:FastCstTbl shr 2[9]
                    285  ;ffSID_RBIlo	equ 2	= Rom:FastCstTbl shr 2[8]
                    286  
002E   B200         287            dc.w      0B200h             ; [9][8][B][A]
002F                288  #ENDIF    
                    289  
                    290  ;--- EOF
                    381  
                    382  ;--------------- parameters validity check (checked by the linker)
002F                383            %assert   {LINbr and 1} eq 0 ;LINbr should be aligned at an even address
002F                384            %assert   {LINbrNom and 1} eq 0 ;LINbrNom should be aligned at an even address
002F                385            %assert   {LINtmp and 1} eq 0 ;LINtmp (temporary buffer) should be aligned at an even address
002F                386            %assert   {LINbytbuf and 1} eq 0 ;LINbytbufl should be aligned at an even address
002F                387            %assert   {LINchksum and 1} eq 0 ;LINchksum should be aligned at an even address
002F                388            %assert   {LINtocnt and 1} eq 0 ;LINtocnt should be aligned at an even address
002F                389            %assert   {LINmess and 1} eq 0 ;LINmess should be aligned at an even address
002F                390            %assert   {LINframe and 15} eq 0 ;LINframe should be aligned at an address that ends with 0000b
002F                391            %assert   {ClearByte and 1} eq 0 ;ClearByte should be aligned at an even address
002F                392            %assert   {SleepTimeOut and 1} eq 0 ;SleepTimeOut should be aligned at an even address
                    393  
002F                394            %assert   {LINoptions1 and 1} eq 0 ;LINoptions1 should be aligned at an even address
002F                395            %assert   {MessStatus and 1} eq 0 ;MessStatus should be aligned at an even address
                    396  
002F                397            %assert   {indx1_tmp and 1} eq 0 ;indx1_tmp should be aligned at an even address
002F                398            %assert   {LIN_IDs and 15} eq 0 ;LIN_IDs should be aligned at an address that ends with 0000b
002F                399            %assert   {ParamBuf and 15} eq 0 ;ParamBuf should be aligned at an address that ends with 0000b
002F                400            %assert   {LIN_IDs2 and 15} eq 0 ;LIN_IDs2 should be aligned at an address that ends with 0000b
002F                401            %assert   {indx2_tmp and 1} eq 0 ;indx2_tmp should be aligned at an even address
                    402  
002F                403            %assert   {LINbrsync and 15} eq 0 ;LINbrsync should be aligned at an address that ends with 0000b
002F                404            %assert   {LINbrcpt and 1} eq 0 ;LINbrcpt should be aligned at an even address
002F                405            %assert   {LINbrhicpt and 1} eq 0 ;LINbrhicpt should be aligned at an even address
002F                406            %assert   {LINbrtmp and 1} eq 0 ;LINbrtmp should be aligned at an even addresses
                    407  
002F                408            %assert   {AutoAddPrsc and 1} eq 0 ;AutoAddPrsc should be aligned at an even address
002F                409            %assert   {AutoAddPrCnt and 1} eq 0 ;AutoAddPrCnt should be aligned at an even address
                    410  
                    411  ;----------------------------------------------------------------------------------------------------------------------
                    412  ;--------------- code -------------------------------------------------------------------------------------------------
                    413  ;----------------------------------------------------------------------------------------------------------------------
                    414  
                    415  ;MACRO : access to analog periphery for MelexCM bug (Mlx16 stack overflow)
002F M              416  AnalogAccess  macro     
     M              417                                         ;do an access to the analog
     M              418            dcom      AnIo,11000011b     ;1 abc 0 hi j
     M              419                                         ;            \
     M              420                                         ;             RWB : read analog IO address 0hiabc
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 19  Win32 Assembler
                                LIN2B.ASM

002F                421  
                    421            mend      
                    422  
                    423  ;-------------- FAST PROTOCOL -----------------------------------------------------------------------------------------
                    424  fastprotocol                           ;FAST FLASH LOADING
002F                425            #IF       cvON eq cvON 
002F                426            #IF       coDEBUGMARK eq cvON 
002F   507C         427            xdcom     #dcFAST            ;mark instruction
0030                428            #ENDIF    
0030 U              429            #IFDEF    USE_RELATIVE_PATH 
0030                  0            #include  "lin2b_fastflash.asm" 
                      1  ; ---------------------------------------------------------------------------
                      2  ;
                      3  ; Description:
                      4  ;  Fast Flash Loading Protocol
                      5  ;
                      6  ; File:        $Source: /var/cvsmucontrol/Projects/lin/mls_sw/source/lin2b_fastflash.asm,v $
                      7  ; Created:     August 31st, 2007
                      8  ;      by:     Benoit Michel, Melexis (bem@melexis.com)
                      9  ; Updated:     $Date: 2014/12/02 13:41:59 $
                     10  ;              $Author: beh $
                     11  ; Revision:    $Revision: 1.4 $
                     12  ;              $Name:  $
                     13  ;
                     14  ; Copyright (c) Melexis Digital Competence Center
                     15  ;
                     16  ; ---------------------------------------------------------------------------
                     17  
                     18  ;RAM
                     19  ;LINframeflag : x x x x
                     20  ;                \ \ \ \
                     21  ;                 \ \ \ not used
                     22  ;                  \ \ not used
                     23  ;                   \ discard the frame
                     24  ;                    frame data ready for transmit
                     25  ;ffSTATUS : x x xx (Fast Flash Loading Status)
                     26  ;            \ \  \
                     27  ;             \ \  break detection step nr (3=found)
                     28  ;              \ 1 : protocol setting
                     29  ;               1 : response requested
                     30  ;LINflashStatus : x x x x
                     31  ;                  \ \ \ \
                     32  ;                   \ \ \ programming mode
                     33  ;                    \ \ continuous frames coming up
                     34  ;                     \ not used
                     35  ;                      not used
                     36  ;------------------------------------------------------------------------------------
                     37  
                     38                                         ;------------------------------------------------------------------------------------
                     39                                         ;the PLL should be started
                     40  
                     41  ff_init                                ;set the MSBi cell
                     42                                         ; Configuration Registers : Cfg0 (0x3A) and Cfg1 (0x3B)
0030   87B7          43            mov       A,#7 
0031   3A77          44            mov       io:1Ah,A           ;Cfg0 : 0111
                     45                                         ; NoCk = 0
                     46                                         ; Split = 1
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 20  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                     47                                         ; RptSync = 1
                     48                                         ; Piped = 1
0032   8EB7          49            mov       A,#14 
0033   3B77          50            mov       io:1Bh,A           ;Cfg1 : 1110
                     51                                         ; Mode 11 (PWM)
                     52                                         ; FCan/Clkd/MArb = 1
                     53                                         ; CanL/Diffm = 0
                     54  
                     55                                         ;stop the counter to stop outputting data
0034   9037          56            dcom      7,90h              ;1 0 01 0000
                     57                                         ;   \  \    \
                     58                                         ;    \  \    nop
                     59                                         ;     \  clear Run
                     60                                         ;      no capture
                     61  
                     62                                         ; Input Bloc : InpCtrl (dcom 4, msb 1), DbCpt (0x3C)
0035   E934          63            dcom      4,0E9h             ;InpCtrl
                     64                                         ;1 1 10 1 0 0 1
                     65                                         ;   \ \    \ \ \
                     66                                         ;    \ \    \ \ EnFdb=1: enable fast debounce (BusIn is debounced on a 2/3 majority vote scheme)
                     67                                         ;     \ \    \ Fbin=0: flag reset (Bin = slow debounced BusIn))
                     68                                         ;      \ \    AutoDb=0: flag set (DbCk devided by the 4 msb's of the Br register)
                     69                                         ;       \ RbErr=10: flag reset (IntSplBin selected)
                     70                                         ;        Rst=1
                     71  
                     72                                         ; Prescaler and Baudrate :
                     73                                         ; SendBaudRate should have been called in the Mlx16 prior to switching to the fast loader mode
                     74                                         ; - PrescA is already programmed
                     75                                         ; - LINbr and LINbr+1 contain the baudrate values (ffBaudCntHi and ffBaudCntLo), the dmar should be called to
                     76                                         ;   program the MSBi cell
                     77  
                     78                                         ; Prescaler Bloc : PrescA (0x3E) and PrescB (0x3F)
0036   81B7          79            mov       A,#1 
0037   6FB7          80            mov       A,Rom:FastCstTbl shr 2[A] 
0038   3F77          81            mov       io:1Fh,A           ;PrescB
                     82  
                     83                                         ; Baudrate generator
0039   024C          84            dmar      #0,LINbr 
003A   03B2          85            mov       B,LINbr+1 
003B   03B3          86            mov       A,LINbr+1          ;save the initial value
003C   8486          87            add       B,#4               ;ffIntBaudCntHi
003D   0372          88            mov       LINbr+1,B          ;LINbr doesn't change for IntBr
003E   034C          89            dmar      #0,LINbr+1 
003F   0373          90            mov       LINbr+1,A          ;restore the correct value of LINbr
0040   0E38          91            dcom      8,0Eh              ;00 00 1110
                     92                                         ;      Edg[2:0]=010: Fast Falling Edge
                     93                                         ;generates an ExEvt when a BrMatch occurs
0041   0739          94            dcom      9,07h              ;00 00 0111
                     95                                         ;  \  \    \
                     96                                         ;   \  \    BrPls[1:0]=11: InBrCk-Halfmatch; BrCk-IntMatch; AuxCk-AuxMatch
                     97                                         ;    \  RptCap : nop
                     98                                         ;     Capt : nop
                     99                                         ;Sync window
0042   0A32         100            dcom      2,0Ah              ;10 00 00 1010
                    101                                         ;  \  \  \    \
                    102                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                    103                                         ;    \  \  SiCk: nop
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 21  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                    104                                         ;     \  FlStRj: nop
                    105                                         ;      StpCpt = 0
                    106                                         ;StatCtrl - TimeOut source
0043   0A34         107            dcom      4,0Ah              ;StatCtrl
                    108                                         ;0 0 00 1010
                    109                                         ;   \  \    \
                    110                                         ;    \  \    load ToEn[2:0]=010 : LTimeOut driven only by IntBr (halfmatch)
                    111                                         ;     \  reset Ftfr : nop
                    112                                         ;      reset internal flags: nop
                    113  
                    114                                         ;initialize the periphery
0044   AC3E         115            dcom      14,0ACh            ;Hspeed = 1 (set the Bypass signal)
                    116                                         ;dcom Flags,{04h or ML_SLEWFAST}    ;Phymod = ML_SLEWFAST - done on the Mlx16 or in fast2b.asm
                    117  
                    118                                         ;disable the timers from the periphery
0045   163B         119            dcom      11,16h             ;00 01 01 10
                    120                                         ;     \  \  \
                    121                                         ;      \  \  Sleep Timer TimeOut setting
                    122                                         ;       \  \   0x : no effect
                    123                                         ;        \  \  10 : disable the timeout
                    124                                         ;         \  \ 11 : enable the timeout
                    125                                         ;          \  Message Timer :stop the message timer
                    126                                         ;           Sleep Timer Run Command
                    127                                         ;            00 : no effect
                    128                                         ;            01 : stop the sleep timer
                    129                                         ;            10 : restart the sleep timer
                    130                                         ;            11 : reload and restart the sleep timer - clears SleepStat
                    131  
0046   3037         132            dcom      7,30h              ;StuffCtrl: set OutMd, ignore the stuffing part
                    133                                         ;0 0 11 0000
                    134                                         ;     \
                    135                                         ;      OutMd loaded with '1'
                    136  
0047 U 0060         137  ff_reinit  call      ff_msbi_rx        ;change the registers that have been changed during TX
     U              138  
     U              139  ff_rxinit                              ;initialize the registers
0048   80B6         140            mov       B,#0               ;reset the following registers
0049   7372         141            mov       ffSTATUS,B 
                    142  
                    143                                         ;call ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                    144  
                    145  ff_newstart                            ;B=0 when jumping here
004A   3E4D         146            dmar      #1,ClearByte       ;use the dma to clear the byte
004B   0A49         147            dmaw      LINchksum,#1 
004C   3972         148            mov       LINbytcnt,B 
004D   6F72         149            mov       LINframeflag,B 
004E   82B5         150            mov       X,#2 
004F   4C71         151            mov       LINmesslen,X       ;2 bytes : PCI + Command
                    152                                         ;------------------------------------------------------------------------------------
0050   88B5         153  ff_rxloopinit  mov       X,#8          ;X is used as a bit counter
                    154                                         ;do not start the counter until there is a falling edge
                    155                                         ;here, we must issue 2 stop instructions since if a Br match appens at the same time, the counter does not stop and it results to a fail of the communication.
0051   9037         156            dcom      7,90h              ;1 0 01 0000
                    157                                         ;   \  \    \
                    158                                         ;    \  \    nop
                    159                                         ;     \  clear run flag, stop the counter
                    160                                         ;      no capture of Br into IntBr
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 22  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                    161            
0052   0000         162            nop                          ;make sur the counter is stopped
0053   0000         163            nop                          ;add 2 nops to be sure that the two stop instructions are executed at a different cnt value even if presca is 1.
                    164            
                    165                                         ;make sur the counter is stopped
0054   9037         166            dcom      7,90h              ;1 0 01 0000
                    167                                         ;   \  \    \
                    168                                         ;    \  \    nop
                    169                                         ;     \  clear run flag, stop the counter
                    170                                         ;      no capture of Br into IntBr
                    171                                         ;set the Sync window
0055   0A32         172            dcom      2,0Ah              ;10 00 00 1010
                    173                                         ;  \  \  \    \
                    174                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                    175                                         ;    \  \  SiCk: nop
                    176                                         ;     \  FlStRj: nop
                    177                                         ;      StpCpt = 10: reset StpCpt
                    178  
                    179  ff_rxloop                              ;RX : this is the loop to receive the data bits
                    180                                         ;X is used as a bit counter
                    181                                         ;LINbytcnt is used to count the bytes received
0056   0A58         182            wait      TimeOut,Event 
0057 U 0009         183            jtime     ff_rxto            ;Half bit match is generated
0058 U 0020         184            jmp       ff_cmd             ;command received
     U              185  ff_rxto                                ;check the the bus (and reset the flags / acknowledge the event!)
0059 U 0060         186            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
005A   7072         187            mov       Atmp,B 
                    188                                         ; Auxiliary Input bloc
005B   37B6         189            mov       B,io:17h           ;PWM=1 and NoCk=0
                    190                                         ; x x x x
                    191                                         ;  \ \ \ \
                    192                                         ;   \ \ \ set at falling edge
                    193                                         ;    \ \ on Brmatch, set with Bin
                    194                                         ;     \ set at rising edge
                    195                                         ;      SplBin: level on the bus
005C   73B3         196            mov       A,ffSTATUS         ; x x xx : Fast Flash Loading Status
                    197                                         ;  \ \  \
                    198                                         ;   \ \  break detection step nr (3=found)
                    199                                         ;    \ 1 : protocol setting
                    200                                         ;     1 : response requested
005D   83BF         201            and       A,#3 
005E   83E7         202            cmp       A,#3               ;test if a start of frame has already been received
005F U 0011         203            jnz       ff_rxto_brk 
0060 U 0020         204            jmp       ff_testbit 
     U              205  
     U              206  ff_rxto_brk                            ;Let's search for a valid break, pattern 0 0 1 at br match
     U              207                                         ;Header Step 0: 0 --> B=xx0x
     U              208                                         ;Header Step 1: 0 --> B=0000     1 --> B=11x0 --> DONE
     U              209                                         ;Header Step 2: 1 --> B=11xx --> DONE
0061   036C         210            switch    A 
0062 U 0020         211            jmp       ff_rxto_brk_st0 
0063 U 0020         212            jmp       ff_rxto_brk_st1 
0064 U 0020         213            jmp       ff_rxto_brk_st2 
0065   5020         214            jmp       ff_rxloopinit 
                    215  
0066   80E6         216  ff_rxto_brk_st1  cmp       B,#0 
0067 U 0011         217            jnz       ff_rxto_brk_st1b 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 23  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

0068   82B7         218            mov       A,#2 
0069 U 0020         219            jmp       ff_rxto_brk_end 
006A   88A6         220  ff_rxto_brk_st1b  msk       B,#8 
006B U 0011         221            jnz       ff_rxto_brk_err 
006C   81B7         222            mov       A,#1 
006D U 0020         223            jmp       ff_rxto_brk_end 
     U              224  
     U              225  ff_rxto_brk_st0                        ;and B,#2
     U              226                                         ;cmp B,#0
006E   70B2         227            mov       B,Atmp 
006F   88A6         228            msk       B,#8 
0070 U 0011         229            jnz       ff_rxto_brk_err 
0071   81B7         230            mov       A,#1 
0072 U 0020         231            jmp       ff_rxto_brk_end 
     U              232  
0073   8CBE         233  ff_rxto_brk_st2  and       B,#12 
0074   8CE6         234            cmp       B,#12 
0075 U 0011         235            jnz       ff_rxto_brk_err 
0076 U 0020         236            jmp       ff_rxto_brk_fin 
     U              237  
0077   80B7         238  ff_rxto_brk_err  mov       A,#0 
0078   7373         239            mov       ffSTATUS,A 
0079   5020         240            jmp       ff_rxloopinit 
                    241  
007A   7373         242  ff_rxto_brk_end  mov       ffSTATUS,A 
007B   5620         243            jmp       ff_rxloop 
                    244  
007C   83B7         245  ff_rxto_brk_fin  mov       A,#3 
007D   7373         246            mov       ffSTATUS,A 
                    247                                         ;do an access to the analog
                    248            AnalogAccess  
                    417                                         ;do an access to the analog
007E   C33C         418            dcom      12,11000011b       ;1 abc 0 hi j
                    419                                         ;            \
                    420                                         ;             RWB : read analog IO address 0hiabc
007F   5020         249            jmp       ff_rxloopinit 
                    250  
                    251  ff_cmd                                 ;check the command
0080   84B3         252            mov       A,LINcmnd 
0081   85B2         253            mov       B,LINcmnd+1 
0082   8073         254            mov       LINresp,A 
0083                255            #IF       coDEBUGMARK eq cvON 
0083   3473         256            mov       LINdbg,A           ;save for xdma
0084   3572         257            mov       LINdbg+1,B         ;save for xdma
0085   A77C         258            xdcom     #dcCOMMAND         ;mark instruction
0086   347D         259            xdma      LINdbg             ;send the command sent by the application
0087                260            #ENDIF    
                    261  
0087   036C         262            switch    A 
0088 U 0020         263            jmp       ff_cmd_ack_ok      ;0 - pcNONE : No commands in the buffer
0089 U 0020         264            jmp       ff_cmd_stch        ;1 - pcSTCH : General command for LIN state changes
008A U 0020         265            jmp       ff_cmd_ack_nok     ;2 - Command not supported
008B U 0020         266            jmp       ff_cmd_ack_nok     ;3 - Command not supported
008C U 0020         267            jmp       ff_cmd_ack_nok     ;4 - pcTX : Transmit the current message (Frame Processing Mode)
008D U 0020         268            jmp       ff_cmd_setframe    ;5 - pcSETFRAME : Discard the current message (Frame Processing Mode) / Set DATAREADY bit / modify continous frame flag
008E U 0020         269            jmp       ff_cmd_ack_nok     ;6 - Command not supported
008F U 0020         270            jmp       ff_cmd_ack_nok     ;7 - Command not supported
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 24  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

0090 U 0020         271            jmp       ff_cmd_ack_nok     ;8 - Command not supported
0091 U 0020         272            jmp       ff_cmd_ack_nok     ;9 - Command not supported
0092 U 0020         273            jmp       ff_cmd_ack_nok     ;A - Command not supported
0093 U 0020         274            jmp       ff_cmd_ack_nok     ;B - Command not supported
0094 U 0020         275            jmp       ff_cmd_ack_nok     ;C - Command not supported
0095 U 0020         276            jmp       ff_cmd_ack_nok     ;D - Command not supported
0096 U 0020         277            jmp       ff_cmd_ack_nok     ;E - Command not supported
0097 U 0020         278            jmp       ff_cmd_rel_buf     ;F - pcRELBUF : Release frame buffer
     U              279  
     U              280  ff_cmd_rel_buf                         ;Release buffer command received ==> to set/reset programming mode bit
0098   82A6         281            msk       B,#2 
0099 U 0011         282            jnz       ff_cmd_rel_buf_end 
009A   5FB3         283            mov       A,LINflashStatus   ;x x x x
                    284                                         ; \ \ \ \
                    285                                         ;  \ \ \ programming mode
                    286                                         ;   \ \ continuous frames coming up
                    287                                         ;    \ not used
                    288                                         ;     QR code disabled (1) or enabled (0)
009B   8EBF         289            and       A,#14 
009C   81A6         290            msk       B,#1 
009D U 0001         291            jz        ff_cmd_rel_buf_wr 
009E   81F7         292            or        A,#1 
                    293  ff_cmd_rel_buf_wr  
009F   5F73         294            mov       LINflashStatus,A 
                    295  ff_cmd_rel_buf_end  
00A0 U 0020         296            jmp       ff_cmd_ack_ok 
     U              297  
     U              298  ff_cmd_setframe                        ;--- Set Frame Command -------------------------------------------------------
     U              299                                         ;B=0 : discard frame
     U              300                                         ;B=1 : data ready
     U              301                                         ;B=2 : cont frame
00A1   82E6         302            cmp       B,#2 
00A2 U 0011         303            jnz       ff_cmd_stch_err 
00A3   86B2         304            mov       B,LINcmnd+2 
                    305                                         ;set/reset continuous frame flag
00A4   5FB3         306            mov       A,LINflashStatus   ;x x x x
                    307                                         ; \ \ \ \
                    308                                         ;  \ \ \ programming mode
                    309                                         ;   \ \ continuous frames coming up
                    310                                         ;    \ not used
                    311                                         ;     QR code disabled (1) or enabled (0)
00A5   82F7         312            or        A,#2 
00A6   81E6         313            cmp       B,#1 
00A7 U 0001         314            jz        ff_cmd_setfr_end 
     U              315                                         ;clear continuous frame flag
00A8   8DBF         316            and       A,#13 
                    317                                         ;reset the status flags as we came out of cont mode which does not do this
00A9   80B6         318            mov       B,#0 
00AA   7372         319            mov       ffSTATUS,B 
                    320  ff_cmd_setfr_end  
00AB   5F73         321            mov       LINflashStatus,A 
00AC U 0020         322            jmp       ff_cmd_ack_ok 
     U              323  
00AD   81E6         324  ff_cmd_stch  cmp       B,#stDISC       ;check if this is an exit command
00AE U 0011         325            jnz       ff_cmd_stch_err    ;invalid command
00AF U 0020         326            jmp       restart            ;stDISC - reinit for lin2b.asm
00B0 U 0020         327  ff_cmd_stch_err  jmp       ff_cmd_ack_nok 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 25  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

     U              328  
     U              329  ff_cmd_ack_ok                          ;Send acknowledge event to MLX16
00B1   80B7         330            mov       A,#ackOK 
00B2 U 0020         331            jmp       ff_cmd_respond     ;send event
     U              332  
     U              333  ff_cmd_ack_nok                         ;Send acknowledge event to MLX16
00B3   81B7         334            mov       A,#ackERR 
                    335  ff_cmd_respond                         ;release the command buffer to be ready for the next command
00B4   8173         336            mov       LINresp+1,A 
00B5   0454         337            ack       event 
00B6   5620         338            jmp       ff_rxloop 
                    339  
                    340  ff_testbit                             ;start bit already received : test if this is a valid bit
00B7   81A6         341            msk       B,#1               ;B = AuxIn
00B8 U 0011         342            jnz       ff_getbit 
     U              343                                         ;no falling edge detected : invalid bit
00B9   70B2         344            mov       B,Atmp 
00BA   88A6         345            msk       B,#8               ;test the bus level
00BB U 0011         346            jnz       ff_jmprxloop       ;keep trying to receive a bit
00BC   4820         347            jmp       ff_rxinit          ;re-init the reception, probably we are receiving a new frame
                    348  ff_getbit                              ;valid bit, store it
00BD   9646         349            rlc       B                  ;get SplBin in the carry
                    350                                         ;store the bit received in the byte buffer
00BE U 0060         351            call      shift_bytbuf       ;LINbytbuf+1 is in A, LINbytbuf in B
     U              352                                         ;update the bit counter (register X)
00BF   81C5         353            sub       X,#1 
00C0 U 0001         354            jz        ff_bytrcvd         ;check if the byte has been received completely
00C1   5620         355  ff_jmprxloop  jmp       ff_rxloop 
                    356  ff_bytrcvd                             ;a byte has been received (it is in LINbytbuf (B) / LINbytbuf+1 (A)), send a mark and update the byte counter
00C2                357            #IF       coDEBUGMARK eq cvON 
                    358                                         ;xdcom #dcFASTBYTE      ;mark instruction
                    359                                         ;xdma LINbytbuf         ;send the byte received
00C2                360            #ENDIF    
00C2   39B1         361            mov       X,LINbytcnt        ;update the byte counter
00C3   4CE1         362            cmp       X,LINmesslen       ;test if the message has been completely received (in that case the data in LINbytbuf is the CRC)
00C4 U 0011         363            jnz       ff_storedata 
00C5 U 0020         364            jmp       ff_messrcvd        ;do not store the CRC
     U              365  ff_storedata                           ;store the byte received
00C6   9245         366            asl       X                  ;multiply the counter by 2
00C7   E576         367            mov       data:LINframe shr 4[X],B ;store the low nibble
00C8   8185         368            add       X,#1 
00C9   E577         369            mov       data:LINframe shr 4[X],A ;store the high nibble
00CA   1645         370            rrc       X                  ;restore the counter
00CB   8185         371            add       X,#1               ;increment it
00CC   3971         372            mov       LINbytcnt,X 
                    373                                         ;update the CRC
00CD U 0060         374            call      ff_crc_calc        ;do CRC calculation, the high nibble just received is already in A, low nibble in B
     U              375  
00CE   81E5         376            cmp       X,#1               ;test if this is the first byte (PCI)
00CF U 0011         377            jnz       ff_jmp_rxinit 
     U              378                                         ;the PCI has been received
00D0                379            #IF       coDEBUGMARK eq cvON 
                    380                                         ;send a mark and process it
00D0   D57C         381            xdcom     #dcFASTPCI         ;mark instruction
00D1   087D         382            xdma      LINbytbuf          ;send the byte received
00D2                383            #ENDIF    
                    384                                         ;restore A and X : the high nibble is in A, the low nibble in X
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 26  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

00D2   08B2         385            mov       B,LINbytbuf        ;no need to restore the byte received, as if this is the PCI, LINchksum was 0
00D3   09B3         386            mov       A,LINbytbuf+1 
00D4   4E73         387            mov       LINtmp,A           ;save the high part of the PCI (use LINtmp)
00D5   83A7         388            msk       A,#3               ;test if this is a Single Frame
00D6 U 0011         389            jnz       ff_pci_nosf 
     U              390  
     U              391                                         ;memorize if this is a protocol setting and if a response if requested
00D7   8CBF         392            and       A,#12              ;discard the two LSBs
00D8   73F3         393            or        A,ffSTATUS         ; x x xx : Fast Flash Loading Status
                    394                                         ;  \ \  \
                    395                                         ;   \ \  break detection step nr (3=found)
                    396                                         ;    \ 1 : protocol setting
                    397                                         ;     1 : response requested
00D9   7373         398            mov       ffSTATUS,A 
00DA   4C72         399  ff_savelength  mov       LINmesslen,B  ;save the length (for SF and last frame), length/256 for FF, or frame counter for CF
00DB   5020         400  ff_jmp_rxinit  jmp       ff_rxloopinit ;go get the next byte
                    401  
00DC   7172         402  ff_pci_nosf  mov       Btmp,B          ;save the low part of the PCI for later
00DD   83BF         403            and       A,#3 
00DE   81E7         404            cmp       A,#1               ;test if this is a First Frame
00DF U 0001         405            jz        ff_pci_ff 
00E0   87B6         406            mov       B,#7               ;Continuous Frame or Last Frame
00E1   DA20         407            jmp       ff_savelength 
00E2   86B6         408  ff_pci_ff  mov       B,#6 
00E3   DA20         409            jmp       ff_savelength 
                    410                                         ;------------------------------------------------------------------------------------
                    411  ff_messrcvd                            ;message received
                    412                                         ;stop the counter (070830)
00E4   9037         413            dcom      7,90h              ;1 0 01 0000
                    414                                         ;   \  \    \
                    415                                         ;    \  \    nop
                    416                                         ;     \  stop the counter
                    417                                         ;      no capture
                    418                                         ;re-open the sync window for slow speed (50kbps) - bem 080221
00E5   0A30         419            dcom      0,0Ah              ;00 00 00 1010
                    420                                         ;  \  \  \    \
                    421                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                    422                                         ;    \  \  SiCk: nop
                    423                                         ;     \  FlStRj: nop
                    424                                         ;      StpCpt: nop
                    425  
                    426                                         ;check the CRC, CRC is in LINbytbuf (B) / LINbytbuf+1 (A)
00E6 U 0060         427            call      ff_crc_calc        ;do CRC calculation, the high nibble just received is already in A, low nibble in B
00E7   80EF         428            cmpcz     A,#0               ;the result should be zero if the CRC is correct (Z already contains the result of B)
00E8 U 0001         429            jz        ff_cksumok 
     U              430                                         ;CRC error
00E9   84B6         431            mov       B,#erCKSUM         ;CRC error
00EA U 0060         432            call      errev              ;send the event
00EB   3020         433            jmp       ff_init 
                    434  ff_cksumok                             ;CRC valid, prepare the data to be sent to the application
00EC   4EB2         435            mov       B,LINtmp           ;the high part of the PCI is in LINtmp
00ED   83BE         436            and       B,#3               ;test the two LSBs only, discard the two MSBs
00EE   4E72         437            mov       LINtmp,B 
00EF   026C         438            switch    B 
00F0 U 0020         439            jmp       ff_single          ;xx00 : single frame
00F1 U 0020         440            jmp       ff_first           ;xx01 : first frame
00F2 U 0020         441            jmp       ff_cont            ;xx10 : continuous frame
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 27  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

00F3 U 0020         442            jmp       ff_last            ;xx11 : last frame (not in the LIN protocol)
     U              443  ff_first                               ;First Frame
     U              444                                         ;--------------------
     U              445                                         ;byte 0 (index 0-1):   Special PCI -> NAD
     U              446                                         ;byte 1 (index 2-3):   Length     -> PCI
     U              447                                         ;byte 2 (index 4-5):   Command     -> LEN
     U              448                                         ;byte 3 (index 6-7):   Data 1      -> SID
     U              449                                         ;byte 4 (index 8-9):   Data 2      -> Command (Data 1)
     U              450                                         ;byte 5 (index 10-11): Data 3      -> Data 1 (Data 2)
     U              451                                         ;byte 6 (index 12-13):             -> Data 2 (Data 3)
     U              452                                         ;byte 7 (index 14-15):             -> Data 3 (Data 4)
     U              453                                         ;--------------------
     U              454                                         ;shift the data
00F4   8BB7         455            mov       A,#11              ;index for data 3
00F5   84B5         456            mov       X,#4               ;offset : 4 nibbles
00F6   83B6         457            mov       B,#3               ;last nibble is nibble 3
00F7 U 0060         458            call      ff_buffloop 
     U              459                                         ;store the SID
00F8   87B7         460            mov       A,#7               ;index of the SID
00F9 U 0060         461            call      ff_sid             ;when returning, A=5
     U              462                                         ;store the length
00FA   83B7         463            mov       A,#3               ;index for length
00FB   82B5         464            mov       X,#2               ;offset : 2 nibbles
00FC   81B6         465            mov       B,#1               ;last nibble is nibble 1
00FD U 0060         466            call      ff_buffloop 
     U              467                                         ;store the NAD and the PCI
00FE   83B7         468            mov       A,#3 
00FF U 0020         469            jmp       ff_nadpci 
     U              470  ff_last                                ;Last Frame - same as Continuous Frame but with less data
     U              471                                         ;--------------------
     U              472                                         ;byte 0 (index 0-1):   Special PCI -> NAD
     U              473                                         ;byte 1 (index 2-3):   Data 1      -> PCI
     U              474                                         ;byte 2 (index 4-5):   Data 2      -> Data 1
     U              475                                         ;byte 3 (index 6-7):   Data 3      -> Data 2
     U              476                                         ;byte 4 (index 8-9):   Data 4      -> Data 3
     U              477                                         ;byte 5 (index 10-11): Data 5      -> Data 4
     U              478                                         ;byte 6 (index 12-13): Data 6      -> Data 5
     U              479                                         ;byte 7 (index 14-15):             -> Data 6
     U              480                                         ;--------------------
0100   82B6         481            mov       B,#2 
0101   4E72         482            mov       LINtmp,B           ;save the PCI as a Continuous Frame PCI (LIN compatible)
                    483  ff_cont                                ;Continuous Frame
                    484                                         ;--------------------
                    485                                         ;byte 0 (index 0-1):   Special PCI -> NAD
                    486                                         ;byte 1 (index 2-3):   Data 1      -> PCI
                    487                                         ;byte 2 (index 4-5):   Data 2      -> Data 1
                    488                                         ;byte 3 (index 6-7):   Data 3      -> Data 2
                    489                                         ;byte 4 (index 8-9):   Data 4      -> Data 3
                    490                                         ;byte 5 (index 10-11): Data 5      -> Data 4
                    491                                         ;byte 6 (index 12-13): Data 6      -> Data 5
                    492                                         ;byte 7 (index 14-15):             -> Data 6
                    493                                         ;--------------------
                    494                                         ;shift the data
0102   8DB7         495            mov       A,#13              ;index for data 6
0103   82B5         496            mov       X,#2               ;offset : 2 nibbles
0104   81B6         497            mov       B,#1               ;last nibble is nibble 1
0105 U 0060         498            call      ff_buffloop 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 28  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

0106   83B7         499            mov       A,#3 
0107 U 0020         500            jmp       ff_nadpci 
     U              501  ff_single                              ;Single Frame
     U              502                                         ;--------------------
     U              503                                         ;byte 0 (index 0-1):   Special PCI -> NAD
     U              504                                         ;byte 1 (index 2-3):   Command     -> PCI
     U              505                                         ;byte 2 (index 4-5):   Data 1      -> SID
     U              506                                         ;byte 3 (index 6-7):   Data 2      -> Command (Data 1)
     U              507                                         ;byte 4 (index 8-9):   Data 3      -> Data 1 (Data 2)
     U              508                                         ;byte 5 (index 10-11): Data 4      -> Data 2 (Data 3)
     U              509                                         ;byte 6 (index 12-13):             -> Data 3 (Data 4)
     U              510                                         ;byte 7 (index 14-15):             -> Data 4 (Data 5)
     U              511                                         ;--------------------
     U              512                                         ;prepare the low part of the PCI (length)
0108   4CB2         513            mov       B,LINmesslen 
0109   7172         514            mov       Btmp,B             ;save it for later
                    515  
                    516                                         ;shift the data
010A   8BB7         517            mov       A,#11              ;index for data 4
010B   84B5         518            mov       X,#4               ;offset : 4 nibbles
010C   81B6         519            mov       B,#1               ;last nibble is nibble 3 (command)
010D U 0060         520            call      ff_buffloop        ;when returning, A=3
     U              521                                         ;store the SID
010E   85B7         522            mov       A,#5 
010F U 0060         523            call      ff_sid             ;when returning, A=3
     U              524  
     U              525  ff_nadpci                              ;NAD and PCI are at the same location for all frames (byter 0 and 1)
     U              526                                         ;the NAD is a constant (ffNADhi, ffNADlo), the PCI is in (LINtmp, Btmp)
     U              527                                         ;store the PCI - A should be 3 when jumping to ff_nadpci
0110   4EB2         528            mov       B,LINtmp           ;the high part of the PCI is in LINtmp
0111   71B1         529            mov       X,Btmp             ;low part of the PCI (length, length/256 or frame counter) is in Btmp
0112 U 0060         530            call      ff_fillbuff 
     U              531                                         ;store the NAD
0113   84B5         532            mov       X,#4 
0114   6DB5         533            mov       X,Rom:FastCstTbl shr 2[X] 
0115   85B6         534            mov       B,#5 
0116   6EB6         535            mov       B,Rom:FastCstTbl shr 2[B] 
0117 U 0060         536            call      ff_fillbuff 
     U              537  
     U              538                                         ;send the message to the application (index 10h : 0x3C)
0118   81B7         539            mov       A,#1 
0119   80B6         540            mov       B,#0 
011A   8B73         541            mov       LINmess+3,A 
011B   8A72         542            mov       LINmess+2,B 
011C   83B7         543            mov       A,#evMESSrcvd 
011D   8873         544            mov       LINmess,A 
011E   8972         545            mov       LINmess+1,B        ;(B=0)
011F   0854         546            set       event              ;set the event and proceed while the application is responding
                    547  
                    548                                         ;check ffSTATUS to see if this is a protocol setting or if a response is expected
0120   73B2         549            mov       B,ffSTATUS         ; x x xx : Fast Flash Loading Status
                    550                                         ;  \ \  \
                    551                                         ;   \ \  break detection step nr (3=found)
                    552                                         ;    \ 1 : protocol setting
                    553                                         ;     1 : response requested
0121   88A6         554            msk       B,#8               ;if a response is requested, go to the TX routine
0122 U 0011         555            jnz       ff_txrqst_ini 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 29  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

     U              556                                         ;test if this is a first frame
0123   4EB2         557            mov       B,LINtmp           ;the high part of the PCI is in LINtmp
0124   81E6         558            cmp       B,#1 
0125 U 0001         559            jz        ff_nosof 
     U              560                                         ;test if we have some continuous frames
0126   5FB1         561            mov       X,LINflashStatus   ; x x x x
                    562                                         ;  \ \ \ \
                    563                                         ;   \ \ \ programming mode
                    564                                         ;    \ \ continuous frames coming up
                    565                                         ;     \ not used
                    566                                         ;      not used
0127   82A5         567            msk       X,#2 
0128 U 0001         568            jz        ff_waitsof         ;go wait for the next start of frame
0129   80B6         569  ff_nosof  mov       B,#0 
012A   4A20         570            jmp       ff_newstart        ;continuous frames coming up : no start of frame
012B   4820         571  ff_waitsof  jmp       ff_rxinit 
                    572                                         ;------------------------------------------------------------------------------------
                    573  ff_txrqst_ini                          ;a response is expected
                    574                                         ;initialize the MSBi to detect a falling edge
012C   0638         575            dcom      8,06h              ;00 00 0110
                    576                                         ;      Rst[1:0]=10: reset upon Edg[2:0]
012D   0E38         577            dcom      8,0Eh              ;00 00 1110
                    578                                         ;      Edg[2:0]=010: Fast Falling Edge
                    579  ff_txrqst                              ;wait for the application to fill the buffer (8 bytes)
                    580                                         ;watch the bus to avoid being stuck here
012E   0C58         581            wait      Event,EvExt        ;command or event from the MSBi
012F U 0008         582            jxev      ff_edge            ;external event coming from the MSBi (edge)
0130 U 0060         583            call      cmdrcvd            ;command from the Mlx16 : process it
     U              584                                         ;check if the command indicated that the data is ready
0131   6FB3         585            mov       A,LINframeflag     ;x x x x
0132   88A7         586            msk       A,#8               ; \ \ \ \
                    587                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                    588                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                    589                                         ;    \ discard the frame
                    590                                         ;     frame data ready for transmit
0133 U 0011         591            jnz       ff_tx              ;the command was a pcDTRDY
     U              592                                         ;the command was not a pcDTRDY, check if it is a discard TX command (ml_Discard)
0134   84A7         593            msk       A,#4 
0135 U 0011         594            jnz       ff_canceltx        ;discard command
0136   2E21         595            jmp       ff_txrqst          ;wait for the next command
                    596  ff_edge                                ;an edge has been detected while the data was not ready, go to the RX area
0137 U 0060         597            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0138   84A7         598            msk       A,#4               ;test LEvExt
0139 U 0011         599            jnz       ff_canceltx        ;edge, cancel the TX and go back to RX
013A   2E21         600            jmp       ff_txrqst          ;it wasn't an edge, keep waiting
013B   3020         601  ff_canceltx  jmp       ff_init 
                    602                                         ;------------------------------------------------------------------------------------
                    603  ff_tx                                  ;the data is in the LINframe buffer, it needs to be cleaned up (NAD, RSID removed)
                    604                                         ;reset the CRC buffer - if the CRC was received correctly, it should alreay be 0 (otherwise there was a checksum error)
013C   3E4D         605            dmar      #1,ClearByte       ;use the dma to clear the byte
013D   0A49         606            dmaw      LINchksum,#1 
                    607                                         ;get the high nibble of the PCI to check the kind of frame that has to be sent
013E   82B5         608            mov       X,#2 
                    609  
                    610                                         ;update the CRC
013F U 0060         611            call      GetByteFast        ;get the PCI (A contains LINbytbuf+1), which is the high nibble of the PCI
0140 U 0060         612            call      ff_crc_calc        ;do CRC calculation for the PCI, low nibble is in B, high nibble is in A
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 30  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

0141   08B2         613            mov       B,LINbytbuf        ;restore A and B
0142   09B3         614            mov       A,LINbytbuf+1 
0143   83BF         615            and       A,#3               ;keep only the last two bits (just in case)
0144   036C         616            switch    A                  ;check the kind of frame
0145 U 0020         617            jmp       ff_tx_single       ;0000: Single Frame
0146 U 0020         618            jmp       ff_tx_first        ;0001: First Frame
     U              619                                         ;0010: Continuous Frame ----------
0147   88B6         620            mov       B,#8               ;frame length
0148   81B5         621            mov       X,#1               ;byte counter
0149 U 0020         622            jmp       ff_txinit 
     U              623  ff_tx_first                            ;0001: First Frame ---------------
     U              624                                         ;check the RSID
014A   86B5         625            mov       X,#6               ;index of the RSID
014B U 0060         626            call      ff_chk_rsid 
     U              627                                         ;jz ff_rsid_err         ;if Z is set, the RSID is 0x7F, which means there is an error
     U              628                                         ;move the length at the RSID place
014C   84B5         629            mov       X,#4 
014D   E5B6         630            mov       B,data:LINframe shr 4[X] ;get the LEN (low nibble)
014E   8185         631            add       X,#1 
014F   E5B7         632            mov       A,data:LINframe shr 4[X] 
0150   8185         633            add       X,#1 
0151   E576         634            mov       data:LINframe shr 4[X],B 
0152   8185         635            add       X,#1 
0153   E577         636            mov       data:LINframe shr 4[X],A 
0154   86B6         637            mov       B,#6               ;frame length: 8-2=6, the byte counter is the same as in the single frames
                    638  ff_tx_single                           ;0000: Single Frame --------------
                    639                                         ;check the RSID
0155   84B5         640            mov       X,#4               ;index of the RSID
0156 U 0060         641            call      ff_chk_rsid        ;B is not modified, A and X are
     U              642                                         ;jz ff_rsid_err         ;if Z is set, the RSID is 0x7F, which means there is an error
0157   8286         643            add       B,#2               ;frame length offset
0158   82B5         644            mov       X,#2               ;byte counter, the length is already in B
                    645  
0159   103E         646            dcom      14,10h             ;ForceR=0 : free the bus
                    647  
                    648  ff_txinit                              ;initialize the registers for TX
015A   4C72         649            mov       LINmesslen,B       ;save the frame length
015B   3971         650            mov       LINbytcnt,X        ;save the byte counter
                    651                                         ;----------------------------
                    652                                         ;stop the counter and clear all flags
                    653                                         ;----------------------------
015C   9037         654            dcom      7,90h              ;1 0 01 0000
                    655                                         ;   \  \    \
                    656                                         ;    \  \    nop
                    657                                         ;     \  clear Run
                    658                                         ;      no capture
                    659                                         ;clear F[2:0], Edg[2:0] and SEdg[2:0]
015D   C034         660            dcom      4,0C0h             ;1 1 00 0000
                    661                                         ;   \
                    662                                         ;    Rst=1
                    663  
015E U 0060         664            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
     U              665                                         ;----------------------------
     U              666                                         ;re-initialize the LIN Module
     U              667                                         ;----------------------------
015F   B738         668            dcom      8,0B7h             ;10 11 0111
                    669                                         ;  \  \    \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 31  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                    670                                         ;   \  \    Rst[1:0]=11 : Re-Synch mode : reset upon selected edge or BrMatch pulse
                    671                                         ;    \  load Mdiff and Togl with 1
                    672                                         ;     Init=10: reset Capt
0160   7B35         673            dcom      5,7Bh              ;OutCrtl: initialize the output bloc: X,Y,CpZ,NxZ,Z set - M,N cleared (recessive outputs)
                    674                                         ;011 11 011
                    675                                         ;  \  \   \
                    676                                         ;   \  \   Y loaded with '1', X set
                    677                                         ;    \  Z, Cpz and NxZ loaded with '1'
                    678                                         ;     M and N loaded with '1'
0161   6336         679            dcom      6,63h              ;AuxCtrl - Auxiliary Ouput bloc
                    680                                         ;011 00 011
                    681                                         ;  \  \   \
                    682                                         ;   \  \   V loaded with '1', U set - send pulses ('0' for continuous level) - (EscpB)
                    683                                         ;    \  W, Wd unchanged
                    684                                         ;     K and L loaded with '1'
0162                685            #IF       coDEBUGMARK eq cvON 
                    686                                         ;mark instruction for the first byte only
0162   D37C         687            xdcom     #dcFASTTX          ;mark instruction
0163   087D         688            xdma      LINbytbuf          ;send the byte just sent
0164                689            #ENDIF    
                    690  
                    691                                         ;make sure the counter is stopped
0164   9037         692            dcom      7,90h              ;1 0 01 0000
                    693                                         ;   \  \    \
                    694                                         ;    \  \    nop
                    695                                         ;     \  clear Run
                    696                                         ;      no capture
                    697  ff_txnextbyte                          ;reset the bit counter
0165   80B5         698            mov       X,#0 
                    699  
                    700                                         ;make sure the counter is stopped
                    701                                         ;dcom PlsCtrl,90h        ;1 0 01 0000
                    702                                         ;   \  \    \
                    703                                         ;    \  \    nop
                    704                                         ;     \  clear Run
                    705                                         ;      no capture
                    706                                         ;set the Sync window
0166   0A33         707            dcom      3,0Ah              ;11 00 00 1010
                    708                                         ;  \  \  \    \
                    709                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                    710                                         ;    \  \  SiCk: nop
                    711                                         ;     \  FlStRj: nop
                    712                                         ;      StpCpt = 1
                    713  
                    714                                         ;------------------------------------------------------------------------------------
                    715  ff_txshift                             ;shift the data bits and get the bit to be sent in C
0167   09B3         716            mov       A,LINbytbuf+1 
0168   08B2         717            mov       B,LINbytbuf 
0169   1647         718            rrc       A 
016A   1646         719            rrc       B 
                    720                                         ; THE FOLLOWING DCOM HAS TO OCCUR BEFORE THE BRCK PULSE !!!
016B   6135         721            dcom      5,61h              ;OutCrtl
                    722                                         ;011 00 001
                    723                                         ;  \  \   \
                    724                                         ;   \  \   Y loaded with CoutCpu, X set
                    725                                         ;    \  Z, Cpz and NxZ unchanged
                    726                                         ;     M and N loaded with '1'
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 32  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                    727                                         ;save the data in LINbytbuf
016C   0872         728            mov       LINbytbuf,B 
016D   0973         729            mov       LINbytbuf+1,A 
                    730                                         ;check if we need to check the bus level
016E   81A5         731            msk       X,#1 
016F U 0001         732            jz        ff_txwait 
     U              733                                         ;check the bus level
0170   72B2         734            mov       B,Xtmp 
0171   88A6         735            msk       B,#8 
0172 U 0001         736            jz        ff_txabort         ;the bus is low : this is a collision
     U              737  
     U              738  ff_txwait                              ;TX : this is the loop to send data on the bus
0173   0045         739            shift     X,00h              ;remove old carry bit
0174   8445         740            shift     X,084h             ;maintain current carry bit
0175   8285         741            add       X,#2               ;prepare X for next bit
0176   0258         742            wait      TimeOut            ;wake up at Br halfmatch
                    743  
                    744                                         ;read status registers
0177   39B7         745            mov       A,io:19h           ;read status register 0 (and clear the flags): {Traffic,LEvExt,Ovf,BrEv}
0178   38B6         746            mov       B,io:18h           ;read status register 1 (and clear the flags): {Bin,SplBin,SyncErr,RunErr}
0179   7272         747            mov       Xtmp,B 
                    748  
017A   37B7         749            mov       A,io:17h           ;PWM=1 and NoCk=0
                    750                                         ; x x x x
                    751                                         ;  \ \ \ \
                    752                                         ;   \ \ \ set at falling edge
                    753                                         ;    \ \ on Brmatch, set with Bin
                    754                                         ;     \ set at rising edge
                    755                                         ;      SplBin: level on the bus
017B U 0000         756            jc        ff_bytesent        ;process the next byte
017C   6721         757            jmp       ff_txshift         ;send the next bit
                    758  
                    759  ff_txabort                             ;abort the transmit - signal it to the application
017D   85B6         760            mov       B,#erTXCOL 
017E U 0060         761            call      errev 
017F   4720         762            jmp       ff_reinit 
                    763  
                    764                                         ;------------------------------------------------------------------------------------
                    765  ff_bytesent                            ;bit 8 : a byte has been sent
                    766                                         ;get the next byte (byte 0 has already been sent)
0180 U 0060         767            call      GetByte            ;get the data byte
0181 U 0000         768            jc        ff_endtx           ;if C is set, the transmit is finished
0182 U 0011         769            jnz       ff_updtcrc         ;if Z is not set, this is a data byte
     U              770                                         ;the CRC is going to be sent next, inverse LINbytbuf (which is in B) and LINbytbuf+1 (which is in A)
0183   0873         771            mov       LINbytbuf,A 
0184   0972         772            mov       LINbytbuf+1,B 
                    773  
                    774  ff_updtcrc                             ;update the CRC
0185   08B2         775            mov       B,LINbytbuf 
0186   09B3         776            mov       A,LINbytbuf+1 
0187 U 0060         777            call      ff_crc_calc        ;do CRC calculation, high nibble in A, low nibble in B
0188   6521         778            jmp       ff_txnextbyte 
                    779  
                    780  ff_endtx                               ;end of transmit
                    781                                         ;stop the counter to stop outputting data
                    782                                         ;dcom PlsCtrl,90h        ;1 0 01 0000
                    783                                         ;   \  \    \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 33  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

                    784                                         ;    \  \    nop
                    785                                         ;     \  clear Run
                    786                                         ;      no capture
                    787  ff_endok                               ;clear data ready flag
0189   6FB1         788            mov       X,LINframeflag     ;x x x x
018A   83BD         789            and       X,#3               ; \ \ \ \
                    790                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                    791                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                    792                                         ;    \ discard the frame
                    793                                         ;     frame data ready for transmit
018B   6F71         794            mov       LINframeflag,X 
                    795                                         ;check if there is some continuous frames going on
018C   5FB1         796            mov       X,LINflashStatus   ;LINflashStatus : x x x x
                    797                                         ;                  \ \ \ \
                    798                                         ;                   \ \ \ programming mode
                    799                                         ;                    \ \ continuous frames coming up
                    800                                         ;                     \ not used
                    801                                         ;                      not used
018D   82A5         802            msk       X,#2               ;test if we have some continuous frames
018E U 0011         803            jnz       ff_sendendtx 
     U              804                                         ;go wait for another start of frame
018F   3020         805            jmp       ff_init 
                    806  ff_sendendtx                           ;send EndEvent to the mlx16
0190   85B7         807            mov       A,#evENDtx 
0191 U 0060         808            call      send_event         ;send the event (data is already ready)
0192   2E21         809            jmp       ff_txrqst          ;keep receiving some data
                    810  
                    811  ;-------------------- sub functions ------------------------------------------------------------------
                    812  ;Initialize the MSBi cell for a reception. Only change the registers that have been changed during TX
0193   B738         813  ff_msbi_rx  dcom      8,0B7h           ;10 11 0111
                    814                                         ;  \  \    \
                    815                                         ;   \  \    Rst[1:0]=11 : Re-Synch mode : reset upon selected edge (see above)
                    816                                         ;    \  \                                           or BrMatch pulse
                    817                                         ;     \  load Mdiff and Togl with 1
                    818                                         ;      Init=10: reset Capt
                    819                                         ; Output bloc
0194   183E         820            dcom      14,18h             ;ForceR=1 : force a recessive state on the bus
0195   7B35         821            dcom      5,7Bh              ;OutCrtl: initialize the output bloc: X,Y,CpZ,NxZ,Z set - M,N cleared (recessive outputs)
                    822                                         ;011 11 011
                    823                                         ;  \  \   \
                    824                                         ;   \  \   Y loaded with '1', X set
                    825                                         ;    \  Z, Cpz and NxZ loaded with '1'
                    826                                         ;     M and N loaded with '1'
                    827                                         ; Auxiliary Ouput bloc
0196   7B36         828            dcom      6,7Bh              ;AuxCtrl: initialize the auxiliary output bloc: U,V,W,Wd set - K,L cleared
0197   0068         829            rt        0,0 
                    830  
                    831  ;Update the CRC - the function should be called for each byte received (or sent)
                    832  ;A : high nibble just received
                    833  ;B : low nibble received
                    834  ;A and B are modified, X not used
0198   7073         835  ff_crc_calc  mov       Atmp,A          ;low nibble calculation
0199   92B7         836            mov       A,B 
019A   0BD3         837            xor       A,LINchksum+1 
019B   0AB2         838            mov       B,LINchksum 
019C   67D6         839            xor       B,Rom:ffCrcTblHi shr 2[A] 
019D   0B72         840            mov       LINchksum+1,B 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 34  Win32 Assembler
                                LIN2B_FASTFLASH.ASM

019E   6BB7         841            mov       A,Rom:ffCrcTblLo shr 2[A] 
019F   0A73         842            mov       LINchksum,A 
01A0   70B3         843            mov       A,Atmp             ;high nibble calculation
01A1   0BD3         844            xor       A,LINchksum+1 
01A2   0AB2         845            mov       B,LINchksum 
01A3   67D6         846            xor       B,Rom:ffCrcTblHi shr 2[A] 
01A4   0B72         847            mov       LINchksum+1,B 
01A5   6BB7         848            mov       A,Rom:ffCrcTblLo shr 2[A] 
01A6   0A73         849            mov       LINchksum,A 
01A7   0068         850            rt        0,0 
                    851  ;--------------------------------------------------
                    852  ;Check the RSID <- the reuslt is not used for now
                    853  ;X : index of the RSID nibble
                    854  ;B is not modified
                    855  ;Z is set if the RSID is 0x7F (error)
01A8   E5B7         856  ff_chk_rsid  mov       A,data:LINframe shr 4[X] ;get the low nibble
01A9   8185         857            add       X,#1 
01AA   8FE7         858            cmp       A,#15 
01AB   E5B7         859            mov       A,data:LINframe shr 4[X] ;get the high nibble
01AC   87EF         860            cmpcz     A,#7 
01AD   0068         861            rt        0,0 
                    862  ;--------------------------------------------------
                    863  ;Move data within the LINframe buffer
                    864  ;A : index of the highest nibble
                    865  ;X : offset in nibbles between the source and the target
                    866  ;B : last nibble to move
01AE   7072         867  ff_buffloop  mov       Atmp,B 
01AF   E7B6         868  ff_loop   mov       B,data:LINframe shr 4[A] ;get the nibble
01B0   9187         869            add       A,X 
01B1   E776         870            mov       data:LINframe shr 4[A],B ;store the nibble
01B2   91C7         871            sub       A,X 
01B3   81C7         872            sub       A,#1 
01B4   70E3         873            cmp       A,Atmp 
01B5 U 0001         874            jz        ff_endsub 
01B6   AF21         875            jmp       ff_loop 
                    876  ;--------------------------------------------------
                    877  ;Store the SID
                    878  ;A : index of the high nibble
01B7   87B5         879  ff_sid    mov       X,#7 
01B8                880            #IF       cvOFF eq cvON 
01B8   6DB6         892  ff_sid_dd  mov       B,Rom:FastCstTbl shr 2[X] ;ffSID_DDhi or ffSID_RBIhi
01B9   81C5         893            sub       X,#1               ;(6 or 8)
01BA   6DB5         894            mov       X,Rom:FastCstTbl shr 2[X] ;ffSID_DDlo or ffSID_RBIlo
                    895  ;Store the content of B and X in the LINframe buffer
                    896  ;A : index of the high nibble
                    897  ;B : content of the high nibble
                    898  ;X : content of the low nibble
                    899  ;A is decreased by 2 when returning from the function
01BB   E776         900  ff_fillbuff  mov       data:LINframe shr 4[A],B 
01BC   81C7         901            sub       A,#1 
01BD   E775         902            mov       data:LINframe shr 4[A],X 
01BE   81C7         903            sub       A,#1 
01BF   0068         904  ff_endsub  rt        0,0 
                    905  
01C0                433            #ENDIF    
01C0                434            #ENDIF    
                    435  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 35  Win32 Assembler
                                LIN2B.ASM

                    436  ;----------------------------------------------------------------------------------------------------------------------
                    437  ;--------------- subroutines ------------------------------------------------------------------------------------------
                    438  brcpt_updt                             ;add the content of LINtmp to LINbrcpt
01C0   40B1         439            mov       X,LINbrcpt 
01C1   4E81         440            add       X,LINtmp 
01C2   4071         441            mov       LINbrcpt,X 
01C3   41B1         442            mov       X,LINbrcpt+1 
01C4   4F89         443            addcz     X,LINtmp+1 
01C5   4171         444            mov       LINbrcpt+1,X 
                    445  brcpt_inc                              ;increment the break counter - C should be set if LINbrcpt+2 has to be incremented by 1
01C6   42B1         446            mov       X,LINbrcpt+2 
01C7   808D         447            addcz     X,#0 
01C8   4271         448            mov       LINbrcpt+2,X 
01C9   43B1         449            mov       X,LINbrcpt+3 
01CA   808D         450            addcz     X,#0 
01CB   4371         451            mov       LINbrcpt+3,X 
01CC   44B1         452            mov       X,LINbrcpt+4 
01CD   808D         453            addcz     X,#0 
01CE   4471         454            mov       LINbrcpt+4,X 
01CF   0068         455            rt        0,0 
                    456  
                    457  brhicpt_updtb                          ;add LINtmp to LINbrhicpt, function returns with X=LINbrhicpt+3
01D0   54B1         458            mov       X,LINbrhicpt 
01D1   4E81         459            add       X,LINtmp 
01D2   5471         460            mov       LINbrhicpt,X 
01D3   55B1         461            mov       X,LINbrhicpt+1 
01D4   4F89         462            addcz     X,LINtmp+1 
01D5   5571         463            mov       LINbrhicpt+1,X 
                    464  brhicpt_inc                            ;increment the break delimiter counter - C should be set if LINbrcpt+2 has to be incremented by 1
01D6   56B1         465            mov       X,LINbrhicpt+2 
01D7   808D         466            addcz     X,#0 
01D8   5671         467            mov       LINbrhicpt+2,X 
01D9   57B1         468            mov       X,LINbrhicpt+3 
01DA   808D         469            addcz     X,#0 
01DB   5771         470            mov       LINbrhicpt+3,X 
01DC   0068         471            rt        0,0 
                    472  
                    473  ; Tbit value in [LINbrtmp+2,LINtmp+1,LINtmp]
                    474  ; Move Tbit to lowsync if Tbit < lowsync
                    475  ; Move Tbit to highsync if Tbit > highsync
                    476  low_high_sync_record  
01DD   4EB3         477            mov       A,LINtmp 
01DE   4FB2         478            mov       B,LINtmp+1 
01DF   5AB1         479            mov       X,LINbrtmp+2       ;overflow counter is in LINbrtmp+2
01E0   49E3         480            cmp       A,lowsync 
01E1   4AEA         481            cmpcz     B,lowsync+1 
01E2   4BE9         482            cmpcz     X,lowsync+2        ;compare [X,B,A] with low margin
01E3 U 0010         483            jnc       low_sync_ok 
01E4   4973         484            mov       lowsync,A 
01E5   4A72         485            mov       lowsync+1,B 
01E6   4B71         486            mov       lowsync+2,X        ;if low is higher than old, replace it by the new value
01E7   46E3         487  low_sync_ok  cmp       A,highsync 
01E8   47EA         488            cmpcz     B,highsync+1 
01E9   48E9         489            cmpcz     X,highsync+2       ;compare [X,B,A] with low margin
01EA U 0000         490            jc        high_sync_ok 
01EB   4673         491            mov       highsync,A 
01EC   4772         492            mov       highsync+1,B 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 36  Win32 Assembler
                                LIN2B.ASM

01ED   4871         493            mov       highsync+2,X       ;if high is lower than old, replace it by the new value
                    494  high_sync_ok                           ;check LINtmp minimum length and add it to LINbrsync
                    495                                         ;LINtmp is in [X,B,A]
01EE   84E6         496            cmp       B,#4 
01EF   80ED         497            cmpcz     X,#0 
01F0 U 0000         498            jc        sync_updt_ok       ;Individual bit is less than 0x40, it's probably a LIN bus short, return with carry set 
01F1   5083         499            add       A,LINbrsync 
01F2   518A         500            addcz     B,LINbrsync+1 
01F3   5289         501            addcz     X,LINbrsync+2 
01F4   5073         502            mov       LINbrsync,A 
01F5   5172         503            mov       LINbrsync+1,B 
01F6   5271         504            mov       LINbrsync+2,X 
01F7   53B3         505            mov       A,LINbrsync+3 
01F8   808F         506            addcz     A,#0 
01F9   5373         507            mov       LINbrsync+3,A      ;carry is not set if we return from here
01FA   0068         508  sync_updt_ok  rt        0,0 
                    509  
                    510  
                    511  brhicpt_brcpt_div                      ;divide the break + break delimiter value by 2 (LINbrhicpt) and divide break value by 2 (LINbrcpt) 
01FB   57B1         512            mov       X,LINbrhicpt+3 
01FC   1045         513            shift     X,10h 
01FD   5771         514            mov       LINbrhicpt+3,X 
01FE   56B1         515            mov       X,LINbrhicpt+2 
01FF   1645         516            rrc       X 
0200   5671         517            mov       LINbrhicpt+2,X 
0201   55B1         518            mov       X,LINbrhicpt+1 
0202   1645         519            rrc       X 
0203   5571         520            mov       LINbrhicpt+1,X 
0204   54B1         521            mov       X,LINbrhicpt 
0205   1645         522            rrc       X 
0206   5471         523            mov       LINbrhicpt,X 
                    524  
                    525  brcpt_div                              ;divide the break value by 2
0207   44B1         526            mov       X,LINbrcpt+4 
0208   1045         527            shift     X,10h 
0209   4471         528            mov       LINbrcpt+4,X 
020A   43B1         529            mov       X,LINbrcpt+3 
020B   1645         530            rrc       X 
020C   4371         531            mov       LINbrcpt+3,X 
020D   42B1         532            mov       X,LINbrcpt+2 
020E   1645         533            rrc       X 
020F   4271         534            mov       LINbrcpt+2,X 
0210   41B1         535            mov       X,LINbrcpt+1 
0211   1645         536            rrc       X                  ;divide only the 2 lower nibbles
0212   4171         537            mov       LINbrcpt+1,X 
0213   40B1         538            mov       X,LINbrcpt 
0214   1645         539            rrc       X 
0215   4071         540            mov       LINbrcpt,X 
0216   0068         541            rt        0,0 
                    542  
                    543  ;----------------------------------------------------------------------------------------------------------------------
                    544  ;Get a data byte from the LINbytbuf
                    545  ;X contains the updated byte counter, to be compared with LINmesslen
                    546  ;LINchksum should contain the checksum or the CRC (for the fast protocol)
                    547  ;Upon the procedure exit, the data byte is in A (high nibble) and B (low nibble) as well as in LINbytbuf
                    548  ;C is set if all the data (and the checksum) has been sent
                    549  ;Z is set if the current byte is the checksum
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 37  Win32 Assembler
                                LIN2B.ASM

                    550  ;The procedure can also be called from GetByteFast (with no processing done for LINbytcnt)
0217   39B1         551  GetByte   mov       X,LINbytcnt        ;get the byte counter
0218   8185         552            add       X,#1               ;increment it
0219   3971         553            mov       LINbytcnt,X        ;save the byte counter
021A   4CE1         554            cmp       X,LINmesslen       ;check if this is the last byte to send
021B U 0000         555            jc        GB_DataByte 
021C U 0001         556            jz        GB_CheckSum 
021D   5040         557            set       C                  ;set C to indicate that all the data has been sent
021E U 0020         558            jmp       GB_Done 
     U              559  GB_CheckSum                            ;get the content of LINchksum
021F   0AB2         560            mov       B,LINchksum 
0220   0BB3         561            mov       A,LINchksum+1 
0221 U 0020         562            jmp       GB_SaveDataDma     ;Z is set; C is not set
     U              563  GB_DataByte                            ;get a byte from the LINframe buffer
0222   9245         564            asl       X                  ;multiply the byte counter by 2 to have the pointer (we access bytes and not nibbles)
                    565  ;               jc GB_Error             ;if the pointer exceed the LINframe capacity (8 bytes), go to the extended buffer
0223   E5B6         566  GetByteFast  mov       B,data:LINframe shr 4[X] ;get the low nibble
0224   8185         567            add       X,#1               ;Z and C are reset
0225   E5B7         568            mov       A,data:LINframe shr 4[X] ;get the high nibble
                    569  GB_SaveDataDma                         ;save the data for the xdma
0226   3472         570            mov       LINdbg,B 
0227   3573         571            mov       LINdbg+1,A 
0228   0872         572  GB_SaveData  mov       LINbytbuf,B     ;save the data in LINbytbuf
0229   0973         573            mov       LINbytbuf+1,A 
                    574  GB_Done   
022A   0068         575            rt        0,0                ;return, the data is in A (high nibble) and B (low nibble)
                    576  
                    577  
                    578  ;this function should be call to reset the WKUP signal form the analog
                    579  dis_ana_wkup  
                    580                                         ;set sleepb
022B   603E         581            dcom      14,60h             ;011 x xxxx
                    582                                         ;   \
                    583                                         ;    sleepb = 1
                    584            
022C   903E         585            dcom      14,90h             ;100 10 xxx
                    586                                         ;      \
                    587                                         ;       enwkup = 0
022D   0068         588            rt        0,0 
                    589  
                    590  ;--------------------------------------------------
                    591  ;Shift LINbytbuf to the right, the bit shifted out (or in) is in C
                    592  ;at the end LINbytbuf+1 is in A, LINbytbuf in B
022E   09B3         593  shift_bytbuf  mov       A,LINbytbuf+1 
022F   08B2         594            mov       B,LINbytbuf 
0230   1647         595            rrc       A 
0231   1646         596            rrc       B 
0232   2822         597            jmp       GB_SaveData        ;save the data in LINbytbuf
                    598  
                    599  ;----------------------------------------------------------------------------------------------------------------------
                    600  ;Update the checksum (add the content of A and B to LINchksum, add the carry if any)
                    601  ;A should contain LINbytbuf+1 and B LINbytbuf
0233   0A82         602  UpdateChkSum  add       B,LINchksum 
0234   0B8B         603            addcz     A,LINchksum+1 
0235   808E         604            addcz     B,#0               ;add the carry
0236   808F         605            addcz     A,#0 
0237   0A72         606            mov       LINchksum,B        ;save the updated checksum
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 38  Win32 Assembler
                                LIN2B.ASM

0238   0B73         607            mov       LINchksum+1,A 
0239   0068         608            rt        0,0 
                    609  
                    610  ;----------------------------------------------------------------------------------------------------------------------
                    611  ;Read the status registers of the MSBi cell
                    612  ;Status register 0 is in A, status register 1 is in B
                    613  ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
023A   39B7         614  ReadStatus  mov       A,io:19h         ;read status register 0 (and clear the flags): {Traffic,LEvExt,Ovf,BrEv}
023B   38B6         615            mov       B,io:18h           ;read status register 1 (and clear the flags): {Bin,SplBin,SyncErr,RunErr}
023C   0068         616            rt        0,0 
                    617  
                    618  ;----------------------------------------------------------------------------------------------------------------------
                    619  ;Increment the prescaler PrescA
                    620  ;X is used
023D   3EB5         621  IncrPrescA  mov       X,io:1Eh 
023E   8185         622            add       X,#1 
023F   3E75         623            mov       io:1Eh,X 
0240   0068         624            rt        0,0 
                    625  
                    626  
                    627  ;----------------------------------------------------------------------------------------------------------------------
                    628  ;Increment the timeout counter (LINtocnt) and check if it reached the max value (LINtoref)
                    629  ;A contains the value to add to the counter
                    630  ;A and B are used and modified
                    631  ;C set if the timeout is not reached
0241   30B3         632  CheckTimeOut  mov       A,LINtocnt     ;increment the counter
0242   31B2         633            mov       B,LINtocnt+1 
0243   8187         634            add       A,#1 
0244   808E         635            addcz     B,#0 
0245   3073         636            mov       LINtocnt,A 
0246   3172         637            mov       LINtocnt+1,B 
0247   36E3         638            cmp       A,LINtoref         ;compare with the timeout reference
0248   37EA         639            cmpcz     B,LINtoref+1 
0249   0068         640            rt        0,0 
                    641  
                    642  ;----------------------------------------------------------------------------------------------------------------------
                    643  ;Increment the break counter (LINbrcpt) by Linbr when transmitting or receiving continuous
                    644  ;zeros on the LIN bus. When a bit is 1, reset the counter. The bit is in C. assume that Linbrcpt+3/+4 is never used
                    645  ;Use only A
024A U 0000         646  UpdateZeroCpt  jc        ResetZeroCnt 
024B   40B3         647            mov       A,LINbrcpt 
024C   0283         648            add       A,LINbr 
024D   4073         649            mov       LINbrcpt,A 
024E   41B3         650            mov       A,LINbrcpt+1 
024F   038B         651            addcz     A,LINbr+1 
0250   4173         652            mov       LINbrcpt+1,A 
0251   42B3         653            mov       A,LINbrcpt+2 
0252   808F         654            addcz     A,#0 
0253 U 0020         655            jmp       ZeroCntDone 
     U              656  ResetZeroCnt                           ;the bit is a 1, reset the 0 counter
0254   80B7         657            mov       A,#0 
0255   4073         658            mov       LINbrcpt,A 
0256   4173         659            mov       LINbrcpt+1,A 
0257   4273         660  ZeroCntDone  mov       LINbrcpt+2,A 
0258   0068         661            rt        0,0 
                    662  
                    663  ;----------------------------------------------------------------------------------------------------------------------
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 39  Win32 Assembler
                                LIN2B.ASM

                    664  ;Increment the break counter (LINbrhicpt)
                    665  ;A and B are used and modified,
0259   54B3         666  IncrLINbrhicpt  mov       A,LINbrhicpt 
025A   55B2         667            mov       B,LINbrhicpt+1 
025B   0283         668            add       A,LINbr 
025C   038A         669            addcz     B,LINbr+1 
025D   5473         670            mov       LINbrhicpt,A 
025E   5572         671            mov       LINbrhicpt+1,B 
025F   56B3         672            mov       A,LINbrhicpt+2 
0260   57B2         673            mov       B,LINbrhicpt+3 
0261   808F         674            addcz     A,#0 
0262   808E         675            addcz     B,#0 
0263   5673         676            mov       LINbrhicpt+2,A 
0264   5772         677            mov       LINbrhicpt+3,B 
0265   0068         678            rt        0,0 
                    679  
                    680  ;Check if the BREAK length is not too long (LINbrhicpt < LINtocnt)
                    681  ;If the BREAK is too long, the SHORT state is entered, if not, the subfunction returns
                    682  ;must return Carry if LINbrhicpt < LINtocnt
0266   54B3         683  CheckHeaderLen  mov       A,LINbrhicpt 
0267   55B2         684            mov       B,LINbrhicpt+1 
0268   30E3         685            cmp       A,LINtocnt 
0269   31EA         686            cmpcz     B,LINtocnt+1 
026A   56B3         687            mov       A,LINbrhicpt+2 
026B   57B2         688            mov       B,LINbrhicpt+3 
026C   32EB         689            cmpcz     A,LINtocnt+2 
026D   33EA         690            cmpcz     B,LINtocnt+3 
026E   0068         691            rt        0,0                ;the break length is not too long: return
                    692  
                    693  ;----------------------------------------------------------------------------------------------------------------------
                    694  ;Check the status of the sleep timer
                    695  ;If there is a timeout (SleepTimeOut overflows), return with C set (should go into sleep mode)
                    696  ;If SleepTimeOut does not overflow, return with C equal 0
                    697  ;A is used
026F   26B7         698  CheckSleepTmr  mov       A,io:6h       ;Sleep Timer Status (read and clear)
0270   8FBF         699            and       A,#15              ;check the timeout flag
0271   4040         700            clr       C                  ;clear C in case there is no timeout (if there is a timeout, C will be updated with the addcz)
0272 U 0001         701            jz        SleepTmrDone       ;return if there is no timeout
     U              702                                         ;do an access to the analog
     U              703            AnalogAccess  
                    417                                         ;do an access to the analog
0273   C33C         418            dcom      12,11000011b       ;1 abc 0 hi j
                    419                                         ;            \
                    420                                         ;             RWB : read analog IO address 0hiabc
0274                704                                         ;Sleep Timer timeout : update the sleep counter (SleepTimeOut) and goto sleep if there is an overflow
0274   82B7         705            mov       A,#2               ;select SleepCntInc
0275   5FB7         706            mov       A,Rom:ConstantTbl shr 2[A] 
0276   3C83         707            add       A,SleepTimeOut     ;increment the counter by the SleepCntInc value
0277   3C73         708            mov       SleepTimeOut,A 
0278   3DB3         709            mov       A,SleepTimeOut+1 
0279   808F         710            addcz     A,#0               ;C generated if the counter overflows
027A   3D73         711            mov       SleepTimeOut+1,A 
027B   0068         712  SleepTmrDone  rt        0,0            ;return
                    713  
                    714  CheckAnaTmr                            ;test the sleep timer for analog access (in sleep mode)
027C   26B7         715            mov       A,io:6h            ;Sleep Timer Status (read and clear)
027D   8FA7         716            msk       A,#15              ;check the timeout flag
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 40  Win32 Assembler
                                LIN2B.ASM

027E U 0001         717            jz        AnaTmrDone 
     U              718                                         ;do an access to the analog
     U              719            AnalogAccess  
                    417                                         ;do an access to the analog
027F   C33C         418            dcom      12,11000011b       ;1 abc 0 hi j
                    419                                         ;            \
                    420                                         ;             RWB : read analog IO address 0hiabc
0280   0068         720  AnaTmrDone  rt        0,0              ;return
                    721  
                    722  ;----------------------------------------------------------------------------------------------------------------------
                    723  wbr_init                               ;this procedure is located somewhere else in the code to solve addressing problems
0281 U 0020         724            jmp       wbr_init_start     ;comes back to sleep_tmr
     U              725  
     U              726  sleep_tmr                              ;sleep timer initialization
     U              727                                         ;initialize the sleep counter (idle timeout timer) in case a Break does not appear within the required time
     U              728                                         ;  SleepCnt
     U              729                                         ;  SleepPre
     U              730                                         ;  Timer
     U              731                                         ;A and B are used, X is not used
     U              732                                         ;---------------------------------
     U              733                                         ;reset the sleep counter
0282   3E4D         734            dmar      #1,ClearByte       ;use the dma to clear the bytes
0283   3C49         735            dmaw      SleepTimeOut,#1    ;clear SleepTimeOut and SleepTimeOut+1
                    736  
                    737                                         ;sleep mode enabled
0284   81B6         738            mov       B,#1               ;select SleepCnt_Val
0285   5EB7         739            mov       A,Rom:ConstantTbl shr 2[B] 
0286   83B6         740            mov       B,#3               ;sleep timer value index
0287   BC77         741            mov       io:7h[B],A 
                    742                                         ;sleep prescaler - enable the counter
0288   80B6         743            mov       B,#0               ;select SleepPre_Val
0289   5EB7         744            mov       A,Rom:ConstantTbl shr 2[B] 
                    745                                         ;1 xxx
                    746                                         ; \   \
                    747                                         ;  \   prescaler (SleepPre_Val)
                    748                                         ;   timer enable
028A   82B6         749            mov       B,#2               ;sleep timer prescaler index
028B   BC77         750            mov       io:7h[B],A 
                    751  
028C   333B         752            dcom      11,33h             ;00 11 00 11
                    753                                         ;     \  \  \
                    754                                         ;      \  \  Sleep Timer TimeOut setting
                    755                                         ;       \  \   0x : no effect
                    756                                         ;        \  \  10 : disable the timeout
                    757                                         ;         \  \ 11 : enable the timeout
                    758                                         ;          \  Message Timer : no effect
                    759                                         ;           Sleep Timer Run Command
                    760                                         ;            00 : no effect
                    761                                         ;            01 : stop the sleep timer
                    762                                         ;            10 : restart the sleep timer
                    763                                         ;            11 : reload and restart the sleep timer - clears SleepStat
028D   0068         764  sleep_tmr_done  rt        0,0 
                    765  
                    766  sleep_tmr_dis                          ;disable the sleep timer
028E   123B         767            dcom      11,12h             ;00 01 00 10
                    768                                         ;     \  \  \
                    769                                         ;      \  \  Sleep Timer TimeOut setting
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 41  Win32 Assembler
                                LIN2B.ASM

                    770                                         ;       \  \   0x : no effect
                    771                                         ;        \  \  10 : disable the timeout
                    772                                         ;         \  \ 11 : enable the timeout
                    773                                         ;          \  Message Timer : no effect
                    774                                         ;           Sleep Timer Run Command
                    775                                         ;            00 : no effect
                    776                                         ;            01 : stop the sleep timer
                    777                                         ;            10 : restart the sleep timer
                    778                                         ;            11 : reload and restart the sleep timer - clears SleepStat
028F   26B7         779            mov       A,io:6h            ;reset the sleep timer status (read and clear)
                    780                                         ;disable the sleep timer
0290   87B7         781            mov       A,#7               ;0 111 reset the msb (timer enable)
0291   82B6         782            mov       B,#2               ;index
0292   BCBF         783            and       A,io:7h[B]         ;get the current value of the prescaler (don't change it)
0293   BC77         784            mov       io:7h[B],A         ;disable the timer
0294   0068         785            rt        0,0 
                    786  
                    787  ;--------------- chstcmnd : handle a change state command from the Mlx16 ----------------------------------------------
                    788  ; This is not accessed with a call but with a jump!!!
                    789  ; parameters : a = pcSTCH, b = 'target' state, x is not modified
                    790  ; result : jump to the 'target' state or send a 'command out of sync' before going back to the original state
                    791  ; see the state transition table TRANStbl in the ROM table section for more details
                    792  chstcmnd                               ;(the target state is already in B)
                    793                                         ;B = 0001 -> DISCONNECT (refer to linapi_cst.asm)   -> 1110
                    794                                         ;B = 0010 -> ACTIVE                                 -> 0101
                    795                                         ;B = 0100 -> SLEEP                                  -> 1001
                    796                                         ;B = 1000 -> WAKE-UP                                -> 0001
                    797                                         ;B = 1111 -> Fast Mode
0295   01B3         798            mov       A,LINst            ;get the current state
0296                799            #IF       cvON eq cvON 
                    800                                         ;allow transition to fast mode
0296   8FE6         801            cmp       B,#stFAST 
0297 U 0011         802            jnz       chstnorm 
     U              803                                         ;request for fast mode
0298   81E7         804            cmp       A,#stDISC 
0299 U 0011         805            jnz       chstinv 
029A   80B7         806            mov       A,#ackOK 
029B   8173         807            mov       LINresp+1,A 
029C   0454         808            ack       event 
029D   2F20         809            jmp       fastprotocol 
029E                810            #ENDIF    
029E   8EE7         811  chstnorm  cmp       A,#stSHORT 
029F U 0001         812            jz        chstinv            ;we can't change the state from short
02A0   52A7         813            msk       A,Rom:TRANStbl shr 2[B] 
02A1 U 0011         814            jnz       chstok             ;the change state requested is possible
     U              815  chstinv                                ;invalid transition, report an error
02A2   81B7         816            mov       A,#ackERR 
02A3   8173         817            mov       LINresp+1,A 
02A4   0454         818            ack       event              ;acknowledge the command
02A5   0068         819            rt        0,0 
                    820  
                    821  chstok                                 ;acknowledge the command (correctly executed)
02A6   80B7         822            mov       A,#ackOK 
02A7   8173         823            mov       LINresp+1,A 
02A8   0454         824            ack       event              ;acknowledge the command
                    825  
                    826                                         ;valid transition, the 'target' state is still in B
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 42  Win32 Assembler
                                LIN2B.ASM

02A9   84E6         827            cmp       B,#stSLEEP 
02AA U 0011         828            jnz       chstnosleep 
02AB   82B5         829            mov       X,#slAPP           ;signal that the sleep mode is entered after a command from the application
02AC U 0020         830            jmp       gotosleep 
     U              831  chstnosleep  
     U              832                                         ;LINst is not directly updated when going to sleep (250us wait efore). update LINst only for the other states
02AD   0172         833            mov       LINst,B 
02AE   82E6         834            cmp       B,#stACT 
02AF U 0011         835            jnz       chstnoact 
02B0 U 0020         836            jmp       active_sc 
     U              837  chstnoact  
02B1   88E6         838            cmp       B,#stWKUP 
02B2 U 0011         839            jnz       chstnowkup 
02B3 U 0020         840            jmp       wakeup_sc 
     U              841  chstnowkup  
02B4 U 0020         842            jmp       dscnct_sc          ;Last state possible: DISC. 
     U              843  
     U              844  
     U              845  ;--------------- errev : send an error to the application -------------------------------------------------------------
     U              846  ; parameters : error type in B
     U              847  ; result : same as setev
     U              848  errev                                  ;free the data buffer
02B5   5EB3         849            mov       A,LINstatus        ;x x x x
02B6   8DBF         850            and       A,#13              ; \ \ \ \
                    851                                         ;  \ \ \ LIN bus activity
                    852                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                    853                                         ;    \ not used
                    854                                         ;     event overflow occured
02B7   5E73         855            mov       LINstatus,A 
                    856                                         ;clear frame flags
02B8   80B7         857            mov       A,#0               ;x x x x
02B9   6F73         858            mov       LINframeflag,A     ; \ \ \ \
                    859                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                    860                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                    861                                         ;    \ discard the frame
                    862                                         ;     frame data ready for transmit
02BA   82B7         863            mov       A,#evERR           ;load the event code into A (the error type should already be in register B)
02BB U 0020         864            jmp       send_event 
     U              865  
     U              866  ;--------------- setev_mess : send an event evMESSrcvd or evMESSrqst to the application -------------------------------------------------------------
     U              867  ; The event will generate an interrupt on the Mlx16.
     U              868  ; parameters : event code in A
     U              869  ; A,B,X used
     U              870  setev_mess                             ;test if the event is free and signal a new one event
02BC U 000B         871            jhshk     setev_mess_ok      ;check if the previous event has been read
02BD   5EB3         872            mov       A,LINstatus        ;x x x x
02BE   88F7         873            or        A,#8               ; \ \ \ \
                    874                                         ;  \ \ \ LIN bus activity
                    875                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                    876                                         ;    \ not used
                    877                                         ;     event overflow occured
02BF   5E73         878            mov       LINstatus,A 
02C0 U 0020         879            jmp       send_event_end 
     U              880  
     U              881  setev_mess_ok                          ;copy the temp registers to LINmess - dmar/dmaw is not accessible for LINmess
02C1   0CB1         882            mov       X,LINindex         ;send the index LSB
02C2   0DB2         883            mov       B,LINindex+1       ;send the index MSB
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 43  Win32 Assembler
                                LIN2B.ASM

02C3   3872         884            mov       LINmessbuf,B 
02C4   02B2         885            mov       B,LINbr            ;send the Br LSB
02C5   8C72         886            mov       LINmess+4,B 
02C6   03B2         887            mov       B,LINbr+1          ;send the Br MSB
02C7   8D72         888            mov       LINmess+5,B 
02C8   3EB6         889            mov       B,io:1Eh           ;send the PrescA
                    890                                         ; A = was set before calling "setev_mess"
                    891                                         ; B = PrescA
                    892                                         ; X = LINindex
                    893                                         ; LINmessbuf = LINindex+1
                    894                                         ; LINmess+4 = LINbr
                    895                                         ; LINmess+5 = LINbr+1
02C9 U 0020         896            jmp       send_event_ok 
     U              897  
     U              898  ;--------------- chst : do a state change and signal it to the application --------------------------------------------
     U              899  ; parameters : new state in b, old state (current state) in LINst, additional parameter in a
     U              900  ; registers : LINst updated
     U              901  ; result : same as send_event, send {A, OldState, NewState, evSTCH}
02CA   01B1         902  chst      mov       X,LINst            ;retrieve the current state
02CB   0172         903            mov       LINst,B            ;update the current state
02CC   3873         904            mov       LINmessbuf,A       ;LINmessbuf can be used for additional parameter (for stACT and stSLEEP)
02CD   65B3         905            mov       A,LINoptions2      ;LINoptions2 : x x x x
                    906                                         ;                     \
                    907                                         ;                      state change masked
02CE   81BF         908            and       A,#1               ;test bit 0
02CF U 0001         909            jz        chst_send 
02D0   0068         910            rt        0,0                ;if set, return immediately without notifying the application
02D1   81B7         911  chst_send  mov       A,#evSTCH 
                    912                                         ;jmp send_event         ;just for debugging purpose
                    913  
                    914  ;--------------- setev : send an event to the application -------------------------------------------------------------
                    915  ; The event will generate an interrupt on the Mlx16.
                    916  ; parameters : event code in A,B,X,LINmessbuf
                    917  ; result : C is set if an error occured
                    918  ; A,B used
                    919  send_event                             ;test if the event is free and signal a new one event
02D2 U 000B         920            jhshk     send_event_ok      ;check if the previous event has been read
02D3   5EB3         921            mov       A,LINstatus        ;x x x x
02D4   88F7         922            or        A,#8               ; \ \ \ \
                    923                                         ;  \ \ \ LIN bus activity
                    924                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                    925                                         ;    \ not used
                    926                                         ;     event overflow occured
02D5   5E73         927            mov       LINstatus,A 
02D6 U 0020         928            jmp       send_event_end 
     U              929  
     U              930  send_event_ok                          ;copy the temp registers to LINmess - dmar/dmaw is not accessible for LINmess
02D7                931            #IF       coDEBUGMARK eq cvON 
02D7   3473         932            mov       LINdbg,A           ;save for xdma
02D8   3572         933            mov       LINdbg+1,B         ;save for xdma
02D9                934            #ENDIF    
02D9   8873         935            mov       LINmess,A 
02DA   8972         936            mov       LINmess+1,B 
02DB   8A71         937            mov       LINmess+2,X 
02DC   38B3         938            mov       A,LINmessbuf 
02DD   8B73         939            mov       LINmess+3,A 
                    940                                         ;copy the protected ID byte
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 44  Win32 Assembler
                                LIN2B.ASM

02DE   0EB3         941            mov       A,LINIDtmp         ;transfer the ID to LINID
02DF   0FB2         942            mov       B,LINIDtmp+1 
02E0   8E73         943            mov       LINID,A 
02E1   8F72         944            mov       LINID+1,B 
                    945                                         ;send the event
02E2   0854         946            set       event              ;set a new event
02E3                947            #IF       coDEBUGMARK eq cvON 
02E3   A67C         948            xdcom     #dcEVENT           ;mark instruction
02E4   347D         949            xdma      LINdbg             ;send the message sent to the application
02E5                950            #ENDIF    
                    951  send_event_end                         ;event set or mutex freed, the acknowledge will be done in the interrupt routine N_M4_SHEM of the Mlx16
02E5   0068         952            rt        0,0 
                    953  
                    954  ;--------------- cmdrcvd : process a command from the application -----------------------------------------------------
                    955  ; parameters : none
                    956  ; result : command code in A, sub-code in B
                    957  ;          X is not used, except for cmd_cnfid
                    958  cmdrcvd                                ;an event has been received, get it
02E6   84B3         959            mov       A,LINcmnd 
02E7   85B2         960            mov       B,LINcmnd+1 
02E8   8073         961            mov       LINresp,A 
                    962  
02E9                963            #IF       coDEBUGMARK eq cvON 
02E9   3473         964            mov       LINdbg,A           ;save for xdma
02EA   3572         965            mov       LINdbg+1,B         ;save for xdma
02EB   A77C         966            xdcom     #dcCOMMAND         ;mark instruction
02EC   347D         967            xdma      LINdbg             ;send the command sent by the application
02ED                968            #ENDIF    
                    969  
                    970  cmdrcvd_drok                           ;not all commands are valid in all states...
02ED   036C         971            switch    A 
02EE U 0020         972            jmp       cmd_ack_nok        ;0 - pcNONE : No commands in the buffer
02EF   9522         973            jmp       chstcmnd           ;1 - pcSTCH : General command for LIN state changes
02F0 U 0020         974            jmp       cmd_cnfbr          ;2 - pcCNFBR : Set the target baudrate/prescaler value
02F1 U 0020         975            jmp       cmd_ack_nok        ;3 - Command not supported
02F2 U 0020         976            jmp       cmd_ack_nok        ;4 - Command not supported
02F3 U 0020         977            jmp       cmd_setframe       ;5 - pcSETFRAME : Discard the current message (Frame Processing Mode) / Set DATAREADY bit / modify continous frame flag
02F4 U 0020         978            jmp       cmd_cnfid          ;6 - pcCNFID : Configure a LIN ID (Identifier Filtering Mode)
02F5 U 0020         979            jmp       cmd_cnfsr          ;7 - pcCNFSR : Configure Slew Rate
02F6 U 0020         980            jmp       cmd_ack_nok        ;8 - Command not supported
02F7 U 0020         981            jmp       cmd_ack_nok        ;9 - Command not supported
02F8 U 0020         982            jmp       cmd_sftver         ;A - pcSFTVER : Software version request
02F9 U 0020         983            jmp       cmd_option         ;B - pcOPTION : Set the option registers
02FA U 0020         984            jmp       cmd_getst          ;C - pcGETST : Get the state of the Mlx4
02FB U 0020         985            jmp       cmd_cnfauto        ;D - pcCNFAUTO : Config auto addressing pulses
02FC U 0020         986            jmp       cmd_ack_nok        ;E - Command not supported
02FD U 0020         987            jmp       cmd_rel_buf        ;F - pcRELBUF : Release frame buffer
     U              988  
     U              989  
     U              990  cmd_ack_ok                             ;Send acknowledge event to MLX16
02FE   80B7         991            mov       A,#ackOK 
02FF U 0020         992            jmp       cmd_respond        ;send event
     U              993  
     U              994  cmd_ack_nok                            ;Send acknowledge event to MLX16
0300   81B7         995            mov       A,#ackERR 
                    996  cmd_respond                            ;release the command buffer to be ready for the next command
0301   8173         997            mov       LINresp+1,A 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 45  Win32 Assembler
                                LIN2B.ASM

0302   0454         998            ack       event 
0303   0068         999            rt        0,0 
                   1000  
                   1001  cmd_sftver                             ;soft version request command-------------------------------------
                   1002                                         ;Request to get the software version or the flash loader version - can be sent from anywhere
                   1003                                         ;SoftVersion = {{EditNbr shl 8} or {LIN2dvtASM shl 7} or {LIN2verASM shl 4} or LIN2revASM}
                   1004                                         ;SoftVersion : xxxx xxxx x xxx xxxx
                   1005                                         ;                       \ \   \    \
                   1006                                         ;                        \ \   \    rev (0 to 15) -> for the LIN software : ver.rev [LIN2revASM]
                   1007                                         ;                         \ \   ver (0 to 7) [LIN2verASM]
                   1008                                         ;                          \ stable (1) / in dvt (0) [LIN2dvtASM]
                   1009                                         ;                          [EditNbr]
                   1010  
0304   82E6        1011            cmp       B,#verEDIT 
0305 U 0001        1012            jz        cmd_veredit        ;check if this is the software version or the flash loader
     U             1013                                         ;Send immediately the software version
     U             1014            
0001               1015  SFTVERL   equ       LIN2revASM and 15 
0306   81B6        1016            mov       B,#SFTVERL 
0307   8272        1017            mov       LINresp+2,B 
                   1018            
0004               1019  SFTVERH   equ       {{LIN2dvtASM shl 3} or LIN2verASM} and 15 
0308   84B6        1020            mov       B,#SFTVERH 
0309 U 0020        1021            jmp       cmd_sftfill 
     U             1022            
0000               1023  EDITVERL  equ       EditNbr and 15 
030A   80B6        1024  cmd_veredit  mov       B,#EDITVERL 
030B   8272        1025            mov       LINresp+2,B 
                   1026            
0000               1027  EDITVERH  equ       {EditNbr shr 4} and 15 
030C   80B6        1028            mov       B,#EDITVERH 
030D   8372        1029  cmd_sftfill  mov       LINresp+3,B 
030E   FE22        1030            jmp       cmd_ack_ok 
                   1031  
                   1032  ;--------------- config_id : configure an ID (Identifier Filtering Mode) ----------------------------------------------
                   1033  ;parameters : a = pcCNFID
                   1034  ;             b = Index
                   1035  ;             {LINcmnd+3, LINcmnd+2} = 0 / 0 / LIN ID (6 bits)
                   1036  ;A, B, X, Btmp, Atmp modified
030F   80B7        1037  config_id  mov       A,#0              ;initialize A
                   1038                                         ;B contains the index
0310   88A6        1039            msk       B,#8               ;check the bank
0311 U 0001        1040            jz        idbank1 
     U             1041                                         ;bank 2 : LIN_IDs2
0312   82B5        1042            mov       X,#LIN_IDs2 shr 4  ;get the address for indexed addressing
0313 U 0020        1043            jmp       idnibble 
     U             1044  idbank1                                ;bank 1 : LIN_IDs
0314   81B5        1045            mov       X,#LIN_IDs shr 4 
                   1046  idnibble                               ;the bank base address is in X, the index in B
0315   7071        1047            mov       Atmp,X             ;save the base address
0316   84A6        1048            msk       B,#4               ;check if it is in the first nibble (0 to 3 or 8 to B)...
0317 U 0001        1049            jz        idlonibble         ;... or in the second (4 to 7 or B to F)
     U             1050                                         ;high nibble
0318   8187        1051            add       A,#1               ;offset (high/low nibble)
                   1052  idlonibble                             ;now push the ID bits in the index
0319   83BE        1053            and       B,#3               ;keep only the two lsb (to get the bit in the nibble)
031A   9246        1054            asl       B                  ;B = 0xx0, where xx is the bit to modify in the nibble
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 46  Win32 Assembler
                                LIN2B.ASM

031B   7172        1055            mov       Btmp,B             ;save B
                   1056  idgetidbitlo                           ;start the processing ! (loop)
                   1057                                         ;bits 0 to 3
031C   86B2        1058            mov       B,LINcmnd+2 
031D   1646        1059  idrotateid  rrc       B 
031E   8672        1060            mov       LINcmnd+2,B        ;save the temporary ID
031F   71B2        1061  idsetinit  mov       B,Btmp            ;restore B
0320   A3B5        1062            mov       X,Data:[X,A] 
0321 U 0000        1063            jc        idsetbit           ;bit set
     U             1064                                         ;reset the corresponding bit
0322   026C        1065            switch    B 
0323   8EBD        1066            and       X,#14              ;B = 0000 : index 0/4/8/12
0324 U 0020        1067            jmp       idnxtbit           ;
0325   8DBD        1068            and       X,#13              ;B = 0100 : index 1/5/9/13
0326 U 0020        1069            jmp       idnxtbit           ;
0327   8BBD        1070            and       X,#11              ;B = 0100 : index 2/6/10/14
0328 U 0020        1071            jmp       idnxtbit           ;
0329   87BD        1072            and       X,#7               ;B = 0110 : index 3/7/11/15
032A U 0020        1073            jmp       idnxtbit           ;
     U             1074  idsetbit                               ;set the corresponding bit
032B   026C        1075            switch    B 
032C   81F5        1076            or        X,#1               ;B = 0000 : index 0/4/8/12
032D U 0020        1077            jmp       idnxtbit           ;
032E   82F5        1078            or        X,#2               ;B = 0010 : index 1/5/9/13
032F U 0020        1079            jmp       idnxtbit           ;
0330   84F5        1080            or        X,#4               ;B = 0100 : index 2/6/10/14
0331 U 0020        1081            jmp       idnxtbit           ;
0332   88F5        1082            or        X,#8               ;B = 0110 : index 3/7/11/15
0333   91B6        1083  idnxtbit  mov       B,X                ;result to save in the index
0334   70B1        1084            mov       X,Atmp             ;restore X
0335   A376        1085            mov       Data:[X,A],B       ;save the result
0336   8AE7        1086            cmp       A,#10              ;have all the ID bits been processed?
0337 U 0010        1087            jnc       idindexrdy         ;yes, move on
0338   8287        1088            add       A,#2               ;no, update the counter
0339   1647        1089            rrc       A                  ;A = 0xxx, C = x
033A   83A7        1090            msk       A,#3               ;    0011, ID bit 4? (does not modify C)
033B   9447        1091            shift     A,94h              ;restore A (Z unchanged)
033C U 0001        1092            jz        idgetidbithi 
033D   1C23        1093            jmp       idgetidbitlo       ;get the next bit
                   1094  idgetidbithi                           ;bit 4
033E   87B2        1095            mov       B,LINcmnd+3        ;get ID bits 4 and 5
033F   1D23        1096            jmp       idrotateid 
                   1097  idindexrdy                             ;check if the init flag bit is set
0340   8CE7        1098            cmp       A,#12 
0341 U 0010        1099            jnc       idindexdone 
     U             1100                                         ;set the init flag bit
0342   8287        1101            add       A,#2 
0343   5040        1102            set       C 
0344   1F23        1103            jmp       idsetinit 
                   1104  idindexdone                            ;ID index ready
0345   FE22        1105            jmp       cmd_ack_ok 
                   1106  
                   1107  ;--------------- BRcorr : fine tuning of the baudrate -----------------------------------------------------------------
                   1108  ;parameters : none
                   1109  ;A, B modified
                   1110  ;registers used : LINbr/LINbr+1 (RW), LINbrcorr (RW), LINbrLSBs (R), MSBI BR register (8 bits access by DMA)
                   1111  ;   LINbrLSBs : xxx 0
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 47  Win32 Assembler
                                LIN2B.ASM

                   1112  ;                  \ \
                   1113  ;                   \ always 0 (that means LINbrcorr LSB should always be 0 too)
                   1114  ;                    SYNC field LSBs used for fine-tuning
                   1115  ;   LINbrcorr : xxx x
                   1116  ;                  \ \
                   1117  ;                   \ 0 : correction not done, 1 : baudrate correction just done
                   1118  ;                    accumulated baudrate correction value, correct the baudrate if a carry is generated
0346   02B2        1119  BRcorrection  mov       B,LINbr        ;preload the baudrate value low nibble
0347   6BB3        1120            mov       A,LINbrcorr 
0348   6A83        1121            add       A,LINbrLSBs 
0349   6B73        1122            mov       LINbrcorr,A        ;update the LINbrcorr accumulator
                   1123                                         ;3 possibilities : overflow, A LSB not set -> LINbr should be incremented by 1, set LSB
                   1124                                         ;                  overflow, A LSB set -> LINbr should not change, do nothing
                   1125                                         ;                  no overflow, A LSB not set -> do nothing
                   1126                                         ;                  no overflow, A LSB set -> decrement LINbr by 1, reset LSB
034A   81BF        1127            and       A,#1               ;000d : decrement if d = 1
034B   9647        1128            rlc       A                  ;00di : decrement if d = 1, increment if i = 1
034C   036C        1129            switch    A                  ;di
034D U 0020        1130            jmp       BRcorrdone         ;00 : nothing
034E U 0020        1131            jmp       BRcorrinc          ;01 : + 1, set LSB
034F U 0020        1132            jmp       BRcorrdec          ;10 : - 1, reset LSB
0350 U 0020        1133            jmp       BRcorrdone         ;11 : nothing
     U             1134  
     U             1135  BRcorrinc                              ;update LINbr
0351   8186        1136            add       B,#1 
0352   0272        1137            mov       LINbr,B 
0353   03B2        1138            mov       B,LINbr+1 
0354   808E        1139            addcz     B,#0 
                   1140                                         ;update LINbrcorr lsb (A is already 0001)
0355   6BF3        1141            or        A,LINbrcorr        ;set the lsb
                   1142            
                   1143                                         ;we should wait before increment Linbr that the counter has actually reach the next value.
                   1144                                         ;if not, a new half match can be detected just after this one because the next half match will be generated at counter+1
                   1145                                         ;the overall proc needs 66 cpuck to update the new Linbr value but the counter is invremented after 128 cpuck if presca = 6, 256 cpuck if presca =7 or 512 cpuck if presca = 8
                   1146                                         ;the waiting loop is made with 10 instructions -> minimum cpuck is 10*3 = 30
                   1147                                         ;the the waiting time should be:
                   1148                                         ;62 cpuck if presca = 6 (128 - 66) (3 loops)
                   1149                                         ;190 cpuck if presca = 7 (256 - 66) (7 loops)
                   1150                                         ;446 cpuck if presca =8 (512 - 66) (15 loops)
                   1151                                         ;no needs to wait if presca < 6
                   1152                                         ;store Linbrcorr to be able to use A register
0356   6B73        1153            mov       LINbrcorr,A 
                   1154            
0357   86B7        1155            mov       A,#6               ;to make the comparison
0358   3EE7        1156            cmp       A,io:1Eh 
0359 U 0000        1157            jc        BRcorrincPresca78  ;if 6 < Presca   -> no need to wait
035A U 0001        1158            jz        BRcorrincPresca6   ;presca = 6
035B U 0020        1159            jmp       BRcorrupdt 
     U             1160  BRcorrincPresca78  
     U             1161                                         ;presca = 7 or 8
035C   87B7        1162            mov       A,#7 
035D   3EE7        1163            cmp       A,io:1Eh 
035E U 0010        1164            jnc       BRcorrincwait      ;presca = 7, we should loop 7 times. luckily, A already = 7 
     U             1165                                         ;presca = 8
035F   8FB7        1166            mov       A,#15 
0360 U 0020        1167            jmp       BRcorrincwait 
     U             1168  BRcorrincPresca6                       ;presca = 6
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 48  Win32 Assembler
                                LIN2B.ASM

0361   83B7        1169            mov       A,#3 
                   1170  BRcorrincwait                          ;Do delay loop
0362   0000        1171            nop       
0363   0000        1172            nop       
0364   0000        1173            nop       
0365   0000        1174            nop       
0366   0000        1175            nop       
0367   0000        1176            nop       
0368   81C7        1177            sub       A,#1 
0369   80E7        1178            cmp       A,#0 
036A U 0001        1179            jz        BRcorrupdt 
036B   6223        1180            jmp       BRcorrincwait 
                   1181  
                   1182  BRcorrdec                              ;update LINbr
036C   81C6        1183            sub       B,#1 
036D   0272        1184            mov       LINbr,B 
036E   03B2        1185            mov       B,LINbr+1 
036F   80CE        1186            subcz     B,#0 
                   1187                                         ;update LINbrcorr lsb
0370   8EB7        1188            mov       A,#14              ;reset the lsb
0371   6BBB        1189            and       A,LINbrcorr 
0372   6B73        1190            mov       LINbrcorr,A 
0373   0372        1191  BRcorrupdt  mov       LINbr+1,B 
                   1192                                         ;update the Br register (dma access)
0374   024C        1193            dmar      #0,LINbr 
0375   0068        1194  BRcorrdone  rt        0,0 
                   1195  
                   1196  ;---------------    autoadd_pls : Auto Addressing Pulse (Cooling) --------------------------------------------------------
                   1197  ;send a pulse and reload AutoAddCpt with the next value
                   1198  ;X modified - no parameter needed (values in AutoAddEv, AutoAddCpt, AutoAddMode)
                   1199  autoadd_pls                            ;an autoaddressing pulse has to be sent 
0376   7172        1200            mov       Btmp,B             ;B must be saved since it contains MSBI Status and could be used further
0377   6DB1        1201            mov       X,AutoAddEv        ;index of the ROM table
0378   8185        1202            add       X,#1               ;increment the index
0379   6D71        1203            mov       AutoAddEv,X        ;update the index (the first pulse is pulse 1, the second pulse 2, and so on...)
                   1204                                         ;test if the event is free and signal a new one event
037A U 000B        1205            jhshk     autoadd_ev_sent    ;check if the previous event has been read
037B   5EB2        1206            mov       B,LINstatus        ;x x x x
037C   88F6        1207            or        B,#8               ; \ \ \ \
                   1208                                         ;  \ \ \ LIN bus activity
                   1209                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   1210                                         ;    \ not used
                   1211                                         ;     event overflow occured
037D   5E72        1212            mov       LINstatus,B 
037E U 0020        1213            jmp       autoadd_ev_end 
037F   8971        1214  autoadd_ev_sent  mov       LINmess+1,X ;pass AutoAddEv as a parameter
0380               1215            #IF       coDEBUGMARK eq cvON 
0380   3471        1216            mov       LINdbg,X           ;save AutoAddEv for xdma
0381   80B7        1217            mov       A,#0 
0382   3573        1218            mov       LINdbg+1,A         ;save for xdma
0383               1219            #ENDIF    
0383   87B7        1220            mov       A,#evCOOLAUTO 
0384   8873        1221            mov       LINmess,A 
0385   0854        1222            set       event              ;send a new event
                   1223                                         ;event set, the acknowledge will be done in the interrupt routine N_M4_SHEM of the Mlx16
0386               1224            #IF       coDEBUGMARK eq cvON 
0386   557C        1225            xdcom     #dcAUTOADD         ;mark instruction
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 49  Win32 Assembler
                                LIN2B.ASM

0387   347D        1226            xdma      LINdbg             ;send the message sent to the application
0388               1227            #ENDIF    
                   1228  autoadd_ev_end                         ;get the next value for AutoAddCpt
                   1229                                         ;access to AUTOADDtbl in lin2bromtbl.asm (was mov X,Rom:AutoAddTbl shr 2[X] in the local table)
0388   91B6        1230            mov       B,X 
0389   88B5        1231            mov       X,#AUTOADDtableX 
                   1232                                         ;ROM table AUTOADDtable located in F20, configure Txtab[5:2] (in MemTab 2)      <--------------
038A   EB3B        1233            dcom      11,AUTOADDtable    ;11 1111 00
                   1234                                         ;           \  \
                   1235                                         ;            \  Txtab[1:0] = 00 (ored with arom[7:6])
                   1236                                         ;             Txtab[5:2] = 1111 (replace arom[11:8])
038B   A6B5        1237            mov       X,Rom:TableRom[X,B] ;get the new value for the counter
038C   6E71        1238            mov       AutoAddCpt,X       ;store the value just retrieved in AutoAddCpt
                   1239                                         ;pulse sent, counter reloaded
                   1240                                         ;if the value is 0, the auto addressing is finished
038D   8FA5        1241            msk       X,#15              ;test if the counter value is 0
038E U 0011        1242            jnz       autoadd_done       ;if not, terminate the subroutine
     U             1243                                         ;all the pulses have been sent, do not use the counter anymore
038F   6CB1        1244            mov       X,AutoAddMode      ;x x x x
                   1245                                         ; \ \ \ \
                   1246                                         ;  \ \ \ within generation
                   1247                                         ;   \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                   1248                                         ;    \ auto addressing always enabled
                   1249                                         ;     not used
0390   84BD        1250            and       X,#4               ;reset auto mode and generation
0391   6C71        1251            mov       AutoAddMode,X 
                   1252  autoadd_done  
0392   71B2        1253            mov       B,Btmp 
0393   0068        1254            rt        0,0 
                   1255  
                   1256  ;-----------------------------------------------------------------------------------------------------
                   1257  ;Procedure called when a single SYNC bit is too long
                   1258  ;A and B used
                   1259  ;B should be set with Stat1
                   1260  SYNCerrBLhigh                          ;check if collision with a new break field, check bus level
0394   88A6        1261            msk       B,#8               ;check the level of the LIN bus, if high no new break
0395 U 0011        1262            jnz       SYNCerrBLfini 
     U             1263                                         ;incorrect sync bit time, could be a start of new break
0396   3BB2        1264            mov       B,LINerrStat       ;x x x x
0397   84F6        1265            or        B,#4               ; \ \ \ \
                   1266                                         ;  \ \ \ data stop bit error detected
                   1267                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   1268                                         ;    \ collision error detected
                   1269                                         ;     ID stop bit error detected
0398   3B72        1270            mov       LINerrStat,B 
                   1271                                         ;copy Low time to Linbrcpt for next break
0399   5AB3        1272            mov       A,LINbrtmp+2       ;Linbrtmp+2 contains the number of overflows
039A   4273        1273            mov       LINbrcpt+2, A      ;copy the number of overflows in Linbrcpt for next break detection
039B   80B7        1274            mov       A, #0 
039C   4073        1275            mov       LINbrcpt+0, A      ;reset other nibbles
039D   4173        1276            mov       LINbrcpt+1, A 
039E   4373        1277            mov       LINbrcpt+3, A 
039F   4473        1278            mov       LINbrcpt+4, A 
                   1279                                         ;Sync field bit length error
03A0   0068        1280  SYNCerrBLfini  rt        0,0 
                   1281  
                   1282  cmd_setframe                           ;--- Set Frame Command -------------------------------------------------------
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 50  Win32 Assembler
                                LIN2B.ASM

03A1   81E6        1283            cmp       B,#1 
03A2   86B2        1284            mov       B,LINcmnd+2        ;Move LINcmnd+2 to B for further handling in TXdataready and continous setting
03A3 U 0001        1285            jz        cmd_setfr_dtrdy    ;B=1 : data ready
03A4 U 0000        1286            jc        cmd_setfr_dscrd    ;B<1 : discard frame
     U             1287  cmd_setfr_cont                         ;set/reset continuous frame flag
03A5   80E6        1288            cmp       B,#0 
03A6   5FB3        1289            mov       A,LINflashStatus   ;x x x x
                   1290                                         ; \ \ \ \
                   1291                                         ;  \ \ \ programming mode
                   1292                                         ;   \ \ continuous frames coming up
                   1293                                         ;    \ not used
                   1294                                         ;     not used
03A7 U 0001        1295            jz        cmd_setfr_rcont 
     U             1296                                         ;set continuous frame flag
03A8   82F7        1297            or        A,#2 
03A9   5F73        1298            mov       LINflashStatus,A 
03AA   FE22        1299            jmp       cmd_ack_ok 
                   1300  cmd_setfr_rcont                        ;reset continuous frame flag
03AB   8DBF        1301            and       A,#13 
03AC   5F73        1302            mov       LINflashStatus,A 
03AD   FE22        1303            jmp       cmd_ack_ok 
                   1304  cmd_setfr_dtrdy                        ;Setting of data ready bit is needed
03AE   6FB3        1305            mov       A,LINframeflag     ;x x x x
03AF   88F7        1306            or        A,#8               ; \ \ \ \
                   1307                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   1308                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   1309                                         ;    \ discard the frame
                   1310                                         ;     frame data ready for transmit
03B0   6F73        1311            mov       LINframeflag,A 
03B1   0072        1312            mov       LINevendTX,B       ;x x x x
                   1313                                         ; \ \ \ \
                   1314                                         ;  \ \ \ End TX event must to be sent
                   1315                                         ;   \ \ unused
                   1316                                         ;    \ unused
                   1317                                         ;     unused
03B2   FE22        1318            jmp       cmd_ack_ok 
                   1319  cmd_setfr_dscrd                        ;set discard frame flag
03B3   6FB3        1320            mov       A,LINframeflag     ;x x x x
03B4   84F7        1321            or        A,#4               ; \ \ \ \
                   1322                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   1323                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   1324                                         ;    \ discard the frame
                   1325                                         ;     frame data ready for transmit
03B5   6F73        1326            mov       LINframeflag,A 
03B6   FE22        1327            jmp       cmd_ack_ok 
                   1328  
                   1329  cmd_rel_buf                            ;Clear buffer occupied flag
03B7   5EB3        1330            mov       A,LINstatus        ;x x x x
03B8   8DBF        1331            and       A,#13              ; \ \ \ \
                   1332                                         ;  \ \ \ LIN bus activity
                   1333                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   1334                                         ;    \ not used
                   1335                                         ;     event overflow occured
03B9   5E73        1336            mov       LINstatus,A 
03BA   82A6        1337            msk       B,#2 
03BB U 0011        1338            jnz       cmd_rel_buf_end 
03BC   5FB3        1339            mov       A,LINflashStatus   ;x x x x
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 51  Win32 Assembler
                                LIN2B.ASM

                   1340                                         ; \ \ \ \
                   1341                                         ;  \ \ \ programming mode
                   1342                                         ;   \ \ continuous frames coming up
                   1343                                         ;    \ not used
                   1344                                         ;     not used
03BD   8EBF        1345            and       A,#14 
03BE   81A6        1346            msk       B,#1 
03BF U 0001        1347            jz        cmd_rel_buf_wr 
03C0   81F7        1348            or        A,#1 
03C1   5F73        1349  cmd_rel_buf_wr  mov       LINflashStatus,A 
03C2   FE22        1350  cmd_rel_buf_end  jmp       cmd_ack_ok 
                   1351  
                   1352  cmd_option                             ;the command received is an option configuration - sent only in DISC state
03C3   81B7        1353            mov       A,#stDISC 
03C4   01E3        1354            cmp       A,LINst 
03C5 U 0001        1355            jz        cmd_optionok 
03C6   0023        1356            jmp       cmd_ack_nok        ;wrong state : send an error
03C7   6472        1357  cmd_optionok  mov       LINoptions1,B  ;set the registers
03C8   86B2        1358            mov       B,LINcmnd+2 
03C9   6572        1359            mov       LINoptions2,B 
03CA   FE22        1360            jmp       cmd_ack_ok 
                   1361  
                   1362  cmd_cnfsr                              ;if is a Slew rate setting command
03CB   81B7        1363            mov       A,#stDISC 
03CC   01E3        1364            cmp       A,LINst 
03CD U 0001        1365            jz        cmd_cnfok          ;we are in disconnected state
03CE   0023        1366            jmp       cmd_ack_nok        ;wrong state : send an error
                   1367  cmd_cnfok                              ;configure the slew rate
03CF   9246        1368            asl       B                  ;B=xSSx
03D0   86BE        1369            and       B,#6               ;0SS0
03D1   026C        1370            switch    B 
03D2   043E        1371            dcom      14,04h             ;0000 : Phymd = 00 -> Check Analog documentation for mode associated
03D3 U 0020        1372            jmp       cmd_srdone         ;slew rate configuration done
03D4   053E        1373            dcom      14,05h             ;0010 : Phymd = 01 -> Check Analog documentation for mode associated
03D5 U 0020        1374            jmp       cmd_srdone         ;slew rate configuration done
03D6   063E        1375            dcom      14,06h             ;0100 : Phymd = 10 -> Check Analog documentation for mode associated
03D7 U 0020        1376            jmp       cmd_srdone         ;slew rate configuration done
03D8   073E        1377            dcom      14,07h             ;0110 : Phymd = 11 -> Check Analog documentation for mode associated
03D9   FE22        1378  cmd_srdone  jmp       cmd_ack_ok       ;slew rate setting command regular end
                   1379  
                   1380  
                   1381  cmd_cnfauto                            ;it was a config autoaddressing
03DA   85B2        1382            mov       B,LINcmnd+1        ;put the value in B (enable/disable/auto/force)
03DB   81E6        1383            cmp       B,#ENABLED 
03DC U 0001        1384            jz        cmd_cnfauto_en 
03DD   82E6        1385            cmp       B,#AUTORESET 
03DE U 0001        1386            jz        cmd_cnfauto_au 
     U             1387  cmd_cnfauto_dis                        ;B = disabled : immediately reset en_auto and cnf_en and cnf_auto       <- be careful : the break counter won't
03DF   80B6        1388            mov       B,#0 
03E0 U 0020        1389            jmp       cmd_cnfauto_ok 
     U             1390  cmd_cnfauto_au                         ;set a flag to indicate that en_auto will have to be disabled after the end of the first break
03E1   82B6        1391            mov       B,#2 
03E2 U 0020        1392            jmp       cmd_cnfauto_ok 
     U             1393  cmd_cnfauto_en                         ;set a flag to indicate that cnf_en is set (auto addressing mode enabled)
03E3   84B6        1394            mov       B,#4 
                   1395                                         ;          \                 is being received !!!
                   1396                                         ;           set en_auto
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 52  Win32 Assembler
                                LIN2B.ASM

03E4   6C72        1397  cmd_cnfauto_ok  mov       AutoAddMode,B ;store AutoAddMode x x x x
                   1398                                         ;                   \ \ \ \
                   1399                                         ;                    \ \ \ within generation
                   1400                                         ;                     \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                   1401                                         ;                      \ auto addressing always enabled
                   1402                                         ;                       not used
03E5   FE22        1403            jmp       cmd_ack_ok 
                   1404  
                   1405  cmd_getst                              ;get state command--------------------------------------------------
03E6   01B3        1406            mov       A,LINst            ;get the state of the state machine, reset bits in B
03E7   8273        1407            mov       LINresp+2,A 
03E8   5EB3        1408            mov       A,LINstatus        ;x x x x
                   1409                                         ; \ \ \ \
                   1410                                         ;  \ \ \ LIN bus activity
                   1411                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   1412                                         ;    \ not used
                   1413                                         ;     event overflow occured
03E9   8373        1414            mov       LINresp+3,A 
03EA   86F6        1415            or        B,#6               ; bits 1 and 2 are not used for reset
03EB   92BF        1416            and       A,B 
03EC   5E73        1417            mov       LINstatus,A 
03ED   FE22        1418            jmp       cmd_ack_ok 
                   1419  
                   1420  cmd_cnfbr                              ;-------------------------------------------------------------------
                   1421                                         ;set the baudrate (was setbr) - sent only in DISC state
                   1422                                         ;calculation of the values has to be done outside
                   1423                                         ;parameters : a = pcCNFBR
                   1424                                         ;             b != 0xE : Prescaler Value
                   1425                                         ;             b = 0xE : Auto baudrate enable
                   1426                                         ;             {LINcmnd+3, LINcmnd+2} = caBaud : {LINbr+1, LINbr} and {LINbrNom+1, LINbrNom}
                   1427                                         ;result : none
03EE   81B7        1428            mov       A,#stDISC 
03EF   01E3        1429            cmp       A,LINst 
03F0 U 0001        1430            jz        cmd_cnfbrok 
03F1   0023        1431            jmp       cmd_ack_nok        ;wrong state : send an error
03F2   8EE6        1432  cmd_cnfbrok  cmp       B,#14 
03F3 U 0001        1433            jz        cmd_cnfbrAuto 
     U             1434                                         ;fixed baudrate mode
03F4   3E76        1435            mov       io:1Eh,B 
03F5   0772        1436            mov       LINprescNom,B 
03F6   0672        1437            mov       LINpresc,B 
03F7   86B2        1438            mov       B,LINcmnd+2 
03F8   0272        1439            mov       LINbr,B 
03F9   0472        1440            mov       LINbrNom,B         ;Nominal Baudrate (never changed, LINbr is changed...
03FA   87B2        1441            mov       B,LINcmnd+3        ;... during the sync field reception)
03FB   0372        1442            mov       LINbr+1,B 
03FC   0572        1443            mov       LINbrNom+1,B 
                   1444                                         ;set the baudrate detected flag
03FD   5CB2        1445            mov       B,LINbrflag        ;x x x x
03FE   84F6        1446            or        B,#4               ; \ \ \ \
                   1447                                         ;  \ \ \ edge to be processed
                   1448                                         ;   \ \ not used
                   1449                                         ;    \ baudrate detected
                   1450                                         ;     auto baudrate on every frame
                   1451                                         ;clear baudrate on every frame
03FF   87BE        1452            and       B,#7 
0400   5C72        1453            mov       LINbrflag,B 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 53  Win32 Assembler
                                LIN2B.ASM

0401   FE22        1454            jmp       cmd_ack_ok 
                   1455  
                   1456  cmd_cnfbrAuto                          ;auto baudrate mode
0402   5CB2        1457            mov       B,LINbrflag        ;x x x x
                   1458                                         ; \ \ \ \
                   1459                                         ;  \ \ \ edge to be processed
                   1460                                         ;   \ \ not used
                   1461                                         ;    \ baudrate detected
                   1462                                         ;     auto baudrate on every frame
0403   87BE        1463            and       B,#7               ;clear the auto baudrate on every frame flag
0404   86B3        1464            mov       A,LINcmnd+2 
0405   80E7        1465            cmp       A,#0 
0406 U 0001        1466            jz        cmd_cnfbrAutoSi 
     U             1467                                         ;set baudrate on every frame
0407   88F6        1468            or        B,#8 
                   1469  cmd_cnfbrAutoSi                        ;clear baudrate detected flag
0408   8BBE        1470            and       B,#11 
0409   5C72        1471            mov       LINbrflag,B 
040A   FE22        1472            jmp       cmd_ack_ok 
                   1473  
                   1474  cmd_cnfid                              ;-------------------------------------------------------------------
                   1475                                         ;The command is a pcCNFID! This command is only accessible in DISCONNECTED state
                   1476                                         ;For pcCNFID and ONLY FOR THIS COMMAND, the acknowledge is not done and
                   1477                                         ;will have to be done later because this command need 'a lot' of processing
040B   81B7        1478            mov       A,#stDISC 
040C   01E3        1479            cmp       A,LINst 
040D U 0001        1480            jz        cmd_cnfidok 
040E   0023        1481            jmp       cmd_ack_nok        ;wrong state : send an error
040F   87B3        1482  cmd_cnfidok  mov       A,LINcmnd+3     ;test if it is a SetLinId or a MessageValid command
0410   9647        1483            rlc       A                  ;if C = 0, it is a SetLinId, if C = 1 it is a MessageValid
0411 U 0000        1484            jc        cmd_enmess         ;MessageValid
0412   0F23        1485            jmp       config_id          ;SetLinId : go process the ID without sending an acknowledge
                   1486  cmd_enmess                             ;-------------------------------------------------------------------
                   1487                                         ;the command received is an enable/disable of an ID - sent only in DISC state
                   1488                                         ;get the parameters : B : index
                   1489                                         ;                     LINcmnd+3 : flag
0413   7172        1490            mov       Btmp,B             ;save the index
                   1491                                         ;no need to save X in Xtmp, in disconnected state, X is not used
0414   8CBE        1492            and       B,#12              ;keep the two msbs : xx00
0415   0846        1493            rr        B                  ;0xx0
0416   026C        1494            switch    B 
0417   1CB1        1495            mov       X,LIN_IDsInit      ;Index 0 to 3
0418 U 0020        1496            jmp       cmd_enbkok         ;
0419   1DB1        1497            mov       X,LIN_IDsInit+1    ;Index 4 to 7
041A U 0020        1498            jmp       cmd_enbkok         ;
041B   2CB1        1499            mov       X,LIN_IDsInit2     ;Index 8 to 11
041C U 0020        1500            jmp       cmd_enbkok         ;
041D   2DB1        1501            mov       X,LIN_IDsInit2+1   ;Index 12 to 15
                   1502  cmd_enbkok                             ;the register to modify is in X
                   1503                                         ;do not change X, do not change B
041E   87B3        1504            mov       A,LINcmnd+3        ;xFxx F is the flag for enable (1) or disable (0)
041F   9647        1505            rlc       A                  ;Fxxx
0420   9647        1506            rlc       A                  ;put the flag in C
0421   71B3        1507            mov       A,Btmp             ;get the index (again!)
0422   83BF        1508            and       A,#3               ;keep only the two lsbs, and does not modify C : 00xx
0423   8847        1509            rl        A                  ;rl does not modify C : 0xx0
0424 U 0000        1510            jc        cmd_ensetbit 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 54  Win32 Assembler
                                LIN2B.ASM

     U             1511  cmd_enresetbit                         ;reset the corresponding bit
0425   036C        1512            switch    A 
0426   8EBD        1513            and       X,#14              ;A = 0000 : index 0/4/8/12
0427 U 0020        1514            jmp       cmd_ensav          ;
0428   8DBD        1515            and       X,#13              ;A = 0100 : index 1/5/9/13
0429 U 0020        1516            jmp       cmd_ensav          ;
042A   8BBD        1517            and       X,#11              ;A = 0100 : index 2/6/10/14
042B U 0020        1518            jmp       cmd_ensav          ;
042C   87BD        1519            and       X,#7               ;A = 0110 : index 3/7/11/15
042D U 0020        1520            jmp       cmd_ensav          ;
     U             1521  cmd_ensetbit                           ;set the corresponding bit
042E   036C        1522            switch    A 
042F   81F5        1523            or        X,#1               ;A = 0000 : index 0/4/8/12
0430 U 0020        1524            jmp       cmd_ensav          ;
0431   82F5        1525            or        X,#2               ;A = 0010 : index 1/5/9/13
0432 U 0020        1526            jmp       cmd_ensav          ;
0433   84F5        1527            or        X,#4               ;A = 0100 : index 2/6/10/14
0434 U 0020        1528            jmp       cmd_ensav          ;
0435   88F5        1529            or        X,#8               ;A = 0110 : index 3/7/11/15
0436   026C        1530  cmd_ensav  switch    B                 ;save the result
0437   1C71        1531            mov       LIN_IDsInit,X      ;Index 0 to 3
0438 U 0020        1532            jmp       cmd_ensav_done     ;
0439   1D71        1533            mov       LIN_IDsInit+1,X    ;Index 4 to 7
043A U 0020        1534            jmp       cmd_ensav_done     ;
043B   2C71        1535            mov       LIN_IDsInit2,X     ;Index 8 to 11
043C U 0020        1536            jmp       cmd_ensav_done     ;
043D   2D71        1537            mov       LIN_IDsInit2+1,X   ;Index 12 to 15
                   1538                                         ;en/dis of the message is done
                   1539  cmd_ensav_done  
                   1540                                         ; we are in dosconnected state, no need to reload X since it is not used in this state
043E   FE22        1541            jmp       cmd_ack_ok 
                   1542  
                   1543  ;----------------------------------------------------------------------------------------------------------------------
                   1544  ;--------------- interrupt and attention vectors ----------------------------------------------------------------------
                   1545  ;interrupts are not used in the LIN task, if this code is executed that means there was a problem
                   1546  ;in that case, send a {evERR,erCRASH} error to the application and reset the task
                   1547  task0_er                               ;handler for critical errors        
043F   80B5        1548            mov       X,#erCRASHIT 
0440   82B6        1549            mov       B,#erCRASH 
0441   B562        1550            call      errev              ;LIN_errev puts #evERR in A and send it to the application
                   1551  
                   1552  task0_por                              ;power on reset & soft reset       
0442   017C        1553            xdcom     #dcRST             ;mark instruction                
0443   1850        1554            ctrl      18h                ;disable interrupts
0444   C054        1555            task      0C0h               ;disable atm
                   1556  
                   1557                                         ;clear the registers used to clear the bytes with dma
0445   80B7        1558            mov       A,#0 
0446   3E73        1559            mov       ClearByte,A 
0447   3F73        1560            mov       ClearByte+1,A 
                   1561  
0448   0154        1562            exit      Mx                 ;- if permitted, reset the Mutex bit
                   1563  
                   1564                                         ; Digital Bus Flags - SLEEPB
0449   603E        1565            dcom      14,60h             ;011 x xxxx
                   1566                                         ;   \
                   1567                                         ;    sleepb = 1
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 55  Win32 Assembler
                                LIN2B.ASM

                   1568  
                   1569  init_lin_task                          ;LIN task initialisation
                   1570                                         ;Configuration Registers : Cfg0 (0x3A) and Cfg1 (0x3B) - there is no reason to change these flags after initialization
044A   80B7        1571            mov       A,#0 
044B   3A77        1572            mov       io:1Ah,A           ;Cfg0 : 0000
                   1573                                         ; NoCk = 0
                   1574                                         ; Split = 0
                   1575                                         ; RptSync = 0
                   1576                                         ; Piped = 0 -> SplBin generated by BrCk pulses
044C   3B77        1577            mov       io:1Bh,A           ;Cfg1 : 0000
                   1578                                         ; Mode 00 (NRZ)
                   1579                                         ; FCan/Clkd/MArb = 0
                   1580                                         ; CanL/Diffm = 0
                   1581                                         ; Prescaler Bloc : PrescA (0x3E) and PrescB (0x3F)
044D   3F77        1582            mov       io:1Fh,A           ;PrescB = 0 : no dividing factor
                   1583                                         ;PrescA is initialized in wbr_init
                   1584  
                   1585                                         ; Output bloc
044E   5B35        1586            dcom      5,5Bh              ;OutCrtl: initialize the output bloc: X,Y,CpZ,NxZ,Z set - M,N cleared (recessive outputs)
                   1587                                         ;010 11 011
                   1588                                         ;  \  \   \
                   1589                                         ;   \  \   Y loaded with '1', X set
                   1590                                         ;    \  Z, Cpz and NxZ loaded with '1'
                   1591                                         ;     M and N loaded with '0'
                   1592                                         ;Auxiliary Ouput bloc
044F   5B36        1593            dcom      6,5Bh              ;AuxCtrl: initialize the auxiliary output bloc: U,V,W,Wd set - K,L cleared
0450   3037        1594            dcom      7,30h              ;StuffCtrl: set OutMd, ignore the stuffing part
                   1595                                         ;0 0 11 0000
                   1596                                         ;     \
                   1597                                         ;      OutMd loaded with '1'
                   1598            
                   1599                                         ;Compare Function
0451   3677        1600            mov       io:16h,A           ;CmpCtrl=0 (compare function)
                   1601                                         ;FilterMsk[2:0] = 000, no mask bit enabled, OutMsk[3:0] = 1111
                   1602            
                   1603                                         ; Tword accessing mode configuration
0452   A03B        1604            dcom      11,regTword        ; Setup Tword accessing mode
                   1605            
                   1606                                         ; Timers
                   1607                                         ; - Watchdog timer
                   1608                                         ; - Sleep timer
                   1609                                         ; - Message timer (not used)
                   1610  
                   1611                                         ;initialize the watchdog counter (Mlx4 Periphery)
                   1612                                         ;the watchdog monitors the LIN bus. If a dominant level is present on the bus for mode than WatchPre_Cnt/WatchPre_Val
                   1613                                         ;a Mlx4 reset is generated
0453   8FB7        1614            mov       A,#15 
0454   5FB7        1615            mov       A,Rom:ConstantTbl shr 2[A] ;WatchPre_Cnt: watchdog timer value
0455   81B6        1616            mov       B,#1               ;watchdog timer value index
0456   BC77        1617            mov       io:7h[B],A 
0457   8EB7        1618            mov       A,#14 
0458   5FB7        1619            mov       A,Rom:ConstantTbl shr 2[A] ;#WatchPre_Val or 8
                   1620                                         ;1 xxx
                   1621                                         ; \   \
                   1622                                         ;  \   prescaler (WatchPre_Val)
                   1623                                         ;   timer enable
0459   80B6        1624            mov       B,#0               ;sleep timer prescaler index
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 56  Win32 Assembler
                                LIN2B.ASM

045A   BC77        1625            mov       io:7h[B],A 
                   1626  
045B   80B7        1627            mov       A,#stINIT 
045C   0173        1628            mov       LINst,A            ;enter INIT state
                   1629  
                   1630  restart                                ;Initalize all RAM private variables
045D   80B7        1631            mov       A,#0 
045E   3E4D        1632            dmar      #1,ClearByte       ;use the dma to clear the bytes
045F   4E49        1633            dmaw      LINtmp,#1          ;clear LINtmp and LINtmp+1
0460   3049        1634            dmaw      LINtocnt,#1        ;clear LINtocnt and LINtocnt+1
0461   3A49        1635            dmaw      MessStatus,#1      ;clear MessStatus
0462   0E49        1636            dmaw      LINIDtmp,#1        ;clear LINIDtmp and LINIDtmp+1
0463   6449        1637            dmaw      LINoptions1,#1     ;clear LINoptions1 and LINoptions2
                   1638  
0464   5F73        1639            mov       LINflashStatus,A   ;Flash status variable init
0465   6C73        1640            mov       AutoAddMode,A      ;reset the auto addressing status register
0466   5C73        1641            mov       LINbrflag,A 
0467   3873        1642            mov       LINmessbuf,A       ;reset the LIN message buffer
0468   0C73        1643            mov       LINindex,A         ;reset the LIN index register (LINindex+1 is initialized later with 8)
0469   5E73        1644            mov       LINstatus,A        ;reset the LIN status flags
046A   6F73        1645            mov       LINframeflag,A     ;reset the sleep status/special ID info
                   1646  
                   1647                                         ;The baudrate is initialized at startup
                   1648                                         ;to avoid a wake up generation/Auto Br detection with Br uninitiliazed
046B   8BB5        1649            mov       X,#{abBRSTART shr 4} 
046C   0571        1650            mov       LINbrNom+1,X 
046D   0371        1651            mov       LINbr+1,X 
046E   8CB5        1652            mov       X,#{abBRSTART and 15} 
046F   0471        1653            mov       LINbrNom,X 
0470   0271        1654            mov       LINbr,X 
0471   83B5        1655            mov       X,#{abPRESCASTART and 15} 
0472   0771        1656            mov       LINprescNom,X 
0473   0671        1657            mov       LINpresc,X 
0474   80B6        1658            mov       B,#0 
                   1659  indxinit                               ;initialize the index table (16 locations! reset LIN_IDsInit too)
0475   C677        1660            mov       Data:LIN_IDs shr 4[B],A 
0476   CA77        1661            mov       Data:LIN_IDs2 shr 4[B],A 
0477   8186        1662            add       B,#1 
0478 U 0001        1663            jz        indxready 
0479   7524        1664            jmp       indxinit 
                   1665  indxready                              ;indexes have been filed with 0
047A   87B6        1666            mov       B,#7 
047B   3673        1667            mov       LINtoref,A         ;initialize the timeout reference value to max (112 = 0x70)
047C   3772        1668            mov       LINtoref+1,B 
                   1669  
047D   88B7        1670            mov       A,#8 
047E   0D73        1671            mov       LINindex+1,A       ;reset the LIN index register (ID not recognized)
                   1672  
047F   81B7        1673            mov       A,#SFTVERL         ;copy software verion in LINmess+4/+5
0480   8C73        1674            mov       LINmess+4,A        ;api can check version compatibility at handshake
0481   84B7        1675            mov       A,#SFTVERH 
0482   8D73        1676            mov       LINmess+5,A 
                   1677  
0483               1678            #IF       coDEBUGMARK eq cvON 
0483   027C        1679            xdcom     #dcWAIT            ;mark instruction
0484               1680            #ENDIF    
0484   2058        1681            wait      signal             ;Initialization done, wait for application to be ready (Handshake)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 57  Win32 Assembler
                                LIN2B.ASM

                   1682                                         ;when the Mlx16 respond (with an event) proceed to DISCONNECT (enter the state machine)
                   1683  ;----------------------------------------------------------------------------------------------------------------------
                   1684  ;-------------- state machine -----------------------------------------------------------------------------------------
                   1685  ;-------------- DISCONNECTED state (stDISC) ---------------------------------------------------------------------------
                   1686  ; command(s) :
                   1687  ; power-down : allowed
                   1688  ; next state(s) : ACTIVE (command), WAKE-UP (command), SLEEP (command)
                   1689  ; action(s) :    state change (see above) or configure an ID
                   1690  dscnct                                 ;disconnected state
0485   81B6        1691            mov       B,#stDISC          ;set the new state: disconnected
0486   CA62        1692            call      chst               ;signal that the state changed
                   1693  
                   1694  dscnct_sc                              ;entering point after state change command (don't do the call to chst)
                   1695                                         ;disable ANA wkup if we come from deep sleep state
0487   2B62        1696            call      dis_ana_wkup 
                   1697                                         ;disable edge/timeout detection... no event should come from the MSBi cell!
                   1698                                         ;StatCtrl
0488   4834        1699            dcom      4,48h              ;StatCtrl
                   1700                                         ;0 1 00 1000
                   1701                                         ;   \  \    \
                   1702                                         ;    \  \    load ToEn[2:0]=000 : LTimeOut not driven
                   1703                                         ;     \  reset Ftfr : nop
                   1704                                         ;      reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
                   1705  
0489   0958        1706  wtcnct    waitpd    Event              ;wait for a command (signaled by an event)/allow power down
                   1707                                         ;check if this is a state change, if so, start the PLL
048A   E662        1708  wtcnt_nostch  call      cmdrcvd        ;process the command - commands are handled in cmdrcvd
048B   8924        1709            jmp       wtcnct 
                   1710  
                   1711  ;-------------- ACTIVE state (stACT) ----------------------------------------------------------------------------------
                   1712  ; command(s) :
                   1713  ; power-down : not allowed
                   1714  ; next state(s) : DISCONNECTED (command (Disconnect)), SLEEP (command (GotoSleep), bus timeout)
                   1715  ; action(s) :    Message processing happens here. If an excessively long dominant state is observed, the FSM goes to BUS SHORT.
                   1716  
                   1717  active                                 ;active state
048C   8AB7        1718            mov       A,#slREG           ;default entering point
048D   82B6        1719            mov       B,#stACT           ;set the new state: active
048E   CA62        1720            call      chst               ;signal that the state changed
                   1721  
                   1722  active_sc                              ;entering point after state change command (don't do the call to chst)
048F   1850        1723            ctrl      18h                ;disable interrupts
0490   C054        1724            task      0C0h               ;disable atm
0491   80B7        1725            mov       A,#0 
0492   3B73        1726            mov       LINerrStat,A 
0493 U 0020        1727            jmp       act_init 
     U             1728  
     U             1729  ;procedures used to go back to active from error in header
     U             1730  ;if no data collision, signal the error if jumped in act_init_er_sig else not signal if jump in act_init_er_no_sig 
     U             1731  ;if data collision, signal data collision in both cases
     U             1732  act_init_er_no_sig                     ;not signal the error met but previous break in frame 
0494   80B6        1733            mov       B,#erNOERR 
                   1734  act_init_er_sig                        ;signal an error or previous break in frame instead
0495   3BB3        1735            mov       A,LINerrStat       ;x x x x
                   1736                                         ; \ \ \ \
                   1737                                         ;  \ \ \ data stop bit error detected
                   1738                                         ;   \ \ wake-up pulse detected (do not handle the break)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 58  Win32 Assembler
                                LIN2B.ASM

                   1739                                         ;    \ collision error detected
                   1740                                         ;     ID stop bit error detected
0496   81A7        1741            msk       A,#1               ;check a stop bit collision
0497 U 0001        1742            jz        act_init_er_send   ;if no collision, go to error signal signaling procedure
0498   8EBF        1743            and       A,#14              ;data stop bit collision detected, reset it
0499   3B73        1744            mov       LINerrStat,A 
049A   39B2        1745            mov       B,LINbytcnt        ;signal collision error
049B   3872        1746            mov       LINmessbuf,B 
049C   82B5        1747            mov       X,#erRXSTOP 
049D   86B6        1748            mov       B,#erRX 
                   1749  act_init_er_send                       ;signal an error if B is filled with
049E   80E6        1750            cmp       B,#erNOERR         ;check if an error has to be sent
049F U 0001        1751            jz        act_init_er        ;go to end of error procedure
04A0   B562        1752            call      errev              ;send the error
                   1753  act_init_er                            ;clear special frames and commands in case of error
04A1   80B7        1754            mov       A,#0 
04A2   6F73        1755            mov       LINframeflag,A 
                   1756  
                   1757  ;----------------------------------------------------------------------------------------------------------------------
                   1758  act_init                               ;Initialization of the MSBi cell for Break reception
                   1759                                         ;reset the special ID and discard flag
04A3   6FB1        1760            mov       X,LINframeflag     ;x x x x
04A4   88BD        1761            and       X,#8               ; \ \ \ \
                   1762                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   1763                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   1764                                         ;    \ discard the frame
                   1765                                         ;     frame data ready for transmit
04A5   6F71        1766            mov       LINframeflag,X 
                   1767                                         ;check the status register to see if a collision occured
04A6   3BB3        1768            mov       A,LINerrStat       ;x x x x
04A7   8DA7        1769            msk       A,#13              ; \ \ \ \
                   1770                                         ;  \ \ \ data stop bit error detected
                   1771                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   1772                                         ;    \ collision error detected
                   1773                                         ;     ID stop bit error detected
04A8 U 0011        1774            jnz       abr_init_col       ;collision detected
04A9 U 0020        1775            jmp       act_regbr          ;there wasn't any collision, go on with normal handling
     U             1776  
     U             1777  abr_init_col                           ;convert LINbrcpt to a prescaler value of 0
     U             1778                                         ;get the previous message baudrate
04AA   024D        1779            dmar      #1,LINbr 
04AB   4E49        1780            dmaw      LINtmp,#1 
                   1781  abr_zero_inc                           ;get the minimal prescaler
04AC   8EB5        1782            mov       X,#14 
04AD   61B5        1783            mov       X,Rom:ConstantTbl2 shr 2[X] ; X = MinPresc
04AE   3EE5        1784  abr_zero_inc2  cmp       X,io:1Eh      ;check if we reached the actusal prescaler 
04AF U 0011        1785            jnz       abr_zero_inc2ok    ;actual prescaler is not reached, continue to divide it
04B0 U 0020        1786            jmp       act_regbr          ;actual prescaler is reached, continue
     U             1787  abr_zero_inc2ok                        ;multiply the counter by 2, divide the prescaler
04B1   40B3        1788            mov       A,LINbrcpt 
04B2   9247        1789            asl       A 
04B3   4073        1790            mov       LINbrcpt,A 
04B4   41B3        1791            mov       A,LINbrcpt+1 
04B5   9647        1792            rlc       A 
04B6   4173        1793            mov       LINbrcpt+1,A 
04B7   42B3        1794            mov       A,LINbrcpt+2 
04B8   9647        1795            rlc       A 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 59  Win32 Assembler
                                LIN2B.ASM

04B9   4273        1796            mov       LINbrcpt+2,A 
04BA   43B3        1797            mov       A,LINbrcpt+3 
04BB   9647        1798            rlc       A 
04BC   4373        1799            mov       LINbrcpt+3,A 
04BD   44B3        1800            mov       A,LINbrcpt+4 
04BE   9647        1801            rlc       A 
04BF   4473        1802            mov       LINbrcpt+4,A 
04C0   8185        1803            add       X,#1 
04C1   AE24        1804            jmp       abr_zero_inc2 
                   1805  
                   1806  act_regbr                              ;regular baudrate detection
04C2   81B5        1807            mov       X,#1 
04C3   6671        1808            mov       AutoAddPrsc,X 
04C4   80B5        1809            mov       X,#0 
04C5   6771        1810            mov       AutoAddPrsc+1,X 
                   1811  act_autoAddPr                          ;Get the minimal prescaler
04C6   8EB5        1812            mov       X,#14 
04C7   61B5        1813            mov       X,Rom:ConstantTbl2 shr 2[X] ; X = MinPresc
04C8   06E1        1814  act_autoAddPr2  cmp       X,LINpresc   ;calculate the prescaler for auto addressing
04C9 U 0001        1815            jz        act_autoAddFin     ;prescaler is ok, continue
04CA   66B2        1816            mov       B,AutoAddPrsc 
04CB   9246        1817            asl       B 
04CC   6672        1818            mov       AutoAddPrsc,B 
04CD   67B2        1819            mov       B,AutoAddPrsc+1 
04CE   9646        1820            rlc       B 
04CF   6772        1821            mov       AutoAddPrsc+1,B 
04D0   8185        1822            add       X,#1 
04D1   C824        1823            jmp       act_autoAddPr2     ;check again the prescaler
04D2   664D        1824  act_autoAddFin  dmar      #1,AutoAddPrsc ;end of autoaddressing initialization
04D3   6849        1825            dmaw      AutoAddPrCnt,#1 
                   1826  
04D4   8162        1827            call      wbr_init           ;no timeout from the MSBi, a slow falling edge generates an EvExt
                   1828  
04D5   80B7        1829            mov       A,#0 
04D6   3A73        1830            mov       MessStatus,A       ;update Active Status
                   1831  
                   1832                                         ;check if the bus is dominant
04D7   3A62        1833            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
04D8   88A6        1834            msk       B,#8 
04D9 U 0011        1835            jnz       act_busrec         ;the bus is recessive
     U             1836                                         ;the bus is dominant,clear the collision bit flags and jump directly to break_start
04DA   3BB3        1837            mov       A,LINerrStat 
04DB   83BF        1838            and       A,#3 
04DC   3B73        1839            mov       LINerrStat,A 
04DD U 0020        1840            jmp       break_start 
     U             1841  
     U             1842  act_busrec                             ;the bus is recessive
04DE   3BB3        1843            mov       A,LINerrStat       ;x x x x
                   1844                                         ; \ \ \ \
                   1845                                         ;  \ \ \ data stop bit error detected
                   1846                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   1847                                         ;    \ collision error detected
                   1848                                         ;     ID stop bit error detected
04DF   8DA7        1849            msk       A,#13              ;test all possible collisions
04E0 U 0001        1850            jz        act_wait           ;no collision was detected go to regular wait for break
     U             1851  act_bus_rec_collision                  ;the bus is recessive but a collision was detected, reset collision flags
04E1   83BF        1852            and       A,#3               ;reset all collision but stop bit (this one is to signal)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 60  Win32 Assembler
                                LIN2B.ASM

04E2   3B73        1853            mov       LINerrStat,A 
04E3   9424        1854            jmp       act_init_er_no_sig ;go back to start with potential erRXSTOP error generation
                   1855  
                   1856                                         ;-----------------------------------------------------------------------------------------------------
                   1857  act_wait                               ;wait for a BREAK : wait for a falling edge ------------------------
04E4   0E58        1858            wait      Event,TimeOut,EvExt 
04E5 U 0008        1859            jxev      act_evext          ;external event coming from the MSBi (falling edge)
04E6 U 0009        1860            jtime     act_to             ;timeout from the sleep timer
04E7   E662        1861            call      cmdrcvd            ;command from the MLX16
04E8   E424        1862            jmp       act_wait 
                   1863  
                   1864                                         ;EvExt -------------------------------------------------------------
                   1865  act_evext                              ;get the Status registers from the MSBi cell
04E9   3A62        1866            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
04EA   88A6        1867            msk       B,#8               ;check the bus level
04EB U 0001        1868            jz        break_start        ;Z is set if the bus is low (break start)
     U             1869                                         ;if there was a timeout at the same time, ignore it and process the edge
04EC   E424        1870            jmp       act_wait 
                   1871  
                   1872                                         ;TimeOut -----------------------------------------------------------
                   1873  act_to                                 ;check the status of the sleep timer
04ED   6F62        1874            call      CheckSleepTmr      ;check the status of the sleep timer (result in C)
04EE U 0000        1875            jc        act_gts            ;if C is not set, the counter did not overflow, keep waiting
04EF   E924        1876            jmp       act_evext          ;sleep timer did not overflow, check the bus
                   1877  act_gts                                ;timeout counter overflows, goto sleep
04F0   86B5        1878            mov       X,#slTO            ;signal that the sleep mode is entered after a sleep timer timeout
04F1 U 0020        1879            jmp       gotosleep 
     U             1880  
     U             1881  break_start                            ;BREAK start detected : prepare to measure the BREAK length
04F2   8E62        1882            call      sleep_tmr_dis      ;disable the sleep timer
                   1883            
                   1884                                         ;make sure that the counter started 
04F3   A037        1885            dcom      7,0A0h             ;10 10 0000
                   1886            
                   1887                                         ;set the baudrate bloc
04F4   0D38        1888            dcom      8,0Dh              ;00 00 1101
                   1889                                         ;      Edg[2:0]=101: Fast Rising Edge
04F5   0538        1890            dcom      8,05h              ;00 00 0101
                   1891                                         ;      Rst[1:0]=01: reset by a Br Match and not by an edge
04F6   7934        1892            dcom      4,79h              ;0 1 11 1001
                   1893                                         ;   \  \    \
                   1894                                         ;    \  \    load ToEn[2:0]=001 : LTimeOut driven only by Br
                   1895                                         ;     \  reset Ftfr : fast edges set the traffic bit
                   1896                                         ;      reset internal flags: yes
                   1897                                         ;do not miss the first overflow
04F7   3A30        1898            dcom      0,03Ah             ;00 00 11 1010
                   1899                                         ;  \  \  \    \
                   1900                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                   1901                                         ;    \  \  SiCk: set SiCk (19/12/05)
                   1902                                         ;     \  FlStRj: nop
                   1903                                         ;      StCpt: nop
                   1904                                         ;set the capture flag (to measure precisely the end of the break field)
04F8   F639        1905            dcom      9,0F6h             ;11 11 0110
                   1906                                         ;  \  \    \
                   1907                                         ;   \  \    BrPls : BrMatch -> BrCk, HalfMatch -> IntbrCk
                   1908                                         ;    \  RptCap : set (if cleared clear Capt on next edge)
                   1909                                         ;     Capt : set (capture cpt in IntBr on edge)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 61  Win32 Assembler
                                LIN2B.ASM

                   1910                                         ;check if this is an auto addressing frame
04F9   6CB2        1911            mov       B,AutoAddMode      ;x x x x
                   1912                                         ; \ \ \ \
                   1913                                         ;  \ \ \ within generation
                   1914                                         ;   \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                   1915                                         ;    \ auto addressing always enabled
                   1916                                         ;     not used
04FA   86A6        1917            msk       B,#6               ;ENABLED or AUTO mode are set
04FB U 0001        1918            jz        abr_checkbus       ;this is not an auto addressing frame, keep going            
     U             1919            
04FC   81F6        1920            or        B,#1               ;set generation
04FD   6C72        1921            mov       AutoAddMode,B 
04FE   6EB2        1922            mov       B,AutoAddCpt       ;check if a pulse should be sent immediately
04FF   8FA6        1923            msk       B,#15 
0500 U 0011        1924            jnz       abr_checkbus       ;no pulse has to be sent
0501   7663        1925            call      autoadd_pls        ;send a pulse now
                   1926  
                   1927  abr_checkbus                           ;check once more if the bus is low
                   1928                                         ;do an access to the analog
                   1929            AnalogAccess  
                    417                                         ;do an access to the analog
0502   C33C         418            dcom      12,11000011b       ;1 abc 0 hi j
                    419                                         ;            \
                    420                                         ;             RWB : read analog IO address 0hiabc
0503   88B6        1930            mov       B,#8 
0504   38BE        1931            and       B,io:18h 
0505 U 0001        1932            jz        abr_wait           ;the bus is low, go to regular wait
     U             1933                                         ;the bus is high, that was a false start
0506   9424        1934            jmp       act_init_er_no_sig ;go back to start with potential erRXSTOP error generation
                   1935  
                   1936                                         ; BREAK and SYNC processing ----------------------------------------
                   1937                                         ; F10 is used to indicate the step processed:
                   1938                                         ; 00 : break start detected, waiting for a rising edge
                   1939                                         ; 01 : break low level length capture, waiting for the start bit of the sync field
                   1940                                         ; 10 : processing the sync field
                   1941  
                   1942  abr_wait                               ;wait for next event or ovf in BREAK-DEL-SYNC
0507   0E58        1943            wait      Event,TimeOut,EvExt 
0508 U 0009        1944            jtime     abr_timeout        ;timeout from the MSBi (sleep timer disabled)
0509 U 0008        1945            jxev      abr_evext          ;external event coming from the MSBi (edge)
050A   E662        1946            call      cmdrcvd            ;command from the MLX16
050B   0725        1947            jmp       abr_wait 
                   1948  
                   1949  abr_evext                              ;external event detected (edge)
050C   3A62        1950            call      ReadStatus 
050D U 0020        1951            jmp       abr_edge 
     U             1952  
     U             1953  abr_timeout                            ;timeout detected (counter overflow)
050E   3A62        1954            call      ReadStatus 
050F   5CB1        1955            mov       X,LINbrflag        ;x x x x
                   1956                                         ; \ \ \ \
                   1957                                         ;  \ \ \ edge to be processed
                   1958                                         ;   \ \ not used
                   1959                                         ;    \ baudrate detected
                   1960                                         ;     auto baudrate on every frame
                   1961            
0510   8EBD        1962            and       X,#14              ;first reset edge to be processed flag in every case
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 62  Win32 Assembler
                                LIN2B.ASM

0511   81A6        1963            msk       B,#1               ;test if a runerr came
0512 U 0011        1964            jnz       abr_ovf_err 
0513   8CA7        1965            msk       A,#12              ;status register 0 (and clear the flags): {Traffic,LEvExt,Ovf,BrEv}
0514 U 0001        1966            jz        abr_ovf_proc       ;no RunError, no traffic, no LEvExt
     U             1967                                         ;there has been some traffic, or LEvExt bit has been set (we should not test runerr since it's likely set by IntBrck that we don't care about at this moment)
     U             1968  abr_ovf_err                            ;an edge was detected right after the timeout event (before reading the stats)
0515   81F5        1969            or        X,#1               ;set edge to be processed flag            
                   1970  abr_ovf_proc                           ;now process the overflow
0516   5C71        1971            mov       LINbrflag,X        ;store is in LINbrflag (with or without edge to process checked)
0517   5040        1972            set       C                  ;increment the counter
0518   046C        1973            switch    F10 
0519 U 0020        1974            jmp       abr_breakovf       ;00: break start detected, waiting for a rising edge
051A U 0020        1975            jmp       abr_breakhiovf     ;01: break low level length capture, waiting for the start bit of the sync field
051B U 0020        1976            jmp       abr_syncovf        ;10: processing the sync field
051C   0725        1977            jmp       abr_wait           ;11: not implemented
                   1978  
                   1979  abr_ovf_end                            ;check the edge needs to be processed flag
051D   5CB1        1980            mov       X,LINbrflag        ;x x x x
051E   81A5        1981            msk       X,#1               ; \ \ \ \
                   1982                                         ;  \ \ \ edge to be processed
                   1983                                         ;   \ \ not used
                   1984                                         ;    \ baudrate detected
                   1985                                         ;     auto baudrate on every frame
051F U 0001        1986            jz        jmp_abr_wait       ;no edge needs processing
     U             1987                                         ;an edge needs processing
0520   8EBD        1988            and       X,#14              ;clear the edge to be processed flag
0521   5C71        1989            mov       LINbrflag,X 
                   1990  abr_edge                               ;now process the edge
0522   4F48        1991            dmaw      LINtmp+1,#0        ;read IntBr (captured value of the counter)
0523   046C        1992            switch    F10 
0524 U 0020        1993            jmp       abr_breakedg       ;00: break start detected, waiting for a rising edge
0525 U 0020        1994            jmp       abr_breakhiedg     ;01: break low level length capture, waiting for the start bit of the sync field
0526 U 0020        1995            jmp       abr_syncedg        ;10: processing the sync field
     U             1996                                         ;11: not implemented
0527   0725        1997  jmp_abr_wait  jmp       abr_wait       ;go back to waiting loop
                   1998  
                   1999  abr_breakovf                           ;break low overflow --------
0528   4E48        2000            dmaw      LINtmp,#0 
0529   C061        2001            call      brcpt_updt         ;Add LINtmp to LINbrcpt, function returns with X=LINbrcpt+4
052A   83E5        2002            cmp       X,#{abSHORTOVF shr 4} ;compare Linbrcpt+4 and Linbrcpt+3 with abSHORTOVF, jump bus_short if equal 
052B U 0011        2003            jnz       abr_breakovf_pls   ;proceed break overflow
052C   43B1        2004            mov       X,LINbrcpt+3 
052D   85E5        2005            cmp       X,#abSHORTOVF and 15 
052E U 0011        2006            jnz       abr_breakovf_pls   ;proceed break overflow
052F U 0020        2007            jmp       BusShort           ; Line low for to long, probably a bus short to GND
     U             2008  abr_breakovf_pls                       ;generate autoadressing pulses
0530   6CB1        2009            mov       X,AutoAddMode      ;x x x x
                   2010                                         ; \ \ \ \
                   2011                                         ;  \ \ \ within generation
                   2012                                         ;   \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                   2013                                         ;    \ auto addressing always enabled
                   2014                                         ;     not used
0531   81A5        2015            msk       X,#1               ;test if autoadressing must be generated
0532 U 0001        2016            jz        abr_breakovf_fin   ;if not set, auto addressing is not used (or is finished), just divide the length
     U             2017                                         ;we are in the auto addressing phase
0533   68B1        2018            mov       X,AutoAddPrCnt 
0534   81C5        2019            sub       X,#1 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 63  Win32 Assembler
                                LIN2B.ASM

0535   6871        2020            mov       AutoAddPrCnt,X 
0536   69B1        2021            mov       X,AutoAddPrCnt+1 
0537   80CD        2022            subcz     X,#0 
0538   6971        2023            mov       AutoAddPrCnt+1,X 
0539 U 0011        2024            jnz       abr_breakovf_fin   ;we are not at Half Tbit pulse, d not decrement the autoaddressing counter
     U             2025                                         ;divider reached, re-init divider number
053A   664D        2026            dmar      #1,AutoAddPrsc 
053B   6849        2027            dmaw      AutoAddPrCnt,#1 
                   2028                                         ;decrement the auto-addressing counter
053C   6EB1        2029            mov       X,AutoAddCpt 
053D   81C5        2030            sub       X,#1 
053E   6E71        2031            mov       AutoAddCpt,X       ;store AutoAddCpt
053F U 0011        2032            jnz       abr_breakovf_fin   ;go do the length comparison
     U             2033                                         ;send a pulse
0540   7663        2034            call      autoadd_pls 
                   2035  abr_breakovf_fin                       ;end of break overflow proecude
0541   1D25        2036            jmp       abr_ovf_end        ;finish the break overflow procedure
                   2037                                         ;-----------------------
                   2038  
                   2039  abr_breakhiovf                         ;break hi overflow
                   2040                                         ;the counter has overflowed
0542   D661        2041            call      brhicpt_inc        ;Increase LINbrhicpt with 0x100, function returns with X=LINbrhicpt+3
0543   7172        2042            mov       Btmp,B             ;save B
0544   56B2        2043            mov       B,LINbrhicpt+2 
0545   42C2        2044            sub       B,LINbrcpt+2       ;substract the length of the break
0546   43C9        2045            subcz     X,LINbrcpt+3 
0547   1045        2046            shift     X,10h              ;divide the result by 2
0548   1646        2047            rrc       B 
0549   42E2        2048            cmp       B,LINbrcpt+2       ;do the comparison
054A   43E9        2049            cmpcz     X,LINbrcpt+3 
054B U 0010        2050            jnc       abr_nobreak        ;break high level is too long, go wait for a new break
054C   71B2        2051            mov       B,Btmp             ;restore B
054D   1D25        2052            jmp       abr_ovf_end        ;check if there was a falling edge also
054E   9424        2053  abr_nobreak  jmp       act_init_er_no_sig ;go wait for a new break
                   2054                                         ;-----------------------
                   2055  
                   2056  abr_syncovf                            ;sync overflow ---------
054F   5AB1        2057            mov       X,LINbrtmp+2       ;...and for the individual bit
0550   8185        2058            add       X,#1 
0551   5A71        2059            mov       LINbrtmp+2,X 
0552   83E5        2060            cmp       X,#3               ;check that there wasn't 2 overflows for a single bit
0553 U 0010        2061            jnc       abr_sb_len_err     ;sync bit is to long, signal an error and wait for "new" break
     U             2062                                         ;keep going (check if there was also an edge)
0554   1D25        2063            jmp       abr_ovf_end        ;finish the SYNC overflow procedure
                   2064  abr_sb_len_err                         ;sync bit measurement overflowed 2 times so the sync bit is to long
                   2065                                         ;signal an error and wait for a "new" break
0555   9463        2066            call      SYNCerrBLhigh      ;A and B are set with Stat0 Stat1
0556 U 0020        2067            jmp       abr_sb_sync_indiv_error ;signal the error only if we are in fixed baudrate, a enough long break has been detected
     U             2068                                         ;-----------------------
     U             2069  
     U             2070  abr_breakedg                           ;break edge ------------
     U             2071                                         ;a rising edge just occurred (end of BREAK)
     U             2072                                         ;- prepare to receive the start bit of the synch field
0557   C061        2073            call      brcpt_updt         ;add LINtmp to LINbrcpt, function returns with X=LINbrcpt+4
0558   88A6        2074            msk       B,#8               ;B high bit contains the bus value, check that it's acutaly high
0559 U 0011        2075            jnz       abr_breakedg_prescacheck ;the bus is actualy high, enter to delimiter decoding procedure
055A               2076            #IF       coDEBUGMARK eq cvON 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 64  Win32 Assembler
                                LIN2B.ASM

055A   067C        2077            xdcom     #dcERRORDEL        ;mark instruction
055B               2078            #ENDIF    
055B   9424        2079            jmp       act_init_er_no_sig ;signal the error
                   2080  abr_breakedg_prescacheck               ;divide LINbrcpt counter and increment the presca until LINbrcpt is under #abBRKOVF
055C   80B5        2081            mov       X,#0 
055D   44E1        2082            cmp       X,LINbrcpt+4       ;Linbrcpt+4 should be 0
055E U 0000        2083            jc        abr_breakedg_div_counter ;LINbrcpt+4 is not 0, LINbrcpt must be divided by 2 and presca increased 
055F   42B1        2084            mov       X,LINbrcpt+2       ;compare Linbrcpt+2/+3 abBRKOVF
0560   89E5        2085            cmp       X,#abBRKOVF and 15 
0561   43B1        2086            mov       X,LINbrcpt+3 
0562   81ED        2087            cmpcz     X,#{abBRKOVF shr 4} and 15 
0563 U 0000        2088            jc        abr_breakedg_prescaok ;Linbrcpt <= abBRKOVF, continue
     U             2089  abr_breakedg_div_counter               ;divide the counter by 2 and increment presca
0564   3D62        2090            call      IncrPrescA 
0565   0762        2091            call      brcpt_div          ;divide the break value by 2
0566   5C25        2092            jmp       abr_breakedg_prescacheck ;go back to counter length check (counter can be divided several times)
                   2093  
                   2094  abr_breakedg_prescaok                  ;If we are in fixed baudrate, check that presca is not higher than requested one
0567   5CB3        2095            mov       A,LINbrflag        ;x x x x
                   2096                                         ; \ \ \ \ 
                   2097                                         ;  \ \ \ edge to be processed
                   2098                                         ;   \ \ not used
                   2099                                         ;    \ baudrate detected
                   2100                                         ;     auto baudrate on every frame
                   2101            
0568   88A7        2102            msk       A,#8               ;check autobaudrate
0569 U 0011        2103            jnz       abr_breakedg_prescaok_busSok ;autobaudrate is on, skip the check
     U             2104            
056A   84A7        2105            msk       A,#4               ;check if baudrate already detected
056B U 0001        2106            jz        abr_breakedg_prescaok_busSok ;Br not detectedyet, skip the check
     U             2107                                         ;Br has already been detected
056C   07B3        2108            mov       A,LINprescNom 
056D   3EE7        2109            cmp       A,io:1Eh 
056E U 0010        2110            jnc       abr_breakedg_prescaok_busSok ;presca is not higher than requested one, continue
     U             2111                                         ;break was too long
056F   81B6        2112            mov       B,#erSHORTDONE 
0570   9524        2113            jmp       act_init_er_sig    ;presca is higher than requested one, it was probably a short, inform the application
                   2114  abr_breakedg_prescaok_busSok           ;end of autoadressing procedure
                   2115                                         ;check if the auto addressing phase is still on
0571   6CB3        2116            mov       A,AutoAddMode      ;x x x x
                   2117                                         ; \ \ \ \
                   2118                                         ;  \ \ \ within generation
                   2119                                         ;   \ \ auto addressing mode set to auto : set to disabled at the end of the procedure
                   2120                                         ;    \ auto addressing always enabled
                   2121                                         ;     not used
0572   81A7        2122            msk       A,#1               ;check if we are still generating
0573 U 0001        2123            jz        abr_breakedg_fin   ;autoaddressing is not generated, bypass the following steps
     U             2124                                         ;error : send evCOOLAUTO with index = 0
0574   8EBF        2125            and       A,#14 
0575   6C73        2126            mov       AutoAddMode,A      ;disable the auto addressing for this frame (in continuous mode, no change for the next frame)
0576   87B7        2127            mov       A,#evCOOLAUTO      ;send evCOOLAUTO with index = 0
0577   80B6        2128            mov       B,#0               ;signal the start pulse
0578   D262        2129            call      send_event         ;send an event to the application
                   2130  abr_breakedg_fin                       ;end of the autoaddressing processing
                   2131                                         ;copy LINbrcpt to LINbrhicpt
0579   404D        2132            dmar      #1,LINbrcpt 
057A   5449        2133            dmaw      LINbrhicpt,#1 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 65  Win32 Assembler
                                LIN2B.ASM

057B   424D        2134            dmar      #1,LINbrcpt+2 
057C   5649        2135            dmaw      LINbrhicpt+2,#1    ;value of IntBr is in LINtmp add it to the LINbrcpt
                   2136  
                   2137                                         ;BREAK received
057D               2138            #IF       coDEBUGMARK eq cvON 
057D   4A7C        2139            xdcom     #dcBREAK           ;mark instruction
057E               2140            #ENDIF    
                   2141  
                   2142                                         ;prepare the reception of the break delimiter
057E   0E38        2143            dcom      8,0Eh              ;00 00 1110
                   2144                                         ;      Edg[2:0]=110: Fast Falling Edge
057F   0638        2145            dcom      8,06h              ;00 00 0110
                   2146                                         ;      Rst[1:0]=01: reset upon an edge
0580   4C34        2147            dcom      4,4Ch              ;0 1 00 1100
                   2148                                         ;   \  \    \
                   2149                                         ;    \  \    load ToEn[2:0]=100 : LTimeOut driven by Ovf event only
                   2150                                         ;     \  reset Ftfr : fast edges set the traffic bit
                   2151                                         ;      reset internal flags: yes
                   2152            
                   2153                                         ;read IntBr to clear capt_flag (capt_err has been reset with internal flags at the previous instructon)
0581   4F48        2154            dmaw      LINtmp+1,#0        ;read IntBr (captured value of the counter)
                   2155            
0582   015C        2156            mov       F10,#1 
                   2157  
                   2158  
0583   0725        2159            jmp       abr_wait           ;end of the edge procedure, go back to waiting loop
                   2160                                         ;-----------------------
                   2161  
                   2162  abr_breakhiedg                         ;break hi edge ---------
                   2163                                         ;SYNC start detected, update the measured length of the delimiter
                   2164                                         ;value of IntBr is in LINtmp
0584   D061        2165            call      brhicpt_updtb      ;Add LINtmp to LINbrhicpt, function returns with X=LINbrhicpt+3
                   2166  
                   2167                                         ;measure the sync length - this is the measure that will determine the baudrate
                   2168                                         ;8 bits should be measured, then the measurement will be divided by 8 to get the bit time
                   2169  
                   2170                                         ;prepare the reception of the sync field
0585   0F38        2171            dcom      8,0Fh              ;00 00 1111
                   2172                                         ;      Edg[2:0]=111: Fast Falling or Rising Edge
0586   0638        2173            dcom      8,06h              ;00 00 0110
                   2174                                         ;      Rst[1:0]=10: reset upon Edg[2:0]
                   2175                                         ;sync window
0587   0A30        2176            dcom      0,0Ah              ;00 00 00 1010
                   2177                                         ;  \  \  \    \
                   2178                                         ;   \  \  \    immediate load of SyncWindow with 1 - EnStrtEdg = 0
                   2179                                         ;    \  \  SiCk: nop
                   2180                                         ;     \  FlStRj: nop
                   2181                                         ;      StCpt: nop (if set cpt is stopped at next Br match
                   2182                                         ;set the capture flag (to measure precisely the end of the break field)
0588   F039        2183            dcom      9,0F0h             ;11 11 0000
                   2184                                         ;  \  \    \
                   2185                                         ;   \  \    BrPls : nop
                   2186                                         ;    \  RptCap : set (if cleared clear Capt on next edge)
                   2187                                         ;     Capt : set (capture cpt in IntBr on edge)
0589   8F34        2188            dcom      4,08Fh             ;1 0 00 1 1 1 1
                   2189                                         ;   \ \    \ \ \
                   2190                                         ;    \ \    \ \ EnFdb=1: enable fast debounce (BusIn is debounced on a 2/3 majority vote scheme)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 66  Win32 Assembler
                                LIN2B.ASM

                   2191                                         ;     \ \    \ Fbin=1: Bin = fast debounced BusIn
                   2192                                         ;      \ \    AutoDb=1: flag set (DbCk devided by the 4 msb's of the Br register)
                   2193                                         ;       \ RbErr=00: no change
                   2194                                         ;        Rst: no change
058A   025C        2195            mov       F10,#2 
058B   80B5        2196            mov       X,#0               ;initialize the bit counter (0 is for the start bit)
058C   7271        2197            mov       Xtmp,X 
058D   5A71        2198            mov       LINbrtmp+2,X       ;reset the overflow counter
                   2199            
058E   3E4D        2200            dmar      #1,ClearByte       ;use the dma to clear the bytes
058F   4649        2201            dmaw      highsync,#1        ;clear highsync and highsync+1
0590   4849        2202            dmaw      highsync+2,#1      ;clear highsync+2 and lowsync
0591   8FB5        2203            mov       X,#15 
0592   4B71        2204            mov       lowsync+2,X        ;lowsync should begin with a high value
0593   4A71        2205            mov       lowsync+1,X        ;lowsync should begin with a high value
                   2206            
                   2207                                         ;LINbrcpt is not used anymore, we will divide it by 11 to make check of Tbit*11 > break faster at the end of SYNC.
                   2208                                         ;/11 -> 0h0.1745D...
                   2209                                         ;round to 0h0.18 -> we do not dvide by 11 but by 10.6
                   2210                                         ;*0h0.18 -> (shift by 4) + (shift by 5) -> LINbrcpt+0 is not needed for the calculation
0594   43B3        2211            mov       A,LINbrcpt+3 
0595   42B2        2212            mov       B,LINbrcpt+2 
0596   41B1        2213            mov       X,LINbrcpt+1 
                   2214                                         ;clear +2/+3
0597   3E4D        2215            dmar      #1,ClearByte 
0598   4249        2216            dmaw      LINbrcpt+2,#1 
                   2217                                         ;shift by 4 -> mov LINbrcpt+X into LINBrcpt+X-1
0599   4273        2218            mov       LINbrcpt+2,A 
059A   4172        2219            mov       LINbrcpt+1,B 
059B   4071        2220            mov       LINbrcpt,X 
                   2221                                         ;shift by 5 -> shift by 1 then mov LINbrcpt+X into LINBrcpt+X-1
059C   1047        2222            shift     A,10h 
059D   1646        2223            rrc       B 
059E   1645        2224            rrc       X 
059F   4081        2225            add       X,LINbrcpt 
05A0   418A        2226            addcz     B,LINbrcpt+1 
05A1   428B        2227            addcz     A,LINbrcpt+2 
05A2   4071        2228            mov       LINbrcpt,X         ;save LINbrcpt/11 for chck in end of SYNC field
05A3   4172        2229            mov       LINbrcpt+1,B 
05A4   4273        2230            mov       LINbrcpt+2,A 
05A5   5071        2231            mov       LINbrsync,X        ;save it also in linbrSYNC for a minimum break first check now, if the baudrate has been detected
05A6   5172        2232            mov       LINbrsync+1,B 
05A7   5273        2233            mov       LINbrsync+2,A 
05A8   5CB3        2234            mov       A,LINbrflag        ;Autobaudrate flag
                   2235                                         ;x x x x
                   2236                                         ; \ \ \ \
                   2237                                         ;  \ \ \ edge to be processed
                   2238                                         ;   \ \ not used
                   2239                                         ;    \ baudrate detected
                   2240                                         ;     auto baudrate on every frame
05A9   8CBF        2241            and       A,#12 
05AA   84E7        2242            cmp       A,#4 
05AB U 0001        2243            jz        abr_min_break_do_check ;baudrate detected check minimum break
05AC U 0020        2244            jmp       abr_breakhiedg_end ;baudrate not detected, don't check the minimum break length since we don't know Tbit for the moment
     U             2245  abr_min_break_do_check  
05AD   3EB7        2246            mov       A,io:1Eh           ;load the actual prescaler
                   2247  abr_min_break_divPresc  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 67  Win32 Assembler
                                LIN2B.ASM

05AE   07E3        2248            cmp       A,LINprescNom      ;compare rrquested and actual prescaler
05AF U 0010        2249            jnc       abr_min_break_check ;both prescaler are equals, go to check counters
05B0   8187        2250            add       A,#1               ;increase prescaler register
05B1   52B1        2251            mov       X,LINbrsync+2      ;divide LINbrsync by 2, it contains break length/11
05B2   1045        2252            shift     X,10h 
05B3   5271        2253            mov       LINbrsync+2,X 
05B4   51B1        2254            mov       X,LINbrsync+1 
05B5   1645        2255            rrc       X 
05B6   5171        2256            mov       LINbrsync+1,X 
05B7   50B1        2257            mov       X,LINbrsync 
05B8   1645        2258            rrc       X 
05B9   5071        2259            mov       LINbrsync,X 
05BA   AE25        2260            jmp       abr_min_break_divPresc ;check again precalers
                   2261  abr_min_break_check                    ;prescalers are equals, compare the counters 
05BB   50B1        2262            mov       X,LINbrsync        ;compare requested counter with LINbrsync (break length/11)
05BC   04E1        2263            cmp       X,LINbrNom 
05BD   51B1        2264            mov       X,LINbrsync+1 
05BE   05E9        2265            cmpcz     X,LINbrNom+1 
05BF   52B1        2266            mov       X,LINbrsync+2 
05C0   80ED        2267            cmpcz     X,#0 
05C1 U 0010        2268            jnc       abr_breakhiedg_end ;Linbrsync is higher than requested BR, break minimum length is ok
05C2   9424        2269            jmp       act_init_er_no_sig ;break length is too short, go back to active without signaling the error
                   2270  abr_breakhiedg_end  
05C3   5049        2271            dmaw      LINbrsync,#1       ;clear LINbrsync and LINbrsync+1
05C4   5249        2272            dmaw      LINbrsync+2,#1     ;clear LINbrsync+2 and LINbrsync+3
05C5   0725        2273            jmp       abr_wait 
                   2274                                         ;-----------------------
                   2275  
                   2276  abr_syncedg                            ;there was an edge, increment the counter (br counter is in LINtmp) and check indiv length
                   2277                                         ;add LINtmp to LINbrsync, function returns with X=LINbrsync+3
                   2278                                         ;and calculate Tbit +/- 50%, save it in low/high sync if highet low or lowest high. to check at the end of the sync                             
05C6   DD61        2279            call      low_high_sync_record 
05C7 U 0010        2280            jnc       abr_syncedg_ok     ;individual sync bit was enough long
05C8 U 0020        2281            jmp       abr_sb_sync_indiv_error ;individual sync bit was very short compared with the break, go back to break detection directly
     U             2282                                         ;reset the overflow counter
05C9   80B5        2283  abr_syncedg_ok  mov       X,#0         ;prepare next bit reception
05CA   5A71        2284            mov       LINbrtmp+2,X 
                   2285                                         ;increment the bit counter
05CB   72B1        2286            mov       X,Xtmp             ;get the bit counter
05CC   8185        2287            add       X,#1               ;increment the bit counter
05CD   7271        2288            mov       Xtmp,X             ;save the bit counter
05CE   88E5        2289            cmp       X,#8 
05CF U 0001        2290            jz        abr_sb_meas        ;last bit, process the time
05D0   0725        2291            jmp       abr_wait 
                   2292                                         ;---------------------------------------------------------------------------
                   2293  
                   2294  abr_sb_meas                            ;SYNC field processing
                   2295                                         ;make a division by 8 - and keep the lsbs for baudrate correction if enabled
05D1   50B1        2296            mov       X,LINbrsync 
05D2   9245        2297            asl       X                  ;a division by 8 is a multiplication by 2 and a division by 16
05D3   6A71        2298            mov       LINbrLSBs,X        ;the lsb of X should always be 0
05D4   53B1        2299            mov       X,LINbrsync+3      ;LinBrsync value before the division is not higher than 0x1800, after the division, LINbrsync+3 is always 0
05D5   80B7        2300            mov       A,#0 
05D6   5373        2301            mov       LINbrsync+3,A 
05D7   51B3        2302            mov       A,LINbrsync+1 
05D8   52B2        2303            mov       B,LINbrsync+2 
05D9   9647        2304            rlc       A 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 68  Win32 Assembler
                                LIN2B.ASM

05DA   9646        2305            rlc       B 
05DB   9645        2306            rlc       X 
05DC   5073        2307            mov       LINbrsync,A 
05DD   5172        2308            mov       LINbrsync+1,B 
05DE   5271        2309            mov       LINbrsync+2,X 
                   2310  abr_sb_sync_indiv_check                ;check if individual sync bit length was ok
05DF   1045        2311            shift     X,10h              ;divide Br by 2
05E0   1646        2312            rrc       B 
05E1   1647        2313            rrc       A 
05E2   49E3        2314            cmp       A,lowsync          ;compare it to the shortest individual bit
05E3   4AEA        2315            cmpcz     B,lowsync+1 
05E4   4BE9        2316            cmpcz     X,lowsync+2 
05E5 U 0010        2317            jnc       abr_sb_sync_indiv_error ;Br divided by 2 is longer than the shortest indiv sync bit, go to error
05E6   5083        2318            add       A,LINbrsync        ;calculate Br*1.5
05E7   518A        2319            addcz     B,LINbrsync+1 
05E8   5289        2320            addcz     X,LINbrsync+2 
05E9   46E3        2321            cmp       A,highsync         ;compare it to the longest individual bit
05EA   47EA        2322            cmpcz     B,highsync+1 
05EB   48E9        2323            cmpcz     X,highsync+2 
05EC U 0000        2324            jc        abr_sb_sync_indiv_error ;Br*1.5 is shorter than the longest indiv sync bit, go to error
05ED U 0020        2325            jmp       abr_sb_sync_indiv_check_ok 
     U             2326  abr_sb_sync_indiv_error                ;one individual bit is not within Br margins, send an error 
05EE   5CB3        2327            mov       A,LINbrflag        ;if the baudrate is detected, the error should be sent sice the minimum break length has already been checked
05EF   8CBF        2328            and       A,#12 
05F0   84E7        2329            cmp       A,#4 
05F1 U 0011        2330            jnz       abr_sb_sync_indiv_error_nsig ;baudrate not detected don't signal the SYNC bit error
05F2   84B5        2331            mov       X,#erSYNCbhi       ;a SYNC bit error came and the break minum length was ok, signal the error
05F3   88B6        2332            mov       B,#erSYNC 
05F4   9524        2333            jmp       act_init_er_sig    ;back to active with error signalment
                   2334  abr_sb_sync_indiv_error_nsig  
05F5   9424        2335            jmp       act_init_er_no_sig ;one individual bit is not within Br margins, go to error
                   2336  abr_sb_sync_indiv_check_ok             ;individual bits length checked
                   2337                                         ;the bit time should be between 99 (63h) and 199 (C7h)
05F6   3EB7        2338            mov       A,io:1Eh           ;load the prescaler
05F7   52B2        2339  abr_sb_div  mov       B,LINbrsync+2    ;check if the measured bit time is more than 8 bits
05F8   80E6        2340            cmp       B,#0 
05F9   53B1        2341            mov       X,LINbrsync+3 
05FA   80ED        2342            cmpcz     X,#0 
05FB U 0011        2343            jnz       abr_sb_prediv      ;LINbrsync+3 is not 0, divide the counter and increas ethe prescaler
05FC U 0020        2344            jmp       abr_sb_presc       ;continue
05FD   8187        2345  abr_sb_prediv  add       A,#1          ;increment the prescaler
                   2346                                         ;divide the measured bit time by 2
05FE   1045        2347            shift     X,10h              ;X contains LINbrsync+3
05FF   5371        2348            mov       LINbrsync+3,X 
0600   1646        2349            rrc       B                  ;B contains LINbrsync+2
0601   5272        2350            mov       LINbrsync+2,B 
0602   51B2        2351            mov       B,LINbrsync+1 
0603   1646        2352            rrc       B 
0604   5172        2353            mov       LINbrsync+1,B 
0605   50B2        2354            mov       B,LINbrsync 
0606   1646        2355            rrc       B 
0607   5072        2356            mov       LINbrsync,B 
                   2357                                         ;divide also the LSBs
0608   6AB2        2358            mov       B,LINbrLSBs 
0609   1646        2359            rrc       B 
060A   8EBE        2360            and       B,#14              ;the lsb should always be 0
060B   6A72        2361            mov       LINbrLSBs,B 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 69  Win32 Assembler
                                LIN2B.ASM

060C   FB61        2362            call      brhicpt_brcpt_div  ;divide also the measured break lengths
060D   F725        2363            jmp       abr_sb_div         ;loop until the higher nibble is 0
                   2364  abr_sb_presc                           ;LINbrsync+2 is 0, check if the bit time is more than 199 (C7h)
060E   50B2        2365            mov       B,LINbrsync 
060F   51B1        2366            mov       X,LINbrsync+1 
0610   87E6        2367            cmp       B,#7 
0611   8CED        2368            cmpcz     X,#12 
0612 U 0010        2369            jnc       abr_sb_divagain    ;div the Br and increment the prescaler one more time
0613 U 0020        2370            jmp       abr_sb_save        ;the bit time value is less than 199, the values are ok
     U             2371  abr_sb_divagain                        ;do a last division
0614   1045        2372            shift     X,10h              ;X contains LINbrsync+1
0615   1646        2373            rrc       B                  ;B contains LINbrsync
0616   7271        2374            mov       Xtmp,X 
0617   FB61        2375            call      brhicpt_brcpt_div  ;divide also the measured break lengths
0618   72B1        2376            mov       X,Xtmp 
0619   8187        2377            add       A,#1               ;increment the prescaler
061A   5872        2378  abr_sb_save  mov       LINbrtmp,B      ;save the baudrate to temporary register
061B   5971        2379            mov       LINbrtmp+1,X 
061C   3EB5        2380            mov       X,io:1Eh           ;save the prescaler
061D   3E77        2381            mov       io:1Eh,A           ;update it with the correct value
                   2382                                         ;clear an eventual timeout
061E   3A62        2383            call      ReadStatus 
                   2384                                         ;wait for the start of the sync byte stop bit
061F   4F48        2385            dmaw      LINtmp+1,#0        ;read IntBr (captured value of the counter)
0620   0D38        2386            dcom      8,0Dh              ;00 00 1101
                   2387                                         ;      Edg[2:0]=001: Fast Rising Edge
0621   0638        2388            dcom      8,06h              ;00 00 0110
                   2389                                         ; \    \
                   2390                                         ;  \ Rst[1:0]=10: reset upon Edg[2:0]
                   2391                                         ;   Nop
                   2392  abr_sb_wait_div                        ;divide also LINtmp if presca has been increased already
0622   3EE5        2393            cmp       X,io:1Eh           ;Lintmp contains the counter time we needed for the operation, will be used for bit7 length test calculation
0623 U 0001        2394            jz        abr_sb_wait        ;if the presca hasn't been modified, continue (Intbr is saved in LINtmp)
0624   8185        2395            add       X,#1               ;else divide LINtmp
0625   4FB3        2396            mov       A,LINtmp+1 
0626   4EB2        2397            mov       B,LINtmp 
0627   1047        2398            shift     A,10h 
0628   1646        2399            rrc       B 
0629   4F73        2400            mov       LINtmp+1,A 
062A   4E72        2401            mov       LINtmp,B 
062B   2226        2402            jmp       abr_sb_wait_div 
                   2403  
062C   0E58        2404  abr_sb_wait  wait      Event,Timeout,EvExt ;wait for rising edge of the stop bit
062D U 0009        2405            jtime     abr_sb_error_to    ;timeout from the MSBi
062E U 0008        2406            jxev      abr_sb_end         ;external event coming from the MSBi (edge)
062F   E662        2407            call      cmdrcvd            ;command from the MLX16
0630   2C26        2408            jmp       abr_sb_wait 
                   2409  
                   2410  abr_sb_error_to                        ;a timeout occured while waiting for the stop bit
0631   3A62        2411            call      ReadStatus         ;read status register
0632   81B5        2412            mov       X,#1               ;set LINbrtmp+2 to a full overflow
0633   5A71        2413            mov       LINbrtmp+2,X 
0634   9463        2414            call      SYNCerrBLhigh      ;enter into the collision handling proc
                   2415  abr_sb_error                           ;an error has been detected after bit 7 recieved
0635   83B5        2416            mov       X,#erSYNCsbhi 
                   2417  sync_err_det                           ;an error sync has been detected
0636   88B6        2418            mov       B,#erSYNC 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 70  Win32 Assembler
                                LIN2B.ASM

0637   9524        2419            jmp       act_init_er_sig    ;signal the error
                   2420  
                   2421  abr_sb_end                             ;we are here at the stop bit of the SYNC field. this part (until wstart_init) is the most critical in term of time needed and directly
                   2422                                         ;influence the minimum Mlx4 frequency allowed
                   2423                                         ;this entire procedure must finish before the PID start bit. It does the following checks:
                   2424                                         ; - Bit 7 was not too long (false stop bit)
                   2425                                         ; - Break+Del < 28Tbit
                   2426                                         ; - Break > 11 Tbit
                   2427                                         ; - Check 15% Margin in case of fixed Br
                   2428                                         ; - report a frame inside frame if it is (LINerrStat == XXX1)
                   2429                                         ; - Prepare MSBI for next start bit
                   2430            
                   2431                                         ;call ReadStatus        ;we directly write the readStatus proc instead of calling it to earn 2 instructions (call, ret)
0638   39B7        2432            mov       A,io:19h           ;read status register 0 (and clear the flags): {Traffic,LEvExt,Ovf,BrEv}
0639   38B6        2433            mov       B,io:18h           ;read status register 1 (and clear the flags): {Bin,SplBin,SyncErr,RunErr}
                   2434  
063A   8A34        2435            dcom      4,8Ah              ;1 0 00 1 0 1 0
                   2436                                         ;   \ \    \ \ \
                   2437                                         ;    \ \    \ \ EnFdb=1: enable fast debounce (BusIn is debounced on a 2/3 majority vote scheme)
                   2438                                         ;     \ \    \ Fbin=1: Bin = fast debounced BusIn
                   2439                                         ;      \ \    AutoDb=1: flag set (DbCk devided by the 4 msb's of the Br register)
                   2440                                         ;       \ RbErr=00: no change
                   2441                                         ;        Rst: no change
                   2442                                         ;SYNC field received correctly ------------------------------------------------------
063B   584C        2443            dmar      #0,LINbrtmp        ;generate pulses to count the break length every Tbit
                   2444            
                   2445                                         ;do the low limit calculation : 11 Tbits (see section 2.3.1.1 of spec 2.1)
                   2446                                         ;LINbrcpt contains break length divided by 11
                   2447                                         ;here, we should check that Tbit < LINbrcpt
063C   42B3        2448            mov       A,LINbrcpt+2 
063D   80E7        2449            cmp       A,#0 
063E U 0001        2450            jz        abr_cptlowdo       ;LINbrcpt/11 is less than 0x100, do the check
063F U 0020        2451            jmp       abr_brlowdone      ;LINbrcpt/11 is more than 0x100, no need to check
     U             2452  abr_cptlowdo                           ;check if LINbrct/11 is more than Br detected (minimum length check)        
0640   40B3        2453            mov       A,LINbrcpt 
0641   41B2        2454            mov       B,LINbrcpt+1 
0642   58E3        2455            cmp       A,LINbrtmp 
0643   59EA        2456            cmpcz     B,LINbrtmp+1 
0644 U 0010        2457            jnc       abr_brlowdone      ;LINbrcpt/11 is more than Br detected, minimum break length is ok
     U             2458  
     U             2459  break_tooshort                         ;false BREAK: too short
0645               2460            #IF       coDEBUGMARK eq cvON 
0645   047C        2461            xdcom     #dcBREAKER         ;mark instruction (error)
0646               2462            #ENDIF    
0646   9424        2463            jmp       act_init_er_no_sig ;break was too short, go back to break waiting loop with no error signal
                   2464            
                   2465  abr_brlowdone  
                   2466                                         ;bit7 maximum length check
0647   4EB3        2467            mov       A,LINtmp 
0648   4FB2        2468            mov       B,LINtmp+1 
0649   4F48        2469            dmaw      LINtmp+1,#0        ;read IntBr (captured value of the counter)
064A   4E83        2470            add       A,LINtmp 
064B   4F8A        2471            addcz     B,LINtmp+1 
064C U 0010        2472            jnc       abr_sb_end_noovf   ;bit 7 did not overflowed, continue
     U             2473  abr_sb_end_ovf                         ;counter overflowed, this is cleary incorrect (0x63<br<0xC0 +-50%)
064D   3526        2474            jmp       abr_sb_error 
                   2475  abr_sb_end_noovf                       ;check if the bit 7 is within Br margin
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 71  Win32 Assembler
                                LIN2B.ASM

                   2476                                         ;Divide by 2 = 50%
064E   4E73        2477            mov       LINtmp,A 
064F   4F72        2478            mov       LINtmp+1,B 
0650   58B3        2479            mov       A,LINbrtmp 
0651   59B2        2480            mov       B,LINbrtmp+1 
0652   1046        2481            shift     B,10h 
0653   1647        2482            rrc       A 
0654   5883        2483            add       A,LINbrtmp 
0655   598A        2484            addcz     B,LINbrtmp+1 
0656 U 0000        2485            jc        abr_sb_end_ok      ;BR*1.5 overflowed, condition is ok
0657   4EE3        2486            cmp       A,LINtmp 
0658   4FEA        2487            cmpcz     B,LINtmp+1 
0659 U 0010        2488            jnc       abr_sb_end_ok      ;Bit7 < BR*1.5, continue 
065A   3526        2489            jmp       abr_sb_error       ;bit length is not within the +50% margin
                   2490  
                   2491  
                   2492                                         ;Theader_max = 1.4*35 = 49
                   2493                                         ;Tbreak_low_max = 49-1-10-10 = 28 rounded to 32 for ease of coding and measure inconsistency
                   2494                                         ;the maximum length for the break is 32 Tbits, so 32*199 (because a Tbit is comprised between
                   2495                                         ;99 and 199), which is 18e0h
                   2496  abr_sb_end_ok                          ;do the high limit calculation (32 Tbit) = Tbit[<<1]<<1
065B   58B3        2497            mov       A,LINbrtmp 
065C   9247        2498            asl       A 
065D   59B2        2499            mov       B,LINbrtmp+1 
065E   9646        2500            rlc       B 
065F   80B5        2501            mov       X,#0 
0660   3071        2502            mov       LINtocnt,X 
0661   9645        2503            rlc       X 
0662   3173        2504            mov       LINtocnt+1,A 
0663   3272        2505            mov       LINtocnt+2,B 
0664   3371        2506            mov       LINtocnt+3,X 
                   2507  
                   2508                                         ;do the comparison
0665   55E3        2509            cmp       A,LINbrhicpt+1     ;A already contains LINtocnt+1
0666   56EA        2510            cmpcz     B,LINbrhicpt+2     ;B already contains LINtocnt+2
0667   57E9        2511            cmpcz     X,LINbrhicpt+3     ;X already contains LINtocnt+3
0668 U 0010        2512            jnc       abr_cptdone        ;the break is less than 32 Tbit, proceed
     U             2513                                         ;the BREAK is too long, signal an error
0669   85B5        2514            mov       X,#erSYNChead 
066A   3626        2515            jmp       sync_err_det       ;the BREAK is too long, signal an error
                   2516            
                   2517  abr_cptdone                            ;Header was ok
                   2518                                         ;Check if we are in fixed baudrate or single shot auto baudrate mode
066B   5CB1        2519            mov       X,LINbrflag        ;x x x x
066C   88A5        2520            msk       X,#8               ; \ \ \ \
                   2521                                         ;  \ \ \ edge to be processed
                   2522                                         ;   \ \ not used
                   2523                                         ;    \ baudrate detected
                   2524                                         ;     auto baudrate on every frame
066D U 0011        2525            jnz       abr_SYNC_noChk     ;We are doing auto baudrate on every frame
     U             2526                                         ;no auto baudrate on every frame
066E   84A5        2527            msk       X,#4 
066F U 0011        2528            jnz       abr_SYNC_Chk       ;Baudrate has already been detected, now check margins
     U             2529  abr_SYNC_noChk                         ;No baudrate has been detected yet, go on without checking margins
0670 U 0020        2530            jmp       abr_SYNC_Fin       ;Br is not fixed yet, directly go to end of SYNC procedure
     U             2531  
     U             2532  abr_SYNC_Chk                           ;verify that the resulting baudrate is not higher than the nominal baudrate plus a 15% margin
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 72  Win32 Assembler
                                LIN2B.ASM

     U             2533                                         ;Compute an approximation of the absolute value of a 15% margin on the nominal baudrate.
     U             2534                                         ;This approximation is based on the fact that x/8 + x/32 yields a result very close to x * 0.15
     U             2535                                         ;Be carreful here: we are working with time and not freq value, so the deviation formula change:
     U             2536                                         ;Brdev = |Brnom - Br|/Brnom = |Tbitnom - Tbit|/Tbit
     U             2537                                         ;This part (until abr_SYNC_Fin) has been optimized for minimizing the number of instruction
     U             2538                                         ;needed for the program to check but not in term memory space needed (instructions in total).
     U             2539                                         ;Divide by 8
0671   59B3        2540            mov       A,LINbrtmp+1       ;use detected baudrate for margin calculations
0672   58B1        2541            mov       X,LINbrtmp 
0673   9245        2542            asl       X 
0674   9647        2543            rlc       A                  ;/8 = /16 * 2
0675   80B6        2544            mov       B,#0 
0676   808E        2545            addcz     B,#0 
0677   8187        2546            add       A,#1               ;add 1 to high nibble since we will not make the carries addition
0678   808E        2547            addcz     B,#0 
0679   4E73        2548            mov       LINtmp,A           ;Copy the Result to LINtmp, forget low nibble, not needed
                   2549                                         ;Divide by 32
067A   59B3        2550            mov       A,LINbrtmp+1 
067B   1047        2551            shift     A,10h              ;/32 = /16 / 2
067C   4E83        2552            add       A,LINtmp 
067D   808E        2553            addcz     B,#0 
067E   4E73        2554            mov       LINtmp,A           ;Copy the 15% margin to LINtmp
067F   4F72        2555            mov       LINtmp+1,B 
0680   58B3        2556            mov       A,LINbrtmp         ;reload Br into A,B,X for next comparisons
0681   59B2        2557            mov       B,LINbrtmp+1 
0682   3EB5        2558            mov       X,io:1Eh 
                   2559                                         ;here we will compare Br recieved and requested and only one of +15% or -15% conditions
                   2560                                         ;depending on if bigger or lower
                   2561                                         ; Br_Nom > Br  ->  check only that Br+15% > Br_Nom
                   2562                                         ; Br_Nom < Br  ->  check only that Br-15% < Br_Nom
0683   07E1        2563            cmp       X,LINprescNom 
0684 U 0001        2564            jz        abr_SYNC_Chk_cmp_cnt ;Presca are equal, compare cnt
0685 U 0000        2565            jc        abr_SYNC_Chk_Hi    ;Presca < Presca_Nom compare only Br+15% > Br_Nom
0686 U 0020        2566            jmp       abr_SYNC_Chk_Lo    ;Presca > Presca_Nom compare only Br-15% < Br_Nom
     U             2567  abr_SYNC_Chk_cmp_cnt                   ;Presca are equal, compare cnt
0687   04E3        2568            cmp       A,LINbrNom         ;compare Br and Br_Nom counters
0688   05EA        2569            cmpcz     B,LINbrNom+1 
0689 U 0000        2570            jc        abr_SYNC_Chk_Hi    ;Br < Br_Nom -> compare only Br+15% > Br_Nom
068A U 0020        2571            jmp       abr_SYNC_Chk_Lo    ;Br > Br_Nom compare only Br-15% < Br_Nom
     U             2572            
     U             2573  abr_SYNC_Chk_Hi                        ;Compare Br+15% > Br_Nom
068B   4E83        2574            add       A,LINtmp           ;add 15% of Br_Nom to Br
068C   4F8A        2575            addcz     B,LINtmp+1 
                   2576                                         ;Check if the value is 200 or more (C8h)
068D   88E7        2577            cmp       A,#8 
068E   8CEE        2578            cmpcz     B,#12 
068F U 0000        2579            jc        abr_SYNC_ChkHiDoPresc ;it's not higher, make the test directly
     U             2580                                         ;Margin is higher than 199
0690   8185        2581            add       X,#1               ;Increase Temp value of PrescNom
0691   1046        2582            shift     B,10h              ;Divide Br margin value by 2
0692   1647        2583            rrc       A 
                   2584  abr_SYNC_ChkHiDoPresc                  ;Do PrescA high margin check
0693   07E1        2585            cmp       X,LINprescNom      ;LINprescNom should be less than or equal to PrescA
0694 U 0001        2586            jz        abr_SYNC_ChkHiDoCnt ;Presca are equals, go check the cnt               
0695 U 0000        2587            jc        abr_SYNC_ChHiEr    ;Presca is still lower than Presca_Nom -> error
0696 U 0020        2588            jmp       abr_SYNC_Fin       ;Presca is higher than Presca_Nom -> test is ok
     U             2589  abr_SYNC_ChkHiDoCnt                    ;Do cnt high margin check
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 73  Win32 Assembler
                                LIN2B.ASM

0697   04E3        2590            cmp       A,LINbrNom 
0698   05EA        2591            cmpcz     B,LINbrNom+1 
0699 U 0010        2592            jnc       jmp_abr_SYNC_Fin   ;LINbrtmp+15% is more than or equal to Br_Nom, 15% check is ok
069A   82B5        2593  abr_SYNC_ChHiEr  mov       X,#erSYNChi ;LINbrtmp+15% is less than Br_Nom, 15% check is not ok    
069B   3626        2594            jmp       sync_err_det       ;generate an error
                   2595  abr_SYNC_Chk_Lo                        ;Compare Br-15% < Br_Nom
069C   4EC3        2596            sub       A,LINtmp           ;sub 15% of Br_Nom to Br
069D   4FCA        2597            subcz     B,LINtmp+1 
                   2598                                         ;Check if the value is below 99 (63h)
069E   83E7        2599            cmp       A,#3 
069F   86EE        2600            cmpcz     B,#6 
06A0 U 0010        2601            jnc       abr_SYNC_ChkLoDoPresc ;it's not lower, make the test directly    
     U             2602                                         ;Margin is below 99
06A1   81C5        2603            sub       X,#1               ;Decrease Temp value of PrescNom
06A2   9247        2604            asl       A                  ;Multiply Br margin value by 2
06A3   9646        2605            rlc       B 
                   2606  abr_SYNC_ChkLoDoPresc                  ;Do PrescA low margin check
06A4   07E1        2607            cmp       X,LINprescNom 
06A5 U 0001        2608            jz        abr_SYNC_ChkLoDoCnt ;Presca are equals, go check the cnt               
06A6 U 0010        2609            jnc       abr_SYNC_ChLoEr    ;Presca is still higher than Presca_Nom -> error
     U             2610  jmp_abr_SYNC_Fin                       ;Presca is lower than Presca_Nom -> test is ok
06A7 U 0020        2611            jmp       abr_SYNC_Fin       ;go to end of SYNC procedure
     U             2612  abr_SYNC_ChkLoDoCnt                    ;Do cnt low margin check
06A8   04E3        2613            cmp       A,LINbrNom 
06A9   05EA        2614            cmpcz     B,LINbrNom+1 
06AA U 0000        2615            jc        abr_SYNC_Fin       ;LINbrtmp-15% is less than or equal to Br_Nom, 15% check is ok                
06AB   81B5        2616  abr_SYNC_ChLoEr  mov       X,#erSYNClo ;LINbrtmp-15% is more than Br_Nom, 15% check is not ok
06AC   3626        2617            jmp       sync_err_det       ;generate an error
                   2618  abr_SYNC_Fin                           ;end of SYNC check procedure, set MSBI to wait for start of ID
                   2619                                         ;let's update the baudrate
06AD   584D        2620            dmar      #1,LINbrtmp 
06AE   0249        2621            dmaw      LINbr,#1 
06AF   3EB7        2622            mov       A,io:1Eh 
06B0   0673        2623            mov       LINpresc,A 
                   2624  
                   2625                                         ;Br register (dma access)
06B1   024C        2626            dmar      #0,LINbr           ;generate pulses to count the break length every Tbit
                   2627  
                   2628                                         ;Send SYNC+Br
06B2               2629            #IF       coDEBUGMARK eq cvON 
06B2   CB7C        2630            xdcom     #dcSYNC            ;mark instruction
06B3   027D        2631            xdma      LINbr              ;send the calculated baudrate
06B4               2632            #ENDIF    
                   2633  
                   2634                                         ;update the traffic flag
06B4   5EB2        2635            mov       B,LINstatus        ;x x x x
06B5   81F6        2636            or        B,#1               ; \ \ \ \
                   2637                                         ;  \ \ \ LIN bus activity
                   2638                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   2639                                         ;    \ not used
                   2640                                         ;     event overflow occured
06B6   5E72        2641            mov       LINstatus,B 
                   2642  
                   2643                                         ;StatCtrl
06B7   4A34        2644            dcom      4,4Ah              ;StatCtrl
                   2645                                         ;0 1 00 1010
                   2646                                         ;   \  \    \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 74  Win32 Assembler
                                LIN2B.ASM

                   2647                                         ;    \  \    load ToEn[2:0]=010 : LTimeOut driven only by IntBr Flag
                   2648                                         ;     \  reset Ftfr : nop
                   2649                                         ;      reset internal flags: yes
                   2650  
                   2651                                         ;event in the middle of a bit
06B8   0639        2652            dcom      9,06h              ;00 00 0110
                   2653                                         ;  \  \    \
                   2654                                         ;   \  \    immediate load of BrPls[1:0]=10 : HalfMatch -> InBrCk
                   2655                                         ;    \  RptCap : nop
                   2656                                         ;     Capt : nop
06B9   81B6        2657            mov       B,#1 
                   2658                                         ;Header length max check, LINbrhicpt incremented and check to be < 28 Tbit (48 -ID - SYNC)
                   2659                                         ;Stop bit of the sync should not increment LINbrhicpt since it's already taken into account in this 28 = 48-20.
                   2660                                         ;Initialize LINtmp with 1. at the wstart bit, we will decrement it and update LINbrhicpt only if = 0.
06BA   4E72        2661            mov       LINtmp,B 
                   2662            
                   2663                                         ;A...
                   2664                                         ;B is used to move the registers around
                   2665                                         ;X is only used to count the bits received
                   2666                                         ;--- the SYNC field has been received, let's proceed with the ID and data bytes...
06BB   4572        2667            mov       LINparity,B        ;preset the buffer used for parity verification of the ID field
06BC   39B2        2668            mov       B,LINbytcnt        ;save Bytcnt old value, it will be sent if Break in frame
06BD   7172        2669            mov       Btmp,B 
06BE   8FB6        2670            mov       B,#15              ;preset the data byte counter (F for the ID, 0 for the first byte...)
06BF   3972        2671            mov       LINbytcnt,B 
06C0   005C        2672            mov       F10,#0             ;reset F0 and F1
                   2673                                         ;initialize the index compare buffers with the init flags
06C1   1C4D        2674            dmar      #1,LIN_IDsInit     ;use CmpRW for 8 bits access
06C2   6249        2675            dmaw      indx1_tmp,#1 
06C3   2C4D        2676            dmar      #1,LIN_IDsInit2 
06C4   2E49        2677            dmaw      indx2_tmp,#1 
06C5   80B6        2678            mov       B,#0 
06C6   0D72        2679            mov       LINindex+1,B       ;preset the ID page register
                   2680  wstart_init                            ;--------------------------------------------------
                   2681                                         ;wait for a Start Bit : use the false start bit rejection?          <-???
                   2682  
                   2683                                         ;no data in A,B or X
                   2684                                         ;Baudrate bloc Re-Initialization
06C7   0738        2685            dcom      8,07h              ;00 00 0111
                   2686                                         ;  \  \    \
                   2687                                         ;   \  \    Rst[1:0]=11 : Re-Synch mode : reset upon selected edge (see next instruction)
                   2688                                         ;    \  nop
                   2689                                         ;     Init: nop
06C8   0E38        2690            dcom      8,0Eh              ;00 00 1110
                   2691                                         ;      Edg[2:0]=110: Fast Falling Edge
06C9   3034        2692            dcom      4,30h              ;0 0 11 0000
                   2693                                         ;   \  \    \
                   2694                                         ;    \  \    nop
                   2695                                         ;     \  set Ftfr : fast edges set the traffic bit
                   2696                                         ;      nop
                   2697  
06CA   0E58        2698  wstart    wait      Event,TimeOut,EvExt 
                   2699                                         ;check the source that ended the wait
                   2700                                         ;if RunErr is set, the mlx4 failed to process the event in time
                   2701                                         ;Description of what happens in case an event and a timeout occur at the exact same time:
                   2702                                         ;- the event (falling edge) is processed, the timeout is ignored
06CB U 0008        2703            jxev      wstart_ev          ;if it's an external event (edge!)  <- start of the bit
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 75  Win32 Assembler
                                LIN2B.ASM

06CC U 0009        2704            jtime     wstart_to          ;if it's a timeout...       <- increment/check the response timeout counter
06CD   E662        2705            call      cmdrcvd            ;else check if it is a command from the Mlx16   <- command?
06CE   CA26        2706            jmp       wstart 
                   2707  
                   2708  wstart_ev                              ;external event : check the source (and reset the flags / acknowledge the event)
06CF   3A62        2709            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
06D0   88A6        2710            msk       B,#8               ;check if the bus is actualy dominant
06D1 U 0001        2711            jz        jmp_wstart_ok      ;the bus is still recessive, false event? go back to wstart
06D2   CA26        2712            jmp       wstart 
                   2713  jmp_wstart_ok  
06D3 U 0020        2714            jmp       wstart_ok          ;other event
     U             2715  
     U             2716  wstart_to                              ;timeout : check that it comes from the baudrate counter
     U             2717                                         ;check the status registers (and reset the flags / acknowledge the event!)
06D4   3A62        2718            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   2719                                         ;test if there was an edge at the same time (in that case ignore the timeout)
06D5   88A6        2720            msk       B,#8               ;{Bin,X,X,X}
06D6 U 0011        2721            jnz       wstart_tstto       ;the bus is still recessive, process timeout
06D7 U 0020        2722            jmp       wstart_ok          ;the bus is dominant, process start bit immediately
     U             2723  
06D8   81A7        2724  wstart_tstto  msk       A,#1           ;check that the timeout comes from the baudrate counter
06D9 U 0011        2725            jnz       wstart_tocnt       ;timeout comes from the MSBI
     U             2726                                         ;check the status of the sleep timer
06DA   6F62        2727            call      CheckSleepTmr 
06DB U 0000        2728            jc        wstart_gts         ;if C is set, the counter did overflow, we should go to sleep
06DC   CA26        2729            jmp       wstart 
                   2730  wstart_gts  
                   2731                                         ;timeout counter overflows, goto sleep
06DD   86B5        2732            mov       X,#slTO            ;signal that the sleep mode is entered after a sleep timer timeout
06DE U 0020        2733            jmp       gotosleep 
     U             2734  
     U             2735  wstart_tocnt                           ;the Timeout comes from the MSBI
     U             2736                                         ;there is a difference here if we are waiting for the ID start bit (we are still in the header)
06DF   39B2        2737            mov       B,LINbytcnt 
06E0   8FE6        2738            cmp       B,#15 
06E1 U 0011        2739            jnz       wstart_data 
     U             2740                                         ;waiting for the ID
     U             2741                                         ;BrEv : increment LINbrhicpt that measures the header length and check if it's not too long (> 28Tbit)
     U             2742                                         ;First two timeout should be not processed since the stop bit of the SYNC is already taken in 28 = 48-20
     U             2743                                         ;LINtmp has been intialized with 1 in SYNC. check if it's 0, if not, decrement it and do nothing
06E2   80B6        2744            mov       B,#0 
06E3   4EE2        2745            cmp       B,LINtmp 
06E4 U 0011        2746            jnz       wstart_nincr_headerto 
06E5   5962        2747            call      IncrLINbrhicpt     ;Increment Linbrhicpt with Linbr
06E6   6662        2748            call      CheckHeaderLen     ;check if the header length is not too long (LINbrhicpt<LINbtocnt) (LINtocnt = 28Tbit)
06E7 U 0000        2749            jc        jmp_wstart 
     U             2750  wstart_header                          ;the BREAK is too long, signal an error
06E8   85B5        2751            mov       X,#erSYNChead 
06E9   71B2        2752            mov       B,Btmp             ;load LINbytcnt with the old byte cnt value if stopbiter must be sent
06EA   3972        2753            mov       LINbytcnt,B 
06EB   88B6        2754            mov       B,#erSYNC 
06EC   9524        2755            jmp       act_init_er_sig    ;signal the error but signal BRFRM instead if header in frame                
                   2756  wstart_nincr_headerto                  ;SYNC stop bit, do not increment the timeout but launch the sleep timer
06ED   4E72        2757            mov       LINtmp,B           ;reset LINtmp in order to begin to count for maximum header length
                   2758                                         ;enable the sleep timer in case the start bit never comes do this operation at the first stop bit timeout (B = 1->0) to not overload Stop sync bit procedures
06EE   8262        2759            call      sleep_tmr 
                   2760  jmp_wstart                             ;go back to waiting start
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 76  Win32 Assembler
                                LIN2B.ASM

06EF   CA26        2761            jmp       wstart             ;go back to waiting start
                   2762  
                   2763  wstart_data                            ;increment the bit counter for the time out and check that the timeout hasn't been reached <- note : this is not relevant in LIN spec 2.1
06F0               2764            #IF       cvTO2x eq cvTO13 
06F0   CA26        2772            jmp       wstart             ;no edge, go back to the waiting loop
06F1               2773            #ENDIF    
                   2774  
                   2775  wstart_ok                              ;received correct start bit
06F1   3AB3        2776            mov       A,MessStatus       ;x x x x
                   2777                                         ; \ \ \ \
                   2778                                         ;  \ \ \ waiting for instruction from Mlx16
                   2779                                         ;   \ \ start bit already received
                   2780                                         ;    \ indicates that a bit time has passed after the ID (allow immediate start of TX)
                   2781                                         ;    message information received
06F2   82F7        2782            or        A,#2               ;signal that the start bit has already been received
06F3   3A73        2783            mov       MessStatus,A 
                   2784  
                   2785                                         ;disable the sleep timer
06F4   8E62        2786            call      sleep_tmr_dis 
                   2787  
06F5               2788            #IF       coDEBUGMARK eq cvON 
06F5   4C7C        2789            xdcom     #dcSTART           ;mark instruction
06F6               2790            #ENDIF    
                   2791  
                   2792                                         ;the counter has been automatically reset
                   2793                                         ;now wait only for timeouts to get the bits
                   2794  
                   2795                                         ;Baudrate bloc
06F6   0538        2796            dcom      8,05h              ;00 00 0101
                   2797                                         ;  \  \    \
                   2798                                         ;   \  \    Rst[1:0]=01: reset with BrMatch (no edges anymore)
                   2799                                         ;    \  nop
                   2800                                         ;     Init: nop
06F7   0838        2801            dcom      8,08h              ;00 00 1000
                   2802                                         ;      Edg[2:0]=000: no effect
                   2803                                         ;event in the middle of a bit
06F8   0639        2804            dcom      9,06h              ;00 00 0110
                   2805                                         ;  \  \    \
                   2806                                         ;   \  \    immediate load of BrPls[1:0]=10 : HalfMatch -> InBrCk
                   2807                                         ;    \  RptCap : nop
                   2808                                         ;     Capt : nop
                   2809  
                   2810  
                   2811  wbit_initcnt                           ;--------------------------------------------------
06F9   3E4D        2812            dmar      #1,ClearByte       ;initialize LINbrcpt counter for in-frame break detection (use the dma to clear the byte)
06FA   4049        2813            dmaw      LINbrcpt,#1 
06FB   4249        2814            dmaw      LINbrcpt+2,#1 
06FC   80B5        2815            mov       X,#0 
06FD   4471        2816            mov       LINbrcpt+4,X 
                   2817                                         ;A and B used to move things around or check registers
                   2818                                         ;X (de)count the bit received : from 9 to 0 - the first bit will be the start bit
06FE   89B5        2819            mov       X,#9 
                   2820  
                   2821                                         ;----------------------------------------------------------------------------------------------------------------------
                   2822  wbit                                   ;wait for a timeout (bit) or a command from the MLX16 (no edge detection)
                   2823                                         ;the bit can be an ID bit (F1=0) or a regular databyte (F1=1)
                   2824                                         ;A and B are free, X contains the bit (de)counter
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 77  Win32 Assembler
                                LIN2B.ASM

                   2825                                         ;------------------------------------------------------------------------------------
06FF   0A58        2826            wait      Event,TimeOut 
                   2827                                         ;check the source that ended the wait
0700 U 0009        2828            jtime     wbit_to            ;if it's a timeout...
0701   7271        2829            mov       Xtmp,X 
0702   E662        2830            call      cmdrcvd            ;else check if it is a command from the Mlx16
0703   72B1        2831            mov       X,Xtmp 
0704   FF26        2832            jmp       wbit 
                   2833                                         ;----------------------------------------------------------------------------------------------------------------------
                   2834  wbit_to                                ;check the source of the timeout (and reset the flags / acknowledge the event!)
0705   3A62        2835            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   2836                                         ;get the bit received in C
0706   9646        2837            rlc       B                  ;the bit just received is now in C, B={SplBin,SyncErr,RunErr,x}
0707   0840        2838            mov       F0,C               ;save it into F0
                   2839                                         ;test for errors: if RunErr is set, the mlx4 failed to process the event in time
                   2840                                         ;timeout counter is increased and check at the end of each byte (during the stop bit)
0708   4663        2841            call      BRcorrection 
                   2842  
0709               2843            #IF       cvTO2x eq cvTO13   ;the timeout check is not needed any more as per LIN spec 2.1
                   2861  
                   2862                                         ;-------------------------------------------------------------------
                   2863                                         ;check if this is the stop bit ------------------------------------------------------
0709   8FA5        2864            msk       X,#15              ;does not affect C - X contains the bit (de)counter
070A U 0001        2865            jz        stopbit 
070B U 0020        2866            jmp       rxbrcorrdone       ;is this the stop bit? No, jump to do the zero-bit counting thing
     U             2867  stopbit                                ;stop bit
     U             2868                                         ;check if the bit is high (F0 should be set)
070C U 0014        2869            jnf0      stopbiter 
     U             2870                                         ;stop bit correct, prepare the msbi cell and then check the timeout
     U             2871                                         ;Baudrate bloc Re-Initialization
070D   0738        2872            dcom      8,07h              ;00 00 0111
                   2873                                         ;  \  \    \
                   2874                                         ;   \  \    Rst[1:0]=11 : Re-Synch mode : reset upon selected edge (see next instruction)
                   2875                                         ;    \  nop
                   2876                                         ;     Init: nop
070E   0E38        2877            dcom      8,0Eh              ;00 00 1110
                   2878                                         ;      Edg[2:0]=110: Fast Falling Edge
070F   3034        2879            dcom      4,30h              ;0 0 11 0000
                   2880                                         ;   \  \    \
                   2881                                         ;    \  \    nop
                   2882                                         ;     \  set Ftfr : fast edges set the traffic bit
                   2883                                         ;      nop
                   2884  
0710 U 0020        2885            jmp       databytrcvd        ;stop bit received correctly
     U             2886  toerr                                  ;timeout error : send LINtocnt content
0711   39B2        2887            mov       B,LINbytcnt        ;get the byte number
0712   3872        2888            mov       LINmessbuf,B       ;store the byte of the collision in LINmessbuf
0713   8BB6        2889            mov       B,#erTORESP        ;signal an error : reponse timeout
0714   B562        2890            call      errev 
0715   A324        2891            jmp       act_init 
                   2892  
                   2893  stopbiter                              ;A real stop bit error has been detected, notify MLX16 of this, prepare for frame in frame reception
                   2894                                         ;reset the counter and change Br and IntBr
0716   A037        2895            dcom      7,0A0h             ;1 0 10 0000
                   2896                                         ;   \  \    \
                   2897                                         ;    \  \    BrCk/OutCk pulse : nop
                   2898                                         ;     \  counter : reset and start
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 78  Win32 Assembler
                                LIN2B.ASM

                   2899                                         ;      capture : nop
0717   39B2        2900            mov       B,LINbytcnt        ;get the byte number
0718   3872        2901            mov       LINmessbuf,B       ;store the byte of the collision in LINmessbuf
0719   4040        2902            clr       C                  ;carry used if cvTO13, should be cleared again here
071A   4A62        2903            call      UpdateZeroCpt      ;to get the correct LinBrcpt value in act_init
                   2904                                         ;the stop bit wasn't received : it is a zero instead. Maybe from a new break... so go wait for an end-of-break
071B U 0015        2905            jnf1      idstopbiter        ;ID stop bit? (F1=0)
     U             2906                                         ;data stop bit error
     U             2907                                         ;set corresponding error bit
071C   3BB2        2908            mov       B,LINerrStat       ;x x x x
071D   81F6        2909            or        B,#1               ; \ \ \ \
                   2910                                         ;  \ \ \ data stop bit error detected
                   2911                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   2912                                         ;    \ collision error detected
                   2913                                         ;     ID stop bit error detected
071E   3B72        2914            mov       LINerrStat,B 
071F   A324        2915            jmp       act_init 
                   2916  idstopbiter                            ;ID stop bit error
                   2917                                         ;set corresponding error bit
0720   3BB2        2918            mov       B,LINerrStat       ;x x x x
0721   88F6        2919            or        B,#8               ; \ \ \ \
                   2920                                         ;  \ \ \ data stop bit error detected
                   2921                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   2922                                         ;    \ collision error detected
                   2923                                         ;     ID stop bit error detected
0722   3B72        2924            mov       LINerrStat,B 
                   2925                                         ;LINmessbuf is already filled with LINbytcnt
0723   87B6        2926            mov       B,#erIDSTOP 
0724   B562        2927  senderr   call      errev              ;send an event to signal the error
0725   A324        2928            jmp       act_init 
                   2929  
                   2930                                         ;---------------------------------
                   2931  rxbrcorrdone                           ;do the zero-bit counting thing - A used, B not used
0726   6040        2932            mov       C,F0               ;Bin is in F0
0727   4A62        2933            call      UpdateZeroCpt 
                   2934  
                   2935                                         ;check if this is the start bit
0728   89E5        2936            cmp       X,#9 
0729 U 0011        2937            jnz       regular 
072A   39B3        2938            mov       A,LINbytcnt        ;check if we are recieving the ID
072B   8FE7        2939            cmp       A,#15 
072C U 0001        2940            jz        decount            ;If yes, don't check the start bit since a stop bit error can be pending
     U             2941                                         ;start bit, check that the bus is low
072D U 0014        2942            jnf0      decount            ;bus s low, start bit ok
072E   86B6        2943            mov       B,#erRX            ;bus is high, start bit not recieved correctly
072F   3873        2944            mov       LINmessbuf,A       ;store byte cnt into the 4st message nibble
0730   81B5        2945            mov       X,#erRXSTART 
0731   B562        2946            call      errev              ;send an event to signal the error
0732   A324        2947            jmp       act_init 
                   2948            
                   2949  regular   
                   2950                                         ;regular bit ------------------------------------------------------------------------
                   2951                                         ;this is not the stop bit, put back Bin into C
0733   6040        2952            mov       C,F0 
                   2953                                         ;this is not the stop bit, update the buffer (the bit is in C)
0734   2E62        2954            call      shift_bytbuf       ;LINbytbuf+1 is in A, LINbytbuf in B, the bit shifted out in C
                   2955  
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 79  Win32 Assembler
                                LIN2B.ASM

                   2956                                         ;test if this is the ID (F1=0) or just a databyte (F1=1)
0735 U 0005        2957            jf1       decount 
0736 U 0020        2958            jmp       IDbyte             ;this is the ID
     U             2959  
     U             2960  decount                                ;this is not the ID field, decrement X (bit counter) and keep waiting
0737   81C5        2961            sub       X,#1 
0738   FF26        2962            jmp       wbit 
                   2963  
                   2964  IDbyte                                 ;We are currently receiving the ID byte (but not the start bit) ---------------------
                   2965                                         ;The ID is 6 bits of data and followed by 2 bits of parity
                   2966                                         ;bits 0 to 5 - ID : compare each bit received with the RAM table, process the parity
                   2967                                         ;bit 6 - parity bit 0 : get the result of the above comparison, if no index is recognized, check the ROM table
                   2968                                         ;                       the local index (if any) is then available in LINindex.
                   2969                                         ;                       If the ID is not recognized (in RAM and ROM), LINindex+1 msb is set
                   2970                                         ;bit 7 - parity bit 1 : check the parity
                   2971                                         ;stop bit
0739   83E5        2972            cmp       X,#3               ;compare only the first 6 bits (do not compare the parity bits)
073A U 0010        2973            jnc       IDcomp 
     U             2974                                         ;parity bits - no compare operation
073B U 0020        2975            jmp       IDcheckpar 
     U             2976  
     U             2977  IDcomp                                 ;check the ID in the RAM table ---
     U             2978                                         ;get the offset
073C   91B7        2979            mov       A,X 
073D   8FD7        2980            xor       A,#0Fh             ;inverse it (to get the index)
073E   8187        2981            add       A,#1 
073F   87BF        2982            and       A,#7 
0740   9247        2983            asl       A                  ;multiply by 2 (we are working with words and dma!)
                   2984                                         ;put back Bin in C
0741   6040        2985            mov       C,F0               ;restore Bin : the incoming bit has to be in C
                   2986  
                   2987                                         ;Bank #1 -------------------------
0742   624D        2988            dmar      #1,indx1_tmp       ;load the compare register : CmpRW = indx1_tmp (lsb=0)
                   2989                                         ;before receiving the first bit, indx1_tmp is preset to 0xFF
                   2990                                         ;CmpChk: compare the incoming bit (in C)
0743   874E        2991            dmar      #2,LIN_IDs shr 4[A] 
                   2992  
                   2993                                         ;IdIdx is loaded, save it before handling the next ID bank
0744   3DB6        2994            mov       B,io:1Dh           ;if IdIdx = 8, that means the ID hasn't been recognized
0745   1E72        2995            mov       LINindxbk1,B       ;save IdIdx for the bank 1
                   2996  
                   2997                                         ;save the temporary result (bank #1)
0746   6249        2998            dmaw      indx1_tmp,#1       ;CmpRW
                   2999  
                   3000                                         ;Bank #2 -------------------------
0747   2E4D        3001            dmar      #1,indx2_tmp       ;load the compare register : CmpRW = indx2_tmp (lsb=0)
                   3002                                         ;before receiving the first bit, indx2_tmp is preset to 0xFF
                   3003                                         ;CmpChk: compare the incoming bit (in C)
0748   8B4E        3004            dmar      #2,LIN_IDs2 shr 4[A] 
                   3005  
                   3006                                         ;IdIdx is loaded, save it before handling the next ID bank
0749   3DB6        3007            mov       B,io:1Dh           ;if IdIdx = 8, that means the ID hasn't been recognized
074A   1F72        3008            mov       LINindxbk2,B       ;save IdIdx for the bank 2
                   3009  
                   3010                                         ;save the temporary result (bank #1)
074B   2E49        3011            dmaw      indx2_tmp,#1       ;CmpRW
                   3012  IDcheckpar                             ;put back Bin in C
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 80  Win32 Assembler
                                LIN2B.ASM

074C   9274        3013            mov       B,F                ;the incoming bit is in F0, bit 0 of register F
074D   81BE        3014            and       B,#1               ;B={000,Bin}
                   3015  
                   3016                                         ;--------------- calculate the parity -------------
074E   81A5        3017            msk       X,#1               ;check if the bit we just received is odd (0,2,4 -> Z not set) or even (1,3,5 -> Z set)
                   3018                                         ;  X    bit     Z
                   3019                                         ; 1001 (9)  start bit   0
                   3020                                         ; 1000 (8)  bit 0       0
                   3021                                         ; 0111 (7)  bit 1       1
                   3022                                         ; 0110 (6)  bit 2       0
                   3023                                         ; 0101 (5)  bit 3       1
                   3024                                         ; 0100 (4)  bit 4       0
                   3025                                         ; 0011 (3)  bit 5       1
                   3026                                         ; 0010 (2)  bit 6 (parity bit 0)
                   3027                                         ; 0001 (1)  bit 7 (parity bit 1)
                   3028                                         ; 0000 (0)  stop bit
074F U 0011        3029            jnz       IDbodd 
0750   9246        3030            asl       B                  ;if bit is odd B={00,Bin,0}, if bit is even B={000,Bin}
0751   45D2        3031  IDbodd    xor       B,LINparity        ;LINparity=0001 B={00,Bin,1}
0752   4572        3032            mov       LINparity,B        ;(bit0) LINparity={00,b0,1}
                   3033                                         ;(bit1) LINparity={00,b0,~b1}
                   3034                                         ;(bit2) LINparity={00,b0 xor b2,~b1}
                   3035                                         ;(bit3) LINparity={00,b0 xor b2,~b1 xor b3}
                   3036                                         ;(bit4) LINparity={00,b0 xor b2 xor b4,~b1 xor b3}
                   3037                                         ;(bit5) LINparity={00,b0 xor b2 xor b4,~b1 xor b3 xor b5}
                   3038                                         ;(p0)   LINparity={00,b0 xor b2 xor b4 xor p0,~b1 xor b3 xor b5}
                   3039                                         ;(p1)   LINparity={00,b0 xor b2 xor b4 xor p0,~b1 xor b3 xor b5 xor p1}
                   3040                                         ;note: ~(a xor b) = ~a xor b
                   3041  
                   3042                                         ;check if this was the last bit of the ID, if it was, check if the ID is correct and do the post-processing
0753   81C5        3043            sub       X,#1               ;decrease the bit counter
0754   016C        3044            switch    X 
0755 U 0020        3045            jmp       IDprocess1         ;X = 0 -> go to IDprocess1 (parity ID bit 1)
0756 U 0020        3046            jmp       IDprocess0         ;X = 1 -> go to IDprocess0 (parity ID bit 0)
0757 U 0020        3047            jmp       IDbit5             ;X = 2 -> go to IDbit5 (ID bit 5)
0758   FF26        3048            jmp       wbit               ;X = 3 -> go to wbit (regular ID bit)
0759   FF26        3049            jmp       wbit               ;X = 4
075A   FF26        3050            jmp       wbit               ;X = 5
075B   FF26        3051            jmp       wbit               ;X = 6
075C U 0020        3052            jmp       tst_brfrm          ;X = 7 (first bit)
075D   FF26        3053            jmp       wbit               ;X = 8 (start bit)
                   3054  
                   3055  tst_brfrm  
                   3056                                         ;check if it was a break inside frame
075E   3BB3        3057            mov       A,LINerrStat       ;x x x x
075F   81A7        3058            msk       A,#1               ; \ \ \ \
                   3059                                         ;  \ \ \ data stop bit error detected
                   3060                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   3061                                         ;    \ collision error detected
                   3062                                         ;     ID stop bit error detected
0760 U 0001        3063            jz        jmp_wbit 
     U             3064                                         ;it was a break inside a frame, reset the flags and signal the error
0761   80B7        3065            mov       A,#0 
0762   3B73        3066            mov       LINerrStat,A 
                   3067  
                   3068                                         ;a break within a response frame has been detected, signal the error
0763   71B2        3069            mov       B,Btmp             ;get the byte number
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 81  Win32 Assembler
                                LIN2B.ASM

0764   3872        3070            mov       LINmessbuf,B       ;store the byte of the collision in LINmessbuf
0765   8CB6        3071            mov       B,#erBRFRM 
0766   B562        3072            call      errev 
                   3073  jmp_wbit  
0767   FF26        3074            jmp       wbit 
                   3075                                         ;------------------------------------------------------------------------------------
                   3076  IDprocess1                             ;parity bit 1 received : all the bits have been received check the parity
                   3077                                         ;(and save the ID in LINindex)
                   3078                                         ;P0 = ID0 xor ID1 xor ID2 xor ID4
                   3079                                         ;P1 = ~(ID1 xor ID3 xor ID4 xor ID5)
                   3080                                         ;Perform some postprocessing to verify the parity bits. The results of a XOR on all odd and even databits is...
                   3081                                         ;... already available (in LINparity), now XOR bit 1 with all even bits and bit 4 with the odd ones.
0768   08B3        3082            mov       A,LINbytbuf        ;A = {ID3 ID2 ID1 ID0}
0769   0E73        3083            mov       LINIDtmp,A         ;save the protected ID
076A   82BF        3084            and       A,#2               ;              {0, 0, ID1, 0}
076B   45D3        3085            xor       A,LINparity        ;LINparity = {0, 0, ID0 xor ID2 xor ID4 xor P0, ~ID1 xor ID3 xor ID5 xor P1}
                   3086                                         ;A =         {0, 0, ID0 xor ID1 xor ID2 xor ID4 xor P0, ~ID1 xor ID3 xor ID5 xor P1}
076C   09B2        3087            mov       B,LINbytbuf+1      ;B = {P1, P0, ID5, ID4}
076D   0F72        3088            mov       LINIDtmp+1,B       ;save the protected ID
076E   81BE        3089            and       B,#1               ;              {0, 0, 0, ID4}
076F   92D7        3090            xor       A,B                ;A = {0, 0, ID0 xor ID1 xor ID2 xor ID4 xor P0, ~ID1 xor ID3 xor ID4 xor ID5 xor P1}
                   3091                                         ;A is 0 if the parity is correct
0770 U 0011        3092            jnz       IDpar_err 
     U             3093                                         ;the ID was correctly received
0771   FF26        3094            jmp       wbit 
                   3095  
                   3096  IDpar_err                              ;ID parity error! ----------------
0772   83B6        3097            mov       B,#erIDPAR 
0773   B562        3098            call      errev              ;send an event to signal an ID parity error
                   3099                                         ;test if the bus is at 0, in that case it can be a collision
0774   38B6        3100            mov       B,io:18h           ;read status register 1 {Bin,SplBin,SyncErr,RunErr}
0775   88A6        3101            msk       B,#8 
0776 U 0011        3102            jnz       idparer_hi 
     U             3103                                         ;the bus is low, set the collision bit
0777   3BB3        3104            mov       A,LINerrStat       ;x x x x
0778   84F7        3105            or        A,#4               ; \ \ \ \
                   3106                                         ;  \ \ \ data stop bit error detected
                   3107                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   3108                                         ;    \ collision error detected
                   3109                                         ;     ID stop bit error detected
0779   3B73        3110            mov       LINerrStat,A 
                   3111  idparer_hi                             ;the bus is high, proceed
077A   A324        3112            jmp       act_init           ;go wait for the next frame
                   3113  
                   3114                                         ;------------------------------------------------------------------------------------
                   3115  IDprocess0                             ;parity bit 0 received - get the arguments of the frame (if it has been recognized)
                   3116                                         ;check if the ID was recognized
077B   0DB3        3117            mov       A,LINindex+1       ;test if the ID has been recognized (LINindex contains a valid index)
077C   88A7        3118            msk       A,#8 
077D U 0001        3119            jz        restore_indx       ;yes : restore the indexes
077E   81B5        3120            mov       X,#1               ;restore the bit counter for parity bit 1
077F   FF26        3121            jmp       wbit               ;go wait for parity bit 1
                   3122  restore_indx                           ;restore the indexes, which were calculated during the processing of ID bit 5
0780   60B3        3123            mov       A,ParamBuf 
0781   61B1        3124            mov       X,ParamBuf+1 
0782   80F5        3125            or        X,#PARAMtableX 
                   3126                                         ;MemTab has been set during the reception of bit 5
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 82  Win32 Assembler
                                LIN2B.ASM

0783   A7B6        3127            mov       B,Rom:TableRom[X,A] ;  X A = 0iii iii0
0784   6072        3128            mov       ParamBuf,B         ;save the data in RAM : there are 2 nibbles to get
0785   8187        3129            add       A,#1 
0786   A7B6        3130            mov       B,Rom:TableRom[X,A] 
0787   6172        3131            mov       ParamBuf+1,B 
                   3132                                         ;arguments saved... wait for the stop bit before processing them
0788   81B5        3133            mov       X,#1               ;restore the bit counter for parity bit 1
0789   FF26        3134            jmp       wbit               ;go wait for parity bit 1
                   3135  
                   3136                                         ;------------------------------------------------------------------------------------
                   3137  IDbit5                                 ;bit 5 received - the index should be ready, prepare the ROM table access - check if this is a special ID (3C, 3D, 3E, 3F)
078A   09B2        3138            mov       B,LINbytbuf+1      ;{bit5, bit4, bit3, bit2}
078B   8FE6        3139            cmp       B,#15 
078C   6FB3        3140            mov       A,LINframeflag 
078D U 0011        3141            jnz       nospclid           ;jnz test with cmp B,#15, two last lines has been swapped to enable jnz to nospclid (not more than 15 lines)
078E   81F7        3142            or        A,#1               ;x x x x
                   3143                                         ; \ \ \ \
                   3144                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3145                                         ;    \ discard the frame
                   3146                                         ;     frame data ready for transmit
078F   6F73        3147            mov       LINframeflag,A 
0790   08B3        3148  nospclid  mov       A,LINbytbuf        ;{bit1, bit0, x, x}
0791   1046        3149            shift     B,10h              ;insert a 0
0792   1647        3150            rrc       A 
0793   1046        3151            shift     B,10h              ;insert a 0
0794   1647        3152            rrc       A                  ;keep only bits 5 to 0, the index is ready in A and B
0795   0D72        3153            mov       LINindex+1,B       ;save the ID
0796   0C73        3154            mov       LINindex,A 
                   3155                                         ;for ID Filtering Mode, check the result of the filtering
                   3156                                         ;check if the ID was recognized : if an ID was recognized in RAM, LINindxbk1 or LINindxbk2 contains its
                   3157                                         ;   index. If they both contain 8, the ID hasn't been recognized.
0797   1EB3        3158            mov       A,LINindxbk1       ;check if the ID has been recognized in the bank 2 (index 0 to 7)
0798   88A7        3159            msk       A,#8 
0799 U 0001        3160            jz        idinram            ;id has been recognized in the bank 1
079A   1FB3        3161            mov       A,LINindxbk2       ;check if the ID has been recognized in the bank 1 (index 8 to 7)
079B   88A7        3162            msk       A,#8 
079C U 0011        3163            jnz       othrbank           ;check other places (ROM...)
     U             3164                                         ;bank 2 ---
079D   8887        3165            add       A,#8               ;add the offset to the index
                   3166                                         ;the index is ready in A (the high nibble should be 0)
079E   0C73        3167  idinram   mov       LINindex,A         ;save the index (replace the ID)
079F   80B6        3168            mov       B,#0               ;if the ID has been recognized in RAM, the Index is between 0 and 15
07A0   0D72        3169            mov       LINindex+1,B       ;LINindex high nibble shoulb be 0
07A1 U 0020        3170            jmp       getframearg 
     U             3171  
     U             3172  othrbank                               ;the ID was not recognized in the RAM table ----------------------------
     U             3173                                         ;check the ROM table (order : nibble1, nibble0, nibble3, nibble2)
     U             3174                                         ;ROM table INDXtbl located in F00, configure Txtab[5:2] (in MemTab 2)
07A2   EA3B        3175            dcom      11,INDXtable       ;11 1111 00
                   3176                                         ;       \  \
                   3177                                         ;        \  Txtab[1:0] = 00 (ored with arom[7:6])
                   3178                                         ;         Txtab[5:2] = 1111 (replace arom[11:8])
                   3179                                         ;Content of the ROM
                   3180                                         ; xx  xxxxxx
                   3181                                         ;   \       \
                   3182                                         ;    \       local index
                   3183                                         ;     00 (0) : ID defined in ROM - index 10h to 3Fh
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 83  Win32 Assembler
                                LIN2B.ASM

                   3184                                         ;     01 (4) : ID defined during initialization (in RAM) - index 0 to 15
                   3185                                         ;     10 (8) : ID defined in EEPROM - need to be loaded in RAM during initialization
                   3186                                         ;     11 (C) : other / not used (default)
07A3   0CB3        3187            mov       A,LINindex         ;ID in [X,A] (without the parity bits)
07A4   0DB1        3188            mov       X,LINindex+1       ;shift the ID, the last two bits of A indicate the nibble of the ROM data
07A5   5040        3189            set       C                  ;set C to select the odd nibble
07A6   9647        3190            rlc       A 
07A7   9645        3191            rlc       X 
07A8   88F5        3192            or        X,#INDXtableX      ;set X msb with lower adress bit of indxtable
07A9   A7B6        3193            mov       B,Rom:TableRom[X,A] ;get the high nibble : xx xx
                   3194                                         ;                       \   \
                   3195                                         ;                        \   local index
                   3196                                         ;                        00 (0) : ID defined in ROM - index 10h to 3Fh
                   3197                                         ;                        01 (4) : ID defined during initialization (in RAM) - index 0 to 15
                   3198                                         ;                        10 (8) : ID defined in EEPROM - need to be loaded in RAM during initialization
                   3199                                         ;                        11 (C) : other / not used (default)
07AA   8CA6        3200            msk       B,#0Ch 
07AB U 0001        3201            jz        idinrom            ;check if the ID has been defined in ROM
     U             3202                                         ;the ID was not recognized anywhere
07AC   0DB2        3203            mov       B,LINindex+1 
07AD   88F6        3204            or        B,#8               ;1xxx : indicates that the ID is not defined
07AE   0D72        3205            mov       LINindex+1,B 
07AF   82B5        3206            mov       X,#2               ;restore the bit counter for parity bit 0
07B0   FF26        3207            jmp       wbit               ;go wait for parity bit 0
                   3208  
                   3209  idinrom                                ;the ID is defined in ROM : get the index
07B1   0D72        3210            mov       LINindex+1,B       ;B = 00xx
                   3211                                         ;        \
                   3212                                         ;         page (1, 2 or 3 - 0 being reserved for RAM indexes)
                   3213                                         ;B = 0000 if the ID was defined in RAM (see idinram)
07B2   81C7        3214            sub       A,#1               ;prepare to get the low nibble of the ROM table to get the complete index
07B3   A7B7        3215            mov       A,Rom:TableRom[X,A] ;low nibble
07B4   0C73        3216            mov       LINindex,A         ;store the index
                   3217  
                   3218  getframearg                            ;prepare the ROM table indexes (A and X) to get the arguments
07B5   0DB1        3219            mov       X,LINindex+1       ;high part of the index, the low part is in A -> X A = 00ii iiii
07B6   9247        3220            asl       A                  ;shift to the left
07B7   9645        3221            rlc       X 
                   3222                                         ;the index is ready, there is only one table with one byte for each index
07B8   EB3B        3223            dcom      11,PARAMtable      ;11 1111 01
                   3224                                         ;       \  \
                   3225                                         ;        \  Txtab[1:0] = 01 (ored with arom[7:6]) - same address as PARAMtable1
                   3226                                         ;         Txtab[5:2] = 1111 (replace arom[11:8])
                   3227                                         ;save A and X in ParamBuf and ParamBuf+1. These two registers are free and will be used at the next...
                   3228                                         ;... step (when retrieving the arguments)
07B9   6073        3229            mov       ParamBuf,A         ; X A = 0iii iii0
07BA   6171        3230            mov       ParamBuf+1,X 
07BB   82B5        3231            mov       X,#2 
07BC   FF26        3232            jmp       wbit 
                   3233  
                   3234  databytrcvd                            ;--------------- all bits have been received - and the stop bit was received --------
                   3235                                         ;if we were receiving the ID, change F0
                   3236                                         ;test if it is the ID byte (F1=0) or just a databyte (F1=1)
07BD U 0015        3237            jnf1      IDcorrect 
07BE U 0020        3238            jmp       nextbyt 
     U             3239  
     U             3240  IDcorrect                              ;The ID has been received correctly (with the stop bit)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 84  Win32 Assembler
                                LIN2B.ASM

     U             3241                                         ;in case the frame was correctly processed, save the current baudrate if it hasn't been done yet
07BF   5CB3        3242            mov       A,LINbrflag        ;x x x x
07C0   84A7        3243            msk       A,#4               ; \ \ \ \
                   3244                                         ;  \ \ \ edge to be processed
                   3245                                         ;   \ \ not used
                   3246                                         ;    \ baudrate detected
                   3247                                         ;     auto baudrate on every frame
07C1 U 0011        3248            jnz       IDbrsaved          ;if the baudrate has already been set, don't do it again
07C2   84F7        3249            or        A,#4               ;if not, indicates that the baudrate has been detected
07C3   5C73        3250            mov       LINbrflag,A 
07C4   0448        3251            dmaw      LINbrNom,#0        ;save the baudrate to the nominal Br
07C5   3EB7        3252            mov       A,io:1Eh           ;get the prescaler
07C6   0773        3253            mov       LINprescNom,A      ;save the prescaler
                   3254                                         ;check if the frame should be processed
07C7   6FB3        3255            mov       A,LINframeflag     ;x x x x
07C8   84A7        3256            msk       A,#4               ; \ \ \ \
                   3257                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3258                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3259                                         ;    \ discard the frame
                   3260                                         ;     frame data ready for transmit
07C9 U 0001        3261            jz        IDbrsaved 
     U             3262                                         ;discard the frame
07CA   A324        3263            jmp       act_init 
                   3264  
07CB   C25C        3265  IDbrsaved  or        F10,#2            ;prepare to get regular data bytes (F1=1)
                   3266                                         ;check if the ID was recognized
07CC   0DB1        3267            mov       X,LINindex+1       ;test if the ID has been recognized (LINindex contains a valid index)
07CD   88A5        3268            msk       X,#8               ;1xxx : indicates that the ID is not defined
07CE U 0001        3269            jz        arg_process        ;ID recognized, proceed with the arguments
     U             3270                                         ;send the unrecognized ID as a mark
07CF               3271            #IF       coDEBUGMARK eq cvON 
07CF   A87C        3272            xdcom     #dcID              ;mark instruction
07D0   087D        3273            xdma      LINbytbuf          ;send the ID
07D1               3274            #ENDIF    
07D1   A324        3275            jmp       act_init 
                   3276  
                   3277  arg_process                            ;process the argument
                   3278                                         ;ParamBuf+1
                   3279                                         ;Content: xxx x
                   3280                                         ;            \ \
                   3281                                         ;             \ not used
                   3282                                         ;              000 : receive
                   3283                                         ;              001 : transmit
                   3284                                         ;              010 : groupe (not implemented, discard)
                   3285                                         ;              011 : (error)
                   3286                                         ;              100 : ask the application
                   3287                                         ;              101 : discard
                   3288                                         ;              110 : hook (not implemented, discard)
                   3289                                         ;              111 : (error)
07D2   61B2        3290            mov       B,ParamBuf+1 
07D3   0046        3291            shift     B,0h               ;if needed, get the bit0 in C with the correct shift
07D4   81E6        3292            cmp       B,#1 
07D5 U 0001        3293            jz        arg_transmit       ;001 : transmit data
07D6 U 0000        3294            jc        arg_receive        ;000 : receive data
07D7   A324        3295            jmp       act_init           ;more than 1, it's an error, go back to active
                   3296  
07D8   83B7        3297  arg_receive  mov       A,#3            ;(0, 0, rx/tx, enabled) - 0 = TX, 1 = RX
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 85  Win32 Assembler
                                LIN2B.ASM

07D9 U 0020        3298            jmp       get_parambuf0 
     U             3299  
     U             3300  arg_transmit                           ;reset the data ready flag (F0)
07DA   005C        3301            mov       F10,#0 
                   3302                                         ;check if we are in continous or in programing mode
07DB   5FB3        3303            mov       A,LINflashStatus   ;x x x x
07DC   83A7        3304            msk       A,#3               ; \ \ \ \
                   3305                                         ;  \ \ \ programming mode
                   3306                                         ;   \ \ continuous frames coming up
                   3307                                         ;    \ not used
                   3308                                         ;     not used
                   3309            
07DD U 0011        3310            jnz       tx_send_ev         ;continous or programing is enabled, do not reset data_ready bit
     U             3311                                         ;reset data_ready and discard bits before asking for MSrqst in general case
07DE   6FB3        3312            mov       A,LINframeflag 
07DF   83BF        3313            and       A,#3 
07E0   6F73        3314            mov       LINframeflag,A 
                   3315  tx_send_ev                             ;check if there is already some data in the frame buffer, if not send an event
07E1   6FB3        3316            mov       A,LINframeflag     ;x x x x
07E2   88A7        3317            msk       A,#8               ; \ \ \ \
                   3318                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3319                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3320                                         ;    \ discard the frame
                   3321                                         ;     frame data ready for transmit
07E3 U 0011        3322            jnz       txsent             ;don't generate MESSrqst event
     U             3323                                         ;Ask immediately the application for data to allow a faster response
07E4   84B7        3324            mov       A,#evMESSrqst      ;send a request for data
07E5   BC62        3325            call      setev_mess 
07E6   81B7        3326  txsent    mov       A,#1               ;(0, 0, rx/tx, enabled) - 0 = TX, 1 = RX
                   3327  
                   3328  get_parambuf0                          ;ParamBuf
                   3329                                         ;Content: x xxx     for receive and transmit messages
                   3330                                         ;          \   \
                   3331                                         ;           \   length : 0 = 1 bytes... 7 = 8 bytes) <- for receive/transmit
                   3332                                         ;            checksum : O = chk13, 1 = chk20 <- for receive/transmit
07E7   60B2        3333            mov       B,ParamBuf 
                   3334                                         ;store the checksum type (be careful: LINparam contains only the...
                   3335                                         ;... valid checksum type, the other arguments are wrong!)
07E8   5B72        3336            mov       LINparam,B         ;x x x x
                   3337                                         ; \ \ \ \
                   3338                                         ;  \ \ \ Not Used
                   3339                                         ;   \ \ ID recognized in Index table
                   3340                                         ;    \ 0=TX, 1=RX
                   3341                                         ;     checksum : 0=regular (without ID field), 1=enhanced (with ID field)
07E9   87BE        3342            and       B,#7               ;get the length
07EA   8186        3343            add       B,#1               ;the length is coded from 0 to 7 but in reality it is from 1 to 8
07EB   4C72        3344            mov       LINmesslen,B       ;store the length
                   3345  
                   3346                                         ;get the message timeout
07EC   81C6        3347            sub       B,#1               ;prepare the index
07ED   9646        3348            rlc       B                  ;shift the length to use it as an index for the ROM table access
07EE   8186        3349            add       B,#1 
07EF   56B5        3350            mov       X,Rom:TO14tbl shr 2[B] ;get the high nibble
07F0   3771        3351            mov       LINtoref+1,X 
07F1   81C6        3352            sub       B,#1               ;increase the index to get the low nibble
07F2   56B5        3353            mov       X,Rom:TO14tbl shr 2[B] ;get the low nibble
07F3   3671        3354            mov       LINtoref,X 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 86  Win32 Assembler
                                LIN2B.ASM

                   3355  
                   3356                                         ;timeout value is ready
                   3357                                         ;test and set the direction flag                    <-------------------------------------
07F4   5BB2        3358            mov       B,LINparam         ;x x x x
                   3359                                         ; \ \ \ \
                   3360                                         ;  \ \ \ Not Used
                   3361                                         ;   \ \ ID recognized in Index table
                   3362                                         ;    \ 0=TX, 1=RX
                   3363                                         ;     checksum : 0=regular (without ID field), 1=enhanced (with ID field)
07F5   88BE        3364            and       B,#8               ;reset all the arguments but the checksum
07F6   8847        3365            rl        A                  ;(0, rx/tx, enabled, 0)
07F7   93F6        3366            or        B,A                ;(checksum, rx/tx, enabled, 0)
07F8   5B72        3367            mov       LINparam,B         ;update the argument register
                   3368  
                   3369                                         ;all the arguments are updated except the master response (not supported yet)       <---
                   3370  
                   3371                                         ;check the checksum type (regular/enhanced) (LINparam is in B)
07F9   9646        3372            rlc       B                  ;C=1 -> enhanced checksum
07FA U 0000        3373            jc        enhancdck          ;optional!
     U             3374  regularck                              ;regular checksum: reset the checksum register
07FB   3E4D        3375            dmar      #1,ClearByte       ;use the dma to clear the byte
07FC U 0020        3376            jmp       init_chksum 
     U             3377  
     U             3378  enhancdck                              ;enhanced checksum: update the checksum register EXCEPT if the ID is between 3C and 3F, which always has a regular checksum
07FD   084D        3379            dmar      #1,LINbytbuf       ;use the dma to copy LINbytbuf to LINchksum
07FE   0A49        3380  init_chksum  dmaw      LINchksum,#1 
07FF U 0020        3381            jmp       updtbytcnt 
     U             3382  
     U             3383  nextbyt                                ;a data byte has been received
     U             3384                                         ;get the next byte!
     U             3385                                         ;before that, get the buffer if this is the first byte and store the byte - it is currently in {LINbytbuf+1,LINbytbuf}
     U             3386                                         ;a message is being received, get the buffer
0800   39B2        3387            mov       B,LINbytcnt 
0801   8FA6        3388            msk       B,#0Fh             ;check if this is the first byte (does not affect B)
0802 U 0001        3389            jz        buffer_check 
0803 U 0020        3390            jmp       cmplenght 
     U             3391  buffer_check                           ;this is the first byte, check if the buffer is free
     U             3392                                         ;if the buffer is not free, the Mlx16 still reading it and the Mlx4 should not modify it
0804   5EB3        3393            mov       A,LINstatus        ; x x x x
0805   82A7        3394            msk       A,#2               ; \ \ \ \
                   3395                                         ;  \ \ \ LIN bus activity
                   3396                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   3397                                         ;    \ not used
                   3398                                         ;     event overflow occured
0806 U 0001        3399            jz        buffer_free 
     U             3400  buffer_full                            ;the buffer is not free, send an error
0807   89B6        3401            mov       B,#erRXOVR 
0808   B562        3402  buffer_error  call      errev 
                   3403                                         ;
                   3404                                         ;check if we should overwrite the buffer or cancel the reception
                   3405                                         ;
0809   A324        3406            jmp       act_init           ;cancel the reception
                   3407  
                   3408  buffer_free  
                   3409                                         ;if auto sleep command detection is enabled, check if the ID is 3C and if the first byte is 00
080A   6FB3        3410            mov       A,LINframeflag     ; x x x x
080B   81A7        3411            msk       A,#1               ; \ \ \ \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 87  Win32 Assembler
                                LIN2B.ASM

                   3412                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3413                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3414                                         ;    \ discard the frame
                   3415                                         ;     frame data ready for transmit
080C U 0001        3416            jz        cmplenght          ;this is not ID 3C
     U             3417                                         ;check the first byte
080D   08B1        3418            mov       X,LINbytbuf 
080E   80E5        3419            cmp       X,#0 
080F   09B1        3420            mov       X,LINbytbuf+1 
0810   80ED        3421            cmpcz     X,#0 
0811 U 0011        3422            jnz       cmplenght          ;the first byte is not 00
     U             3423                                         ;set the sleep command received flag
0812   82F7        3424            or        A,#2               ; x x x x
0813   6F73        3425            mov       LINframeflag,A     ; \ \ \ \
                   3426                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3427                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3428                                         ;    \ discard the frame
                   3429                                         ;     frame data ready for transmit
                   3430  
0814   4CE2        3431  cmplenght  cmp       B,LINmesslen      ;check if the message has been received completely
0815 U 0001        3432            jz        updtbytcnt         ;if yes, do not store the checksum
     U             3433                                         ;clear data ready flag as we are writing to the frame buffer
0816   6FB3        3434            mov       A,LINframeflag     ;x x x x
0817   87BF        3435            and       A,#7               ; \ \ \ \
                   3436                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3437                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3438                                         ;    \ discard the frame
                   3439                                         ;     frame data ready for transmit
0818   6F73        3440            mov       LINframeflag,A 
                   3441                                         ;copy the byte to the frame buffer
                   3442                                         ;byte number in B, data in LINbytbuf/LINbytbuf+1
0819   9246        3443            asl       B                  ;get only the high nibble
081A   08B3        3444            mov       A,LINbytbuf        ;low nibble
081B   E677        3445            mov       data:LINframe shr 4[B],A 
081C   8186        3446            add       B,#1               ;high nibble
081D   09B3        3447            mov       A,LINbytbuf+1 
081E   E677        3448            mov       data:LINframe shr 4[B],A 
                   3449  
                   3450  updtbytcnt                             ;update the byte counter
081F   39B1        3451            mov       X,LINbytcnt 
0820   8185        3452            add       X,#1 
0821   3971        3453            mov       LINbytcnt,X 
                   3454                                         ;was it the ID field?
0822 U 0011        3455            jnz       updtchksum         ;no
     U             3456                                         ;yes (then, depending on the checksum kind, the ID is already in memory)
     U             3457                                         ;initialize the bit counter for the time out (LIN 2.0 spec)
0823   3E4D        3458            dmar      #1,ClearByte       ;use the dma to clear the bytes
0824   3049        3459            dmaw      LINtocnt,#1        ;clear LINtocnt and LINtocnt+1
                   3460                                         ;check if this is a TX
0825   5BB3        3461            mov       A,LINparam         ;x x x x
0826   84A7        3462            msk       A,#4               ; \ \ \ \
                   3463                                         ;  \ \ \ Not Used
                   3464                                         ;   \ \ ID recognized in Index table
                   3465                                         ;    \ 0=TX, 1=RX
                   3466                                         ;     checksum : 0=regular (without ID field), 1=enhanced (with ID field)
0827 U 0011        3467            jnz       ntx 
0828 U 0020        3468            jmp       TXreq              ;proceed to transmit
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 88  Win32 Assembler
                                LIN2B.ASM

     U             3469  
     U             3470  updtchksum                             ;still receiving data bytes, update the checksum buffer
0829   08B2        3471            mov       B,LINbytbuf 
082A   09B3        3472            mov       A,LINbytbuf+1 
                   3473  
                   3474                                         ;the number of bytes received is already in X
082B   81C5        3475            sub       X,#1               ;subtract one for the checksum
082C   4CE1        3476            cmp       X,LINmesslen       ;compare to the message length
082D U 0001        3477            jz        checkck            ;if X=0, the byte juste received is the checksum
     U             3478  
082E   3362        3479            call      UpdateChkSum       ;if not, update the checksum
                   3480  
                   3481  ntx                                    ;send a mark and go wait for the start bit of the next byte
082F               3482            #IF       coDEBUGMARK eq cvON 
082F   CE7C        3483            xdcom     #dcDATA            ;mark instruction
0830   087D        3484            xdma      LINbytbuf          ;send the byte received
0831               3485            #ENDIF    
                   3486                                         ;enable the sleep timer in case the start bit never comes
0831   8262        3487            call      sleep_tmr 
                   3488                                         ;the start bit wait is already initialized (for faster processing) go directly to the wait
0832   CA26        3489            jmp       wstart 
                   3490  checkck                                ;the checksum has just been received, check it
0833   0A82        3491            add       B,LINchksum 
0834   0B8B        3492            addcz     A,LINchksum+1 
                   3493                                         ;the checksum should be FF, check that
0835   8186        3494            add       B,#1 
0836   808F        3495            addcz     A,#0 
0837 U 0001        3496            jz        message_ok         ;check if the checksum + 1 equals 0
     U             3497  message_bad                            ;send an error event
0838   84B6        3498            mov       B,#erCKSUM         ;checksum error
0839   B562        3499            call      errev              ;send the event
083A   A324        3500            jmp       act_init           ;wait for the next break
                   3501  
                   3502  message_ok                             ;check if this is a sleep command from the master
083B   6FB3        3503            mov       A,LINframeflag     ;x x x x
083C   82A7        3504            msk       A,#2               ; \ \ \ \
                   3505                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3506                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3507                                         ;    \ discard the frame
                   3508                                         ;     frame data ready for transmit
083D U 0001        3509            jz        message_send 
     U             3510                                         ;this is a go-to-sleep command from the master : free the buffer
083E   5EB3        3511            mov       A,LINstatus        ; x x x x
083F   8DBF        3512            and       A,#13              ; \ \ \ \
                   3513                                         ;  \ \ \ LIN bus activity
                   3514                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   3515                                         ;    \ not used
                   3516                                         ;     event overflow occured
0840   5E73        3517            mov       LINstatus,A 
0841   81B5        3518            mov       X,#slMST           ;signal that the sleep mode is entered with a go-to-sleep command from the master
0842 U 0020        3519            jmp       gotosleep          ;if this is a sleep command, go to the sleep state
     U             3520  message_send                           ;send a message to the application to say that a message has been received
     U             3521                                         ;set the buffer occupied flag
0843   5EB3        3522            mov       A,LINstatus 
0844   82F7        3523            or        A,#2 
0845   5E73        3524            mov       LINstatus,A 
                   3525                                         ;send the index or the ID (which index has to be sent for special IDs ???)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 89  Win32 Assembler
                                LIN2B.ASM

0846   83B7        3526            mov       A,#evMESSrcvd 
0847   BC62        3527            call      setev_mess 
                   3528  mess_sent                              ;go back to the wait state (wait for a new break)
0848   A324        3529            jmp       act_init 
                   3530  
                   3531  ;----- start of the TX area --------------------------------------------------------------------------
                   3532  ;Variables used Content / Local         Value when entering Value at the end
                   3533  ;-----------------------------------------------------------------------------------------------------
                   3534  ;A  none
                   3535  ;B  none
                   3536  ;X  none
                   3537  ;F0 bit sent (for read back)    none, reset after entering
                   3538  ;F1 data ready (if F1 = 1)  none, reset after entering
                   3539  ;   half bit flag : F1 = 0 for the first half of a bit, F1 = 1 for the second half
                   3540  ;LINtocnt   timeout counter     none, reset after entering
                   3541  ;LINmesslen message length      message length (1-8)
                   3542  ;LINtoref   timeout value (theorical)   none, initialized   response time available to the application - in half-bits!
                   3543  ;LINoptions1            x x xx
                   3544  ;              \  \
                   3545  ;               \  header stop bit length (for Slave to Master messages) : 0, 0.5, 1, 1.5 + 1 stop bits
                   3546  ;                stop bits between databytes during TX : 0 or 1 + 1 stop bit -> 1 or 2
                   3547  ;LINbrcpt   0-counter, for break    none        number of successive 0s received
                   3548  ;LINstopbit half stop bit counter / local   none
                   3549  ;LINbytcnt  byte counter (used also in RX)  none
                   3550  ;LINchksum  checksum        0 (regular CK) or ID (enhanced checksum)
                   3551  ;LINtxbytlen    byte length (with the stop bits)    none
                   3552  ;-----------------------------------------------------------------------------------------------------
                   3553  TXreq                                  ;a request to tranmit data bytes on the LIN bus has been received -------------------
                   3554                                         ;LIN param :
                   3555  
                   3556                                         ;initialize the bit and byte counters
0849   8FB5        3557            mov       X,#15              ;initialize the pointer to the data to be sent (LINbytcnt)
084A   3971        3558            mov       LINbytcnt,X        ;X will be incremented in GetByte, start with 15 (15+1=0)
084B   80B5        3559            mov       X,#0 
                   3560  
                   3561                                         ;reset the break counter for break in frame
084C   3E4D        3562            dmar      #1,ClearByte       ;use the dma to clear the bytes
084D   4049        3563            dmaw      LINbrcpt,#1        ;clear LINbrcpt and LINbrcpt+1
084E   4249        3564            dmaw      LINbrcpt+2,#1      ;clear LINbrcpt+2 and LINbrcpt+2
084F   4471        3565            mov       LINbrcpt+4,X       ;clear LINbrcpt+4
                   3566                                         ;check the current level on the bus
0850   38B7        3567            mov       A,io:18h           ;read status register 1 (and clear the flags): {Bin,SplBin,SyncErr,RunErr}
0851   88A7        3568            msk       A,#8               ;check if the bus is high
0852 U 0011        3569            jnz       TXncol 
     U             3570                                         ;the bus is already low -> collision! A break may have already started!
     U             3571  
     U             3572  TXcol                                  ;signal a collision
     U             3573                                         ; in LINmessbuf is stored the byte counter (if == 15, collision during TXreq. first byte is 0)
     U             3574                                         ; in X is stored the bit number:
     U             3575                                         ; 0 -> stop bit of the last byte
     U             3576                                         ; 1 -> start bit of the current byte
     U             3577                                         ; 2 -> first data bit
     U             3578                                         ;...
     U             3579                                         ; 9 -> data bit 7 
     U             3580                                         ; A -> first stop bit of the current byte (in case 2 stop bits have been requested by the application)
0853   39B2        3581            mov       B,LINbytcnt        ;get the byte
0854   3872        3582            mov       LINmessbuf,B       ;store the byte of the collision in LINmessbuf
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 90  Win32 Assembler
                                LIN2B.ASM

0855   85B6        3583            mov       B,#erTXCOL 
0856   B562        3584            call      errev              ;send the event
                   3585                                         ;signal that a TXCOL error occured before entering the end of break procedure
0857   3BB2        3586            mov       B,LINerrStat       ;x x x x
0858   84F6        3587            or        B,#4               ; \ \ \ \
                   3588                                         ;  \ \ \ data stop bit error detected
                   3589                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   3590                                         ;    \ collision error detected
                   3591                                         ;     ID stop bit error detected
0859   3B72        3592            mov       LINerrStat,B 
                   3593                                         ;reset the data ready flag and set the buffer free
085A   5EB2        3594            mov       B,LINstatus        ; x x x x
085B   8DBE        3595            and       B,#13              ; \ \ \ \
                   3596                                         ;  \ \ \ LIN bus activity
                   3597                                         ;   \ \ 0 : buffer free - 1 : buffer not free
                   3598                                         ;    \ not used
                   3599                                         ;     event overflow occured
085C   5E72        3600            mov       LINstatus,B 
085D   A124        3601            jmp       act_init_er        ;go wait for the end of the break
                   3602  
                   3603  TXncol                                 ;TX initialization
085E   0538        3604            dcom      8,05h              ;00 00 0101
                   3605                                         ;  \  \    \
                   3606                                         ;   \  \    Rst[1:0]=01: reset with BrMatch
                   3607                                         ;    \  nop
                   3608                                         ;     Init: nop
085F   0838        3609            dcom      8,08h              ;00 00 1000
                   3610                                         ;      Edg[2:0]=000: no  edge
0860   6B34        3611            dcom      4,6Bh              ;StatCtrl
                   3612                                         ;0 1 10 1011
                   3613                                         ;   \  \    \
                   3614                                         ;    \  \    load ToEn[2:0]=011 : LTimeOut driven Br Flag and IntFlag <- measure half bits for stop bit length
                   3615                                         ;     \  reset Ftfr
                   3616                                         ;      reset internal flags
0861   B034        3617            dcom      4,0B0h             ;InpCtrl
                   3618                                         ;1 0 11 0000
                   3619                                         ;   \  \    \
                   3620                                         ;    \  \    no change
                   3621                                         ;     \  RbErr=11: select SplRbErr in StatReg1
                   3622                                         ;      Rst: no change
                   3623                                         ;reset the timeout counter
0862   3049        3624            dmaw      LINtocnt,#1        ;clear LINtocnt and LINtocnt+1
                   3625  
                   3626                                         ;get the message maximum response time
0863   4CB3        3627            mov       A,LINmesslen       ;get the length [1-8]
0864   81C7        3628            sub       A,#1               ;prepare the index [0-7]
0865   9647        3629            rlc       A                  ;shift the length to use it as an index for the ROM table access
0866   5BB6        3630            mov       B,Rom:TO10tbl shr 2[A] ;get the low nibble
0867   3672        3631            mov       LINtoref,B 
0868   8187        3632            add       A,#1               ;increase the index to get the high nibble
0869   5BB6        3633            mov       B,Rom:TO10tbl shr 2[A] ;get the high nibble
086A   3772        3634            mov       LINtoref+1,B 
                   3635                                         ;timeout value is ready, now calculate the real length of the message
086B   64B3        3636            mov       A,LINoptions1      ;x x xx
                   3637                                         ; \ \  \
                   3638                                         ;  \ \  header stop bit length (for Slave to Master messages) : 0, 0.5, 1, 1.5 + 1 stop bits
                   3639                                         ;   \ stop bits between databytes during TX : 0 or 1 + 1 stop bit -> 1 or 2
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 91  Win32 Assembler
                                LIN2B.ASM

                   3640                                         ;    not used
086C   84BF        3641            and       A,#4               ;test the stop bits between databytes
086D U 0001        3642            jz        TXtocalcdone       ;one stop bit, the calculation is done
086E   81B5        3643            mov       X,#1               ;one additional stop bit
086F   8A85        3644  TXtocalcdone  add       X,#10          ; X value is before 0 or 1 depending on if we want 2 or 1 stop bit
0870   5D71        3645            mov       LINtxbytlen,X 
                   3646  
                   3647                                         ;stop bit counter
0871   64B1        3648            mov       X,LINoptions1      ;get the number of half stop bits
0872   83BD        3649            and       X,#3               ;(only the last two bits are significant)
0873   8285        3650            add       X,#2               ;a half stop bit has already been received, wait for the next one and then for the additional ones (bem 070807)
0874   4D71        3651            mov       LINstopbit,X       ;a half stop bit has already been received, wait for the next one and then for the additional ones
                   3652  
                   3653                                         ;check if the data is ready
0875   6FB3        3654            mov       A,LINframeflag     ;x x x x
0876   88A7        3655            msk       A,#8               ; \ \ \ \
                   3656                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3657                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3658                                         ;    \ discard the frame
                   3659                                         ;     frame data ready for transmit
0877   005C        3660            mov       F10,#0             ;reset data ready flag (f1)
0878 U 0001        3661            jz        TXstart 
0879   025C        3662            mov       F10,#2             ;signal that the data is ready: F1 = 1, F0 = 0
                   3663  
                   3664  TXstart                                ;TX initialization done ----------
                   3665                                         ;enable bit error detection and set its sampling point at the end of the bit
                   3666                                         ;set the configuration register
                   3667                                         ;wait for: - the response from the application indicating that the data is ready
                   3668                                         ;          - the end of the stop bit
                   3669                                         ;          - an edge, indicating someone is transmitting (then generate an error and go check if this is a break)
                   3670                                         ;if RunErr is set, the mlx4 failed to process the event in time
087A   0E58        3671            wait      Event,EvExt,TimeOut 
                   3672                                         ;check the source that ended the wait
087B U 0008        3673            jxev      TXw_ev             ;external event (edge?) : error!
087C U 0009        3674            jtime     TXw_to             ;timeout from the baudrate, can be BrFlag or IntFlag
     U             3675                                         ;command from the Mlx16 ----------
087D   E662        3676            call      cmdrcvd            ;command from the Mlx16 : process it
087E   6FB1        3677            mov       X,LINframeflag     ;x x x x
087F   88A5        3678            msk       X,#8               ; \ \ \ \
                   3679                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
                   3680                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3681                                         ;    \ discard the frame
                   3682                                         ;     frame data ready for transmit
0880 U 0011        3683            jnz       jmp_TXdatardy      ;data is ready to transmit
     U             3684                                         ;the data is not yet available for transmit, check if message should be discarded
0881   84A5        3685            msk       X,#4 
0882 U 0001        3686            jz        TXnotrdy           ;not a discard command, wait for the next command
0883   A324        3687            jmp       act_init           ;message should be discarded
0884 U 0020        3688  jmp_TXdatardy  jmp       TXdatardy     ;data is ready to transmit
     U             3689  
     U             3690  TXw_ev                                 ;external event : collision ------
     U             3691                                         ;check the source of the event (and reset the flags / acknowledge the event!)
0885   3A62        3692            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0886   88A6        3693            msk       B,#8               ;test Bin
0887 U 0001        3694            jz        TX_jmptxcol        ;the bus is low : somebody is driving it! Error!
     U             3695                                         ;signal a collision with byte=0 / bit=0 (default values)
     U             3696                                         ;the bus is high...
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 92  Win32 Assembler
                                LIN2B.ASM

0888   7A28        3697  TXnotrdy  jmp       TXstart            ;go back to the waiting state
                   3698  
                   3699  TXw_to                                 ;timeout -------------------------
                   3700                                         ;count the (half) stop bits (decrease the counter) and increment the timeout counter
                   3701  
                   3702                                         ;check the source of the timeout (and reset the flags / acknowledge the event!)
0889   3A62        3703            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   3704                                         ;check if these was some traffic on the bus (collision) and if the bus is recessive
088A   88A7        3705            msk       A,#8 
088B U 0011        3706            jnz       TX_jmptxcol 
     U             3707                                         ;check if the bus is recessive
088C   88BE        3708            and       B,#8 
088D U 0011        3709            jnz       TWw_tonocol 
     U             3710                                         ;collision !
088E   5328        3711  TX_jmptxcol  jmp       TXcol 
                   3712  TWw_tonocol                            ;check the source of the timeout
088F   81A7        3713            msk       A,#1               ;BrEv set if BrFlag set and ToEn[0] set or if IntFlag set and ToEn[1] set
                   3714                                         ;here ToEn = 011 -> BrEv set by BrFlag and IntFlag
0890 U 0011        3715            jnz       TXw_took 
0891   7A28        3716            jmp       TXstart            ;incorrect timeout, keep waiting
                   3717  TXdatardy                              ;data is ready
                   3718                                         ;check LINstopbit, if not zero, update the data ready flag (F0)
0892   4DB1        3719            mov       X,LINstopbit 
0893   80E5        3720            cmp       X,#0 
0894 U 0011        3721            jnz       TXrdyflag 
0895 U 0020        3722            jmp       TXcmd              ;X = 0, start the transmit
0896   C25C        3723  TXrdyflag  or        F10,#2            ;X not 0, update the TX flag (F1)
0897   7A28        3724            jmp       TXstart            ;wait for the next command
                   3725  
                   3726  TXw_took                               ;increment the bit counter for the time out and check that the timeout hasn't been reached
0898   4162        3727            call      CheckTimeOut 
0899 U 0000        3728            jc        TXnto_error 
     U             3729                                         ;timeout error
089A   1127        3730            jmp       toerr 
                   3731  
                   3732  TXnto_error                            ;the timeout hasn't been reached
089B   4DB1        3733            mov       X,LINstopbit       ;get the number of (half) stop bits
                   3734                                         ; test X to see if it is a half bit or a complete bit (X not modified)
089C   81A5        3735            msk       X,#1 
089D U 0011        3736            jnz       TXwbrcorrdone 
089E   4663        3737            call      BRcorrection 
                   3738  
089F   81C5        3739  TXwbrcorrdone  sub       X,#1          ;decrease the stop bit counter
08A0   808D        3740            addcz     X,#0               ;if X was already 0, do not overflow
08A1   4D71        3741            mov       LINstopbit,X       ;update the counter
08A2   80E5        3742            cmp       X,#0 
08A3 U 0011        3743            jnz       TX_jmpstart        ;minimum stop bit length not met, keep waiting
08A4 U 0005        3744            jf1       TXcmd              ;minimum stop bit duration met, check if the data is ready (F1 = 1)
08A5   7A28        3745  TX_jmpstart  jmp       TXstart         ;data is not ready (F1 = 0) or X > 0, keep waiting
                   3746  
                   3747  TXcmd                                  ;data ready and stop bit minimum length reached --------------------
                   3748                                         ;the data is in LINframe...
                   3749                                         ;restore full bit timeouts, collisions are checked automatically with RbErr, as set in InpCtrl
                   3750                                         ;clear data ready flag
08A6   6FB3        3751            mov       A,LINframeflag     ;x x x x
08A7   87BF        3752            and       A,#7               ; \ \ \ \
                   3753                                         ;  \ \ \ special ID received (3C, 3D, 3E or 3F)
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 93  Win32 Assembler
                                LIN2B.ASM

                   3754                                         ;   \ \ sleep command received (ID 3C + first byte 00)
                   3755                                         ;    \ discard the frame
                   3756                                         ;     frame data ready for transmit
08A8   6F73        3757            mov       LINframeflag,A 
                   3758  
08A9   9037        3759            dcom      7,90h              ;1 0 01 0000
                   3760                                         ;   \  \    \
                   3761                                         ;    \  \    BrCk/OutCk pulse : nop
                   3762                                         ;     \  counter : stop
                   3763                                         ;      capture : nop
                   3764                                         ;set the MSBi so the propagation time is measured
08AA   6834        3765            dcom      4,68h              ;StatCtrl
                   3766                                         ;0 1 10 1000
                   3767                                         ;   \  \    \
                   3768                                         ;    \  \    load ToEn[2:0]=000 : LTimeOut not driven
                   3769                                         ;     \  reset Ftfr
                   3770                                         ;      reset internal flags
                   3771                                         ;prepare IntBr
08AB   02B3        3772            mov       A,LINbr            ;get the baudrate
08AC   03B2        3773            mov       B,LINbr+1 
08AD   1046        3774            shift     B,10h              ;divide the baudrate by 2
08AE   1647        3775            rrc       A 
08AF   4E73        3776            mov       LINtmp,A 
08B0   4F72        3777            mov       LINtmp+1,B 
08B1   4F4C        3778            dmar      #0,LINtmp+1        ;write it to IntBr
                   3779                                         ;send the start bit immediately and measure the propagation time (if coPROPMEAS if enabled)
08B2   1762        3780            call      GetByte 
08B3   3362        3781            call      UpdateChkSum       ;C is 0
08B4   82B5        3782            mov       X,#2 
08B5   7071        3783            mov       Atmp,X 
08B6   80B5        3784            mov       X,#0 
                   3785                                         ;set the MSBi so the propagation time is measured
08B7   4F48        3786            dmaw      LINtmp+1,#0        ;read IntBr to reset capt_flag
08B8   0A38        3787            dcom      8,0Ah              ;00 00 1010
                   3788                                         ;          Edg[2:0]=010: slow falling edge
08B9   2034        3789            dcom      4,20h              ;0 0 10 0000
                   3790                                         ;   \  \    \
                   3791                                         ;    \  \    nop
                   3792                                         ;     \  reset Ftfr : slow edges set the traffic bit
                   3793                                         ;      nop
08BA   6539        3794            dcom      9,65h              ;01 10 0101
                   3795                                         ;  \  \    \
                   3796                                         ;   \  \    BrPls[1:0] = 01
                   3797                                         ;    \  RptCap = 0
                   3798                                         ;     set Capt on next BrCk
08BB   0135        3799            dcom      5,01h              ;000 00 001
                   3800                                         ;   \  \   \
                   3801                                         ;    \  \   X set, Y loaded with CoutCpu
                   3802                                         ;     \  Z, Cpz and NxZ unchanged
                   3803                                         ;      M and N unchanged
08BC   A437        3804            dcom      7,0A4h             ;1 0 10 0100
                   3805                                         ;   \  \    \
                   3806                                         ;    \  \    BrCk/OutCk pulse : generate a BrCK pulse
                   3807                                         ;     \  counter : reset and start
                   3808                                         ;      capture : nop
                   3809                                         ;set the MSBi so the propagation time is measured
                   3810                                         ;enable the timeout after the BrCk pulse
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 94  Win32 Assembler
                                LIN2B.ASM

08BD   6B34        3811            dcom      4,6Bh              ;StatCtrl
                   3812                                         ;0 1 10 1011
                   3813                                         ;   \  \    \
                   3814                                         ;    \  \    load ToEn[2:0]=011 : LTimeOut driven Br Flag - or IntBr
                   3815                                         ;     \  reset Ftfr
                   3816                                         ;      reset internal flags
08BE   0658        3817            wait      EvExt,TimeOut      ;wait for the falling edge - or for a timeout
08BF U 0009        3818            jtime     TXer_delay 
08C0   3A62        3819            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
08C1   4F48        3820            dmaw      LINtmp+1,#0        ;read the captured counter value (propagation delay)
08C2   02B3        3821            mov       A,LINbr            ;get the baudrate
08C3   03B2        3822            mov       B,LINbr+1 
08C4   1046        3823            shift     B,10h              ;divide the baudrate by 2
08C5   1647        3824            rrc       A 
08C6   4E83        3825            add       A,LINtmp           ;add the propagation delay
08C7   4F8A        3826            addcz     B,LINtmp+1 
08C8   4E73        3827            mov       LINtmp,A 
08C9   4F72        3828            mov       LINtmp+1,B 
08CA   4F4C        3829            dmar      #0,LINtmp+1        ;write it to IntBr
                   3830  
                   3831                                         ;disable the timeout after the IntBrCk pulse
08CB   0934        3832            dcom      4,09h              ;StatCtrl
                   3833                                         ;0 0 00 1001
                   3834                                         ;           \
                   3835                                         ;            load ToEn[2:0]=001 : LTimeOut driven Br Flag - or IntBr
                   3836                                         ;disable the edge detector
08CC   0838        3837            dcom      8,08h              ;00 00 1000
                   3838                                         ;          Edg[2:0]=000: no edge detection
08CD U 0020        3839            jmp       TXchkbus 
     U             3840  
     U             3841  TXer_delay                             ;delay error: the propagation delay is too long
08CE   3A62        3842            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
08CF   88A6        3843            msk       B,#8               ;check if the bus is recessive
08D0 U 0011        3844            jnz       TXer_delay_ok      ;the bus is recessive, it's actualy a delay error
08D1 U 0020        3845            jmp       TXcoldtctd         ;the bus is dominant, it's probably a collision error
     U             3846  TXer_delay_ok  
08D2   1B35        3847            dcom      5,1Bh              ; X set, Y set, Z, Cpz and NxZ set, M and N unchanged
08D3   82B5        3848            mov       X,#erCRASHTX 
08D4   82B6        3849            mov       B,#erCRASH 
08D5   B562        3850            call      errev              ;send an error to the application
08D6   81B6        3851            mov       B,#stDISC 
08D7   0172        3852            mov       LINst,B            ;update the state
08D8   8724        3853            jmp       dscnct_sc          ;go in the disconnected state without sending and event
                   3854  
08D9   1762        3855  TXnextbyte  call      GetByte          ;get the data byte (LINbytcnt is incremented (by 1)
08DA   80B5        3856            mov       X,#0               ;reset the bit counter
08DB U 0000        3857            jc        jmp_TXend          ;if C is set, the transmit is finished
08DC U 0011        3858            jnz       TXdata             ;if Z is set, the checksum should be sent
     U             3859                                         ;the checksum is in A and B, invert all the bits
08DD   8FD6        3860            xor       B,#15 
08DE   8FD7        3861            xor       A,#15 
08DF               3862            #IF       coDEBUGMARK eq cvON 
08DF   3472        3863            mov       LINdbg,B           ;save the checksum for xdma
08E0   3573        3864            mov       LINdbg+1,A 
08E1               3865            #ENDIF    
08E1   2862        3866            call      GB_SaveData        ;save the checksum in LINbytbuf
08E2 U 0020        3867            jmp       TXstartbit 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 95  Win32 Assembler
                                LIN2B.ASM

08E3 U 0020        3868  jmp_TXend  jmp       TXend 
     U             3869  TXdata                                 ;regular data byte: update the checksum
08E4   3362        3870            call      UpdateChkSum 
08E5   4040        3871  TXstartbit  clr       C                ;start bit
08E6   0135        3872  TXsendbit  dcom      5,01h             ;000 00 001
                   3873                                         ;   \  \   \
                   3874                                         ;    \  \   X set, Y loaded with CoutCpu
                   3875                                         ;     \  Z, Cpz and NxZ unchanged
                   3876                                         ;      M and N unchanged
08E7   0A58        3877  TXwaitbit  wait      TimeOut, Event    ;wait before sending the next bit
08E8 U 0009        3878            jtime     TXchkbus 
08E9   E662        3879            call      cmdrcvd            ;command from the MLX16
08EA   E728        3880            jmp       TXwaitbit 
                   3881  
                   3882                                         ;timeout : begining of a bit time, prepare the next bit
08EB   3A62        3883  TXchkbus  call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   3884            
                   3885                                         ;check if a collision occured
08EC   84A6        3886            msk       B,#4               ;SplBin is actually RbErr
08ED U 0011        3887            jnz       TXcoldtctd 
     U             3888            
     U             3889                                         ;update the 0 counter, verify if the bit just sent was recessive or dominant
08EE   70B3        3890            mov       A,Atmp             ;Atmp contains bit sent shifted to the left
08EF   1047        3891            shift     A,010h             ;shift the register two times
08F0   1047        3892            shift     A,010h 
08F1   4A62        3893            call      UpdateZeroCpt      ;Carry contains the bit sent, update the zero counter
                   3894  
08F2   4663        3895            call      BRcorrection       ;X is not modified
                   3896  
08F3   8185        3897            add       X,#1               ;no collision detected, increment the bit counter
08F4   5DE1        3898            cmp       X,LINtxbytlen      ;check if the current byte has been completely sent
08F5 U 0001        3899            jz        TXstopbit 
     U             3900                                         ;if not, shift the next bit out, and fill the buffer with 1s (C is set because of the cmp instruction above)
08F6   2E62        3901            call      shift_bytbuf       ;shift LINbytbuf+1 and LINbytbuf, the bit to send is in C
08F7   70B3        3902            mov       A,Atmp 
08F8   8447        3903            shift     A,084h             ;save the bit to sent into Atmp use later for zero counting
08F9   7073        3904            mov       Atmp,A 
08FA   E628        3905            jmp       TXsendbit 
                   3906  
                   3907  TXcoldtctd                             ;collision!
                   3908                                         ;set all the outputs flip-flops
08FB   4040        3909            clr       C                  ;a collision has been detected necessary because a dominant state has been detected
08FC   4A62        3910            call      UpdateZeroCpt      ;count dominant state one more time
08FD   1B35        3911            dcom      5,1Bh              ;000 11 011
                   3912                                         ;   \  \   \
                   3913                                         ;    \  \   X set, Y set
                   3914                                         ;     \  Z, Cpz and NxZ set
                   3915                                         ;      M and N unchanged
08FE   5328        3916            jmp       TXcol              ;signal the collision
                   3917  
                   3918  TXstopbit  
08FF   70B3        3919            mov       A,Atmp             ;we are sending the start bit (dominant), fill Atmp with it
0900   4040        3920            clr       C 
0901   8447        3921            shift     A,084h 
0902   7073        3922            mov       Atmp,A 
                   3923                                         ;the stop bit is being sent, get the next byte
0903               3924            #IF       coDEBUGMARK eq cvON 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 96  Win32 Assembler
                                LIN2B.ASM

0903   CF7C        3925            xdcom     #dcDATATX          ;mark instruction
0904   347D        3926            xdma      LINdbg             ;send the byte sent
0905               3927            #ENDIF    
0905   D928        3928            jmp       TXnextbyte 
                   3929  
                   3930  TXend                                  ;set all the outputs flip-flops to recessive (1)
0906   1B35        3931            dcom      5,1Bh              ;000 11 011
                   3932                                         ;   \  \   \
                   3933                                         ;    \  \   X set, Y set
                   3934                                         ;     \  Z, Cpz and NxZ set
                   3935                                         ;      M and N unchanged
                   3936  TXendwait                              ;wait one more time to check the stop bit
0907   0A58        3937            wait      TimeOut, Event 
0908 U 0009        3938            jtime     TXendcheck 
0909   E662        3939            call      cmdrcvd            ;command from the MLX16
090A   0729        3940            jmp       TXendwait 
                   3941  
                   3942  TXendcheck                             ;check the the bus (and reset the flags / acknowledge the event!)
090B   3A62        3943            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   3944                                         ;check if a collision occured
090C   84A6        3945            msk       B,#4               ;SplBin is actually RbErr
090D U 0001        3946            jz        TXend_ok           ;no collision
090E   FB28        3947            jmp       TXcoldtctd         ;collision error
                   3948  
                   3949  TXend_ok                               ;TX done
                   3950                                         ;data ready flag has been reset at the beginning of transmission. no need to reset it here
                   3951  
                   3952                                         ;check if the end of the transmition needs to be signaled or if continous frame are coming
090F   5FB1        3953            mov       X,LINflashStatus   ;x x x x
0910   83A5        3954            msk       X,#3               ; \ \ \ \
                   3955                                         ;  \ \ \ programming mode
                   3956                                         ;   \ \ continuous frames coming up
                   3957                                         ;    \ not used
                   3958                                         ;     not used
0911 U 0011        3959            jnz       SendEndEvent       ;continuous frames enabled
0912   00B1        3960            mov       X,LINevendTX       ;x x x x
                   3961                                         ; \ \ \ \
                   3962                                         ;  \ \ \ End TX event must to be sent
                   3963                                         ;   \ \ unused
                   3964                                         ;    \ unused
                   3965                                         ;     unused
0913   81A5        3966            msk       X,#1               ;is EndEvent enabled?
0914 U 0001        3967            jz        FrameEnd           ;no
     U             3968  SendEndEvent                           ;send EndEvent to the mlx16
0915   85B7        3969            mov       A,#evENDtx 
0916   BC62        3970            call      setev_mess 
0917   A324        3971  FrameEnd  jmp       act_init           ;go wait for a new frame
                   3972  
                   3973  ;-------------- SHORT -------------------------------------------------------------------------------------------------
                   3974  ; If a dominant level is present on the LIN bus for a time too long to be a break, then it is considered to be a short.
                   3975  ; An error is generated.
                   3976  ; The state machine goes automatically to the ACTIVE state
                   3977  BusShort                               ;Baudrate bloc Re-Initialization : wait for a rising edge, no timeout from the MSBi cell
0918   0738        3978            dcom      8,07h              ;00 00 0111
                   3979                                         ;  \  \    \
                   3980                                         ;   \  \    Rst[1:0]=11 : Re-Synch mode : reset upon selected edge (see next instruction)
                   3981                                         ;    \  nop
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 97  Win32 Assembler
                                LIN2B.ASM

                   3982                                         ;     Init: nop
0919   0938        3983            dcom      8,09h              ;00 00 1001
                   3984                                         ;      Edg[2:0]=001: Slow Rising Edge
091A   6834        3985            dcom      4,68h              ;StatCtrl
                   3986                                         ;0 1 10 1000
                   3987                                         ;   \  \    \
                   3988                                         ;    \  \    load ToEn[2:0]=000 : LTimeOut not driven
                   3989                                         ;     \  reset Ftfr : slow edge set the traffic bit
                   3990                                         ;      reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
                   3991                                         ;enable the sleep timer
091B   8262        3992            call      sleep_tmr 
                   3993  
                   3994                                         ;make sure the bus is still dominant
091C   38B6        3995            mov       B,io:18h           ;read status register 1 (and clear the flags): {Bin,SplBin,SyncErr,RunErr}
091D   88A6        3996            msk       B,#8 
091E U 0001        3997            jz        short_enter        ;this was a false alert, don't signal it to the application
091F   9424        3998            jmp       act_init_er_no_sig ;do not signal the state change if the bus short state was not entered
                   3999  short_enter                            ;enter the stSHORT state
0920   01B1        4000            mov       X,LINst            ;retrieve the current state (it will be passed as an argument of the error erSHORT)
0921   8EB6        4001            mov       B,#stSHORT 
0922   0172        4002            mov       LINst,B            ;update the current state
                   4003                                         ;don't signal the state change because this is done with the error erSHORT
                   4004                                         ;signal an error to the Mlx16
0923   8AB6        4005            mov       B,#erSHORT 
0924   B562        4006            call      errev 
                   4007                                         ;stop the counter to save power
0925   9037        4008            dcom      7,90h              ;1 0 01 0000
                   4009                                         ;   \  \    \
                   4010                                         ;    \  \    BrCk/OutCk pulse : nop
                   4011                                         ;     \  counter : stop
                   4012                                         ;      capture : nop
                   4013  
                   4014                                         ;wait here for - a rising edge (goto ACTIVE)
                   4015                                         ;              - a sleep timeout (goto SLEEP with reason slTODOM)       <<<<<<<<<<<<<<<<< or slTO
                   4016                                         ;              - a command from the Mlx16
0926   0E58        4017  short_wait  wait      Event,TimeOut,EvExt ;wait for a next event
0927 U 0008        4018            jxev      short_done         ;external event coming from the MSBi (edge)
0928 U 0009        4019            jtime     short_to           ;timeout from the sleep timer
0929   E662        4020            call      cmdrcvd            ;command from the MLX16
092A   2629        4021            jmp       short_wait 
                   4022  
                   4023  short_done                             ;go to the ACTIVE state
092B   3A62        4024            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
092C   88A6        4025            msk       B,#8 
092D U 0001        4026            jz        jmp_short_wait     ;if the bus is still low, keep waiting
     U             4027                                         ;otherwise exit the short state and go into active state
     U             4028                                         ;if slave was in sleep mode and issued a Short error (too long wakeup pulse), it should go back to active anyway because:
     U             4029                                         ; - Standard not asking to the node to chek too long wakup pulse to exit sleep mode
     U             4030                                         ; - slave already transmit a chst active to Mlx16 and then should go to it
092E   8C24        4031            jmp       active 
                   4032  
                   4033  short_to                               ;check if this is a timeout due to the sleep timer
092F   6F62        4034            call      CheckSleepTmr      ;check the status of the sleep timer
0930 U 0010        4035            jnc       jmp_short_wait     ;if C is not set, the counter did not overflow, keep waiting
     U             4036                                         ;timeout counter overflows, goto sleep
0931   87B7        4037            mov       A,#slTODOM         ;signal that the sleep mode is entered after a sleep timer timeout
0932   84B6        4038            mov       B,#stSLEEP         ;set the new state: sleep
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 98  Win32 Assembler
                                LIN2B.ASM

0933   CA62        4039            call      chst               ;signal that the state changed
0934   8E62        4040            call      sleep_tmr_dis      ;disable the sleep timer
0935   80B7        4041            mov       A,#0               ;we entered in sleep with a dominant state
0936   7073        4042            mov       Atmp,A 
0937 U 0020        4043            jmp       sleep_entered      ;jump to sleep mode
0938   2629        4044  jmp_short_wait  jmp       short_wait   ;go back to event waiting
                   4045  
                   4046  ;-------------- wbr_init -----------------------------------------------------------------------------------
                   4047  wbr_init_start                         ;* Initialization of the MSBi cell for Break reception
                   4048                                         ;A and B are used, X is used
                   4049                                         ;use LINtmp for baud-rate calculation but do not need to keep it
                   4050                                         ;use LINbr/LINbr+1 (read only)
                   4051                                         ;MSBi cell : initialize Br and IntBr - the prescaler is already initialized in the initialization part
                   4052                                         ;            CkCtrl : reset Capt (do not allow a capture now)
                   4053                                         ;            BrCtrl : reset and start the counter upon reception of a slow falling edge
                   4054                                         ;            StatCtrl : disable edge/timeout detection... no event should come from the MSBi cell
                   4055                                         ;                       reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
                   4056                                         ;* Registers : reset the timeout counter LINtocnt
                   4057                                         ;  Initialize the LINparam registers : LINparam = 0xC : enhanced checksum, RX frame, ID not recognized, n/a
                   4058                                         ;Reconfigure MSBii Counter
0939   005C        4059            mov       F10,#0             ;clear F1 and F0
093A   80B5        4060            mov       X,#0               ;initialize X
                   4061  
                   4062                                         ;Reset the auto baudrate counters
093B   3E4D        4063            dmar      #1,ClearByte       ;use the dma to clear the bytes
093C   5449        4064            dmaw      LINbrhicpt,#1      ;clear LINbrhicpt and LINbrhicpt+1
093D   5649        4065            dmaw      LINbrhicpt+2,#1    ;clear LINbrhicpt+2 and LINbrhicpt+3
                   4066  
                   4067                                         ;check if LINbrcpt should be cleared
093E   3BB3        4068            mov       A,LINerrStat       ;x x x x
093F   8DA7        4069            msk       A,#13              ; \ \ \ \
                   4070                                         ;  \ \ \ data stop bit error detected
                   4071                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   4072                                         ;    \ collision error detected
                   4073                                         ;     ID stop bit error detected
0940 U 0011        4074            jnz       brcpt_nclr 
0941   4049        4075            dmaw      LINbrcpt,#1        ;clear LINbrcpt and LINbrcpt+1
0942   4249        4076            dmaw      LINbrcpt+2,#1      ;clear LINbrcpt+2 and LINbrcpt+3
0943   4471        4077            mov       LINbrcpt+4,X       ;clear Linbrcpt+4
0944   8EB7        4078  brcpt_nclr  mov       A,#14 
0945   63B7        4079            mov       A,Rom:ConstantTbl2 shr 2[A] ; A = MinPresc
0946   3E77        4080            mov       io:1Eh,A           ;init the prescaler
0947   80B7        4081            mov       A,#0 
0948   5A73        4082            mov       LINbrtmp+2,A 
0949   6A73        4083            mov       LINbrLSBs,A 
094A   6B73        4084            mov       LINbrcorr,A 
                   4085  
                   4086                                         ;Baud-rate initialization
094B   03B3        4087            mov       A,LINbr+1          ;divide LINbr by 2 and store it in LINtmp for dma access
094C   1047        4088            shift     A,10h 
094D   4F73        4089            mov       LINtmp+1,A 
094E   02B3        4090            mov       A,LINbr 
094F   1647        4091            rrc       A 
0950   4E73        4092            mov       LINtmp,A 
0951   4E4C        4093            dmar      #0,LINtmp          ;generate pulses to count the break length every half bit time
                   4094  
                   4095                                         ;the baudrate is initialized, initialize the MSBi cell -----------------------------------------------
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 99  Win32 Assembler
                                LIN2B.ASM

0952   EF34        4096            dcom      4,0EFh             ;1 1 10 1 1 1 1
                   4097                                         ;   \ \    \ \ \
                   4098                                         ;    \ \    \ \ EnFdb=1: enable fast debounce (BusIn is debounced on a 2/3 majority vote scheme)
                   4099                                         ;     \ \    \ Fbin=1: flag set (Bin = high debounced BusIn))
                   4100                                         ;      \ \    AutoDb=1: flag set (DbCk devided by the 4 msb's of the Br register)
                   4101                                         ;       \ RbErr=10: flag reset (IntSplBin selected)
                   4102                                         ;        Rst=1
0953   8539        4103            dcom      9,85h              ;10 00 0101
                   4104                                         ;  \  \    \
                   4105                                         ;   \  \    BrPls : nop (IntMatch -> InBrCk, BrMatch -> BrCk)
                   4106                                         ;    \  RptCap : nop
                   4107                                         ;     Capt : reset (do not allow a capture now)
                   4108                                         ;stop the counter to save power
0954   9037        4109            dcom      7,90h              ;1 0 01 0000
                   4110                                         ;   \  \    \
                   4111                                         ;    \  \    BrCk/OutCk pulse : nop
                   4112                                         ;     \  counter : stop
                   4113                                         ;      capture : nop
                   4114  
                   4115                                         ;Set IntBr value to half Br - use LINtmp (calculated above)
0955   4F4C        4116            dmar      #0,LINtmp+1        ;IntBr = Br / 2
                   4117                                         ;LINtmp is not used anymore in this routine after that
                   4118                                         ;read IntBr to reset capt_flag
0956   4F48        4119            dmaw      LINtmp+1,#0 
                   4120  
                   4121                                         ;baud-rate bloc : reset and start the counter upon reception of a slow falling edge
0957   0638        4122            dcom      8,06h              ;00 00 0110
                   4123                                         ;      Rst[1:0]=10: reset upon Edg[2:0] (slow falling edge)
0958   0A38        4124            dcom      8,0Ah              ;00 00 1010
                   4125                                         ;      Edg[2:0]=010: Slow Falling Edge
                   4126  
                   4127                                         ;StatCtrl : disable edge/timeout detection... no event should come from the MSBi cell
0959   2834        4128            dcom      4,28h              ;0 0 10 1000
                   4129                                         ;   \  \    \
                   4130                                         ;    \  \    load ToEn[2:0]=000 : LTimeOut not driven
                   4131                                         ;     \  set Ftfr : slow edges set the traffic bit
                   4132                                         ;      don't reset internal flags
                   4133  
                   4134                                         ;the MSBi cell is initialized
                   4135                                         ;initialize the registers used for auto-addressing - even if auto addressing mode is not set yet
                   4136                                         ;ROM table AUTOADDtable, configure Txtab[5:2] (in MemTab 2), AUTOADDtable value is set in lincst.asm
095A   EB3B        4137            dcom      11,AUTOADDtable    ;11 1111 00
                   4138                                         ;           \  \
                   4139                                         ;            \  Txtab[1:0] = 00 (ored with arom[7:6])
                   4140                                         ;             Txtab[5:2] = 1111 (replace arom[11:8])
095B   80B7        4141            mov       A,#0 
095C   6D73        4142            mov       AutoAddEv,A        ;index of the ROM table
095D   88B5        4143            mov       X,#AUTOADDtableX 
095E   A7B6        4144            mov       B,Rom:TableRom[X,A] ;get the first value for the counter
095F   6E72        4145            mov       AutoAddCpt,B 
                   4146  
                   4147                                         ;Check if byte counter can be cleared
0960   3BB2        4148            mov       B,LINerrStat       ;x x x x
0961   8DA6        4149            msk       B,#13              ; \ \ \ \
                   4150                                         ;  \ \ \ data stop bit error detected
                   4151                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   4152                                         ;    \ collision error detected
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 100  Win32 Assembler
                                LIN2B.ASM

                   4153                                         ;     ID stop bit error detected
0962 U 0011        4154            jnz       wbr_msbi_init_end 
     U             4155  
     U             4156                                         ;reset the timeout register
0963   3049        4157            dmaw      LINtocnt,#1        ;use the dma to clear the byte
                   4158  
                   4159                                         ;initialize the LINparam registers
                   4160                                         ;enhanced checksum, RX frame, ID not recognized, n/a
0964   8CB7        4161            mov       A,#0Ch 
0965   5B73        4162            mov       LINparam,A         ;x x x x
                   4163                                         ; \ \ \ \
                   4164                                         ;  \ \ \ Not Used
                   4165                                         ;   \ \ ID recognized in Index table
                   4166                                         ;    \ 0=TX, 1=RX
                   4167                                         ;     checksum : 0=regular (without ID field), 1=enhanced (with ID field)
                   4168  wbr_msbi_init_end  
0966   8222        4169            jmp       sleep_tmr 
                   4170  
                   4171  ;-------------- WAKE state (stWKUP) -----------------------------------------------------------------------------------
                   4172  ; command(s) :
                   4173  ; power-down : not allowed
                   4174  ; next state(s) : DISCONNECTED (command), ACTIVE (bus), SLEEP (timer)
                   4175  ; action(s) :    In this state the task will attempt to wake up the bus by issuing a wake-up pulse and susequently monitor the bus for
                   4176  ;                activity. The Wake-Up request is issuing by forcing the bus to the dominant state for 250us to 5ms.
                   4177  ;   At  1kbps, Tbit =  1ms, 5 * Tbit =   5ms
                   4178  ;   At 20kbps, Tbit = 50us, 5 * Tbit = 250us -> a wake-up pulse will always be 5 bits long, regardless of the baudrate.
                   4179  ;   If no frame header is issued within 150ms from the wake up request (ending edge), 2 more requests can be sent. Then
                   4180  ;   a fourth one after 1.5 seconds.
                   4181  ;   UPDATED 070115 : 1.5 seconds after the 3rd pulse, an event is sent to the application. The decision to send another
                   4182  ;                set of pulses is left to the application.
                   4183  ; register(s) : A follow the wake-up cycle
                   4184  ;   ___     _______________________     _______________________     ________ //  _________
                   4185  ;      |___|         150ms         |___|          150ms        |___|       1.5s           |
                   4186  ;   A =  0            1              2             3             4          5             6 : send a slWKUPabort
                   4187  wakeup_sc                              ;entering point after state change command (don't do the call to chst)
                   4188                                         ;disable ANA wkup if we come from deep sleep state               
0967   2B62        4189            call      dis_ana_wkup 
                   4190                                         ;initialize the MSBi cell for break detection
0968   8162        4191            call      wbr_init 
                   4192                                         ;Slow Clock Disabled (ask for fast clock)
0969   883F        4193            dcom      15,88h             ;1xxx 10xx
                   4194                                         ;       \
                   4195                                         ;        SlowCk = 0 (FstCkRq = 1 : request PLL)
                   4196                                         ;A will now be used to follow the wake-up cycle (see schematic above)
096A   80B6        4197            mov       B,#0 
096B   7172        4198            mov       Btmp,B 
                   4199  wakeup_pulse                           ;MSBi cell initialization
096C               4200            #IF       coDEBUGMARK eq cvON 
096C   547C        4201            xdcom     #dcWAKEUP          ;mark instruction
096D               4202            #ENDIF    
                   4203                                         ;generate pulses to count the pulse length every Tbit
096D   07B3        4204            mov       A,LINprescNom      ; OZH 20130129
096E   3E77        4205            mov       io:1Eh,A 
096F   044C        4206            dmar      #0,LINbrNom 
                   4207                                         ;Baudrate bloc
0970   0538        4208            dcom      8,05h              ;00 00 0101
                   4209                                         ;  \  \    \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 101  Win32 Assembler
                                LIN2B.ASM

                   4210                                         ;   \  \    Rst[1:0]=01: reset with BrMatch
                   4211                                         ;    \  nop
                   4212                                         ;     Init: nop
0971   0838        4213            dcom      8,08h              ;00 00 1000
                   4214                                         ;      Edg[2:0]=000: no edge
                   4215                                         ;StatCtrl
0972   4934        4216            dcom      4,49h              ;StatCtrl
                   4217                                         ;0 1 00 1001
                   4218                                         ;   \  \    \
                   4219                                         ;    \  \    load ToEn[2:0]=011 : LTimeOut driven Br Flag
                   4220                                         ;     \  nop
                   4221                                         ;      reset internal flags
                   4222                                         ;CkCtrl
0973   0639        4223            dcom      9,06h              ;00 00 0110
                   4224                                         ;  \  \    \
                   4225                                         ;   \  \    BrPls : BrMatch -> BrCk
                   4226                                         ;    \  RptCap : nop
                   4227                                         ;     Capt : nop
                   4228                                         ;send the start bit immediately
0974   1235        4229            dcom      5,12h              ;000 10 010
                   4230                                         ;   \  \   \
                   4231                                         ;    \  \   Y reset, X unchanged
                   4232                                         ;     \  Z reset (start bit)
                   4233                                         ;      M and N unchanged
                   4234                                         ;reset the counter
0975   A037        4235            dcom      7,0A0h             ;1 0 10 0000
                   4236                                         ;   \  \    \
                   4237                                         ;    \  \    BrCk/OutCk pulse : nop
                   4238                                         ;     \  counter : reset and start
                   4239                                         ;      capture : nop
                   4240  
                   4241                                         ;reset the flags so if a Timeout occured before the reset of the timer, it is discarded
0976   3A62        4242            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   4243  
                   4244                                         ;initialize X (number of Tbit for a pulse)
0977   8CB5        4245            mov       X,#12 
0978   5DB5        4246            mov       X,Rom:ConstantTbl shr 2[X] 
                   4247  
                   4248  wakeup_tbit                            ;X contains the number of Tbit for a pulse
0979   0A58        4249            wait      Event,TimeOut      ;wait before sending the next bit
                   4250                                         ;check the source that ended the wait
097A U 0009        4251            jtime     wakeuppls_to       ;TimeOut from the counter
097B   E662        4252            call      cmdrcvd            ;Event from the Mlx16: get the command (X not modified)
097C   7929        4253            jmp       wakeup_tbit        ;keep waiting
                   4254  
                   4255  wakeuppls_to                           ;check the source of the timeout (and reset the flags / acknowledge the event!)
097D   3A62        4256            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   4257                                         ;...
                   4258                                         ;check if a bit error has been detected
                   4259                                         ;...
097E   81C5        4260            sub       X,#1 
097F U 0001        4261            jz        wakeup_done 
     U             4262                                         ;prepare the next bit
0980   0235        4263            dcom      5,02h              ;000 00 010
                   4264                                         ;   \  \   \
                   4265                                         ;    \  \   Y reset, X unchanged
                   4266                                         ;     \  Z unchanged
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 102  Win32 Assembler
                                LIN2B.ASM

                   4267                                         ;      M and N unchanged
                   4268                                         ;keep waiting
0981   7929        4269            jmp       wakeup_tbit 
                   4270  
                   4271  wakeup_done                            ;put a recessive level on the bus
0982   1B35        4272            dcom      5,1Bh              ;000 11 011
                   4273                                         ;   \  \   \
                   4274                                         ;    \  \   X and Y set
                   4275                                         ;     \  Z unchanged
                   4276                                         ;      M and N unchanged
                   4277                                         ;increment B
0983   71B2        4278            mov       B,Btmp 
0984   8186        4279            add       B,#1 
0985   7172        4280            mov       Btmp,B 
                   4281                                         ;check if this is a pause (B odd) or a pulse (B even)
0986   81A6        4282            msk       B,#1 
0987 U 0011        4283            jnz       wakeup_pause       ;this is a pause
     U             4284                                         ;this is a pulse, ot the sequence is finished, in that case send a slWKUPabort
0988   86E6        4285            cmp       B,#6 
0989 U 0001        4286            jz        wakeup_end 
098A   6C29        4287            jmp       wakeup_pulse 
                   4288  
                   4289  wakeup_end                             ;end of the wake-up sequence. No activity was detected, signal it to the application
098B   84B5        4290            mov       X,#slWKUPabort 
098C U 0020        4291            jmp       gotosleep 
     U             4292  
     U             4293  wakeup_pause                           ;wait for the rising edge of the bus, with a timeout of 1 bit time
     U             4294                                         ;if at the end of the bit time the bus is still low, then there is someone else driving the bus, go try to detect a break
098D   0938        4295            dcom      8,09h              ;00 00 1001
                   4296                                         ;          Edg[2:0]=001: slow rising edge
098E   0658        4297            wait      EvExt,TimeOut      ;wait for the rising edge, or for a timeout
098F U 0009        4298            jtime     wakeup_toedge 
     U             4299                                         ;if this is not a timeout, it was a rising edge, prepare to receive a break
0990   3A62        4300            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0991 U 0020        4301            jmp       wakeup_nobreak 
     U             4302  
     U             4303  wakeup_toedge                          ;check if the bus is still dominant (break)
0992   3A62        4304            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0993   88A6        4305            msk       B,#8 
0994 U 0001        4306            jz        wakeup_break 
0995 U 0020        4307            jmp       wakeup_nobreak 
     U             4308  wakeup_break                           ;the bus is dominant, there is a break ?
0996   80B5        4309            mov       X,#0               ;reset LINbrcpt +3/+4 
0997   4371        4310            mov       LINbrcpt+3,X 
0998   4471        4311            mov       LINbrcpt+4,X 
0999   04B3        4312            mov       A,LINbrNom         ;put LINbr in A/B
099A   05B2        4313            mov       B,LINbrNom+1 
                   4314                                         ;put the 6 Tbit in the bit counter (6 half bits = 12)
                   4315                                         ;6Tbit = 4Tbit + 2Tbit
099B   9247        4316            asl       A                  ;multply by 2
099C   9646        4317            rlc       B 
099D   9645        4318            rlc       X 
099E   4073        4319            mov       LINbrcpt,A         ;store it in Linbrcpt
099F   4172        4320            mov       LINbrcpt+1,B 
09A0   4271        4321            mov       LINbrcpt+2,X 
09A1   9247        4322            asl       A                  ;multply by 2 again
09A2   9646        4323            rlc       B 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 103  Win32 Assembler
                                LIN2B.ASM

09A3   9645        4324            rlc       X 
09A4   4083        4325            add       A,LINbrcpt         ;add it to LINbrcpt
09A5   418A        4326            addcz     B,LINbrcpt+1 
09A6   4289        4327            addcz     X,LINbrcpt+2 
09A7   4073        4328            mov       LINbrcpt,A         ;store it in Linbrcpt
09A8   4172        4329            mov       LINbrcpt+1,B 
09A9   4271        4330            mov       LINbrcpt+2,X       ;save the value
                   4331                                         ;5 for the pulse and 1 for the timeout while waiting for an edge
                   4332                                         ;start the counter
09AA   A037        4333            dcom      7,0A0h             ;1 0 10 0000
                   4334                                         ;   \  \    \
                   4335                                         ;    \  \    BrCk/OutCk pulse : nop
                   4336                                         ;     \  counter : reset and start
                   4337                                         ;      capture : nop
09AB   88B7        4338            mov       A,#slWKUPbreak 
09AC   82B6        4339            mov       B,#stACT           ;signal a change to that ACTIVE state
09AD   CA62        4340            call      chst 
                   4341            
                   4342                                         ;Set collision bit to make sure auto-baudrate part is handling correct
09AE   3BB3        4343            mov       A,LINerrStat       ;x x x x
09AF   84F7        4344            or        A,#4               ; \ \ \ \
                   4345                                         ;  \ \ \ data stop bit error detected
                   4346                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   4347                                         ;    \ collision error detected
                   4348                                         ;     ID stop bit error detected
09B0   3B73        4349            mov       LINerrStat,A 
09B1   A324        4350            jmp       act_init           ;go wait for the end of the break
                   4351  
                   4352  wakeup_nobreak                         ;initialize the MSBi cell for break detection
09B2   8162        4353            call      wbr_init 
                   4354  
09B3   71B2        4355            mov       B,Btmp 
09B4   85E6        4356            cmp       B,#5               ;A < 5 : C
                   4357                                         ;A = 5 : no C, Z
                   4358                                         ;A > 5 : no C
09B5 U 0001        4359            jz        wakeup_long 
09B6   84B7        4360            mov       A,#4               ;index for WuPauseCnt_Val (wake-up pause value)
09B7   85B5        4361            mov       X,#5               ;index for WuPausePre_Val (prescaler)
09B8 U 0020        4362            jmp       wakeup_send 
     U             4363  
     U             4364  wakeup_long                            ;long pause
09B9   86B7        4365            mov       A,#6               ;index for WuSeqCnt_Val (wake-up long pause value)
09BA   87B5        4366            mov       X,#7               ;index for WuSeqPre_Val (prescaler)
                   4367                                         ;initialise the MSBi cell (timer)
                   4368                                         ;Wake Up Request -> 150 ms between two pulses (pulses between 250us and 5 ms wide) then 1.5 s before another pulse sequence
                   4369                                         ;Pause Length : 150ms - used with the Sleep Timer : WuPauseCnt_Val, WuPausePre_Val
                   4370                                         ;Sequence Pause Length : 1.5s - used with the Sleep Timer : WuSeqCnt_Val, WuSeqPre_Val
                   4371  wakeup_send                            ;wake-up timer
09BB   63B7        4372            mov       A,Rom:ConstantTbl2 shr 2[A] ;WuSeqCnt_Val or WuSeqCnt_Val: wake-up pause value
09BC   61B5        4373            mov       X,Rom:ConstantTbl2 shr 2[X] ;WuPausePre_Val or WuSeqPre_Val
                   4374                                         ;1 xxx
                   4375                                         ; \   \
                   4376                                         ;  \   prescaler (WuSeqPre_Val)
                   4377                                         ;   timer enabled
09BD   83B6        4378            mov       B,#3               ;sleep timer value index
09BE   BC77        4379            mov       io:7h[B],A 
09BF   82B6        4380            mov       B,#2               ;sleep timer prescaler index
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 104  Win32 Assembler
                                LIN2B.ASM

09C0   BC75        4381            mov       io:7h[B],X 
09C1   333B        4382            dcom      11,33h             ;enable and restart the sleep timer timeout (060821)
                   4383  
                   4384  wakeup_wait                            ;wait...
09C2   0F58        4385            waitpd    Event,TimeOut,EvExt 
                   4386                                         ;Event from the Mlx16 (command)
                   4387                                         ;EvExt from the MSBi (edge)
                   4388                                         ;TimeOut from the counter
                   4389                                         ;check the source that ended the wait
09C3 U 0008        4390            jxev      wakeup_ev          ;EvExt from the MSBi (edge!)
09C4 U 0009        4391            jtime     wakeup_to          ;TimeOut from the counter
09C5   E662        4392            call      cmdrcvd            ;Event from the Mlx16: get the command
09C6   C229        4393            jmp       wakeup_wait        ;keep waiting
                   4394  
                   4395  wakeup_to                              ;TimeOut ! -----------------------
09C7   3A62        4396            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   4397                                         ;check that the bus is not low
09C8   88A6        4398            msk       B,#8 
09C9 U 0001        4399            jz        wakeup_ev 
     U             4400                                         ;check the status of the timers
09CA   26B7        4401            mov       A,io:6h            ;Sleep Timer Status (read and clear)
09CB   8FBF        4402            and       A,#15 
09CC U 0001        4403            jz        wakeup_oth         ;if it's not the Sleep Timer, check the others
     U             4404                                         ;go to the wakeup loop
09CD   8229        4405            jmp       wakeup_done 
                   4406  
                   4407  wakeup_oth                             ;it was the Message Timer that timed out...
09CE   C229        4408            jmp       wakeup_wait 
                   4409  
                   4410  wakeup_ev                              ;Edge ! --------------------------
09CF   3A62        4411            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
                   4412                                         ;if this is really a wake-up, change state and the go measure the break...
09D0   85B7        4413            mov       A,#slWKUPresp      ;signal that there was some activity on the bus
09D1   82B6        4414            mov       B,#stACT           ;load the new state
09D2   CA62        4415            call      chst               ;do the change
09D3   A324        4416            jmp       act_init           ;go measure the break
                   4417  
                   4418  ;-------------- SLEEP state (stSLEEP) ---------------------------------------------------------------------------------
                   4419  ; command(s) :
                   4420  ; power-down : allowed
                   4421  ; next state(s) : DISCONNECTED (command), ACTIVE (bus), WAKE-UP (command)
                   4422  ; action(s) :   allow the processor to go into low speed mode, wake-up on bus activity or Mlx16 event (WakeUp or Disconnect)
                   4423  ;   Sleep mode is entered on a sleep command send by the Mlx16, ona diagnostic master request frame with
                   4424  ;   the first byte equal to 0, or if the bus is inactive for more than 4 seconds
                   4425  ;   a wake-up request is a dominant pulse longer thant 150us, the cell must be ready within 100ms
                   4426  ;   X contains the reason why we went to sleep
                   4427  
                   4428  gotosleep                              ;enter to sleep state
                   4429                                         ;Xtmp is used to remember what is the source of the sleep state transition
                   4430                                         ;It can be slTO, slTOMESS, slMST, slAPP, slWKUP
09D4   7271        4431            mov       Xtmp,X 
09D5   38B7        4432            mov       A,io:18h           ; save the bus state into Atmp for later
09D6   7073        4433            mov       Atmp,A 
                   4434                                         ;don't disable the sleep timer, it is used for analog access
                   4435                                         ;initialise the MSBi cell to wait for 250us - (Br counter at 50us)
09D7   87B7        4436            mov       A,#7 
09D8   5FB7        4437            mov       A,Rom:ConstantTbl shr 2[A] 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 105  Win32 Assembler
                                LIN2B.ASM

09D9   4F73        4438            mov       LINtmp+1,A 
09DA   86B7        4439            mov       A,#6 
09DB   5FB7        4440            mov       A,Rom:ConstantTbl shr 2[A] 
09DC   4E73        4441            mov       LINtmp,A 
                   4442  
                   4443                                         ;Initialize Br register on the LIN cell to measure the length of an eventual wake-up pulse
09DD   4E4C        4444            dmar      #0,LINtmp 
                   4445                                         ;also load IntBr
09DE   4F4C        4446            dmar      #0,LINtmp+1 
                   4447  
                   4448                                         ;Initialize the prescaler
09DF   84B7        4449            mov       A,#4 
09E0   5FB7        4450            mov       A,Rom:ConstantTbl shr 2[A] 
09E1   3E77        4451            mov       io:1Eh,A 
                   4452  
                   4453  sleep_init                             ;start a 250us timer (before entering the deep sleep mode)
09E2   6934        4454            dcom      4,69h              ;StatCtrl
                   4455                                         ;0 1 10 1001
                   4456                                         ;   \  \    \
                   4457                                         ;    \  \    load ToEn[2:0]=001 : Br drives the TimeOut
                   4458                                         ;     \  reset Ftfr : slow edges set the traffic bit
                   4459                                         ;      reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
09E3   0738        4460            dcom      8,07h              ;00 00 0111
                   4461                                         ;  \  \    \
                   4462                                         ;   \  \    Rst[1:0]=11: reset with BrMatch or Edge (type of edge set in wbr_init)
                   4463                                         ;    \  nop
                   4464                                         ;     Init: nop
09E4   0A38        4465            dcom      8,0Ah              ;00 00 1010
                   4466                                         ;      Edg[2:0]=010: Slow Falling Edge
09E5   A037        4467            dcom      7,0A0h             ;1 0 10 0000
                   4468                                         ;   \  \    \
                   4469                                         ;    \  \    BrCk/OutCk pulse : nop
                   4470                                         ;     \  counter : reset and start
                   4471                                         ;      capture : nop
                   4472                                         ;250us is 5 Tbit@20kbps, initialize the counter - add one period to finish the stop bit
09E6   85B5        4473            mov       X,#5 
09E7   5DB5        4474            mov       X,Rom:ConstantTbl shr 2[X] ;SleepDelay
09E8   8185        4475            add       X,#1 
                   4476  
                   4477  sleep_wait                             ;wait for a timeout while monitoring the bus and listening to the application
09E9   0E58        4478            wait      Event,TimeOut,EvExt 
09EA U 0008        4479            jxev      sleep_event        ;external event coming from the MSBi (edge)
09EB U 0009        4480            jtime     sleep_to           ;timeout from the timer
09EC   E662        4481            call      cmdrcvd            ;command from the MLX16
09ED   E929        4482            jmp       sleep_wait 
                   4483  
                   4484  sleep_event                            ;an edge occured, start the measurement
09EE   3A62        4485            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
09EF   88BE        4486  sleep_testbus  and       B,#8 
09F0 U 0011        4487            jnz       jmp_sleep_wait     ;if the bus is not 0, return to wait
09F1 U 0020        4488            jmp       sleep_pulse        ;else start measuring the pulse
     U             4489  
     U             4490  sleep_to                               ;test the analog timer
09F2   7C62        4491            call      CheckAnaTmr 
09F3 U 0001        4492            jz        sleep_tomsbi 
09F4   E929        4493            jmp       sleep_wait 
                   4494  sleep_tomsbi                           ;decrement the counter
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 106  Win32 Assembler
                                LIN2B.ASM

09F5   3A62        4495            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
09F6   81C5        4496            sub       X,#1 
09F7 U 0001        4497            jz        sleep_took 
09F8   84BF        4498            and       A,#4               ;check if an event occured during the timeout
09F9 U 0011        4499            jnz       sleep_missev 
09FA   81A6        4500            msk       B,#1               ;check if an event occured while reading the registers
09FB U 0011        4501            jnz       sleep_missev 
09FC   EF29        4502            jmp       sleep_testbus      ;in case an event occured, check the bus level
09FD   E929        4503  jmp_sleep_wait  jmp       sleep_wait 
                   4504  sleep_missev                           ;an event was missed, check the bus
09FE   EF29        4505            jmp       sleep_testbus 
                   4506  
                   4507  sleep_took                             ;the 250us have been reached, enter the sleep state (if we weren't in that state yet)
09FF   01B1        4508            mov       X,LINst 
0A00   84E5        4509            cmp       X,#stSLEEP 
0A01 U 0001        4510            jz        sleep_entered      ;already in sleep state (wrong pulse received)
0A02   72B3        4511            mov       A,Xtmp             ;signal how the sleep mode is entered
0A03   84B6        4512            mov       B,#stSLEEP         ;set the new state: sleep
0A04   CA62        4513            call      chst               ;signal that the state changed
                   4514  
                   4515  sleep_entered                          ;check what is the way to get out of sleep mode:
                   4516                                         ; - reception of a frame on the LIN bus : soft wake-up, the Mlx4 has to monitor the bus and cannot be powered down
                   4517                                         ; - reception of a wake-up signal : hard wake-up, WKUP sent by the periphery, the Mlx4 can be put into deep sleep
0A05   65B3        4518            mov       A,LINoptions2      ;x x x x
                   4519                                         ; \ \ \ \
                   4520                                         ;  \ \ \ state change masked (1)
                   4521                                         ;   \ \ not used
                   4522                                         ;    \ deep sleep (1) / light sleep (0)
                   4523                                         ;     not used
0A06   84A7        4524            msk       A,#4 
0A07 U 0011        4525            jnz       sleep_deep 
0A08 U 0020        4526            jmp       sleep_light        ;go to sleep light
     U             4527  
     U             4528  sleep_deep                             ;In deep sleep, the wake up of the Mlx4 is done by the periphery (WKUP signal). The Mlx4 DOES NOT monitor the bus !
0A09   4834        4529            dcom      4,48h              ;StatCtrl
                   4530                                         ;0 1 00 1000
                   4531                                         ;   \  \    \
                   4532                                         ;    \  \    load ToEn[2:0]=000 : TimeOut not driven
                   4533                                         ;     \  nop
                   4534                                         ;      reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
0A0A   9037        4535            dcom      7,90h              ;1 0 01 0000
                   4536                                         ;   \  \    \
                   4537                                         ;    \  \    BrCk/OutCk pulse : nop
                   4538                                         ;     \  counter : stop
                   4539                                         ;      capture : nop
0A0B   0438        4540            dcom      8,04h              ;00 00 0100
                   4541                                         ;  \  \    \
                   4542                                         ;   \  \    Rst[1:0]=00 : no reset
                   4543                                         ;    \  nop
                   4544                                         ;     Init: nop
                   4545                                         ; Digital Bus Flags : reset sleepb
0A0C   403E        4546            dcom      14,40h             ;010 x xxxx
                   4547                                         ;   \
                   4548                                         ;    sleepb = 0
                   4549                                         ; Slow Clock Enable
0A0D   8C3F        4550            dcom      15,8Ch             ;1xxx 11xx
                   4551                                         ;       \
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 107  Win32 Assembler
                                LIN2B.ASM

                   4552                                         ;        SlowCk = 1 (no PLL request)
                   4553                                         ;The clock will go in slow mode only if the mlx16 also request it to
                   4554  
                   4555  sleep_chkwup                           ;then check the wake-up pin from the analog before enabling the wake-up signal
0A0E   23B7        4556            mov       A,io:3h            ;{EXCP, WKUP, PHYSTAT[1:0]}
0A0F   84BF        4557            and       A,#4 
0A10 U 0001        4558            jz        sleep_enwkup 
     U             4559                                         ;wake-up pulse detected, check the bus to see if it has changed
     U             4560                                         ;get the Status registers from the MSBi cell
0A11   3A62        4561            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0A12   88BF        4562            and       A,#8               ;check the Traffic bit
0A13 U 0011        4563            jnz       jmp_dis_sleep      ;traffic bit is set : there was an edge
0A14   0E2A        4564            jmp       sleep_chkwup       ;traffic bit not set, check the wake-up signal again
0A15 U 0020        4565  jmp_dis_sleep  jmp       dis_sleep 
     U             4566  
     U             4567  sleep_enwkup                           ;no wake-up pulse, enable wake-up : wkup signal is a source ot timeout for the mlx4
0A16   983E        4568            dcom      14,98h             ;100 11 xxx
                   4569                                         ;      \
                   4570                                         ;       enwkup = 1
                   4571  sleep                                  ;deep sleep loop
0A17   0B58        4572            waitpd    Event,TimeOut      ;(0Bh) - power-down allowed
0A18 U 0009        4573            jtime     wu_pulse           ;check the wake-up signal coming from the periphery
0A19   E662        4574            call      cmdrcvd            ;a command has been received : get the command
0A1A   172A        4575            jmp       sleep              ;loop (if this was a state change, the program goes directly to the selected state)
                   4576  
                   4577  sleep_light                            ;light sleep, keep monitoring the bus
0A1B   6834        4578            dcom      4,68h              ;StatCtrl
                   4579                                         ;0 1 10 1000
                   4580                                         ;   \  \    \
                   4581                                         ;    \  \    load ToEn[2:0]=000 : TimeOut not driven
                   4582                                         ;     \  reset Ftfr : slow edges set the traffic bit
                   4583                                         ;      reset internal flags: Traffic, TraErr, flags related to CaptErr, TimeOut, EvExt
0A1C   9037        4584            dcom      7,90h              ;1 0 01 0000
                   4585                                         ;   \  \    \
                   4586                                         ;    \  \    BrCk/OutCk pulse : nop
                   4587                                         ;     \  counter : stop
                   4588                                         ;      capture : nop
0A1D   0638        4589            dcom      8,06h              ;00 00 0110
                   4590                                         ;  \  \    \
                   4591                                         ;   \  \    Rst[1:0]=10 : edge cause a reset
                   4592                                         ;    \  nop
                   4593                                         ;     Init: nop
0A1E   0A38        4594            dcom      8,0Ah              ;00 00 1010
                   4595                                         ;      Edg[2:0]=010: Slow Falling Edge
                   4596            
0A1F   70B3        4597            mov       A,Atmp             ;reload the bus state at the beginning
0A20   88BF        4598            and       A,#8               ;check if the bus state was recessive
0A21 U 0001        4599            jz        wait_sleep_light   ;it was dominant, drop
0A22   38B6        4600            mov       B,io:18h           ;check the actual bus state
0A23   88BE        4601            and       B,#8 
0A24 U 0011        4602            jnz       wait_sleep_light   ;the actual state is recessive, continue
0A25 U 0020        4603            jmp       sleep_pulse        ;the actual state is dominant while recessive at the beginning, go directly to pulse detection
     U             4604  
     U             4605                                         ;--- deep sleep mode -------------
     U             4606  wu_pulse                               ;test the analog timer
0A26   7C62        4607            call      CheckAnaTmr 
0A27 U 0001        4608            jz        wu_test 
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 108  Win32 Assembler
                                LIN2B.ASM

0A28   172A        4609            jmp       sleep 
                   4610  wu_test                                ;a wake-up pulse has been detected : check the wake-up pin from the analog
0A29   23B7        4611            mov       A,io:3h            ;{EXCP, WKUP, PHYSTAT[1:0]}
0A2A   84BF        4612            and       A,#4               ;check if it was really a wake-up pulse
0A2B U 0011        4613            jnz       dis_sleep 
     U             4614  false_wu                               ;the bus is high : that was probably a glitch. Clear the flags
0A2C   3A62        4615            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0A2D               4616            #IF       coDEBUGMARK eq cvON 
0A2D   057C        4617            xdcom     #dcSLEEP           ;mark instruction
0A2E               4618            #ENDIF    
0A2E   172A        4619            jmp       sleep 
                   4620  
                   4621  wait_sleep_light                       ;wait for an external event of a command from the Mlx16 - power down not allowed
0A2F   0E58        4622            wait      Event,EvExt,TimeOut 
0A30 U 0008        4623            jxev      sleep_light_pls    ;external event coming from the MSBi (edge)
0A31 U 0009        4624            jtime     sleep_light_to 
0A32   E662        4625            call      cmdrcvd            ;command from the MLX16 : get the command
0A33   2F2A        4626            jmp       wait_sleep_light   ;loop (if this was a state change, the program goes directly to the selected state)
                   4627  
                   4628  sleep_light_to                         ;test the analog timer
0A34   7C62        4629            call      CheckAnaTmr 
0A35   2F2A        4630            jmp       wait_sleep_light 
                   4631  
                   4632  sleep_light_pls                        ;check if the bus is really low, go to the active state to measure the first pulse, which can be a break
0A36   3A62        4633            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0A37   88BE        4634            and       B,#8 
0A38 U 0001        4635            jz        sleep_pulse        ;the bus is low, measure the pulse length
0A39   2F2A        4636            jmp       wait_sleep_light 
                   4637  
                   4638  dis_sleep                              ;disable wake-up : wkup signal is not a source ot timeout for the mlx4 anymore
0A3A   2B62        4639            call      dis_ana_wkup 
0A3B U 0020        4640            jmp       pulse_valid 
     U             4641  
     U             4642                                         ;---------------------------------
     U             4643  sleep_pulse                            ;a falling edge has been detected while waiting for the 250us before entering the sleep mode
     U             4644                                         ;reset the timeout counter, which will be used to measure the length of the pulse
0A3C   3E4D        4645            dmar      #1,ClearByte       ;use the dma to clear the byte
0A3D   3049        4646            dmaw      LINtocnt,#1 
                   4647  
                   4648                                         ;re-init the MSBi cell
0A3E   4934        4649            dcom      4,49h              ;StatCtrl
                   4650                                         ;0 1 00 1001
                   4651                                         ;   \       \
                   4652                                         ;    \       load ToEn[2:0]=001 : Br drives the TimeOut
                   4653                                         ;     reset internal flags
                   4654                                         ;wait for a rising edge
0A3F   0938        4655            dcom      8,09h              ;00 00 1001
                   4656                                         ;      Edg[2:0]=001: Slow Rising Edge
                   4657                                         ;no reset on rising edge
0A40   0538        4658            dcom      8,05h              ;00 00 0101
                   4659                                         ;       Rst[1:0]=01 : reset on BrMatch
                   4660                                         ;reset the counter
0A41   A037        4661            dcom      7,0A0h             ;1 0 10 0000
                   4662                                         ;   \  \    \
                   4663                                         ;    \  \    BrCk/OutCk pulse : nop
                   4664                                         ;     \  counter : reset and start
                   4665                                         ;      capture : nop
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 109  Win32 Assembler
                                LIN2B.ASM

0A42   8639        4666            dcom      9,86h              ;10 00 0110
                   4667                                         ;  \  \    \
                   4668                                         ;   \  \    BrPls : nop (halfMatch -> InBrCk, BrMatch -> BrCk)
                   4669                                         ;    \  RptCap : nop
                   4670                                         ;     Capt : reset (do not allow a capture now)
                   4671  
                   4672  pulse_wait                             ;wait for a timeout while monitoring the bus and listening to the application
0A43   0E58        4673            wait      Event,TimeOut,EvExt 
0A44 U 0008        4674            jxev      jmp_pulse_chkedg   ;external event coming from the MSBi (edge)
0A45 U 0009        4675            jtime     pulse_inc_chk      ;timeout from the timer
0A46   E662        4676            call      cmdrcvd            ;command from the MLX16
0A47   432A        4677            jmp       pulse_wait 
                   4678  jmp_pulse_chkedg  
0A48 U 0020        4679            jmp       pulse_chkedg 
     U             4680  
     U             4681  pulse_inc_chk                          ;a Br event occured, increment the counter and check the length
0A49   7C62        4682            call      CheckAnaTmr        ;check if Timeout comes from Sleep timer
0A4A U 0001        4683            jz        pulse_inc_cnt      ;wake up from MSBI, increment the counter  
0A4B   432A        4684            jmp       pulse_wait         ;wake up from sleep timer, go back to wait
                   4685  pulse_inc_cnt  
0A4C   3A62        4686            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0A4D   30B3        4687            mov       A,LINtocnt 
0A4E   31B2        4688            mov       B,LINtocnt+1 
0A4F   8187        4689            add       A,#1 
0A50   808E        4690            addcz     B,#0 
0A51   3073        4691            mov       LINtocnt,A 
0A52   3172        4692            mov       LINtocnt+1,B 
                   4693  
0A53   88B5        4694            mov       X,#8 
0A54   5DE7        4695            cmp       A,Rom:ConstantTbl shr 2[X] 
0A55   89B5        4696            mov       X,#9 
0A56   5DEE        4697            cmpcz     B,Rom:ConstantTbl shr 2[X] 
0A57 U 0011        4698            jnz       pulse_chkmax       ;check the maximum pulse length
0A58   82B7        4699            mov       A,#2               ;x x x x
0A59   3B73        4700            mov       LINerrStat,A       ; \ \ \ \
                   4701                                         ;  \ \ \ data stop bit error detected
                   4702                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   4703                                         ;    \ collision error detected
                   4704                                         ;     ID stop bit error detected
                   4705  pulse_chkmax                           ;check if the bus hasn't been dominant for too long
0A5A   8AB5        4706            mov       X,#10 
0A5B   5DE7        4707            cmp       A,Rom:ConstantTbl shr 2[X] 
0A5C   8BB5        4708            mov       X,#11 
0A5D   5DEE        4709            cmpcz     B,Rom:ConstantTbl shr 2[X] 
0A5E U 0000        4710            jc        pulse_chkedg       ;dominant length ok, check the edge
     U             4711                                         ;the bus has been dominant for too long, this is a short
0A5F   1829        4712            jmp       BusShort 
                   4713  
                   4714  pulse_chkedg                           ;check if there was a rising edge
0A60   3A62        4715            call      ReadStatus         ;A = {Traffic,LEvExt,Ovf,BrEv}, B = {Bin,SplBin,SyncErr,RunErr}
0A61   88A6        4716            msk       B,#8 
0A62 U 0011        4717            jnz       pulse_end          ;the bus is high, it's actualy an edge
0A63   432A        4718            jmp       pulse_wait         ;it wasn't an external event... back to the waiting loop
                   4719  
                   4720  pulse_end                              ;a rising edge has been detected, check if it was long enough to be a wake-up pulse
0A64   01B2        4721            mov       B,LINst            ;prepare state checking
0A65   3BB3        4722            mov       A,LINerrStat       ;x x x x
Melexis Win32 Assembler 1.9.3 (c)2001 Melexis Ltd Thu Sep 24 13:51:31 2015
Page 110  Win32 Assembler
                                LIN2B.ASM

0A66   82A7        4723            msk       A,#2               ; \ \ \ \
                   4724                                         ;  \ \ \ data stop bit error detected
                   4725                                         ;   \ \ wake-up pulse detected (do not handle the break)
                   4726                                         ;    \ collision error detected
                   4727                                         ;     ID stop bit error detected
0A67 U 0011        4728            jnz       pulse_valid_check  ;pulse is valid, check if we are in sleep or init
     U             4729                                         ;the pulse has really ended but it was too short, go back to wait for the 250us delay if we were not already in the sleep state
0A68               4730            #IF       coDEBUGMARK eq cvON 
0A68   057C        4731            xdcom     #dcSLEEP           ;mark instruction
0A69               4732            #ENDIF    
0A69   84E6        4733            cmp       B,#stSLEEP 
0A6A U 0001        4734            jz        jmp_sleep_light    ;we were in the sleep state, keep waiting for a pulse or a command
0A6B   E229        4735            jmp       sleep_init         ;we were not in the sleep state, wait for 250us
0A6C   1B2A        4736  jmp_sleep_light  jmp       sleep_light ;go back to sleep light
                   4737  pulse_valid_check                      ;the pulse is valid, check if we are in regular sleep mode           
0A6D   84E6        4738            cmp       B,#stSLEEP         ;check if we were in sleep init 
0A6E U 0001        4739            jz        pulse_valid        ;valid pulse has been received during sleep
     U             4740                                         ;we were in sleep init, generate an wakeup error
0A6F   8FB6        4741            mov       B,#erWKUPINIT 
0A70   B562        4742            call      errev 
0A71   A324        4743            jmp       act_init           ;go to the active state
                   4744  pulse_valid                            ;the wake-up pulse was valid, signal it to the application
0A72   83B7        4745            mov       A,#slWKUP          ;signal that there was a wake-up pulse
0A73   82B6        4746            mov       B,#stACT           ;load the new state
0A74   CA62        4747            call      chst               ;do the change
                   4748                                         ;clear the wakeup flags and go wait for a new break
0A75   80B7        4749            mov       A,#0 
0A76   3B73        4750            mov       LINerrStat,A 
0A77   A324        4751            jmp       act_init           ;go to the active state
                   4752  
                   4753  ;--------------- program end ------------------------------------------------------------------------------------------
0A78               4754  prog_end  end       
	No errors on assembly of 'LIN2B.ASM' 6366 lines