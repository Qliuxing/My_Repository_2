/*
 * LIN 2.x Low Level LIN FW API
 * Node Configuration and Identification
 *
 * Generated by configuration tool C:\EVWS\_LIBRARY_PLATFORMS\library_platform_mulan2\bin\ldf_nodegen.exe (version 1.4.0)
 *
 * Copyright (C) 2007-2013 Melexis N.V.
 */

#include "lin_api.h"



/* 
 * Type of response that should be sent upon receiving 0x3D (SRF) request.
 * Additional non-diagnostic frames can be sent between 0x3C (MRF) and
 * 0x3D(SRF)
 */
static volatile SlaveResponse_t pendingSlaveResponse; 

/* Local functions */
static ml_Status isSupplierIdValid (const ml_uint8 data[]);
static ml_Status isFunctionIdValid (const ml_uint8 data[]);

static SlaveResponse_t readByIdentifier (void);

#if defined (HAS_ASSIGN_NAD_SERVICE)
static SlaveResponse_t assignNAD (void);
#endif /* HAS_ASSIGN_NAD_SERVICE */

#if defined (HAS_CONDITIONAL_CHANGE_NAD_SERVICE)
static SlaveResponse_t conditionalChangeNAD (void);
static ml_uint8 ml_ResponseNAD;
#endif /* HAS_CONDITIONAL_CHANGE_NAD_SERVICE */

#if LIN_VERSION == 20
static SlaveResponse_t assignFrameID (void);
#endif /* LIN_VERSION == 20 */

#if LIN_VERSION >= 21
static SlaveResponse_t assignFrameIdRange (void);
#endif /* LIN_VERSION >= 21 */

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
static SlaveResponse_t saveConfiguration (void);
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */

#if defined (HAS_READ_BY_ID_CALLOUT)
static ml_uint8 callout_user_data[5];
#endif /* HAS_READ_BY_ID_CALLOUT */

/*
 ******************************************************************************
 * ml_DiagInit
 * 
 * (Re)initialize the configuration/identification layer
 ******************************************************************************
 */
void ml_DiagInit (void)
{
    pendingSlaveResponse = respNoResponse;
}

/*
 ******************************************************************************
 * ml_DiagMasterRequest
 * 
 * The function is called when Master Request Frame (0x3C) is received
 *
 * LinFrameDataBuffer[] frame structure: 
 *     NAD, PCI, SID,  Data
 *     [0]  [1]  [2]  [3..7] 
 ******************************************************************************
 */
void ml_DiagMasterRequest (void) 
{
#if LIN_VERSION >= 21
    mlu_TL_TimeoutStart(); /* N_As_LIN timeout (1000 mS) */

    if (LinFrameDataBuffer[0] != 0x7EU  /* functional request */) {
        /* A new MRF received (no matter to what NAD),
         * so reset pending response
         */
        pendingSlaveResponse = respNoResponse;
    }
    /* else :
     * Do NOT reset pending response in case of intervening Functional Request
     * Checked by LIN2.1 CT test case 13.1
     */

#elif LIN_VERSION == 20
    /* A new MRF received (no matter to what NAD),
    * so reset pending response
    */
    pendingSlaveResponse = respNoResponse;

#else
    #error Behaviour for specified LIN_VERSION is not defined!

#endif


#if defined (HAS_ASSIGN_NAD_SERVICE)
    /*
     * Check if this is [assign NAD] request (requires initial NAD in contrast to other services)
     */
    if (((LinFrameDataBuffer[0] == ml_InitialNAD) || (LinFrameDataBuffer[0] == 0x7FU /* wildcard */ ))
           && (LinFrameDataBuffer[2] == 0xB0U /* SID */ ))
    {
        pendingSlaveResponse = assignNAD();
    }
    else
#endif /* HAS_ASSIGN_NAD_SERVICE */

    /*
     *  If request is addressed to our NAD (or NAD wildcard)
     */
    if ((LinFrameDataBuffer[0] == ml_ConfiguredNAD) || (LinFrameDataBuffer[0] == 0x7FU /* wildcard */)) {
   
        switch (LinFrameDataBuffer[2] /* SID */) {

#if LIN_VERSION == 20
        case 0xB1: /* ---------------------------- Assign FrameID */
            pendingSlaveResponse = assignFrameID();
            break; /* !case 0xB1 */
#endif /* LIN_VERSION == 20 */

        case 0xB2: /*------------------- Read by Identifier request */
            pendingSlaveResponse = readByIdentifier();
            break; /* !case 0xB2 */

#if defined (HAS_CONDITIONAL_CHANGE_NAD_SERVICE)
        case 0xB3: /*--------------- Conditional change NAD request (LIN2.x) */
            pendingSlaveResponse = conditionalChangeNAD();
            break; /* !case 0xB3 */
#endif /* HAS_CONDITIONAL_CHANGE_NAD_SERVICE */

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
        case 0xB6: /*--------------- Save Configuration request */
            pendingSlaveResponse = saveConfiguration();
            break; /* !case 0xB6 */
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */

#if LIN_VERSION >= 21
        case 0xB7:
            pendingSlaveResponse = assignFrameIdRange();
            break; /* !case 0xB7 */
#endif /* LIN_VERSION >= 21 */

        default:
            /* ignore not supported services */
            break;
        }
    }
    else {
        /*
         * Message is not addressed to this node, ignore it
         */
    }
}


/*
 ******************************************************************************
 * ml_DiagSlaveResponse
 * 
 * The function is called when Slave Response Frame (0x3D) is requested
 *
 * Return:
 *      ML_SUCCESS  There is data to send
 *      ML_FAILURE  There is nothing to send (no response)
 ******************************************************************************
 */
ml_Status ml_DiagSlaveResponse (void) 
{
    ml_Status status = ML_SUCCESS;
    SlaveResponse_t thisPendingSlaveResponse = pendingSlaveResponse;

    /* reset pending response after processing */
    /* speculative next state/response, overwrite if otherwise */
    pendingSlaveResponse = respNoResponse; 

        switch (thisPendingSlaveResponse) 
        {
            case respNoResponse:
                status = ML_FAILURE;
                break;

            case respLinProductID:
                /* Fill the buffer with slave Response */
                /* Response format : NAD PCI RSID D1 D2 D3 D4 D5 */
                LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                LinFrameDataBuffer[1] = 0x06U;  /* PCI */
                LinFrameDataBuffer[2] = 0xF2U;  /* RSID = SID+0x40 = 0xb2+0x40 */
            
                LinFrameDataBuffer[3] = ml_ProductID[0];
                LinFrameDataBuffer[4] = ml_ProductID[1];
                LinFrameDataBuffer[5] = ml_ProductID[2];
                LinFrameDataBuffer[6] = ml_ProductID[3];
                LinFrameDataBuffer[7] = ml_ProductID[4];

                /* status = ML_SUCCESS */
                /* pendingSlaveResponse = respNoResponse; */
                /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                break;

#if defined (HAS_SERIAL_NUMBER_CALLOUT)
            case respSerialNumber:
                LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                LinFrameDataBuffer[1] = 0x05U;  /* PCI */
                LinFrameDataBuffer[2] = 0xF2U;  /* RSID = SID+0x40 = 0xb2+0x40 */
                    
                ld_serial_number_callout(&LinFrameDataBuffer[3]); /* Insert Serial Number into data bytes 3..6 */
        
                LinFrameDataBuffer[7] = 0xFFU;
                
                /* status = ML_SUCCESS */
                /* pendingSlaveResponse = respNoResponse; */
                /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                break;
#endif /* HAS_SERIAL_NUMBER_CALLOUT */

            case respNegativeResponse:
                LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                LinFrameDataBuffer[1] = 0x03U;  /* PCI */
                LinFrameDataBuffer[2] = 0x7FU;  /* RSID = 0x7F  */ 
                    
                LinFrameDataBuffer[3] = 0xB2U;  /* Data1: Requested ID  */
                LinFrameDataBuffer[4] = 0x12U;  /* Data2: Error code    */
                LinFrameDataBuffer[5] = 0xFFU;  /* Data3                */
                LinFrameDataBuffer[6] = 0xFFU;  /* Data4                */
                LinFrameDataBuffer[7] = 0xFFU;  /* Data5                */
            
                /* status = ML_SUCCESS */
                /* pendingSlaveResponse = respNoResponse; */
                /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                break;

#if defined (HAS_ASSIGN_NAD_SERVICE)
            case respAssignNAD:
                LinFrameDataBuffer[0] = ml_InitialNAD;
                LinFrameDataBuffer[1] = 0x01U;  /* PCI */
                LinFrameDataBuffer[2] = 0xF0U;  /* RSID = 0XB0 + 0x40 */
            
                LinFrameDataBuffer[3] = 0xFFU;
                LinFrameDataBuffer[4] = 0xFFU;
                LinFrameDataBuffer[5] = 0xFFU;
                LinFrameDataBuffer[6] = 0xFFU;
                LinFrameDataBuffer[7] = 0xFFU;
              
                /* status = ML_SUCCESS */
                /* pendingSlaveResponse = respNoResponse; */
                /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                break;
#endif /* HAS_ASSIGN_NAD_SERVICE */

#if defined (HAS_CONDITIONAL_CHANGE_NAD_SERVICE)
            case respConditionalChangeNAD:
                LinFrameDataBuffer[0] = ml_ResponseNAD; /* old NAD, see [PLTF-351] */
                LinFrameDataBuffer[1] = 0x01U;  /* PCI */
                LinFrameDataBuffer[2] = 0xF3U;  /* RSID = 0XB3 + 0x40 */

                LinFrameDataBuffer[3] = 0xFFU;
                LinFrameDataBuffer[4] = 0xFFU;
                LinFrameDataBuffer[5] = 0xFFU;
                LinFrameDataBuffer[6] = 0xFFU;
                LinFrameDataBuffer[7] = 0xFFU;
            
                /* status = ML_SUCCESS */
                /* pendingSlaveResponse = respNoResponse; */
                /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                break;
#endif /* HAS_CONDITIONAL_CHANGE_NAD_SERVICE */

#if LIN_VERSION == 20
            case respPositiveAssignFID:
                 LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                 LinFrameDataBuffer[1] = 0x01U; /* PCI */
                 LinFrameDataBuffer[2] = 0xF1U; /* RSID = 0xB1+0x40 */
    
                 LinFrameDataBuffer[3] = 0xFFU;
                 LinFrameDataBuffer[4] = 0xFFU;
                 LinFrameDataBuffer[5] = 0xFFU;
                 LinFrameDataBuffer[6] = 0xFFU;
                 LinFrameDataBuffer[7] = 0xFFU;

                 /* status = ML_SUCCESS */
                 /* pendingSlaveResponse = respNoResponse; */
                 /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
             break;
#endif /* LIN_VERSION == 20 */

#if LIN_VERSION >= 21
            case respPositiveAssignFidRange:
                 LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                 LinFrameDataBuffer[1] = 0x01U; /* PCI */
                 LinFrameDataBuffer[2] = 0xF7U; /* RSID = 0xB7+0x40 */

                 LinFrameDataBuffer[3] = 0xFFU;
                 LinFrameDataBuffer[4] = 0xFFU;
                 LinFrameDataBuffer[5] = 0xFFU;
                 LinFrameDataBuffer[6] = 0xFFU;
                 LinFrameDataBuffer[7] = 0xFFU;

                 /* status = ML_SUCCESS */
                 /* pendingSlaveResponse = respNoResponse; */
                 /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                 break;

#endif /* LIN_VERSION >= 21 */

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
            case respPositiveSaveConfig:
                 LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                 LinFrameDataBuffer[1] = 0x01U; /* PCI */
                 LinFrameDataBuffer[2] = 0xF6U; /* RSID = 0xB6+0x40 */
        
                 LinFrameDataBuffer[3] = 0xFFU;
                 LinFrameDataBuffer[4] = 0xFFU;
                 LinFrameDataBuffer[5] = 0xFFU;
                 LinFrameDataBuffer[6] = 0xFFU;
                 LinFrameDataBuffer[7] = 0xFFU;
                
                 /* status = ML_SUCCESS */
                 /* pendingSlaveResponse = respNoResponse; */
                 /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                 break;
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */

#if defined (HAS_READ_BY_ID_CALLOUT)
            case respUserDefIdCallout:
                 LinFrameDataBuffer[0] = ml_ConfiguredNAD;
                 LinFrameDataBuffer[1] = 0x06U; /* PCI */
                 LinFrameDataBuffer[2] = 0xF2U; /* RSID = 0xB2+0x40 */

                 LinFrameDataBuffer[3] = callout_user_data[0];
                 LinFrameDataBuffer[4] = callout_user_data[1];
                 LinFrameDataBuffer[5] = callout_user_data[2];
                 LinFrameDataBuffer[6] = callout_user_data[3];
                 LinFrameDataBuffer[7] = callout_user_data[4];

                 /* status = ML_SUCCESS */
                 /* pendingSlaveResponse = respNoResponse; */
                 /* [COOKED_API:] currSlaveState = stateIdle;   transition 6 */
                 break;
#endif /* HAS_READ_BY_ID_CALLOUT */

            default:
                status = ML_FAILURE;
                /* [COOKED_API:] currSlaveState = stateIdle; */
                /* pendingSlaveResponse = respNoResponse; */
                    
                break;
        }  /* switch (thisPendingSlaveResponse) */
    return (status);
}


/*
 *************************************************************************************
 * ml_DiagClearPendingResponse
 *
 *  Clears pending slave's respone (if any) to be sent with SRF frame
 *************************************************************************************
 */
void ml_DiagClearPendingResponse (void)
{
    pendingSlaveResponse = respNoResponse;
}


/*
 *************************************************************************************
 * isSupplierIdValid
 * 
 * Checks if supplierID is valid, i.e. match node's SupplierID which
 * is located in ml_ProductID[0], ml_ProductID[1]
 * 
 * Implementation note:
 * Little-endian CPU is implied and word aligned ml_ProductID[] is required
 * 
 * Returns:
 *     ML_SUCCESS  SupplierID is valid 
 *     ML_FAILURE  SupplierID is not valid
 *************************************************************************************
 */
static ml_Status isSupplierIdValid (const ml_uint8 data[])
{
    ml_uint16 supplierID;
    ml_uint16 cur_supplierID;
    ml_Status status;
    
    /* supplierID word could be on odd address, so get LSB, MSB separately */
    supplierID = ((ml_uint16)data[1] << 8 ) | data[0];
    cur_supplierID = (ml_uint16)ml_ProductID[0]
                 | (((ml_uint16)ml_ProductID[1]) << 8);

    if (   (supplierID == cur_supplierID)
        || (supplierID == 0x7FFFU /* wildcard */)) {
        status = ML_SUCCESS;
    } 
    else {
        status = ML_FAILURE;
    }

    return status;
}

/*
 *************************************************************************************
 * isFunctionIdValid
 * 
 * Checks if functionID is valid, i.e. match node's FunctionID which
 * is located in ml_ProductID[2], ml_ProductID[3]
 * 
 * Implementation note:
 * Little-endian CPU is implied and word aligned ml_ProductID[] is required
 *  
 * Returns:
 *     ML_SUCCESS  FunctionID is valid 
 *     ML_FAILURE  FunctionID is not valid
 *************************************************************************************
 */
static ml_Status isFunctionIdValid (const ml_uint8 data[])
{
    ml_uint16 functionID;
    ml_uint16 cur_functionID;
    ml_Status status;


    /* functionID word could be on odd address, so get LSB, MSB separately */
    functionID = ((ml_uint16)data[1] << 8) | data[0];
    cur_functionID = ((ml_uint16)ml_ProductID[2])
                  | (((ml_uint16)ml_ProductID[3]) << 8);

    if (   (functionID == cur_functionID)
        || (functionID == 0xFFFFU /* wildcard */)) {
        status = ML_SUCCESS;
    }
    else {
        status = ML_FAILURE;
    }

    return status;
}


#if defined (HAS_ASSIGN_NAD_SERVICE)
/*
 *************************************************************************************
 * assignNAD
 * 
 * Parses "Assign NAD" frame (service 0xB0) and returns resulting slave
 * response.
 * Uses global LinFrameDataBuffer[] buffer
 *
 *  Frame structure:
 *  InitialNAD, PCI, SID, SupplierID_LSB, SupplierID_MSB, FunctionID_LSB, FunctionID_MSB, NewNAD
 *     [0]      [1]  [2]       [3]             [4]             [5]            [6]           [7]
 * 
 * Returns:
 *      Requested response or respNoResponse
 *************************************************************************************
 */
static SlaveResponse_t assignNAD (void)
{
    if (LinFrameDataBuffer[1] != 0x06U) /* if PCI is not valid .. */
    {
        return respNoResponse;
    }
    /* else: PCI is valid, continue processing .. */

    /* Validate SupplierID [3..4] and FunctionID [5..6] */
    if ( (isSupplierIdValid(&LinFrameDataBuffer[3]) == ML_SUCCESS) &&
         (isFunctionIdValid(&LinFrameDataBuffer[5]) == ML_SUCCESS) )
    {
        ml_ConfiguredNAD = LinFrameDataBuffer[7];   /* new NAD */
#if defined (HAS_SET_LOADER_NAD)
        (void)ml_SetLoaderNAD(ml_ConfiguredNAD);    /* notify the loader about application's NAD */
#endif /* HAS_SET_LOADER_NAD */

        return respAssignNAD;
    }
    else {
        return respNoResponse;
    }
}
#endif /* HAS_ASSIGN_NAD_SERVICE */


#if LIN_VERSION == 20
/*
 *************************************************************************************
 * assignFrameID
 * 
 * Parses "Assign Frame Id" frame (service 0xB1), performs requested assignment and
 * returns resulting slave response.
 * Uses global LinFrameDataBuffer[] buffer
 *
 *  Frame structure:
 *  NAD, PCI, SID, SupplierID_LSB, SupplierID_MSB, MessageID_LSB, MessageID_MSB, PID
 *  [0]  [1]  [2]       [3]             [4]             [5]           [6]        [7]
 * 
 * Returns:
 *     respPositiveAssign   Frame ID successfully assigned to the message
 *     respNoResponse       Assignment failed
 *
 *************************************************************************************
 */
static SlaveResponse_t assignFrameID (void)
{
    ml_uint16 msgID_lin20; /* LIN 2.0 message identifier (16-bit) */
    ml_uint8 pid;
    ml_uint8 index;


    if (LinFrameDataBuffer[1] != 0x06U)     /* if PCI is not valid .. */
    {
        return respNoResponse;
    }
    /* else: PCI is valid, continue processing .. */
    
    if ( isSupplierIdValid(&LinFrameDataBuffer[3]) == ML_SUCCESS ) {    /* if supplier ID is valid .. */
        msgID_lin20 = ((ml_uint16)LinFrameDataBuffer[6] << 8)| LinFrameDataBuffer[5];
        pid = LinFrameDataBuffer[7];

        /* Find the internal index of requested message */
        for (index = 0U; index < ML_NUMBER_OF_DYNAMIC_MESSAGES; index++) {
            if (MID_list[index] == msgID_lin20) {
                break; /* found an index */
            }
        }

        if (index < ML_NUMBER_OF_DYNAMIC_MESSAGES) {
            ml_Status status;
            
            /* 
             * 0x40 (non valid Protected ID) is used to unassign FrameID for this message
             * [see LIN 2.0 spec, page 121]. Unassigned FrameID can be used for other
             * message then.
             *
             * MLX4 LIN FW does not remove message-to-FrameID association from internal
             * RAM (LIN_IDs array), but marks the message as disabled. So this message
             * is excluded from FrameId-to-message_index mapping
             */
            if (0x40U == pid) {
                (void)ml_Disconnect();
                status = ml_DisableMessage(index);
                (void)ml_Connect();

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
                node_configuration[index] = 0x00U;
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */
            } else if ((pid & 0x3FU) < 0x3CU){
                (void)ml_Disconnect();
                status = ml_AssignFrameToMessageID(index, pid);
                (void)ml_Connect();

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
                node_configuration[index] = pid;    /* save assignment to node_configuration */
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */
            }
            /* Frame Ids 0x3C..0x3F shall not be re-assigned [LIN spec] */
            else {
                status = ML_FAILURE;
            }
            
            if (ML_SUCCESS == status) {
#if defined(HAS_EVENT_TRIGGERED_FRAMES)
                /*
                 * For Associated Unconditional Frames put PID as a first
                 * byte in the data buffer
                 */
                if (ML_UNCOND_ASSOCIATED == frame_list[index].frame_type) {
                    ml_uint8 volatile *ptr = frame_list[index].dataBuffer;
                    *ptr = pid;
                }
#endif /* HAS_EVENT_TRIGGERED_FRAMES */
                return respPositiveAssignFID;
            }
            /* else : Assignment failed */
        }
        /* else : index is not found */ 
    }
    /* else: wrong SupplierID  */

    return respNoResponse;
}
#endif /* LIN_VERSION == 20 */

/*
 *************************************************************************************
 * readByIdentifier
 * 
 * Parses "Read by Identifier" frame (service 0xB2) and returns resulting slave
 * response.
 * Uses global LinFrameDataBuffer[] buffer
 *
 *  Frame structure:
 *  NAD, PCI, SID, Identifier, SupplierID_LSB, SupplierID_MSB, FunctionID_LSB, FunctionID_MSB
 *  [0]  [1]  [2]     [3]            [4]             [5]           [6]              [7]
 * 
 * Returns:
 *      Requested response or respNoResponse
 *************************************************************************************
 */
static SlaveResponse_t readByIdentifier (void)
{
    if (LinFrameDataBuffer[1] != 0x06U) /* if PCI is not valid .. */
    {
        return respNoResponse;
    }
    /* else: PCI is valid, continue processing .. */

    /* Validate SupplierID [4..5] and FunctionID [6..7] */
    if ( (isSupplierIdValid(&LinFrameDataBuffer[4]) == ML_SUCCESS) &&
         (isFunctionIdValid(&LinFrameDataBuffer[6]) == ML_SUCCESS) ) {  /* if supplier/function IDs are valid .. */

        switch (LinFrameDataBuffer[3]) {    /* check IDs ..  */
        case 0x00:                          /* ID: LIN Product Identification */
            return respLinProductID;
            break;                          /*lint !e527: unreachable because or the return above */

#if defined (HAS_SERIAL_NUMBER_CALLOUT)
        case 0x01:                          /* ID: Serial number (optional) */
            return respSerialNumber;
            break;                          /*lint !e527: unreachable because or the return above */
#endif /* HAS_SERIAL_NUMBER_CALLOUT */

        default:
#if defined (HAS_READ_BY_ID_CALLOUT)
            if ( (LinFrameDataBuffer[3] > 31U )&&(LinFrameDataBuffer[3] < 64U) )
            {
                /* read_by_id_callout, must be implemented by slave application */
                return (SlaveResponse_t)ld_read_by_id_callout (LinFrameDataBuffer[3], callout_user_data);
            }
            /* else : wrong ID */
#endif /* HAS_READ_BY_ID_CALLOUT */

            return respNegativeResponse;
            break;                          /*lint !e527: unreachable because or the return above */
        }
    }
    else { /* SupplierID or FunctionID are not matched */
        return respNoResponse;
    }
}

#if defined (HAS_CONDITIONAL_CHANGE_NAD_SERVICE)
/*
 *************************************************************************************
 * conditionalChangeNAD
 * 
 * Parses "Conditional change NAD" frame (service 0xB3) and returns resulting
 * slave response.
 * Uses global LinFrameDataBuffer[] buffer
 *
 *  Frame structure:
 *  NAD, PCI, SID, Identifier, Byte, Mask, Invert, New NAD
 *  [0]  [1]  [2]     [3]       [4]   [5]    [6]     [7]
 * 
 * Returns:
 *      Requested response or respNoResponse
 *************************************************************************************
 */
static SlaveResponse_t conditionalChangeNAD (void)
{
    if (LinFrameDataBuffer[1] == 0x06U)                 /* if PCI is valid .. */
    {
        uint8 data_bytes[4];

        /* Get the identifier of possible read by ID response and selected by Id
         * Extract the data byte selected by `Byte` (starts from 1)
         */
        switch (LinFrameDataBuffer[3]) /* Requested Id */
        {
            case 0x00:                                  /* ID: LIN Product Identification */
                if (   (LinFrameDataBuffer[4] == 0U)
                    || (LinFrameDataBuffer[4] > 5U))    /* if selected Byte is out of range [1..5] .. */
                {
                    return respNoResponse;              /* .. no response */
                }
                /* else: correct Byte selected, continue processing .. */

                data_bytes[0] = ml_ProductID[LinFrameDataBuffer[4] - 1U]; /* DataByte_1 is ml_ProductID[0] */
                break;

#if defined (HAS_SERIAL_NUMBER_CALLOUT)
            case 0x01:                                  /* ID: Serial number (optional) */
                if (   (LinFrameDataBuffer[4] == 0U)
                    || (LinFrameDataBuffer[4] > 4U))    /* if selected Byte is out of range [1..4] .. */
                {
                    return respNoResponse;              /* .. no response */
                }
                /* else: correct Byte selected, contimue processing .. */

                ld_serial_number_callout(data_bytes);
                data_bytes[0] = data_bytes[LinFrameDataBuffer[4] - 1U];
                break;
#endif /* HAS_SERIAL_NUMBER_CALLOUT */

            default:                                        /* Other IDs */
#if defined (HAS_READ_BY_ID_CALLOUT)
                if ( (LinFrameDataBuffer[3] > 31U )&&(LinFrameDataBuffer[3] < 64U) )  /* if ID is correct .. */
                {
                    l_u8 status;

                    if (   (LinFrameDataBuffer[4] == 0U)
                        || (LinFrameDataBuffer[4] > 5U))    /* if selected Byte is out of range [1..5] .. */
                    {
                        return respNoResponse;              /* no response */
                    }
                    /* else: correct Byte selected, continue processing .. */

                    status = ld_read_by_id_callout (LinFrameDataBuffer[3], callout_user_data);
                    if (status != LD_POSITIVE_RESPONSE)     /* if not a positive response .. */
                    {
                        return respNoResponse;
                    }
                    /* else: positive response expected */

                    data_bytes[0] = callout_user_data[LinFrameDataBuffer[4] - 1U];   /* Byte_1 corresponds to data[0] */
                }
                else /* Requested Id is not supported .. */
                {
                    return respNoResponse;
                }
#else
                return respNoResponse;
#endif /* HAS_READ_BY_ID_CALLOUT */
                break;      /*lint !e527: unreachable because or the return above */
        }

        data_bytes[0] ^= LinFrameDataBuffer[6];         /* do a bitwise XOR with Invert */
        data_bytes[0] &= LinFrameDataBuffer[5];         /* do a bitwise AND with Mask */

        if (data_bytes[0] == 0U)                        /* if condition PASSED .. */
        {
            ml_ResponseNAD = ml_ConfiguredNAD;          /* store old NAD for response [PLTF-351] */
            ml_ConfiguredNAD = LinFrameDataBuffer[7];   /* new NAD */
#if defined(HAS_SET_LOADER_NAD)
            (void)ml_SetLoaderNAD(ml_ConfiguredNAD);          /* notify the loader about application's NAD */
#endif /* HAS_SET_LOADER_NAD */

            return respConditionalChangeNAD;
        }
        /* else : condition FAILED => no response  */
    }
    /* else : PCI is not correct => no response */
    return respNoResponse;
}
#endif /* HAS_CONDITIONAL_CHANGE_NAD_SERVICE */


#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
/*
 ******************************************************************************
 * saveConfiguration
 *
 * corresponds to 0xB6 service ID, used by ml_DiagMasterRequest
 ******************************************************************************
 */

static SlaveResponse_t saveConfiguration (void)
{
    if (LinFrameDataBuffer[1] != 1U)    /* if PCI is not correct .. */
    {
        return respNoResponse;
    }
    /* else: PCI is correct, contiue processing .. */

    l_ifc_write_status_flags_i1(ML_IFC_SAVE_CONFIGURATION); 

    return respPositiveSaveConfig;
}
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */


#if LIN_VERSION >= 21
/*
 ******************************************************************************
 * assignFrameIDRange
 * 
 * The function corresponds to 0xB7 service ID, is used by ml_DiagMasterRequest
 *
 * various pid values:
 * 0xFF is used as do-not-care value, used to keep other assigned values of this frame.
 * 0x00 (non valid Protected ID) is used in this request to unassign FrameId
 * for this message [see LIN 2.1 spec, page 74]. Unassigned FrameId can be used
 * for other message then.
 *
 * MLX4 LIN FW does not remove message-to-FrameId association from internal
 * RAM (LIN_IDs array), but marks the message as disabled. 
 *
 ******************************************************************************
 */

static SlaveResponse_t assignFrameIdRange (void)
{
    /* wrong PCI */
    if (LinFrameDataBuffer[1] != 0x06U)
    {
        return respNoResponse;
    }

    /* invalid start index */
    if (LinFrameDataBuffer[3] >= ML_NUMBER_OF_DYNAMIC_MESSAGES)
    {
        return respNoResponse;
    }
    else 
    { 
        ml_uint8 *pid;
        ml_uint8 index;
        ml_uint8 i;


        index = LinFrameDataBuffer[3] + 3U; /* index of the last frame in the range */
        pid = &LinFrameDataBuffer[7];       /* PID of the last frame in the range */

        for (i = 0U; i < 4U; i++) {
            if (*pid != 0xFFU) {                                /* if id is NOT 0xFF .. */
                if (index >= ML_NUMBER_OF_DYNAMIC_MESSAGES) {   /* if wrong index for valid pid .. */
                    return respNoResponse;
                }
                else {                                          /* proper index */
                    (void)ml_Disconnect();
                    if (*pid == 0x00U) {                        /* unassign */
                        if (ml_DisableMessage(index) != 0U) {
                            (void)ml_Connect();
                            return respNoResponse;              /* failed to unassign */
                        }
                        /* else save unassignment to node_configuration */

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
                        node_configuration[index] = 0x00U;
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */
                    }
                    else {                                      /* assign */
                        if (ml_AssignFrameToMessageID(index,*pid) != 0U) {
                            (void)ml_Connect();
                            return respNoResponse; /* failed to assign */
                        }
                        /* else: assignment was OK, continue processing */

#if defined(HAS_SAVE_CONFIGURATION_SERVICE)
                        /* save assignment to node_configuration */
                        node_configuration[index] = *pid;
#endif /* HAS_SAVE_CONFIGURATION_SERVICE */

#if defined (HAS_EVENT_TRIGGERED_FRAMES)
                        /*
                         * For Associated Unconditional Frames put PID as a first
                         * byte in the data buffer
                         */
                        if (ML_UNCOND_ASSOCIATED == frame_list[index].frame_type) {
                            ml_uint8 volatile *ptr = frame_list[index].dataBuffer;
                            *ptr = *pid;
                        }
                        /* else: it was NOT an unconditional frame */
#endif /* HAS_EVENT_TRIGGERED_FRAMES */
                    } /* assign */

                    (void)ml_Connect();
                } /* proper index */
            }
            else {  /* id is 0xFF .. */
                    /* .. skip PID from processing */
            }

            --pid;          /*lint !e960 : deviation MISRA 2004:17.4 pointer decrement */
            --index;        /* get previous index */
        } /* for 4 pids */

        return respPositiveAssignFidRange;
    }
} /* assignFrameIdRange */
#endif /* LIN_VERSION >= 21 */


/* EOF */
